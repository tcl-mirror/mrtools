= Decoding ELF Format Files

== Introduction

This document describes a Tcl package named, *elfdecode*.
This document is also a literate program and contains both the
descriptive material as well as the source code for the package.
The *elfdecode* package is used to decode ELF files that contain program
executable information.
ELF is a common executable format used in Unix and Linux operating systems.

=== Scope
The primary use case for this package is to obtain symbolic information
about an executable.
The package does _not_ contain any capabilities to generate ELF files.
This package does not attempt to be comprehensive in the same way
that +libelf+ is.

== Representing an ELF File

The *elfdecode* package uses TclOO to represent the ELF file as an object.

(((classes,elffile)))

----
<<elffile class>>=
::oo::class create ::elfdecode::elffile {
    <<elffile methods>>
}
----

The design of this class is to decode the binary ELF data into internal
data structures which can then be used to query information about the
executable.

The following sections describe the methods available to *elffile* objects.

[float]
=== Exported Methods

(((elffile methods,exported,constructor)))

=== Constructor
The constructor for the +elffile+ class only performs initialization.
Other methods are used to read in the contents of an ELF file.
It does create some internal data structures that are used for subsequent
queries.
----
<<elffile methods>>=
constructor {} {
    set svcname ::elfdecode[self]
    ::logger::init $svcname
    ::logger::import -all -namespace log $svcname

    namespace import ::ral::*
    namespace import ::ralutil::*

    <<elffile data structures>>
}
----

.+elffile+ Variables
We hold the ELF data as a large string and use a variable to track
our +position+ in that string where binary decoding operations take place.
----
<<elffile data structures>>=
my variable elfdata
my variable position
----

The ELF format defines a set of data structures and, naturally enough,
the data used here mirror, but are not identical to, the one defined
in the ELF format specification

The ELF file starts with a header.
We hold the header as a +dict+ with the following keys:
+ei_class+,
+ei_data+,
+ei_version+,
+e_type+,
+e_machine+,
+e_version+,
+e_entry+,
+e_phoff+,
+e_shoff+,
+e_flags+,
+e_ehsize+,
+e_phentsize+,
+e_phnum+,
+e_shentsize+,
+e_shnum+ and
+e_shstrndx+.
The meaning of the keys is available from the ELF format specification.

The remainder of the ELF data is in the form of sections.
There are section headers, program headers and a symbol table.
Naming information is in the form of integer offsets into
a string table.
All the string information is collected into the string table.
Since the header information is very tabular oriented,
we define some TclRAL ++relvar++s to hold the headers.
The ++relvar++s are also convenient for query operations.

.ELF Section Header
----
<<elffile data structures>>=
relvar create ElfSecHeader {
    sh_index int
    sh_name string
    sh_type int
    sh_flags int
    sh_addr int
    sh_offset int
    sh_size int
    sh_link int
    sh_info int
    sh_addralign int
    sh_entsize int
} sh_index
----

Each section is described by ELF a section header.
The ELF section header attributes names are taken from the ELF format
specification.
The +sh_name+ attribute is the name of the section as a string and has
been resolved through the string table.

.ELF Program Header
----
<<elffile data structures>>=
relvar create ElfProgHeader {
    p_index int
    p_type int
    p_offset int
    p_vaddr int
    p_paddr int
    p_filesz int
    p_memsz int
    p_flags int
    p_align int
} p_index
----

The ELF program header describes how an executable is to be loaded
into memory.
The ELF program header attributes names are also taken from the specification.
Since we are not particularly concerned with running the program program
contained in the ELF file, we only parse the header.

.ELF Symbol Table
----
<<elffile data structures>>=
relvar create ElfSymbolTable {
    st_index int
    st_name string
    st_value int
    st_size int
    st_info int
    st_bind string
    st_type string
    st_other int
    st_shndx int
} st_index
----

Finally, the symbol table attribute names are also taken from the
specification.
The +st_name+ is a string table resolved name for the symbol.
Note also that symbol names are _not_ unique, only the index into the
symbol table is guaranteed to be unique.

(((elffile methods,exported,readFile)))

=== readFile
Several methods are provided to obtain the data from and ELF file.
The +readFile+ method will read the data directly from a named file.
----
<<elffile methods>>=
method readFile {fname} {
    set elfchan [::open $fname rb]
    try {
        return [my decodeData [chan read $elfchan]]
    } finally {
        chan close $elfchan
    }
}
----

(((elffile methods,exported,readChan)))

=== readChan
The +readChan+ method allow you to open a Tcl channel by some other means
and have it supply the ELF file data.
----
<<elffile methods>>=
method readChan {chan} {
    # Make sure we are in binary mode!
    chan configure $chan -translation binary
    return [my decodeData [chan read $chan]]
}
----

(((elffile methods,exported,decodeData)))

=== decodeData
And finally, the +decodeData+ method does the real work of sequencing the
decoding of the binary ELF data and building up the internal data structures.
----
<<elffile methods>>=
method decodeData {data} {
    my variable elfdata
    set elfdata $data
    my variable position
    set position 0
    my variable elfheader
    set elfheader [my ReadElfHeader]
    log::debug "ELF header = \"$elfheader\""
    dict with elfheader {
        my ReadSecHeaders $e_shoff $e_shnum $e_shentsize $e_shstrndx
        my ReadProgHeaders $e_phoff $e_phnum $e_phentsize
        my ReadSymTable
    }
    return $elfheader
}
----
After reading in the header,
the section headers, program headers and symbol table are
parsed out of the binary data.

(((elffile methods,exported,getSectionHeaderByName)))

=== getSectionHeaderByName
The +getSectionHeaderByName+ method returns a list of dictionaries of attributes
of the section header given by +name+.
ELF section names are not guaranteed to be unique only section indices are
unique.
So it is possible that the returned list has more than one element.
----
<<elffile methods>>=
method getSectionHeaderByName {name} {
    return [pipe {
        relvar set ElfSecHeader |
        relation restrictwith ~ {$sh_name eq $name} |
        relation body ~
    }]
}
----

(((elffile methods,exported,getSectionHeaderByIndex)))

=== getSectionHeaderByIndex
The +getSectionHeaderByIndex+ method returns a dictionary of the
attribute of the section header given by +index+.
ELF section header indices are unique.
----
<<elffile methods>>=
method getSectionHeaderByIndex {index} {
    set header [relvar restrictone ElfSecHeader sh_index $index]
    if {[relation isempty $header]} {
        error "no section header with index, \"$index\""
    }
    return [tuple get [relation tuple $headers]]
}
----

(((elffile methods,exported,foreachSectionHeader)))

=== foreachSectionHeader
The +foreachSectionHeader+ method provides a control structure that
iterates across each section header.
The +varname+ argument is the name of a variable to which a dictionary
value is assigned that contains a section heading.
The +script+ is then executed.
----
<<elffile methods>>=
method foreachSectionHeader {varname script} {
    upvar 1 $varname header
    foreach header [relation body [relvar set ElfSecHeader]] {
        uplevel 1 $script
    }
}
----

(((elffile methods,exported,getSectionDataByIndex)))

=== getSectionDataByIndex
The +getSectionData+ method returns a string containing the binary
information contained in the section given by +index+.
----
<<elffile methods>>=
method getSectionDataByIndex {index} {
    set header [my getSectionHeaderByIndex $index]
    my Seek [dict get $header sh_offset]
    return [my Read [dict get $header sh_size]]
}
----

(((elffile methods,exported,getSectionDataByName)))

=== getSectionDataByName
The +getSectionData+ method returns a string containing the binary
information contained in the section given by +name+.
If the section given by +name+ is not unique, then an error is thrown.
----
<<elffile methods>>=
method getSectionDataByName {name} {
    set headers [my getSectionHeaderByName $name]
    if {[llength $headers] != 1} {
        error "cannot find unique section named, \"$name\""
    }
    set header [lindex $headers 0]
    my Seek [dict get $header sh_offset]
    return [my Read [dict get $header sh_size]]
}
----

(((elffile methods,exported,getSymbol)))

=== getSymbolByName
The +getSymbolByName+ method returns a list of dictionaries of attributes
of the symbol given by +name+.
Since symbol names are not unique,
the returned list may have a length greater than one.
----
<<elffile methods>>=
method getSymbolByName {name} {
    return [pipe {
        relvar set ElfSymbolTable |
        relation restrictwith ~ {$st_name eq $name} |
        relation body ~
    }]
}
----

[float]
=== Unexported Methods

(((elffile methods,unexported,ReadElfHeader)))

=== ReadELFHeader
The +ReadELFHeader+ method reads the header that is the beginning of an
ELF file and converts the binary information into other data types.
It checks that the ELF identification is correct to insure that we are
actually dealing with an ELF formatted file.

Note that we limit ourselves to 32-bit ELF files that are little endian.
----
<<elffile methods>>=
method ReadElfHeader {} {
    # Read the 16 byte identifier field and make sure we are dealing
    # with an ELF file. The header is of a fixed 16 byte format.
    # We need to squirrel away the class and data type information
    # so we can distinguish between the various file types and byte orders.
    my variable ei_class ei_data
    my ConvertIdentifier\
        elfmag0 elfmagName ei_class ei_data ei_version ei_osabi\
        ei_abiversion ei_pad

    if {$elfmag0 != 0x7f || $elfmagName ne "ELF"} {
        error "bad ELF magic number, [format %#x $elfmag0] $elfmagName"
    }

    set ei_class [my XlateEnumValue ei_class $ei_class]
    set ei_data [my XlateEnumValue ei_data $ei_data]

    # Convert the remainder of the header.
    my Convert header\
        e_type e_machine e_version e_entry e_phoff e_shoff e_flags\
        e_ehsize e_phentsize e_phnum e_shentsize e_shnum e_shstrndx
    my Advance [expr {$e_ehsize -16}]

    set e_type [my XlateEnumValue e_type $e_type]

    # At this point we know we have a good ELF file.
    return [dict create\
        ei_class $ei_class\
        ei_data $ei_data\
        ei_version $ei_version\
        ei_osabi $ei_osabi\
        ei_abiversion $ei_abiversion\
        e_type $e_type\
        e_machine $e_machine\
        e_version $e_version\
        e_entry $e_entry\
        e_phoff $e_phoff\
        e_shoff $e_shoff\
        e_flags $e_flags\
        e_ehsize $e_ehsize\
        e_phentsize $e_phentsize\
        e_phnum $e_phnum\
        e_shentsize $e_shentsize\
        e_shnum $e_shnum\
        e_shstrndx $e_shstrndx\
    ]
}
----

(((elffile methods,unexported,ReadSecHeaders)))

=== ReadSecHeaders
----
<<elffile methods>>=
method ReadSecHeaders {e_shoff e_shnum e_shentsize e_shstrndx} {
    if {$e_shnum == 0} {
        return
    }
    # Seek to where the section header table is located.
    my Seek $e_shoff

    set sectuples [list]
    # Read and convert the entire array of section headers.
    for {set secNo 0} {$secNo < $e_shnum} {incr secNo} {
        my Convert section\
                sh_name sh_type sh_flags sh_addr sh_offset\
                sh_size sh_link sh_info sh_addralign sh_entsize

        # The first entry in the section header has a type of 0 and
        # does not contain any useful information.
        if {$sh_type == 0} {
            continue
        }
        set secheader [list\
            sh_index        $secNo\
            sh_name         $sh_name\
            sh_type         $sh_type\
            sh_flags        $sh_flags\
            sh_addr         $sh_addr\
            sh_offset       $sh_offset\
            sh_size         $sh_size\
            sh_link         $sh_link\
            sh_info         $sh_info\
            sh_addralign    $sh_addralign\
            sh_entsize      $sh_entsize\
        ]
        log::debug "section header: $secheader"
        lappend sectuples $secheader
    }
    set sections [relation create {
        sh_index int
        sh_name int
        sh_type int
        sh_flags int
        sh_addr int
        sh_offset int
        sh_size int
        sh_link int
        sh_info int
        sh_addralign int
        sh_entsize int
    } {*}$sectuples]
    log::info \n[relformat $sections sections]

    # Now we want to update the information stored with the section
    # headers to replace the string index used as the name with
    # a real string that is the section name.
    set shstrsec [relation restrictwith $sections\
            {$sh_index == $e_shstrndx}]
    if {[relation isnotempty $shstrsec]} {
        relation assign $shstrsec sh_type sh_offset sh_size
        if {$sh_type == 3} {
            set shnames [my ReadStringTable $sh_offset $sh_size]
            #log::info \n[relformat $shnames SectionNames]
            relvar set ElfSecHeader [pipe {
                relation join $sections $shnames -using {sh_name st_index} |
                relation eliminate ~ sh_name |
                relation rename ~ st_string sh_name
            }]
        }
    }
    log::info \n[relformat [relvar set ElfSecHeader] ElfSecHeader]
}
----

(((elffile methods,unexported,ReadProgHeaders)))

=== ReadProgHeaders
----
<<elffile methods>>=
method ReadProgHeaders {e_phoff e_phnum e_phentsize} {
    if {$e_phnum == 0} {
        return
    }
    # Seek to where the section header table is
    my Seek $e_phoff

    for {set phNo 0} {$phNo < $e_phnum} {incr phNo} {
        my Convert prog\
                p_type p_offset p_vaddr p_paddr\
                p_filesz p_memsz p_flags p_align

        relvar insert ElfProgHeader [list\
            p_index     $phNo\
            p_type      $p_type\
            p_offset    $p_offset\
            p_vaddr     $p_vaddr\
            p_paddr     $p_paddr\
            p_filesz    $p_filesz\
            p_memsz     $p_memsz\
            p_flags     $p_flags\
            p_align     $p_align\
        ]
    }
    log::info \n[relformat [relvar set ElfProgHeader] ElfProgHeader]
}
----

(((elffile methods,unexported,ReadStringTable)))

=== ReadStringTable
----
<<elffile methods>>=
method ReadStringTable {sh_offset sh_size} {
    # seek to the file location
    my Seek $sh_offset
    set strings [my Read $sh_size]
    set strOff 0
    # The strings are just packed NUL terminated ASCII strings.
    # Just split on the NUL character to unbundle the them.
    set tuples [list]
    foreach s [split $strings "\0"] {
        if {[string length $s] != 0} {
            lappend tuples [list st_index $strOff st_string $s]
        }
        incr strOff [expr {[string length $s] + 1}]
    }

    return [relation create {st_index int st_string string} {*}$tuples]
}
----

(((elffile methods,unexported,ReadSymbolTable)))

=== ReadSymbolTable
----
<<elffile methods>>=
method ReadSymTable {} {
    log::debug [info level 0]
    set symsecs [my getSectionHeaderByName .symtab]
    if {[llength $symsecs] != 1} {
        log::info "cannot find symbol table section named, \".symtab\""
        return
    }
    set symheader [lindex $symsecs 0]
    dict with symheader {
        if {$sh_type != 2} {
            error "expected symbol table section type of \"2\",\
                    got \"$sh_type\""
        }
        if {$sh_entsize == 0} {
            error "expected non-zero symbol table entry size,\
                    got \"$sh_entsize\""
        }
        my Seek $sh_offset
        set symtuples [list]
        set nSyms [expr {$sh_size / $sh_entsize}]
        my variable ei_class
        for {set symindex 0} {$symindex < $nSyms} {incr symindex} {
            set sym [expr {$ei_class eq "ELFCLASS32" ?\
                [my ReadElf32Sym] : [my ReadElf64Sym]}]
            my Advance $sh_entsize
            if {[dict size $sym] == 0} {
                log::info "discarding unnamed symbol table entry, \"$symindex\""
                continue
            }
            dict set sym st_index $symindex
            lappend symtuples $sym
        }
        # Create a relation with the symbol information.
        set syms [relation create {
            st_index int
            st_nindex int
            st_value int
            st_size int
            st_info int
            st_bind string
            st_type string
            st_other int
            st_shndx int} {*}$symtuples]
        log::debug \n[relformat $syms syms]
        # Now we want to read the string table and resolve the index
        # values into actual names.
        # First, find the string table.
        set strsecs [my getSectionHeaderByName .strtab]
        if {[llength $strsecs] != 1} {
            log::info "cannot find string table section named, \".strtab\""
            return
        }
        set strheader [lindex $strsecs 0]
        dict with strheader {
            if {$sh_type != 3} {
                error "expected symbol table section type of \"3\",\
                        got \"$sh_type\""
            }
            if {$sh_entsize != 0} {
                error "expected zero string table entry size,\
                        got \"$sh_entsize\""
            }
            set symnames [my ReadStringTable $sh_offset $sh_size]
        }
    }
    relvar set ElfSymbolTable [pipe {
        relation join $syms $symnames -using {st_nindex st_index} |
        relation eliminate ~ st_nindex |
        relation rename ~ st_string st_name
    }]
    log::info \n[relformat [relvar set ElfSymbolTable] ElfSymbolTable]
    return
}
----

----
<<elffile methods>>=
method ReadElf32Sym {} {
    my Convert symbol st_index st_value st_size st_info st_other st_shndx
    # The "zero" string index is undefined and implies the symbol
    # has not name. We discard those.
    if {$st_index == 0} {
        return
    }
    set st_bind [expr {$st_info >> 4}]
    set st_type [expr {$st_info & 0xf}]
    return [list\
        st_nindex   $st_index\
        st_value    $st_value\
        st_size     $st_size\
        st_info     $st_info\
        st_bind     $st_bind\
        st_type     $st_type\
        st_other    $st_other\
        st_shndx    $st_shndx\
    ]
}
----

----
<<elffile methods>>=
method ReadElf64Sym {} {
    my Convert symbol st_index st_info st_other st_shndx st_value st_size
    # The "zero" string index is undefined and implies the symbol
    # has not name. We discard those.
    if {$st_index == 0} {
        return
    }
    set st_bind [expr {$st_info >> 4}]
    set st_type [expr {$st_info & 0xf}]
    return [list\
        st_nindex   $st_index\
        st_value    $st_value\
        st_size     $st_size\
        st_info     $st_info\
        st_bind     $st_bind\
        st_type     $st_type\
        st_other    $st_other\
        st_shndx    $st_shndx\
    ]
}
----

(((elffile methods,unexported,Seek)))

=== Seek
----
<<elffile methods>>=
method Seek {offset} {
    my variable elfdata position

    if {$offset < 0} {
        set position 0
    } elseif {$offset > [string length $elfdata]} {
        set position [string length $elfdata]
    } else {
        set position $offset
    }
    #log::debug "seek to $position"
}
----

(((elffile methods,unexported,Advance)))

=== Advance
----
<<elffile methods>>=
method Advance {offset} {
    my variable elfdata
    my variable position
    set newpos [expr {$position + $offset}]

    if {$newpos < 0} {
        set position 0
    } elseif {$newpos > [string length $elfdata]} {
        set position [string length $elfdata]
    } else {
        set position $newpos
    }
    #log::debug "advance to $position"
}
----

(((elffile methods,unexported,Read)))

=== Read
----
<<elffile methods>>=
method Read {count} {
    my variable elfdata
    my variable position

    set end [expr {$position + $count - 1}]
    if {$end >= [string length $elfdata]} {
        error "attempt to read beyond end of ELF data"
    }
    set data [string range $elfdata $position $end]
    set position [expr {$end + 1}]
    return $data
}
----

=== Conversion Specification
In order to support both 64 bit and 32 bit ELF files and both little
endian and big endian formats,
we need different binary conversion specification strings.
We will define some class data and class based methods to obtain the
proper format information.
We will organize the format specifiers by name with variations
for 32 / 64 bits and for little / big endian.
Class methods then provide a means to lookup the proper format specifier.

----
<<elffile class data>>=
namespace eval [info object namespace ::elfdecode::elffile] {
    namespace import ::ral::*
    namespace import ::ralutil::*

    <<elffile data definitions>>
}
----

----
<<elffile data definitions>>=
relvar create FormatSpec {
    Name        string
    Class       string
    DataType    string
    Format      string
    Size        int
} {Name Class DataType}

relvar insert FormatSpec {
    Name        header
    Class       ELFCLASS32
    DataType    ELFDATA2LSB
    Format      {su su iu iu iu iu iu su su su su su su}
    Size        0
} {
    Name        header
    Class       ELFCLASS32
    DataType    ELFDATA2MSB
    Format      {Su Su Iu Iu Iu Iu Iu Su Su Su Su Su Su}
    Size        0
} {
    Name        header
    Class       ELFCLASS64
    DataType    ELFDATA2LSB
    Format      {su su iu wu wu wu iu su su su su su su}
    Size        0
} {
    Name        header
    Class       ELFCLASS64
    DataType    ELFDATA2MSB
    Format      {Su Su Iu Wu Wu Wu Iu Su Su Su Su Su Su}
    Size        0
} {
    Name        section
    Class       ELFCLASS32
    DataType    ELFDATA2LSB
    Format      {iu iu iu iu iu iu iu iu iu iu}
    Size        40
} {
    Name        section
    Class       ELFCLASS32
    DataType    ELFDATA2MSB
    Format      {Iu Iu Iu Iu Iu Iu Iu Iu Iu Iu}
    Size        40
} {
    Name        section
    Class       ELFCLASS64
    DataType    ELFDATA2LSB
    Format      {iu iu wu wu wu wu iu iu wu wu}
    Size        64
} {
    Name        section
    Class       ELFCLASS64
    DataType    ELFDATA2MSB
    Format      {Iu Iu Wu Wu Wu Wu Iu Iu Wu Wu}
    Size        64
} {
    Name        prog
    Class       ELFCLASS32
    DataType    ELFDATA2LSB
    Format      {iu iu iu iu iu iu iu iu}
    Size        32
} {
    Name        prog
    Class       ELFCLASS32
    DataType    ELFDATA2MSB
    Format      {Iu Iu Iu Iu Iu Iu Iu Iu}
    Size        32
} {
    Name        prog
    Class       ELFCLASS64
    DataType    ELFDATA2LSB
    Format      {iu iu wu wu wu wu wu wu}
    Size        56
} {
    Name        prog
    Class       ELFCLASS64
    DataType    ELFDATA2MSB
    Format      {Iu Iu Wu Wu Wu Wu Wu Wu}
    Size        56
} {
    Name        symbol
    Class       ELFCLASS32
    DataType    ELFDATA2LSB
    Format      {iu iu iu cu cu su}
    Size        0
} {
    Name        symbol
    Class       ELFCLASS32
    DataType    ELFDATA2MSB
    Format      {Iu Iu Iu cu cu Su}
    Size        0
} {
    Name        symbol
    Class       ELFCLASS64
    DataType    ELFDATA2LSB
    Format      {iu cu cu su wu wu}
    Size        0
} {
    Name        symbol
    Class       ELFCLASS64
    DataType    ELFDATA2MSB
    Format      {Iu cu cu Su Wu Wu}
    Size        0
}
----

----
<<elffile class methods>>=
::oo::objdefine ::elfdecode::elffile method findFormat {name class datatype} {
    set fmt [relvar restrictone FormatSpec Name $name Class $class\
            DataType $datatype]
    if {[relation isempty $fmt]} {
        error "unknown format specification, \"$name $class $datatype\""
    }
    return [tuple get [relation tuple $fmt]]
}
----

(((elffile methods,unexported,Convert)))

=== Convert
The *Convert* method is a simple control structure wrapper around
the *binary scan* command.
Here we perform the conversion into variables that are passed by name.
This gives us a chance to check that the conversion did indeed happen properly.

----
<<elffile methods>>=
method Convert {fmtname args} {
    my variable ei_class ei_data
    set fmtrel [relvar restrictone [classns]::FormatSpec\
        Name        $fmtname\
        Class       $ei_class\
        DataType    $ei_data\
    ]
    if {[relation isempty $fmtrel]} {
        error "cannot find format specification,\
                \"$fmtname $ei_class $ei_data\""
    }
    my Scan [relation extract $fmtrel Format] $args
    my Advance [relation extract $fmtrel Size]
}
----

----
<<elffile methods>>=
method ConvertIdentifier {args} {
    my Scan {cu a3 cu cu cu cu cu cu7} $args
    my Advance 16
}
----

----
<<elffile methods>>=
method Scan {fmt arglist} {
    my variable elfdata
    my variable position

    foreach arg $arglist {
        upvar 2 $arg $arg
    }
    set cvtd [binary scan $elfdata "@$position $fmt" {*}$arglist]
    if {$cvtd != [llength $arglist]} {
        error "expected to convert \"[llength $arglist]\" values,\
            actually converted \"$cvtd\""
    }
}
----

== Enumerated Values
Since Tcl encourages the use of strings,
there are several conversions from binary that are best represented
as string data.
This is data such as enumerated values that is better consumed as strings
and is defined by the ELF format.
The data consists of a set of constant values and so we define them
directly into the namespace of the class.
It is often the case that these values have both a fixed set of enumerator
plus allowances for vendors and operating systems to include specific
values.
The decoding of these specific values is determined by the generator of
the ELF file, but they must fall within a given numeric range.
Here we define some data structures that can be used to decode
this type of symbolic information.
----
<<elffile data definitions>>=
relvar create ELFEnumerator {
    SymbolType  string
    Enumerator  string
    Value       int
} {SymbolType Enumerator} {SymbolType Value}

relvar create ELFEnumRange {
    SymbolType  string
    Enumerator  string
    LowValue    int
    HighValue   int
} {SymbolType Enumerator} {SymbolType LowValue}
----

----
<<elffile methods>>=
method XlateEnumValue {symtype etor} {
    set enum [relvar restrictone [classns]::ELFEnumerator\
            SymbolType $symtype Value $etor]
    if {[relation isnotempty $enum]} {
        return [relation extract $enum Enumerator]
    }
    set range [pipe {
        relvar set [classns]::ELFEnumRange |
        relation restrictwith ~ {
            $SymbolType eq $symtype && $LowValue >= $etor &&\
            $etor <= $HighValue}
    }]
    if {[relation isnotempty $range]} {
        relation assign $range Enumerator LowValue
        return $Enumerator\[[expr {$etor - $LowValue}]\]
    } else {
        error "unknown ELF symbol type, \"$symtype\""
    }
}
----

=== Class Data
----
<<elffile data definitions>>=
relvar insert ELFEnumerator {
    SymbolType  ei_class
    Enumerator  ELFCLASS32
    Value       1
} {
    SymbolType  ei_class
    Enumerator  ELFCLASS64
    Value       2
} {
    SymbolType  ei_data
    Enumerator  ELFDATA2LSB
    Value       1
} {
    SymbolType  ei_data
    Enumerator  ELFDATA2MSB
    Value       2
}
----

=== Object File Types
----
<<elffile data definitions>>=
relvar insert ELFEnumerator {
    SymbolType  e_type
    Enumerator  ET_NONE
    Value       0
} {
    SymbolType  e_type
    Enumerator  ET_REL
    Value       1
} {
    SymbolType  e_type
    Enumerator  ET_EXEC
    Value       2
} {
    SymbolType  e_type
    Enumerator  ET_DYN
    Value       3
} {
    SymbolType  e_type
    Enumerator  ET_CORE
    Value       4
}

relvar insert ELFEnumRange {
    SymbolType  e_type
    Enumerator  ET_LOOS
    LowValue    0xfe00
    HighValue   0xfeff
} {
    SymbolType  e_type
    Enumerator  ET_LOPROC
    LowValue    0xff00
    HighValue   0xffff
}
----

== Code Organization

Describe

----
<<elfdecode.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2013 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require oo::util
package require logger
package require ral
package require ralutil

namespace eval ::elfdecode {
    namespace export elffile
    namespace ensemble create

    logger::initNamespace [namespace current]

    variable version 1.0
}

proc ::oo::Helpers::classns {} {
    return [info object namespace [uplevel 1 {self class}]]
}

<<elffile class>>

<<elffile class data>>
<<elffile class methods>>

package provide elfdecode $::elfdecode::version
----
