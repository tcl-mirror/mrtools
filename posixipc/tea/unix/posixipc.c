/*
#
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
*/

/*
# This software is copyrighted 2018 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
*/

/*
 * Include Files
 */
#define _POSIX_C_SOURCE 201112L

#include "tcl.h"
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <ctype.h>
#include <string.h>
#include <mqueue.h>
#include <semaphore.h>

/*
 * Macros
 */
#ifndef COUNTOF
#define COUNTOF(a)      (sizeof(a) / sizeof(a[0]))
#endif /* COUNTOF */
#define NS_SEP          "::"

#define PACKAGE_NS      NS_SEP PACKAGE_NAME
#define CMD_NS(n)       PACKAGE_NS NS_SEP #n

#define MQ_NS           CMD_NS(mq)
#define MQ_SUBCMD(c)    MQ_NS NS_SEP #c

#define SHM_NS          CMD_NS(shm)
#define SHM_SUBCMD(c)   SHM_NS NS_SEP #c

/*
 * Data Types
 */
struct fopenModeDes {
    char const *modeName ;          // <1>
    int oFlags ;                    // <2>
    int tclMask ;                   // <3>
    bool isBinary ;                 // <4>
} ;
struct openFlagDes {
    char const *modeName ;          // <1>
    int oFlags ;                    // <2>
    int tclMask ;                   // <3>
    bool isBinary ;                 // <4>
    bool isAccessMode ;             // <5>
} ;
typedef struct {
    Tcl_Channel channel ;       // <1>
    mqd_t mqdes ;               // <2>
    int tclMask ;               // <3>
    unsigned lastpriority ;     // <4>
    unsigned defpriority ;      // <5>
} MqState ;
typedef enum {
    Mq_curmsgs_opt = 0,
    Mq_lastpriority_opt,
    Mq_maxmsg_opt,
    Mq_msgsize_opt,
    Mq_priority_opt,

    Mq_OPTION_COUNT             // must be last
} MqOptionType ;
typedef struct {
    Tcl_Channel channel ;       // <1>
    int shmfd ;                 // <2>
    sem_t *semaphore ;          // <3>
    int tclMask ;               // <4>
    int blockingMode ;          // <5>
    uint8_t *address ;          // <6>
    size_t length ;             // <7>
    size_t position ;           // <8>
} ShmState ;

/*
 * Forward References
 */
static int processFopenModeOption(Tcl_Interp *interp, char const *const mode,
        int *flags, int *mask, bool *binary) ;
static int fopenModeCompare(void const *m1, void const *m2) ;
static int processOpenModeOption(Tcl_Interp *interp, char const *const mode,
        int *flags, int *mask, bool *binary) ;
static int mqBlockModeProc(ClientData instanceData, int mode) ;
static int mqCloseProc(ClientData instanceData, Tcl_Interp *interp) ;
static int mqInputProc(ClientData instanceData, char *buf, int bufSize,
        int *errorCodePtr) ;
static int mqOutputProc(ClientData instanceData, char const *buf, int toWrite,
        int *errorCodePtr) ;
static struct MqConfigOpt const *lookUpMqOpt(char const *optionName) ;
static int mqOptCompare(void const *m1, void const *m2) ;
static int mqGetOptionProc(ClientData instanceData, Tcl_Interp *interp,
        char const *optionName, Tcl_DString *optionValue) ;
static int ipcFailure(Tcl_Interp *interp, char const *type, char const *msg) ;
static int mqFailure(Tcl_Interp *interp, char const *msg) ;
static int mqSetOptionProc(ClientData instanceData, Tcl_Interp *interp,
        char const *optionName, char const *newValue) ;
static void mqWatchProc(ClientData instanceData, int mask) ;
static int mqGetHandleProc(ClientData instanceData, int direction,
        ClientData *handlePtr) ;
static int openFlagCompare(void const *m1, void const *m2) ;
static int mqOpenCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
static int mqSendCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
static int mqReceiveCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
static int mqUnlinkCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
static int shmCloseProc(ClientData instanceData, Tcl_Interp *interp) ;
static int shmInputProc(ClientData instanceData, char *buf, int bufSize,
        int *errorCodePtr) ;
static int shmOutputProc(ClientData instanceData, char const *buf, int toWrite,
        int *errorCodePtr) ;
static int shmSeekProc(ClientData instanceData, long offset, int seekMode,
        int *errorCodePtr) ;
static void shmWatchProc(ClientData instanceData, int mask) ;
static int shmGetHandleProc(ClientData instanceData, int direction,
        ClientData *handlePtr) ;
static int shmBlockModeProc(ClientData instanceData, int mode) ;
static int shmFailure(Tcl_Interp *interp, char const *msg) ;
static int shmOpenCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
static int shmUnlinkCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;

/*
 * Static Data
 */
static Tcl_ChannelType MqChannelType = {
    .typeName = "mq",           /* The name of the channel type in Tcl
                                 * commands. This storage is owned by channel
                                 * type. */
    .version = TCL_CHANNEL_VERSION_5,
                                /* Version of the channel type. */
    .closeProc = mqCloseProc,
                                /* Function to call to close the channel, or
                                 * TCL_CLOSE2PROC if the close2Proc should be
                                 * used instead. */
    .inputProc = mqInputProc,
                                /* Function to call for input on channel. */
    .outputProc = mqOutputProc,
                                /* Function to call for output on channel. */
    .seekProc = NULL,
                                /* Function to call to seek on the channel.
                                 * May be NULL. */
    .setOptionProc = mqSetOptionProc,
                                /* Set an option on a channel. */
    .getOptionProc = mqGetOptionProc,
                                /* Get an option from a channel. */
    .watchProc = mqWatchProc,
                                /* Set up the notifier to watch for events on
                                 * this channel. */
    .getHandleProc = mqGetHandleProc,
                                /* Get an OS handle from the channel or NULL
                                 * if not supported. */
    .close2Proc = NULL,
                                /* Function to call to close the channel if
                                 * the device supports closing the read &
                                 * write sides independently. */
    .blockModeProc = mqBlockModeProc,
                                /* Set blocking mode for the raw channel. May
                                 * be NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_2 channels or later
     */
    .flushProc = NULL,
                                /* Function to call to flush a channel. May be
                                 * NULL. */
    .handlerProc = NULL,
                                /* Function to call to handle a channel event.
                                 * This will be passed up the stacked channel
                                 * chain. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_3 channels or later
     */
    .wideSeekProc = NULL,
                                /* Function to call to seek on the channel
                                 * which can handle 64-bit offsets. May be
                                 * NULL, and must be NULL if seekProc is
                                 * NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_4 channels or later
     * TIP #218, Channel Thread Actions
     */
    .threadActionProc = NULL,
                                /* Function to call to notify the driver of
                                 * thread specific activity for a channel. May
                                 * be NULL. */

    /*
     * Only valid in TCL_CHANNEL_VERSION_5 channels or later
     * TIP #208, File Truncation
     */
    .truncateProc = NULL
                                /* Function to call to truncate the underlying
                                 * file to a particular length. May be NULL if
                                 * the channel does not support truncation. */
} ;
struct MqConfigOpt {
    char const *optName ;
    bool setOnOpen ;
    bool setOnConfig ;
} const mqOptions[Mq_OPTION_COUNT] = {  // Ordered by ascending option name!
    [Mq_curmsgs_opt] = {
        .optName = "-curmsgs",
        .setOnOpen = false,
        .setOnConfig = false,
    },
    [Mq_lastpriority_opt] = {
        .optName = "-lastpriority",
        .setOnOpen = false,
        .setOnConfig = false,
    },
    [Mq_maxmsg_opt] = {
        .optName = "-maxmsg",
        .setOnOpen = true,
        .setOnConfig = false,
    },
    [Mq_msgsize_opt] = {
        .optName = "-msgsize",
        .setOnOpen = true,
        .setOnConfig = false,
    },
    [Mq_priority_opt] = {
        .optName = "-priority",
        .setOnOpen = true,
        .setOnConfig = true,
    },
} ;
static char const mqOptionsList[] =
        "curmsgs lastpriority maxmsg msgsize priority" ;
static Tcl_ChannelType ShmChannelType = {
    .typeName = "shm",          /* The name of the channel type in Tcl
                                 * commands. This storage is owned by channel
                                 * type. */
    .version = TCL_CHANNEL_VERSION_5,
                                /* Version of the channel type. */
    .closeProc = shmCloseProc,
                                /* Function to call to close the channel, or
                                 * TCL_CLOSE2PROC if the close2Proc should be
                                 * used instead. */
    .inputProc = shmInputProc,
                                /* Function to call for input on channel. */
    .outputProc = shmOutputProc,
                                /* Function to call for output on channel. */
    .seekProc = shmSeekProc,
                                /* Function to call to seek on the channel.
                                 * May be NULL. */
    .setOptionProc = NULL,
                                /* Set an option on a channel. */
    .getOptionProc = NULL,
                                /* Get an option from a channel. */
    .watchProc = shmWatchProc,
                                /* Set up the notifier to watch for events on
                                 * this channel. */
    .getHandleProc = shmGetHandleProc,
                                /* Get an OS handle from the channel or NULL
                                 * if not supported. */
    .close2Proc = NULL,
                                /* Function to call to close the channel if
                                 * the device supports closing the read &
                                 * write sides independently. */
    .blockModeProc = shmBlockModeProc,
                                /* Set blocking mode for the raw channel. May
                                 * be NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_2 channels or later
     */
    .flushProc = NULL,
                                /* Function to call to flush a channel. May be
                                 * NULL. */
    .handlerProc = NULL,
                                /* Function to call to handle a channel event.
                                 * This will be passed up the stacked channel
                                 * chain. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_3 channels or later
     */
    .wideSeekProc = NULL,
                                /* Function to call to seek on the channel
                                 * which can handle 64-bit offsets. May be
                                 * NULL, and must be NULL if seekProc is
                                 * NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_4 channels or later
     * TIP #218, Channel Thread Actions
     */
    .threadActionProc = NULL,
                                /* Function to call to notify the driver of
                                 * thread specific activity for a channel. May
                                 * be NULL. */

    /*
     * Only valid in TCL_CHANNEL_VERSION_5 channels or later
     * TIP #208, File Truncation
     */
    .truncateProc = NULL
                                /* Function to call to truncate the underlying
                                 * file to a particular length. May be NULL if
                                 * the channel does not support truncation. */
} ;

/*
 * External Functions
 */
int
Posixipc_Init(
    Tcl_Interp *interp)
{
#       ifdef USE_TCL_STUBS
    /*
     * Stubs have to be initialized first.
     */
    if (Tcl_InitStubs(interp, TCL_VERSION, 0) == NULL) {
        return TCL_ERROR ;
    }
#       endif /* USE_TCL_STUBS */
    /*
     * Create all the commands for the package.
     */
    static char const pkgNamespace[] = PACKAGE_NS ;     // <1>
    Tcl_Namespace *ipcNs = Tcl_CreateNamespace(interp, pkgNamespace, NULL, NULL) ;
    
    Tcl_Obj *ipcMap = Tcl_NewDictObj() ;                // <2>
    static char const mqNsName[] = MQ_NS ;
    static char const mqStr[] = "mq" ;
    /*
     * Create the namespace in which the sub-command resides.
     */
    Tcl_Namespace *mqNs = Tcl_CreateNamespace(interp, mqNsName, NULL, NULL) ;
    /*
     * Create the ensemble mapping dictionary.
     */
    Tcl_Obj *mqMap = Tcl_NewDictObj() ;
    
    static char const mqOpenCmdName[] = MQ_SUBCMD(open) ;
    static char const openStr[] = "open" ;
    
    Tcl_CreateObjCommand(interp, mqOpenCmdName, mqOpenCmd, NULL, NULL) ;    // <1>
    if (Tcl_DictObjPut(interp, mqMap, Tcl_NewStringObj(openStr, -1),
            Tcl_NewStringObj(mqOpenCmdName, -1)) != TCL_OK) {
        goto release_mq ;                                                      // <2>
    }
    static char const mqSendCmdName[] = MQ_SUBCMD(send) ;
    static char const sendStr[] = "send" ;
    
    Tcl_CreateObjCommand(interp, mqSendCmdName, mqSendCmd, NULL, NULL) ;
    if (Tcl_DictObjPut(interp, mqMap, Tcl_NewStringObj(sendStr, -1),
            Tcl_NewStringObj(mqSendCmdName, -1)) != TCL_OK) {
        goto release_mq ;
    }
    static char const mqRecvCmdName[] = MQ_SUBCMD(receive) ;
    static char const recvStr[] = "receive" ;
    
    Tcl_CreateObjCommand(interp, mqRecvCmdName, mqReceiveCmd, NULL, NULL) ;
    if (Tcl_DictObjPut(interp, mqMap, Tcl_NewStringObj(recvStr, -1),
            Tcl_NewStringObj(mqRecvCmdName, -1)) != TCL_OK) {
        goto release_mq ;
    }
    static char const mqUnlinkCmdName[] = MQ_SUBCMD(unlink) ;
    static char const unlinkStr[] = "unlink" ;
    
    Tcl_CreateObjCommand(interp, mqUnlinkCmdName, mqUnlinkCmd, NULL, NULL) ;
    if (Tcl_DictObjPut(interp, mqMap, Tcl_NewStringObj(unlinkStr, -1),
            Tcl_NewStringObj(mqUnlinkCmdName, -1)) != TCL_OK) {
        goto release_mq ;
    }
    
    /*
     * Create an ensemble command on the mq namespace.
     */
    Tcl_Command mqEnsembleToken = Tcl_CreateEnsemble(interp, mqNsName, mqNs, 0) ;
    if (Tcl_SetEnsembleMappingDict(interp, mqEnsembleToken, mqMap) != TCL_OK) {
        goto release_mq ;
    }
    /*
     * Export the newly created ensemble command.
     */
    if (Tcl_Export(interp, ipcNs, mqStr, 0) != TCL_OK) {
        goto release_ipc ;
    }
    /*
     * Add the mq ensemble command to the mapping for the posixipc command.
     */
    if (Tcl_DictObjPut(interp, ipcMap, Tcl_NewStringObj(mqStr, -1),
            Tcl_NewStringObj(mqNsName, -1)) != TCL_OK) {
        goto release_ipc ;
    }
    static char const shmNsName[] = SHM_NS ;
    static char const shmStr[] = "shm" ;
    Tcl_Namespace *shmNs = Tcl_CreateNamespace(interp, shmNsName, NULL, NULL) ;
    
    Tcl_Obj *shmMap = Tcl_NewDictObj() ;
    
    static char const shmOpenCmdName[] = SHM_SUBCMD(open) ;
    
    Tcl_CreateObjCommand(interp, shmOpenCmdName, shmOpenCmd, NULL, NULL) ;
    if (Tcl_Export(interp, shmNs, openStr, 0) != TCL_OK) {
        goto release_shm ;
    }
    if (Tcl_DictObjPut(interp, shmMap, Tcl_NewStringObj(openStr, -1),
            Tcl_NewStringObj(shmOpenCmdName, -1)) != TCL_OK) {
        goto release_shm ;
    }
    static char const shmUnlinkCmdName[] = SHM_SUBCMD(unlink) ;
    
    Tcl_CreateObjCommand(interp, shmUnlinkCmdName, shmUnlinkCmd, NULL, NULL) ;
    if (Tcl_Export(interp, shmNs, unlinkStr, 0) != TCL_OK) {
        goto release_shm ;
    }
    if (Tcl_DictObjPut(interp, shmMap, Tcl_NewStringObj(unlinkStr, -1),
            Tcl_NewStringObj(shmUnlinkCmdName, -1)) != TCL_OK) {
        goto release_shm ;
    }
    
    Tcl_Command shmEnsembleToken = Tcl_CreateEnsemble(interp, shmNsName, shmNs, 0) ;
    if (Tcl_SetEnsembleMappingDict(interp, shmEnsembleToken, shmMap) != TCL_OK) {
        goto release_shm ;
    }
    if (Tcl_Export(interp, ipcNs, shmStr, 0) != TCL_OK) {
        goto release_ipc ;
    }
    if (Tcl_DictObjPut(interp, ipcMap, Tcl_NewStringObj(shmStr, -1),
            Tcl_NewStringObj(shmNsName, -1)) != TCL_OK) {
        goto release_ipc ;
    }
    Tcl_Command ipcCmdToken = Tcl_CreateEnsemble(interp, pkgNamespace, ipcNs, 0) ;
    if (Tcl_SetEnsembleMappingDict(interp, ipcCmdToken, ipcMap) != TCL_OK) {
        goto release_ipc ;
    }
    /*
     * Support for package configuration command.
     */
    static char const posixipc_copyright[] =
        "This software is copyrighted 2018 by G. Andrew Mangogna."
        " Terms and conditions for use are distributed with the source code." ;
    
    static Tcl_Config const posixipc_config[] = {
        [0] = {"pkgname", PACKAGE_NAME},
        [1] = {"version", PACKAGE_VERSION},
        [2] = {"copyright", posixipc_copyright},
        {NULL, NULL}
    } ;
    
    Tcl_RegisterConfig(interp, posixipc_config[0].value, posixipc_config, "utf-8") ;
    /*
     * Declare the package as now provided.
     */
    Tcl_PkgProvide(interp, PACKAGE_NAME, PACKAGE_VERSION) ;

    return TCL_OK ;

    /*
     * Release resources on error.
     */
    release_shm:
        Tcl_DecrRefCount(shmMap) ;
        goto release_ipc ;
    release_mq:
        Tcl_DecrRefCount(mqMap) ;
        goto release_ipc ;
    release_ipc:
        Tcl_DecrRefCount(ipcMap) ;
        Tcl_DeleteNamespace(ipcNs) ;
        return TCL_ERROR ;
}
int
Posixipc_SafeInit(
    Tcl_Interp *interp)
{
    return TCL_ERROR ;      // <1>
}
#if TCL_MAJOR_VERSION >= 8 && TCL_MINOR_VERSION >= 5
int
Posixipc_Unload(
    Tcl_Interp *interp)
{
    // HERE! Do we need to close all the IPC mechanisms?
    return TCL_OK ;
}
#endif
#if TCL_MAJOR_VERSION >= 8 && TCL_MINOR_VERSION >= 5
int
Posixipc_SafeUnload(
    Tcl_Interp *interp)
{
    return TCL_ERROR ;
}
#endif
Tcl_Channel
PosixIPC_OpenMQChannel(
    Tcl_Interp *interp,
    Tcl_Obj *name,
    char const *mode,
    mode_t permissions,
    int maxmsg,
    int msgsize,
    unsigned priority)
{
    int flags = 0 ;
    int tclMask = 0 ;
    bool bintrans = false ;

    if (islower(*mode)) {
        if (processFopenModeOption(interp, mode, &flags, &tclMask, &bintrans) !=
                TCL_OK) {
            return NULL ;
        }
    } else {
        if (processOpenModeOption(interp, mode, &flags, &tclMask, &bintrans) !=
                TCL_OK) {
            return NULL ;
        }
    }

    char const *mqname = Tcl_GetString(name) ;
    struct mq_attr attrs = {
        .mq_flags = 0,
        .mq_maxmsg = maxmsg,
        .mq_msgsize = msgsize,
        .mq_curmsgs = 0
    } ;
    
    mqd_t mqdes = mq_open(mqname, flags, permissions, &attrs) ;
    if (mqdes < 0) {
        mqFailure(interp, mqname) ;
        return NULL ;
    }

    Tcl_Channel mqChan ;

    char chanName[TCL_INTEGER_SPACE + 16] ;
    snprintf(chanName, sizeof(chanName), "posixmq%d", mqdes) ;
    MqState *mqdata = ckalloc(sizeof(MqState)) ;
    mqChan = Tcl_CreateChannel(&MqChannelType, chanName, mqdata, tclMask) ;
    
    mqdata->channel = mqChan ;
    mqdata->mqdes = mqdes ;
    mqdata->tclMask = tclMask ;
    mqdata->lastpriority = 0 ;
    mqdata->defpriority = priority ;

    if (bintrans) {
        if (Tcl_SetChannelOption(interp, mqChan, "-translation", "binary") !=
                TCL_OK) {
            goto release_chan ;
        }
    }

    
    int syserr = mq_getattr(mqdata->mqdes, &attrs) ;
    if (syserr < 0) {
        mqFailure(interp, "mq_getattr failed during open") ;
        goto release_chan ;
    }
    
    Tcl_SetChannelBufferSize(mqChan, attrs.mq_msgsize) ;

    return mqChan ;

release_chan:
    Tcl_Close(interp, mqChan) ;
    return NULL ;
}
Tcl_Channel
PosixIPC_OpenSHMChannel(
    Tcl_Interp *interp,
    Tcl_Obj *name,
    char const *mode,
    mode_t permissions,
    off_t size)
{
    int flags = 0 ;
    int tclMask = 0 ;
    bool bintrans = false ;

    if (islower(*mode)) {
        if (processFopenModeOption(interp, mode, &flags, &tclMask, &bintrans) !=
                TCL_OK) {
            return NULL ;
        }
    } else {
        if (processOpenModeOption(interp, mode, &flags, &tclMask, &bintrans) !=
                TCL_OK) {
            return NULL ;
        }
    }

    int syserr ;
    char const *shmname = Tcl_GetString(name) ;

    sem_t *shmsem = sem_open(shmname, flags, permissions, 1) ;      // <1>
    if (shmsem == SEM_FAILED) {
        shmFailure(interp, "cannot open shared memory exclusive access semaphore") ;
        return NULL ;
    }
    if ((flags & O_CREAT) != 0 && size <= 0) {
        if (interp != NULL) {
            Tcl_SetObjResult(interp,
                    Tcl_ObjPrintf("shared memory size must be positive")) ;
        }
        goto release_sem ;
    }
    
    int shmfd = shm_open(shmname, flags, permissions) ;
    if (shmfd < 0) {
        shmFailure(interp, shmname) ;
        goto release_sem ;
    }
    struct stat shmStatus ;
    syserr = fstat(shmfd, &shmStatus) ;
    if (syserr < 0) {
        shmFailure(interp, "cannot get status of shared memory") ;
        goto release_shm ;
    }
    
    if (shmStatus.st_size == 0) {
        int syserr = ftruncate(shmfd, size) ;
        if (syserr < 0) {
            shmFailure(interp,
                    "cannot set the size of shared memory using ftruncate()") ;
            goto release_shm ;
        }
    } else {
        size = shmStatus.st_size ;
    }
    int mapProt = 0 ;
    mapProt |= (tclMask & TCL_READABLE) != 0 ? PROT_READ : 0 ;
    mapProt |= (tclMask & TCL_WRITABLE) != 0 ? PROT_WRITE : 0 ;
    
    void *mapaddr = mmap(NULL, size, mapProt, MAP_SHARED, shmfd, 0) ;
    if (mapaddr == MAP_FAILED) {
        shmFailure(interp, shmname) ;
        goto release_shm ;
    }

    Tcl_Channel shmChan ;
    char chanName[TCL_INTEGER_SPACE + 16] ;
    snprintf(chanName, sizeof(chanName), "posixshm%d", shmfd) ;
    
    ShmState *shmdata = ckalloc(sizeof(ShmState)) ;
    shmdata->shmfd = shmfd ;
    shmdata->semaphore = shmsem ;
    shmdata->tclMask = tclMask ;
    shmdata->blockingMode = (flags & O_NONBLOCK) != 0 ?
            TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING ;
    shmdata->address = mapaddr ;
    shmdata->length = size ;
    shmdata->position = 0 ;
    shmdata->channel = shmChan =
            Tcl_CreateChannel(&ShmChannelType, chanName, shmdata, tclMask) ;
    if (bintrans) {
        if (Tcl_SetChannelOption(interp, shmChan, "-translation", "binary") !=
                TCL_OK) {
            goto release_chan ;
        }
    }

    return shmChan ;

release_chan:
    Tcl_Close(interp, shmChan) ;
    ckfree(shmdata) ;

release_shm:
    close(shmfd) ;

release_sem:
    sem_close(shmsem) ;

    return NULL ;
}

/*
 * Static Functions
 */
static int
processFopenModeOption(
    Tcl_Interp *interp,
    char const *const mode,
    int *flags,
    int *mask,
    bool *binary)
{
    static struct fopenModeDes const fopenModes[] = { // ordered by ascending modeName!
        {
            .modeName = "r",
            .oFlags = O_RDONLY,
            .tclMask = TCL_READABLE,
            .isBinary = false,
        }, {
            .modeName = "r+",
            .oFlags = O_RDWR,
            .tclMask = TCL_READABLE | TCL_WRITABLE,
            .isBinary = false,
        }, {
            .modeName = "r+b",
            .oFlags = O_RDWR,
            .tclMask = TCL_READABLE | TCL_WRITABLE,
            .isBinary = true,
        }, {
            .modeName = "rb",
            .oFlags = O_RDONLY,
            .tclMask = TCL_READABLE,
            .isBinary = true,
        }, {
            .modeName = "rb+",
            .oFlags = O_RDWR,
            .tclMask = TCL_READABLE | TCL_WRITABLE,
            .isBinary = true,
        }, {
            .modeName = "w",
            .oFlags = O_WRONLY | O_CREAT,
            .tclMask = TCL_WRITABLE,
            .isBinary = false,
        }, {
            .modeName = "w+",
            .oFlags = O_RDWR | O_CREAT,
            .tclMask = TCL_READABLE | TCL_WRITABLE,
            .isBinary = false,
        }, {
            .modeName = "w+b",
            .oFlags = O_RDWR | O_CREAT,
            .tclMask = TCL_READABLE | TCL_WRITABLE,
            .isBinary = true,
        }, {
            .modeName = "wb",
            .oFlags = O_WRONLY | O_CREAT,
            .tclMask = TCL_WRITABLE,
            .isBinary = true,
        }, {
            .modeName = "wb+",
            .oFlags = O_RDWR | O_CREAT,
            .tclMask = TCL_READABLE | TCL_WRITABLE,
            .isBinary = true,
        },
    } ;

    struct fopenModeDes const *modeSpec ;
    struct fopenModeDes key = {
        .modeName = mode,
    } ;
    
    modeSpec = bsearch(&key, fopenModes, COUNTOF(fopenModes),
            sizeof(struct fopenModeDes), fopenModeCompare) ;

    if (modeSpec == NULL) {
        Tcl_SetObjResult(interp, Tcl_ObjPrintf("unknown open mode, \"%s\": "
                "should be one of %s, %s %s, %s, %s, %s, %s, or %s",
                mode,
                fopenModes[0].modeName, fopenModes[1].modeName,
                fopenModes[3].modeName, fopenModes[4].modeName,
                fopenModes[5].modeName, fopenModes[6].modeName,
                fopenModes[8].modeName, fopenModes[9].modeName)) ;
        return TCL_ERROR ;
    }

    *flags = modeSpec->oFlags ;
    *mask = modeSpec->tclMask ;
    *binary = modeSpec->isBinary ;

    return TCL_OK ;
}
static int
fopenModeCompare(
    void const *m1,
    void const *m2)
{
    struct fopenModeDes const *o1 = m1 ;
    struct fopenModeDes const *o2 = m2 ;

    return strcmp(o1->modeName, o2->modeName) ;
}
static int
processOpenModeOption(
    Tcl_Interp *interp,
    char const *const mode,
    int *flags,
    int *mask,
    bool *binary)
{
    int resultCode = TCL_OK ;

    static struct openFlagDes const openFlags[] = { // order by ascending modeName!
        {
            .modeName = "BINARY",
            .oFlags = 0,            // BINARY does not affect the open flags.
            .tclMask = 0,
            .isBinary = true,
            .isAccessMode = false,
        }, {
            .modeName = "CREAT",
            .oFlags = O_CREAT,
            .tclMask = 0,
            .isBinary = false,
            .isAccessMode = false,
        }, {
            .modeName = "EXCL",
            .oFlags = O_EXCL,
            .tclMask = 0,
            .isBinary = false,
            .isAccessMode = false,
        }, {
            .modeName = "NONBLOCK",
            .oFlags = O_NONBLOCK,
            .tclMask = 0,
            .isBinary = false,
            .isAccessMode = false,
        }, {
            .modeName = "RDONLY",
            .oFlags = O_RDONLY,
            .tclMask = TCL_READABLE,
            .isBinary = false,
            .isAccessMode = true,
        }, {
            .modeName = "RDWR",
            .oFlags = O_RDWR,
            .tclMask = TCL_READABLE | TCL_WRITABLE,
            .isBinary = false,
            .isAccessMode = true,
        }, {
            .modeName = "WRONLY",
            .oFlags = O_WRONLY,
            .tclMask = TCL_WRITABLE,
            .isBinary = false,
            .isAccessMode = true,
        },
    } ;

    int modeCount ;
    char const **modeItems ;
    
    if (Tcl_SplitList(interp, mode, &modeCount, &modeItems) != TCL_OK) {
        return TCL_ERROR ;
    }

    int oflags = 0 ;
    int tclMask = 0 ;
    bool bintrans = false ;
    int accessFlagCount = 0 ;
    
    for (int itemIndex = 0 ; itemIndex < modeCount ; itemIndex++) {
        struct openFlagDes key = {
            .modeName = modeItems[itemIndex],
        } ;
    
        struct openFlagDes const *flagSpec =
                bsearch(&key, openFlags, COUNTOF(openFlags),
                sizeof(struct openFlagDes), openFlagCompare) ;
    
        if (flagSpec == NULL) {
            Tcl_SetObjResult(interp,
                    Tcl_ObjPrintf("invalid access mode \"%s\": must be "
                    "%s, %s, %s, %s, %s, %s, or %s", modeItems[itemIndex],
                    openFlags[0].modeName, openFlags[1].modeName,
                    openFlags[2].modeName, openFlags[3].modeName,
                    openFlags[4].modeName, openFlags[5].modeName,
                    openFlags[6].modeName)) ;
            resultCode = TCL_ERROR ;
            goto release_list_items ;          // <1>
        } else {
            oflags |= flagSpec->oFlags ;
            tclMask |= flagSpec->tclMask ;
            bintrans = bintrans || flagSpec->isBinary ;
            accessFlagCount += flagSpec->isAccessMode ;
        }
    }

    if (accessFlagCount != 1) {
        Tcl_SetObjResult(interp, Tcl_NewStringObj(
                "access mode must specify exactly one of RDONLY, WRONLY, or RDWR",
                -1)) ;
        resultCode = TCL_ERROR ;
        goto release_list_items ;
    }

    *flags = oflags ;
    *mask = tclMask ;
    *binary = bintrans ;

release_list_items:
    ckfree(modeItems) ;
    return resultCode ;
}
static int
mqBlockModeProc(
    ClientData instanceData,
    int mode)
{
    struct mq_attr newattrs = {
        .mq_flags = mode == TCL_MODE_NONBLOCKING ? O_NONBLOCK : 0,  // <1>
        .mq_maxmsg = 0,
        .mq_msgsize = 0,
        .mq_curmsgs = 0,
    } ;

    MqState *mqPtr = instanceData ;

    int err = mq_setattr(mqPtr->mqdes, &newattrs, NULL) ;
    return err < 0 ? errno : err ;
}
static int
mqCloseProc(
    ClientData instanceData,
    Tcl_Interp *interp)
{
    MqState *mqPtr = instanceData ;

    Tcl_DeleteFileHandler(mqPtr->mqdes) ;   // <1>

    int err = mq_close(mqPtr->mqdes) ;
    ckfree(mqPtr) ;                         // <2>

    return err < 0 ? errno : err ;
}
static int
mqInputProc(
    ClientData instanceData,
    char *buf,
    int bufSize,
    int *errorCodePtr)
{
    MqState *mqData = instanceData ;

    int read = mq_receive(mqData->mqdes, buf, bufSize, &mqData->lastpriority) ; // <1>
    if (read == -1) {
        *errorCodePtr = errno ;
    }
    return read ;
}
static int
mqOutputProc(
    ClientData instanceData,
    char const *buf,
    int toWrite,
    int *errorCodePtr)
{
    MqState *mqPtr = instanceData ;

    int err = mq_send(mqPtr->mqdes, buf, toWrite, mqPtr->defpriority) ; // <1>
    if (err == -1) {
        *errorCodePtr = errno ;
        return -1 ;
    }
    return toWrite ;
}
static struct MqConfigOpt const *
lookUpMqOpt(
    char const *optionName)
{
    struct MqConfigOpt key = {
        .optName = optionName
    } ;

    return bsearch(&key, mqOptions, COUNTOF(mqOptions),
            sizeof(struct MqConfigOpt), mqOptCompare) ;
}
static int
mqOptCompare(
    void const *m1,
    void const *m2)
{
    struct MqConfigOpt const *o1 = m1 ;
    struct MqConfigOpt const *o2 = m2 ;

    return strcmp(o1->optName, o2->optName) ;
}
static int
mqGetOptionProc(
    ClientData instanceData,
    Tcl_Interp *interp,
    char const *optionName,
    Tcl_DString *optionValue)
{
    MqState *mqPtr = instanceData ;

    if (optionName != NULL) {
        struct MqConfigOpt const *optProp = lookUpMqOpt(optionName) ;
        
        if (optProp == NULL) {
            return Tcl_BadChannelOption(interp, optionName, mqOptionsList) ;
        }
        struct mq_attr attrs ;                      // retrieved mq attributes
        char buf[TCL_INTEGER_SPACE + 16] ;          // formated option values
        
        static char const getAttrFailedMsg[] = "get option: mq_getattr() failed" ;
        
        MqOptionType whichOpt = (MqOptionType)(optProp - mqOptions) ;
        switch (whichOpt) {
            case Mq_curmsgs_opt:
            {
                int err = mq_getattr(mqPtr->mqdes, &attrs) ;
                if (err < 0) {
                    return mqFailure(interp, getAttrFailedMsg) ;
                }
                snprintf(buf, sizeof(buf), "%ld", attrs.mq_curmsgs) ;
            }
                break ;
            case Mq_lastpriority_opt:
            {
                snprintf(buf, sizeof(buf), "%u", mqPtr->lastpriority) ;
            }
                break ;
            case Mq_maxmsg_opt:
            {
                int err = mq_getattr(mqPtr->mqdes, &attrs) ;
                if (err < 0) {
                    return mqFailure(interp, getAttrFailedMsg) ;
                }
                snprintf(buf, sizeof(buf), "%ld", attrs.mq_maxmsg) ;
            }
                break ;
            case Mq_msgsize_opt:
            {
                int err = mq_getattr(mqPtr->mqdes, &attrs) ;
                if (err < 0) {
                    return mqFailure(interp, getAttrFailedMsg) ;
                }
                snprintf(buf, sizeof(buf), "%ld", attrs.mq_msgsize) ;
            }
                break ;
            case Mq_priority_opt:
            {
                snprintf(buf, sizeof(buf), "%u", mqPtr->defpriority) ;
            }
                break ;
            default:        // <1>
                Tcl_Panic("posixipc mq: get option failure: found option named, "
                        "\"%s\", but no code to process the option", optionName) ;
                break ;
        }
        
        Tcl_DStringAppendElement(optionValue, buf) ;
    } else {
        struct mq_attr attrs ;
        int err = mq_getattr(mqPtr->mqdes, &attrs) ;
        if (err < 0) {
            return mqFailure(interp, "get option: mq_getattr() failed") ;
        }
        char buf[TCL_INTEGER_SPACE + 16] ;      // buffer space for the formatting
        struct MqConfigOpt const *optProp = mqOptions ;
        
        Tcl_DStringAppendElement(optionValue, optProp->optName) ;
        optProp++ ;                                                 // <1>
        snprintf(buf, sizeof(buf), "%ld", attrs.mq_curmsgs) ;
        Tcl_DStringAppendElement(optionValue, buf) ;
        Tcl_DStringAppendElement(optionValue, optProp->optName) ;
        optProp++ ;
        snprintf(buf, sizeof(buf), "%u", mqPtr->lastpriority) ;
        Tcl_DStringAppendElement(optionValue, buf) ;
        Tcl_DStringAppendElement(optionValue, optProp->optName) ;
        optProp++ ;
        snprintf(buf, sizeof(buf), "%ld", attrs.mq_maxmsg) ;
        Tcl_DStringAppendElement(optionValue, buf) ;
        Tcl_DStringAppendElement(optionValue, optProp->optName) ;
        optProp++ ;
        snprintf(buf, sizeof(buf), "%ld", attrs.mq_msgsize) ;
        Tcl_DStringAppendElement(optionValue, buf) ;
        Tcl_DStringAppendElement(optionValue, optProp->optName) ;
        optProp++ ;                                                 // <1>
        snprintf(buf, sizeof(buf), "%u", mqPtr->defpriority) ;
        Tcl_DStringAppendElement(optionValue, buf) ;
    }
    return TCL_OK ;
}
static int
ipcFailure(
    Tcl_Interp *interp,
    char const *type,
    char const *msg)
{
    Tcl_SetErrno(errno) ;
    Tcl_Obj *errObj = Tcl_ObjPrintf("posixipc %s: %s: %s", type, msg,
            Tcl_PosixError(interp)) ;
    Tcl_SetObjResult(interp, errObj) ;
    return TCL_ERROR ;                  // <1>
}
static int
mqFailure(
    Tcl_Interp *interp,
    char const *msg)
{
    return ipcFailure(interp, "mq", msg) ;
}
static int
mqSetOptionProc(
    ClientData instanceData,
    Tcl_Interp *interp,
    char const *optionName,
    char const *newValue)
{
    MqState *mqPtr = instanceData ;

    struct MqConfigOpt const *optProp = lookUpMqOpt(optionName) ;
    if (optProp == NULL) {
        return Tcl_BadChannelOption(interp, optionName, mqOptionsList) ;
    } else if (!optProp->setOnConfig) {
        Tcl_Obj *errObj = Tcl_ObjPrintf("posixipc mq: set option: "
                "%s option may not be set by configuration", optionName) ;
        Tcl_SetObjResult(interp, errObj) ;
        return TCL_ERROR ;
    } else {
        MqOptionType whichOpt = (MqOptionType)(optProp - mqOptions) ;
        switch (whichOpt) {
            case Mq_priority_opt:
            {
                int priority ;
                if (Tcl_GetInt(interp, newValue, &priority) != TCL_OK) {
                    return TCL_ERROR ;
                }
                if (priority < 0) {
                    Tcl_Obj *errObj = Tcl_ObjPrintf("posixipc mq: set option: "
                            "invalid negative message priority: %d", priority) ;
                    Tcl_SetObjResult(interp, errObj) ;
                    return TCL_ERROR ;
                }
                mqPtr->defpriority = priority ;
            }
                break ;
        
            default:
                Tcl_Panic("posixipc mq: set option failure: found option named, "
                        "\"%s\", but no code to process the option", optionName) ;
                break ;
        }
    }

    return TCL_OK ;
}
static void
mqWatchProc(
    ClientData instanceData,
    int mask)
{
    MqState *mqPtr = instanceData ;

    mask &= mqPtr->tclMask ;
    if (mask != 0) {
        Tcl_CreateFileHandler(mqPtr->mqdes, mask,
                (Tcl_FileProc *)Tcl_NotifyChannel, mqPtr->channel) ;
    } else {
        Tcl_DeleteFileHandler(mqPtr->mqdes) ;
    }
}
static int
mqGetHandleProc(
    ClientData instanceData,
    int direction,
    ClientData *handlePtr)
{
    MqState *mqPtr = instanceData ;

    if ((direction & mqPtr->tclMask) == 0) {
        return TCL_ERROR ;
    }

    *handlePtr = (ClientData)(intptr_t)(mqPtr->mqdes) ; // <1>
    return TCL_OK ;
}
static int
openFlagCompare(
    void const *m1,
    void const *m2)
{
    struct openFlagDes const *f1 = m1 ;
    struct openFlagDes const *f2 = m2 ;

    return strcmp(f1->modeName, f2->modeName) ;
}
static int
mqOpenCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    static char const usage[] = "?options? queuename ?access? ?permissions?" ;
    if (objc < 2) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }

    int maxmsg = 10 ;
    int msgsize = 8192 ;
    int priority = 0 ;
    char const *mode = "r" ;
    mode_t permissions = 0666 ;

    int objindex = 1 ;                                      // <1>
    for ( ; objindex < objc ; objindex++) {
        char const *optionName = Tcl_GetString(objv[objindex]) ;
        if (strcmp(optionName, "--") == 0) {                        // <1>
            objindex++ ;                                            // <2>
            break ;
        }
        struct MqConfigOpt const *optProp = lookUpMqOpt(optionName) ;
        if (optProp == NULL) {                                      // <3>
            if (*optionName == '-') {
                return Tcl_BadChannelOption(interp, optionName, mqOptionsList) ;
            } else {
                break ;
            }
        }
        if (!optProp->setOnOpen) {                                  // <4>
            Tcl_SetObjResult(interp,
                    Tcl_ObjPrintf("option, %s, cannot be set on open: "
                    "should be one of: %s, %s, or %s",
                    optProp->optName, mqOptions[2].optName, mqOptions[3].optName,
                    mqOptions[4].optName)) ;
            return TCL_ERROR ;
        }
    
        if (++objindex >= objc) {                                   // <1>
            Tcl_WrongNumArgs(interp, 1, objv, usage) ;
            return TCL_ERROR ;
        }
    
        MqOptionType whichOpt = (MqOptionType)(optProp - mqOptions) ;
        switch (whichOpt) {
            case Mq_maxmsg_opt:
                if (Tcl_GetIntFromObj(interp, objv[objindex], &maxmsg) !=
                        TCL_OK) {
                    return TCL_ERROR ;
                }
                break ;
            case Mq_msgsize_opt:
                if (Tcl_GetIntFromObj(interp, objv[objindex], &msgsize) !=
                        TCL_OK) {
                    return TCL_ERROR ;
                }
                break ;
            case Mq_priority_opt:
                if (Tcl_GetIntFromObj(interp, objv[objindex], &priority) !=
                        TCL_OK) {
                    return TCL_ERROR ;
                }
                if (priority < 0) {                                 // <1>
                    Tcl_SetObjResult(interp,
                            Tcl_ObjPrintf("negative values for option, \"%s\", "
                            "are not allowed: got %d",
                            optionName, priority)) ;
                    return TCL_ERROR ;
                }
                break ;
            default:
                Tcl_Panic("posixipc mq: open option failure: "
                        "found option named, "
                        "\"%s\", but no code to process the option",
                        optionName) ;
                break ;
        }
    }

    int remain = objc - objindex ;
    if (remain < 1 || remain > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }
    
    if (remain > 1) {
        mode = Tcl_GetString(objv[objindex + 1]) ;
    }
    
    if (remain == 3) {
        int permArgValue ;
        if (Tcl_GetIntFromObj(interp, objv[objindex + 2], &permArgValue)
                != TCL_OK) {
            return TCL_ERROR ;
        }
        permissions = permArgValue ;
    }

    Tcl_Channel chan = PosixIPC_OpenMQChannel(interp, objv[objindex], mode,
            permissions, maxmsg, msgsize, priority) ;
    if (chan == NULL) {
        return TCL_ERROR ;
    }
    Tcl_RegisterChannel(interp, chan) ;                             // <1>
    Tcl_SetObjResult(interp, Tcl_NewStringObj(Tcl_GetChannelName(chan), -1)) ;

    return TCL_OK ;
}
static int
mqSendCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    static char const usage[] = "mqchan msg ?priority?" ;
    if (objc < 3 || objc > 4) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }

    char const *chanName = Tcl_GetString(objv[1]) ;
    int mode ;
    Tcl_Channel channel = Tcl_GetChannel(interp, chanName, &mode) ;
    if (channel == NULL) {
        return TCL_ERROR ;
    }
    MqState *mqdata = Tcl_GetChannelInstanceData(channel) ;

    int msglen ;
    unsigned char *msg = Tcl_GetByteArrayFromObj(objv[2], &msglen) ;

    int priority = mqdata->defpriority ;
    if (objc == 4) {
        if (Tcl_GetIntFromObj(interp, objv[3], &priority) != TCL_OK) {
            return TCL_ERROR ;
        }
        if (priority < 0) {
            Tcl_SetObjResult(interp,
                    Tcl_ObjPrintf("negative values for priority "
                    "are not allowed: got %d", priority)) ;
            return TCL_ERROR ;
        }
    }

    int err = mq_send(mqdata->mqdes, (char const *)msg, msglen, priority) ;
    if (err < 0) {
        return mqFailure(interp, "mq_send failed") ;
    }

    Tcl_SetObjResult(interp, Tcl_NewIntObj(msglen)) ;
    return TCL_OK ;
}
static int
mqReceiveCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    static char const usage[] = "mqchan ?priorvar?" ;
    if (objc < 2 || objc > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }

    char const *chanName = Tcl_GetString(objv[1]) ;
    int mode ;
    Tcl_Channel channel = Tcl_GetChannel(interp, chanName, &mode) ;
    if (channel == NULL) {
        return TCL_ERROR ;
    }

    MqState *mqdata = Tcl_GetChannelInstanceData(channel) ;
    struct mq_attr attrs ;
    int syserr = mq_getattr(mqdata->mqdes, &attrs) ;
    if (syserr < 0) {
        return mqFailure(interp, "mq_getattr failed during receive") ;
    }

    Tcl_Obj *resultObj = Tcl_NewObj() ;
    unsigned char *value = Tcl_SetByteArrayLength(resultObj, attrs.mq_msgsize) ;

    syserr = mq_receive(mqdata->mqdes, (char *)value, attrs.mq_msgsize,
            &mqdata->lastpriority) ;
    if (syserr < 0) {
        mqFailure(interp, "mq_receive failed") ;
        goto release_result ;
    }

    if (objc == 3) {
        Tcl_Obj *priorObj = Tcl_NewIntObj(mqdata->lastpriority) ;
        if (Tcl_ObjSetVar2(interp, objv[2], NULL, priorObj, TCL_LEAVE_ERR_MSG)
                == NULL) {
            Tcl_DecrRefCount(priorObj) ;
            goto release_result ;
        }
    }

    Tcl_SetObjResult(interp, resultObj) ;
    return TCL_OK ;

release_result:
    Tcl_DecrRefCount(resultObj) ;

    return TCL_ERROR ;
}
static int
mqUnlinkCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    static char const usage[] = "queuename" ;
    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }

    char const *mqname = Tcl_GetString(objv[1]) ;

    mqd_t mqdes = mq_unlink(mqname) ;
    if (mqdes < 0) {
        return mqFailure(interp, mqname) ;
    }

    return TCL_OK ;
}
static int
shmCloseProc(
    ClientData instanceData,
    Tcl_Interp *interp)
{
    ShmState *shmData = instanceData ;

    Tcl_DeleteFileHandler(shmData->shmfd) ;

    int resultCode = 0 ;

    int syserr = munmap(shmData->address, shmData->length) ;
    if (syserr < 0) {
        resultCode = errno ;
    }

    syserr = close(shmData->shmfd) ;
    if (syserr < 0) {
        resultCode = errno ;
    }

    syserr = sem_close(shmData->semaphore) ;
    if (syserr < 0) {
        resultCode = errno ;
    }

    ckfree(shmData) ;
    return resultCode ;
}
static int
shmInputProc(
    ClientData instanceData,
    char *buf,
    int bufSize,
    int *errorCodePtr)
{
    ShmState *shmData = instanceData ;

    int syserr ;
    if (shmData->blockingMode == TCL_MODE_NONBLOCKING) {
        syserr = sem_trywait(shmData->semaphore) ;
        if (syserr == -1) {
            *errorCodePtr = errno ;
            return -1 ;
        }
    } else {
        syserr = sem_wait(shmData->semaphore) ;
        if (syserr == -1) {
            *errorCodePtr = errno ;
            return -1 ;
        }
    }

    size_t remaining = shmData->length - shmData->position ;
    int toRead = bufSize < remaining ? bufSize : remaining ;

    memcpy(buf, shmData->address + shmData->position, toRead) ;
    shmData->position += toRead ;

    syserr = sem_post(shmData->semaphore) ;
    if (syserr == -1) {
        *errorCodePtr = errno ;
        return -1 ;
    }

    return toRead ;
}
static int
shmOutputProc(
    ClientData instanceData,
    char const *buf,
    int toWrite,
    int *errorCodePtr)
{
    ShmState *shmData = instanceData ;

    int syserr ;
    if (shmData->blockingMode == TCL_MODE_NONBLOCKING) {
        syserr = sem_trywait(shmData->semaphore) ;
        if (syserr == -1) {
            *errorCodePtr = errno ;
            return -1 ;
        }
    } else {
        syserr = sem_wait(shmData->semaphore) ;
        if (syserr == -1) {
            *errorCodePtr = errno ;
            return -1 ;
        }
    }

    size_t available = shmData->length - shmData->position ;
    int canWrite = toWrite < available ? toWrite : available ;

    memcpy(shmData->address + shmData->position, buf, canWrite) ;
    shmData->position += canWrite ;

    syserr = sem_post(shmData->semaphore) ;
    if (syserr == -1) {
        *errorCodePtr = errno ;
        return -1 ;
    }

    return canWrite ;
}
static int
shmSeekProc(
    ClientData instanceData,
    long offset,
    int seekMode,
    int *errorCodePtr)
{
    ShmState *shmData = instanceData ;

    off_t start ;
    switch (seekMode) {
    case SEEK_SET:
        start = 0 ;
        break ;

    case SEEK_CUR:
        start = shmData->position ;
        break ;

    case SEEK_END:
        start = shmData->length - 1 ;
        break ;

    default:
        Tcl_Panic("unknown seek mode") ;
        break ;
    }

    off_t newPosition = start + offset ;
    if (newPosition < 0 || newPosition >= shmData->length) {
        *errorCodePtr = EINVAL ;
        return -1 ;
    }

    shmData->position = newPosition ;
    return newPosition ;
}
static void
shmWatchProc(
    ClientData instanceData,
    int mask)
{
    ShmState *shmData = instanceData ;

    mask &= shmData->tclMask ;
    if (mask != 0) {
        Tcl_CreateFileHandler(shmData->shmfd, mask,
                (Tcl_FileProc *)Tcl_NotifyChannel, shmData->channel) ;
    } else {
        Tcl_DeleteFileHandler(shmData->shmfd) ;
    }
}
static int
shmGetHandleProc(
    ClientData instanceData,
    int direction,
    ClientData *handlePtr)
{
    ShmState *shmData = instanceData ;

    if ((direction & shmData->tclMask) == 0) {
        return TCL_ERROR ;
    }

    *handlePtr = (ClientData)(intptr_t)(shmData->shmfd) ;
    return TCL_OK ;
}
static int
shmBlockModeProc(
    ClientData instanceData,
    int mode)
{
    ShmState *shmData = instanceData ;

    shmData->blockingMode = mode ;

    return 0 ;
}
static int
shmFailure(
    Tcl_Interp *interp,
    char const *msg)
{
    return ipcFailure(interp, "shm", msg) ;
}
static int
shmOpenCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    static char const usage[] = "?options? sharedname ?access? ?permissions?" ;
    if (objc < 2) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }

    char const *mode = "r" ;
    mode_t permissions = 0666 ;
    off_t shmSize = 0 ;                // <1>

    int objindex = 1 ;
    for ( ; objindex < objc ; objindex++) {
        char const *optionName = Tcl_GetString(objv[objindex]) ;
        if (strcmp(optionName, "--") == 0) {
            objindex++ ;
            break ;
        } else if (strcmp(optionName, "-size") == 0) {
            if (++objindex >= objc) {
                Tcl_WrongNumArgs(interp, 1, objv, usage) ;
                return TCL_ERROR ;
            }
            int size ;
            if (Tcl_GetIntFromObj(interp, objv[objindex], &size) != TCL_OK) {
                return TCL_ERROR ;
            }
            shmSize = size ;
        } else {
            break ;
        }
    }

    int remain = objc - objindex ;
    if (remain < 1 || remain > 3) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }
    
    if (remain > 1) {
        mode = Tcl_GetString(objv[objindex + 1]) ;
    }
    
    if (remain == 3) {
        int permArgValue ;
        if (Tcl_GetIntFromObj(interp, objv[objindex + 2], &permArgValue)
                != TCL_OK) {
            return TCL_ERROR ;
        }
        permissions = permArgValue ;
    }

    Tcl_Channel chan = PosixIPC_OpenSHMChannel(interp, objv[objindex], mode,
            permissions, shmSize) ;
    if (chan == NULL) {
        return TCL_ERROR ;
    }
    Tcl_RegisterChannel(interp, chan) ;
    Tcl_SetObjResult(interp, Tcl_NewStringObj(Tcl_GetChannelName(chan), -1)) ;

    return TCL_OK ;
}
static int
shmUnlinkCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    static char const usage[] = "shmname" ;
    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }

    char const *shmname = Tcl_GetString(objv[1]) ;

    int shmerr = shm_unlink(shmname) ;
    int semerr = sem_unlink(shmname) ;      // <1>

    if (shmerr < 0 || semerr < 0) {
        return shmFailure(interp, shmname) ;
    }

    return TCL_OK ;
}
