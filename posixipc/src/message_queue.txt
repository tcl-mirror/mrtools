== Message Queues
The `mq` command is an ensemble command.
The following sections describe each sub-command in the ensemble.

=== mq open command

*******
`posixipc mq open` ?options? mqname +
`posixipc mq open` ?options? mqname access +
`posixipc mq open` ?options? mqname access permissions

options::
    Options consist of the following

    -maxmsg _count_;;
        The maximum number of messages that may be queued.
        This option only may be set when `open` is called,
        but it may be queried as a configuration option.
        If missing, a system default value is used.
    -msgsize _len_;;
        The maximum length in bytes any message.
        This option only may be set when `open` is called,
        but it may be queried as a configuration option.
        If missing, a system default value is used.
    -curmsg;;
        The number of messages currently in the queue.
        This option only may *not* be set when `open` is called,
        but it may be queried as a configuration option.
    -priority _prior_;;
        The default message priority as a non-negative number.
        This option may be set when `open` is called or as a
        configuration option.
        It gives the default priority of messages queue to the
        message queue.
        If not specified, the default priority is 0.
        Messages are placed on the message queue in decreasing
        order of priority.

mqname::
    The name of message queue. Message queue names must start with
    a slash (/) character and may *not* contain any other slash
    characters.
*******

*******
access::
    The _access_ argument, if present, indicates the way in which the
    message queue is to be accessed.
    In the first form, _access_ may have any of the following forms:
    r;;
        Open the message queue for reading only.
        The message queue must already exist.
        This is the default if _access_ is not specified.
    r+;;
        Open the message queue for reading and writing.
        The message queue must already exist.
    w;;
        Open the message queue for writing only.
        Create the message queue if it does not already exist.
    w+;;
        Open the message queue for reading and writing.
        Create the message queue if it does not already exist.

+
All legal _access_ values above may have the character *b* added
as the second or third character in the value to indicate that the
opened channel should be configured as if with the
*fconfigure -translation binary* option, making the channel suitable
for reading or writing of binary data.
+
In the second form,
_access_ consists of a list of any of the following flags,
all of which have the standard POSIX meanings.
One of the flags must be either *RDONLY*, *WRONLY*, or *RDWR*.

    RDONLY;;
        Open the message queue for reading only.
    WRONLY;;
        Open the message queue for writing only.
    RDWR;;
        Open the message queue for both reading and writing.
    CREAT;;
        Create the message queue if it does not already exist.
    EXCL;;
        If *CREAT* is also specified, an error is returned if the
        message queue already exists.
    NONBLOCK;;
        Prevent the process from blocking in subsequent I/O operations.

permissions::
    If the message queue is created as part of opening it,
    _permissions_ is used to set the permissions for the new message
    queue in conjunction withthe process's file mode creation mask.
    _Permissions_ defaults to 0666.
*******

/////
posixipc mq open ?options? name
posixipc mq open ?options? name access
posixipc mq open ?options? name access permissions

options ==> mq option strings
-maxmsg -- max number of messages on the queue
-msgsize -- max message size

for get options ==> above options plus
-curmsgs -- number of messages currently in queue

access ==> using letters
r -- read only, file must exist
r+ -- read/write, file must exist
w -- write only, create if not exist
w+ -- read/write, create if not exist
can add "b" to get binary mode translation

access ==> using flags
RDONLY
WRONLY
RDWR
CREAT
EXCL
NONBLOCK

permissions ==> file permissions, just a number
/////

[source,c]
----
<<mq forward function declarations>>=
static int mqOpenCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
----

[source,c]
----
<<mq static function definitions>>=
static int
mqOpenCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    return TCL_OK ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqSendCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
----

[source,c]
----
<<mq static function definitions>>=
static int
mqSendCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    return TCL_OK ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqRecvCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
----

[source,c]
----
<<mq static function definitions>>=
static int
mqRecvCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    return TCL_OK ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqUnlinkCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
----

[source,c]
----
<<mq static function definitions>>=
static int
mqUnlinkCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    return TCL_OK ;
}
----

=== Tcl Channel Considerations

[source,c]
----
<<mq data structures>>=
typedef struct mqData {
    Tcl_Channel channel ;
    mqd_t mqdes ;
    struct mq_attr attrs ;
} PosixmqState ;
----

[source,c]
----
<<mq static data>>=
static Tcl_ChannelType PosixmqChannelType = {
    .typeName = "mq",           /* The name of the channel type in Tcl
                                 * commands. This storage is owned by channel
                                 * type. */
    .version = TCL_CHANNEL_VERSION_5,
                                /* Version of the channel type. */
    .closeProc = mqCloseProc,
                                /* Function to call to close the channel, or
                                 * TCL_CLOSE2PROC if the close2Proc should be
                                 * used instead. */
    .inputProc = mqInputProc,
                                /* Function to call for input on channel. */
    .outputProc = mqOutputProc,
                                /* Function to call for output on channel. */
    .seekProc = NULL,
                                /* Function to call to seek on the channel.
                                 * May be NULL. */
    .setOptionProc = mqSetOptionProc,
                                /* Set an option on a channel. */
    .getOptionProc = mqGetOptionProc,
                                /* Get an option from a channel. */
    .watchProc = mqWatchProc,
                                /* Set up the notifier to watch for events on
                                 * this channel. */
    .getHandleProc = mqGetHandleProc,
                                /* Get an OS handle from the channel or NULL
                                 * if not supported. */
    .close2Proc = NULL,
                                /* Function to call to close the channel if
                                 * the device supports closing the read &
                                 * write sides independently. */
    .blockModeProc = mqBlockModeProc,
                                /* Set blocking mode for the raw channel. May
                                 * be NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_2 channels or later
     */
    .flushProc = NULL,
                                /* Function to call to flush a channel. May be
                                 * NULL. */
    .handlerProc = NULL,
                                /* Function to call to handle a channel event.
                                 * This will be passed up the stacked channel
                                 * chain. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_3 channels or later
     */
    .wideSeekProc = NULL,
                                /* Function to call to seek on the channel
                                 * which can handle 64-bit offsets. May be
                                 * NULL, and must be NULL if seekProc is
                                 * NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_4 channels or later
     * TIP #218, Channel Thread Actions
     */
    .threadActionProc = NULL,
                                /* Function to call to notify the driver of
                                 * thread specific activity for a channel. May
                                 * be NULL. */

    /*
     * Only valid in TCL_CHANNEL_VERSION_5 channels or later
     * TIP #208, File Truncation
     */
    .truncateProc = NULL
                                /* Function to call to truncate the underlying
                                 * file to a particular length. May be NULL if
                                 * the channel does not support truncation. */
} ;
----

[source,c]
----
<<mq forward function declarations>>=
static int mqBlockModeProc(ClientData instanceData, int mode) ;

<<mq static function definitions>>=
static int
mqBlockModeProc(
    ClientData instanceData,
    int mode)
{
    return 0 ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqCloseProc(ClientData instanceData, Tcl_Interp *interp) ;

<<mq static function definitions>>=
static int
mqCloseProc(
    ClientData instanceData,
    Tcl_Interp *interp)
{
    return 0 ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqInputProc(ClientData instanceData, char *buf, int bufSize,
        int *errorCodePtr) ;

<<mq static function definitions>>=
static int
mqInputProc(
    ClientData instanceData,
    char *buf,
    int bufSize,
    int *errorCodePtr)
{
    return -1 ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqOutputProc(ClientData instanceData, char const *buf, int toWrite,
        int *errorCodePtr) ;

<<mq static function definitions>>=
static int
mqOutputProc(
    ClientData instanceData,
    char const *buf,
    int toWrite,
    int *errorCodePtr)
{
    return -1 ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqGetOptionProc(ClientData instanceData, Tcl_Interp *interp,
        char const *optionName, Tcl_DString *optionValue) ;

<<mq static function definitions>>=
static int
mqGetOptionProc(
    ClientData instanceData,
    Tcl_Interp *interp,
    char const *optionName,
    Tcl_DString *optionValue)
{
    return TCL_ERROR ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqSetOptionProc(ClientData instanceData, Tcl_Interp *interp,
        char const *optionName, char const *newValue) ;

<<mq static function definitions>>=
static int
mqSetOptionProc(
    ClientData instanceData,
    Tcl_Interp *interp,
    char const *optionName,
    char const *newValue)
{
    return TCL_ERROR ;
}
----

[source,c]
----
<<mq forward function declarations>>=
static void mqWatchProc(ClientData instanceData, int mask) ;

<<mq static function definitions>>=
static void
mqWatchProc(
    ClientData instanceData,
    int mask)
{
}
----

[source,c]
----
<<mq forward function declarations>>=
static int mqGetHandleProc(ClientData instanceData, int direction,
        ClientData *handlePtr) ;

<<mq static function definitions>>=
static int
mqGetHandleProc(
    ClientData instanceData,
    int direction,
    ClientData *handlePtr)
{
    return TCL_ERROR ;
}
----

// vim:set syntax=asciidoc:
