== Package Considerations

The `posixipc` package contains contains a single ensemble command
also named `posixipc`.
There are three sub-commands corresponding to the three POSIX IPC mechansims.
The sub-commands are:

mq::
    Commands for POSIX message queues.
sem::
    Commands for POSIX semaphores.
shm::
    Commands for POSIX share memory objects.

Each of the above sub-commands is also an ensemble command with
sub-commands for the specific operations.
The `posixipc` sub-commands are also exported from the `posixipc` namespace.
This allows selective importing to save the amount of typing required
for simple invocations.
For example,
the `mq` sub-commands can be invoked in two ways:

.Example mq command invocations
======
`posixipc mq open /foo`

`namespace import posixipc::mq`

`mq open /foo`
======

=== Package Initialization

The Tcl mechanism for dynamic loading uses a naming convention to
identify the initialization function to invoke to prepare the package
for use.
In our case,
the naming convension requires that
we supply a function named, `Posixipc_Init`.

The purpose of the initialization function is to define all the
commands supported by the package and then inform the interpreter
that the package is loaded and ready for use.

[source,c]
----
<<package external function definitions>>=
int
Posixipc_Init(
    Tcl_Interp *interp)
{
    /*
     * Stubs have to be initialized first.
     */
    if (Tcl_InitStubs(interp, TCL_VERSION, 0) == NULL) {
        return TCL_ERROR ;
    }
    /*
     * Create all the commands for the package.
     */
    <<create ipc commands>>
    /*
     * Support for package configuration.
     */
    Tcl_RegisterConfig(interp, posixipc_pkgname, posixipc_config, "utf-8") ;
    /*
     * Declare the package as now provided.
     */
    Tcl_PkgProvide(interp, posixipc_pkgname, posixipc_version) ;

    return TCL_OK ;

    /*
     * Error clean up.
     */
    <<shm error clean up>>
    <<sem error clean up>>
    <<mq error clean up>>
    <<ipc error clean up>>
}
----

==== Creating IPC Commands

Creating the IPC commands is a straight forward, albeit, rather tedious
set of Tcl API invocations.
We start with creating a namespace for the package,
followed by creating the commands for each type of IPC mechanism.
Finally, a namespace emsemble is used to provide access to the
entire set of mechanism commands.
This list of function invocations is packaged as a set of literate
program chunks to show the sequence.

[source,c]
----
<<create ipc commands>>=
<<create package namespace>>
<<create mq command>>
<<create sem command>>
<<create shm command>>
<<create ipc command ensemble>>
----

To create the package namespace,
we must supply its name.

[source,c]
----
<<create package namespace>>=
static char const pkgNamespace[] = PACKAGE_NS ;     // <1>
Tcl_Namespace *ipcNs = Tcl_CreateNamespace(interp, pkgNamespace, NULL, NULL) ;

Tcl_Obj *ipcMapObj = Tcl_NewDictObj() ;             // <2>
----
<1> The `PACKAGE_NS` macro is defined in the following section.
<2> Here and in the following,
we use a dictionary to accumulate the mapping for namespace ensembles.
We install the mapping as part of creating the ensemble commands
for each of the IPC mechanisms.
This technique allows the ensembles to be extended at the Tcl script level
if desired.

In the process of creating all the commands and namespaces,
we need some strings that can be pieced together from components.
These are used to form the fully qualified names for the commands.
To accomplish all this we use some pre-processor macros to emphasize
the naming pattern.

[source,c]
----
<<package macros>>=
#define DOUBLECOLON     "::"
#define PACKAGE_NS      DOUBLECOLON PACKAGE_NAME
#define CMD_NS(n)       PACKAGE_NS DOUBLECOLON #n

#define MQ_NS           CMD_NS(mq)
#define MQ_SUBCMD(c)    MQ_NS DOUBLECOLON #c

#define SEM_NS          CMD_NS(sem)
#define SEM_SUBCMD(c)   SEM_NS DOUBLECOLON #c

#define SHM_NS          CMD_NS(shm)
#define SHM_SUBCMD(c)   SHM_NS DOUBLECOLON #c
----

==== Creating the `mq` command

The following chunk establishes a pattern we use for the other
IPC commands.
For the `mq` command,
we create a namespace and a dictionary used to hold the ensemble
mapping.
Then, each sub-command of `mq` is created.
The sub-commands are just ordinary Tcl commands implemented as ``C'' functions.
The sub-commands are exported from the `mq` namespace and entered into
the ensemble mapping.

Finally, after all the sub-commands are in place,
the `mq` command is created as a namespace ensemble.
The accumulated mapping is installed on the ensemble command and
the resulting ensemble command is exported.

[source,c]
----
<<create mq command>>=
static char const mqNsName[] = MQ_NS ;
static char const mqStr[] = "mq" ;
/*
 * Create the namespace in which the sub-commands reside.
 */
Tcl_Namespace *mqNs = Tcl_CreateNamespace(interp, mqNsName, NULL, NULL) ;
/*
 * Create the ensemble mapping dictionary.
 */
Tcl_Obj *mqMapObj = Tcl_NewDictObj() ;

/*
 * mq open command
 */
static char const mqOpenCmdName[] = MQ_SUBCMD(open) ;
static char const openStr[] = "open" ;

Tcl_CreateObjCommand(interp, mqOpenCmdName, mqOpenCmd, NULL, NULL) ;
if (Tcl_Export(interp, mqNs, openStr, 0) != TCL_OK) {
    goto mqerror ;     // <1>
}
if (Tcl_DictObjPut(interp, mqMapObj, Tcl_NewStringObj(openStr, -1),
        Tcl_NewStringObj(mqOpenCmdName, -1)) != TCL_OK) {
    goto mqerror ;
}

/*
 * mq send command
 */
static char const mqSendCmdName[] = MQ_SUBCMD(send) ;
static char const sendStr[] = "send" ;

Tcl_CreateObjCommand(interp, mqSendCmdName, mqSendCmd, NULL, NULL) ;
if (Tcl_Export(interp, mqNs, sendStr, 0) != TCL_OK) {
    goto mqerror ;
}
if (Tcl_DictObjPut(interp, mqMapObj, Tcl_NewStringObj(sendStr, -1),
        Tcl_NewStringObj(mqSendCmdName, -1)) != TCL_OK) {
    goto mqerror ;
}

/*
 * mq recv command
 */
static char const mqRecvCmdName[] = MQ_SUBCMD(recv) ;
static char const recvStr[] = "recv" ;

Tcl_CreateObjCommand(interp, mqRecvCmdName, mqRecvCmd, NULL, NULL) ;
if (Tcl_Export(interp, mqNs, recvStr, 0) != TCL_OK) {
    goto mqerror ;
}
if (Tcl_DictObjPut(interp, mqMapObj, Tcl_NewStringObj(recvStr, -1),
        Tcl_NewStringObj(mqRecvCmdName, -1)) != TCL_OK) {
    goto mqerror ;
}

/*
 * mq unlink command
 */
static char const mqUnlinkCmdName[] = MQ_SUBCMD(unlink) ;
static char const unlinkStr[] = "unlink" ;

Tcl_CreateObjCommand(interp, mqUnlinkCmdName, mqUnlinkCmd, NULL, NULL) ;
if (Tcl_Export(interp, mqNs, unlinkStr, 0) != TCL_OK) {
    goto mqerror ;
}
if (Tcl_DictObjPut(interp, mqMapObj, Tcl_NewStringObj(unlinkStr, -1),
        Tcl_NewStringObj(mqUnlinkCmdName, -1)) != TCL_OK) {
    goto mqerror ;
}

/*
 * Create an ensemble command on the mq namespace.
 */
Tcl_Command mqEnsembleToken = Tcl_CreateEnsemble(interp, mqNsName, mqNs, 0) ;
if (Tcl_SetEnsembleMappingDict(interp, mqEnsembleToken, mqMapObj) != TCL_OK) {
    goto mqerror ;
}
/*
 * Export the newly created ensemble command.
 */
if (Tcl_Export(interp, ipcNs, mqStr, 0) != TCL_OK) {
    goto ipcerror ;
}
/*
 * Add the mq ensemble command to the mapping for the posixipc command.
 */
if (Tcl_DictObjPut(interp, ipcMapObj, Tcl_NewStringObj(mqStr, -1),
        Tcl_NewStringObj(mqNsName, -1)) != TCL_OK) {
    goto ipcerror ;
}
----
<1> Ok, let's get the ``go to'' thing out of the way early.
Yes, there are `goto` statements in the code.
But they are used very sparingly and in a specific way.
All the `goto` statements are always forward jumps in the code
(backward jumps using `goto` truly disrupt thinking about the program flow)
and are used only for error clean up.
With no exceptions in ``C'', a `goto` is often the cleanest way
to insure that allocated resources are cleaned up properly.
Yes, it can be done other ways, but those other ways always involve
either a lot of nesting or more variables or some abuse of the
pre-processor.
So, just get over any `goto` hysteria you may have.

==== Creating the `sem` command

The `sem` command follows the pattern established above for the
`mq` command.
We have a `sem` namespace.
Sub-commands are defined in that namespace and
finally, a namespace ensemble command called, `sem` is created.

[source,c]
----
<<create sem command>>=
static char const semNsName[] = SEM_NS ;
static char const semStr[] = "sem" ;

Tcl_Namespace *semNs = Tcl_CreateNamespace(interp, semNsName, NULL, NULL) ;
Tcl_Obj *semMapObj = Tcl_NewDictObj() ;

/*
 * sem open command
 */
static char const semOpenCmdName[] = SEM_SUBCMD(open) ;

Tcl_CreateObjCommand(interp, semOpenCmdName, semOpenCmd, NULL, NULL) ;
if (Tcl_Export(interp, semNs, openStr, 0) != TCL_OK) {
    goto semerror ;
}
if (Tcl_DictObjPut(interp, semMapObj, Tcl_NewStringObj(openStr, -1),
        Tcl_NewStringObj(semOpenCmdName, -1)) != TCL_OK) {
    goto semerror ;
}

/*
 * sem close command
 */
static char const semCloseCmdName[] = SEM_SUBCMD(close) ;
static char const closeStr[] = "close" ;

Tcl_CreateObjCommand(interp, semCloseCmdName, semCloseCmd, NULL, NULL) ;
if (Tcl_Export(interp, semNs, closeStr, 0) != TCL_OK) {
    goto semerror ;
}
if (Tcl_DictObjPut(interp, semMapObj, Tcl_NewStringObj(closeStr, -1),
        Tcl_NewStringObj(semCloseCmdName, -1)) != TCL_OK) {
    goto semerror ;
}

/*
 * sem post command
 */
static char const semPostCmdName[] = SEM_SUBCMD(post) ;
static char const postStr[] = "post" ;

Tcl_CreateObjCommand(interp, semPostCmdName, semPostCmd, NULL, NULL) ;
if (Tcl_Export(interp, semNs, postStr, 0) != TCL_OK) {
    goto semerror ;
}
if (Tcl_DictObjPut(interp, semMapObj, Tcl_NewStringObj(postStr, -1),
        Tcl_NewStringObj(semPostCmdName, -1)) != TCL_OK) {
    goto semerror ;
}

/*
 * sem wait command
 */
static char const semWaitCmdName[] = SEM_SUBCMD(wait) ;
static char const waitStr[] = "wait" ;

Tcl_CreateObjCommand(interp, semWaitCmdName, semWaitCmd, NULL, NULL) ;
if (Tcl_Export(interp, semNs, waitStr, 0) != TCL_OK) {
    goto semerror ;
}
if (Tcl_DictObjPut(interp, semMapObj, Tcl_NewStringObj(waitStr, -1),
        Tcl_NewStringObj(semWaitCmdName, -1)) != TCL_OK) {
    goto semerror ;
}

/*
 * sem unlink command
 */
static char const semUnlinkCmdName[] = SEM_SUBCMD(unlink) ;

Tcl_CreateObjCommand(interp, semUnlinkCmdName, semUnlinkCmd, NULL, NULL) ;
if (Tcl_Export(interp, semNs, unlinkStr, 0) != TCL_OK) {
    goto semerror ;
}
if (Tcl_DictObjPut(interp, semMapObj, Tcl_NewStringObj(unlinkStr, -1),
        Tcl_NewStringObj(semUnlinkCmdName, -1)) != TCL_OK) {
    goto semerror ;
}

Tcl_Command semEnsembleToken = Tcl_CreateEnsemble(interp, semNsName, semNs, 0) ;
if (Tcl_SetEnsembleMappingDict(interp, semEnsembleToken, semMapObj) != TCL_OK) {
    goto semerror ;
}
if (Tcl_Export(interp, ipcNs, semStr, 0) != TCL_OK) {
    goto ipcerror ;
}
if (Tcl_DictObjPut(interp, ipcMapObj, Tcl_NewStringObj(semStr, -1),
        Tcl_NewStringObj(semNsName, -1)) != TCL_OK) {
    goto ipcerror ;
}
----

==== Creating the `shm` command

[source,c]
----
<<create shm command>>=
static char const shmNsName[] = SHM_NS ;
static char const shmStr[] = "shm" ;
/*
 * Create the namespace in which the sub-commands reside.
 */
Tcl_Namespace *shmNs = Tcl_CreateNamespace(interp, shmNsName, NULL, NULL) ;
/*
 * Create the ensemble mapping dictionary.
 */
Tcl_Obj *shmMapObj = Tcl_NewDictObj() ;

/*
 * shm open command
 */
static char const shmOpenCmdName[] = SHM_SUBCMD(open) ;

Tcl_CreateObjCommand(interp, shmOpenCmdName, shmOpenCmd, NULL, NULL) ;
if (Tcl_Export(interp, shmNs, openStr, 0) != TCL_OK) {
    goto shmerror ;     // <1>
}
if (Tcl_DictObjPut(interp, shmMapObj, Tcl_NewStringObj(openStr, -1),
        Tcl_NewStringObj(shmOpenCmdName, -1)) != TCL_OK) {
    goto shmerror ;
}

/*
 * shm unlink command
 */
static char const shmUnlinkCmdName[] = SHM_SUBCMD(unlink) ;

Tcl_CreateObjCommand(interp, shmUnlinkCmdName, shmUnlinkCmd, NULL, NULL) ;
if (Tcl_Export(interp, shmNs, unlinkStr, 0) != TCL_OK) {
    goto shmerror ;
}
if (Tcl_DictObjPut(interp, shmMapObj, Tcl_NewStringObj(unlinkStr, -1),
        Tcl_NewStringObj(shmUnlinkCmdName, -1)) != TCL_OK) {
    goto shmerror ;
}

Tcl_Command shmEnsembleToken = Tcl_CreateEnsemble(interp, shmNsName, shmNs, 0) ;
if (Tcl_SetEnsembleMappingDict(interp, shmEnsembleToken, shmMapObj) != TCL_OK) {
    goto shmerror ;
}
if (Tcl_Export(interp, ipcNs, shmStr, 0) != TCL_OK) {
    goto ipcerror ;
}
if (Tcl_DictObjPut(interp, ipcMapObj, Tcl_NewStringObj(shmStr, -1),
        Tcl_NewStringObj(shmNsName, -1)) != TCL_OK) {
    goto ipcerror ;
}
----

==== Creating the `posixipc` command

Finally, after we have created all the IPC commands and their sub-commands,
we can create the top level namespace ensemble command for the package.
We install the mapping dictionary that has been accumulated for the
three sub-commands in the package ensemble.

[source,c]
----
<<create ipc command ensemble>>=
Tcl_Command ipcCmdToken = Tcl_CreateEnsemble(interp, pkgNamespace, ipcNs, 0) ;
if (Tcl_SetEnsembleMappingDict(interp, ipcCmdToken, ipcMapObj) != TCL_OK) {
    goto ipcerror ;
}
----

==== Error clean up

We must be careful to clean up any acquired resources in the face of
errors.
In our case,
we must deal with the dictionary objects that are used to accumulate
the namespace ensemble command mappings.

Also, in the case of any failure, we just delete the namespace
that contains the package level ensemble command and all the children
and associated commands will disappear.

[source,c]
----
<<ipc error clean up>>=
ipcerror:
    Tcl_DecrRefCount(ipcMapObj) ;
    Tcl_DeleteNamespace(ipcNs) ;
    return TCL_ERROR ;
----

[source,c]
----
<<mq error clean up>>=
mqerror:
    Tcl_DecrRefCount(mqMapObj) ;
    goto ipcerror ;
----

[source,c]
----
<<sem error clean up>>=
semerror:
    Tcl_DecrRefCount(semMapObj) ;
    goto ipcerror ;
----

[source,c]
----
<<shm error clean up>>=
shmerror:
    Tcl_DecrRefCount(shmMapObj) ;
    goto ipcerror ;
----

=== Safe Interpreters

[source,c]
----
<<package external function definitions>>=
int
Posixipc_SafeInit(
    Tcl_Interp *interp)
{
    return TCL_ERROR ;      // <1>
}
----
<1> Since we are dealing with I/O between processes, this is *not*
a capability given to safe interpreters.

=== Package Unloading

[source,c]
----
<<package external function definitions>>=
#if TCL_MAJOR_VERSION >= 8 && TCL_MINOR_VERSION >= 5
int
Posixipc_Unload(
    Tcl_Interp *interp)
{
    // HERE!
    return TCL_OK ;
}
#endif
----

[source,c]
----
<<package external function definitions>>=
#if TCL_MAJOR_VERSION >= 8 && TCL_MINOR_VERSION >= 5
int
Posixipc_SafeUnload(
    Tcl_Interp *interp)
{
    return TCL_ERROR ;
}
#endif
----

=== Package Configuration Information

[source,c]
----
<<package static data>>=
static char const posixipc_pkgname[] = PACKAGE_NAME ;
static char const posixipc_version[] = PACKAGE_VERSION ;
static char const posixipc_copyright[] =
    "This software is copyrighted 2018 by G. Andrew Mangogna."
    " Terms and conditions for use are distributed with the source code." ;

static Tcl_Config posixipc_config[] = {
    {"pkgname", posixipc_pkgname},
    {"version", posixipc_version},
    {"copyright", posixipc_copyright},
    {NULL, NULL}
} ;
----

// vim:set syntax=asciidoc:
