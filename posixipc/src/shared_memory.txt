== Shared Memory
Shared Memory
In what follows, we present the Tcl channel driver functions first,
followed by the Tcl level commands.

=== Shared Memory Channel Driver

In this section we present the channel driver for the POSIX shared
memory type channel.

==== Channel Driver Components

In this section,
we describe the functions supplied for the Tcl channel driver that
is used for POSIX shared memory.

The following is an initialized variable of the proper structure
that is given to `Tcl_CreateChannel()` to define the shared memory operations.

[source,c]
----
<<shm static data>>=
static Tcl_ChannelType ShmChannelType = {
    .typeName = "shm",          /* The name of the channel type in Tcl
                                 * commands. This storage is owned by channel
                                 * type. */
    .version = TCL_CHANNEL_VERSION_5,
                                /* Version of the channel type. */
    .closeProc = shmCloseProc,
                                /* Function to call to close the channel, or
                                 * TCL_CLOSE2PROC if the close2Proc should be
                                 * used instead. */
    .inputProc = shmInputProc,
                                /* Function to call for input on channel. */
    .outputProc = shmOutputProc,
                                /* Function to call for output on channel. */
    .seekProc = shmSeekProc,
                                /* Function to call to seek on the channel.
                                 * May be NULL. */
    .setOptionProc = NULL,
                                /* Set an option on a channel. */
    .getOptionProc = NULL,
                                /* Get an option from a channel. */
    .watchProc = shmWatchProc,
                                /* Set up the notifier to watch for events on
                                 * this channel. */
    .getHandleProc = shmGetHandleProc,
                                /* Get an OS handle from the channel or NULL
                                 * if not supported. */
    .close2Proc = NULL,
                                /* Function to call to close the channel if
                                 * the device supports closing the read &
                                 * write sides independently. */
    .blockModeProc = shmBlockModeProc,
                                /* Set blocking mode for the raw channel. May
                                 * be NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_2 channels or later
     */
    .flushProc = NULL,
                                /* Function to call to flush a channel. May be
                                 * NULL. */
    .handlerProc = NULL,
                                /* Function to call to handle a channel event.
                                 * This will be passed up the stacked channel
                                 * chain. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_3 channels or later
     */
    .wideSeekProc = NULL,
                                /* Function to call to seek on the channel
                                 * which can handle 64-bit offsets. May be
                                 * NULL, and must be NULL if seekProc is
                                 * NULL. */
    /*
     * Only valid in TCL_CHANNEL_VERSION_4 channels or later
     * TIP #218, Channel Thread Actions
     */
    .threadActionProc = NULL,
                                /* Function to call to notify the driver of
                                 * thread specific activity for a channel. May
                                 * be NULL. */

    /*
     * Only valid in TCL_CHANNEL_VERSION_5 channels or later
     * TIP #208, File Truncation
     */
    .truncateProc = NULL
                                /* Function to call to truncate the underlying
                                 * file to a particular length. May be NULL if
                                 * the channel does not support truncation. */
} ;
----

Notice that not all functions are provided (_i.e._ some members of the
structure are set to `NULL`).
Those members are:

setOptionProc::
    There are no channel type specific options that can be written.
getOptionProc::
    There are no channel type specific options that can be read.
close2Proc::
    For shared memory,
    the idea of closing read or write separately does not apply.
flushProc::
    This is reserved.
handlerProc::
    Used only for stacked drivers.
wideSeekProc::
    We assume shared memory areas are less than 2 GiBytes so wide seeking
    is not necessary.
threadActionProc::
    There is no thread specific driver state.
truncateProc::
    Once created, the size of a shared memory object underlying
    the channel is not changed.

When a new shared memory Tcl channel is created,
some instance data for the channel may also be supplied.
That instance data is then provided as an argument to each of the
functions for the driver.
This makes things much more convenient for the driver function code
to have access to the state of the channel.
The following data structure defines the information that constitutes
the state of an individual shared memory channel.

[source,c]
----
<<shm data types>>=
typedef struct {
    Tcl_Channel channel ;       // <1>
    int shmfd ;                 // <2>
    sem_t *semaphore ;          // <3>
    int tclMask ;               // <4>
    int blockingMode ;          // <5>
    uint8_t *address ;          // <6>
    size_t length ;             // <7>
    size_t position ;           // <8>
} ShmState ;
----
<1> The Tcl channel handle as returned from `Tcl_CreateChannel()`.
<2> The shared memory descriptor. In reality on Linux this is
    an ordinary file descriptor.
<3> The semaphore used to control exclusive access to the shared memory.
<4> A mask of allowed operations on the channel.
    This is combination of TCL_READABLE or TCL_WRITABLE.
<5> The current state of blocking mode for the channel.
<6> The address in memory where the shared memory area is located.
<7> The length in bytes of the shared memory area.
<8> The current position in the shared memory area where the next
    read or write will occur.

The following sections describe each of the functions supplied as part
of the shared memory channel driver.

===== Close procedure

[source,c]
----
<<shm forward function declarations>>=
static int shmCloseProc(ClientData instanceData, Tcl_Interp *interp) ;
----

[source,c]
----
<<shm static function definitions>>=
static int
shmCloseProc(
    ClientData instanceData,
    Tcl_Interp *interp)
{
    ShmState *shmData = instanceData ;

    Tcl_DeleteFileHandler(shmData->shmfd) ;

    int resultCode = 0 ;

    int syserr = munmap(shmData->address, shmData->length) ;
    if (syserr < 0) {
        resultCode = errno ;
        goto errorout ;
    }

    syserr = close(shmData->shmfd) ;
    if (syserr < 0) {
        resultCode = errno ;
        goto errorout ;
    }

    syserr = sem_close(shmData->semaphore) ;
    if (syserr < 0) {
        resultCode = errno ;
        goto errorout ;
    }

errorout:
    ckfree(shmData) ;
    return resultCode ;
}
----

===== Input procedure

[source,c]
----
<<shm forward function declarations>>=
static int shmInputProc(ClientData instanceData, char *buf, int bufSize,
        int *errorCodePtr) ;
----

[source,c]
----
<<shm static function definitions>>=
static int
shmInputProc(
    ClientData instanceData,
    char *buf,
    int bufSize,
    int *errorCodePtr)
{
    ShmState *shmData = instanceData ;

    <<shm: lock semaphore>>

    size_t remaining = shmData->length - shmData->position ;
    int toRead = bufSize < remaining ? bufSize : remaining ;

    memcpy(buf, shmData->address + shmData->position, toRead) ;
    shmData->position += toRead ;

    <<shm: unlock semaphore>>

    return toRead ;
}
----

[source,c]
----
<<shm: lock semaphore>>=
int syserr ;
if (shmData->blockingMode == TCL_MODE_NONBLOCKING) {
    syserr = sem_trywait(shmData->semaphore) ;
    if (syserr == -1) {
        *errorCodePtr = errno ;
        return errno == EAGAIN ? EAGAIN : -1 ;
    }
} else {
    syserr = sem_wait(shmData->semaphore) ;
    if (syserr == -1) {
        *errorCodePtr = errno ;
        return -1 ;
    }
}
----

[source,c]
----
<<shm: unlock semaphore>>=
syserr = sem_post(shmData->semaphore) ;
if (syserr == -1) {
    *errorCodePtr = errno ;
    return -1 ;
}
----

===== Output procedure

[source,c]
----
<<shm forward function declarations>>=
static int shmOutputProc(ClientData instanceData, char const *buf, int toWrite,
        int *errorCodePtr) ;
----

[source,c]
----
<<shm static function definitions>>=
static int
shmOutputProc(
    ClientData instanceData,
    char const *buf,
    int toWrite,
    int *errorCodePtr)
{
    ShmState *shmData = instanceData ;

    <<shm: lock semaphore>>

    size_t available = shmData->length - shmData->position ;
    int canWrite = toWrite < available ? toWrite : available ;

    memcpy(shmData->address + shmData->position, buf, canWrite) ;
    shmData->position += canWrite ;

    <<shm: unlock semaphore>>

    return canWrite ;
}
----

===== Seek procedure

[source,c]
----
<<shm forward function declarations>>=
static int shmSeekProc(ClientData instanceData, long offset, int seekMode,
        int *errorCodePtr) ;
----

[source,c]
----
<<shm static function definitions>>=
static int
shmSeekProc(
    ClientData instanceData,
    long offset,
    int seekMode,
    int *errorCodePtr)
{
    ShmState *shmData = instanceData ;

    off_t start ;
    switch (seekMode) {
    case SEEK_SET:
        start = 0 ;
        break ;

    case SEEK_CUR:
        start = shmData->position ;
        break ;

    case SEEK_END:
        start = shmData->length - 1 ;
        break ;

    default:
        Tcl_Panic("unknown seek mode") ;
        break ;
    }

    off_t newPosition = start + offset ;
    if (newPosition < 0 || newPosition >= shmData->length) {
        *errorCodePtr = EINVAL ;
        return -1 ;
    }

    shmData->position = newPosition ;
    return newPosition ;
}
----

===== Watch procedure

[source,c]
----
<<shm forward function declarations>>=
static void shmWatchProc(ClientData instanceData, int mask) ;
----

[source,c]
----
<<shm static function definitions>>=
static void
shmWatchProc(
    ClientData instanceData,
    int mask)
{
    ShmState *shmData = instanceData ;

    mask &= shmData->tclMask ;
    if (mask != 0) {
        Tcl_CreateFileHandler(shmData->shmfd, mask,
                (Tcl_FileProc *)Tcl_NotifyChannel, shmData->channel) ;
    } else {
        Tcl_DeleteFileHandler(shmData->shmfd) ;
    }
}
----

===== Get handle procedure

[source,c]
----
<<shm forward function declarations>>=
static int shmGetHandleProc(ClientData instanceData, int direction,
        ClientData *handlePtr) ;
----

[source,c]
----
<<shm static function definitions>>=
static int
shmGetHandleProc(
    ClientData instanceData,
    int direction,
    ClientData *handlePtr)
{
    ShmState *shmData = instanceData ;

    if ((direction & shmData->tclMask) == 0) {
        return TCL_ERROR ;
    }

    *handlePtr = (ClientData)(intptr_t)(shmData->shmfd) ;
    return TCL_OK ;
}
----

===== Block mode procedure
    .blockModeProc = shmBlockModeProc,

[source,c]
----
<<shm forward function declarations>>=
static int shmBlockModeProc(ClientData instanceData, int mode) ;
----

[source,c]
----
<<shm static function definitions>>=
static int
shmBlockModeProc(
    ClientData instanceData,
    int mode)
{
    ShmState *shmData = instanceData ;

    shmData->blockingMode = mode ;

    return 0 ;
}
----

[source,c]
----
<<mq external functions definitions>>=
Tcl_Channel
PosixIPC_OpenSHMChannel(
    Tcl_Interp *interp,
    Tcl_Obj *name,
    char const *mode,
    mode_t permissions,
    size_t size)
{
    int flags = 0 ;
    int tclMask = 0 ;
    bool bintrans = false ;

    if (islower(*mode)) {
        if (processFopenModeOption(interp, mode, &flags, &tclMask, &bintrans) !=
                TCL_OK) {
            return NULL ;
        }
    } else {
        if (processOpenModeOption(interp, mode, &flags, &tclMask, &bintrans) !=
                TCL_OK) {
            return NULL ;
        }
    }

    int syserr ;
    char const *qname = Tcl_GetString(name) ;

    <<OpenSHMChannel: open semaphore>>
    <<OpenSHMChannel: open shared memory>>

    Tcl_Channel shmChan ;
    <<OpenSHMChannel: create shared memory channel>>

    <<OpenSHMChannel: set translation option>>

    return shmChan ;

chanerror:
    Tcl_Close(interp, shmChan) ;
    return NULL ;
}
----

[source,c]
----
<<OpenSHMChannel: open semaphore>>=
int semflags = flags & (O_CREAT | O_EXCL) ;
sem_t *shmsem = sem_open(qname, semflags, permissions, 1) ;
if (shmsem == SEM_FAILED) {
    shmFailure(interp, "cannot open exclusive access semaphore") ;
    return NULL ;
}
----

[source,c]
----
<<OpenSHMChannel: open shared memory>>=
if ((flags & O_CREAT) != 0 && size == 0) {
    if (interp != NULL) {
        Tcl_SetObjResult(interp,
                Tcl_ObjPrintf("cannot create zero sized shared memory")) ;
    }
    return NULL ;
}

int shmfd = shm_open(qname, flags, permissions) ;
if (shmfd < 0) {
    shmFailure(interp, qname) ;
    return NULL ;
}

struct stat shmStatus ;
syserr = fstat(shmfd, &shmStatus) ;
if (syserr < 0) {
    shmFailure(interp, "cannot get status of shared memory") ;
    close(shmfd) ;
}

if (shmStatus.st_size == 0) {
    int syserr = ftruncate(shmfd, size) ;
    if (syserr < 0) {
        shmFailure(interp, "cannot set size of shared memory") ;
        close(shmfd) ;
        return NULL ;
    }
} else {
    size = shmStatus.st_size ;
}
----

[source,c]
----
<<OpenSHMChannel: create shared memory channel>>=
char chanName[TCL_INTEGER_SPACE + 16] ;
snprintf(chanName, sizeof(chanName), "posixshm%d", shmfd) ;

ShmState *shmdata = ckalloc(sizeof(ShmState)) ;
shmdata->shmfd = shmfd ;
shmdata->semaphore = shmsem ;
shmdata->tclMask = tclMask ;
shmdata->length = size ;
shmdata->position = 0 ;

int mapProt = 0 ;
mapProt |= (tclMask & TCL_READABLE) != 0 ? PROT_READ : 0 ;
mapProt |= (tclMask & TCL_WRITABLE) != 0 ? PROT_WRITE : 0 ;

shmdata->address = mmap(NULL, size, mapProt, MAP_SHARED, shmfd, 0) ;
if (shmdata->address == MAP_FAILED) {
    shmFailure(interp, qname) ;
    close(shmfd) ;
    ckfree(shmdata) ;
    return NULL ;
}


shmChan = Tcl_CreateChannel(&ShmChannelType, chanName, shmdata, tclMask) ;
shmdata->channel = shmChan ;
----

If the channel was opened in binary mode,
we need to instruct the Tcl channel system to set the translation properly.

[source,c]
----
<<OpenSHMChannel: set translation option>>=
if (bintrans) {
    if (Tcl_SetChannelOption(interp, shmChan, "-translation", "binary") !=
            TCL_OK) {
        goto chanerror ;
    }
}
----

[source,c]
----
<<shm forward function declarations>>=
static int shmFailure(Tcl_Interp *interp, char const *msg) ;
----

Since it is a system call that has failed,
we need a reasonable error message and must make sure to set Tcl's
notion of `errno` indicating the cause of the error.

[source,c]
----
<<mq static function definitions>>=
static int
shmFailure(
    Tcl_Interp *interp,
    char const *msg)
{
    return ipcFailure(interp, "shm", msg) ;
}
----

=== SHM Commands
SHM Commands

==== shm open command

[source,c]
----
<<shm forward function declarations>>=
static int shmOpenCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
----

[source,c]
----
<<shm static function definitions>>=
static int
shmOpenCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    static char const usage[] = "?options? sharedname ?access? ?permissions?" ;
    if (objc < 2) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }

    <<shmOpenCmd: establish default option values>>

    <<shmOpenCmd: parse options arguments>>

    <<shmOpenCmd: gather remaining arguments>>

    <<shmOpenCmd: create channel>>

    return TCL_OK ;
}
----

[source,c]
----
<<shmOpenCmd: establish default option values>>=
char const *mode = "r" ;
mode_t permissions = 0666 ;
size_t shmSize = 0 ;
----

[source,c]
----
<<shmOpenCmd: parse options arguments>>=
int objindex = 1 ;
for ( ; objindex < objc ; objindex++) {
    char const *optionName = Tcl_GetString(objv[objindex]) ;
    if (strcmp(optionName, "--") == 0) {
        objindex++ ;
        break ;
    } else if (strcmp(optionName, "-size") == 0) {
        if (++objindex >= objc) {
            Tcl_WrongNumArgs(interp, 1, objv, usage) ;
            return TCL_ERROR ;
        }
        int size ;
        if (Tcl_GetIntFromObj(interp, objv[objindex], &size) != TCL_OK) {
            return TCL_ERROR ;
        }
        if (size <= 0) {
            Tcl_SetObjResult(interp,
                    Tcl_ObjPrintf("shared memory size must be positive")) ;
            return TCL_ERROR ;
        }
        shmSize = size ;
    } else {
        break ;
    }
}
----

[source,c]
----
<<shmOpenCmd: gather remaining arguments>>=
int remain = objc - objindex ;
if (remain < 1 || remain > 3) {
    Tcl_WrongNumArgs(interp, 1, objv, usage) ;
    return TCL_ERROR ;
}

if (remain > 1) {
    mode = Tcl_GetString(objv[objindex + 1]) ;
}

if (remain == 3) {
    int permArgValue ;
    if (Tcl_GetIntFromObj(interp, objv[objindex + 2], &permArgValue)
            != TCL_OK) {
        return TCL_ERROR ;
    }
    permissions = permArgValue ;
}
----

[source,c]
----
<<shmOpenCmd: create channel>>=
Tcl_Channel chan = PosixIPC_OpenSHMChannel(interp, objv[objindex], mode,
        permissions, shmSize) ;
if (chan == NULL) {
    return TCL_ERROR ;
}
Tcl_RegisterChannel(interp, chan) ;
Tcl_SetObjResult(interp, Tcl_NewStringObj(Tcl_GetChannelName(chan), -1)) ;
----

.Tests
[source,tcl]
----
<<shm tests>>=
test shm-open-1.0 {
    Open a shared memory object
} -setup {
    set shmName /shm_open_1.0
} -cleanup {
    chan close $shmchan
    posixipc shm unlink $shmName
} -body {
    set shmchan [posixipc shm open -size 256 $shmName w+]
    log::debug "shm channel = $shmchan"
    return $shmchan
} -result {posixshm[0-9]*} -match glob
----

[source,tcl]
----
<<shm tests>>=
test shm-open-2.0 {
    Open shared memory, write and read
} -setup {
    set shmName /shm_open_2.0
} -cleanup {
    chan close $shmchan
    posixipc shm unlink $shmName
} -body {
    set shmchan [posixipc shm open -size 256 -- $shmName w+]
    log::debug "shm channel = $shmchan"
    chan configure $shmchan -buffering line
    chan puts $shmchan "Hello World"
    chan seek $shmchan 0
    chan gets $shmchan
} -result {Hello World}
----

==== shm unlink command

[source,c]
----
<<shm forward function declarations>>=
static int shmUnlinkCmd(ClientData clientData, Tcl_Interp *interp, int objc,
        Tcl_Obj *const objv[]) ;
----

[source,c]
----
<<shm static function definitions>>=
static int
shmUnlinkCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int objc,
    Tcl_Obj *const objv[])
{
    static char const usage[] = "sharedname" ;
    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 1, objv, usage) ;
        return TCL_ERROR ;
    }

    char const *shmname = Tcl_GetString(objv[1]) ;

    int shmerr = shm_unlink(shmname) ;
    int semerr = sem_unlink(shmname) ;

    if (shmerr < 0 || semerr < 0) {
        return shmFailure(interp, shmname) ;
    }

    return TCL_OK ;
}
----

// vim:set syntax=asciidoc:
