#
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2018 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger
package require logger::utils
package require logger::appender
package require tcltest

# Add custom arguments here.
set optlist {
    {level.arg warn {Logging level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]
tcltest::configure {*}$argv

logger::setlevel $options(level)

if {$::tcl_platform(os) eq "Linux"} {
    load ../tea/build/x86_64-linux-tcl8.6/libposixipc1.0.so
} else {
    package require posixipc
}

namespace eval ::posixipc::test {
    namespace import ::tcltest::*

    testConstraint linuxOnly [expr {$::tcl_platform(os) eq "Linux" ?\
            "true" : "false"}]

    set logger [::logger::init posixipc]
    ::logger::utils::applyAppender -appender colorConsole -serviceCmd $logger\
            -appenderArgs {-conversionPattern {\[%c\] \[%p\] '%m'}}
    ::logger::import -all -force -namespace log posixipc
    log::info "testing posixipc version: [package require posixipc]"

    variable mqFSMount
    if {[file exists /dev/mqueue]} {
        set mqFSMount /dev/mqueue
    } elseif {[file exists /mnt/mqueue]} {
        set mqFSMount /mnt/mqueue
    }

    test package-commands-2.1 {
        Check that posixipc::mq::open was created
    } -setup {
    } -cleanup {
    } -body {
        info commands ::posixipc::mq::open
    } -result {::posixipc::mq::open}
    test package-commands-2.2 {
        Check that posixipc::mq::send was created
    } -setup {
    } -cleanup {
    } -body {
        info commands ::posixipc::mq::send
    } -result {::posixipc::mq::send}
    test package-commands-2.3 {
        Check that posixipc::mq::receive was created
    } -setup {
    } -cleanup {
    } -body {
        info commands ::posixipc::mq::receive
    } -result {::posixipc::mq::receive}
    test package-commands-2.4 {
        Check that posixipc::mq::unlink was created
    } -setup {
    } -cleanup {
    } -body {
        info commands ::posixipc::mq::unlink
    } -result {::posixipc::mq::unlink}
    test package-commands-2.0.1 {
        Check that posixipc::mq is a namespace ensemble command
    } -setup {
    } -cleanup {
    } -body {
        namespace ensemble exists posixipc::mq
    } -result {1}
    test package-commands-2.0.2 {
        Verify the ensemble mapping for the mq command
    } -setup {
    } -cleanup {
    } -body {
        namespace ensemble configure posixipc::mq -map
    } -result {open ::posixipc::mq::open send ::posixipc::mq::send receive ::posixipc::mq::receive unlink ::posixipc::mq::unlink}
    test package-commands-2.0.3 {
        Check that posixipc::mq is exported
    } -setup {
    } -cleanup {
        namespace forget ::posixipc::mq
    } -body {
        namespace import ::posixipc::mq
        namespace origin mq
    } -result {::posixipc::mq}
    test package-commands-4.0 {
        Check that posixipc::shm::open was created
    } -setup {
    } -cleanup {
    } -body {
        info commands ::posixipc::shm::open
    } -result {::posixipc::shm::open}
    test package-commands-4.1 {
        Check that posixipc::shm::unlink was created
    } -setup {
    } -cleanup {
    } -body {
        info commands ::posixipc::shm::unlink
    } -result {::posixipc::shm::unlink}
    test package-commands-4.2.0 {
        Check that posixipc::shm is a namespace ensemble command
    } -setup {
    } -cleanup {
    } -body {
        namespace ensemble exists posixipc::shm
    } -result {1}
    test package-commands-4.2.1 {
        Verify the ensemble mapping for the shm command
    } -setup {
    } -cleanup {
    } -body {
        namespace ensemble configure posixipc::shm -map
    } -result {open ::posixipc::shm::open unlink ::posixipc::shm::unlink}
    test package-commands-4.2.2 {
        Check that posixipc::shm is exported
    } -setup {
    } -cleanup {
        namespace forget ::posixipc::shm
    } -body {
        namespace import ::posixipc::shm
        namespace origin shm
    } -result {::posixipc::shm}
    test package-commands-1.0 {
        Check that posixipc is a namespace ensemble command
    } -setup {
    } -cleanup {
    } -body {
        namespace ensemble exists posixipc
    } -result {1}
    test package-configuration-1.0 {
        Check that all the configuration info keys are present
    } -setup {
    } -cleanup {
    } -body {
        posixipc::pkgconfig list
    } -result {pkgname version copyright}
    test package-configuration-2.0 {
        Check package name from the configuration
    } -setup {
    } -cleanup {
    } -body {
        posixipc::pkgconfig get pkgname
    } -result {posixipc}
    test package-configuration-3.0 {
        Check package version from the configuration
    } -setup {
    } -cleanup {
    } -body {
        posixipc::pkgconfig get version
    } -result {1.0}
    test package-configuration-4.0 {
        Check package copyright info from the configuration
    } -setup {
    } -cleanup {
    } -body {
        posixipc::pkgconfig get copyright
    } -result {This software is copyrighted 2018 by G. Andrew Mangogna.\
    Terms and conditions for use are distributed with the source code.}

    namespace import ::posixipc::mq
    test mq-input-1.0 {
        Read in non-blocking mode when queue is empty
    } -setup {
        set queueName /mq-input-1.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName {CREAT EXCL RDWR NONBLOCK}]
        log::debug "mq channel = $mqchan"
        set nread [chan read $mqchan 1]
        log::debug "nread, \"$nread\""
        log::debug "nread length = [string length $nread]"
        set eof [chan eof $mqchan]
        log::debug "eof = $eof"
        return [expr {($nread eq {}) && !$eof}]
    } -result {1}
    test mq-output-1.0 {
        Write in non-blocking mode when queue is full
    } -setup {
        set queueName /mq-output-1.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open -maxmsg 1 $queueName {CREAT EXCL RDWR NONBLOCK}]
        log::debug "mq channel = $mqchan"
        chan configure $mqchan -buffering line
        chan puts $mqchan "Hello 1"
        set second "Hello 2"
        chan puts $mqchan $second
        set pending [chan pending output $mqchan]
        return [expr {$pending == [string length $second] + 1}] ; # +1 for newline
    } -result {1}
    test mq-get-option-1.0 {
        Get message queue options one at a time
    } -setup {
        set queueName /mq-get-option-1.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
    
        set optionNames {-curmsgs -lastpriority -maxmsg -msgsize -priority}
        foreach opt $optionNames {
            set optValue($opt) [chan configure $mqchan $opt]
            log::debug "$opt = $optValue($opt)"
        }
    
        array set optExpected {
            -curmsgs 0
            -lastpriority 0
            -maxmsg 10
            -msgsize 8192
            -priority 0
        }
    
        foreach opt $optionNames {
            if {$optValue($opt) != $optExpected($opt)} {
                return 0 ;
            }
        }
        return 1
    } -result {1}
    test mq-get-option-2.0 {
        Bad option name
    } -setup {
        set queueName /mq-get-option-2.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
    
        chan configure $mqchan -foo
    } -result {bad option "-foo": should be one of -blocking, -buffering,\
            -buffersize, -encoding, -eofchar, -translation, -curmsgs,\
            -lastpriority, -maxmsg, -msgsize, or -priority}\
        -returnCodes error
    test mq-get-option-3.0 {
        Get all options for a message queue in one command
    } -setup {
        set queueName /mq-get-option-3.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
    
        set opts [chan configure $mqchan]
        log::debug "option = $opts"
        return [dict get $opts -msgsize]
    } -result {8192}
    test mq-set-option-1.0 {
        Set / get priority option on open queue
    } -setup {
        set queueName /mq-set-option-1.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
        chan configure $mqchan -priority 20
        chan configure $mqchan -priority
    } -result {20}
    test mq-set-option-1.1 {
        Set priority option to negative number
    } -setup {
        set queueName /mq-set-option-1.1
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
        chan configure $mqchan -priority -20
    } -result {posixipc mq: set option: invalid negative message priority: -20}\
      -returnCodes error
    test mq-set-option-2.0 {
        Attempt to set create time option
    } -setup {
        set queueName /mq-set-option-2.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
        chan configure $mqchan -msgsize 128
    } -result {posixipc mq: set option: -msgsize option may not be set by\
            configuration}\
      -returnCodes error
    test mq-set-option-3.0 {
        Attempt to set bad option
    } -setup {
        set queueName /mq-set-option-3.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
        chan configure $mqchan -foo 128
    } -result {bad option "-foo": should be one of -blocking, -buffering,\
        -buffersize, -encoding, -eofchar, -translation, -curmsgs, -lastpriority,\
        -maxmsg, -msgsize, or -priority}\
      -returnCodes error
    test fopen-mode-1.0 {
        Open the message queue in "w" mode
    } -setup {
        set queueName /fopen-mode-1.0
        set queueFile $mqFSMount$queueName
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w]
        log::debug "mq channel = $mqchan"
    
        set fattrs [file attributes $queueFile]
        log::debug "mq file attributes = $fattrs"
        set rightUser [expr {[dict get $fattrs -owner] eq $::tcl_platform(user)}]
    
        set exists [file exists $queueFile]
    
        return [expr {$rightUser && $exists}]
    } -result {1}
    test fopen-mode-1.1 {
        Open the message queue in "wb+" mode
    } -setup {
        set queueName /fopen-mode-1.1
        set queueFile $mqFSMount$queueName
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName wb+]
        log::debug "mq channel = $mqchan"
    
        set fattrs [file attributes $queueFile]
        log::debug "mq file attributes = $fattrs"
        set rightUser [expr {[dict get $fattrs -owner] eq $::tcl_platform(user)}]
    
        set exists [file exists $queueFile]
    
        set trans [chan configure $mqchan -translation]
        log::debug "translation = \"$trans\""
        set isBinary [expr {$trans eq "lf lf"}]
    
        return [expr {$rightUser && $exists && $isBinary}]
    } -result {1}
    test fopen-mode-2.0 {
        Open the message queue with bad mode
    } -setup {
        set queueName /fopen-mode-2.0
    } -cleanup {
    } -body {
        mq open $queueName a
    } -result {unknown open mode, "a": should be one of r, r+ rb, rb+, w, w+, wb,\
            or wb+}\
        -returnCodes error
    test open-mode-1.0 {
        Open the message queue for writing and create if necessary
    } -setup {
        set queueName open-mode-1.0
        set queueFile [file join $mqFSMount $queueName]
    } -cleanup {
        chan close $mqchan
        file delete $queueFile
    } -body {
        set mqchan [mq open /$queueName {WRONLY CREAT}]
        log::debug "mq channel = $mqchan"
    
        set fattrs [file attributes $queueFile]
        log::debug "mq file attributes = $fattrs"
        set rightUser [expr {[dict get $fattrs -owner] eq $::tcl_platform(user)}]
    
        set exists [file exists $queueFile]
    
        return [expr {$rightUser && $exists}]
    } -result {1}
    test open-mode-2.0 {
        Attempt to open with a bad flag name.
    } -setup {
        set queueName /open-mode-2.0
    } -cleanup {
    } -body {
        mq open $queueName FOO
    } -result {invalid access mode "FOO": must be BINARY, CREAT, EXCL,\
            NONBLOCK, RDONLY, RDWR, or WRONLY}\
        -returnCodes error
    test open-mode-3.0 {
        Attempt to open with no access mode flag
    } -setup {
        set queueName /open-mode-3.0
    } -cleanup {
    } -body {
        mq open $queueName CREAT
    } -result {access mode must specify exactly one of RDONLY, WRONLY, or RDWR}\
        -returnCodes error
    test open-mode-3.1 {
        Attempt to open with multiple access mode flags
    } -setup {
        set queueName /open-mode-3.1
    } -cleanup {
    } -body {
        mq open $queueName {RDONLY RDWR}
    } -result {access mode must specify exactly one of RDONLY, WRONLY, or RDWR}\
        -returnCodes error
    test mq-open-1.0 {
        Open a message queue
    } -setup {
        set queueName /mq-open-1.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
        return $mqchan
    } -result {posixmq[0-9]*} -match glob
    test mq-open-2.0 {
        Open a message queue with create time options
    } -setup {
        set queueName /mq-open-2.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open -msgsize 256 -priority 10 -- $queueName w+]
        log::debug "mq channel = $mqchan"
        chan configure $mqchan -msgsize
    } -result {256}
    test mq-open-2.1 {
        Open a message queue with incorrect create time options
    } -setup {
        set queueName /mq-open-2.1
    } -cleanup {
    } -body {
        set mqchan [mq open -curmsgs 256 $queueName w+]
    } -result {option, -curmsgs, cannot be set on open: should be one of:\
            -maxmsg, -msgsize, or -priority}\
       -returnCodes error
    test mq-open-2.2 {
        Open a message queue with message size too large
    } -setup {
        set queueName /mq-open-2.2
    } -cleanup {
    } -constraints linuxOnly -body {
        set mqchan [mq open -msgsize 16000 $queueName w+]
    } -result {posixipc mq: /mq-open-2.2: invalid argument}\
       -returnCodes error
    test mq-open-2.3 {
        Open a message queue lacking option argument
    } -setup {
        set queueName /mq-open-2.3
    } -cleanup {
    } -body {
        set mqchan [mq open -msgsize 200 -priority]
    } -result {wrong # args: should be "mq open ?options? queuename ?access?\
            ?permissions?"} -returnCodes error
    test mq-open-2.4 {
        Open a message queue with bad message size
    } -setup {
        set queueName /mq-open-2.4
    } -cleanup {
    } -body {
        set mqchan [mq open -msgsize foo $queueName w+]
    } -result {expected integer but got "foo"} -returnCodes error
    test mq-open-2.5 {
        Open a message queue with bad max messages
    } -setup {
        set queueName /mq-open-2.5
    } -cleanup {
    } -body {
        set mqchan [mq open -maxmsg foo $queueName w+]
    } -result {expected integer but got "foo"} -returnCodes error
    test mq-open-2.6 {
        Open a message queue with bad priority
    } -setup {
        set queueName /mq-open-2.6
    } -cleanup {
    } -body {
        set mqchan [mq open -priority foo $queueName w+]
    } -result {expected integer but got "foo"} -returnCodes error
    test mq-open-2.7 {
        Open a message queue with wrong number of arguments
    } -setup {
    } -cleanup {
    } -body {
        set mqchan [mq open]
    } -result {wrong # args: should be "mq open ?options? queuename ?access?\
            ?permissions?"} -returnCodes error
    test mq-open-2.8 {
        Open a message queue with option name
    } -setup {
        set queueName /mq-open-2.8
    } -cleanup {
    } -body {
        set mqchan [mq open -foobar 27 $queueName w+]
    } -result {bad option "-foobar": should be one of -blocking, -buffering,\
            -buffersize, -encoding, -eofchar, -translation, -curmsgs,\
            -lastpriority, -maxmsg, -msgsize, or -priority} -returnCodes error
    test mq-open-2.9 {
        Open a message queue with negative priority
    } -setup {
        set queueName /mq-open-2.9
    } -cleanup {
    } -body {
        set mqchan [mq open -priority -30 $queueName w+]
    } -result {negative values for option, "-priority", are not allowed: got -30}\
            -returnCodes error
    test mq-open-2.10 {
        Open a message queue with wrong number of arguments after options
    } -setup {
    } -cleanup {
    } -body {
        set mqchan [mq open -priority 20]
    } -result {wrong # args: should be "mq open ?options? queuename ?access?\
            ?permissions?"} -returnCodes error
    test mq-open-2.11 {
        Open a message queue with negative priority
    } -setup {
        set queueName /mq-open-2.11
    } -cleanup {
    } -body {
        set mqchan [mq open $queueName w+ foo]
    } -result {expected integer but got "foo"} -returnCodes error
    test mq-open-2.12 {
        Open a message queue with non-default permissions
    } -setup {
        set queueName /mq-open-2.12
        set queueFile $mqFSMount$queueName
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName w+ 0640]
    
        set fattrs [file attributes $queueFile]
        log::debug "mq file attributes = $fattrs"
        dict get $fattrs -permissions
    } -result {00640}
    test mq-open-3.0 {
        Write to a message queue
    } -setup {
        set queueName /mq-open-3.0
        set mqchan [mq open -maxmsg 1 -msgsize 128 $queueName w+]
        chan configure $mqchan\
            -buffering line
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        log::debug "mq channel = $mqchan"
        log::debug "max messages = [chan configure $mqchan -maxmsg]"
        log::debug "message size = [chan configure $mqchan -msgsize]"
    
        chan puts $mqchan "Write a message"
        chan gets $mqchan
    } -result {Write a message}
    test mq-send-1.0 {
        Write to a message queue using send command
    } -setup {
        set queueName /mq-send-1.0
        set mqchan [mq open $queueName w+]
        chan configure $mqchan -buffering line
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        log::debug "mq channel = $mqchan"
    
        mq send $mqchan "Write a message\n"
        chan gets $mqchan
    } -result {Write a message}
    test mq-send-2.0 {
        send message -- wrong args
    } -setup {
    } -cleanup {
    } -body {
        mq send
    } -result {wrong # args: should be "mq send mqchan msg ?priority?"}\
        -returnCodes error
    test mq-send-2.1 {
        send message -- bad priority
    } -setup {
        set queueName /mq-send-2.1
        set mqchan [mq open $queueName w+]
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        mq send $mqchan "Hello World" foobar
    } -result {expected integer but got "foobar"} -returnCodes error
    test mq-send-2.2 {
        send message -- negative priority
    } -setup {
        set queueName /mq-send-2.2
        set mqchan [mq open $queueName w+]
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        mq send $mqchan "Hello World" -6
    } -result {negative values for priority are not allowed: got -6}\
        -returnCodes error
    test mq-send-2.3 {
        send message -- bad channel
    } -setup {
    } -cleanup {
    } -body {
        mq send posixmq27 "Hello World"
    } -result {can not find channel named "posixmq27"} -returnCodes error
    test mq-send-3.0 {
        Send a message -- non-blocking mode and queue full
    } -setup {
        set queueName /mq-send-3.0
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open -maxmsg 1 $queueName {CREAT EXCL RDWR NONBLOCK}]
        mq send $mqchan "Hello World"
        mq send $mqchan "Hello World"
    } -result {posixipc mq: mq_send failed: resource temporarily unavailable}\
        -returnCodes error
    test mq-receive-1.0 {
        Receive a message using the receive command
    } -setup {
        set queueName /mq-receive-1.0
        set mqchan [mq open $queueName w+]
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        log::debug "mq channel = $mqchan"
    
        set msgvalue "Receive a message"
        append msgvalue "\0"
        mq send $mqchan $msgvalue 20
        set msg [mq receive $mqchan msgpriority]
        set endmsg [expr {[string first \0 $msg] + 1}]
        binary scan $msg a$endmsg msgstr
    
        log::debug "message = \"$msgstr\""
        log::debug "priority = $msgpriority"
        log::debug "last priority = [chan configure $mqchan -lastpriority]"
    
        expr {$msgstr eq $msgvalue && $msgpriority == 20 &&\
                [chan configure $mqchan -lastpriority] == 20}
    } -result {1}
    test mq-receive-2.0 {
        Receive a message -- wrong arguments
    } -setup {
    } -cleanup {
    } -body {
        mq receive
    } -result {wrong # args: should be "mq receive mqchan ?priorvar?"}\
        -returnCodes error
    test mq-receive-2.1 {
        Receive a message -- non-blocking mode and no messages
    } -setup {
        set queueName /mq-receive-2.1
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName {CREAT EXCL RDWR NONBLOCK}]
        mq receive $mqchan
    } -result {posixipc mq: mq_receive failed: resource temporarily unavailable}\
        -returnCodes error
    test mq-receive-2.2 {
        Receive a message -- bad channel
    } -setup {
    } -cleanup {
    } -body {
        mq receive posixmq88
    } -result {can not find channel named "posixmq88"} -returnCodes error
    test mq-receive-2.3 {
        Receive a message -- bad priority variable
    } -setup {
        set queueName /mq-receive-2.3
    } -cleanup {
        chan close $mqchan
        mq unlink $queueName
    } -body {
        set mqchan [mq open $queueName {CREAT EXCL RDWR NONBLOCK}]
        mq send $mqchan "Hello World" 20
        mq receive $mqchan ::foobar::priority
    } -result {can't set "::foobar::priority": parent namespace doesn't exist}\
        -returnCodes error
    test mq-unlink-1.0 {
        Unlink a message queue
    } -setup {
        set queueName /mq-unlink-1.0
    } -cleanup {
        chan close $mqchan
    } -body {
        set mqchan [mq open $queueName w+]
        log::debug "mq channel = $mqchan"
        mq unlink $queueName
        file exists [file join $mqFSMount $queueName]
    } -result {0}
    test mq-unlink-2.0 {
        Unlink a message queue -- bad argument
    } -setup {
    } -cleanup {
    } -body {
        set mqchan [mq unlink]
    } -result {wrong # args: should be "mq unlink queuename"} -returnCodes error
    test mq-unlink-2.0 {
        Unlink a message queue -- unknown queue
    } -setup {
    } -cleanup {
    } -body {
        set mqchan [mq unlink /foobar]
    } -result {posixipc mq: /foobar: no such file or directory} -returnCodes error
    test text-record-messages-1.0 {
        Pass simple text records as messages.
    } -body {
        set total 0
        foreach num {1 2 3} {
            chan puts $clientChan "chan puts $num"
            set response [gets $serverChan]
            log::debug "server: received, \"$response\""
    
            set total [expr {$total + $response}]
        }
    
        chan puts $clientChan break
        return $total
    } -setup {
        set serverQueue /mqtest_txt_server
        set serverChan [mq open $serverQueue {CREAT EXCL RDONLY}]
        chan configure $serverChan -buffering line
        log::debug "server queue, \"$serverQueue\", open"
    
        set clientQueue /mqtest_txt_client
        set clientChan [mq open $clientQueue {CREAT EXCL WRONLY}]
        chan configure $clientChan -buffering line
        log::debug "client queue, \"$clientQueue\", open"
    
        makeFile {
            if {$::tcl_platform(os) eq "Linux"} {
                load ../tea/build/x86_64-linux-tcl8.6/libposixipc1.0.so
            } else {
                package require posixipc
            }
        
            namespace import ::posixipc::mq
        
            set clientQueue /mqtest_txt_client
            set clientChan [mq open $clientQueue RDONLY]
            chan configure $clientChan -buffering line
        
            set serverQueue /mqtest_txt_server
            chan close stdout                               ; # <1>
            set serverChan [mq open $serverQueue WRONLY]
            chan configure $serverChan -buffering line
        
            while {[gets $clientChan line] != -1} {
                try {
                    eval $line
                } on error {result} {
                    chan puts "error: $result"
                    break
                }
            }
        
            chan close $serverChan
            chan close $clientChan
        } txt-client.tcl
    
        exec tclsh txt-client.tcl &
        log::debug "client started in the background"
    } -cleanup {
        chan close $serverChan
        chan close $clientChan
    
        mq unlink $clientQueue
        mq unlink $serverQueue
    } -result {6}
    test text-record-messages-2.0 {
        Pass multiple text records as a message.
    } -body {
        foreach num {3 4 5} {
            chan puts $clientChan "chan puts $num"
        }
        chan puts $clientChan break ; # causes client to break out of its loop
        chan flush $clientChan
    
        set total 0
        for {set i 0} {$i < 3} {incr i} {
            set response [gets $serverChan]
            log::debug "server: received, \"$response\""
            set total [expr {$total + $response}]
        }
    
        return $total
    } -setup {
        set serverQueue /mqtest_mtxt_server
        set serverChan [mq open $serverQueue {CREAT EXCL RDONLY}]
        chan configure $serverChan -buffering line
        log::debug "server queue, \"$serverQueue\", open"
    
        set clientQueue /mqtest_mtxt_client
        set clientChan [mq open $clientQueue {CREAT EXCL WRONLY}]
        chan configure $clientChan -buffering full
        log::debug "client queue, \"$clientQueue\", open"
    
        makeFile {
            if {$::tcl_platform(os) eq "Linux"} {
                load ../tea/build/x86_64-linux-tcl8.6/libposixipc1.0.so
            } else {
                package require posixipc
            }
        
            namespace import ::posixipc::mq
        
            set clientQueue /mqtest_mtxt_client
            set clientChan [mq open $clientQueue RDONLY]
            chan configure $clientChan -buffering line
        
            set serverQueue /mqtest_mtxt_server
            chan close stdout                               ; # <1>
            set serverChan [mq open $serverQueue WRONLY]
            chan configure $serverChan -buffering full
        
            while {[gets $clientChan line] > 0} {
                try {
                    eval $line
                } on error {result} {
                    chan puts "error: $result"
                    break
                }
            }
            chan flush stdout   ; # <2>
        
            chan close $serverChan
            chan close $clientChan
        } mtxt-client.tcl
    
        exec tclsh mtxt-client.tcl &
        log::debug "client started in the background"
    } -cleanup {
        chan close $serverChan
        chan close $clientChan
    
        mq unlink $clientQueue
        mq unlink $serverQueue
    } -result {12}
    test text-record-messages-3.0 {
        Pass simple text records as messages.
    } -body {
        set total 0
        foreach num {7 8 9} {
            chan puts $clientChan "chan puts $num"
            set response [gets $serverChan]
            log::debug "server: received, \"$response\""
    
            set total [expr {$total + $response}]
        }
    
        chan puts $clientChan exit  ; # <1>
        return $total
    } -setup {
        set serverQueue /mqtest_edtxt_server
        set serverChan [mq open $serverQueue {CREAT EXCL RDONLY}]
        chan configure $serverChan -buffering line
        log::debug "server queue, \"$serverQueue\", open"
    
        set clientQueue /mqtest_edtxt_client
        set clientChan [mq open $clientQueue {CREAT EXCL WRONLY}]
        chan configure $clientChan -buffering line
        log::debug "client queue, \"$clientQueue\", open"
    
        makeFile {
            if {$::tcl_platform(os) eq "Linux"} {
                load ../tea/build/x86_64-linux-tcl8.6/libposixipc1.0.so
            } else {
                package require posixipc
            }
        
            namespace import ::posixipc::mq
        
            set clientQueue /mqtest_edtxt_client
            set clientChan [mq open $clientQueue RDONLY]
            chan configure $clientChan -buffering line -blocking false
        
            set serverQueue /mqtest_edtxt_server
            chan close stdout
            set serverChan [mq open $serverQueue WRONLY]
            chan configure $serverChan -buffering line
        
            proc ::readMsg {mqchan} {
                set line [chan gets $mqchan]
                try {
                    eval $line
                } on error {result} {
                    chan puts "error: $result"
                    return -code error $result
                }
            }
        
            chan event $clientChan readable [list ::readMsg $clientChan]
            vwait forever
        } ed-txt-client.tcl
    
        exec tclsh ed-txt-client.tcl &
        log::debug "client started in the background"
    } -cleanup {
        chan close $serverChan
        chan close $clientChan
    
        mq unlink $clientQueue
        mq unlink $serverQueue
    } -result {24}

    namespace import ::posixipc::shm
    test shm-open-1.0 {
        Open a shared memory object
    } -setup {
        set shmName /shm_open_1.0
    } -cleanup {
        chan close $shmchan
        shm unlink $shmName
    } -body {
        set shmchan [shm open -size 256 $shmName w+]
        log::debug "shm channel = $shmchan"
        return $shmchan
    } -result {posixshm[0-9]*} -match glob
    test shm-open-1.1 {
        Open a shared memory object with negative size
    } -setup {
        set shmName /shm_open_1.1
    } -cleanup {
    } -body {
        shm open -size -20 $shmName w+
    } -result {shared memory size must be positive} -returnCodes error
    test shm-open-1.2 {
        Open a shared memory object with bad name
    } -setup {
        set shmName /shm_open_1.2/foo
    } -cleanup {
    } -body {
        shm open -size 256 $shmName w+
    } -result {posixipc shm: cannot open shared memory exclusive access\
            semaphore:*} -match glob -returnCodes error
    test shm-open-1.3 {
        Open a shared memory object with bad access value
    } -setup {
        set shmName /shm_open_1.3
    } -cleanup {
    } -body {
        shm open -size 256 $shmName a
    } -result {unknown open mode, "a": should be one of r, r+ rb, rb+, w, w+, wb,\
            or wb+} -returnCodes error
    test shm-open-1.4 {
        Open a shared memory object with bad access flag
    } -setup {
        set shmName /shm_open_1.4
    } -cleanup {
    } -body {
        shm open -size 256 $shmName {FOOBAR}
    } -result {invalid access mode "FOOBAR": must be BINARY, CREAT, EXCL,\
            NONBLOCK, RDONLY, RDWR, or WRONLY} -returnCodes error
    test shm-open-1.5 {
        Open a shared memory object with bad size spec
    } -setup {
        set shmName /shm_open_1.5
    } -cleanup {
    } -body {
        shm open -size
    } -result {wrong # args: should be "shm open ?options? sharedname ?access?\
            ?permissions?"} -returnCodes error
    test shm-open-1.6 {
        Open a shared memory object with no name
    } -setup {
        set shmName /shm_open_1.6
    } -cleanup {
    } -body {
        shm open -size 256
    } -result {wrong # args: should be "shm open ?options? sharedname ?access?\
            ?permissions?"} -returnCodes error
    test shm-open-1.7 {
        Open a shared memory object with no name
    } -setup {
        set shmName /shm_open_1.6
    } -cleanup {
    } -body {
        shm open $shmName r+ foobar
    } -result {expected integer but got "foobar"} -returnCodes error
    test shm-open-1.8 {
        Open a shared memory -- too few arguments
    } -setup {
    } -cleanup {
    } -body {
        shm open
    } -result {wrong # args: should be "shm open ?options? sharedname ?access?\
            ?permissions?"} -returnCodes error
    test shm-open-1.9 {
        Open a shared memory -- bad size spec
    } -setup {
        set shmName /shm_open_1.9
    } -cleanup {
    } -body {
        shm open -size foobar $shmName r+
    } -result {expected integer but got "foobar"} -returnCodes error
    test shm-open-1.10 {
        Open a shared memory with non-default permissions
    } -setup {
        set shmName /shm_open_1.10
        set shmFile /dev/shm$shmName
    } -cleanup {
        chan close $shmchan
        shm unlink $shmName
    } -constraints linuxOnly -body {
        set shmchan [shm open -size 1024 $shmName w+ 0640]
    
        set fattrs [file attributes $shmFile]
        log::debug "shm file attributes = $fattrs"
        dict get $fattrs -permissions
    } -result {00640}
    test shm-open-2.0 {
        Open shared memory, write and read
    } -setup {
        set shmName /shm_open_2.0
    } -cleanup {
        chan close $shmchan
        shm unlink $shmName
    } -body {
        set shmchan [shm open -size 256 -- $shmName w+]
        log::debug "shm channel = $shmchan"
        chan configure $shmchan -buffering line
        chan puts $shmchan "Hello World"
        chan seek $shmchan 0
        chan gets $shmchan
    } -result {Hello World}
    test shm-open-2.1 {
        Open shared memory, write and read -- non-blocking
    } -setup {
        set shmName /shm_open_2.1
    } -cleanup {
        chan close $shmchan
        shm unlink $shmName
    } -body {
        set shmchan [shm open -size 256 -- $shmName w+]
        log::debug "shm channel = $shmchan"
        chan configure $shmchan -buffering line -blocking false
        chan puts $shmchan "Hello World"
        chan seek $shmchan 0
        chan gets $shmchan
    } -result {Hello World}
    test shm-open-3.0 {
        Read past EOF.
    } -setup {
        set shmName /shm_open_3.0
    } -cleanup {
        chan close $shmchan
        shm unlink $shmName
    } -body {
        set shmchan [shm open -size 256 -- $shmName w+]
        log::debug "shm channel = $shmchan"
        chan configure $shmchan -buffering line
        chan seek $shmchan 0
        chan puts $shmchan [string repeat a 255]
        chan seek $shmchan 0
        set contents [chan gets $shmchan]
        log::debug "got [string length $contents] byte string"
        log::debug "string starts with \"[string index $contents 0]\""
        log::debug "at file location, [chan tell $shmchan]"
        set end [chan read $shmchan 1]
        log::debug "reading past EOF, \"$end\""
        set eof [chan eof $shmchan]
        log::debug "eof = $eof"
        return $eof
    } -result {1}
    test shm-unlink-1.0 {
        unlink shared memory -- wrong arguments
    } -setup {
    } -cleanup {
    } -body {
        shm unlink
    } -result {wrong # args: should be "shm unlink shmname"} -returnCodes error

    cleanupTests
}
