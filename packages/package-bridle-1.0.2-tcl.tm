# ACTIVESTATE TEAPOT-PKG BEGIN TM -*- tcl -*-
# -- Tcl Module

# @@ Meta Begin
# Package bridle 1.0.2
# Meta description This package suppliments the harness package by
# Meta description providing a way to synchronize to stub output from a
# Meta description tack generated test harness.
# Meta platform    tcl
# Meta require     {Tcl 8.6}
# Meta require     eventTrace
# Meta require     harness
# Meta require     logger
# Meta require     oo::util
# Meta require     ral
# Meta require     ralutil
# Meta summary     Monitoring tack generated test harnesses
# @@ Meta End


# ACTIVESTATE TEAPOT-PKG BEGIN REQUIREMENTS

package require Tcl 8.6
package require eventTrace
package require harness
package require logger
package require oo::util
package require ral
package require ralutil

# ACTIVESTATE TEAPOT-PKG END REQUIREMENTS

# ACTIVESTATE TEAPOT-PKG BEGIN DECLARE

package provide bridle 1.0.2

# ACTIVESTATE TEAPOT-PKG END DECLARE
# ACTIVESTATE TEAPOT-PKG END TM
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
# This software is copyrighted 2013 - 2016 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
#

package require Tcl 8.6
package require logger
package require ral
package require ralutil
package require harness
package require eventTrace
package require oo::util

namespace eval ::bridle {
    namespace export rein
    namespace ensemble create

    logger::initNamespace [namespace current]

    variable version 1.0.2

    ::ralutil::sysIdsInit
}

::oo::class create ::bridle::rein {
    variable program map pycca timeout
    constructor {args} {
        set svcname ::bridle[self]
        ::logger::init $svcname
        ::logger::import -all -namespace log $svcname
    
        # Default timeout is 2 seconds
        set timeout 2000
        foreach {option value} $args {
            switch -exact -- $option {
                -program {
                    set program [auto_execok $value]
                    if {$program eq {}} {
                        error "unknown program, \"$value\""
                    }
                }
                -map {
                    set map $value
                    if {![file exists $map]} {
                        error "unknown map file, \"$map\""
                    }
                }
                -pycca {
                    set pycca $value
                    if {![file exists $pycca]} {
                        error "unknown pycca save file, \"$pycca\""
                    }
                }
                -timeout {
                    set timeout $value
                }
                default {
                    error "unknown option, \"$option\""
                }
            }
        }
    
        if {![info exists program]} {
            error "-program option not supplied"
        }
        if {![info exists map]} {
            error "-map option not supplied"
        }
        if {![info exists pycca]} {
            error "-pycca option not supplied"
        }
    
        log::debug "-program option = \"$program\""
        log::debug "-map option = \"$map\""
        log::debug "-pycca option = \"$pycca\""
        log::debug "-timeout option = \"$timeout\""
    
        switch -exact -- $::tcl_platform(os) {
            Linux {
                set maptype ELF
            }
            Windows -
            Darwin {
                set maptype PEI
            }
            default {
                error "unsupported os, \"$::tcl_platform(os)\""
            }
        }
        eventTrace setTracePlatform $maptype
        eventTrace traceInit $map $pycca
    
        namespace import ::ral::*
        namespace import ::ralutil::*
    
        relvar create Command {
            CmdId       int
            Command     string
            Response    string
        } CmdId
        
        sysIdsGenSystemId [self namespace]::Command CmdId
        relvar create Trace {
            TraceId     int
            Type        string
            Match       dict
            Prefix      list
        } TraceId
        
        sysIdsGenSystemId [self namespace]::Trace TraceId
        relvar trace add variable Trace {insert update set} {apply {{op name args} {
            set allowedTypes [list trace stub instrument]
            switch -exact -- $op {
                insert {
                    set tuple [lindex $args 0]
                    set type [::ral::tuple extract $tuple Type]
                    if {$type ni $allowedTypes} {
                        error "bad Type value, \"$type\""
                    }
                    return $tuple
                }
                update {
                    set tuple [lindex $args 1]
                    set type [::ral::tuple extract $tuple Type]
                    if {$type ni $allowedTypes} {
                        error "bad Type value, \"$type\""
                    }
                    return $tuple
                }
                set {
                    set relvalue [lindex $args 0]
                    foreach type [::ral::relation list $relvalue Type] {
                        if {$type ni $allowedTypes} {
                            error "bad Type value, \"$type\""
                        }
                    }
                    return $relvalue
                }
                default {
                    error "unknown operation, \"$op\""
                }
            }
        }}}
        relvar create StubOutput {
            StubId      int
            CmdId       int
            Output      string
        } StubId
        
        sysIdsGenSystemId [self namespace]::StubOutput StubId
        
        relvar association R1\
            StubOutput CmdId *\
            Command CmdId 1
    
        return
    }
    destructor {
        my variable connection
        if {[info exists connection]} {
            $connection close
        }
    }
    method cget {option} {
        switch -exact -- $option {
            -program -
            -map -
            -pycca -
            -timeout {
                return [set [string range $option 1 end]]
            }
    
            default {
                error "unknown option, \"$option\""
            }
        }
    }
    method start {{delay 500}} {
        set pid [exec $program &]
        after $delay
        return $pid
    }
    method connect {} {
        my variable connection
        set connection [harness open driver stub]
        # Turn on state machine tracing
        $connection trace true
        # Set the trace/debug output to non-blocking. We will be
        # waiting on output and synchonizing to the results.
        set stub [$connection cget stub]
        chan configure $stub -blocking no
        chan event $stub readable [mymethod RecvStubInput $stub]
    
        # Set up a fake command and other variables.  This is in case we receive
        # input before sending a "command" or attempting a "sync".
        set cmd [relvar insert Command {
            Command     connect
            Response    {result {}}
        }]
        my variable currentCmdId
        set currentCmdId [relation extract $cmd CmdId]
        my variable syncType
        set syncType {}
        my variable syncPattern
        set syncPattern {}
        return
    }
    method command {args} {
        # Send the command and wait for the response
        my variable connection
        set response [$connection {*}$args]
    
        # Save the command and its response
        set cmd [relvar insert Command [list\
            Command     $args\
            Response    $response\
        ]]
        # Set up variable with the current command ID. This is used
        # when stub output is saved.
        my variable currentCmdId
        set currentCmdId [relation extract $cmd CmdId]
        log::info [my FormatCmdResp $currentCmdId $args $response]
    
        # Throw an error if the response is an error.
        set result [dict get $response result]
        if {[dict get $response code] eq "error"} {
            log::error $result
            error $result
        }
        return $response
    }
    method trace {op args} {
        switch -exact -- $op {
            add {
                return [my AddTrace {*}$args]
            }
            remove {
                return [my RmTrace {*}$args]
            }
            info {
                return [my QueryTrace {*}$args]
            }
            default {
                error "unknown trace operation, \"$op\": should be one of\
                        add, remove or info"
            }
        }
    }
    method AddTrace {type match prefix} {
        set trace [relvar insert Trace [list\
            Type        $type\
            Match       $match\
            Prefix      $prefix\
        ]]
        return [relation extract $trace TraceId]
    }
    method RmTrace {traceid} {
        relvar deleteone Trace TraceId $traceid
    }
    method QueryTrace {traceid} {
        set trace [relvar restrictone Trace TraceId $traceid]
        return [expr {[relation isnotempty $trace] ?\
                [tuple get [relation tuple $trace]] : [list]}]
    }
    method EvalTraces {type content} {
        set traces [pipe {
            relvar set Trace |
            relation restrictwith ~ {$Type eq $type}
        }]
        relation foreach trace $traces -ascending TraceId {
            relation assign $trace Match Prefix
            if {[my MatchTrace $Match $content]} {
                try {
                    log::debug "matched trace: pattern = \"$Match\",\
                            content = \"$content\""
                    {*}$Prefix $type $content
                } on error {result opts} {
                    log::error "tracing error: $result"
                } on break {} {
                    return -level 0 -code break
                }
            }
        }
        return
    }
    method MatchTrace {pattern content} {
        dict for {pkey pvalue} $pattern {
            if {!([dict exists $content $pkey] &&\
                    [string match $pvalue [dict get $content $pkey]])} {
                return false
            }
        }
        return true
    }
    method smtraces {} {
        my trace add trace {} [mymethod MarkTrace]
    }
    method MarkTrace {type content} {
        try {
            if {[dict get $content eventType] eq "Normal"} {
                lassign [split [dict get $content dstInst] .] dstClass
                my variable currentCmdId
                set cmd [relvar restrictone Command CmdId $currentCmdId]
                set tname [expr {[relation isnotempty $cmd] ?\
                    [relation extract $cmd Command] : "unknown-$currentCmdId"}]
                eventTrace markTransition $tname $dstClass\
                    [dict get $content currState]\
                    [dict get $content eventNumber]
            }
        }
    }
    method sync {type pattern {wait {}}} {
        my variable syncType
        set syncType $type
        my variable syncPattern
        set syncPattern $pattern
    
        set to [expr {$wait eq {} ? $timeout : $wait}]
        my variable timerId
        set timerId [after $to [mymethod TimeOutSync]]
    
        my variable syncVar
        vwait [my varname syncVar]
        return $syncVar
    }
    method TimeOutSync {} {
        log::info "sync time out"
        my variable syncVar
        set [my varname syncVar] timeout
    }
    method RecvStubInput {stub} {
        for {set cnt [chan gets $stub line]} {$cnt >= 0}\
                {set cnt [chan gets $stub line]} {
    
            # Skip empty lines
            if {[string length $line] == 0} {
                continue
            }
    
            # Store away the received message
            my variable currentCmdId
            relvar insert StubOutput [list\
                CmdId       $currentCmdId\
                Output      $line\
            ]
            log::info [my FormatStubOutput $line]
    
            # We need to format state machine traces so that we are comparing
            # to human readable strings rather than number. Other types of
            # stub output comes back as strings already.
            lassign $line type content
            if {$type eq "trace"} {
                set content [eventTrace formatTrace $content]
                log::debug "sm trace: \"$content\""
            }
    
            # Check for tracing
            my EvalTraces $type $content
            # Check for synchronization
            my variable syncType
            my variable syncPattern
            if {$type eq $syncType && [my MatchTrace $syncPattern $content]} {
                log::debug "sync match"
                my variable syncVar
                set [my varname syncVar] [list $type $content]
    
                # Cancel the timeout
                my variable timerId
                after cancel $timerId
    
                break
            }
        }
        if {[chan eof $stub]} {
            log::error "EOF on stub socket"
            chan close $stub
        }
    }
    method prtraces {} {
        set traces [pipe {
            relvar set Command |
            relation join ~ [relvar set StubOutput] |
            relation group ~ StubOutputs StubId Output
        }]
        log::debug \n[relformat $traces]
    
        set result {}
        relation foreach trace $traces -ascending CmdId {
            relation assign $trace
            append result [my FormatCmdResp $CmdId $Command $Response]
            relation foreach stuboutput $StubOutputs -ascending StubId {
                append result [my FormatStubOutput\
                        [relation extract $stuboutput Output]] \n
            }
            append result \n
        }
        return [string trimright $result]
    }
    method FormatCmdResp {id cmd resp} {
        return [format "%5d %s -> \"%s\"\n" $id $cmd [dict get $resp result]]
    }
    
    method FormatStubOutput {so} {
        lassign $so type content
        switch -exact -- $type {
            stub {
                set fmtd [my FormatStub $content]
            }
            instrument {
                set fmtd [my FormatInstrument $content]
            }
            trace {
                set fmtd [my FormatTrace $content]
            }
            default {
                log::error "unknown response type, \"$type\""
                set fmtd {}
            }
        }
        return "      $type -> $fmtd"
    }
    
    method FormatTime {time} {
        lassign [split $time .] secs msecs
        return "[clock format $secs -format "%Y/%m/%d %T.$msecs"]: "
    }
    
    method FormatInstrument {content} {
        if {[dict exists $content time]} {
            append msg [my FormatTime [dict get $content time]]
        }
        append msg "[dict get $content func]()\
                [dict get $content file]:[dict get $content line]"
    }
    
    method FormatStub {content} {
        if {[dict exists $content time]} {
            append msg [my FormatTime [dict get $content time]]
        }
        append msg "[dict get $content domain].[dict get $content eop]("
        foreach {name value} [dict get $content parameters] {
            append msg "$value => $name, "
        }
        set msg [string trimright $msg ", "]
        append msg ")"
    }
    
    method FormatTrace {content} {
        try {
            set fmt [eventTrace ptrace [eventTrace formatTrace $content]]
        } on error {emsg} {
            log::error $emsg
            set fmt [eventTrace ptrace $content]
            return -level 0
        }
        return $fmt
    }
}

package provide bridle $::bridle::version
