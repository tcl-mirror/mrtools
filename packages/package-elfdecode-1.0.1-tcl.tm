# ACTIVESTATE TEAPOT-PKG BEGIN TM -*- tcl -*-
# -- Tcl Module

# @@ Meta Begin
# Package elfdecode 1.0.1
# Meta description This package defines a TclOO class that converts an ELF
# Meta description binary executable file into more useful data structures
# Meta description that can be queried.
# Meta platform    tcl
# Meta require     {Tcl 8.6}
# Meta require     logger
# Meta require     ral
# Meta require     ralutil
# Meta summary     elfdecode -- decode binary ELF format files
# @@ Meta End


# ACTIVESTATE TEAPOT-PKG BEGIN REQUIREMENTS

package require Tcl 8.6
package require logger
package require ral
package require ralutil

# ACTIVESTATE TEAPOT-PKG END REQUIREMENTS

# ACTIVESTATE TEAPOT-PKG BEGIN DECLARE

package provide elfdecode 1.0.1

# ACTIVESTATE TEAPOT-PKG END DECLARE
# ACTIVESTATE TEAPOT-PKG END TM
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2013 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require logger
package require ral
package require ralutil

namespace eval ::elfdecode {
    namespace export elffile
    namespace ensemble create

    logger::initNamespace [namespace current]

    variable version 1.0.1
}

proc ::oo::Helpers::classns {} {
    return [info object namespace [uplevel 1 {self class}]]
}
::oo::class create ::elfdecode::elffile {
    constructor {} {
        set svcname ::elfdecode[self]
        ::logger::init $svcname
        ::logger::import -all -namespace log $svcname
    
        namespace import ::ral::*
        namespace import ::ralutil::*
    
        my variable elfdata
        my variable position
        relvar create ElfSecHeader {
            sh_index int
            sh_name string
            sh_type string
            sh_flags string
            sh_addr int
            sh_offset int
            sh_size int
            sh_link int
            sh_info int
            sh_addralign int
            sh_entsize int
        } sh_index
        relvar create ElfProgHeader {
            p_index int
            p_type string
            p_offset int
            p_vaddr int
            p_paddr int
            p_filesz int
            p_memsz int
            p_flags string
            p_align int
        } p_index
        relvar create ElfSymbolTable {
            st_index int
            st_name string
            st_value int
            st_size int
            st_info int
            st_bind string
            st_type string
            st_other int
            st_shndx string
        } st_index
    }
    method readFile {fname} {
        set elfchan [::open $fname rb]
        try {
            return [my decodeData [chan read $elfchan]]
        } finally {
            chan close $elfchan
        }
    }
    method readChan {chan} {
        # Make sure we are in binary mode!
        chan configure $chan -translation binary
        return [my decodeData [chan read $chan]]
    }
    method decodeData {data} {
        my variable elfdata
        set elfdata $data
        my variable position
        set position 0
        my variable elfheader
        set elfheader [my ReadElfHeader]
        log::info "ELF header = \"$elfheader\""
        dict with elfheader {
            my ReadSecHeaders $e_shoff $e_shnum $e_shentsize $e_shstrndx
            my ReadProgHeaders $e_phoff $e_phnum $e_phentsize
            my ReadSymTable
        }
        return $elfheader
    }
    method getSectionHeaderByName {name} {
        return [pipe {
            relvar set ElfSecHeader |
            relation restrictwith ~ {$sh_name eq $name} |
            relation body ~
        }]
    }
    method getSectionHeaderByIndex {index} {
        set header [relvar restrictone ElfSecHeader sh_index $index]
        if {[relation isempty $header]} {
            error "no section header with index, \"$index\""
        }
        return [tuple get [relation tuple $headers]]
    }
    method foreachSectionHeader {varname script} {
        upvar 1 $varname header
        foreach header [relation body [relvar set ElfSecHeader]] {
            try {
                uplevel 1 $script
            } on error {result opts} {
                return -options $opts $result
            } on break {
                return -level 0 -code break
            } on continue {
                return -level 0 -code continue
            }
        }
    }
    method getSectionDataByIndex {index} {
        set header [my getSectionHeaderByIndex $index]
        my Seek [dict get $header sh_offset]
        return [my Read [dict get $header sh_size]]
    }
    method getSectionDataByName {name} {
        set headers [my getSectionHeaderByName $name]
        if {[llength $headers] != 1} {
            error "cannot find unique section named, \"$name\""
        }
        set header [lindex $headers 0]
        my Seek [dict get $header sh_offset]
        return [my Read [dict get $header sh_size]]
    }
    method getSymbolByName {name} {
        return [pipe {
            relvar set ElfSymbolTable |
            relation restrictwith ~ {$st_name eq $name} |
            relation body ~
        }]
    }
    method getSymbolTable {} {
        return [relvar set ElfSymbolTable]
    }
    method ReadElfHeader {} {
        # Read the 16 byte identifier field and make sure we are dealing with an
        # ELF file. The header is of a fixed 16 byte format.  We need to squirrel
        # away the class and data type information so we can distinguish between
        # the various file types and byte orders.
        my variable ei_class ei_data
        my ConvertIdentifier\
            elfmag0 elfmagName ei_class ei_data ei_version ei_osabi\
            ei_abiversion ei_pad
    
        if {$elfmag0 != 0x7f || $elfmagName ne "ELF"} {
            error "bad ELF magic number, [format %#x $elfmag0] $elfmagName"
        }
        # At this point we know we have a good ELF file.
        # Convert some numbers into more meaningful strings.
        set ei_class [my XlateEnumValue ei_class $ei_class]
        set ei_data [my XlateEnumValue ei_data $ei_data]
    
        # Convert the remainder of the header.
        my Convert header\
            e_type e_machine e_version e_entry e_phoff e_shoff e_flags\
            e_ehsize e_phentsize e_phnum e_shentsize e_shnum e_shstrndx
        my Advance [expr {$e_ehsize - 16}]
    
        set e_type [my XlateEnumValue e_type $e_type]
        set e_version [expr {$e_version == 1 ? "EV_CURRENT" : "EV_NONE"}]
    
        return [dict create\
            ei_class $ei_class\
            ei_data $ei_data\
            ei_version $ei_version\
            ei_osabi $ei_osabi\
            ei_abiversion $ei_abiversion\
            e_type $e_type\
            e_machine $e_machine\
            e_version $e_version\
            e_entry $e_entry\
            e_phoff $e_phoff\
            e_shoff $e_shoff\
            e_flags $e_flags\
            e_ehsize $e_ehsize\
            e_phentsize $e_phentsize\
            e_phnum $e_phnum\
            e_shentsize $e_shentsize\
            e_shnum $e_shnum\
            e_shstrndx $e_shstrndx\
        ]
    }
    method ReadSecHeaders {e_shoff e_shnum e_shentsize e_shstrndx} {
        if {$e_shnum == 0} {
            return
        }
        # Seek to where the section header table is located.
        my Seek $e_shoff
    
        set sectuples [list]
        # Read and convert the entire array of section headers.
        for {set secNo 0} {$secNo < $e_shnum} {incr secNo} {
            my Convert section\
                    sh_name sh_type sh_flags sh_addr sh_offset\
                    sh_size sh_link sh_info sh_addralign sh_entsize
    
            set sh_type [my XlateEnumValue sh_type $sh_type]
            # The first entry in the section header has a type of 0 and
            # does not contain any useful information.
            if {$sh_type eq "SHT_NULL"} {
                continue
            }
            set sh_flags [my XlateFlagBits sh_flags $sh_flags]
            set secheader [list\
                sh_index        $secNo\
                sh_name         $sh_name\
                sh_type         $sh_type\
                sh_flags        $sh_flags\
                sh_addr         $sh_addr\
                sh_offset       $sh_offset\
                sh_size         $sh_size\
                sh_link         $sh_link\
                sh_info         $sh_info\
                sh_addralign    $sh_addralign\
                sh_entsize      $sh_entsize\
            ]
            log::debug "section header: $secheader"
            lappend sectuples $secheader
        }
        # Create a relation with all the section header information.
        set sections [relation create {
            sh_index int
            sh_name int
            sh_type string
            sh_flags string
            sh_addr int
            sh_offset int
            sh_size int
            sh_link int
            sh_info int
            sh_addralign int
            sh_entsize int
        } {*}$sectuples]
        #log::info \n[relformat $sections sections]
    
        # Now we want to update the information stored with the section
        # headers to replace the string index used as the name with
        # the string that is the section name.
        set shstrsec [relation restrictwith $sections\
                {$sh_index == $e_shstrndx}]
        if {[relation isnotempty $shstrsec]} {
            relation assign $shstrsec sh_type sh_offset sh_size
            if {$sh_type eq "SHT_STRTAB"} {
                set shnames [my ReadStringTable $sh_offset $sh_size]
                #log::info \n[relformat $shnames SectionNames]
                relvar set ElfSecHeader [pipe {
                    relation join $sections $shnames -using {sh_name st_index} |
                    relation eliminate ~ sh_name |
                    relation rename ~ st_string sh_name
                }]
            }
        }
        log::info \n[relformat [relvar set ElfSecHeader] ElfSecHeader]
    }
    method ReadProgHeaders {e_phoff e_phnum e_phentsize} {
        if {$e_phnum == 0} {
            return
        }
        # Seek to where the section header table is
        my Seek $e_phoff
    
        for {set phNo 0} {$phNo < $e_phnum} {incr phNo} {
            my Convert prog\
                    p_type p_offset p_vaddr p_paddr\
                    p_filesz p_memsz p_flags p_align
            # Turns some numbers into strings.
            set p_type [my XlateEnumValue p_type $p_type]
            set p_flags [my XlateFlagBits p_flags $p_flags]
    
            relvar insert ElfProgHeader [list\
                p_index     $phNo\
                p_type      $p_type\
                p_offset    $p_offset\
                p_vaddr     $p_vaddr\
                p_paddr     $p_paddr\
                p_filesz    $p_filesz\
                p_memsz     $p_memsz\
                p_flags     $p_flags\
                p_align     $p_align\
            ]
        }
        log::info \n[relformat [relvar set ElfProgHeader] ElfProgHeader]
    }
    method ReadStringTable {sh_offset sh_size} {
        # seek to the file location
        my Seek $sh_offset
        set strings [my Read $sh_size]
        set strOff 0
        # The strings are just packed NUL terminated ASCII strings.
        # Just split on the NUL character to unbundle the them.
        set tuples [list]
        foreach s [split $strings "\0"] {
            if {[string length $s] != 0} {
                lappend tuples [list st_index $strOff st_string $s]
            }
            incr strOff [expr {[string length $s] + 1}]
        }
    
        return [relation create {st_index int st_string string} {*}$tuples]
    }
    method ReadSymTable {} {
        set symsecs [my getSectionHeaderByName .symtab]
        if {[llength $symsecs] != 1} {
            log::info "cannot find symbol table section named, \".symtab\""
            return
        }
        set symheader [lindex $symsecs 0]
        dict with symheader {
            if {$sh_type ne "SHT_SYMTAB"} {
                error "expected symbol table section type of \"SHT_SYMTAB\",\
                        got \"$sh_type\""
            }
            if {$sh_entsize == 0} {
                error "expected non-zero symbol table entry size,\
                        got \"$sh_entsize\""
            }
            my Seek $sh_offset
            set nSyms [expr {$sh_size / $sh_entsize}]
            my variable ei_class
            # Accumulate a list of dictionaries to use as a relation value body.
            set symtuples [list]
            for {set symindex 0} {$symindex < $nSyms} {incr symindex} {
                # As it turns out, the ordering of fields is different for 32-bit
                # vs. 64-bit ELF files. The field contents are the same, but we
                # slightly different procs to read the symbol table entries.
                set sym [expr {$ei_class eq "ELFCLASS32" ?\
                    [my ReadElf32Sym] : [my ReadElf64Sym]}]
                my Advance $sh_entsize
                if {[dict size $sym] == 0} {
                    log::notice "discarding unnamed symbol table entry,\
                            \"$symindex\""
                    continue
                }
                dict set sym st_index $symindex
                # Decode the st_info field and translate the numbers into strings.
                dict set sym st_bind [my XlateEnumValue st_bind\
                    [expr {[dict get $sym st_info] >> 4}]]
                dict set sym st_type [my XlateEnumValue st_type\
                    [expr {[dict get $sym st_info] & 0xf}]]
                # Decode the symbol section index reference
                dict set sym st_shndx [my XlateEnumValue shndx\
                    [dict get $sym st_shndx]]
    
                lappend symtuples $sym
            }
            # Create a relation with the symbol information.
            set syms [relation create {
                st_index int
                st_nindex int
                st_value int
                st_size int
                st_info int
                st_bind string
                st_type string
                st_other int
                st_shndx string} {*}$symtuples]
            #log::debug \n[relformat $syms syms]
    
            # Now we want to read the string table and resolve the index values
            # into actual names.  First, find the string table. Its name is
            # also special.
            set strsecs [my getSectionHeaderByName .strtab]
            if {[llength $strsecs] != 1} {
                log::info "cannot find string table section named, \".strtab\""
                return
            }
            set strheader [lindex $strsecs 0]
            dict with strheader {
                if {$sh_type ne "SHT_STRTAB"} {
                    error "expected symbol table section type of \"SHT_STRTAB\",\
                            got \"$sh_type\""
                }
                if {$sh_entsize != 0} {
                    error "expected zero string table entry size,\
                            got \"$sh_entsize\""
                }
                set symnames [my ReadStringTable $sh_offset $sh_size]
            }
        }
        # Join the string table to the symbol table and replace the string indices
        # with symbol names.
        relvar set ElfSymbolTable [pipe {
            relation join $syms $symnames -using {st_nindex st_index} |
            relation eliminate ~ st_nindex |
            relation rename ~ st_string st_name
        }]
        log::info \n[relformat [relvar set ElfSymbolTable] ElfSymbolTable]
        return
    }
    method ReadElf32Sym {} {
        my Convert symbol st_index st_value st_size st_info st_other st_shndx
        # The "zero" string index is undefined and implies the symbol
        # has not name. We discard those.
        if {$st_index == 0} {
            return
        }
        return [list\
            st_nindex   $st_index\
            st_value    $st_value\
            st_size     $st_size\
            st_info     $st_info\
            st_other    $st_other\
            st_shndx    $st_shndx\
        ]
    }
    method ReadElf64Sym {} {
        my Convert symbol st_index st_info st_other st_shndx st_value st_size
        # The "zero" string index is undefined and implies the symbol
        # has not name. We discard those.
        if {$st_index == 0} {
            return
        }
        return [list\
            st_nindex   $st_index\
            st_value    $st_value\
            st_size     $st_size\
            st_info     $st_info\
            st_other    $st_other\
            st_shndx    $st_shndx\
        ]
    }
    method Seek {offset} {
        my variable elfdata position
    
        if {$offset < 0} {
            set position 0
        } elseif {$offset > [string length $elfdata]} {
            set position [string length $elfdata]
        } else {
            set position $offset
        }
        #log::debug "seek to $position"
    }
    method Advance {offset} {
        my variable elfdata
        my variable position
        set newpos [expr {$position + $offset}]
    
        if {$newpos < 0} {
            set position 0
        } elseif {$newpos > [string length $elfdata]} {
            set position [string length $elfdata]
        } else {
            set position $newpos
        }
        #log::debug "advance to $position"
    }
    method Read {count} {
        my variable elfdata
        my variable position
    
        set end [expr {$position + $count - 1}]
        if {$end >= [string length $elfdata]} {
            error "attempt to read beyond end of ELF data"
        }
        set data [string range $elfdata $position $end]
        set position [expr {$end + 1}]
        return $data
    }
    method Convert {fmtname args} {
        my variable ei_class ei_data
        set fmtrel [relvar restrictone [classns]::ElfFormatSpec\
            Name        $fmtname\
            Class       $ei_class\
            DataType    $ei_data\
        ]
        if {[relation isempty $fmtrel]} {
            error "cannot find format specification,\
                    \"$fmtname $ei_class $ei_data\""
        }
        my Scan [relation extract $fmtrel Format] $args
        my Advance [relation extract $fmtrel Size]
    }
    method ConvertIdentifier {args} {
        my Scan {cu a3 cu cu cu cu cu cu7} $args
        my Advance 16
    }
    method Scan {fmt arglist} {
        my variable elfdata
        my variable position
    
        foreach arg $arglist {
            upvar 2 $arg $arg
        }
        set cvtd [binary scan $elfdata "@$position $fmt" {*}$arglist]
        if {$cvtd != [llength $arglist]} {
            error "expected to convert \"[llength $arglist]\" values,\
                actually converted \"$cvtd\""
        }
    }
    method XlateEnumValue {symtype etor} {
        set enum [relvar restrictone [classns]::ElfEnumerator\
                SymbolType $symtype Value $etor]
        if {[relation isnotempty $enum]} {
            return [relation extract $enum Enumerator]
        }
        set range [pipe {
            relvar set [classns]::ElfEnumRange |
            relation restrictwith ~ {
                $SymbolType eq $symtype && $etor >= $LowValue &&\
                $etor <= $HighValue}
        }]
        if {[relation isnotempty $range]} {
            relation assign $range Enumerator LowValue
            return $Enumerator\[[format %#x $etor]\]
        } else {
            # If all else fails, just return the original value.
            return $etor
        }
    }
    method XlateFlagBits {symtype value} {
        set result [list]
        set bitsyms [pipe {
            relvar set [classns]::ElfBitSymbol |
            relation restrictwith ~ {$SymbolType eq $symtype}
        }]
        relation foreach bitsym $bitsyms -ascending Offset {
            relation assign $bitsym SymbolName Offset Length
            # Compute a mask from the bit field definition.
            set mask [expr {((1 << $Length) - 1) <<  $Offset}]
            set mvalue [expr {$value & $mask}]
            if {$mvalue != 0} {
                # We treat single bit fields differently. Multi-bit fields have a
                # value associated with them.
                if {$Length == 1} {
                    lappend result $SymbolName
                } else {
                    lappend result "$SymbolName\([expr {$mvalue >> $Offset}]\)"
                }
            }
        }
        return $result
    }
}
namespace eval [info object namespace ::elfdecode::elffile] {
    namespace import ::ral::*
    namespace import ::ralutil::*

    relvar create ElfFormatSpec {
        Name        string
        Class       string
        DataType    string
        Format      string
        Size        int
    } {Name Class DataType}
    
    relvar insert ElfFormatSpec {
        Name        header
        Class       ELFCLASS32
        DataType    ELFDATA2LSB
        Format      {su su iu iu iu iu iu su su su su su su}
        Size        0
    } {
        Name        header
        Class       ELFCLASS32
        DataType    ELFDATA2MSB
        Format      {Su Su Iu Iu Iu Iu Iu Su Su Su Su Su Su}
        Size        0
    } {
        Name        header
        Class       ELFCLASS64
        DataType    ELFDATA2LSB
        Format      {su su iu wu wu wu iu su su su su su su}
        Size        0
    } {
        Name        header
        Class       ELFCLASS64
        DataType    ELFDATA2MSB
        Format      {Su Su Iu Wu Wu Wu Iu Su Su Su Su Su Su}
        Size        0
    } {
        Name        section
        Class       ELFCLASS32
        DataType    ELFDATA2LSB
        Format      {iu iu iu iu iu iu iu iu iu iu}
        Size        40
    } {
        Name        section
        Class       ELFCLASS32
        DataType    ELFDATA2MSB
        Format      {Iu Iu Iu Iu Iu Iu Iu Iu Iu Iu}
        Size        40
    } {
        Name        section
        Class       ELFCLASS64
        DataType    ELFDATA2LSB
        Format      {iu iu wu wu wu wu iu iu wu wu}
        Size        64
    } {
        Name        section
        Class       ELFCLASS64
        DataType    ELFDATA2MSB
        Format      {Iu Iu Wu Wu Wu Wu Iu Iu Wu Wu}
        Size        64
    } {
        Name        prog
        Class       ELFCLASS32
        DataType    ELFDATA2LSB
        Format      {iu iu iu iu iu iu iu iu}
        Size        32
    } {
        Name        prog
        Class       ELFCLASS32
        DataType    ELFDATA2MSB
        Format      {Iu Iu Iu Iu Iu Iu Iu Iu}
        Size        32
    } {
        Name        prog
        Class       ELFCLASS64
        DataType    ELFDATA2LSB
        Format      {iu iu wu wu wu wu wu wu}
        Size        56
    } {
        Name        prog
        Class       ELFCLASS64
        DataType    ELFDATA2MSB
        Format      {Iu Iu Wu Wu Wu Wu Wu Wu}
        Size        56
    } {
        Name        symbol
        Class       ELFCLASS32
        DataType    ELFDATA2LSB
        Format      {iu iu iu cu cu su}
        Size        0
    } {
        Name        symbol
        Class       ELFCLASS32
        DataType    ELFDATA2MSB
        Format      {Iu Iu Iu cu cu Su}
        Size        0
    } {
        Name        symbol
        Class       ELFCLASS64
        DataType    ELFDATA2LSB
        Format      {iu cu cu su wu wu}
        Size        0
    } {
        Name        symbol
        Class       ELFCLASS64
        DataType    ELFDATA2MSB
        Format      {Iu cu cu Su Wu Wu}
        Size        0
    }
    relvar create ElfEnumerator {
        SymbolType  string
        Enumerator  string
        Value       int
    } {SymbolType Enumerator} {SymbolType Value}
    relvar create ElfEnumRange {
        SymbolType  string
        Enumerator  string
        LowValue    int
        HighValue   int
    } {SymbolType Enumerator} {SymbolType LowValue}
    relvar insert ElfEnumerator {
        SymbolType  ei_class
        Enumerator  ELFCLASS32
        Value       1
    } {
        SymbolType  ei_class
        Enumerator  ELFCLASS64
        Value       2
    } {
        SymbolType  ei_data
        Enumerator  ELFDATA2LSB
        Value       1
    } {
        SymbolType  ei_data
        Enumerator  ELFDATA2MSB
        Value       2
    }
    relvar insert ElfEnumerator {
        SymbolType  e_type
        Enumerator  ET_NONE
        Value       0
    } {
        SymbolType  e_type
        Enumerator  ET_REL
        Value       1
    } {
        SymbolType  e_type
        Enumerator  ET_EXEC
        Value       2
    } {
        SymbolType  e_type
        Enumerator  ET_DYN
        Value       3
    } {
        SymbolType  e_type
        Enumerator  ET_CORE
        Value       4
    }
    
    relvar insert ElfEnumRange {
        SymbolType  e_type
        Enumerator  ET_LOOS
        LowValue    0xfe00
        HighValue   0xfeff
    } {
        SymbolType  e_type
        Enumerator  ET_LOPROC
        LowValue    0xff00
        HighValue   0xffff
    }
    relvar insert ElfEnumerator {
        SymbolType  sh_type
        Enumerator  SHT_NULL
        Value       0
    } {
        SymbolType  sh_type
        Enumerator  SHT_PROGBITS
        Value       1
    } {
        SymbolType  sh_type
        Enumerator  SHT_SYMTAB
        Value       2
    } {
        SymbolType  sh_type
        Enumerator  SHT_STRTAB
        Value       3
    } {
        SymbolType  sh_type
        Enumerator  SHT_RELA
        Value       4
    } {
        SymbolType  sh_type
        Enumerator  SHT_HASH
        Value       5
    } {
        SymbolType  sh_type
        Enumerator  SHT_DYNAMIC
        Value       6
    } {
        SymbolType  sh_type
        Enumerator  SHT_NOTE
        Value       7
    } {
        SymbolType  sh_type
        Enumerator  SHT_NOBITS
        Value       8
    } {
        SymbolType  sh_type
        Enumerator  SHT_REL
        Value       9
    } {
        SymbolType  sh_type
        Enumerator  SHT_SHLIB
        Value       10
    } {
        SymbolType  sh_type
        Enumerator  SHT_DYNSYM
        Value       11
    }
    
    relvar insert ElfEnumRange {
        SymbolType  sh_type
        Enumerator  SHT_LOOS
        LowValue    0x60000000
        HighValue   0x6fffffff
    } {
        SymbolType  sh_type
        Enumerator  SHT_LOPROC
        LowValue    0x70000000
        HighValue   0x7fffffff
    }
    relvar insert ElfEnumerator {
        SymbolType  shndx
        Enumerator  SHN_UNDEF
        Value       0
    } {
        SymbolType  shndx
        Enumerator  SHN_ABS
        Value       0xfff1
    } {
        SymbolType  shndx
        Enumerator  SHN_COMMON
        Value       0xfff2
    }
    
    relvar insert ElfEnumRange {
        SymbolType  shndx
        Enumerator  SHN_LOPROC
        LowValue    0xff00
        HighValue   0xff1f
    } {
        SymbolType  shndx
        Enumerator  SHT_LOOS
        LowValue    0xff20
        HighValue   0xff3f
    }
    relvar insert ElfEnumerator {
        SymbolType  p_type
        Enumerator  PT_NULL
        Value       0
    } {
        SymbolType  p_type
        Enumerator  PT_LOAD
        Value       1
    } {
        SymbolType  p_type
        Enumerator  PT_DYNAMIC
        Value       2
    } {
        SymbolType  p_type
        Enumerator  PT_INTERP
        Value       3
    } {
        SymbolType  p_type
        Enumerator  PT_NOTE
        Value       4
    } {
        SymbolType  p_type
        Enumerator  PT_SHLIB
        Value       5
    } {
        SymbolType  p_type
        Enumerator  PT_PHDR
        Value       6
    }
    
    relvar insert ElfEnumRange {
        SymbolType  p_type
        Enumerator  PT_LOOS
        LowValue    0x60000000
        HighValue   0x6fffffff
    } {
        SymbolType  p_type
        Enumerator  PT_LOPROC
        LowValue    0x70000000
        HighValue   0x7fffffff
    }
    relvar insert ElfEnumerator {
        SymbolType  st_bind
        Enumerator  STB_LOCAL
        Value       0
    } {
        SymbolType  st_bind
        Enumerator  STB_GLOBAL
        Value       1
    } {
        SymbolType  st_bind
        Enumerator  STB_WEAK
        Value       2
    }
    
    relvar insert ElfEnumRange {
        SymbolType  st_bind
        Enumerator  STB_LOOS
        LowValue    10
        HighValue   12
    } {
        SymbolType  st_bind
        Enumerator  STB_LOPROC
        LowValue    13
        HighValue   15
    }
    relvar insert ElfEnumerator {
        SymbolType  st_type
        Enumerator  STT_NOTYPE
        Value       0
    } {
        SymbolType  st_type
        Enumerator  STT_OBJECT
        Value       1
    } {
        SymbolType  st_type
        Enumerator  STT_FUNC
        Value       2
    } {
        SymbolType  st_type
        Enumerator  STT_SECTION
        Value       3
    } {
        SymbolType  st_type
        Enumerator  STT_FILE
        Value       4
    }
    
    relvar insert ElfEnumRange {
        SymbolType  st_type
        Enumerator  STT_LOOS
        LowValue    10
        HighValue   12
    } {
        SymbolType  st_type
        Enumerator  STT_LOPROC
        LowValue    13
        HighValue   15
    }
    relvar create ElfBitSymbol {
        SymbolType  string
        SymbolName  string
        Offset      int
        Length      int
    } {SymbolType SymbolName} {SymbolType Offset}
    relvar insert ElfBitSymbol {
        SymbolType  sh_flags
        SymbolName  SHF_WRITE
        Offset      0
        Length      1
    } {
        SymbolType  sh_flags
        SymbolName  SHF_ALLOC
        Offset      1
        Length      1
    } {
        SymbolType  sh_flags
        SymbolName  SHF_EXECINST
        Offset      2
        Length      1
    } {
        SymbolType  sh_flags
        SymbolName  SHF_MASKPROC
        Offset      28
        Length      4
    }
    relvar insert ElfBitSymbol {
        SymbolType  p_flags
        SymbolName  PF_X
        Offset      0
        Length      1
    } {
        SymbolType  p_flags
        SymbolName  PF_W
        Offset      1
        Length      1
    } {
        SymbolType  p_flags
        SymbolName  PF_R
        Offset      2
        Length      1
    } {
        SymbolType  p_flags
        SymbolName  PF_MASKOS
        Offset      16
        Length      8
    } {
        SymbolType  p_flags
        SymbolName  PF_MASKPROC
        Offset      24
        Length      8
    }
}

package provide elfdecode $::elfdecode::version
