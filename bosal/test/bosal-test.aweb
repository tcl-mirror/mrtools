// vim:set syntax=asciidoc:

= Unit Tests for Bosal

== Null Command

(((chunk,bosal harness tests)))
(((test,null-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test null-1.0 {
    Null command test
} -setup {
} -cleanup {
} -body {
    harnessCmdResp null
} -result {}
----

(((chunk,bosal harness tests)))
(((test,null-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test null-2.0 {
    Null command with wrong argument count
} -setup {
} -cleanup {
} -body {
    harnessCmdResp null foo
} -result {wrong # of arguments, 2: expected, null} -returnCodes error
----

== Query Domains

(((chunk,bosal harness tests)))
(((test,query-domains-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-domains-1.0 {
    query domains successfully
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query domains
} -result {lube sio}
----

(((chunk,bosal harness tests)))
(((test,query-domains-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-domains-2.0 {
    query domains with too many arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query domains foo
} -result {wrong # of arguments, 3: expected, query domains} -returnCodes error
----

== Query Classes

(((chunk,bosal harness tests)))
(((test,query-classes-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-1.0 {
    query lube classes
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes lube
} -result {Lubrication_Schedule Injector_Design Injector Autocycle_Session Machinery Reservoir}
----

(((chunk,bosal harness tests)))
(((test,query-classes-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-2.0 {
    query classes -- unknown domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes foo
} -result {unknown domain, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,query-classes-2.1)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-2.1 {
    query classes -- wrong number of arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes foo bar
} -result {wrong # of arguments, 4: expected, "query classes <domain>"}\
-returnCodes error
----

== Query Attributes

(((chunk,bosal harness tests)))
(((test,query-attributes-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-attributes-1.0 {
    Query attributes of the Injector_Design class in the lube domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query attributes lube Injector_Design
} -result {Delivery_window Good_injection_duration Max_dissipation_pressure Max_system_pressure Min_delivery_pressure Model}
----

(((chunk,bosal harness tests)))
(((test,query-attributes-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-attributes-2.0 {
    query attributes -- too many arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query attributes lube Injector_Design foo
} -result {wrong # of arguments, 5: expected, "query attributes <domain> <class>"}\
-returnCodes error
----

(((chunk,bosal harness tests)))
(((test,query-attributes-2.1)))

[source,tcl]
----
<<bosal harness tests>>=
test query-attributes-2.1 {
    query attributes -- too few arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query attributes lube
} -result {wrong # of arguments, 3: expected, "query attributes <domain> <class>"}\
-returnCodes error
----

== Query Instances

(((chunk,bosal harness tests)))
(((test,query-instances-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-instances-1.0 {
    query instances of Injector in lube domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query instances lube Injector
} -result {total 3 named {in1 in2 in3}}
----

== Query States

(((chunk,bosal harness tests)))
(((test,query-states-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-states-1.0 {
    query states of Reservoir class in lube domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query states lube Reservoir
} -result {NORMAL LOW VERY_LOW EMPTY}
----

(((chunk,bosal harness tests)))
(((test,query-states-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-states-2.0 {
    query states of class with no state model
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query states lube Injector_Design
} -result {Class does not have a state model}\
-returnCodes error
----

== Query Events

(((chunk,bosal harness tests)))
(((test,query-events-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-events-1.0 {
    query events of the Reservoir class in the lube domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query events lube Reservoir
} -result {Low_injection_pressure Low_lube_level Normal_lube_level Too_many_low_lube_cycles}
----

== Query Current State

(((chunk,bosal harness tests)))
(((test,query-current-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-current-1.0 {
    query current state of an Injector instance in the lube domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query current lube Injector in1
} -result {SLEEPING}
----

(((chunk,bosal harness tests)))
(((test,query-current-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-current-2.0 {
    query current state for class with no state model
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query current lube Injector_Design ihn4
} -result {Class does not have a state model}\
-returnCodes error
----

== Domain Operations

(((chunk,bosal harness tests)))
(((test,domainop-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.0 {
    Unknown domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop foo init
} -result {unknown domain, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-1.1)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.1 {
    No operation name
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop sio
} -result {wrong # of arguments: 2: expected, domainop <domain> <operation> ?<arg1> <arg2> ...?}\
-returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-1.2)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.2 {
    Unknown operations
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop sio foo
} -result {unknown operation, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-1.3)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.3 {
    Missing operation argument
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop lube Suspend_Autocycle_Session
} -result {wrong # arguments: got 0, expected 1} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-1.4)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.4 {
    Bad operation argument
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop lube Suspend_Autocycle_Session foo
} -result {bad parameter: "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.0 {
    Initialize lube domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp eloop halt
    harnessCmdResp domainop lube init
} -result {}
----

(((chunk,bosal harness tests)))
(((test,domainop-2.1)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.1 {
    Initialize sio domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop sio init
} -result {}
----

== Read Attribute

(((chunk,bosal harness tests)))
(((test,read-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-1.0 {
    Read a single attribute
} -setup {
} -cleanup {
} -body {
    set result [harnessCmdResp read lube Injector_Design ihn4 Model]
    dict get $result Model
} -result {IHN4}
----

(((chunk,bosal harness tests)))
(((test,read-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-2.0 {
    Read all attributes
} -setup {
} -cleanup {
} -body {
    set result [harnessCmdResp read lube Injector_Design ihn4]
    set nattrs [dict size $result]
    set model [dict get $result Model]
    expr {$nattrs == 6 && $model eq "IHN4"}
} -result {1}
----

(((chunk,bosal harness tests)))
(((test,read-3.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-3.0 {
    Unknown attribute
} -setup {
} -cleanup {
} -body {
    harnessCmdResp read lube Injector_Design ihn4 foo
} -result {unknown attribute, "foo"} -returnCodes error
----

== Update Attribute

(((chunk,bosal harness tests)))
(((test,update-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test update-1.0 {
    Update a single attribute
} -setup {
    set oldwindow [dict get\
        [harnessCmdResp read lube Injector_Design ihn4 Delivery_window]\
        Delivery_window]
} -cleanup {
    harnessCmdResp update lube Injector_Design ihn4 Delivery_window $oldwindow
} -body {
    harnessCmdResp update lube Injector_Design ihn4 Delivery_window 42
    set result [harnessCmdResp read lube Injector_Design ihn4 Delivery_window]
    dict get $result Delivery_window
} -result {42}
----

== State Machine Traces

(((chunk,bosal harness tests)))
(((test,trace-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-1.0 {
    Get trace status
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace
} -result {off}
----

(((chunk,bosal harness tests)))
(((test,trace-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-2.0 {
    Turn tracing on
} -setup {
} -cleanup {
    harnessCmdResp trace off
} -body {
    harnessCmdResp trace on
} -result {on}
----

(((chunk,bosal harness tests)))
(((test,trace-3.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-3.0 {
    Bad trace option
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace foo
} -result {unknown trace option, "foo": expected, "on | off"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,trace-3.1)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-3.1 {
    Wrong number of trace arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace on heavy
} -result {wrong # of arguments: 3: expected, "trace ?on | off?"}\
-returnCodes error
----

== Run Event Loop

(((chunk,bosal harness tests)))
(((test,eloop-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test eloop-1.0 {
    Dispatch one event from the event loop
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace on
    for {set i 0} {$i < 10} {incr i} {
        harnessCmdResp eloop once
        set trace [waitForEventTrace type transition]
    }

    dict get $trace target
} -result {Reservoir.res2}
----

== Instrumentation Traces

(((chunk,bosal harness tests)))
(((test,instr-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test instr-1.0 {
    Instrumentation traces
} -setup {
    harnessCmdResp instr on
} -cleanup {
    harnessCmdResp instr off
} -body {
    harnessCmdResp domainop sio Read_point 0
} -result {0}
----

== Code Organization

=== Test Script

(((chunk,bosal-test.test)))

[source,tcl]
----
<<bosal-test.test>>=
#!/usr/bin/env tclsh
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
<<copyright info>>

package require Tcl 8.6
package require cmdline
package require logger
package require struct::queue

set optlist {
    {level.arg warn {Logging level}}
    {nostart {Do not start harness executable}}
    {port.arg 3906 {TCP port for harness communications}}
    {log.arg {test.log} {Log file for harness output}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

logger::setlevel $options(level)

package require tcltest
eval tcltest::configure $argv

namespace eval ::bosal::test {
    <<test utility variables>>
    <<test utility procs>>
}

namespace eval ::bosal::test {
    namespace import ::tcltest::*
    ::logger::initNamespace [namespace current] $::options(level)

    if {!$::options(nostart)} {
        startHarnessExec $::options(log)
    }
    setupHarnessComm $::options(port)

    <<bosal harness tests>>

    cleanupHarnessComm
    cleanupTests
}
----

=== Test Utility Procedures

(((chunk,test utility procs)))
(((proc,startHarnessExec)))

[source,tcl]
----
<<test utility procs>>=
proc startHarnessExec {logfile} {
    exec ./ls_harness > $logfile &
    after 500
}
----

(((chunk,test utility procs)))
(((proc,setupHarnessComm)))

[source,tcl]
----
<<test utility procs>>=
proc setupHarnessComm {{port 3906}} {
    log::info "connecting to localhost:$port"
    variable hchan [socket localhost $port]
    chan configure $hchan -blocking true -buffering line
    chan event $hchan readable\
        [list [namespace current]::handleHarnessInput $hchan]
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc cleanupHarnessComm {} {
    variable hchan
    catch {chan close $hchan}
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc putsToHarness {cmd} {
    variable hchan
    puts $hchan $cmd
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc handleHarnessInput {chanId} {
    set llen [chan gets $chanId line]
    if {$llen == -1} {
        if {[chan eof $chanId]} {
            log::warn "EOF on harness input -- closing \"$chanId\""
            chan close $chanId
        } elseif {[chan blocked $chanId]} {
            log::notice "partial line received"
        }
        return
    }

    if {$llen != 0} {
        log::debug "harness response: \"$line\""

        lassign $line resp_type resp_value

        switch -exact -- $resp_type {
            cmd {
                handleCmdResponse $resp_value
            }
            trace {
                handleTraceResponse $resp_value
            }
            fatal {
                handleFatalResponse $resp_value
            }
            instr {
                handleInstrResponse $resp_value
            }
            default {
                error "unknown response type, \"$resp_value\""
            }
        }
    }
}
----

[source,tcl]
----
<<test utility variables>>=
variable cmdPattern
variable cmdSyncVar {}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc harnessCmdResp {args} {
    variable cmdPattern
    set cmdPattern [dict create\
        name [lindex $args 0]\
        timer [after 3000 [namespace code cmdTimeout]]
    ]
    putsToHarness $args

    set response [waitForCmdResponse]
    set result [dict get $response result]
    if {[dict get $response status] eq "error"} {
        error $result
    }
    return $result
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc handleCmdResponse {respValue} {
    variable cmdPattern

    set expectedName [dict get $cmdPattern name]
    set recvdName [dict get $respValue name]

    if {[string match $expectedName $recvdName]} {
        signalCmdResponse $respValue
    } else {
        log::error "expected response to $expectedName command,\
                got response to $recvdName command"
        signalCmdResponse ERROR
    }
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc cmdTimeout {} {
    set [namespace current]::cmdSyncVar TIMEOUT
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc signalCmdResponse {value} {
    set [namespace current]::cmdSyncVar $value
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc waitForCmdResponse {} {
    vwait [namespace current]::cmdSyncVar
    variable cmdPattern
    variable cmdSyncVar

    if {$cmdSyncVar eq "TIMEOUT"} {
        error "timeout for command, \"[dict get $cmdPattern name]\""
    } else {
        after cancel [dict get $cmdPattern timer]
    }
    return $cmdSyncVar
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility variables>>=
variable traceSyncVar {}
variable tracesReceived [::struct::queue]
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc handleTraceResponse {respValue} {
    variable tracesReceived

    $tracesReceived put $respValue

    set [namespace current]::traceSyncVar TRACE
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc waitForEventTrace {args} {
    variable tracesReceived
    variable traceSyncVar

    set expect $args
    while {true} {
        while {[$tracesReceived size] != 0} {
            set actual [$tracesReceived get]

            set traceMatched 0
            dict for {key value} $expect {
                if {[dict exists $actual $key] &&\
                        [string match $value [dict get $actual $key]]} {
                    incr traceMatched
                }
            }
            if {$traceMatched == [dict size $expect]} {
                return $actual
            } else {
                log::notice "discarding trace, \"$actual\":\
                        failed to match, \"$expect\""
            }
        }

        set timer [after 3000 [namespace code traceTimeout]]
        vwait [namespace current]::traceSyncVar
        if {$traceSyncVar eq "TIMEOUT"} {
            error "timed out on receiving event traces"
        } else {
            after cancel $timer
        }
    }
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc traceTimeout {} {
    set [namespace current]::traceSyncVar TIMEOUT
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility variables>>=
variable instrSyncVar {}
variable instrReceived [::struct::queue]
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc handleInstrResponse {respValue} {
    variable instrReceived

    $instrReceived put $respValue

    set [namespace current]::instrSyncVar INSTR
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc waitForInstrTrace {pattern} {
    variable instrReceived
    variable instrSyncVar

    while {true} {
        while {[$instrReceived size] != 0} {
            set actual [$instrReceived get]

            if {[string match $pattern $actual]} {
                return $actual
            } else {
                log::notice "discarding instrumentation, \"$actual\":\
                        failed to match, \"$pattern\""
            }
        }

        set timer [after 3000 [namespace code instrTimeout]]
        vwait [namespace current]::instrSyncVar
        if {$instrSyncVar eq "TIMEOUT"} {
            error "timed out on receiving instrumentation traces"
        } else {
            after cancel $timer
        }
    }
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc instrTimeout {} {
    set [namespace current]::instrSyncVar TIMEOUT
}
----

(((chunk,test utility procs)))

[source,tcl]
----
<<test utility procs>>=
proc handleFatalResponse {respValue} {
    log::error "fatal error response, \"$respValue\""
    error $respValue
}
----

=== Copyright Information

[source,tcl]
----
<<copyright info>>=
# This software is copyrighted 2017 - 2018 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

////

(((chunk,bosal harness tests)))
(((test,%)))

[source,tcl]
----
<<bosal harness tests>>=
test % {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////
