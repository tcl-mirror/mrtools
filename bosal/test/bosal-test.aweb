// vim:set syntax=asciidoc:

= Unit Tests for Bosal

== Null Command

(((chunk,bosal harness tests)))
(((test,null-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test null-1.0 {
    Null command test
} -setup {
} -cleanup {
} -body {
    harnessCmdResp null
} -result {}
----

(((chunk,bosal harness tests)))
(((test,null-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test null-2.0 {
    Null command with wrong argument count
} -setup {
} -cleanup {
} -body {
    harnessCmdResp null foo
} -result {wrong # of arguments, 2: expected, null} -returnCodes error
----

== Domain Operations

(((chunk,bosal harness tests)))
(((test,domainop-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.0 {
    Unknown domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop foo init
} -result {unknown domain, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-1.1)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.1 {
    No operation name
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop sio
} -result {wrong # of arguments: 2: expected, domainop <domain> <operation> ?<arg1> <arg2> ...?}\
-returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-1.2)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.2 {
    Unknown operations
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop sio foo
} -result {unknown operation, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-1.3)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.3 {
    Missing operation argument
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop lube Suspend_Autocycle_Session
} -result {wrong # arguments: got 0, expected 1} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-1.4)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.4 {
    Bad operation argument
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop lube Suspend_Autocycle_Session foo
} -result {bad parameter: "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.0 {
    Initialize lube domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop lube init
} -result {}
----

(((chunk,bosal harness tests)))
(((test,domainop-2.1)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.1 {
    Initialize sio domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop sio init
} -result {}
----

== Query Domains

(((chunk,bosal harness tests)))
(((test,query-domains-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-domains-1.0 {
    query domains successfully
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query domains
} -result {lube sio}
----

(((chunk,bosal harness tests)))
(((test,query-domains-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-domains-2.0 {
    query domains with too many arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query domains foo
} -result {wrong # of arguments, 3: expected, query domains} -returnCodes error
----

== Query Classes

(((chunk,bosal harness tests)))
(((test,query-classes-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-1.0 {
    query lube classes
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes lube
} -result {Lubrication_Schedule Injector_Design Injector Autocycle_Session Machinery Reservoir}
----

(((chunk,bosal harness tests)))
(((test,query-classes-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-2.0 {
    query classes -- unknown domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes foo
} -result {unknown domain, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,query-classes-2.1)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-2.1 {
    query classes -- wrong number of arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes foo bar
} -result {wrong # of arguments, 4: expected, "query classes <domain>"}\
-returnCodes error
----

(((chunk,bosal harness tests)))
(((test,read-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-1.0 {
    Read a single attribute
} -setup {
} -cleanup {
} -body {
    set result [harnessCmdResp read lube Injector_Design ihn4 Model]
    dict get $result Model
} -result {IHN4}
----

== Read Attribute

(((chunk,bosal harness tests)))
(((test,read-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-2.0 {
    Read all attributes
} -setup {
} -cleanup {
} -body {
    set result [harnessCmdResp read lube Injector_Design ihn4]
    set nattrs [dict size $result]
    set model [dict get $result Model]
    expr {$nattrs == 6 && $model eq "IHN4"}
} -result {1}
----

(((chunk,bosal harness tests)))
(((test,read-3.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-3.0 {
    Unknown attribute
} -setup {
} -cleanup {
} -body {
    harnessCmdResp read lube Injector_Design ihn4 foo
} -result {unknown attribute, "foo"} -returnCodes error
----

== State Machine Traces

(((chunk,bosal harness tests)))
(((test,trace-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-1.0 {
    Get trace status
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace
} -result {off}
----

(((chunk,bosal harness tests)))
(((test,trace-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-2.0 {
    Turn tracing on
} -setup {
} -cleanup {
    harnessCmdResp trace off
} -body {
    harnessCmdResp trace on
} -result {on}
----

(((chunk,bosal harness tests)))
(((test,trace-3.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-3.0 {
    Bad trace option
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace foo
} -result {unknown trace option, "foo": expected, "on | off"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,trace-3.1)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-3.1 {
    Wrong number of trace arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace on heavy
} -result {wrong # of arguments: 3: expected, "trace ?on | off?"}\
-returnCodes error
----

== Update Attribute

(((chunk,bosal harness tests)))
(((test,update-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test update-1.0 {
    Update a single attribute
} -setup {
    set oldwindow [dict get\
        [harnessCmdResp read lube Injector_Design ihn4 Delivery_window]\
        Delivery_window]
} -cleanup {
    harnessCmdResp update lube Injector_Design ihn4 Delivery_window $oldwindow
} -body {
    harnessCmdResp update lube Injector_Design ihn4 Delivery_window 42
    set result [harnessCmdResp read lube Injector_Design ihn4 Delivery_window]
    dict get $result Delivery_window
} -result {42}
----

== Code Organization

=== Test Script

(((chunk,bosal-test.test)))

[source,tcl]
----
<<bosal-test.test>>=
#!/usr/bin/env tclsh
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
<<copyright info>>

package require Tcl 8.6
package require cmdline
package require logger

set optlist {
    {level.arg warn {Logging level}}
    {nostart {Do not start harness executable}}
    {port.arg 3906 {TCP port for harness communications}}
    {log.arg {test.log} {Log file for harness output}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

logger::setlevel $options(level)

package require tcltest
eval tcltest::configure $argv

namespace eval ::bosal::test {
    variable syncPatterns ; array set syncPatterns {}
    variable syncVar {}

    <<test utility procs>>
}

namespace eval ::bosal::test {
    namespace import ::tcltest::*
    ::logger::initNamespace [namespace current] $::options(level)

    if {!$::options(nostart)} {
        startHarnessExec $::options(log)
    }
    setupHarnessComm $::options(port)

    <<bosal harness tests>>

    cleanupHarnessComm
    cleanupTests
}
----

=== Test Utility Procedures

(((chunk,test utility procs)))
(((proc,startHarnessExec)))

[source,tcl]
----
<<test utility procs>>=
proc startHarnessExec {logfile} {
    exec ./ls_harness > $logfile &
    after 500
}
----

(((chunk,test utility procs)))
(((proc,setupHarnessComm)))

[source,tcl]
----
<<test utility procs>>=
proc setupHarnessComm {port} {
    log::info "connecting to localhost:$port"
    variable hchan [socket localhost $port]
    chan configure $hchan -blocking true -buffering line
    chan event $hchan readable\
        [list [namespace current]::handleHarnessInput $hchan]
}

proc syncToResponse {value} {
    set [namespace current]::syncVar $value
}

proc waitForResponse {} {
    vwait [namespace current]::syncVar
    variable syncVar
    if {$syncVar eq "ERROR" || $syncVar eq "TIMEOUT"} {
        error "response error, $syncVar"
    }
    return $syncVar
}

proc handleHarnessInput {chanId} {
    set llen [chan gets $chanId line]
    if {$llen == -1} {
        if {[chan eof $chanId]} {
            log::warn "EOF on harness input -- closing \"$chanId\""
            chan close $chanId
        } elseif {[chan blocked $chanId]} {
            log::notice "partial line received"
        }
        return
    }

    if {$llen != 0} {
        log::debug "harness response: \"$line\""

        lassign $line resp_type resp_value

        switch -exact -- $resp_type {
            cmd {
                handleCmdResponse $resp_value
            }
            trace {
                handleTraceResponse $resp_value
            }
            fatal {
                handleFatalResponse $resp_value
            }
            instr {
                handleInstResponse $resp_value
            }
            default {
                error "unknown response type, \"$resp_value\""
            }
        }
    }
}

proc handleCmdResponse {respValue} {
    variable syncPatterns

    if {[info exists syncPatterns(cmd)]} {
        set pattern $syncPatterns(cmd)

        set expectedName [dict get $syncPatterns(cmd) name]
        set recvdName [dict get $respValue name]

        if {$recvdName eq $expectedName} {
            syncToResponse $respValue
        } else {
            log::error "expected response to $expectedName command,\
                    got response to $recvdName command"
            syncToResponse ERROR
        }
        array unset syncPatterns(cmd)
    } else {
        log::error "received unexpected command response, \"$respValue\""
    }
}

proc handleTraceResponse {respValue} {
}

proc handleFatalResponse {respValue} {
}

proc handleInstrResponse {respValue} {
}

proc cleanupHarnessComm {} {
    variable hchan
    chan close $hchan
}

proc putsToHarness {cmd} {
    variable hchan
    puts $hchan $cmd
}

proc harnessCmdResp {args} {
    variable syncPatterns
    set syncPatterns(cmd) [dict create name [lindex $args 0]]
    putsToHarness $args

    set response [waitForResponse]
    set result [dict get $response result]
    if {[dict get $response status] eq "error"} {
        error $result
    }
    return $result
}
----

=== Copyright Information

This software is copyrighted.
It is licensed in the same manner as Tcl itself.

[source,tcl]
----
<<copyright info>>=
# This software is copyrighted 2017 - 2018 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

////

(((chunk,bosal harness tests)))
(((test,%)))

[source,tcl]
----
              <<bosal harness tests>>=
test % {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////
