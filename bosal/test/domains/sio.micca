# DO NOT EDIT THIS FILE!
# THIS FILE IS GENERATED FROM THE SOURCE OF A LITERATE PROGRAM.
# YOU MUST EDIT THE ORIGINAL SOURCE TO MODIFY THIS FILE.
#*++
# Copyright:
#   Copyright 2016, by the authors of "Models to Code".
#   All rights reserved.
#
# Project:
#   Models to Code Book
#
# Module:
#   Signal I/O Domain micca file
#*--

domain sio {
    typealias SioPointID_t MRT_InstId
    typealias SioPointValue_t int32_t
    typealias PointValueMask_t uint32_t
    typealias Count_t int
    typealias Msec_t uint32_t
    typealias SioConverterID_t MRT_InstId
    typealias SioGroupID_t MRT_InstId
    typealias SioThresholdID_t MRT_InstId
    typealias AccessType_t {enum {ReadWrite, ReadOnly, WriteOnly}}
    typealias MemoryType_t {enum {Memory, ReadClear, ReadClearZero}}
    typealias EdgeType_t {enum {Inactive, Active, BothActive}}
    typealias BitCount_t uint8_t
    typealias BitOffset_t uint8_t
    typealias ExcursionDirection_t {enum {Rising, Falling}}
    domainop SioPointValue_t Read_point {pid SioPointID_t} {
        <%IO_Point idtoref pid iop%>
        return <%instance iop operation readPoint%> ;
    }
    domainop void Write_point {pid SioPointID_t value SioPointValue_t} {
        <%IO_Point idtoref pid iop%>
        <%instance iop operation writePoint value value%> ;
    }
    domainop void init {} {
        <%IO_Point foreachInstance iop%>
            <%instance iop findOneRelated spt {~R1 Signalling_Point}%>
            if (spt != NULL) {
                <%instance spt signal On%>
            }
        <%end%>
    }
    eentity NOTIFY {
        operation void New_point_value {
                point SioPointID_t
                value SioPointValue_t} {
        }
    }
    eentity NOTIFY {
        operation void In_range {
                point SioPointID_t
                threshold SioThresholdID_t} {
        }
    }
    eentity NOTIFY {
        operation void Out_of_range {
                point SioPointID_t
                threshold SioThresholdID_t} {
        }
    }
    eentity NOTIFY {
        operation void Signal_point {
                point SioPointID_t
                isActive bool} {
        }
    }
    eentity DEVICE {
        operation void Convert_group {
                converter SioConverterID_t
                group SioGroupID_t} {
        }
    }
    eentity DEVICE {
        operation SioPointValue_t Read_converted_value {
                converter SioConverterID_t
                point SioPointID_t} {
            return 1 ;
        }
    }
    eentity DEVICE {
        operation void Write_reg {
                pid SioPointID_t
                value SioPointValue_t} {
        }
    }
    eentity DEVICE {
        operation SioPointValue_t Read_reg {
                pid SioPointID_t} {
            return 1 ;
        }
    }
    eentity DEVICE {
        operation void Enable_signal {
                pid SioPointID_t} {
        }
    }
    eentity DEVICE {
        operation void Disable_signal {
                pid SioPointID_t} {
        }
    }
    class IO_Point {
        instop SioPointValue_t readPoint {} {
            SioPointValue_t value = 0 ;
            <%R1 classify self ptref%>
                <%subclass Discrete_Point%>
                    value = <%instance ptref operation readPoint%> ;
                <%end%>
                <%subclass Signalling_Point%>
                    value = <%instance ptref operation readPoint%> ;
                <%end%>
                <%subclass Continuous_Point%>
                    value = <%instance ptref operation readPoint%> ;
                <%end%>
            <%end%>
            return value ;
        }
        instop void writePoint {
                value SioPointValue_t} {
            <%R1 classify self ptref%>
                <%subclass Discrete_Point%>
                    <%instance ptref operation writePoint value value%> ;
                <%end%>
                <%subclass Continuous_Point%>
                    <%instance ptref operation writePoint value value%> ;
                <%end%>
                <%default%>
                    // Only Discrete and Continuous points can be written
                <%end%>
            <%end%>
        }
    }
    class Discrete_Point {
        instop SioPointValue_t readPoint {} {
            SioPointValue_t value = 0 ;
        
            <%R8 classify self ptref%>
                <%subclass Packed_Point%>
                    value = <%instance ptref operation readPoint%> ;
                <%end%>
                <%subclass Control_Point%>
                    value = <%instance ptref operation readPoint%> ;
                <%end%>
            <%end%>
        
            return value ;
        }
        instop void writePoint {value SioPointValue_t} {
            <%R8 classify self ptref%>
                <%subclass Packed_Point%>
                    <%instance ptref operation writePoint value value%> ;
                <%end%>
                <%subclass Control_Point%>
                    <%instance ptref operation writePoint value value%> ;
                <%end%>
            <%end%>
        }
    }
    class Signalling_Point {
        attribute Value SioPointValue_t -default 0
        attribute Trigger EdgeType_t
        attribute Active_high bool
        attribute Debounce_time Msec_t
        instop void evalSignal {} {
            <%my findOneRelated iop R1%>
            SioPointID_t ptid = <%instance iop instid%> ;
        
            <%my assign Value Active_high Trigger%>
        
            if ((Value == 1 && Active_high) || (Value == 0 && !Active_high)) {
                if (Trigger != Inactive) {
                    <%NOTIFY Signal_point point ptid isActive true%> ;
                }
            } else {
                if (Trigger != Active) {
                    <%NOTIFY Signal_point point ptid isActive false%> ;
                }
            }
            <%DEVICE Enable_signal pid ptid%> ;
        }
        instop SioPointValue_t readPoint {} {
            SioPointID_t spid = <%my instid%> ;
            return <%DEVICE Read_reg pid spid%> ;
        }
        statemodel {
            initialstate OFF
            defaulttrans IG
            
            transition OFF - On -> ON
            transition OFF - Confirm -> CH
            
            transition ON - Off -> OFF
            transition ON - Confirm -> CH
            transition ON - Trigger -> DEBOUNCING
            
            transition DEBOUNCING - Off -> OFF
            transition DEBOUNCING - Confirm -> CONFIRMING
            
            transition CONFIRMING - Off -> OFF
            transition CONFIRMING - Confirm -> CH
            transition CONFIRMING - Trigger -> DEBOUNCING
            state OFF {} {
                <%my canceldelayed Confirm%>
                <%my findOneRelated iop R1%>
                MRT_InstId iopid = <%instance iop instid%> ;
                <%DEVICE Disable_signal pid iopid%> ;
            }
            state ON {} {
                <%my findOneRelated iop R1%>
                MRT_InstId iopid = <%instance iop instid%> ;
                <%my attr Value%> = <%DEVICE Read_reg pid iopid%> ;
                <%my operation evalSignal%> ;
            }
            state DEBOUNCING {} {
                <%my assign Debounce_time%>
                <%my delaysignal Debounce_time Confirm%> ;
            }
            state CONFIRMING {} {
                <%my findOneRelated iop R1%>
                MRT_InstId iopid = <%instance iop instid%> ;
            
                SioPointValue_t value = <%DEVICE Read_reg pid iopid%> ;
                if (value != <%my attr Value%>) {
                    <%my attr Value%> = value ;
                    <%my operation evalSignal%> ;
                }
            }
        }
    }
    class Continuous_Point {
        instop SioPointValue_t readPoint {} {
            SioPointValue_t value ;
            <%R2 classify self ptref%>
                <%subclass Continuous_Input_Point%>
                    value = <%instance ptref attr Value%> ;
                <%end%>
                <%default%>
                    value = 0 ;
                <%end%>
            <%end%>
        
            return value ;
        }
        instop void writePoint {value SioPointValue_t} {
            <%R2 classify self ptref%>
                <%subclass Continuous_Output_Point%>
                    <%instance ptref operation writePoint value value%> ;
                <%end%>
                <%default%>
                    /*
                     * Writes to Continuous Input Points are silently ignored.
                     */
                <%end%>
            <%end%>
        }
    }
    class Packed_Point {
        attribute Length BitCount_t
        attribute Offset BitOffset_t
        instop SioPointValue_t readPoint {} {
            <%my findOneRelated ctpt R9%>
            SioPointValue_t value = <%instance ctpt operation readPoint%> ;
            SioPointValue_t mask = (1 << <%my attr Length%>) - 1 ;
            return (value >> <%my attr Offset%>) & mask ;
        }
        instop void writePoint {value SioPointValue_t} {
            <%my assign Length Offset%>
            SioPointValue_t mask = ((1 << Length) - 1) << Offset ;
        
            <%my findOneRelated ctpt R9%>
            SioPointValue_t base ;
            switch (<%instance ctpt attr Memory_model%>) {
            case Memory:
            default:
                base = <%instance ctpt operation readPoint%> ;
                break ;
        
            case ReadClear:
                base = 0 ;
                break ;
        
            case ReadClearZero:
                base = ~0 ;
                break ;
            }
        
            <%instance ctpt operation writePoint value {
                    ((value << mask) | base)
            }%> ;
        }
    }
    class Control_Point {
        attribute Memory_model MemoryType_t
        attribute Access AccessType_t
        instop SioPointValue_t readPoint {} {
            SioPointValue_t value = 0 ;
            if (<%my attr Access%> != WriteOnly) {
                SioPointID_t cpid = <%my instid%> ;
                value = <%DEVICE Read_reg pid cpid%> ;
            }
            return value ;
        }
        instop void writePoint {value SioPointValue_t} {
            if (<%my attr Access%> != ReadOnly) {
                SioPointID_t cpid = <%my instid%> ;
                <%DEVICE Write_reg pid cpid value value%> ;
            }
        }
    }
    class Continuous_Output_Point {
        instop void writePoint {value SioPointValue_t} {
            <%my findOneRelated ps R2 R3%>
            SioPointValue_t scaled = <%instance ps operation scaleValueOut value value%> ;
            MRT_InstId iopid = <%my instid%> ;
            <%DEVICE Write_reg pid iopid value scaled%> ;
        }
    }
    class Continuous_Input_Point {
        attribute Value SioPointValue_t -default 0
        instop void updateValue {value SioPointValue_t} {
            <%my findOneRelated ps R2 R3%>
            SioPointValue_t scaled = <%instance ps operation scaleValueIn value value%> ;
            <%my update Value scaled%>
            MRT_InstId iopid = <%my instid%> ;
            <%NOTIFY New_point_value point iopid value scaled%> ;
        
            <%my foreachRelated rl {R7 Range_Limitation}%>
                <%instance rl signal New_point pointValue scaled%>
            <%end%>
        }
    }
    class Point_Scaling {
        attribute Multiplier SioPointValue_t
        attribute Divisor SioPointValue_t
        attribute Intercept SioPointValue_t
        attribute Mask PointValueMask_t
        instop SioPointValue_t scaleValueIn {value SioPointValue_t} {
            <%my assign Intercept Multiplier Divisor Mask%>
            /*
             * Convert, rounding to deal with division truncation.
             */
            SioPointValue_t in =
                    ((value * Multiplier + Divisor / 2) / Divisor) + Intercept ;
            if (in > Mask) {
                in = Mask ;
            }
            return in ;
        }
        instop SioPointValue_t scaleValueOut {value SioPointValue_t} {
            <%my assign Intercept Multiplier Divisor Mask%>
            if (value < Intercept) {
                value = Intercept ;
            }
            /*
             * Convert, rounding to deal with division truncation.
             */
            SioPointValue_t out =
                    (((value - Intercept) * Multiplier) + Divisor / 2) / Divisor ;
            if (out > Mask) {
                out = Mask ;
            }
            return out ;
        }
    }
    class Point_Threshold {
        attribute Limit SioPointValue_t
        attribute Direction ExcursionDirection_t
        attribute Over_limit Count_t
        attribute Under_limit Count_t
    }
    class Range_Limitation {
        attribute Over_count Count_t -default 0
        attribute Under_count Count_t -default 0
        statemodel {
            initialstate IN_RANGE
            defaulttrans CH
            
            transition IN_RANGE - New_point -> CHECKING_OUT_OF_RANGE
            
            transition CHECKING_OUT_OF_RANGE - New_point -> CHECKING_OUT_OF_RANGE
            transition CHECKING_OUT_OF_RANGE - Out_of_range -> OUT_OF_RANGE
            
            transition OUT_OF_RANGE - New_point -> CHECKING_IN_RANGE
            
            transition CHECKING_IN_RANGE - New_point -> CHECKING_IN_RANGE
            transition CHECKING_IN_RANGE - In_range -> IN_RANGE
            state IN_RANGE {} {
                <%my findOneRelated iop ~R7 R2 R1%>
                MRT_InstId iopid = <%instance iop instid%> ;
            
                <%my findOneRelated pt R7%>
                MRT_InstId ptid = <%instance pt instid%> ;
            
                <%NOTIFY In_range point iopid threshold ptid%> ;
                <%my update Over_count 0%>
            }
            state CHECKING_OUT_OF_RANGE {pointValue SioPointValue_t} {
                <%my findOneRelated pt R7%>
                bool outRange ;
                if (<%instance pt attr Direction%> == Rising) {
                    outRange = pointValue > <%instance pt attr Limit%> ;
                } else {
                    outRange = pointValue <= <%instance pt attr Limit%> ;
                }
                if (outRange) {
                    if (++<%my attr Over_count%> >= <%instance pt attr Over_limit%>) {
                        <%my signal Out_of_range%>
                    }
                } else {
                    <%my update Over_count 0%>
                }
            }
            state OUT_OF_RANGE {} {
                <%my findOneRelated iop ~R7 R2 R1%>
                MRT_InstId iopid = <%instance iop instid%> ;
            
                <%my findOneRelated pt R7%>
                MRT_InstId ptid = <%instance pt instid%> ;
            
                <%NOTIFY Out_of_range point iopid threshold ptid%> ;
                <%my update Under_count 0%>
            }
            state CHECKING_IN_RANGE {pointValue SioPointValue_t} {
                <%my findOneRelated pt R7%>
                bool inRange ;
                if (<%instance pt attr Direction%> == Rising) {
                    inRange = pointValue <= <%instance pt attr Limit%> ;
                } else {
                    inRange = pointValue > <%instance pt attr Limit%> ;
                }
                if (inRange) {
                    if (++<%my attr Under_count%> >= <%instance pt attr Under_limit%>) {
                        <%my signal In_range%>
                    }
                } else {
                    <%my update Under_count 0%>
                }
            }
        }
    }
    class Signal_Converter {
        attribute Converter_available bool -default true
        statemodel {
            initialstate CONVERSION_COMPLETE
            defaulttrans CH
            
            transition CONVERSION_COMPLETE - Converter_assigned -> CONVERTING
            
            transition CONVERTING - Conversion_done -> CONVERSION_COMPLETE
            state CONVERSION_COMPLETE {} {
                <%my findOneRelated cg ~R6%>
                assert(cg != NULL) ;
            
                MRT_InstId selfid = <%my instid%> ;
                <%instance cg foreachRelated cip ~R4%>
                    SioPointID_t cipid = <%instance cip instid%> ;
                    SioPointValue_t value = <%DEVICE Read_converted_value\
                            converter selfid point cipid%> ;
                    <%instance cip operation updateValue value value%> ;
                <%end%>
                <%instance cg signal Conversion_done%>
            
                <%my findOneRelated cvn {~R6 Conversion}%>
                <%instance cvn delete%>
                <%my update Converter_available true%>
                <%R6 findByIdInstance self r6asgn%>
                <%instance r6asgn signal Converter_ready%>
            }
            state CONVERTING {} {
                <%my findOneRelated cg ~R6%>
                assert(cg != NULL) ;
                MRT_InstId cgid = <%instance cg instid%> ;
                MRT_InstId selfid = <%my instid%> ;
                <%DEVICE Convert_group converter selfid group cgid%> ;
            }
        }
    }
    class Conversion_Group {
        attribute Waiting_for_converter bool -default false
        attribute Period Msec_t
        statemodel {
            initialstate FINISHED
            defaulttrans CH
            
            transition FINISHED - Sample -> WAITING_FOR_CONVERSION
            transition FINISHED - Stop -> IG
            transition FINISHED - Conversion_done -> IG
            
            transition WAITING_FOR_CONVERSION - Sample -> WAITING_FOR_CONVERSION
            transition WAITING_FOR_CONVERSION - Stop -> FINISHED
            transition WAITING_FOR_CONVERSION - Conversion_done -> CONVERSION_COMPLETED
            
            transition CONVERSION_COMPLETED - Sample -> WAITING_FOR_CONVERSION
            transition CONVERSION_COMPLETED - Stop -> FINISHED
            state FINISHED {} {
                <%my canceldelayed Sample%>
                <%my update Waiting_for_converter false%>
                mrt_SyncToEventLoop() ;
            }
            state WAITING_FOR_CONVERSION {} {
                <%my update Waiting_for_converter true%>
                <%my findOneRelated sc R5%>
                <%R6 findByIdInstance sc r6asgn%>
                <%instance r6asgn signal Group_ready%>
            }
            state CONVERSION_COMPLETED {} {
                <%my assign Period%>
                if (Period != 0) {
                    <%my delaysignal Period Sample%>
                }
            }
        }
    }
    class Conversion {}
    generalization R1 -union IO_Point\
        Discrete_Point\
        Signalling_Point\
        Continuous_Point
    generalization R8 -union Discrete_Point\
        Packed_Point\
        Control_Point
    association R9 -static Packed_Point 0..*--1 Control_Point
    association R3 -static Continuous_Point 1..*--1 Point_Scaling
    generalization R2 -union Continuous_Point\
        Continuous_Output_Point\
        Continuous_Input_Point
    association R7 -static -associator Range_Limitation\
        Continuous_Input_Point 1..*--0..* Point_Threshold
    association R4 -static Continuous_Input_Point 1..*--1 Conversion_Group
    association R5 -static Conversion_Group 1..*--1 Signal_Converter
    association R6 -associator Conversion\
            Conversion_Group 0..1--0..1 Signal_Converter {
        identifyby Signal_Converter
        statemodel {
            defaulttrans CH
            initialstate WAITING_FOR_GROUP
            
            transition WAITING_FOR_GROUP - Group_ready -> WAITING_FOR_CONVERTER
            transition WAITING_FOR_GROUP - Converter_ready -> IG
            
            transition WAITING_FOR_CONVERTER - Group_ready -> IG
            transition WAITING_FOR_CONVERTER - Converter_ready -> Assigning_Converter
            
            transition Assigning_Converter - Group_ready -> IG
            transition Assigning_Converter - Converter_ready -> IG
            transition Assigning_Converter - Converter_assigned -> WAITING_FOR_GROUP
            state WAITING_FOR_GROUP {} {
                <%Signal_Converter refvar sc%>
                sc = <%my attr idinstance%> ;
            
                <%instance sc foreachRelatedWhere cg {cg->Waiting_for_converter} ~R5%>
                    <%my signal Group_ready%>
                    break ;
                <%end%>
            }
            state WAITING_FOR_CONVERTER {} {
                <%Signal_Converter refvar sc%>
                sc = <%my attr idinstance%> ;
            
                if (<%instance sc attr Converter_available%>) {
                    <%my signal Converter_ready%>
                }
            }
            state Assigning_Converter {} {
                <%Signal_Converter refvar sc%>
                sc = <%my attr idinstance%> ;
            
                assert(<%instance sc attr Converter_available%>) ;
            
                <%instance sc foreachRelatedWhere cg {cg->Waiting_for_converter} ~R5%>
                    <%instance sc update Converter_available false%>
                    <%instance cg update Waiting_for_converter false%>
                    <%Conversion create cnv R6 {Signal_Converter sc Conversion_Group cg}%>
                    <%my signal Converter_assigned%>
                    <%instance sc signal Converter_assigned%>
                    break ;
                <%end%>
            }
        }
    }
}

population sio {
    class IO_Point {
        table       {}\
            iop1    {}\
            iop2    {}\
            iop3    {}\
            iop4    {}\
            iop5    {}\
            iop6    {}\
            iop7    {}\
            iop8    {}\
            iop9    {}\
            iop10   {}\
            iop11   {}
    }
    class Discrete_Point {
        table               {R1}\
            iop4            {iop4}\
            iop5            {iop5}\
            iop6            {iop6}
    }
    
    class Signalling_Point {
        table                   {Trigger    Active_high Debounce_time  R1}\
            iop7                {BothActive true        500         iop7}\
            iop8                {BothActive true        500         iop8}\
            iop9                {BothActive true        500         iop9}\
            iop10               {BothActive true        2000        iop10}\
            iop11               {BothActive true        2000        iop11}
    }
    
    class Continuous_Point {
        table                   {R1             R3}\
            iop1                {iop1           ix77b_pres_scale}\
            iop2                {iop2           ihn4_pres_scale}\
            iop3                {iop3           ix77b_pres_scale}
    }
    
    class Point_Scaling {
        table                   {Multiplier Divisor Intercept   Mask}\
            ihn4_pres_scale     {1          1       0           ~0}\
            ix77b_pres_scale    {1          1       0           ~0}
    }
    
    class Packed_Point {
    }
    
    class Control_Point {
        table               {Memory_model Access        R8}\
            iop4            {Memory       ReadWrite     iop4}\
            iop5            {Memory       ReadWrite     iop5}\
            iop6            {Memory       ReadWrite     iop6}
    }
    
    class Continuous_Output_Point {
    }
    
    class Continuous_Input_Point {
        table                       {R2             R4}\
            iop1                    {iop1           cg1}\
            iop2                    {iop2           cg2}\
            iop3                    {iop3           cg3}
    }
    
    class Point_Threshold {
        table               {Limit Direction Over_limit Under_limit}\
            pt1             {19    Rising    2          2}\
            pt2             {35    Rising    1          2}\
            pt3             {32    Rising    2          2}\
            pt4             {15    Rising    2          2}\
            pt5             {26    Rising    1          2}\
            pt6             {26    Rising    2          2}
    }
    
    class Range_Limitation {
        table               {R7}\
            pt4_iop1        {{Continuous_Input_Point iop1 Point_Threshold pt4}}\
            pt5_iop1        {{Continuous_Input_Point iop1 Point_Threshold pt5}}\
            pt6_iop1        {{Continuous_Input_Point iop1 Point_Threshold pt6}}\
            pt1_iop2        {{Continuous_Input_Point iop2 Point_Threshold pt1}}\
            pt2_iop2        {{Continuous_Input_Point iop2 Point_Threshold pt2}}\
            pt3_iop2        {{Continuous_Input_Point iop2 Point_Threshold pt3}}\
            pt4_iop3        {{Continuous_Input_Point iop3 Point_Threshold pt4}}\
            pt5_iop3        {{Continuous_Input_Point iop3 Point_Threshold pt5}}\
            pt6_iop3        {{Continuous_Input_Point iop3 Point_Threshold pt6}}
    }
    
    class Conversion_Group {
        table          {Period     R5}\
            cg1        {500        cvt1}\
            cg2        {500        cvt1}\
            cg3        {500        cvt1}
    }
    
    class Signal_Converter {
        instance cvt1
    }
    
    class Conversion {
        allocate 1
    }
    
    assigner R6 {
        instance r6asgn1 cvt1
    }
    
}
