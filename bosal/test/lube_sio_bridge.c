/*
# DO NOT EDIT THIS FILE!
# THIS FILE IS GENERATED FROM THE SOURCE OF A LITERATE PROGRAM.
# YOU MUST EDIT THE ORIGINAL SOURCE TO MODIFY THIS FILE.
#*++
# Copyright:
#   Copyright 2016, by the authors of "Models to Code".
#   All rights reserved.
#
# Project:
#   Models to Code Book
#
# Module:
#   Lube domain to Signal I/O Domain bridge code
#*--
*/

#include "lube.h"
#include "sio.h"

typedef struct {
    MRT_InstId fromInst ;
    MRT_InstId toInst ;
} BridgeIDMap ;
static SioPointValue_t const injToPointMap[LUBE_INJECTOR_INSTCOUNT] = {
    [LUBE_INJECTOR_IN1_INSTID] = SIO_IO_POINT_IOP1_INSTID,
    [LUBE_INJECTOR_IN2_INSTID] = SIO_IO_POINT_IOP2_INSTID,
    [LUBE_INJECTOR_IN3_INSTID] = SIO_IO_POINT_IOP3_INSTID,
} ;
static SioPointValue_t const presToConvGrpMap[LUBE_INJECTOR_INSTCOUNT] = {
    [LUBE_INJECTOR_IN1_INSTID] = SIO_CONVERSION_GROUP_CG1_INSTID,
    [LUBE_INJECTOR_IN2_INSTID] = SIO_CONVERSION_GROUP_CG2_INSTID,
    [LUBE_INJECTOR_IN3_INSTID] = SIO_CONVERSION_GROUP_CG3_INSTID,
} ;
static BridgeIDMap const presToInjMap[LUBE_INJECTOR_INSTCOUNT] = {
    {
        .fromInst = SIO_IO_POINT_IOP1_INSTID,
        .toInst = LUBE_INJECTOR_IN1_INSTID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP2_INSTID,
        .toInst = LUBE_INJECTOR_IN2_INSTID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP3_INSTID,
        .toInst = LUBE_INJECTOR_IN3_INSTID,
    },
} ;
static BridgeIDMap const
    sigPtToLubeInstMap[LUBE_MACHINERY_INSTCOUNT + LUBE_RESERVOIR_INSTCOUNT] = {
    {
        .fromInst = SIO_IO_POINT_IOP7_INSTID,
        .toInst = LUBE_MACHINERY_M1_INSTID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP8_INSTID,
        .toInst = LUBE_MACHINERY_M2_INSTID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP9_INSTID,
        .toInst = LUBE_MACHINERY_M3_INSTID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP10_INSTID,
        .toInst = LUBE_RESERVOIR_RES1_INSTID,
    },
    {
        .fromInst = SIO_IO_POINT_IOP11_INSTID,
        .toInst = LUBE_RESERVOIR_RES2_INSTID,
    },
} ;
static void
signalConversionGroup(
    MRT_InstId injectorId,
    MRT_EventCode event)
{
    assert(injectorId < LUBE_INJECTOR_INSTCOUNT) ;

    int pcode = mrt_PortalSignalEvent(&sio__PORTAL,
        SIO_CONVERSION_GROUP_CLASSID,
        presToConvGrpMap[injectorId],
        event,
        NULL, 0) ;

    assert(pcode == 0) ;
    (void)pcode ;
}
static BridgeIDMap const *
mapIOPoint(
    BridgeIDMap const *mapping,
    int numMappings,
    MRT_InstId from)
{
    for ( ; numMappings > 0 ; numMappings--, mapping++) {
        if (mapping->fromInst == from) {
            return mapping ;
        }
    }

    return NULL ;
}
static void
signalInjector(
    MRT_InstId injectorId,
    MRT_EventCode event)
{
    assert(injectorId < LUBE_INJECTOR_INSTCOUNT) ;

    int pcode = mrt_PortalSignalEvent(&lube__PORTAL,
        LUBE_INJECTOR_CLASSID,
        injectorId,
        event,
        NULL, 0) ;

    assert(pcode == 0) ;
    (void)pcode ;
}

static void
controlInjector(
    MRT_InstId injectorId,
    bool starting)
{
    assert(injectorId < LUBE_INJECTOR_INSTCOUNT) ;

    sio_Write_point(injToPointMap[injectorId], starting ? 1 : 0) ;
}
void
lube_SIO_Inject__EOP(
    MRT_InstId injectorId)
{
    assert(injectorId < LUBE_INJECTOR_INSTCOUNT) ;

    controlInjector(injectorId, true) ;
}
void
lube_SIO_Stop_injecting__EOP(
    MRT_InstId injectorId)
{
    assert(injectorId < LUBE_INJECTOR_INSTCOUNT) ;

    controlInjector(injectorId, false) ;
}
void
lube_SIO_Start_monitoring__EOP(
    MRT_InstId injectorId)
{
    assert(injectorId < LUBE_INJECTOR_INSTCOUNT) ;

    signalConversionGroup(injectorId, SIO_CONVERSION_GROUP_SAMPLE_EVENT) ;
}
void
lube_SIO_Stop_monitoring__EOP(
    MRT_InstId injectorId)
{
    assert(injectorId < LUBE_INJECTOR_INSTCOUNT) ;

    signalConversionGroup(injectorId, SIO_CONVERSION_GROUP_STOP_EVENT) ;
}
void
sio_NOTIFY_New_point_value__EOP(
    SioPointID_t point,
    SioPointValue_t value)
{
    assert(point < SIO_IO_POINT_INSTCOUNT) ;

    BridgeIDMap const * pointMap = mapIOPoint(presToInjMap, COUNTOF(presToInjMap), point) ;

    assert(pointMap != NULL) ;
    if (pointMap == NULL) {
        return ;
    }

    int pcode = mrt_PortalUpdateAttr(&lube__PORTAL,
        LUBE_INJECTOR_CLASSID,
        pointMap->toInst,
        LUBE_INJECTOR_PRESSURE_ATTRID,
        &value,
        sizeof(value)) ;

    assert(pcode > 0) ;
    (void)pcode ;
}
void
sio_NOTIFY_In_range__EOP(
    SioPointID_t point,
    SioThresholdID_t threshold)
{
    assert(point < SIO_IO_POINT_INSTCOUNT) ;
    assert(threshold < SIO_POINT_THRESHOLD_INSTCOUNT) ;

    BridgeIDMap const *pointMap = mapIOPoint(presToInjMap, COUNTOF(presToInjMap), point) ;

    assert(pointMap != NULL) ;
    if (pointMap == NULL) {
        return ;
    }

    switch (threshold) {
    case SIO_POINT_THRESHOLD_PT1_INSTID:// fall through
    case SIO_POINT_THRESHOLD_PT4_INSTID:
        signalInjector(pointMap->toInst,
            LUBE_INJECTOR_BELOW_INJECT_PRESSURE_EVENT) ;
        break ;

    /*
     * N.B. no default case.
     * Unexpected Range Limitation instances are silently ignored.
     */
    }
}
void
sio_NOTIFY_Out_of_range__EOP(
    SioPointID_t point,
    SioThresholdID_t threshold)
{
    assert(point < SIO_IO_POINT_INSTCOUNT) ;
    assert(threshold < SIO_POINT_THRESHOLD_INSTCOUNT) ;

    BridgeIDMap const *pointMap = mapIOPoint(presToInjMap, COUNTOF(presToInjMap), point) ;

    assert(pointMap != NULL) ;
    if (pointMap == NULL) {
        return ;
    }

    switch (threshold) {
    case SIO_POINT_THRESHOLD_PT1_INSTID:// fall through
    case SIO_POINT_THRESHOLD_PT4_INSTID:
        signalInjector(pointMap->toInst,
                LUBE_INJECTOR_ABOVE_INJECT_PRESSURE_EVENT) ;
        break ;

    case SIO_POINT_THRESHOLD_PT3_INSTID:// fall through
    case SIO_POINT_THRESHOLD_PT6_INSTID:
        signalInjector(pointMap->toInst,
                LUBE_INJECTOR_ABOVE_DISSIPATION_PRESSURE_EVENT) ;
        break ;

    case SIO_POINT_THRESHOLD_PT2_INSTID:// fall through
    case SIO_POINT_THRESHOLD_PT5_INSTID:
        lube_Injector_max_pressure(pointMap->toInst) ;      // <1>
        break ;

    /*
     * N.B. no default case.
     * Unexpected Range Limitation instances are silently ignored.
     */
    }
}
void
sio_NOTIFY_Signal_point__EOP(
    SioPointID_t point,
    bool isActive)
{
    assert(point < SIO_IO_POINT_INSTCOUNT) ;

    BridgeIDMap const * pointMap = mapIOPoint(sigPtToLubeInstMap,
            COUNTOF(sigPtToLubeInstMap), point) ;

    assert(pointMap != NULL) ;
    if (pointMap == NULL) {
        return ;
    }

    switch (point) {
    case SIO_IO_POINT_IOP7_INSTID: // fall through
    case SIO_IO_POINT_IOP8_INSTID: // fall through
    case SIO_IO_POINT_IOP9_INSTID: {
        void (*lubeOp)(MRT_InstId) = isActive ?
                lube_Lock_Machinery : lube_Unlock_Machinery ;
        lubeOp(pointMap->toInst) ;
    }
        break ;

    case SIO_IO_POINT_IOP10_INSTID: // fall through
    case SIO_IO_POINT_IOP11_INSTID: {
        MRT_EventCode levelEvent = isActive ?
                LUBE_RESERVOIR_NORMAL_LUBE_LEVEL_EVENT :
                LUBE_RESERVOIR_LOW_LUBE_LEVEL_EVENT ;
        int pcode = mrt_PortalSignalEvent(&lube__PORTAL,
            LUBE_RESERVOIR_CLASSID,
            pointMap->toInst,
            levelEvent,
            NULL, 0) ;
        assert(pcode == 0) ;
    }
        break ;
    /*
     * N.B. no default case.
     */
    }
}
