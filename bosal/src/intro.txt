// vim:set syntax=asciidoc:

== Harnessing micca generated domains

This document is about a program named `bosal`.
This document is also a
http://www.literateprogramming.com/[literate program]
and contains all the design information and code for the `bosal` program.
Readers unfamiliar with literate programs should consult the
<<literate-programming,appendix>> for more details.

=== Test harness concepts

When
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/wiki?name=MiccaPage[`micca`]
is used to translate an xUML domain into code,
the resulting ``C'' file can be combined with a `main` function
and any necessary external entity stubsfootnote:[`micca` can also
generate the external entity stubs] to build an executable of the
domain.
The resulting executable, unfortunately, does not do very much.
A domain in isolation, without being bridged to other service domains,
doesn't have any way of being triggered to execute.
We need the ability to invoke domain operations, signal events,
and perform other model level actions on the domain and to be
able to observe its execution.

The `micca` run-time is capable of executing in a POSIX environment.
This is intended primarily to be able to simulate and integrate
a system that is ultimately targeted for a micro-controller.
A POSIX environment has more capability for testing and introspection and a
substantial amount of the integration and testing for an application can be
accomplished there.
To support this important activity,
`bosal` is used to automatically generate a test harness in which one or
more domains may be run under the control of the harness.

=== Test harness structure

The following figure shows schematically how a `bosal` generated
harness is structured.

image::harness-drawing.pdf[title="Test Harness Structure Overview"]

The `bosal` generated test harness contains code that creates a
localhost TCP/IP server.
Communication is across an ordinary TCP socket.
The protocol is ASCII text, record oriented and formulated as commands.
It is possible to interact with a test harness using `telnet(1)`.
A test harness can be used with multiple domains.
Any external operations of the harnessed domains must also be resolved.
This can be done using separate code files or by requesting micca
to generate the stubs.
In the multiple domain case,
there are usually bridge code files that take the place of some of the
external operations stubs.
By compiling and linking the generated harness code, the generated
domain code, and any other required bridges or stubs,
a program is obtained that can control the domain execution
via commands received across the communications interface.

By reading the files saved by `micca`,
`bosal` can generate the code that maps the command protocol onto
the specifics of a domain.
For example,
domain operations can be invoked by the the `domainop` command.
This command takes arguments of which domain the operation refers to,
the name of the operation, and any arguments the operation requires.
The test harness code then arranges to invoke the ``C'' function
that is the domain operation.

=== Building a test harness

To complete building a test harness,
a `main` function must be provided.
The `main` function must invoke
`mrt_Initialize()` before any domain or harness
functions are invoked.
The test harness is started by invoking `bsl_Run()`.
Other initialization may be done in `main`.
For example,
interacting with other systems or programs or invoking domain
initialization functions are candidates for placing in `main`.
The code below shows a minimal `main` function necessary to run
a test harness.
Upon request,
`bosal` will generate a minimal `main` function directly into the
harness code file.

[source,c]
----
#include "bosal.h"
#include "micca_rt.h"

int
main(
    int argc,
    char **argv)
{
    /*
     * Initializing the micca run time must be done before any other
     * domain or harness functions are invoked.
     */
    mrt_Initialize() ;

    /*
     * It may be necessary to initialize domains or bridges. This can
     * be specific to the needs of a particular situation.
     */

    /*
     * Finally, the harness is set to run. The harness code will take
     * over handling the micca event loop.
     */
    bsl_Run() ;
}
----

=== Invoking `bosal`

*****
`bosal` _options_ _savefile1 savefile2 ..._

where options are:

-version::
    Print out version information and exit.
-header::
    Output a copy of the header file, `bosal.h`, and exit.
-doc::
    Output a copy of the manual documentation and exit.
-output _filename_::
    Name of the output file. If this option is not supplied, then `bosal`
    writes the test harness code to the standard output.
-main::
    include a minimal `main` function in harness output.
-nogenerate::
    Don't generate any output.
-level _loglevel_::
    Logger print level. If this option is not supplied, then the logging
    level is set to `warn`.

_savefileN_::
    The names of the files, saved by `micca`, for the domains
    that are to be configured into the test harness.

*****

=== Harness communications protocol

Once a test harness is executing,
clients can connect to TCP port 3906 on localhost to access the
test harness.
Only one client may access a test harness.
Any further connection attempts are refused.
After a client has connected,
terminating the connection causes the test harness to terminate.

The protocol accepted on the communications socket of the
test harness is ASCII record oriented.
Each command is sent as a sequence of whitespace separated words
terminated by `CR/LF`.
Words that need to contain whitespace must be quoted by enclosing
it in braces (`{}`).
Words that contain an unmatched set of braces must precede the
unmatched brace character by a backslash (`\`), _e.g._ `{\{}`

Responses from the test harness are of three types:

Command responses::
    are of the form `cmd {<command response>}`.
State machine traces::
    are of the form `trace {<trace record>}`.
Execution instrumentation::
    are of the form `instr {<instrumentation record>}`.

Commands sent to the test harness always receive a response
and client should not send another command until a response has been received.
However,
if tracing or instrumentation is turned on,
state machine trace records and execution instrumentation are
send asynchronously to any command / response sequence.
Client connections to the test harness must be prepared to receive
trace and execution records if they enable these functions.
At start up, tracing and instrumentation are tuned off
and initial interaction with a test harness is strictly command / response
in nature.

==== Command responses

The syntax of a `<command response>` is a set of whitespace
separated words that form name / value pairs.
Command response consists of three name / value pairs:

`name <command name>`::
    The name of the command is returned in its response.
`result <command execution result>`::
    The result of the command is returned.
    The format of the `<command execution result>` depends upon the nature
    of the command and is described below for each command.
`code <command execution status>`::
    The execution status of the command is returned.
    If `<command execution status>` is the string, ok, then the command
    executed successfully.
    If it is, error, then the command failed and the `result` value
    is a human readable error message.

==== Trace records

* `type <transition type>`
* `event <event name>`
* `source <event signaler>`
* `target <event recipient>`
* `currstate <recipient current state>`
* `newstate <recipient new state>`
* `time <event dispatch time>`

==== Instrumentation records

Instrumentation records

==== Null command

The `null` command performs no action, successfully.
It can be used to insure that the test harness is running and responsive.

*****
[horizontal]
Command:: `null`
Response:: `cmd {name null result {} code ok}`
*****
