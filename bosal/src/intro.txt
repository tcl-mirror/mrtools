// vim:set syntax=asciidoc:

== Harnessing micca generated domains

This document is about a program named `bosal`.
This document is also a
http://www.literateprogramming.com/[literate program]
and contains all the design information and code for the `bosal` program.
Readers unfamiliar with literate programs should consult the
<<literate-programming,appendix>> for more details.

=== Bosal harness concepts

When
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/wiki?name=MiccaPage[`micca`]
is used to translate an xUML domain into code,
the resulting ``C'' file can be combined with a `main` function
and any necessary external entity stubsfootnote:[`micca` can also
generate the external entity stubs] to build an executable program for the
domain.
The resulting executable, unfortunately, does not do very much.
A domain in isolation, without being bridged to other service domains,
doesn't have any way of being triggered to execute.
We need the ability to invoke domain operations, signal events,
and perform other model level actions on the domain and to be
able to observe its execution.

The `micca` run-time is capable of executing in a POSIX environment.
This is intended primarily to be able to simulate and integrate
a system that is ultimately targeted for a micro-controller.
A POSIX environment has more capability for testing and introspection and a
substantial amount of the integration and testing for an application can be
accomplished there.
To support this important activity,
`bosal` is used to automatically generate a test harness in which one or
more domains may be run under the control of the harness.

=== Test harness structure

The following figure shows schematically how a `bosal` generated
harness is structured.

image::harness-drawing.pdf[title="Test Harness Structure Overview"]

The `bosal` generated test harness contains code that creates a
localhost TCP/IP server.
Communication is across an ordinary TCP socket.
The protocol is ASCII text, record oriented and formulated as commands.
It is possible, although not very convenient,
to interact with a test harness using `telnet(1)`.
A test harness can be generated that contains multiple domains.
Any external operations of the harnessed domains must also be resolved.
This can be done using separate code files or by requesting micca
to generate the stubs.
In the multiple domain case,
there are usually bridge code files that take the place of some of the
external operations stubs.
By compiling and linking the `bosal` generated harness code, the
`micca` generated domain code, and any other required bridges or stubs,
a program is obtained that can control the domain execution
via commands received across the communications interface.

By reading the files saved by `micca`,
`bosal` can generate the code that maps the command protocol onto
the specifics of a domain.
For example,
domain operations can be invoked by the the `domainop` command.
This command takes arguments of which domain the operation refers to,
the name of the operation, and any arguments the operation requires.
The test harness code then arranges to invoke the ``C'' function
that is the domain operation.

=== Building a test harness

To complete building a test harness,
a `main` function must be provided.
The `main` function must invoke
`mrt_Initialize()` before any domain or harness
functions are invoked.
The test harness is started by invoking `bsl_Run()`.
Other initialization may be done in `main`.
For example,
interacting with other systems or programs or invoking domain
initialization functions are candidates for placing in `main`.
The code below shows a minimal `main` function necessary to run
a test harness.
Upon request,
`bosal` will generate a minimal `main` function directly into the
harness code file.

[source,c]
----
#include "bosal.h"
#include "micca_rt.h"

int
main(
    int argc,
    char **argv)
{
    /*
     * Initializing the micca run time must be done before any other
     * domain or harness functions are invoked.
     */
    mrt_Initialize() ;

    /*
     * It may be necessary to initialize domains or bridges. This can
     * be specific to the needs of a particular situation.
     */

    /*
     * Finally, the harness is set to run. The harness code will take
     * over handling the micca event loop.
     */
    bsl_Run() ;
}
----

=== Invoking `bosal`

*****
`bosal` _options_ _savefile1 savefile2 ..._

where options are:

-version::
    Print out version information and exit.
-header::
    Output a copy of the header file, `bosal.h`, and exit.
-doc::
    Output a copy of the manual documentation and exit.
-output _filename_::
    Name of the output file. If this option is not supplied, then `bosal`
    writes the test harness code to the standard output.
-main::
    include a minimal `main` function in harness output.
-nogenerate::
    Don't generate any output.
-level _loglevel_::
    Logger print level. If this option is not supplied, then the logging
    level is set to `warn`.

_savefileN_::
    The names of the files, saved by `micca`, for the domains
    that are to be configured into the test harness.

*****

=== Harness communications protocol

Once a test harness is executing,
clients can connect to TCP port 3906, by default, on localhost to access the
test harness.
Only one client may access a test harness.
Any further connection attempts are refused.
After a client has connected,
terminating the connection causes the test harness to terminate.

The protocol accepted on the communications socket of the
test harness is ASCII record oriented.
Each command is sent as a sequence of whitespace separated words
terminated by `CR/LF`.
Words that need to contain whitespace must be quoted by enclosing
it in braces (`{}`).
Words that contain an unmatched set of braces must precede the
unmatched brace character by a backslash (`\`), _e.g._ `{\{}`

Responses from the test harness are of four types:

Command responses::
    are of the form `cmd {<command response>}`.
Fatal run-time errors::
    are of the form `fatal {<error message>}`.
State machine traces::
    are of the form `trace {<state trace record>}`.
Execution instrumentation::
    are of the form `instr {<instrumentation record>}`.

Commands sent to the test harness always receive a response
and client should not send another command until a response has been received.
However,
if tracing or instrumentation is turned on,
state machine trace records and execution instrumentation are
send asynchronously to any command / response sequence.
Also, any fatal errors are sent asynchronously.
Client connections to the test harness must be prepared to receive
trace and execution records if they enable these functions.
At start up, tracing and instrumentation are tuned off
and initial interaction with a test harness is strictly command / response
in nature with the possibility of a fatal error.

==== Command responses

The syntax of a `<command response>` is a set of whitespace
separated words that form name / value pairs.
A command response consists of three name / value pairs:

`name <command name>`::
    The name of the command is returned in its response.
`result <command execution result>`::
    The result of the command is returned.
    The format of the `<command execution result>` depends upon the nature
    of the command and is described below for each command.
`code <command execution status>`::
    The execution status of the command is returned.
    If `<command execution status>` is the string, *ok*, then the command
    executed successfully.
    If it is, *error*, then the command failed and the `result` value
    is a human readable error message.

==== Fatal errors

Fatal errors indicate a _panic_ condition in the execution of the domain.
The response contains a human readable string indicating the cause of the
error.

Normally,
such panic conditions would cause the program to terminate.
By default the `micca` run-time code invokes `abort` when a fatal
error occurs.
However, a test harness installs its own fatal error handler and
insures to insure that the program does not terminate and that
the communications interface continues to operate.
This allows additional queries to attempt to determine the cause of the
error or to inquire as the to state of other components.

==== State trace records

When tracing in turned on,
the test harness will send a `trace` record each time an event is
dispatched to a class instance or an assigner.
The trace record, simular to a command response, consists of a
set of name / value pairs.

`type <transition type>`::
    The type of the transition. `<transition type>` will be one of the
    following strings.
    - *transition*
    - *polymorphic*
    - *creation*

`event <event name>`::
    The name of the event.

`source <event signaler>`::
    The class instance that signaled the event.

`target <event recipient>`::
    The class instance that received the event.

`currstate <recipient current state>`::
    The current state of the receiving class instance before the event
    transition takes place.

`newstate <recipient new state>`::
    The new state of the receiving class instance after the transition
    has happened.

`time <event dispatch time>`::
    A timestamp of when the dispatch occurred.

==== Instrumentation records

Instrumentation records contain traces of functions that are executed.
`Micca` will generate, by default, execution traces if the
`MRT_INSTRUMENT` preprocessor symbol is defined when the domain
code is compiled.
If the preprocessor symbol `BOSAL` also is defined when the domain is
compiled, the automatically generated instrumentation output will be sent
on the communications interface as an `instr` record.
Further, instrumentation may be added in state activities or external
entity stubs as needed.
The format of the instrumentation response is a simple string the
contents of which are specific to the way the instrumentation was
generated.

=== Command protocol details

The following sections describe each command accepted by a test harness.
The commands are listed in alphabetical order.
The *->* symbol is used to indicate the text sent to the test harness.
The *<-* symbol is used to indicate the response.
Note that only successful responses are shown below.
Any error occurring during execution of the command results in the
response containing the `code error` field and the result is a
diagnostic error string.

==== Cancel command
Cancel command

==== Create command
Create command

==== Createasync command
Createasync command

==== Delaysignal command
Delaysignal command

==== Delete command
Delete command

==== Domainop command

The `domainop` command executes a domain operation.

*****
[horizontal]
->:: `domainop` _domain_ _operation_ ? _arg1 arg2 ..._ ?
<-:: `cmd {name domainop result` _operation_result_ `code ok}`

_domain_:: is the name of a domain.
_operation_:: the name of an operation in the domain.
    The operation name is the same as that given in the domain definition.
_argN_:: arguments to the domain operation.
    The order of the arguments must be the same as the order given in
    the domain definition.
_operation_result_::
    The result of the domain operation is dependent upon the return
    value of the domain operation.
*****

==== Event loop command

The `eloop` command gives control over event dispatching and how the
domain is allowed to execute.
It is possible to halt event dispatch and also to dispatch event
one by one or as an entire thread of control.

*****
[horizontal]
-:: `eloop` ? _operation_ ?
<-:: `cmd {name eloop result` _eloop result_ `code ok}`

_operation_:: event loop operation.
The _operation_ argument is optional.
If present, it must be one of the following strings:
    - *run* => run the event loop to dispatch events.
    - *halt* => halt the event loop. No further events are dispatched.
    - *once* => dispatch one event from the event loop.
    - *toc* => dispatch one thread of control from the event loop.
      The *toc* operation can be specified optionally with either a
      *wait* or *nowait* argument.
      If *wait* is specified (or by default if no *toc* option is specified),
      then the event loop will wait until a thread of control event
      arrives.
      If *nowait* is specified, the command will return immediately
      if no thread of control is ready to dispatch.
      This option is useful if the event that starts the thread of control
      is issued via a delayed signal.

_eloop result_::
    is the current run state of the event loop,
    either *running* or *halted*, if the _operation_ was missing, *run*, or
    *halt*.
    The _eloop result_ is either *true* or *false* if the _operation_ was
    *once* or *toc* and indicates if any event or thread of control was
    actually dispatched.
    It is an error to attempt to execute the *once* or *toc* operations if
    the event loop is currently *running*.
*****

==== Null command

The `null` command performs no action, successfully.
It can be used to insure that the test harness is running and responsive.

*****
[horizontal]
->:: `null`
<-:: `cmd {name null result {} code ok}`
*****

==== Instrument command

The `instr` command controls whether instrumentation records are
send on the communications connection.
Clients may use it to change the amount of execution trace instrumentation
coming from the test harness.

*****
[horizontal]
->:: `instr` ? _on_ | _off_?
<-:: `cmd {name instr result` _instr_result `code ok}`

_instr_result_::
    The current state of the instrumentation record output.
*****

==== Query command
Query command

==== Read command
Read command

==== Remaining command
Remaining command

==== Signal command
Signal command

==== Trace command
Trace command

==== Update command
Update command
