// vim:set syntax=asciidoc:

== Domain Independent Code

=== Introduction

Give overview of the structure of a test harness.
Need a diagram showing how a set of domains is harnessed together
with the test harness code providing a communications interface.

The test harness must provide a `main` function.
After invoking `mrt_Initialize()`,
then `bslInitialize()` must be invoked.
Finally, `bsl_Run()` must be invoked to run the system.

=== Running the Harness

(((chunk,harness external function declarations)))
(((function,bsl_Run)))

[source,c]
----
<<harness external function declarations>>=
extern void bsl_Run(void) ;
----

(((chunk,harness external function definitions)))
(((function,bsl_Run)))

[source,c]
----
<<harness external function definitions>>=
void
bsl_Run(void)
{
    if (!bslInitialize()) {
        return ;
    }

    mrt_SetFatalErrorHandler(bslErrorHandler) ;

    for (bslHarnessState = bslRunning ; bslHarnessState != bslTerminate ;) {
        if (setjmp(bslFatalBuf) == 0) {
            mrt_EventLoop() ;
        }

        while (bslHarnessState == bslHalted) {
            bslReadAndEvalCommand(0) ;
        }
    }
    bslClose() ;
}
----

(((chunk,harness static data)))
(((data,bslHarnessState)))

[source,c]
----
<<harness static data>>=
static enum {
    bslHalted,
    bslRunning,
    bslTerminate,
} bslHarnessState ;
----

(((chunk,harness static data)))
(((data,bslFatalBuf)))

[source,c]
----
<<harness static data>>=
static jmp_buf bslFatalBuf ;
----

(((chunk,harness forward function declarations)))
(((function,bslErrorHandler)))

[source,c]
----
<<harness forward function declarations>>=
static void bslErrorHandler(MRT_ErrorCode errNum, char const *fmt,
        va_list alist) ;
----

(((chunk,harness static functions)))
(((function,bslErrorHandler)))

[source,c]
----
<<harness static functions>>=
static void
bslErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list alist)
{
    static char buf[BUFSIZ] ;

    vsnprintf(buf, sizeof(buf), fmt, alist) ;
    bslTrimSpaceRight(buf) ;
    fprintf(bslCmdStream, "fatal {%s}\n" , buf) ;

    bslHarnessState = bslHalted ;
    longjmp(bslFatalBuf, 1) ;
}
----

=== Harness Initialization

(((chunk,harness forward function declarations)))
(((function,bslInitialize)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslInitialize(void) ;
----

(((chunk,harness static functions)))
(((function,bslInitialize)))

[source,c]
----
<<harness static functions>>=
static bool
bslInitialize(void)
{
    <<bslInitialize: create socket>>
    <<bslInitialize: bind socket>>
    <<bslInitialize: listen on socket>>
    <<bslInitialize: register signals>>

    // start with tracing off
    bslDefaultTraceHandler = mrt_RegisterTraceHandler(NULL) ;

    return true ;
}
----

(((chunk,bslInitialize: create socket)))

[source,c]
----
<<bslInitialize: create socket>>=
bslServiceSock = socket(AF_INET, SOCK_STREAM, 0) ;
if (bslServiceSock == -1) {
    perror("unable to obtain AF_INET stream socket") ;
    return false ;
}
----

[source,c]
----
<<harness static data>>=
static int bslServiceSock = -1 ;
----

(((chunk,bslInitialize: bind socket)))

[source,c]
----
<<bslInitialize: bind socket>>=
struct sockaddr_in hsrvAddr ;
memset(&hsrvAddr, 0, sizeof(hsrvAddr)) ;
#       ifdef __APPLE__
hsrvAddr.sin_len = sizeof(hsrvAddr) ;
#       endif /* __APPLE__ */
hsrvAddr.sin_family = AF_INET ;
hsrvAddr.sin_port = htons(HARNESS_PORT) ;

static char const host[] = "localhost" ;
struct hostent *hostAddr = gethostbyname(host) ;
if (hostAddr == NULL) {
    perror(host) ;
    return false ;
}
assert(hostAddr->h_addrtype == AF_INET) ;
memcpy(&hsrvAddr.sin_addr, hostAddr->h_addr_list[0], hostAddr->h_length) ;

int err = bind(bslServiceSock, (struct sockaddr const *)&hsrvAddr,
        sizeof(hsrvAddr)) ;
if (err == -1) {
    perror("bind()") ;
    return false ;
}
----

(((chunk,bslInitialize: listen on socket)))

[source,c]
----
<<bslInitialize: listen on socket>>=
mrt_RegisterFDService(bslServiceSock, bslAcceptConnection, NULL, NULL) ;
err = listen(bslServiceSock, 1) ;
if (err == -1) {
    perror("listen()") ;
    return false ;
}
----

(((chunk,bslInitialize: register signals)))

[source,c]
----
<<bslInitialize: register signals>>=
mrt_RegisterSignal(SIGQUIT, bslExitOnSignal) ;
mrt_RegisterSignal(SIGINT, bslExitOnSignal) ;
mrt_RegisterSignal(SIGTERM, bslExitOnSignal) ;
----

(((chunk,harness static data)))
(((data,bslDefaultTraceHandler)))

[source,c]
----
<<harness static data>>=
void (*bslDefaultTraceHandler)(MRT_TraceInfo const *traceInfo) ;
----

=== Accepting Service Connections

(((chunk,harness forward function declarations)))
(((function,bslAcceptConnection)))

[source,c]
----
<<harness forward function declarations>>=
static void bslAcceptConnection(int sock) ;
----

(((chunk,harness static functions)))
(((function,bslAcceptConnection)))

[source,c]
----
<<harness static functions>>=
static void
bslAcceptConnection(
    int sock)
{
    int fd = accept(sock, NULL, 0) ;

    int err = shutdown(bslServiceSock, SHUT_RDWR) ;
    if (err == -1) {
        perror("shutdown()") ;
        exit(EXIT_FAILURE) ;
    }
    mrt_UnregisterFDService(sock, true, false, false) ;
    bslServiceSock = -1 ;

    if (fd == -1) {
        perror("accept()") ;
        exit(EXIT_FAILURE) ;
    }

    mrt_RegisterFDService(fd, bslReadAndEvalCommand, NULL, NULL) ;
    bslCmdStream = fdopen(fd, "w+") ;
    err = setvbuf(bslCmdStream, NULL, _IOLBF, 0) ;
}
----

(((chunk,harness static data)))
(((data,bslCmdStream)))

[source,c]
----
<<harness static data>>=
static FILE *bslCmdStream ;
----

(((chunk,harness forward function declarations)))
(((function,bslReadAndEval)))

[source,c]
----
<<harness forward function declarations>>=
static void bslReadAndEvalCommand(int rfd) ;
----

(((chunk,harness static functions)))
(((function,bslReadAndEvalCommand)))

[source,c]
----
<<harness static functions>>=
static void
bslReadAndEvalCommand(
    int rfd)
{
    static char cmdBuffer[BUFSIZ] ;

    char *cmd = fgets(cmdBuffer, sizeof(cmdBuffer), bslCmdStream) ;
    if (cmd == NULL) {
        if (feof(bslCmdStream)) {
            dbgprintf("goodbye\n") ;
            bslClose() ;
            exit(EXIT_SUCCESS) ;
        } else if (ferror(bslCmdStream)) {
            if (errno == EINTR) {
                clearerr(bslCmdStream) ;
                return ;
            }
            perror("fgets()") ;
            bslClose() ;
            exit(EXIT_FAILURE) ;
        } else {
            printf("partial\n") ;
            return ;
        }
    }
    bslTrimSpaceRight(cmdBuffer) ;
    dbgprintf("%s\n", cmdBuffer) ;

    int argc = 0 ;
    char *const *argv = NULL ;
    static char parseBuffer[BUFSIZ] ;
    strcpy(parseBuffer, cmdBuffer) ;

    bslBeginResponse() ;
    bslAddWord("cmd") ;
    bslPushContext() ;

    int err = bslParseCommand(parseBuffer, &argc, &argv) ;
    if (err == -1) {
        bslFormatToContext("name unknown return error result ") ;
        bslPushContext() ;
        bslFormatToContext("failed to parse command: \"%s\"", cmdBuffer) ;
        bslPopContext() ;
    } else if (argc != 0) {
        bslExecCommand(argc, argv) ;
    } else {
        return ;
    }

    bslPopContext() ;
    bslEndResponse() ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslExitOnSignal)))

[source,c]
----
<<harness forward function declarations>>=
static void bslExitOnSignal(int signal) ;
----

(((chunk,harness static functions)))
(((function,bslExitOnSignal)))

[source,c]
----
<<harness static functions>>=
static void
bslExitOnSignal(
    int signal)
{
    dbgprintf("caught signal %d\n", signal) ;
    bslClose() ;
    exit(EXIT_SUCCESS) ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClose)))

[source,c]
----
<<harness forward function declarations>>=
static void bslClose(void) ;
----

(((chunk,harness static functions)))
(((function,bslClose)))

[source,c]
----
<<harness static functions>>=
static void
bslClose(void)
{
    if (bslServiceSock != -1) {
        shutdown(bslServiceSock, SHUT_RDWR) ;
    }
    if (bslCmdStream != NULL) {
        fclose(bslCmdStream) ;
    }
}
----

=== Parsing Harness Commands

(((chunk,harness forward function declarations)))
(((function,bslParseCommand)))

[source,c]
----
<<harness forward function declarations>>=
static int bslParseCommand(char *line, int *pargc, char *const **pargv) ;
----

(((chunk,harness static functions)))
(((function,bslParseCommand)))

[source,c]
----
<<harness static functions>>=
static int
bslParseCommand(
    char *line,
    int *pargc,
    char *const **pargv)
{
    #define MAX_ARGS    64
    static char *args[MAX_ARGS] ;

    char **pArgv = args ;
    char **const argvEnd = pArgv + MAX_ARGS ;

    int quoteCount = 0 ;
    int parseState = OUTOFWORD ;
    int parseStackStorage[2] ;
    int *parseStackTop = parseStackStorage ;

    char *pWord = line ;
    for ( ; *line != ASCII_NUL ; line++) {
        char c = *line ;
        switch (parseState) {
        case OUTOFWORD:
            if (isgraph(c)) {
                if (c == ESCAPE_CHAR) {
                    *parseStackTop++ = INWORD ;
                    parseState = INESCAPE ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else if (c == BEGIN_QUOTE) {
                    *parseStackTop++ = OUTOFWORD ;
                    parseState = INQUOTE ;
                    ++quoteCount ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else {
                    // new word beginning
                    if (pArgv < argvEnd) {
                        *pArgv++ = pWord ;
                    } else {
                        fprintf(stderr, "exceeded max arguments") ;
                        return -1 ;
                    }
                    *pWord++ = c ;
                    parseState = INWORD ;
                }
            } // else the character is just space to skip
            break ;

        case INWORD:
            if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = INESCAPE ;
            } else if (c == BEGIN_QUOTE) {
                *parseStackTop++ = parseState ;
                parseState = INQUOTE ;
                ++quoteCount ;
            } else if (isspace(c)) {
                // end of word
                parseState = OUTOFWORD ;
                *pWord++ = ASCII_NUL ;
            } else {
                *pWord++ = c ;
            }
            break ;

        case INESCAPE:
            switch (c) {
                case 'a':
                    *pWord++ = '\a' ;
                    break ;
                case 'b':
                    *pWord++ = '\b' ;
                    break ;
                case 't':
                    *pWord++ = '\t' ;
                    break ;
                case 'n':
                    *pWord++ = '\n' ;
                    break ;
                case 'v':
                    *pWord++ = '\v' ;
                    break ;
                case 'f':
                    *pWord++ = '\f' ;
                    break ;
                case 'r':
                    *pWord++ = '\r' ;
                    break ;
                default:
                    *pWord++ = c ;
                    break ;
            }
            parseState = *--parseStackTop ;
            break ;

        case INQUOTE:
            if (c == BEGIN_QUOTE) {
                ++quoteCount ;
                *pWord++ = c ;
            } else if (c == END_QUOTE) {
                if (--quoteCount == 0) {
                    parseState = *--parseStackTop ;
                    // check if ending the quote also ended the word
                    if (parseState == OUTOFWORD) {
                        *pWord++ = ASCII_NUL ;
                    }
                } else {
                    *pWord++ = c ;
                }
            } else if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = INESCAPE ;
            } else {
                *pWord++ = c ;
            }
            break ;
        }
    }

    *pWord = ASCII_NUL ;
    *pArgv = NULL ;
    if (quoteCount == 0 && parseState != INESCAPE) {
        if (pargc) {
            *pargc = pArgv - args ;
        }
        if (pargv) {
            *pargv = args ;
        }
        return 0 ;
    } else {
        return -1 ;
    }
}
----

=== Executing Harness Commands

(((chunk,harness forward function declarations)))
(((function,bslExecCommand)))

[source,c]
----
<<harness forward function declarations>>=
static void bslExecCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslExecCommand)))

[source,c]
----
<<harness static functions>>=
static void
bslExecCommand(
    int argc,
    char *const *argv)
{
    BSL_CommandMap key = {
        .name = argv[0],
        .commandFunc = NULL
    } ;

    BSL_CommandMap const *cmd =
            bsearch(&key, commands, COUNTOF(commands), sizeof(commands[0]),
            bslCommandMapCompare) ;

    bslAddWord("name") ;
    bslAddWord(argv[0]) ;
    bslAddWord("result") ;
    bslPushContext() ;

    bool success ;
    if (cmd != NULL) {
        assert(cmd->commandFunc != NULL) ;
        success = cmd->commandFunc(argc, argv) ;
    } else {
        bslFormatToContext("unknown command, \"%s\"", argv[0]) ;
        success = false ;
    }

    bslPopContext() ;
    bslAddWord("code") ;
    bslAddWord(success ? "ok" : "error") ;
}
----

[source,c]
----
<<harness data types>>=
typedef bool BSL_CommandFunc(int, char * const*) ;

typedef struct bslcommandmap {
    char const *name ;
    BSL_CommandFunc *commandFunc ;
} BSL_CommandMap ;
----

(((chunk,harness forward function declarations)))
(((function,bslCommandMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslCommandMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslCommandMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslCommandMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_CommandMap const *cm1 = m1 ;
    BSL_CommandMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

(((chunk,harness static data)))
(((data.commands)))

[source,c]
----
<<harness static data>>=
static BSL_CommandMap const commands[] = { // must be in ascending "name" order
    {
        .name = "cancel",
        .commandFunc = NULL  //bslCancelCommand
    },
    {
        .name = "delaysignal",
        .commandFunc = bslDelaySignalCommand
    },
    {
        .name = "delete",
        .commandFunc = NULL  //bslDeleteCommand
    },
    {
        .name = "domainop",
        .commandFunc = bslDomainopCommand
    },
    {
        .name = "eloop",
        .commandFunc = bslEloopCommand
    },
    {
        .name = "instr",
        .commandFunc = NULL  //bslInstrCommand
    },
    {
        .name = "null",
        .commandFunc = bslNullCommand
    },
    {
        .name = "query",
        .commandFunc = NULL  //bslQueryCommand
    },
    {
        .name = "read",
        .commandFunc = NULL  //bslReadCommand
    },
    {
        .name = "remaining",
        .commandFunc = NULL  //bslRemainingCommand
    },
    {
        .name = "signal",
        .commandFunc = bslSignalCommand
    },
    {
        .name = "trace",
        .commandFunc = bslTraceCommand
    },
    {
        .name = "update",
        .commandFunc = NULL  //bslUpdateCommand
    },
} ;
----

=== Locating Domain Components

==== Finding a Harness

(((chunk,harness forward function declarations)))
(((function,bslFindHarness)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_DomainHarness const *const bslFindHarness(char const *domainName) ;
----

(((chunk,harness static functions)))
(((function,bslFindHarness)))

[source,c]
----
<<harness static functions>>=
static BSL_DomainHarness const *const
bslFindHarness(
    char const *domainName)
{
    assert(domainName != NULL) ;

    BSL_DomainHarness const *hiter = bslHarnesses ;
    int hcount = bslHarnessCount ;
    for ( ; hcount != 0 ; hcount--, hiter++) {
        assert(hiter->portal != NULL) ;
        assert(hiter->portal->name != NULL) ;
        char const *trialName = mrt_PortalDomainName(hiter->portal) ;
        if (strcmp(domainName, trialName) == 0) {
            return hiter ;
        }
    }
    bslFormatToContext("unknown domain, \"%s\"", domainName) ;
    return NULL ;
}
----

==== Finding a Domain Operation

(((chunk,harness forward function declarations)))
(((function,bslFindOperation)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_OperationMap const *const bslFindOperation(
    BSL_DomainHarness const *const harness, char const *opName) ;
----

(((chunk,harness static functions)))
(((function,bslFindOperation)))

[source,c]
----
<<harness static functions>>=
static BSL_OperationMap const *const
bslFindOperation(
    BSL_DomainHarness const *const harness,
    char const *opName)
{
    BSL_OperationMap key = {
        .name = opName,
        .func = NULL
    } ;

    BSL_OperationMap const *const opMap =
            bsearch(&key, harness->operations, harness->operationCount,
            sizeof(key), bslOperationMapCompare) ;
    if (opMap == NULL) {
        bslFormatToContext("unknown operation, \"%s\"", opName) ;
    }

    return opMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslOperationMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslOperationMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslOperationMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslOperationMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_OperationMap const *cm1 = m1 ;
    BSL_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Domain Class

(((chunk,harness forward function declarations)))
(((function,bslFindClass)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_ClassMap const *const bslFindClass(
    BSL_DomainHarness const *const harness, char const *className) ;
----

(((chunk,harness static functions)))
(((function,bslFindClass)))

[source,c]
----
<<harness static functions>>=
static BSL_ClassMap const *const
bslFindClass(
    BSL_DomainHarness const *const harness,
    char const *className)
{
    BSL_ClassMap key = {
        .name = className
    } ;

    BSL_ClassMap const *const classMap =
            bsearch(&key, harness->classes, harness->classCount,
            sizeof(key), bslClassMapCompare) ;
    if (classMap == NULL) {
        bslFormatToContext("unknown class, \"%s\"", className) ;
    }

    return classMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslClassMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslClassMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_OperationMap const *cm1 = m1 ;
    BSL_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class Instance

(((chunk,harness forward function declarations)))
(((function,bslFindInst)))

[source,c]
----
<<harness forward function declarations>>=
static int bslFindInst(BSL_ClassMap const *const class, char const *instName) ;
----

(((chunk,harness static functions)))
(((function,bslFindInst)))

[source,c]
----
<<harness static functions>>=
static int
bslFindInst(
    BSL_ClassMap const *const class,
    char const *instName)
{
    // First scan to see if we got a number.
    int instId = -1 ;
    int converted = sscanf(instName, "%i", &instId) ;
    if (converted == 1) {
        if (instId < 0) {
            bslFormatToContext("instance id's must be non-negative: "
                    "got, %i", instId) ;
        }
    } else {
        // Not a number, try to look up the name.
        BSL_InstMap key = {
            .name = instName
        } ;

        BSL_InstMap const *const instMap =
                bsearch(&key, class->insts, class->instCount,
                sizeof(key), bslInstMapCompare) ;
        if (instMap == NULL) {
            bslFormatToContext("unknown instance, \"%s\"", instName) ;
            instId = -1 ;
        } else {
            instId = instMap->id ;
        }
    }

    return instId ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslInstMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslInstMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslInstMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslInstMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_InstMap const *cm1 = m1 ;
    BSL_InstMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class Event

(((chunk,harness forward function declarations)))
(((function,bslFindEvent)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_EventMap const *bslFindEvent(BSL_ClassMap const *const class,
        char const *eventName) ;
----

(((chunk,harness static functions)))
(((function,bslFindEvent)))

[source,c]
----
<<harness static functions>>=
static BSL_EventMap const *
bslFindEvent(
    BSL_ClassMap const *const class,
    char const *eventName)
{
    // First scan to see if we got a number.
    BSL_EventMap const *eventMap = NULL ;
    char *end ;
    MRT_EventCode eventNumber = strtoul(eventName, &end, 0) ;
    if (*end == ASCII_NUL) {
        // search for the event number in the map
        BSL_EventMap const *mapIter = class->events ;
        for (unsigned eventCount = class->eventCount ; eventCount != 0 ;
                eventCount--, mapIter++) {
            if (mapIter->number == eventNumber) {
                eventMap = mapIter ;
                break ;
            }
        }
    } else {
        // Not a number, try to look up the name.
        BSL_EventMap key = {
            .name = eventName
        } ;

        eventMap = bsearch(&key, class->events, class->eventCount,
                sizeof(key), bslEventMapCompare) ;
    }

    if (eventMap == NULL) {
        bslFormatToContext("unknown event, \"%s\"", eventName) ;
    }

    return eventMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslEventMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslEventMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_EventMap const *cm1 = m1 ;
    BSL_EventMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

=== Harness Commands Implementation

==== Null Command

(((chunk,harness forward function declarations)))
(((function,bslNullCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslNullCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslNullCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslNullCommand(
    int argc,
    char *const *argv)
{
    return true ;
}
----

(((chunk,bosal harness tests)))
(((test,null-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test null-1.0 {
    Null command test
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp null]
    dict get $response code
} -result {ok}
----

==== Domain Operation Command

(((chunk,harness forward function declarations)))
(((function,bslDomainopCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslDomainopCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslDomainopCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslDomainopCommand(
    int argc,
    char *const *argv)
{
    if (argc < 3) {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "domainop <domain> <operation> ?<arg1> <arg2> ...?",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *opName = argv[2] ;
    BSL_OperationMap const *const opMap = bslFindOperation(harness, opName) ;
    if (opMap == NULL) {
        return false ;
    }
    return opMap->func(argc - 3, argv + 3) ;
}
----

(((chunk,bosal harness tests)))
(((test,domainop-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.0 {
    Initialize lube domain
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp domainop lube init]
    dict get $response code
} -result {ok}
----

(((chunk,bosal harness tests)))
(((test,domainop-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.0 {
    Unknown domain
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp domainop foo init]
    dict get $response result
} -result {unknown domain, "foo"}
----

(((chunk,bosal harness tests)))
(((test,domainop-2.1)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.1 {
    No operation name
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp domainop sio]
    dict get $response result
} -result {wrong # of arguments: 2: expected, domainop <domain> <operation> ?<arg1> <arg2> ...?}
----

(((chunk,bosal harness tests)))
(((test,domainop-2.2)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.2 {
    Unknown operations
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp domainop sio foo]
    dict get $response result
} -result {unknown operation, "foo"}
----

(((chunk,bosal harness tests)))
(((test,domainop-2.3)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.3 {
    Missing operation argument
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp domainop lube Suspend_Autocycle_Session]
    dict get $response result
} -result {wrong # arguments: got 0, expected 1}
----

(((chunk,bosal harness tests)))
(((test,domainop-2.4)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.4 {
    Bad operation argument
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp domainop lube Suspend_Autocycle_Session foo]
    dict get $response result
} -result {bad parameter: "foo"}
----

==== Signal Command

(((chunk,harness forward function declarations)))
(((function,bslSignalCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslSignalCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslSignalCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslSignalCommand(
    int argc,
    char *const *argv)
{
    if (argc < 5) {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "\"signal <domain> <class> <inst> <event> ?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        bslFormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    BSL_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 5, argv + 5, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalSignalEvent(portal, classId, instId, eventNumber,
            params, sizeof(params)) ;
    } else {
        pcode = mrt_PortalSignalEvent(portal, classId, instId, eventNumber,
            NULL, 0) ;
    }

    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Delay Signal Command

[literal]
--
delaysignal <domain> <class> <inst> <delay> <event> ?<arg1> <arg2> ...?
--

(((chunk,harness forward function declarations)))
(((function,bslDelaySignalCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslDelaySignalCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslDelaySignalCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslDelaySignalCommand(
    int argc,
    char *const *argv)
{
    if (argc < 6) {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "\"delaysignal <domain> <class> <inst> <delay> <event> "
            "?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        bslFormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *delayTime = argv[4] ;
    MRT_DelayTime delay ;
    int converted = sscanf(delayTime, "%" SCNi32, &delay) ;
    if (converted != 1) {
        bslFormatToContext(failedConvertMsg, delayTime, SCNi32) ;
        return false ;
    }

    char *eventName = argv[5] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    BSL_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 6, argv + 6, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalSignalDelayedEvent(portal, classId, instId,
                eventNumber, params, sizeof(params), delay) ;
    } else {
        pcode = mrt_PortalSignalDelayedEvent(portal, classId, instId,
                eventNumber, NULL, 0, delay) ;
    }

    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Trace Command

(((chunk,harness forward function declarations)))
(((function,bslTraceCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslTraceCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslTraceCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslTraceCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        MRT_TraceHandler handler = mrt_RegisterTraceHandler(NULL) ;
        mrt_RegisterTraceHandler(handler) ;
        bslAddWord(handler == NULL ? "off" : "on") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            mrt_RegisterTraceHandler(bslTraceResponse) ;
            bslAddWord("on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            mrt_RegisterTraceHandler(NULL) ;
            bslAddWord("off") ;
        } else {
            bslFormatToContext(
                    "unknown trace option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
            status = false ;
        }
    } else {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, \"trace ?on | off?\"", argc) ;
        status = false ;
    }

    return status ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslTraceResponse)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTraceResponse(MRT_TraceInfo const *traceInfo) ;
----

(((chunk,harness static functions)))
(((function,bslTraceResponse)))

[source,c]
----
<<harness static functions>>=
static void
bslTraceResponse(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (bslDefaultTraceHandler != NULL) {
        bslDefaultTraceHandler(traceInfo) ;
    }

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
        char const *newStateName ;
        if (newState == MRT_StateCode_IG) {
            newStateName = "IG" ;
        } else if (newState == MRT_StateCode_CH) {
            newStateName = "CH" ;
        } else {
            newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.newState] ;
        }

        fprintf(bslCmdStream,
                "trace {"
                "type transition "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "currstate %s "
                "newstate %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.currentState],
            newStateName,
            bslTimestamp()) ;
    }
        break ;

    case mrtPolymorphicEvent: {
        MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
                genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
        MRT_Class const *subclass ;
        char const *subname = NULL ;
        if (rel->relType == mrtRefGeneralization) {
            subclass = rel->relInfo.refGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
            subname = subclass->name ;
        } else if (rel->relType == mrtUnionGeneralization) {
            subclass = rel->relInfo.unionGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode] ;
            subname = subclass->name ;
        } else {
            printf("%s: bad relationship type in polymorphic event, %d\n",
                bslTimestamp(), rel->relType) ;
            break ;
        }
        fprintf(bslCmdStream,
                "trace {"
                "type polymorphic "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "relationship %s "
                "newevent %s "
                "subclass %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->pdb->genNames[
                traceInfo->info.polyTrace.genNumber],
            subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
            subname,
            bslTimestamp()) ;
    }
        break ;

    case mrtCreationEvent:
        fprintf(bslCmdStream,
                "trace {"
                "type creation "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->info.creationTrace.targetClass->name, targetName,
            bslTimestamp()) ;
        break ;

    default:
        fprintf(bslCmdStream,
                "trace {"
                "type error "
                "result {unknown trace event type, \"%u\"} "
                "time %s"
                "}\n",
            traceInfo->eventType,
            bslTimestamp()) ;
        break ;
    }
}
----

(((chunk,harness forward function declarations)))
(((function,bslTimestamp)))

[source,c]
----
<<harness forward function declarations>>=
static char const *bslTimestamp(void) ;
----

(((chunk,harness static functions)))
(((function,bslTimestamp)))

[source,c]
----
<<harness static functions>>=
static char const *
bslTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "too big" ;
    }

    return timestamp ;
}
----

(((chunk,bosal harness tests)))
(((test,trace-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-1.0 {
    Get trace status
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp trace]
    dict get $response result
} -result {off}
----

(((chunk,bosal harness tests)))
(((test,trace-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-2.0 {
    Turn tracing on
} -setup {
} -cleanup {
    harnessCmdResp trace off
} -body {
    set response [harnessCmdResp trace on]
    dict get $response result
} -result {on}
----

(((chunk,bosal harness tests)))
(((test,trace-3.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-3.0 {
    Bad trace option
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp trace foo]
    dict get $response result
} -result {unknown trace option, "foo": expected, "on | off"}
----

(((chunk,bosal harness tests)))
(((test,trace-3.1)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-3.1 {
    Wrong number of trace arguments
} -setup {
} -cleanup {
} -body {
    set response [harnessCmdResp trace on heavy]
    dict get $response result
} -result {wrong # of arguments: 3: expected, "trace ?on | off?"}
----

==== Event Loop Command

(((chunk,harness forward function declarations)))
(((function,bslEloopCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslEloopCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslEloopCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslEloopCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        char const *state ;
        switch (bslHarnessState) {
        case bslHalted :
            state = "halted" ;
            break ;

        case bslRunning:
            state = "running" ;
            break ;

        case bslTerminate:
        default:
            state = "terminated" ;
            break ;
        }
        bslAddWord(state) ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "run") == 0) {
            bslHarnessState = bslRunning ;
            bslAddWord("running") ;
        } else if (strcmp(argv[1], "halt") == 0) {
            mrt_SyncToEventLoop() ;
            bslHarnessState = bslHalted ;
            bslAddWord("halted") ;
        } else if (strcmp(argv[1], "terminate") == 0) {
            mrt_SyncToEventLoop() ;
            bslHarnessState = bslTerminate ;
            bslAddWord("terminated") ;
        } else if (strcmp(argv[1], "once") == 0) {
            if (bslHarnessState != bslRunning) {
                bool didEvent = mrt_DispatchSingleEvent() ;
                bslAddWord(didEvent ? "true" : "false") ;
            } else {
                bslAddWord("event loop is running") ;
                status = false ;
            }
        } else if (strcmp(argv[1], "toc") == 0) {
            if (bslHarnessState != bslRunning) {
                bool didEvent = mrt_DispatchThreadOfControl(true) ;
                bslAddWord(didEvent ? "true" : "false") ;
            } else {
                bslAddWord("event loop is running") ;
                status = false ;
            }
        } else {
            bslFormatToContext(
                "unknown eloop option, \"%s\": expected, "
                "\"run | halt | once | toc | terminate\"",
                argv[1]) ;
            status = false ;
        }
    } else {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "\"eloop ?run | halt | once | terminate?\"",
            argc) ;
        status = false ;
    }

    return status ;
}
----

== Domain Dependent Code

=== Generate Command

(((chunk,required packages)))

[source,tcl]
----
<<required packages>>=
package require textutil::expander
----

(((chunk,bosal commands)))
(((proc,generate)))

[source,tcl]
----
<<bosal commands>>=
proc generate {options} {
    <<generate: set up template expansion>>
    <<generate: generate code>>
}
----

(((chunk,generate: set up template expansion)))

[source,tcl]
----
<<generate: set up template expansion>>=
textutil::expander expand
expand setbrackets <% %>
expand errmode [dict get $options expanderror]
----

(((chunk,generate: generate code)))

[source,tcl]
----
<<generate: generate code>>=
expand evalcmd "namespace eval [namespace current]::GenCode"
try {
    variable codeTemplate
    return [expand expand $codeTemplate]
} on error {result opts} {
    # puts $::errorInfo
    return -options $opts $result
} finally {
    rename expand {}
}
----

==== Code Template

(((chunk,bosal data)))
(((data,codeTemplate)))

[source,tcl]
----
<<bosal data>>=
variable codeTemplate [textutil::adjust::undent {
/*
<<edit warning>>
<<copyright info>>
*/

/*
 * Include Files
 */
#define _POSIX_C_SOURCE 200809L
#include "bosal.h"
#include "micca_rt.h"
#include "micca_rt_internal.h"
/*
 * Domain Header Files
 */
<%includeDomainHeaders%>
#include <sys/socket.h>
#include <sys/time.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <setjmp.h>
#include <ctype.h>
#include <time.h>
#include <strings.h>

/*
 * Macros
 */
#ifndef NDEBUG
#   define  dbgprintf(...)    printf(__VA_ARGS__)
#else
#   define  dbgprintf(...)
#endif /* NDEBUG */

#define ASCII_NUL       '\0'
#define BEGIN_QUOTE     '{'
#define END_QUOTE       '}'
#define ESCAPE_CHAR     '\\'

#define OUTOFWORD   0
#define INWORD      1
#define INESCAPE    2
#define INQUOTE     3

/*
 * Constants
 */
#ifndef HARNESS_PORT
#   define HARNESS_PORT 3906
#endif /* HARNESS_PORT */
#ifndef BSL_NESTLIMIT
#   define  BSL_NESTLIMIT   4
#endif /* BSL_NESTLIMIT */

/*
 * Data Types
 */
<<harness data types>>

/*
 * Forward References
 */
<<harness forward function declarations>>

/*
 * Static Data
 */
<<harness static data>>

/*
 * Static Functions
 */
<<harness static functions>>

/*
 * External Functions
 */
<<harness external function definitions>>
}]
----

(((chunk,bosal code template commands)))
(((proc,generateHarnesses)))

[source,tcl]
----
<<bosal code template commands>>=
proc includeDomainHeaders {} {
    set div [diverter new]

    forAllRefs domainRef [Domain findAll] {
        set domainName [readAttribute $domainRef Name]
        $div puts "#include \"$domainName.h\""
    }

    $div return
}
----

=== Generating Domain Mappings

(((chunk,harness static data)))

[source,c]
----
<<harness static data>>=
<%generateEventMaps%>
<%generateInstMaps%>
<%generateAttrMaps%>
<%generateClassMaps%>
<%generateOpMaps%>
<%generateHarnesses%>
----

==== Generating the Domain Harness

(((chunk,harness data types)))
(((type,BSL_DomainHarness)))

[source,c]
----
<<harness data types>>=
typedef struct bsldomainharness {
    MRT_DomainPortal const *portal ;
    struct bsloperationmap const *const operations ;
    unsigned operationCount ;
    struct bslclassmap const *const classes ;
    unsigned classCount ;
} BSL_DomainHarness ;
----

(((chunk,bosal code template commands)))
(((proc,generateHarnesses)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateHarnesses {} {
    set div [diverter new]

    $div puts "static BSL_DomainHarness const bslHarnesses\[] = {"
    $div push

    forAllRefs domRef [Domain findAll] {
        assignAttribute $domRef {Name domainName}
        $div puts "{"
        $div push
        $div puts ".portal = &${domainName}__PORTAL,"

        set opsRef [findRelated $domRef ~R5]
        if {[isEmptyRef $opsRef]} {
            set ops NULL
            set opsCount 0
        } else {
            set ops ${domainName}__OPMAP
            set opsCount COUNTOF($ops)
        }
        $div puts ".operations = $ops,"
        $div puts ".operationCount = $opsCount,"

        $div puts ".classes = ${domainName}__CLASSMAP,"
        $div puts ".classCount = COUNTOF(${domainName}__CLASSMAP)"

        $div pop
        $div puts "},"
    }

    $div pop
    $div puts "} ;"
    $div puts "static int const bslHarnessCount = COUNTOF(bslHarnesses) ;"

    $div return
}
----

==== Generating the Operations Map

(((chunk,harness data types)))
(((type,BSL_DomainOpFunc)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_DomainOpFunc(int, char *const *) ;
----

(((chunk,harness data types)))
(((type,BSL_OperationMap)))

[source,c]
----
<<harness data types>>=
typedef struct bsloperationmap {
    char const *name ;
    BSL_DomainOpFunc *func ;
} BSL_OperationMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateOpMap)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpMaps {} {
    set div [diverter new]

    set ops [pipe {
        DomainOperation findAll |
        deRef ~ |
        relation project ~ Domain Name |
        relation group ~ Ops Name
    }]

    relation foreach op $ops {
        relation assign $op
        $div puts "static BSL_OperationMap const ${Domain}__OPMAP\[] = {"
        $div push

        relation foreach op $Ops -ascending Name {
            set opName [relation extract $op Name]
            $div puts "{\"$opName\", ${Domain}_${opName}__OPFUNC},"
        }

        $div pop
        $div puts "} ;"
    }

    $div return
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateOpFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateOpFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpFuncDeclarations {} {
    set div [diverter new]

    forAllRefs dopRef [DomainOperation findAll] {
        assignAttribute $dopRef Domain Name
        $div puts "static bool ${Domain}_${Name}__OPFUNC(int, char *const *) ;"
    }

    $div return
}
----

(((chunk,harness static functions)))

[source,c]
----
<<harness static functions>>=
<%generateOpFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateOpFuncDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpFuncDefinitions {} {
    set div [diverter new]

    forAllRefs dopRef [DomainOperation findAll] {
        assignAttribute $dopRef Domain Name ReturnDataType
        $div puts "static bool ${Domain}_${Name}__OPFUNC("
        $div puts "    int argc,"
        $div puts "    char *const *argv)"
        $div puts "{" ; $div push

        set paramRefs [findRelated $dopRef ~R6]
        set nparams [refMultiplicity $paramRefs]
        $div puts "if (argc != $nparams) {" ; $div push
        $div puts "bslFormatToContext(wrongNumArgsMsg, argc, $nparams) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        set argIndex 0
        set params [deRef $paramRefs]
        relation foreach param $params -ascending Number {
            relation assign $param {DataType type} {Name paramName}
            set typeinfo [GetTypeInfo $Domain $type $paramName]
            $div puts "[dict get $typeinfo declaration] ;"

            set scnfmt [dict get $typeinfo scan]
            set varref [dict get $typeinfo varref]
            if {$scnfmt ne {}} {
                $div puts "if (sscanf(argv\[$argIndex\], \"%\" $scnfmt,\
                    $varref) != 1) {" ; $div push
                $div puts "bslFormatToContext(badParamMsg, argv\[$argIndex\]) ;"
                $div puts "return false ;"
                $div pop ; $div puts "}"
            } else {
                $div puts "$paramName = argv\[$argIndex\] ;"
            }

            incr argIndex
        }

        set invokeParams [pipe {
            relation list $params Name -ascending Number |
            join ~ {, }
        }]
        set invocation "${Domain}_${Name}($invokeParams) ;"

        if {$ReturnDataType eq "void"} {
            $div puts $invocation
        } else {
            set rettypeinfo [GetTypeInfo $Domain $ReturnDataType result__OP]
            set decl [dict get $rettypeinfo declaration]
            $div puts "$decl = $invocation ;"
            $div puts "bslFormatToContext(\"%\" [dict get $rettypeinfo print],\
                    [dict get $rettypeinfo varref]) ;"
        }

        $div puts "return true ;"
        $div pop ; $div puts "}"
    }

    $div return
}
----

(((chunk,harness static data)))
(((data,wrongNumArgsMsg)))
(((data,badParamMsg)))

[source,c]
----
<<harness static data>>=
static char const wrongNumArgsMsg[] = "wrong # arguments: got %d, expected %d" ;
static char const badParamMsg[] = "bad parameter: \"%s\"" ;
----

==== Generating the Class Map

(((chunk,harness data types)))
(((type,BSL_ClassMap)))

[source,c]
----
<<harness data types>>=
typedef struct bslclassmap {
    char const *name ;
    MRT_ClassId id ;
    struct bslattrmap const *attrs ;
    unsigned attrCount ;
    struct bslinstmap const *insts ;
    unsigned instCount ;
    struct bsleventmap const *events ;
    unsigned eventCount ;
} BSL_ClassMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateClassMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateClassMaps {} {
    set div [diverter new]

    set classGrps [pipe {
        Class findAll |
        deRef ~ |
        relation group ~ Classes Name Number
    }]

    relation foreach classGrp $classGrps {
        relation assign $classGrp {Domain domainName} Classes
        $div puts "static BSL_ClassMap const ${domainName}__CLASSMAP\[] = {"
        $div push

        relation foreach class $Classes -ascending Name {
            relation assign $class {Name className} Number
            $div puts "{" ; $div push

            $div puts ".name = \"$className\","
            $div puts ".id = $Number,"

            set attrRef [Attribute findWhere\
                    {$Domain eq $domainName && $Class eq $className}]
            if {[isEmptyRef $attrRef]} {
                set attrMap NULL
                set attrCount 0
            } else {
                set attrMap ${domainName}_${className}__ATTRMAP
                set attrCount COUNTOF(${domainName}_${className}__ATTRMAP)
            }
            $div puts ".attrs = $attrMap,"
            $div puts ".attrCount = $attrCount,"

            set instRef [ClassInstance findWhere\
                    {$Domain eq $domainName && $Class eq $className}]
            if {[isEmptyRef $instRef]} {
                set instMap NULL
                set instCount 0
            } else {
                set instMap ${domainName}_${className}__INSTMAP
                set instCount COUNTOF(${domainName}_${className}__INSTMAP)
            }
            $div puts ".insts = $instMap,"
            $div puts ".instCount = $instCount,"

            set eventRef [Event findWhere\
                    {$Domain eq $domainName && $Model eq $className}]
            if {[isEmptyRef $eventRef]} {
                set eventMap NULL
                set eventCount 0
            } else {
                set eventMap ${domainName}_${className}__EVENTMAP
                set eventCount COUNTOF(${domainName}_${className}__EVENTMAP)
            }
            $div puts ".events = $eventMap,"
            $div puts ".eventCount = $eventCount,"

            $div pop ; $div puts "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the Attribute Map

(((chunk,harness data types)))
(((type,BSL_AttrMap)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_AttrReadFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId) ;
typedef bool BSL_AttrUpdateFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId, char const *) ;
typedef struct bslattrmap {
    char const *name ;
    MRT_AttrId id ;
    BSL_AttrReadFunc *readFunc ;
    BSL_AttrUpdateFunc *updateFunc ;
} BSL_AttrMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateAttrMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrMaps {} {
    set div [diverter new]

    set attrGrps [pipe {
        Attribute findAll |
        deRef ~ |
        relation project ~ Domain Class Name |
        relation group ~ Attrs Name
    }]

    relation foreach attrGrp $attrGrps {
        relation assign $attrGrp {Domain domainName} {Class className} Attrs
        $div puts "static BSL_AttrMap const\
                ${domainName}_${className}__ATTRMAP\[] = {"
        $div push

        set attrNum -1
        relation foreach attr $Attrs -ascending Name {
            relation assign $attr {Name attrName}
            $div puts "{" ; $div push

            $div puts ".name = \"$attrName\","
            $div puts ".id = [incr attrNum],"
            $div puts ".readFunc = ${domainName}_${className}_${attrName}__RD,"
            $div puts ".updateFunc = ${domainName}_${className}_${attrName}__UP"

            $div pop ; $div puts "},"
            incr id
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the Attribute Read Functions

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateAttrReadFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrReadFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrReadFuncDeclarations {} {
    set div [diverter new]

    forAllRefs attrRef [Attribute findAll] {
        assignAttribute $attrRef Domain Class Name
        $div puts "static bool\
            ${Domain}_${Class}_${Name}__RD(MRT_DomainPortal const *,\
            MRT_ClassId, MRT_InstId, MRT_AttrId) ;"
    }

    $div return
}
----

(((chunk,harness static functions)))

[source,c]
----
<<harness static functions>>=
<%generateAttrReadFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrReadFuncsDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrReadFuncDefinitions {} {
    set div [diverter new]

    forAllRefs attrRef [Attribute findAll] {
        assignAttribute $attrRef Domain Class Name DataType
        $div puts "static bool ${Domain}_${Class}_${Name}__RD("
        $div push
        $div puts "MRT_DomainPortal const *portal,"
        $div puts "MRT_ClassId classId,"
        $div puts "MRT_InstId instId,"
        $div puts "MRT_AttrId attrId)"
        $div pop
        $div puts "{" ; $div push

        set typeinfo [GetTypeInfo $Domain $DataType attrValue]
        set attrVar [dict get $typeinfo declaration]

        $div puts "$attrVar ;"

        set pAttrVar [dict get $typeinfo varref]

        $div puts "int pcode = mrt_PortalReadAttr(portal, classId, instId,\
                attrId, $pAttrVar, sizeof(attrValue)) ;"
        $div puts "if (pcode < 0) {" ; $div push
        $div puts "bslFormatToContext(mrt_PortalErrorString(pcode)) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        set varType [dict get $typeinfo type]
        set prifmt [dict get $typeinfo print]
        switch -exact -- $varType {
            scalar {
                $div puts "bslFormatToContext(\"%\" $prifmt, attrValue) ;"
            }
            string {
                $div puts "bslFormatToContext(\"%\" $prifmt, attrValue) ;"
            }
            array {
                set dim [dict get $typeinfo dimension]
                $div puts "for (int index = 0 ; $index < $dim ; index++) {"
                $div push
                $div puts "bslFormatToContext(\"%\" $prifmt \" \",\
                        attrValue\[index]) ;"
                $div pop ; $div puts "}"
            }
            default {
                error "unknown variable type, $varType"
            }
        }

        $div puts "return true ;"

        $div pop ; $div puts "}"
    }

    $div return
}
----

==== Generating the Attribute Update Functions

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateAttrUpdateFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrUpdateFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrUpdateFuncDeclarations {} {
    set div [diverter new]

    forAllRefs attrRef [Attribute findAll] {
        assignAttribute $attrRef Domain Class Name
        $div puts "static bool\
            ${Domain}_${Class}_${Name}__UP(MRT_DomainPortal const *,\
            MRT_ClassId, MRT_InstId, MRT_AttrId, char const *) ;"
    }

    $div return
}
----

(((chunk,harness static functions)))

[source,c]
----
<<harness static functions>>=
<%generateAttrUpdateFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrUpdateFuncsDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrUpdateFuncDefinitions {} {
    set div [diverter new]

    forAllRefs attrRef [Attribute findAll] {
        assignAttribute $attrRef Domain Class Name DataType
        $div puts "static bool ${Domain}_${Class}_${Name}__UP("
        $div push
        $div puts "MRT_DomainPortal const *portal,"
        $div puts "MRT_ClassId classId,"
        $div puts "MRT_InstId instId,"
        $div puts "MRT_AttrId attrId,"
        $div puts "char const *value)"
        $div pop
        $div puts "{" ; $div push

        $div puts "int pcode ;"
        set typeinfo [GetTypeInfo $Domain $DataType convertedValue]
        switch -exact -- [dict get $typeinfo type] {
            scalar {
                $div puts "[dict get $typeinfo declaration] ;"
                set cvtRef [dict get $typeinfo varref]

                if {[dict get $typeinfo basetype] eq "bool"} {
                    $div puts "int nitems = bslScanBoolean(value, $cvtRef) ;"
                    set scnfmt \"bool\"
                } else {
                    set scnfmt [dict get $typeinfo scan]
                    $div puts "int nitems = sscanf(value, \"%\" $scnfmt,\
                            $cvtRef) ;"
                }
                $div puts "if (nitems == 1) {" ; $div push
                $div puts "pcode = mrt_PortalUpdateAttr(portal, classId,\
                    instId, attrId, $cvtRef, sizeof(convertedValue)) ;"
                $div pop ; $div puts "} else {" ; $div push
                $div puts "bslFormatToContext(failedConvertMsg,\
                        value, $scnfmt) ;"
                $div puts "return false ;"
                $div pop ; $div puts "}"
            }
            string {
                $div puts "pcode = mrt_PortalUpdateAttr(portal, classId,\
                    instId, attrId, value, strlen(value) + 1) ;"
            }
            array {
            }
        }

        $div puts "if (pcode < 0) {" ; $div push
        $div puts "bslFormatToContext(mrt_PortalErrorString(pcode)) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        $div puts "return true ;"

        $div pop ; $div puts "}"
    }

    $div return
}
----

(((chunk,harness static data)))
(((data,failedConvertMsg)))

[source,c]
----
<<harness static data>>=
static char const failedConvertMsg[] = "failed to convert, \"%s\" as \"%s\"" ;
----

==== Generate the Instance Map

(((chunk,harness data types)))
(((type,BSL_InstMap)))

[source,c]
----
<<harness data types>>=
typedef struct bslinstmap {
    char const *name ;
    MRT_InstId id ;
} BSL_InstMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateInstMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateInstMaps {} {
    set div [diverter new]

    set instGrps [pipe {
        ClassInstance findAll |
        deRef ~ |
        relation group ~ Insts Instance Number
    }]

    relation foreach instGrp $instGrps {
        relation assign $instGrp {Domain domainName} {Class className} Insts
        $div puts "static BSL_InstMap const\
                ${domainName}_${className}__INSTMAP\[] = {"
        $div push

        relation foreach inst $Insts -ascending Instance {
            relation assign $inst {Instance instName} {Number instNum}
            $div puts "{" ; $div push

            $div puts ".name = \"$instName\","
            $div puts ".id = $instNum,"

            $div pop ; $div puts "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generate the Event Map

(((chunk,harness data types)))
(((type,BSL_EventMap)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_EventParamFunc(int, char * const*, MRT_EventParams) ;

typedef struct bsleventmap {
    char const *name ;
    MRT_EventCode number ;
    BSL_EventParamFunc *paramFunc ;
} BSL_EventMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateEventMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventMaps {} {
    set div [diverter new]

    set eventGrps [pipe {
        Event findAll |
        deRef ~ |
        relation group ~ Events Event Number PSigID
    }]

    relation foreach eventGrp $eventGrps {
        relation assign $eventGrp {Domain domainName} {Model className} Events
        $div puts "static BSL_EventMap const\
                ${domainName}_${className}__EVENTMAP\[] = {"
        $div push

        relation foreach event $Events -ascending Event {
            relation assign $event {Event eventName} {Number eventNum} PSigID
            $div puts "{" ; $div push

            $div puts ".name = \"$eventName\","
            $div puts ".number = $eventNum,"
            $div puts ".paramFunc = [expr {$PSigID ne {} ?\
                    "${domainName}_${className}_${eventName}__EPFUNC" :\
                    "NULL"}]"

            $div pop ; $div puts "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the Event Parameter Functions

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateEventParamFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateEventParamFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventParamFuncDeclarations {} {
    set div [diverter new]

    set eventRefs [Event findWhere {$PSigID ne {}}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Domain domainName} {Model className}\
            {Event eventName}
        $div puts "static bool\
            ${domainName}_${className}_${eventName}__EPFUNC(\
            int, char * const*, MRT_EventParams) ;"
    }

    $div return
}
----

(((chunk,harness static functions)))

[source,c]
----
<<harness static functions>>=
<%generateEventParamFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateEventParamFuncDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventParamFuncDefinitions {} {
    set div [diverter new]

    set eventRefs [Event findWhere {$PSigID ne {}}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Domain domainName} {Model className}\
            {Event eventName}
        $div puts "static bool\
            ${domainName}_${className}_${eventName}__EPFUNC("
        $div push
        $div puts "int paramc,"
        $div puts "char * const *paramv,"
        $div puts "MRT_EventParams parambuf)"
        $div pop ; $div puts "{" ; $div push

        set paramRefs [findRelated $eventRef R69 ~R79]
        set nparams [refMultiplicity $paramRefs]
        $div puts "if (paramc != $nparams) {" ; $div push
        $div puts "bslFormatToContext(wrongNumArgsMsg, paramc, $nparams) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        set structName ${domainName}_${className}_${eventName}__EPARAMS
        $div puts "struct $structName *params =\
                (struct $structName *)parambuf ;"

        set parameters [pipe {
            deRef $paramRefs |
            relation join ~ $::micca::Argument |
            relation project ~ Domain PSigID Name Position DataType
        }]
        set pindex 0
        set nitemsDefined false
        relation foreach parameter $parameters -ascending Position {
            relation assign $parameter {Domain domainName} {Name paramName}\
                    {DataType dataType}
            set typeinfo [GetTypeInfo $domainName $dataType params->$paramName]
            set scnfmt [dict get $typeinfo scan]
            if {$scnfmt eq {}} {
                $div puts "params->$paramName = paramv\[$pindex\] ;"
            } else {
                if {!$nitemsDefined} {
                    $div puts "int nitems ;"
                    set nitemsDefined true
                }
                set reftovar [dict get $typeinfo varref]
                if {[dict get $typeinfo basetype] eq "bool"} {
                    $div puts "nitems = bslScanBoolean(paramv\[$pindex\],\
                            $reftovar) ;"
                    set scnfmt \"bool\"
                } else {
                    $div puts "nitems = sscanf(paramv\[$pindex\],\
                        \"%\" $scnfmt, $reftovar) ;"
                }
                $div puts "if (nitems != 1) {" ; $div push
                $div puts "bslFormatToContext(failedConvertMsg,\
                        paramv\[$pindex\], $scnfmt) ;"
                $div puts "return false ;"
                $div pop ; $div puts "}"
            }

            incr pindex
        }

        $div puts "return true ;"
        $div pop ; $div puts "}"
    }

    $div return
}
----

== Bosal Header File

(((chunk,bosal data)))
(((data.headerFile)))

[source,tcl]
----
<<bosal data>>=
variable headerFile [textutil::adjust::undent {
/*
<<edit warning>>
<<copyright info>>
*/
/*
 * This file is the header file for bosal. A typical use case is to
 * include it in the file which contains the "main" function. This
 * file corresponds to:
   <<version info>>
 */

#ifndef BOSAL_H_
#define BOSAL_H_

/*
 * External Functions
 */
<<harness external function declarations>>

#endif /* BOSAL_H_ */}]
----
