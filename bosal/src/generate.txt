// vim:set syntax=asciidoc:

== Domain independent code

Much of the test harness code is independent of the specifics of any
domain in the harness.
One alternative design is to place the domain independent code in
a separate file and compile that code into a library.
Here,
we have decided to put both domain independent and domain dependent code
into the same file.
This design reduces any dependency between an external library code file and
different versions of `bosal`.
Since the amount of domain independent code is relatively small,
removing external dependencies was deemed beneficial.

=== External harness functions

==== Running the harness

Normally,
systems built from `micca` supply a `main()` function
which invokes the `mrt_EventLoop()` function in the micca run-time to
cause the domain to execute.
This function manages all the state machine dispatch and execution
sequencing.
When running in a test harness,
we want more control over the execution sequencing and must perform
other initialization before allowing the domains to run.
Consequently,
test harness code is run by invoking `bsl_Run()`.

(((chunk,harness external function declarations)))
(((function,bsl_Run)))

*******
[source,c]
----
<<harness external function declarations>>=
extern void bsl_Run(void) ;
----

Invoking `bsl_Run()` initializes and runs a `bosal` generated
test harness.
Before invoking this function,
it is necessary to invoke `mrt_Initialize()`.
*******

The implementation of `bsl_Run` is as you might expect,
an infinte loop that replaces the micca run-time event loop.

(((chunk,harness external function definitions)))
(((function,bsl_Run)))

[source,c]
----
<<harness external function definitions>>=
void
bsl_Run(void)
{
    if (!bslInitialize()) {                                         // <1>
        return ;
    }

    mrt_SetFatalErrorHandler(bslErrorHandler) ;                     // <2>

    for (bslHarnessState = bslRunning ; ;) {
        if (setjmp(bslFatalBuf) == 0) {                             // <3>
            mrt_EventLoop() ;                                       // <4>
        }

        for (bslHarnessState = bslHalted ; bslHarnessState == bslHalted ;) {
            bslReadAndEvalCommand(0) ;                              // <5>
        }
    }
}
----
<1> First, we must initialize the test harness infrastructure.
<2> The default error handler for the `micca` run-time will
invoke `abort()` when an error occurs.
This would cause the test harness to stop.
We want more control so we can see transitions and probe
the cause of an error.
<3> The test harness error handler uses `setjmp/longjmp` to transfer
control back to here if a fatal error occurs.
<4> It is still `mrt_EventLoop` that causes everything to run.
`mrt_EventLoop` will return if any action in the domain invokes
`mrt_SyncToEventLoop` or if the harness error handler is invoked
as a result of a fatal error.
In either case,
we consider the state of the event loop as halted.
<5> Once the event loop is halted,
we still need to read and evaluate test harness commands off the communications
link so that an external program can interact with the harness.

The harness keeps track of whether or not it is in the `micca` run-time
event loop and uses a variable to track that state.

(((chunk,harness static data)))
(((data,bslHarnessState)))

[source,c]
----
<<harness static data>>=
static enum {
    bslHalted,
    bslRunning,
} bslHarnessState = bslHalted ;
----

==== Harness instrumentation

The test harness provides functions, modeled after `printf(3)`,
for unstructured instrumentation output.
These functions are usually used by instrumentation that is
generated by `micca` and result in the output being formulated
as an instrumentation trace on the harness communication socket.

(((chunk,harness external function declarations)))
(((function,bsl_Vprintf)))

*****
[source,c]
----
<<harness external function declarations>>=
extern int
bsl_Vprintf(
    char const *format,
    va_list args) ;
----

format::
    a `printf`-style format string describing the output.
args::
    a variable argument list supplying parameters according to `format`.
*****

(((chunk,harness external function definitions)))
(((function,bsl_Vprintf)))

[source,c]
----
<<harness external function definitions>>=
int
bsl_Vprintf(
    char const *format,
    va_list args)
{
    if (!instrOn || bslCmdStream == NULL) {
        return 0 ;
    }

    bslBeginResponse(InstrContext) ;
    bslAddWordToContext(InstrContext, "instr") ;

    bslPushContext(InstrContext) ;
    bslVformatToContext(InstrContext, format, args) ;

    return bslEndResponse(InstrContext) ;
}
----

(((chunk,harness external function declarations)))
(((function,bsl_Printf)))

*****
[source,c]
----
<<harness external function declarations>>=
extern int
bsl_Printf(
    char const *format,
    ...) ;
----

format::
    A `printf`-style format string.
...::
    A variable number of function arguments matching the `format`
    specification.
*****

(((chunk,harness external function definitions)))
(((function,bsl_Printf)))

[source,c]
----
<<harness external function definitions>>=
int
bsl_Printf(
    char const *format,
    ...)
{
    va_list args ;

    va_start(args, format) ;
    int n = bsl_Vprintf(format, args) ;
    va_end(args) ;

    return n ;
}
----

=== Handling fatal system errors

The `micca` run-time code diagnoses several fatal system errors.
These are ``panic'' conditions and, by default,
invokes `abort()` to terminate the process.
We need to do better than that in a test harness since we might want to
inquire and probe to determine the circumstances of the failure.
Fortunately, we can install our own error handler to prevent the
harness from terminating.
The error handler arguments are dictated by the `micca` run-time.

(((chunk,harness forward function declarations)))
(((function,bslErrorHandler)))

[source,c]
----
<<harness forward function declarations>>=
static void bslErrorHandler(MRT_ErrorCode errNum, char const *fmt,
        va_list alist) ;
----

(((chunk,harness static function definitions)))
(((function,bslErrorHandler)))

[source,c]
----
<<harness static function definitions>>=
static void
bslErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list alist)
{
    bslBeginResponse(FatalContext) ;
    bslAddWordToContext(FatalContext, "fatal") ;

    bslPushContext(FatalContext) ;
    bslVformatToContext(FatalContext, fmt, alist) ;

    bslEndResponse(FatalContext) ;

    longjmp(bslFatalBuf, 1) ;                           // <1>
}
----
<1> This transfers control back to `bsl_Run`.

(((chunk,harness static data)))
(((data,bslFatalBuf)))

The `setjmp/longjmp` combination that performs the non-local goto needs
a variable to hold the context.

[source,c]
----
<<harness static data>>=
static jmp_buf bslFatalBuf ;
----

=== Harness initialization

The `bslInitialize` function sets up the communications and command
infrastructure for the test harness.
Most of the initialization work is involved in setting up the
TCP / IP communications socket.

(((chunk,harness forward function declarations)))
(((function,bslInitialize)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslInitialize(void) ;
----

(((chunk,harness static function definitions)))
(((function,bslInitialize)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslInitialize(void)
{
    <<bslInitialize: create socket>>
    <<bslInitialize: bind socket>>
    <<bslInitialize: listen on socket>>
    <<bslInitialize: register signals>>

    // start with tracing off
    bslDefaultTraceHandler = mrt_RegisterTraceHandler(NULL) ; // <1>

    return true ;
}
----
<1> Setting the trace handler to `NULL` disables the tracing.
We save the default trace handler pointer so it may be restored later.

Setting up the communications socket is standard POSIX systems
programming.

(((chunk,bslInitialize: create socket)))

[source,c]
----
<<bslInitialize: create socket>>=
bslServiceSock = socket(AF_INET, SOCK_STREAM, 0) ;
if (bslServiceSock == -1) {
    perror("unable to obtain AF_INET stream socket") ;
    return false ;
}
----

The socket number is held as file static data so it may be used
for other communications purposes.

[source,c]
----
<<harness static data>>=
static int bslServiceSock = -1 ;
----

The socket will be used in a server role to listen for connections,
so we must bind to a port that clients will know.

(((chunk,bslInitialize: bind socket)))

[source,c]
----
<<bslInitialize: bind socket>>=
struct sockaddr_in hsrvAddr ;
memset(&hsrvAddr, 0, sizeof(hsrvAddr)) ;
#       ifdef __APPLE__
hsrvAddr.sin_len = sizeof(hsrvAddr) ;
#       endif /* __APPLE__ */
hsrvAddr.sin_family = AF_INET ;
hsrvAddr.sin_port = htons(HARNESS_PORT) ;

static char const host[] = "localhost" ;            // <1>
struct hostent *hostAddr = gethostbyname(host) ;
if (hostAddr == NULL) {
    perror(host) ;
    return false ;
}
assert(hostAddr->h_addrtype == AF_INET) ;
memcpy(&hsrvAddr.sin_addr, hostAddr->h_addr_list[0], hostAddr->h_length) ;

int err = bind(bslServiceSock, (struct sockaddr const *)&hsrvAddr,
        sizeof(hsrvAddr)) ;
if (err == -1) {
    perror("bind()") ;
    return false ;
}
----
<1> Note we bind to `localhost`. Remote communications to a test harness
is not supported.

In addition to listening on the socket,
we register the file descriptor with the `micca` run-time.
The POSIX version of the `micca` run-time will perform callbacks
when file descriptors change state.

(((chunk,bslInitialize: listen on socket)))

[source,c]
----
<<bslInitialize: listen on socket>>=
mrt_RegisterFDService(bslServiceSock, bslAcceptConnection, NULL, NULL) ;
err = listen(bslServiceSock, 1) ;
if (err == -1) {
    perror("listen()") ;
    return false ;
}
----

We also want to handle the usual signals that indicate the harness
should be shut down.
Again the `micca` run-time for POSIX supplies functions to interface
signals to the event loop and obtain a callback when the signal
occurs.

(((chunk,bslInitialize: register signals)))

[source,c]
----
<<bslInitialize: register signals>>=
mrt_RegisterSignal(SIGQUIT, bslExitOnSignal) ;
mrt_RegisterSignal(SIGINT, bslExitOnSignal) ;
mrt_RegisterSignal(SIGTERM, bslExitOnSignal) ;
----

The `micca` run-time has a default trace handler
and we want to store that away when it is replaced by the
harness specific trace handler.

(((chunk,harness static data)))
(((data,bslDefaultTraceHandler)))

[source,c]
----
<<harness static data>>=
void (*bslDefaultTraceHandler)(MRT_TraceInfo const *traceInfo) ;
----

=== Accepting service connections

When a connection attempt occurs on the test harness socket,
control is transferred by the event loop to the `bslAcceptConnection`
function.

(((chunk,harness forward function declarations)))
(((function,bslAcceptConnection)))

[source,c]
----
<<harness forward function declarations>>=
static void bslAcceptConnection(int sock) ;
----

The implementation is a bit different than is usually used for a server
program.
First, a test harness is run for only a single session.
It does *not* service multiple clients, so the passive listening
socket is closed after the client connection is accepted.
Once the client connection is established,
it is also registered with the `micca` run-time to receive commands.

(((chunk,harness static function definitions)))
(((function,bslAcceptConnection)))

[source,c]
----
<<harness static function definitions>>=
static void
bslAcceptConnection(
    int sock)
{
    int fd = accept(sock, NULL, 0) ;

    int err = shutdown(sock, SHUT_RDWR) ;
    if (err == -1) {
        perror("shutdown()") ;
        exit(EXIT_FAILURE) ;
    }
    mrt_UnregisterFDService(sock, true, false, false) ;
    bslServiceSock = -1 ;

    if (fd == -1) {
        perror("accept()") ;
        exit(EXIT_FAILURE) ;
    }

    mrt_RegisterFDService(fd, bslReadAndEvalCommand, NULL, NULL) ;
    bslCmdStream = fdopen(fd, "w+") ;                               // <1>
    err = setvbuf(bslCmdStream, NULL, _IOLBF, 0) ;                  // <2>
}
----
<1> It is easiest just to deal with the communications connection
as a standard stream.
<2> We want line buffering so that the response is sent on an ASCII record
basis.

The command stream is stored in a file scoped variable so that the
I/O functions can just use it directly.
Only handling a single client makes all this much simpler.

(((chunk,harness static data)))
(((data,bslCmdStream)))

[source,c]
----
<<harness static data>>=
static FILE *bslCmdStream ;
----

=== Evaluating command input

The `bslReadAndEvalCommand` function was registered as the callback for
read activity on the communications connection.

(((chunk,harness forward function declarations)))
(((function,bslReadAndEval)))

[source,c]
----
<<harness forward function declarations>>=
static void bslReadAndEvalCommand(int rfd) ;
----

The `micca` run-time code arranges for this function to be called whenever
there is data to be read on the connection.
The function reads a line of input and treats it as a command,
parsing the command arguments, executing the command,
and formulating a response.

(((chunk,harness static function definitions)))
(((function,bslReadAndEvalCommand)))

[source,c]
----
<<harness static function definitions>>=
static void
bslReadAndEvalCommand(
    int rfd)
{
    <<blsReadAndEvalCommand: read command>>
    <<blsReadAndEvalCommand: initialize response>>
    <<blsReadAndEvalCommand: parse and execute command>>
    <<blsReadAndEvalCommand: finish response>>
}
----

The command is read using `fgets`.
There is some additional code to handle end of file and read errors.

(((chunk,blsReadAndEvalCommand: read command)))

[source,c]
----
<<blsReadAndEvalCommand: read command>>=
static char cmdBuffer[BUFSIZ] ;

char *cmd = fgets(cmdBuffer, sizeof(cmdBuffer), bslCmdStream) ;
if (cmd == NULL) {
    if (feof(bslCmdStream)) {
        dbgprintf("goodbye\n") ;
        bslClose() ;
        exit(EXIT_SUCCESS) ;
    } else if (ferror(bslCmdStream)) {
        if (errno == EINTR) {           // <1>
            clearerr(bslCmdStream) ;
            return ;
        }
        perror("fgets()") ;
        bslClose() ;
        exit(EXIT_FAILURE) ;
    } else {
        dbgprintf("partial\n") ;
        return ;
    }
}
bslTrimSpaceRight(cmdBuffer) ;          // <2>
dbgprintf("%s\n", cmdBuffer) ;
----
<1> Allow for interrupted reads on the socket.
<2> Remove any trailing whitespace.

The response to a command is built up word by word and a
set of buffered contexts is used to hold a word as it it
being generated.
We discuss these functions in
<<response-context,another section>>.


(((chunk,blsReadAndEvalCommand: initialize response)))

[source,c]
----
<<blsReadAndEvalCommand: initialize response>>=
bslBeginResponse(CmdContext) ;
bslAddWordToContext(CmdContext, "cmd") ;
bslPushContext(CmdContext) ;
----

The parsing strategy is to accumlate an array of pointers to the
character strings that are the words in the command.
The parsing is done, _in situ_, by writing `NUL` characters over
the whitespace separators in the command and recording the
addresses of where words begin.

(((chunk,blsReadAndEvalCommand: parse command)))

[source,c]
----
<<blsReadAndEvalCommand: parse and execute command>>=
static char parseBuffer[BUFSIZ] ;
strcpy(parseBuffer, cmdBuffer) ;                            // <1>

int argc = 0 ;
char *const *argv = NULL ;
int err = bslParseCommand(parseBuffer, &argc, &argv) ;

if (err == -1) {
    bslFormatToContext(CmdContext, "name unknown status error result ") ;

    bslPushContext(CmdContext) ;
    bslFormatToContext(CmdContext,
            "failed to parse command: \"%s\"", cmdBuffer) ;
} else if (argc != 0) {
    bslExecCommand(argc, argv) ;
} else {
    return ;
}
----
<1> We copy the command before parsing it so that we can have
the original string to use in case of an error.

(((chunk,blsReadAndEvalCommand: finish response)))

[source,c]
----
<<blsReadAndEvalCommand: finish response>>=
bslEndResponse(CmdContext) ;
----

=== Clean up and exit

When common signals are caught,
we clean up and exit.

(((chunk,harness forward function declarations)))
(((function,bslExitOnSignal)))

[source,c]
----
<<harness forward function declarations>>=
static void bslExitOnSignal(int signal) ;
----

(((chunk,harness static function definitions)))
(((function,bslExitOnSignal)))

[source,c]
----
<<harness static function definitions>>=
static void
bslExitOnSignal(
    int signal)
{
    dbgprintf("caught signal %d\n", signal) ;
    bslClose() ;
    exit(EXIT_SUCCESS) ;
}
----

Closing down requires both closing the socket and unregistering
the file descriptor from the `micca` run-time.
This is a bit overdone, since if the intent is to terminate the
process, then the operating system will take care of any loose ends.

(((chunk,harness forward function declarations)))
(((function,bslClose)))

[source,c]
----
<<harness forward function declarations>>=
static void bslClose(void) ;
----

(((chunk,harness static function definitions)))
(((function,bslClose)))

[source,c]
----
<<harness static function definitions>>=
static void
bslClose(void)
{
    if (bslServiceSock != -1) {
        shutdown(bslServiceSock, SHUT_RDWR) ;
        bslServiceSock = -1 ;
    }
    if (bslCmdStream != NULL) {
        mrt_UnregisterFDService(fileno(bslCmdStream), true, false, false) ;
        fclose(bslCmdStream) ;
    }
}
----

=== Parsing harness commands

The command parser is a very simplistic state machine implemented in a
`switch` statement.
The parsing states determine how to handle escape characters and other
special situation used to determine word boundaries.

(((chunk,harness forward function declarations)))
(((function,bslParseCommand)))

[source,c]
----
<<harness forward function declarations>>=
static int bslParseCommand(char *line, int *pargc, char *const **pargv) ;
----

(((chunk,harness static function definitions)))
(((function,bslParseCommand)))

[source,c]
----
<<harness static function definitions>>=
static int
bslParseCommand(
    char *line,
    int *pargc,
    char *const **pargv)
{
    #define MAX_ARGS    64
    static char *args[MAX_ARGS] ;

    char **pArgv = args ;
    char **const argvEnd = pArgv + MAX_ARGS ;

    int quoteCount = 0 ;
    int parseState = OUTOFWORD ;
    int parseStackStorage[2] ;
    int *parseStackTop = parseStackStorage ;

    char *pWord = line ;
    for ( ; *line != ASCII_NUL ; line++) {
        char c = *line ;
        switch (parseState) {
        case OUTOFWORD:
            if (isgraph(c)) {
                if (c == ESCAPE_CHAR) {
                    *parseStackTop++ = INWORD ;
                    parseState = INESCAPE ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else if (c == BEGIN_QUOTE) {
                    *parseStackTop++ = OUTOFWORD ;
                    parseState = INQUOTE ;
                    ++quoteCount ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else {
                    // new word beginning
                    if (pArgv < argvEnd) {
                        *pArgv++ = pWord ;
                    } else {
                        fprintf(stderr, "exceeded max arguments") ;
                        return -1 ;
                    }
                    *pWord++ = c ;
                    parseState = INWORD ;
                }
            } // else the character is just space to skip
            break ;

        case INWORD:
            if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = INESCAPE ;
            } else if (c == BEGIN_QUOTE) {
                *parseStackTop++ = parseState ;
                parseState = INQUOTE ;
                ++quoteCount ;
            } else if (isspace(c)) {
                // end of word
                parseState = OUTOFWORD ;
                *pWord++ = ASCII_NUL ;
            } else {
                *pWord++ = c ;
            }
            break ;

        case INESCAPE:
            switch (c) {
                case 'a':
                    *pWord++ = '\a' ;
                    break ;
                case 'b':
                    *pWord++ = '\b' ;
                    break ;
                case 't':
                    *pWord++ = '\t' ;
                    break ;
                case 'n':
                    *pWord++ = '\n' ;
                    break ;
                case 'v':
                    *pWord++ = '\v' ;
                    break ;
                case 'f':
                    *pWord++ = '\f' ;
                    break ;
                case 'r':
                    *pWord++ = '\r' ;
                    break ;
                default:
                    *pWord++ = c ;
                    break ;
            }
            parseState = *--parseStackTop ;
            break ;

        case INQUOTE:
            if (c == BEGIN_QUOTE) {
                ++quoteCount ;
                *pWord++ = c ;
            } else if (c == END_QUOTE) {
                if (--quoteCount == 0) {
                    parseState = *--parseStackTop ;
                    // check if ending the quote also ended the word
                    if (parseState == OUTOFWORD) {
                        *pWord++ = ASCII_NUL ;
                    }
                } else {
                    *pWord++ = c ;
                }
            } else if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = INESCAPE ;
            } else {
                *pWord++ = c ;
            }
            break ;
        }
    }

    *pWord = ASCII_NUL ;
    *pArgv = NULL ;
    if (quoteCount == 0 && parseState != INESCAPE) {
        if (pargc) {
            *pargc = pArgv - args ;
        }
        if (pargv) {
            *pargv = args ;
        }
        return 0 ;
    } else {
        return -1 ;
    }
}
----

=== Executing harness commands

To execute a harness command,
the command name is mapped to a function pointer.
This is accomplished by a binary search on an array of structures
ordered by command name giving the corresponding command function.

(((chunk,harness forward function declarations)))
(((function,bslExecCommand)))

[source,c]
----
<<harness forward function declarations>>=
static void bslExecCommand(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslExecCommand)))

[source,c]
----
<<harness static function definitions>>=
static void
bslExecCommand(
    int argc,
    char *const *argv)
{
    bslFormatToContext(CmdContext, "name %s result ", argv[0]) ;
    bslPushContext(CmdContext) ;

    BSL_CommandMap key = {
        .name = argv[0],
        .commandFunc = NULL
    } ;

    BSL_CommandMap const *cmd =
            bsearch(&key, commands, COUNTOF(commands), sizeof(commands[0]),
            bslCommandMapCompare) ;

    bool success ;
    if (cmd != NULL) {
        assert(cmd->commandFunc != NULL) ;
        success = cmd->commandFunc(argc, argv) ;
    } else {
        bslFormatToContext(CmdContext, "unknown command, \"%s\"", argv[0]) ;
        success = false ;
    }

    bslPopContext(CmdContext) ;
    bslFormatToContext(CmdContext, "status %s", success ? "ok" : "error") ;
}
----

The mapping from command name to command function pointer is accomplished
by a simple structure containing both pieces of information.

[source,c]
----
<<harness data types>>=
typedef bool BSL_CommandFunc(int, char * const*) ;

typedef struct bslcommandmap {
    char const *name ;
    BSL_CommandFunc *commandFunc ;
} BSL_CommandMap ;
----

When using a binary search,
we need a comparison functions.
This one uses `strcmp(3)` to do the actual command name comparison.

(((chunk,harness forward function declarations)))
(((function,bslCommandMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslCommandMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static function definitions)))
(((function,bslCommandMapCompare)))

[source,c]
----
<<harness static function definitions>>=
static int
bslCommandMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_CommandMap const *cm1 = m1 ;
    BSL_CommandMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

Finally,
the command name to command function map is held in an array variable
of file static scope.
The array entries must be in order of ascending alphabetic order of the
command name.

(((chunk,harness static data)))
(((data.commands)))

[source,c]
----
<<harness static data>>=
static BSL_CommandMap const commands[] = { // must be in ascending "name" order
    {
        .name = "cancel",
        .commandFunc = bslCancelCommand
    }, {
        .name = "create",
        .commandFunc = bslCreateCommand
    }, {
        .name = "createasync",
        .commandFunc = bslCreateAsyncCommand
    }, {
        .name = "delaysignal",
        .commandFunc = bslDelaySignalCommand
    }, {
        .name = "delete",
        .commandFunc = bslDeleteCommand
    }, {
        .name = "domainop",
        .commandFunc = bslDomainopCommand
    }, {
        .name = "eloop",
        .commandFunc = bslEloopCommand
    }, {
        .name = "instr",
        .commandFunc = bslInstrCommand
    }, {
        .name = "null",
        .commandFunc = bslNullCommand
    }, {
        .name = "query",
        .commandFunc = bslQueryCommand
    }, {
        .name = "read",
        .commandFunc = bslReadCommand
    }, {
        .name = "remaining",
        .commandFunc = bslRemainingCommand
    }, {
        .name = "signal",
        .commandFunc = bslSignalCommand
    }, {
        .name = "trace",
        .commandFunc = bslTraceCommand
    }, {
        .name = "update",
        .commandFunc = bslUpdateCommand
    }, {
        .name = "version",
        .commandFunc = bslVersionCommand
    },
} ;
----

=== Harness command implementation

In this section the code for the functions which implement the
various harness commands is described.
The command functions follow a basic pattern.
Arguments arrive as an array of strings.
This is the same array created when the command record was parsed
into words.
The argument strings may need to be converted into internal forms
such as integers.
Some argument strings are used directly.
Once the arguments have been checked and converted,
most of the command functions use `micca` run-time procedures
or use the portal provided by `micca` to accomplish their goal.
Each command function formats any output into a
<<response-context,response context>>
and returns a boolean value to indicate if the command was executed
successfully.

Many of the command functions need to look up entities such as
which domain or which class in a domain, etc.
These searches map an external identifier, such as a class name or
an event number, to an internal pointer value.
The internal pointer references data needed to operate on the entity.
The functions which perform the search for model level entities are described
<<locating-domain-components,below>>.

Since the command functions follow a similar pattern,
we present them with little additional commentary.

==== Cancel command

(((chunk,harness forward function declarations)))
(((function,bslCancelCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslCancelCommand(int, char *const *) ;
----

(((chunk,harness static function definitions)))
(((function,bslCancelCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslCancelCommand(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"cancel <domain> <class> <inst> <event>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    MRT_EventCode eventNumber = event->number ;
    int pcode = mrt_PortalCancelDelayedEvent(portal, classId, instId,
            eventNumber) ;
    if (pcode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Create command

(((chunk,harness forward function declarations)))
(((function,bslCreateCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslCreateCommand(int, char *const *) ;
----

(((chunk,harness static function definitions)))
(((function,bslCreateCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslCreateCommand(
    int argc,
    char *const *argv)
{
    if (argc < 3 || argc > 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"create <domain> <class> ?<state>?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    MRT_StateCode initState = MRT_StateCode_IG ;
    if (argc == 4) {                                                // <1>
        char *stateName = argv[3] ;
        BSL_StateMap const *const state = bslFindState(class, stateName) ;
        if (state == NULL) {
            return false ;
        }
        initState = state->number ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int pcode = mrt_PortalCreateInstance(portal, classId, initState) ;
    if (pcode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    bslFormatToContext(CmdContext, "%d", pcode) ;

    return true ;
}
----
<1> Providing an initial state for an instance is optional.

==== Create async command

(((chunk,harness forward function declarations)))
(((function,bslCreateCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslCreateAsyncCommand(int, char *const *) ;
----

(((chunk,harness static function definitions)))
(((function,bslCreateAsyncCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslCreateAsyncCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments: %d: expected, "
            "\"createasync <domain> <class> <event> ?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *eventName = argv[3] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    BSL_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {                                       // <1>
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 4, argv + 4, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalCreateInstanceAsync(portal, classId, eventNumber,
            params, sizeof(params)) ;
    } else {
        pcode = mrt_PortalCreateInstanceAsync(portal, classId, eventNumber,
            NULL, 0) ;
    }

    if (pcode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    bslFormatToContext(CmdContext, "%d", pcode) ;
    return true ;
}
----
<1> Parameters to the creation event are optional. Those creation events
that require parameters have a generated harness function to perform the
conversion from strings to internal form.

==== Delay signal command

(((chunk,harness forward function declarations)))
(((function,bslDelaySignalCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslDelaySignalCommand(int, char *const *) ;
----

(((chunk,harness static function definitions)))
(((function,bslDelaySignalCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslDelaySignalCommand(
    int argc,
    char *const *argv)
{
    if (argc < 6) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments: %d: expected, "
            "\"delaysignal <domain> <class> <inst> <delay> <event> "
            "?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *delayTime = argv[4] ;
    MRT_DelayTime delay ;
    int converted = sscanf(delayTime, "%" SCNu32, &delay) ;
    if (converted != 1) {
        bslFormatToContext(CmdContext, failedConvertMsg, delayTime, SCNi32) ;
        return false ;
    }

    char *eventName = argv[5] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    BSL_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 6, argv + 6, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalSignalDelayedEvent(portal, classId, instId,
                eventNumber, params, sizeof(params), delay) ;
    } else {
        pcode = mrt_PortalSignalDelayedEvent(portal, classId, instId,
                eventNumber, NULL, 0, delay) ;
    }

    if (pcode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Delete command

(((chunk,harness forward function declarations)))
(((function,bslDeleteCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslDeleteCommand(int, char *const *) ;
----

(((chunk,harness static function definitions)))
(((function,bslDeleteCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslDeleteCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"delete <domain> <class> <inst>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int pcode = mrt_PortalDeleteInstance(portal, classId, instId) ;
    if (pcode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Domain operation command

(((chunk,harness forward function declarations)))
(((function,bslDomainopCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslDomainopCommand(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslDomainopCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslDomainopCommand(
    int argc,
    char *const *argv)
{
    if (argc < 3) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments: %d: expected, "
            "domainop <domain> <operation> ?<arg1> <arg2> ...?",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *opName = argv[2] ;
    BSL_OperationMap const *const opMap = bslFindOperation(harness, opName) ;
    if (opMap == NULL) {
        return false ;
    }
    return opMap->func(argc - 3, argv + 3) ;                // <1>
}
----
<1> The invocation of domain operations is wrapped by a `bosal`
generated function which performs the conversion of the operation
arguments from strings to internal form.

==== Event loop Command

The event loop command function is more complicated than others.
The command packs substantial semantics into the argument combinations
and the event loop actions must be separated out.

(((chunk,harness forward function declarations)))
(((function,bslEloopCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslEloopCommand(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslEloopCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslEloopCommand(
    int argc,
    char *const *argv)
{
    static char const runMsg[] = "event loop is running" ;

    bool status = true ;

    if (argc == 1) {
        switch (bslHarnessState) {
        case bslHalted :
            bslAddWordToContext(CmdContext, "halted") ;
            break ;

        case bslRunning:
            bslAddWordToContext(CmdContext, "running") ;
            break ;

        default:
            bslFormatToContext(CmdContext, "unknown harness state, \"%d\"",
                    bslHarnessState) ;
            status = false ;
            break ;
        }
    } else if (argc == 2) {
        if (strcmp(argv[1], "run") == 0) {
            bslHarnessState = bslRunning ;
            bslAddWordToContext(CmdContext, "running") ;
        } else if (strcmp(argv[1], "halt") == 0) {
            mrt_SyncToEventLoop() ;
            bslHarnessState = bslHalted ;
            bslAddWordToContext(CmdContext, "halted") ;
        } else if (strcmp(argv[1], "once") == 0) {
            if (bslHarnessState != bslRunning) {
                bool didEvent = mrt_DispatchSingleEvent() ;
                bslAddWordToContext(CmdContext, didEvent ? "true" : "false") ;
            } else {
                bslAddWordToContext(CmdContext, runMsg) ;
                status = false ;
            }
        } else if (strcmp(argv[1], "toc") == 0) {
            if (bslHarnessState != bslRunning) {
                bool didEvent = mrt_DispatchThreadOfControl(true) ;
                bslAddWordToContext(CmdContext, didEvent ? "true" : "false") ;
            } else {
                bslAddWordToContext(CmdContext, runMsg) ;
                status = false ;
            }
        } else {
            bslFormatToContext(CmdContext,
                "unknown eloop option, \"%s\": expected, "
                "\"run | halt | once | toc\"",
                argv[1]) ;
            status = false ;
        }
    } else if (argc == 3) {
        if (strcmp(argv[1], "toc") == 0) {
            if (bslHarnessState == bslRunning) {
                bslAddWordToContext(CmdContext, runMsg) ;
                status = false ;
            } else {
                if (strcmp(argv[2], "wait") == 0) {
                    bool didEvent = mrt_DispatchThreadOfControl(true) ;
                    bslAddWordToContext(CmdContext, didEvent ? "true" : "false") ;
                } else if (strcmp(argv[2], "nowait") == 0) {
                    bool didEvent = mrt_DispatchThreadOfControl(false) ;
                    bslAddWordToContext(CmdContext, didEvent ? "true" : "false") ;
                } else {
                    bslFormatToContext(CmdContext,
                        "unknown toc option, \"%s\": expected, "
                        "\"toc wait | nowait\"", argv[2]) ;
                    status = false ;
                }
            }
        } else {
            bslFormatToContext(CmdContext,
                "bad eloop command format, \"%s\": expected, "
                "\"toc ?wait | nowait?\"",
                argv[1]) ;
            status = false ;
        }
    } else {
        bslFormatToContext(CmdContext,
            "wrong # of arguments: %d: expected, "
            "\"eloop ?run | halt | once | toc ?wait | nowait?\"",
            argc) ;
        status = false ;
    }

    return status ;
}
----

==== Instrument command

(((chunk,harness forward function declarations)))
(((function,bslInstrCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslInstrCommand(int argc, char *const *argv) ;
----

We want to be able to control whether instrumentation output is
generated.
This makes it easier for simple clients to interact with a test harness
without having to account of asynchronous output from the harness.
We keep the state in a simple boolean variable.

(((chunk,harness static data)))
(((variable,instrOn)))

[source,c]
----
<<harness static data>>=
static bool instrOn = false ;
----

(((chunk,harness static function definitions)))
(((function,bslInstrCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslInstrCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        bslAddWordToContext(CmdContext, instrOn ? "on" : "off") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            instrOn = true ;
            bslAddWordToContext(CmdContext, "on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            instrOn = false ;
            bslAddWordToContext(CmdContext, "off") ;
        } else {
            bslFormatToContext(CmdContext,
                    "unknown instr option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
            status = false ;
        }
    } else {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, \"instr ?on | off?\"", argc) ;
        status = false ;
    }

    return status ;
}
----

==== Null command

(((chunk,harness forward function declarations)))
(((function,bslNullCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslNullCommand(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslNullCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslNullCommand(
    int argc,
    char *const *argv)
{
    if (argc != 1) {
        bslFormatToContext(CmdContext,
                "wrong # of arguments, %d: expected, null", argc) ;
        return false ;
    }

    return true ;
}
----

==== Query command

(((chunk,harness forward function declarations)))
(((function,bslQueryCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryCommand(int, char *const *) ;
----

The query command allows queries for a number of different entities
in the test harness.
The implementation delegates the queries for the different entities
to different functions.

(((chunk,harness static function definitions)))
(((function,bslQueryCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryCommand(
    int argc,
    char *const *argv)
{
    if (argc < 2) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "query <subcmd> ?<domain> <arg1> <arg2> ...?",
            argc) ;
        return false ;
    }

    char *subcmdName = argv[1] ;
    bool status ;
    if (strcmp(subcmdName, "domains") == 0) {
        status = bslQueryDomains(argc, argv) ;
    } else if (strcmp(subcmdName, "operations") == 0) {
        status = bslQueryDomainOps(argc, argv) ;
    } else if (strcmp(subcmdName, "doparams") == 0) {
        status = bslQueryDomainOpParams(argc, argv) ;
    } else if (strcmp(subcmdName, "classes") == 0) {
        status = bslQueryClasses(argc, argv) ;
    } else if (strcmp(subcmdName, "attributes") == 0) {
        status = bslQueryAttrs(argc, argv) ;
    } else if (strcmp(subcmdName, "instances") == 0) {
        status = bslQueryInsts(argc, argv) ;
    } else if (strcmp(subcmdName, "states") == 0) {
        status = bslQueryStates(argc, argv) ;
    } else if (strcmp(subcmdName, "events") == 0) {
        status = bslQueryEvents(argc, argv) ;
    } else if (strcmp(subcmdName, "evparams") == 0) {
        status = bslQueryEventParams(argc, argv) ;
    } else if (strcmp(subcmdName, "current") == 0) {
        status = bslQueryCurrent(argc, argv) ;
    } else {
        bslFormatToContext(CmdContext,
            "unknown subcommand, \"%s\": expected, "
            "\"domains | classes | attributes | instances | "
            "states | events | current\"",
            subcmdName) ;
        status = false ;
    }

    return status ;
}
----

===== Query domains

(((chunk,harness forward function declarations)))
(((function,bslQueryDomains)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryDomains(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryDomains)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryDomains(
    int argc,
    char *const *argv)
{
    if (argc != 2) {
        bslFormatToContext(CmdContext,
                "wrong # of arguments, %d: expected, \"query domains\"", argc) ;
        return false ;
    }

    BSL_DomainHarness const *harness = bslHarnesses ;
    for (int count = bslHarnessCount ; count > 0 ; count--) {
        assert(harness->portal != NULL) ;
        bslAddWordToContext(CmdContext, mrt_PortalDomainName(harness->portal)) ;
        harness++ ;
    }
    return true ;
}
----

===== Query domain operations

(((chunk,harness forward function declarations)))
(((function,bslQueryDomainOps)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryDomainOps(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryDomainOps)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryDomainOps(
    int argc,
    char *const *argv)
{
    if (argc != 3) {
        bslFormatToContext(CmdContext,
                "wrong # of arguments, %d: expected, "
                "\"query operations <domain>\"", argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    bslPushContext(CmdContext) ;
    BSL_OperationMap const *opMap = harness->operations ;
    for (int cnt = harness->operationCount ; cnt > 0 ; cnt--) {
        bslAddWordToContext(CmdContext, opMap->name) ;

        opMap++ ;
    }
    bslPopContext(CmdContext) ;

    return true ;
}
----

===== Query domain operation parameters

(((chunk,harness forward function declarations)))
(((function,bslQueryDomainOpParams)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryDomainOpParams(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryDomainOpParams)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryDomainOpParams(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(CmdContext,
                "wrong # of arguments, %d: expected, "
                "\"query doparams <domain> <operation>\"", argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *opName = argv[3] ;
    BSL_OperationMap const *const opMap = bslFindOperation(harness, opName) ;
    if (opMap == NULL) {
        return false ;
    }

    bslPushContext(CmdContext) ;
    BSL_DomainOpParam const *params = opMap->params ;
    for (int cnt = opMap->paramCount ; cnt > 0 ; cnt--) {
        bslAddWordToContext(CmdContext, params->name) ;
        bslAddWordToContext(CmdContext, params->dataType) ;

        params++ ;
    }
    bslPopContext(CmdContext) ;

    return true ;
}
----

===== Query classes

(((chunk,harness forward function declarations)))
(((function,bslQueryClasses)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryClasses(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryClasses)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryClasses(
    int argc,
    char *const *argv)
{
    if (argc != 3) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, \"query classes <domain>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int classCount = mrt_PortalDomainClassCount(portal) ;
    for (MRT_ClassId id = 0 ; id < classCount ; id++) {                 // <1>
        char const *className = NULL ;
        int pcode = mrt_PortalClassName(portal, id, &className) ;
        if (pcode == 0) {
            bslAddWordToContext(CmdContext, className) ;
        } else {
            bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
            return false ;
        }
    }
    return true ;
}
----
<1> Class numbers always run from 0 to `classCount - 1`.
The code generation for the test harness guarantees that.
In truth, the class id's are just array index values.

===== Query attributes

(((chunk,harness forward function declarations)))
(((function,bslQueryAttrs)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryAttrs(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryAttrs)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryAttrs(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"query attributes <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int attrCount = mrt_PortalClassAttributeCount(portal, classId) ;
    assert(attrCount >= 0) ;
    if (attrCount < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(attrCount)) ;
        return false ;
    }

    for (MRT_AttrId attrId = 0 ; attrId < attrCount ; attrId++) {
        char const *attrName = NULL ;
        int pcode = mrt_PortalClassAttributeName(portal, classId, attrId,
                &attrName) ;
        if (pcode == 0) {
            bslAddWordToContext(CmdContext, attrName) ;
        } else {
            bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
            return false ;
        }
    }

    return true ;
}
----

===== Query instances

(((chunk,harness forward function declarations)))
(((function,bslQueryInsts)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryInsts(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryInsts)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryInsts(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"query instances <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int instCount = mrt_PortalClassInstanceCount(portal, classId) ;
    assert(instCount >= 0) ;
    if (instCount < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(instCount)) ;
        return false ;
    }

    bslFormatToContext(CmdContext, "total %d named ", instCount) ;

    bslPushContext(CmdContext) ;
    BSL_InstMap const *inst = classMap->insts ;
    for (unsigned namedCount = classMap->instCount ; namedCount != 0 ;
            namedCount--, inst++) {
        bslAddWordToContext(CmdContext, inst->name) ;
    }
    bslPopContext(CmdContext) ;

    return true ;
}
----

===== Query states

(((chunk,harness forward function declarations)))
(((function,bslQueryStates)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryStates(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryStates)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryStates(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"query states <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int stateCount = mrt_PortalClassStateCount(portal, classId) ;
    if (stateCount > 0) {
        for (MRT_StateCode stateId = 0 ; stateId < stateCount ; stateId++) {
            char const *stateName = NULL ;
            int pcode = mrt_PortalClassStateName(portal, classId, stateId,
                    &stateName) ;
            if (pcode == 0) {
                bslAddWordToContext(CmdContext, stateName) ;
            } else {
                bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
                return false ;
            }
        }
    }

    return true ;
}
----

===== Query events

(((chunk,harness forward function declarations)))
(((function,bslQueryEvents)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryEvents(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryEvents)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryEvents(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"query events <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int eventCount = mrt_PortalClassEventCount(portal, classId) ;
    if (eventCount > 0) {
        for (MRT_EventCode eventId = 0 ; eventId < eventCount ; eventId++) {
            char const *eventName = NULL ;
            int pcode = mrt_PortalClassEventName(portal, classId, eventId,
                    &eventName) ;
            if (pcode == 0) {
                bslAddWordToContext(CmdContext, eventName) ;
            } else {
                bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
                return false ;
            }
        }
    }

    return true ;
}
----

===== Query event parameters

(((chunk,harness forward function declarations)))
(((function,bslQueryEventParams)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryEventParams(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryEventParams)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryEventParams(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"query evparams <domain> <class> <event>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }

    char *eventName = argv[4] ;
    BSL_EventMap const *const eventMap = bslFindEvent(classMap, eventName) ;
    if (eventMap == NULL) {
        return false ;
    }

    bslPushContext(CmdContext) ;
    BSL_EventParam const *params = eventMap->params ;
    for (int i = eventMap->paramCount ; i > 0 ; i--) {
        bslAddWordToContext(CmdContext, params->name) ;
        bslAddWordToContext(CmdContext, params->dataType) ;

        params++ ;
    }
    bslPopContext(CmdContext) ;

    return true ;
}
----

===== Query current state

(((chunk,harness forward function declarations)))
(((function,bslQueryCurrent)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryCurrent(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslQueryCurrent)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslQueryCurrent(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"query current <domain> <class> <instance>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[4] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int statecode = mrt_PortalInstanceCurrentState(portal, classId, instId) ;
    if (statecode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(statecode)) ;
        return false ;
    }

    char const *stateName ;
    int pcode = mrt_PortalClassStateName(portal, classId, statecode, &stateName) ;
    if (pcode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    bslAddWordToContext(CmdContext, stateName) ;
    return true ;
}
----

==== Read Command

(((chunk,harness forward function declarations)))
(((function,bslReadCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslReadCommand(int, char *const *) ;
----

The read command implementation is slightly more complicated.
The command allows one to read all the attributes without having to
specify their names or to read just a specified set of attributes.
This causes the two cases to be separated.

(((chunk,harness static function definitions)))
(((function,bslReadCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslReadCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"read <domain> <class> <inst> ?<attr1> <attr2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    bool status = true ;
    if (argc == 4) {
        // read all the attributes
        BSL_AttrMap const *attr = class->attrs ;
        for (unsigned attrCount = class->attrCount ; attrCount != 0 ;
                attrCount--, attr++) {
            bslAddWordToContext(CmdContext, attr->name) ;
            bslPushContext(CmdContext) ;
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            bslPopContext(CmdContext) ;

            if (!status) {
                break ;
            }
        }
    } else {
        char *const *attrNames = argv + 4 ;
        for (int attrCount = argc - 4 ; attrCount != 0 ;
                attrCount--, attrNames++) {
            BSL_AttrMap const *const attr = bslFindAttr(class, *attrNames) ;
            if (attr == NULL) {
                bslResetContext(CmdContext) ;
                bslFormatToContext(CmdContext,
                        "unknown attribute, \"%s\"", *attrNames) ;
                status = false ;
                break ;
            }

            bslAddWordToContext(CmdContext, *attrNames) ;
            bslPushContext(CmdContext) ;
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            bslPopContext(CmdContext) ;

            if (!status) {
                break ;
            }
        }
    }

    return status ;
}
----

==== Remaining Command

(((chunk,harness forward function declarations)))
(((function,bslRemainingCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslRemainingCommand(int, char *const *) ;
----

(((chunk,harness static function definitions)))
(((function,bslRemainingCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslRemainingCommand(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"remaining <domain> <class> <inst> <event>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }
    MRT_EventCode eventNumber = event->number ;

    MRT_DelayTime delay ;
    int pcode = mrt_PortalRemainingDelayTime(portal, classId, instId,
            eventNumber, &delay) ;
    if (pcode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
        return false ;
    } else {
        bslFormatToContext(CmdContext, "%" PRIu32, delay) ;
    }

    return true ;
}
----

==== Signal Command

(((chunk,harness forward function declarations)))
(((function,bslSignalCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslSignalCommand(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslSignalCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslSignalCommand(
    int argc,
    char *const *argv)
{
    if (argc < 5) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments: %d: expected, "
            "\"signal <domain> <class> <inst> <event> ?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    BSL_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 5, argv + 5, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalSignalEvent(portal, classId, instId, eventNumber,
            params, sizeof(params)) ;
    } else if (argc > 5) {
        bslFormatToContext(CmdContext, wrongNumArgsMsg, argc - 5, 0) ;
        return false ;
    } else {
        pcode = mrt_PortalSignalEvent(portal, classId, instId, eventNumber,
            NULL, 0) ;
    }

    if (pcode < 0) {
        bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Trace Command

(((chunk,harness forward function declarations)))
(((function,bslTraceCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslTraceCommand(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslTraceCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslTraceCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        MRT_TraceHandler handler = mrt_RegisterTraceHandler(NULL) ;
        mrt_RegisterTraceHandler(handler) ;
        bslAddWordToContext(CmdContext, handler == NULL ? "off" : "on") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            mrt_RegisterTraceHandler(bslTraceResponse) ;
            bslAddWordToContext(CmdContext, "on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            mrt_RegisterTraceHandler(bslDefaultTraceHandler) ;
            bslAddWordToContext(CmdContext, "off") ;
        } else {
            bslFormatToContext(CmdContext,
                    "unknown trace option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
            status = false ;
        }
    } else {
        bslFormatToContext(CmdContext,
            "wrong # of arguments: %d: expected, \"trace ?on | off?\"", argc) ;
        status = false ;
    }

    return status ;
}
----

==== Responding to traces

If tracing is turned on,
then the `bslTraceResponse()` function is registered with the `micca`
run-time to handle output of tracing information.
The code is here straight forward enough,
but rather longer since it must handle the three different types of traces.
The code for the three types is placed in separate literate chunks.

(((chunk,harness forward function declarations)))
(((function,bslTraceResponse)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTraceResponse(MRT_TraceInfo const *traceInfo) ;
----

(((chunk,harness static function definitions)))
(((function,bslTraceResponse)))

[source,c]
----
<<harness static function definitions>>=
static void
bslTraceResponse(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        <<bslTraceResponse: transition traces>>
    }
        break ;

    case mrtPolymorphicEvent: {
        <<bslTraceResponse: polymorphic traces>>
    }
        break ;

    case mrtCreationEvent:
        <<bslTraceResponse: creation traces>>
        break ;

    default:
        fprintf(bslCmdStream,
                "trace {"
                "type error "
                "result {unknown trace event type, \"%u\"} "
                "time %s"
                "}\n",
            traceInfo->eventType,
            bslTimestamp()) ;
        break ;
    }
}
----

(((chunk,bslTraceResponse: transition traces)))

[source,c]
----
<<bslTraceResponse: transition traces>>=
MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
char const *newStateName ;
if (newState == MRT_StateCode_IG) {
    newStateName = "IG" ;
} else if (newState == MRT_StateCode_CH) {
    newStateName = "CH" ;
} else {
    newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
        traceInfo->info.transitionTrace.newState] ;
}

fprintf(bslCmdStream,
        "trace {"
        "type transition "
        "event %s "
        "source %s.%s "
        "target %s.%s "
        "currstate %s "
        "newstate %s "
        "time %s"
        "}\n",
    traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
    sourceClassName, sourceName,
    traceInfo->targetInst->classDesc->name, targetName,
    traceInfo->targetInst->classDesc->edb->stateNames[
        traceInfo->info.transitionTrace.currentState],
    newStateName,
    bslTimestamp()) ;
----

(((chunk,bslTraceResponse: polymorphic traces)))

[source,c]
----
<<bslTraceResponse: polymorphic traces>>=
MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
        genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
MRT_Class const *subclass ;
char const *subname = NULL ;
if (rel->relType == mrtRefGeneralization) {
    subclass = rel->relInfo.refGeneralization.
        subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
    subname = subclass->name ;
} else if (rel->relType == mrtUnionGeneralization) {
    subclass = rel->relInfo.unionGeneralization.
        subclasses[traceInfo->info.polyTrace.subcode] ;
    subname = subclass->name ;
} else {
    printf("%s: bad relationship type in polymorphic event, %d\n",
        bslTimestamp(), rel->relType) ;
    break ;
}
fprintf(bslCmdStream,
        "trace {"
        "type polymorphic "
        "event %s "
        "source %s.%s "
        "target %s.%s "
        "relationship %s "
        "newevent %s "
        "subclass %s "
        "time %s"
        "}\n",
    traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
    sourceClassName, sourceName,
    traceInfo->targetInst->classDesc->name, targetName,
    traceInfo->targetInst->classDesc->pdb->genNames[
        traceInfo->info.polyTrace.genNumber],
    subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
    subname,
    bslTimestamp()) ;
----

(((chunk,bslTraceResponse: creation traces)))

[source,c]
----
<<bslTraceResponse: creation traces>>=
fprintf(bslCmdStream,
        "trace {"
        "type creation "
        "event %s "
        "source %s.%s "
        "target %s.%s "
        "time %s"
        "}\n",
    traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
    sourceClassName, sourceName,
    traceInfo->info.creationTrace.targetClass->name, targetName,
    bslTimestamp()) ;
----

Traces are timestamped before sending to the test harness client.
The standard library time functions handle the heavy lifting.

(((chunk,harness forward function declarations)))
(((function,bslTimestamp)))

[source,c]
----
<<harness forward function declarations>>=
static char const *bslTimestamp(void) ;
----

(((chunk,harness static function definitions)))
(((function,bslTimestamp)))

[source,c]
----
<<harness static function definitions>>=
static char const *
bslTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "timestamp too big" ;
    }

    return timestamp ;
}
----

==== Update Command

(((chunk,harness forward function declarations)))
(((function,bslUpdateCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslUpdateCommand(int, char *const *) ;
----

(((chunk,harness static function definitions)))
(((function,bslUpdateCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslUpdateCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        bslFormatToContext(CmdContext,
            "wrong # of arguments, %d: expected, "
            "\"update <domain> <class> <inst> ?<attr1> <value1> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    bool status = true ;
    int updateCount = argc - 4 ;
    if (updateCount % 2 != 0) {
        bslFormatToContext(CmdContext,
                "updates must be given as name / value pairs") ;
        return false ;
    }

    char *const *attrName = argv + 4 ;
    char *const *valueString = argv + 5 ;
    for ( ; updateCount != 0 ;
            updateCount -= 2, attrName += 2, valueString += 2) {
        BSL_AttrMap const *const attr = bslFindAttr(class, *attrName) ;
        if (attr == NULL) {
            bslResetContext(CmdContext) ;
            bslFormatToContext(CmdContext,
                    "unknown attribute, \"%s\"", *attrName) ;
            status = false ;
            break ;
        }

        bslAddWordToContext(CmdContext, *attrName) ;
        bslPushContext(CmdContext) ;
        status = attr->updateFunc(portal, classId, instId, attr->id,
                *valueString) ;
        if (status) {
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            bslPopContext(CmdContext) ;
        }

        if (!status) {
            break ;
        }
    }

    return status ;
}
----

==== Version command

(((chunk,harness forward function declarations)))
(((function,bslVersionCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslVersionCommand(int argc, char *const *argv) ;
----

(((chunk,harness static function definitions)))
(((function,bslVersionCommand)))

[source,c]
----
<<harness static function definitions>>=
static bool
bslVersionCommand(
    int argc,
    char *const *argv)
{
    if (argc != 1) {
        bslFormatToContext(CmdContext, wrongNumArgsMsg, 0, 1) ;
        return false ;
    }

    bslAddWordToContext(CmdContext, BOSAL_VERSION) ;
    return true ;
}
----

=== Locating Domain Components [[locating-domain-components]]

Much of the function of a test harness is to map external identifiers
onto internal data.
For example, domains are known by a name, which is a string, outside
of the test harness, but operations on the domain require a pointer
to the portal for the domain.

In this section we describe the various functions used to perform the
mapping of strings and numbers into pointers to the internal data structures
used in the actual operations on the domain components.

Note also that if these search functions fail,
they place an error message into the command response context indicating
the cause of the failure.
This prevents having to generate error messages at invocation of the
search functions.

==== Finding a Harness

The harness code generator creates a variable which is an array of 
<<domain-harness-data-type,data structures>>
containing a description of the domains integrated into the harness.
This array is not created in any particular order,
so finding a particular domain in the test harness is done using a simple
linear sequential search.
Since the number of domain in a test harness is usually quite small
(usually much less than even 10),
the search method is not critical to the performance.

(((chunk,harness forward function declarations)))
(((function,bslFindHarness)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_DomainHarness const *const bslFindHarness(char const *domainName) ;
----

(((chunk,harness static function definitions)))
(((function,bslFindHarness)))

[source,c]
----
<<harness static function definitions>>=
static BSL_DomainHarness const *const
bslFindHarness(
    char const *domainName)
{
    assert(domainName != NULL) ;

    BSL_DomainHarness const *hiter = bslHarnesses ;
    int hcount = bslHarnessCount ;
    for ( ; hcount != 0 ; hcount--, hiter++) {
        assert(hiter->portal != NULL) ;
        assert(hiter->portal->name != NULL) ;
        char const *trialName = mrt_PortalDomainName(hiter->portal) ;
        if (strcmp(domainName, trialName) == 0) {
            return hiter ;
        }
    }
    bslFormatToContext(CmdContext, "unknown domain, \"%s\"", domainName) ;
    return NULL ;
}
----

==== Finding a Domain Operation

The mapping data of domain operation name to its corresponding operation
function is ordered by ascending operation name,
so a binary search may be used to find a particular operation name.

(((chunk,harness forward function declarations)))
(((function,bslFindOperation)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_OperationMap const *const bslFindOperation(
    BSL_DomainHarness const *const harness, char const *opName) ;
----

(((chunk,harness static function definitions)))
(((function,bslFindOperation)))

[source,c]
----
<<harness static function definitions>>=
static BSL_OperationMap const *const
bslFindOperation(
    BSL_DomainHarness const *const harness,
    char const *opName)
{
    BSL_OperationMap key = {
        .name = opName,
        .func = NULL
    } ;

    BSL_OperationMap const *const opMap =
            bsearch(&key, harness->operations, harness->operationCount,
            sizeof(key), bslOperationMapCompare) ;
    if (opMap == NULL) {
        bslFormatToContext(CmdContext, "unknown operation, \"%s\"", opName) ;
    }

    return opMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslOperationMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslOperationMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static function definitions)))
(((function,bslOperationMapCompare)))

[source,c]
----
<<harness static function definitions>>=
static int
bslOperationMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_OperationMap const *cm1 = m1 ;
    BSL_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Domain Class

(((chunk,harness forward function declarations)))
(((function,bslFindClass)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_ClassMap const *const bslFindClass(
    BSL_DomainHarness const *const harness, char const *className) ;
----

(((chunk,harness static function definitions)))
(((function,bslFindClass)))

[source,c]
----
<<harness static function definitions>>=
static BSL_ClassMap const *const
bslFindClass(
    BSL_DomainHarness const *const harness,
    char const *className)
{
    BSL_ClassMap key = {
        .name = className
    } ;

    BSL_ClassMap const *const classMap =
            bsearch(&key, harness->classes, harness->classCount,
            sizeof(key), bslClassMapCompare) ;
    if (classMap == NULL) {
        bslFormatToContext(CmdContext, "unknown class, \"%s\"", className) ;
    }

    return classMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslClassMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static function definitions)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness static function definitions>>=
static int
bslClassMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_OperationMap const *cm1 = m1 ;
    BSL_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class Attribute

(((chunk,harness forward function declarations)))
(((function,bslFindAttr)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_AttrMap const *const
bslFindAttr(
    BSL_ClassMap const *const class,
    char const *attrName) ;
----

(((chunk,harness static function definitions)))
(((function,bslFindAttr)))

[source,c]
----
<<harness static function definitions>>=
static BSL_AttrMap const *const
bslFindAttr(
    BSL_ClassMap const *const class,
    char const *attrName)
{
    BSL_AttrMap key = {
        .name = attrName
    } ;

    return (BSL_AttrMap const *const)
            bsearch(&key, class->attrs, class->attrCount,
            sizeof(key), bslAttrMapCompare) ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslAttrMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslAttrMapCompare(void const*, void const*) ;
----

(((chunk,harness static function definitions)))
(((function,bslAttrMapCompare)))

[source,c]
----
<<harness static function definitions>>=
static int
bslAttrMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_AttrMap const *cm1 = m1 ;
    BSL_AttrMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class Instance

A class instance may be specified as either a number or,
for initial instance, a name.
When searching for a class instance, we first try to see if it is specified
as a number and then fall back to names should the number conversion fail.

(((chunk,harness forward function declarations)))
(((function,bslFindInst)))

[source,c]
----
<<harness forward function declarations>>=
static int bslFindInst(BSL_ClassMap const *const class, char const *instName) ;
----

(((chunk,harness static function definitions)))
(((function,bslFindInst)))

[source,c]
----
<<harness static function definitions>>=
static int
bslFindInst(
    BSL_ClassMap const *const class,
    char const *instName)
{
    // First scan to see if we got a number.
    int instId = -1 ;
    int converted = sscanf(instName, "%i", &instId) ;
    if (converted == 1) {
        if (instId < 0) {
            bslFormatToContext(CmdContext,
                    "instance id's must be non-negative: got, %i", instId) ;
        }
    } else {
        // Not a number, try to look up the name.
        BSL_InstMap key = {
            .name = instName
        } ;

        BSL_InstMap const *const instMap =
                bsearch(&key, class->insts, class->instCount,
                sizeof(key), bslInstMapCompare) ;
        if (instMap == NULL) {
            bslFormatToContext(CmdContext,
                    "unknown instance, \"%s\"", instName) ;
            instId = -1 ;
        } else {
            instId = instMap->id ;
        }
    }

    return instId ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslInstMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslInstMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static function definitions)))
(((function,bslInstMapCompare)))

[source,c]
----
<<harness static function definitions>>=
static int
bslInstMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_InstMap const *cm1 = m1 ;
    BSL_InstMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class Event

(((chunk,harness forward function declarations)))
(((function,bslFindEvent)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_EventMap const *bslFindEvent(BSL_ClassMap const *const class,
        char const *eventName) ;
----

(((chunk,harness static function definitions)))
(((function,bslFindEvent)))

[source,c]
----
<<harness static function definitions>>=
static BSL_EventMap const *
bslFindEvent(
    BSL_ClassMap const *const class,
    char const *eventName)
{
    BSL_EventMap key = {
        .name = eventName
    } ;

    BSL_EventMap const *eventMap = bsearch(&key, class->events,
            class->eventCount, sizeof(key), bslEventMapCompare) ;

    if (eventMap == NULL) {
        bslFormatToContext(CmdContext, "unknown event, \"%s\"", eventName) ;
    }

    return eventMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslEventMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static function definitions)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness static function definitions>>=
static int
bslEventMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_EventMap const *cm1 = m1 ;
    BSL_EventMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class State

(((chunk,harness forward function declarations)))
(((function,bslFindState)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_StateMap const *bslFindState(BSL_ClassMap const *const class,
        char const *stateName) ;
----

(((chunk,harness static function definitions)))
(((function,bslFindState)))

[source,c]
----
<<harness static function definitions>>=
static BSL_StateMap const *
bslFindState(
    BSL_ClassMap const *const class,
    char const *stateName)
{
    BSL_StateMap key = {
        .name = stateName
    } ;

    BSL_StateMap const *stateMap = bsearch(&key, class->states,
            class->stateCount, sizeof(key), bslStateMapCompare) ;

    if (stateMap == NULL) {
        bslFormatToContext(CmdContext, "unknown state, \"%s\"", stateName) ;
    }

    return stateMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslStateMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static function definitions)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness static function definitions>>=
static int
bslStateMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_StateMap const *cm1 = m1 ;
    BSL_StateMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

== Domain Dependent Code

In this section,
we describe the Tcl code that generates the ``C'' code that is
dependent upon the particulars of the domain.
Previously,
we presented ``C'' code which formed the common core of the test harness
code and was independent of the details of the harnessed domain.
That code, however, does depend upon data structures and functions
that are specific to the details of the harnessed domain.
For example,
the code to locate a class in a domain is independent of the domain, but
relies on generated data that is specific to the domain.

The approach to the code generation is same as that found in the
code generation for `micca`, namely,
a template is expanded.
Command in the template are executed and the result of the embedded commands
is substituted into the template.
The embedded template commands query the domain model to find out the
information needed to generate the correct code.
Note, that the queries contained in the template commands reference
the `micca` domain model.
It will be useful to have that model readily available to understand
the details of the queries being performed.

We start at the top level and then show the details of the various
commands embedded in the template.

=== Generate Command

The `generate` command is the fundamental command to create the
``C'' code file for the test harness.
<<source-code,Later>>
we see how the `generate` procedure is used in the overall processing
of the `bosal` program.

(((chunk,bosal commands)))
(((proc,generate)))

[source,tcl]
----
<<bosal commands>>=
proc generate {options} {
    <<generate: set up template expansion>>
    <<generate: generate code>>
}
----

Template expansion is accomplished using the `expander`
package from _tcllib_.

(((chunk,required packages)))

[source,tcl]
----
<<required packages>>=
package require textutil::expander
----

(((chunk,generate: set up template expansion)))

[source,tcl]
----
<<generate: set up template expansion>>=
textutil::expander expand
expand setbrackets <% %>                            ; # <1>
expand errmode [dict get $options expanderror]
expand evalcmd "namespace eval [namespace current]::GenCode"    ; # <2>

variable GenCode::includeMain [dict get $options main]
----
<1> For convenience, we change the strings the expander uses to recognize
an embedded command.
This set is more convenient when dealing with ``C'' code.
<2> To make sure the command names resolve as we want,
the expansion is done in a separate namespace.

(((chunk,generate: generate code)))

[source,tcl]
----
<<generate: generate code>>=
try {
    variable codeTemplate
    return [expand expand $codeTemplate]
} on error {result opts} {
    # puts $::errorInfo
    return -options $opts $result
} finally {
    rename expand {}
}
----

==== Code Template

The template for the code generation is organized in the order
required by the ``C'' compiler.
This lets us insure that constructs are declared before they are
defined as required by the language.

(((chunk,bosal data)))
(((data,codeTemplate)))

[source,tcl]
----
<<bosal data>>=
variable codeTemplate [textutil::adjust::undent {
/*
<<edit warning>>
<<copyright info>>

This file generated by bosal version:
<<version info>>
*/

/*
 * Include Files
 */
#define _POSIX_C_SOURCE 201112L
#include "bosal.h"
#include "micca_rt.h"
#include "micca_rt_internal.h"
/*
 * Domain Header Files
 */
<%includeDomainHeaders%>
#include <sys/socket.h>
#include <sys/time.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <setjmp.h>
#include <ctype.h>
#include <time.h>
#include <strings.h>

/*
 * Macros
 */
#ifndef NDEBUG
#   define  dbgprintf(...)    printf(__VA_ARGS__)
#else
#   define  dbgprintf(...)
#endif /* NDEBUG */

/*
 * Special characters used in parsing commands.
 */
#define ASCII_NUL       '\0'
#define BEGIN_QUOTE     '{'
#define END_QUOTE       '}'
#define ESCAPE_CHAR     '\\'

/*
 * The state of the command parser.
 */
#define OUTOFWORD   0
#define INWORD      1
#define INESCAPE    2
#define INQUOTE     3

/*
 * Constants
 */
#ifndef HARNESS_PORT
#   define HARNESS_PORT 3906    /* default port number for TCP connection */
#endif /* HARNESS_PORT */
#ifndef BSL_NESTLIMIT
#   define  BSL_NESTLIMIT   4   /* maximum depth of text diversions */
#endif /* BSL_NESTLIMIT */

/*
 * Data Types
 */
<<harness data types>>

/*
 * Forward References
 */
<<harness forward function declarations>>

/*
 * Static Data
 */
<<harness static data>>
<%generateStateMaps%>
<%generateEventParams%>
<%generateEventMaps%>
<%generateInstMaps%>
<%generateAttrMaps%>
<%generateClassMaps%>
<%generateOpParams%>
<%generateOpMaps%>
<%generateHarnesses%>

/*
 * Static Functions
 */
<<harness static function definitions>>

/*
 * External Functions
 */
<<harness external function definitions>>
<%generateMain%>
}]
----

In the following sections,
we show the Tcl code that is executed during the template expansion.

=== Generating main

Upon request,
`bosal` will generate a `main()` function into the test harness code file.
For simple cases,
this main is sufficient to run the test harness and removes the burden
of having yet another file in the project.
The following Tcl procedure creates the code for the minimal `main()` function.

(((chunk,bosal code template commands)))
(((proc,generateMain)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateMain {} {
    variable includeMain

    if ($includeMain) {
        set div [diverter new]                      ; # <1>

        $div puts int
        $div puts main( ; $div push
        $div puts "int argc,"
        $div puts "char **argv)" ; $div pop
        $div puts "{" ; $div push
        $div puts "mrt_Initialize() ;"
        $div puts "bsl_Run() ;"
        $div puts "return 0 ;" ; $div pop
        $div puts "}"

        $div return
    }

    return
}
----
<1> The Tcl code to generate the test harness code uses the concept of a
<<text-diversion,text diversion>>
to deal with indentation levels, etc.

=== Including the domain header files

The domain header files are derived from the name of a domain.
This matches the naming convension used by `micca` in producing
the header file.

(((chunk,bosal code template commands)))
(((proc,generateHarnesses)))

[source,tcl]
----
<<bosal code template commands>>=
proc includeDomainHeaders {} {
    set div [diverter new]

    forAllRefs domainRef [Domain findAll] {
        set domainName [readAttribute $domainRef Name]
        $div puts "#include \"$domainName.h\""
    }

    $div return
}
----

=== Generating domain mappings

A major part of the link between the domain independent code and
the harnessed domains is a set of mapping tables.
The mapping tables typically map string values onto some internal
reference into the domain.
For example,
knowing how to execute a domain operation involves mapping the
name of the operation to a function that ultimately invokes the
``C'' function that is the domain operation provided by the model translation.

The mapping tables are ordered alphabetically by the string key.
This allows us to use `bsearch` to find an entry.
The tables are not very large, so binary search is sufficient
for our purposes and easier to manage than a hash table.

==== Generating the domain harness

The top level mapping locates information about a domain and is a mapping
from the name of the domain to its descriptive data.

The following data structure describes an harnessed domain.
[[domain-harness-data-type]]

(((chunk,harness data types)))
(((type,BSL_DomainHarness)))

[source,c]
----
<<harness data types>>=
typedef struct bsldomainharness {
    MRT_DomainPortal const *portal ;                    // <1>
    struct bsloperationmap const *const operations ;    // <2>
    unsigned operationCount ;                           // <3>
    struct bslclassmap const *const classes ;           // <4>
    unsigned classCount ;                               // <5>
} BSL_DomainHarness ;
----
<1> A pointer to the portal for the domain. The portal is needed
to use the `micca` run-time portal functions to control aspects of the
domain.
<2> A pointer to an array of descriptors for the domain operations
of the domain.
The domain operation descriptors are defined <<operation-map,below>>.
<3> The number of elements in the `operations` array.
<4> A pointer to an array of descriptors for the classes in the domain.
The class descriptors are defined <<class-map,below>>.
<5> The number of elements in the `classes` array.

The data for the set of domains in the harness is contained in
an initialized array variable of file static scope.

We spend some effort here to describe how the generation of the
harness mapping data structure happens.
Other map generating procedures follow a similar pattern,
so understanding this one will help in understanding the remaining ones.

(((chunk,bosal code template commands)))
(((proc,generateHarnesses)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateHarnesses {} {
    set div [diverter new]

    <<generateHarnesses: query micca model>>
    <<generateHarnesses: iterate over query result>>

    $div return
}
----

Much of the code generated by `bosal` contains data obtained from the
population of the platform specific model as gathered by `micca`.
When `bosal` runs,
it obtains the domain data by reading the file saved by `micca` when
the domain is translated.
The relvars of the `micca` model reside in the `micca` namespace and
so we can use those values directly.

Since the harness map needs information about the operations of a
domain and the classes in the domain,
we start by obtaining that information.

(((chunk,generateHarnesses: query micca model)))

[source,tcl]
----
<<generateHarnesses: query micca model>>=
set domops [relation project $::micca::DomainOperation Domain Name]
set classes [relation project $::micca::Class Domain Name]
----

Here we projected out only the attributes of *DomainOperation*
and *Class* that we intend to use.
This just keeps things easier to grasp by removing unused attributes.

The main query follows.
The desired result is a relation value that gives the domain name
and two additional attributes giving the required information about
domain operations and classes.

(((chunk,generateHarnesses: query micca model)))

[source,tcl]
----
<<generateHarnesses: query micca model>>=
set domains [pipe {
    relation project $::micca::Domain Name |
    relation rename ~ Name Domain |
    rvajoin ~ $domops Ops |
    rvajoin ~ $classes Classes
}]
----

This query is a pipeline of four commands:

. Start with the **Domain**s of the model and,
again for simplicity,
project out the name as the only attribute we are interested in.
. Rename the *Name* attribute to be *Domain*.
This makes the attribute have the same name as it has in the
*DomainOperation* and *Class* relvars.
. Perform a relational outer join against the domain operations.
The relational outer join avoids *NULL* values in the result
by creating a relation valued attribute containing the joined tuples.
If there are no matching tuples, then the relation valued attribute
is empty (_i.e._ it contains no tuples).
The new relation valued attribute is called *Ops*.
. Do the same thing with the classes, placing the result in an attribute
named, *Classes*.

The result of the query has the following tabular heading.
The tuples in the relation have three attribute:
*Domain*, *Ops*, and *Classes*.
There is one tuple in the relation for each domain in the harness.

.....
+------+---------------------------+-------------------------+
|Domain|Ops                        |Classes                  |
|string|Relation                   |Relation                 |
+------+---------------------------+-------------------------+
|      |+-------------------------+|+--------------------+   |
|      ||Name                     |||Name                |   |
|      ||string                   |||string              |   |
|      |+-------------------------+|+--------------------+   |
|      ||                         |||                    |   |
|      |+-------------------------+|+--------------------+   |
+------+---------------------------+-------------------------+
.....

Recall that the *Ops* and *Classes* attributes are also relations.
These relations contain a single attribute, *Name* which is the
name of the domain operation or class.
There is one tuple in the *Ops* relation value for each domain operation
in the domain and one tuple in the *Classes* for each class in the domain.

Now the array can be defined and initialized by iterating over the
tuples in the result relation.

(((chunk,generateHarnesses: iterate over query result)))
[source,tcl]
----
<<generateHarnesses: iterate over query result>>=
$div puts "static BSL_DomainHarness const bslHarnesses\[] = {"  ;   # <1>
$div push

relation foreach domain $domains -ascending Domain {
    relation assign $domain                                     ;   # <2>

    set opsCount [relation cardinality $Ops]
    set ops [expr {$opsCount > 0 ? "${Domain}__OPMAP" : "NULL"}] ;  # <3>

    set classCount [relation cardinality $Classes]
    set classes [expr {$classCount > 0 ? "${Domain}__CLASSMAP" : "NULL"}]

    $div puts "{" ; $div push

    $div puts ".portal = &${Domain}__PORTAL,"                   ;   # <4>
    $div puts ".operations = $ops,"
    $div puts ".operationCount = $opsCount,"
    $div puts ".classes = $classes,"
    $div puts ".classCount = $classCount"

    $div pop ; $div puts -nonewline "},"
}

$div pop ; $div puts "} ;"

$div puts "static int const bslHarnessCount =\
        [relation cardinality $domains] ;"                      ;   # <5>
----
<1> Define an array named `bslHarnesses` to hold the harness information.
This will be followed by initializers for all the elements of the array.
<2> `relation assign` splits out the attributes into ordinary Tcl variables
with the same name.
Since *Ops* and *Classes* were relation valued, the corresponding Tcl
variables will hold relation values.
<3> Here we see the use of a naming convention to tie together the
harness information with the array of domain operation descriptors.
Another embedded macro command will generate the information for the
domain operations and will use this naming convention for the variable.
Since in ``C'' the name of an array degrades to a pointer to the first
element of the array,
the simple array name gives us the pointer value we need here.
We use `NULL` to indicate that there are no domain operations for the domain.
The same strategy is also applied to the classes of the domain.
<4> Now the structure member initializers of each array element are written to
the diversion that is used to accumulate the output returned as the
result of the embedded macro command expansion.
<5> We generate a constant to know the number of elements in the
harness information array.

==== Generating the operations map [[operation-map]]

Domain operation names are mapped to a corresponding function.
That function has a fixed signature and serves as a wrapper
to parse the arguments to the domain operation and then eventually,
if there is no argument parsing error, invoke the actual domain
operation.
The wrapper function are automatically generated from the signature
of the domain operations.

The wrapper function has the following prototype.

(((chunk,harness data types)))
(((type,BSL_DomainOpFunc)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_DomainOpFunc(int, char *const *) ;
----

The mapping is from a string name to the wrapper function pointer
and the descriptors of the domain operation parameters.

(((chunk,harness data types)))
(((type,BSL_OperationMap)))

[source,c]
----
<<harness data types>>=
typedef struct bsloperationmap {
    char const *name ;
    BSL_DomainOpFunc *func ;
    struct bslopparams const *params ;
    size_t paramCount ;
} BSL_OperationMap ;
----

Following the same pattern as above,
generating the domain operations map involves querying the model
and then iterating over the results of the query.

(((chunk,bosal code template commands)))
(((proc,generateOpMap)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpMaps {} {
    set div [diverter new]

    <<generateOpMaps: query micca model>>
    <<generateOpMaps: iterate over query result>>

    $div return
}
----

The model query involves the domain operations and any parameters
to the operation.

[source,tcl]
----
<<generateOpMaps: query micca model>>=
set params [relation project $::micca::DomainOperationParameter\
        Domain Operation Name]
set domainops [pipe {
    relation project $::micca::DomainOperation Domain Name |
    relation rename ~ Name Operation |
    rvajoin ~ $params Params |
    relation group ~ Ops Operation Params
}]
----

This query results in a relation value with the following
tabular heading.

.....
+------+-------------------------------+
|Domain|Ops                            |
|string|Relation                       |
+------+-------------------------------+
|      |+-----------+--------+         |
|      ||Operation  |Params  |         |
|      ||string     |Relation|         |
|      |+-----------+--------+         |
|      ||           |+------+|         |
|      ||           ||Name  ||         |
|      ||           ||string||         |
|      ||           |+------+|         |
|      ||           ||      ||         |
|      ||           |+------+|         |
|      |+-----------+--------+         |
+------+-------------------------------+
.....

In words,
the relation resulting from the query of the `micca` model
relates the domain name to a relation valued attribute
 describing the domain operations.
The operation relation value maps the operation name to another relation
value attribute describing its parameters.
The parameters relation gives the name, ordinal number and data type of
the parameter.

[source,tcl]
----
<<generateOpMaps: iterate over query result>>=
relation foreach domainop $domainops {
    relation assign $domainop

    <<generateOpMaps: generate operations descriptions>>
}
----

Iterating over the domain operations allows us to
create the initialized array variable that serves as the
domain operations map.

[source,tcl]
----
<<generateOpMaps: generate operations descriptions>>=
$div puts "static BSL_OperationMap const ${Domain}__OPMAP\[] = {"

$div push
relation foreach op $Ops -ascending Operation {
    relation assign $op

    set paramCount [relation cardinality $Params]
    set paramMap [expr {$paramCount != 0 ?
            "${Domain}_${Operation}__OPPARAMS" : "NULL"}]

    $div puts "{" ; $div push
    $div puts ".name = \"$Operation\","
    $div puts ".func = ${Domain}_${Operation}__OPFUNC,"
    $div puts ".params = $paramMap,"
    $div puts ".paramCount = $paramCount"
    $div pop ; $div puts -nonewline "},"
}

$div pop
$div puts "} ;"
----

==== Generating the domain operation functions

We need forward declarations for all the domain operation functions
to keep the compiler happy.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateOpFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateOpFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpFuncDeclarations {} {
    set div [diverter new]

    forAllRefs dopRef [DomainOperation findAll] {
        assignAttribute $dopRef Domain Name
        $div puts "static bool ${Domain}_${Name}__OPFUNC(int, char *const *) ;"
    }

    $div return
}
----

As mentioned previously,
the domain operation function is a wrapper to parse the string
arguments obtained from the command into the internal forms
needed by the actual domain operation.

(((chunk,harness static function definitions)))

[source,c]
----
<<harness static function definitions>>=
<%generateOpFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateOpFuncDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpFuncDefinitions {} {
    set div [diverter new]

    <<generateOpFuncDefinitions: query micca model>>
    <<generateOpFuncDefinitions: iterate over query result>>

    $div return
}
----

The query is similar to the one used for the domain operation information
in the harness.

[source,tcl]
----
<<generateOpFuncDefinitions: query micca model>>=
set domainops [pipe {
    relation project $::micca::DomainOperation Domain Name ReturnDataType |
    relation rename ~ Name Operation |
    rvajoin ~ $::micca::DomainOperationParameter Params
}]
----

The query generates a relation value with the following heading.

.....
+------+--------------------+---------------+----------------------------+
|Domain|Operation           |ReturnDataType |Params                      |
|string|string              |string         |Relation                    |
+------+--------------------+---------------+----------------------------+
|      |                    |               |+------+------+--------+    |
|      |                    |               ||Name  |Number|DataType|    |
|      |                    |               ||string|int   |string  |    |
|      |                    |               |+------+------+--------+    |
|      |                    |               |+------+------+--------+    |
+------+--------------------+---------------+----------------------------+
.....

We iterate over the tuples in the query result which gives us the
information to invoke a single domain operation.

[source,tcl]
----
<<generateOpFuncDefinitions: iterate over query result>>=
relation foreach domainop $domainops {
    <<generateOpFuncDefinitions: generate operation function>>
}
----

Here we generate the domain operation wrapper function
that is referenced in the domain operation mapping table.
The structure of these functions is to:

. Check the argument count to insure that it is correct.
. Scan the arguments converting them to internal form.
. Invoke the domain operation provided by the domain itself.

[source,tcl]
----
<<generateOpFuncDefinitions: generate operation function>>=
relation assign $domainop

$div puts "static bool ${Domain}_${Operation}__OPFUNC(" ; $div push ; # <1>
$div puts "int argc,"
$div puts "char *const *argv)" ; $div pop
$div puts "{" ; $div push

<<generateOpFuncDefinitions: check argument count>>

relation foreach param $Params -ascending Number {
    <<generateOpFuncDefinitions: scan argument value>>
}

<<generateOpFuncDefinitions: generate operation invocation>>

$div puts "return true ;"
$div pop ; $div puts "}"
----
<1> The wrapper functions all have the same signature.
Naming convention is used to insure uniqueness of the function names.

We know the proper number of arguments to the domain operation since it
is the same as the cardinality of the parameter relation value.

[source,tcl]
----
<<generateOpFuncDefinitions: check argument count>>=
set nparams [relation cardinality $Params]
$div puts "if (argc != $nparams) {" ; $div push
$div puts "bslFormatToContext(CmdContext, wrongNumArgsMsg, argc, $nparams) ;"
$div puts "return false ;"
$div pop ; $div puts "}"
----

Scanning the arguments implies we iterate over the parameters calling
`sscanf()`.
The parameters to `sscanf` are based on the type of the argument.

[source,tcl]
----
<<generateOpFuncDefinitions: scan argument value>>=
relation assign $param {DataType type} {Name paramName} {Number argIndex}
set typeinfo [GetTypeInfo $Domain $type $paramName]
$div puts "[dict get $typeinfo declaration] ;"

set scnfmt [dict get $typeinfo scan]
set varref [dict get $typeinfo varref]
if {$scnfmt ne {}} {
    $div puts "if (sscanf(argv\[$argIndex\], \"%\" $scnfmt,\
	$varref) != 1) {" ; $div push
    $div puts "bslFormatToContext(CmdContext, badParamMsg, argv\[$argIndex\]) ;"
    $div puts "return false ;" ; $div pop
    $div puts "}"
} else {
    $div puts "$paramName = argv\[$argIndex\] ;"
}
----

The domain operation is invoked using the converted argument values.
If there is a return value,
then it must be formatted into a string for the command response.

[source,tcl]
----
<<generateOpFuncDefinitions: generate operation invocation>>=
set invokeParams [pipe {
    relation list $Params Name -ascending Number |
    join ~ {, }
}]
set invocation "${Domain}_${Operation}($invokeParams) ;"

if {$ReturnDataType eq "void"} {
    $div puts $invocation
} else {
    set rettypeinfo [GetTypeInfo $Domain $ReturnDataType result__OP]
    set decl [dict get $rettypeinfo declaration]
    $div puts "$decl = $invocation ;"
    $div puts "bslFormatToContext(CmdContext,\
		\"%\" [dict get $rettypeinfo print], result__OP) ;"
}
----

Many of the wrapper functions generated have the same error messages.
So, we declare them once and use them in the wrappers.

(((chunk,harness static data)))
(((data,wrongNumArgsMsg)))
(((data,badParamMsg)))

[source,c]
----
<<harness static data>>=
static char const wrongNumArgsMsg[] = "wrong # arguments: got %d, expected %d" ;
static char const badParamMsg[] = "bad parameter: \"%s\"" ;
----

==== Generating the operations parameter data

To support querying the name and data type of the operation parameters,
we also need to record that information.

(((chunk,harness data types)))
(((type,BSL_DomainOpParam)))

[source,c]
----
<<harness data types>>=
typedef struct bslopparams {
    char const *name ;          // <1>
    char const *dataType ;      // <2>
} BSL_DomainOpParam ;
----
<1> The name of the domain operation parameter.
<2> The ``C'' data type of the parameter.

The implementation of this procedure follows the established pattern.
We make a query on a populated `micca` platform model and then
use the result to generate ``C'' variables and their initializers.

(((chunk,bosal code template commands)))
(((proc,generateOpParams)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpParams {} {
    set div [diverter new]

    set paramGrps [relation group $::micca::DomainOperationParameter Params\
            Name Number DataType]

    relation foreach paramGrp $paramGrps {
        relation assign $paramGrp

        $div puts "static BSL_DomainOpParam const\
            ${Domain}_${Operation}__OPPARAMS\[] = {"
        $div push

        relation foreach param $Params -ascending Number {
            relation assign $param

            $div puts "{" ; $div push
            $div puts ".name = \"$Name\","
            $div puts ".dataType = \"$DataType\""
            $div pop ; $div puts -nonewline "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the class map [[class-map]]

The class mapping data is more extensive since classes are associated
with many other components.
The following is the structure of the generated data.

(((chunk,harness data types)))
(((type,BSL_ClassMap)))

[source,c]
----
<<harness data types>>=
typedef struct bslclassmap {
    char const *name ;                      // <1>
    MRT_ClassId id ;                        // <2>
    struct bslattrmap const *attrs ;        // <3>
    unsigned attrCount ;                    // <4>
    struct bslinstmap const *insts ;        // <5>
    unsigned instCount ;                    // <6>
    struct bsleventmap const *events ;      // <7>
    unsigned eventCount ;                   // <8>
    struct bslstatemap const *states ;      // <9>
    unsigned stateCount ;                   // <10>
} BSL_ClassMap ;
----
<1> The name of the class.
<2> A numeric ID for the class.
<3> A pointer to an array of attribute descriptions.
<4> The number of elements in the `attrs` array.
<5> A pointer to an array of instance descriptions.
<6> The number of elements in the `insts` array.
<7> A pointer to an array of event descriptions.
<8> The number of elements in the `events` array.
<9> A pointer to an array of state descriptions.
<10> The number elements in the `states` array.

To generate the class mapping data,
we use a set of naming conventions for the variables that
hold each of the components, _e.g._ attributes, instances, etc., and
reference them when generating the initialized array that is the class map.
Although we present the code generation for the class map first,
followed by the code for the generation of the components,
the template is ordered so as to expand the generation of the components
first.
This saves us from having to generate forward references for the
component variables just to satisfy the compiler.

(((chunk,bosal code template commands)))
(((proc,generateClassMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateClassMaps {} {
    set div [diverter new]

    # <1>
    set attrs [pipe {
        relation project $::micca::Attribute Domain Class Name |
        relation rename ~ Name AttrName
    }]
    set insts [relation project $::micca::ClassInstance Domain Class Instance]
    set states [pipe {
        relation project $::micca::StatePlace Domain Model Name |
        relation rename ~ Model Class Name StateName |
        relation restrictwith ~ {$StateName ne "@"}
    }]  ; # <2>
    set events [pipe {
        relation project $::micca::Event Domain Model Event |
        relation rename ~ Model Class Event EventName
    }]

    set domclasses [pipe {
        relation rename $::micca::Class Name Class Number ClassId |
        rvajoin ~ $attrs Attrs |
        rvajoin ~ $insts Insts |
        rvajoin ~ $states States |
        rvajoin ~ $events Events |
        relation group ~ Comps Attrs Insts States Events |
        relation group ~ Classes Class ClassId Comps
    }]  ; # <3>

    relation foreach domclass $domclasses {
        relation assign $domclass
        $div puts "static BSL_ClassMap const ${Domain}__CLASSMAP\[] = {"
        $div push

        relation foreach class $Classes -ascending Class {
            relation assign $class
            relation assign $Comps

            # <4>
            set attrCount [relation cardinality $Attrs]
            set attrMap [expr {$attrCount > 0 ?\
                "${Domain}_${Class}__ATTRMAP" : "NULL"}]

            set instCount [relation cardinality $Insts]
            set instMap [expr {$instCount > 0 ?\
                "${Domain}_${Class}__INSTMAP" : "NULL"}]

            set eventCount [relation cardinality $Events]
            set eventMap [expr {$eventCount > 0 ?\
                "${Domain}_${Class}__EVENTMAP" : "NULL"}]

            set stateCount [relation cardinality $States]
            set stateMap [expr {$stateCount > 0 ?\
                "${Domain}_${Class}__STATEMAP" : "NULL"}]

            # <5>
            $div puts "{" ; $div push
            $div puts ".name = \"$Class\","
            $div puts ".id = $ClassId,"
            $div puts ".attrs = $attrMap,"
            $div puts ".attrCount = $attrCount,"
            $div puts ".insts = $instMap,"
            $div puts ".instCount = $instCount,"
            $div puts ".events = $eventMap,"
            $div puts ".eventCount = $eventCount,"
            $div puts ".states = $stateMap,"
            $div puts ".stateCount = $stateCount,"
            $div pop ; $div puts -nonewline "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----
<1> We start by projecting out only the attributes of the components
of the class that we need.
Sometimes attributes also need to be renamed to make the join operations
easier to specify.
<2> We remove any pseudo-initial states from the states of a class since
that state is always transitory and used internally for asychronous
instance creation.
<3> This series of `rvajoin` invocations creates a relation valued
attribute for each of the components in which we are interested.
With some grouping,
we can obtain the classes for a domain with the class components
in a convenient attribute form.
<4> Having built up relation valued attributes for each of the
class components we are interested in,
we visit each component to determine any subordinate mappings.
<5> Having all the required information in variables,
we can now generate the ``C'' code to initialize the array member.

==== Generating the attribute map

The required mapping for a class attribute maps the attribute id value
to a pair of functions, one for reading the attribute and one for
writing the attribute.
The following data structure declarations define the interface to the
attribute access functions.

(((chunk,harness data types)))
(((type,BSL_AttrMap)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_AttrReadFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId) ;
typedef bool BSL_AttrUpdateFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId, char const *) ;

typedef struct bslattrmap {
    char const *name ;                  // <1>
    MRT_AttrId id ;                     // <2>
    BSL_AttrReadFunc *readFunc ;        // <3>
    BSL_AttrUpdateFunc *updateFunc ;    // <4>
} BSL_AttrMap ;
----
<1> The name of the attribute.
<2> A numerical identifier for the attribute.
<3> A pointer to a function to read the attribute value.
<4> A pointer to a function to update the attribute value.

(((chunk,bosal code template commands)))
(((proc,generateAttrMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrMaps {} {
    set div [diverter new]

    set attrGrps [pipe {
        relation project $::micca::Attribute Domain Class Name |
        relation group ~ Attrs Name
    }]

    relation foreach attrGrp $attrGrps {
        relation assign $attrGrp
        $div puts "static BSL_AttrMap const ${Domain}_${Class}__ATTRMAP\[] = {"
        $div push

        set attrNum -1
        relation foreach attr $Attrs -ascending Name {
            relation assign $attr
            $div puts "{" ; $div push

            $div puts ".name = \"$Name\","
            $div puts ".id = [incr attrNum],"
            $div puts ".readFunc = ${Domain}_${Class}_${Name}__RD,"
            $div puts ".updateFunc = ${Domain}_${Class}_${Name}__UP"

            $div pop ; $div puts -nonewline "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the attribute read functions

For the attribute read functions,
we will need forward declarations for the function signatures.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateAttrFuncDeclarations%>
----

Note that we simply place the embedded macro command that generates the
forward declarations into the appropriate literate program chunk.
We use this technique in other situations that follow.
Also note that we have combined the forward declaration for the
read and update functions.
Both use the same information from the `micca` model and
forward declarations are not order dependent.

(((chunk,bosal code template commands)))
(((proc,generateAttrFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrFuncDeclarations {} {
    set div [diverter new]

    relation foreach attr $::micca::Attribute {
        relation assign $attr Domain Class Name
        $div puts "static bool\
            ${Domain}_${Class}_${Name}__RD(MRT_DomainPortal const *,\
            MRT_ClassId, MRT_InstId, MRT_AttrId) ;"
        $div puts "static bool\
            ${Domain}_${Class}_${Name}__UP(MRT_DomainPortal const *,\
            MRT_ClassId, MRT_InstId, MRT_AttrId, char const *) ;"
    }

    $div return
}
----

The attribute read function is just an ordinary function at file static
scope.

(((chunk,harness static function definitions)))

[source,c]
----
<<harness static function definitions>>=
<%generateAttrReadFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrReadFuncsDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrReadFuncDefinitions {} {
    set div [diverter new]

    relation foreach attr $::micca::Attribute {
        relation assign $attr Domain Class Name DataType

        $div puts "static bool ${Domain}_${Class}_${Name}__RD(" ; $div push
        $div puts "MRT_DomainPortal const *portal,"
        $div puts "MRT_ClassId classId,"
        $div puts "MRT_InstId instId,"
        $div puts "MRT_AttrId attrId)" ; $div pop

        $div puts "{" ; $div push

        set typeinfo [GetTypeInfo $Domain $DataType attrValue]
        set attrVar [dict get $typeinfo declaration]

        $div puts "$attrVar ;"

        set pAttrVar [dict get $typeinfo varref]

        $div puts "int pcode = mrt_PortalReadAttr(portal, classId, instId,\
                attrId, $pAttrVar, sizeof(attrValue)) ;"
        $div puts "if (pcode < 0) {" ; $div push
        $div puts "bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        set varType [dict get $typeinfo type]
        set prifmt [dict get $typeinfo print]
        switch -exact -- $varType {
            scalar {
                $div puts "bslFormatToContext(CmdContext, \"%\" $prifmt, attrValue) ;"
            }
            string {
                $div puts "bslFormatToContext(CmdContext, \"%\" $prifmt, attrValue) ;"
            }
            array {
                set dim [dict get $typeinfo dimension]
                $div puts "for (int index = 0 ; $index < $dim ; index++) {"
                $div push
                $div puts "bslFormatToContext(CmdContext, \"%\" $prifmt \" \",\
                        attrValue\[index]) ;"
                $div pop ; $div puts "}"
            }
            default {
                error "unknown variable type, $varType"
            }
        }

        $div puts "return true ;"

        $div pop ; $div puts "}"
    }

    $div return
}
----

==== Generating the attribute update functions

The generation of the attribute update functions follows the same
pattern as for the attribute read functions.

(((chunk,harness static function definitions)))

[source,c]
----
<<harness static function definitions>>=
<%generateAttrUpdateFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrUpdateFuncsDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrUpdateFuncDefinitions {} {
    set div [diverter new]

    relation foreach attr $::micca::Attribute {
        relation assign $attr Domain Class Name DataType

        $div puts "static bool ${Domain}_${Class}_${Name}__UP(" ; $div push
        $div puts "MRT_DomainPortal const *portal,"
        $div puts "MRT_ClassId classId,"
        $div puts "MRT_InstId instId,"
        $div puts "MRT_AttrId attrId,"
        $div puts "char const *value)" ; $div pop

        $div puts "{" ; $div push

        $div puts "int pcode ;"
        set typeinfo [GetTypeInfo $Domain $DataType convertedValue]
        switch -exact -- [dict get $typeinfo type] {
            scalar {
                $div puts "[dict get $typeinfo declaration] ;"
                set cvtRef [dict get $typeinfo varref]

                if {[dict get $typeinfo basetype] eq "bool"} {
                    $div puts "int nitems = bslScanBoolean(value, $cvtRef) ;"
                    set scnfmt \"bool\"
                } else {
                    set scnfmt [dict get $typeinfo scan]
                    $div puts "int nitems = sscanf(value, \"%\" $scnfmt,\
                            $cvtRef) ;"
                }
                $div puts "if (nitems == 1) {" ; $div push
                $div puts "pcode = mrt_PortalUpdateAttr(portal, classId,\
                    instId, attrId, $cvtRef, sizeof(convertedValue)) ;"
                $div pop ; $div puts "} else {" ; $div push
                $div puts "bslFormatToContext(CmdContext, failedConvertMsg,\
                        value, $scnfmt) ;"
                $div puts "return false ;"
                $div pop ; $div puts "}"
            }
            string {
                $div puts "pcode = mrt_PortalUpdateAttr(portal, classId,\
                    instId, attrId, value, strlen(value) + 1) ;"
            }
            array {
                $div puts "bslFormatToContext(CmdContext,
                    \"unable to update array attributes\") ;"
            }
        }

        $div puts "if (pcode < 0) {" ; $div push
        $div puts "bslFormatToContext(CmdContext, mrt_PortalErrorString(pcode)) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        $div puts "return true ;"

        $div pop ; $div puts "}"
    }

    $div return
}
----

(((chunk,harness static data)))
(((data,failedConvertMsg)))

[source,c]
----
<<harness static data>>=
static char const failedConvertMsg[] = "failed to convert, \"%s\" as \"%s\"" ;
----

==== Generating the instance map

The instance mapping is from an instance name to an instance ID.
Note that only initial instances have a name.

(((chunk,harness data types)))
(((type,BSL_InstMap)))

[source,c]
----
<<harness data types>>=
typedef struct bslinstmap {
    char const *name ;
    MRT_InstId id ;
} BSL_InstMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateInstMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateInstMaps {} {
    set div [diverter new]

    set instGrps [relation group $::micca::ClassInstance Insts Instance Number]

    relation foreach instGrp $instGrps {
        relation assign $instGrp {Domain domainName} {Class className} Insts

        $div puts "static BSL_InstMap const\
                ${domainName}_${className}__INSTMAP\[] = {"
        $div push

        relation foreach inst $Insts -ascending Instance {
            relation assign $inst {Instance instName} {Number instNum}
            $div puts "{" ; $div push

            $div puts ".name = \"$instName\","
            $div puts ".id = $instNum,"

            $div pop ; $div puts -nonewline "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the event map

The event mapping data maps the event name to an event number.
The additional complication is that some events carry supplimental
argument data.
For those cases,
a function is generated to convert the event argument data to internal form
and additional descriptive data is generated to support querying
the event parameters.

(((chunk,harness data types)))
(((type,BSL_EventMap)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_EventParamFunc(int, char * const*, MRT_EventParams) ;

typedef struct bsleventmap {
    char const *name ;
    MRT_EventCode number ;
    BSL_EventParamFunc *paramFunc ;
    struct bsleventparams const *params ;
    size_t paramCount ;
} BSL_EventMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateEventMaps)))

One complication here is that we must deal with polymorphic events
and assigner events.
We do _not_ allow access to assigner events, so they must be excluded.
However, we do allow polymorphic events so they can be signaled to
superclasses.
However, a superclass is not required to have a state model.
Polymorphic events do not affect any state model that the superclass
may have.
So our query for which events to generate mappings is slightly more
complicated.
We must start at instance state models (to eliminate the assigners)
to find any events those state models may have.
Also we must start at superclasses and find all the deferred events
they may be related to and these will be polymorphic events for
those superclasses (either inherited or directly defined).
The union is then the set of events for which we are interested in generating
maps.
Since we need this set of events in several places,
we create a helper function to do the query.

(((procedure,GetMappedEvents)))

[source,tcl]
----
<<bosal helper commands>>=
proc GetMappedEvents {} {
    set instevents [pipe {
        InstanceStateModel findAll |
        findRelated % R50 ~R87 R80 |
        deRef %
    } {} |%]

    set defevents [pipe {
        Superclass findAll |
        findRelated ~ R86 R80 |
        deRef ~
    }]

    return [relation union $instevents $defevents]
}
----

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventMaps {} {
    set div [diverter new]

    set params [relation project $::micca::Parameter Domain PSigID Name]

    set eventGrps [pipe {
        GetMappedEvents |
        rvajoin ~ $params Params |
        relation eliminate ~ PSigID |
        relation group ~ Events Event Number Params
    }]
    # puts [relformat $eventGrps eventGrps]

    relation foreach eventGrp $eventGrps {
        relation assign $eventGrp

        $div puts "static BSL_EventMap const ${Domain}_${Model}__EVENTMAP\[] = {"
        $div push

        relation foreach event $Events -ascending Event {
            relation assign $event
            set nparams [relation cardinality $Params]
            if {$nparams > 0} {
                set paramStore ${Domain}_${Model}_${Event}__EVPARAM
                set paramFunc ${Domain}_${Model}_${Event}__EPFUNC
            } else {
                set paramStore NULL
                set paramFunc NULL
            }

            $div puts "{" ; $div push

            $div puts ".name = \"$Event\","
            $div puts ".number = $Number,"
            $div puts ".paramFunc = $paramFunc,"
            $div puts ".params = $paramStore,"
            $div puts ".paramCount = $nparams"

            $div pop ; $div puts -nonewline "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the event parameter functions

Following a similar pattern as attribute read and update functions,
we generate event parameter functions.
This include forward declarations and the conversion functions themselves.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateEventParamFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateEventParamFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventParamFuncDeclarations {} {
    set div [diverter new]

    set events [pipe {
        GetMappedEvents |
        relation restrictwith ~ {$PSigID ne {}}
    }]
    # puts [relformat $events events]

    relation foreach event $events {
        relation assign $event {Domain domainName} {Model className}\
            {Event eventName}
        $div puts "static bool\
            ${domainName}_${className}_${eventName}__EPFUNC(\
            int, char * const*, MRT_EventParams) ;"
    }

    $div return
}
----

To generate the functions used to convert the event parameter values
to the internal representation,
we must include data type information in what we retrieve about
the event parameters.

(((chunk,harness static function definitions)))

[source,c]
----
<<harness static function definitions>>=
<%generateEventParamFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateEventParamFuncDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventParamFuncDefinitions {} {
    set div [diverter new]

    set paramtypes [pipe {
        relation join $::micca::Parameter $::micca::Argument |
        relation eliminate ~ ASigID
    }]

    set paramevents [pipe {
        GetMappedEvents |
        rvajoin ~ $paramtypes Params |
        relation eliminate ~ PSigID |
        relation restrictwith ~ {[relation isnotempty $Params]}
    }]
    # puts [relformat $paramevents paramevents]

    relation foreach paramevent $paramevents {
        relation assign $paramevent

        $div puts "static bool ${Domain}_${Model}_${Event}__EPFUNC(" ; $div push
        $div puts "int paramc,"
        $div puts "char * const *paramv,"
        $div puts "MRT_EventParams parambuf)" ; $div pop

        $div puts "{" ; $div push


        set nparams [relation cardinality $Params]
        $div puts "if (paramc != $nparams) {" ; $div push
        $div puts "bslFormatToContext(CmdContext, wrongNumArgsMsg, paramc,\
                $nparams) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        set structName ${Domain}_${Model}_${Event}__EPARAMS
        $div puts "struct $structName *params =\
                (struct $structName *)parambuf ;"

        set nitemsDefined false
        relation foreach param $Params -ascending Position {
            relation assign $param

            set typeinfo [GetTypeInfo $Domain $DataType params->$Name]
            set scnfmt [dict get $typeinfo scan]
            if {$scnfmt eq {}} {
                $div puts "params->$Name = paramv\[$Position\] ;"
            } else {
                if {!$nitemsDefined} {
                    $div puts "int nitems ;"
                    set nitemsDefined true
                }
                set reftovar [dict get $typeinfo varref]
                if {[dict get $typeinfo basetype] eq "bool"} {
                    $div puts "nitems = bslScanBoolean(paramv\[$Position\],\
                            $reftovar) ;"
                    set scnfmt \"bool\"
                } else {
                    $div puts "nitems = sscanf(paramv\[$Position\],\
                        \"%\" $scnfmt, $reftovar) ;"
                }
                $div puts "if (nitems != 1) {" ; $div push
                $div puts "bslFormatToContext(CmdContext, failedConvertMsg,\
                        paramv\[$Position\], $scnfmt) ;"
                $div puts "return false ;"
                $div pop ; $div puts "}"
            }
        }

        $div puts "return true ;"
        $div pop ; $div puts "}"
    }

    $div return
}
----

==== Generating the event parameter descriptions

The event parameter mapping maps an event name to its corresponding
``C'' data type.

(((chunk,harness data types)))
(((type,BSL_EventParam)))

[source,c]
----
<<harness data types>>=
typedef struct bsleventparams {
    char const *name ;          // <1>
    char const *dataType ;      // <2>
} BSL_EventParam ;
----
<1> The name of the event.
<2> The ``C'' data type of the event.

(((chunk,bosal code template commands)))
(((proc,generateEventParams)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventParams {} {
    set div [diverter new]

    set params [pipe {
        relation join $::micca::Parameter $::micca::Argument |
        relation eliminate ~ ASigID
    }]

    set paramevents [pipe {
        GetMappedEvents |
        relation eliminate ~ Number |
        rvajoin ~ $params Params |
        relation eliminate ~ PSigID |
        relation restrictwith ~ {[relation isnotempty $Params]}
    }]
    # puts [relformat $paramevents paramevents]

    relation foreach paramevent $paramevents {
        relation assign $paramevent

        $div puts "static BSL_EventParam const\
            ${Domain}_${Model}_${Event}__EVPARAM\[] = {"
        $div push

        relation foreach param $Params -ascending Position {
            relation assign $param Name DataType

            $div puts "{" ; $div push
            $div puts ".name = \"$Name\","
            $div puts ".dataType = \"$DataType\""
            $div pop ; $div puts -nonewline "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generate the state map

A state map gives the correspondence between the name of a state and
its internal state number.

(((chunk,harness data types)))
(((type,BSL_StateMap)))

[source,c]
----
<<harness data types>>=
typedef struct bslstatemap {
    char const *name ;          // <1>
    MRT_StateCode number ;      // <2>
} BSL_StateMap ;
----
<1> The name of the state.
<2> The internal ID number of the state.

(((chunk,bosal code template commands)))
(((proc,generateStateMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateStateMaps {} {
    set div [diverter new]

    set stateGrps [pipe {
        InstanceStateModel findAll |
        findRelated % R50 ~R55 R57 |
        deRef % |
        relation restrictwith % {$Name ne "@"} |
        relation group % States Name Number
    } {} |%]

    relation foreach stateGrp $stateGrps {
        relation assign $stateGrp

        $div puts "static BSL_StateMap const ${Domain}_${Model}__STATEMAP\[] = {"
        $div push

        relation foreach state $States -ascending Name {
            relation assign $state

            $div puts "{" ; $div push
            $div puts ".name = \"$Name\","
            $div puts ".number = $Number,"
            $div pop ; $div puts -nonewline "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

== Bosal header file

We must also be prepared to generate a header file for the harness
that contains the interface information for the `bosal` external
functions.
This file must be included in the compilation unit that contains
the `main()` function at the least.
The `bosal` program accepts an option to create this header file.

(((chunk,bosal data)))
(((data.headerFile)))

[source,tcl]
----
<<bosal data>>=
variable headerFile [textutil::adjust::undent {
/*
<<edit warning>>
<<copyright info>>
*/
/*
 * This file is the header file for bosal. A typical use case is to
 * include it in the file which contains the "main" function. This
 * file corresponds to bosal version:
   <<version info>>
 */

#ifndef BOSAL_H_
#define BOSAL_H_

#define BOSAL_VERSION\
<<version info>>

#include <stdarg.h>

/*
 * External Functions
 */
<<harness external function declarations>>

#endif /* BOSAL_H_ */}]
----
