// vim:set syntax=asciidoc:

== Domain independent code

Much of the test harness code is independent of the specifics of any
domain in the harness.
One alternative design is to place the domain independent code in
a separate file and compile that code into a library.
Here,
we have decided to put both domain independent and domain dependent code
into the same file.
This design reduces any dependency between an external libray code file and
different versions of `bosal`.
Since the amount of domain independent code is relatively small,
removing external dependencies was deemed beneficial.

=== Running the harness

Normally,
systems build from `micca` domains are run by invoking the
`mrt_EventLoop()` run-time function.
This function manages all the state machine dispatch and execution
sequencing.
When running in a test harness,
we want more control over the execution sequencing and must perform
other initialization before allowing the domains to run.
Consequently,
test harness code is run by invoking `bsl_Run()`.

(((chunk,harness external function declarations)))
(((function,bsl_Run)))

*******
[source,c]
----
<<harness external function declarations>>=
extern void bsl_Run(void) ;
----

Invoking `bsl_Run()` initializes and runs a `bosal` generated
test harness.
Before invoking this function,
it is necessary to invoke `mrt_Initialize()`.
*******

The implementation of `bsl_Run` is as you might expect.
It is an infinte loop that replaces the micca run-time event loop.

(((chunk,harness external function definitions)))
(((function,bsl_Run)))

[source,c]
----
<<harness external function definitions>>=
void
bsl_Run(void)
{
    if (!bslInitialize()) {                                         // <1>
        return ;
    }

    mrt_SetFatalErrorHandler(bslErrorHandler) ;                     // <2>

    for (bslHarnessState = bslRunning ; ;) {
        if (setjmp(bslFatalBuf) == 0) {                             // <3>
            mrt_EventLoop() ;                                       // <4>
        }

        for (bslHarnessState = bslHalted ; bslHarnessState == bslHalted ;) {
            bslReadAndEvalCommand(0) ;                              // <5>
        }
    }
}
----
<1> First, we must initialize the test harness infrastructure.
<2> The default error handler for the `micca` run-time will
invoke `abort()` when an error occurs.
This would cause the test harness to stop.
We want more control so we can see transitions and probe
the cause of an error.
<3> The test harness error handler uses `setjmp/longjmp` to transfer
control back to here if a fatal error occurs.
<4> It is still `mrt_EventLoop` that causes everything to run.
`mrt_EventLoop` will return if any action in the domain invokes
`mrt_SyncToEventLoop` or if the harness error handler is invoked
as a result of a fatal error.
In either case,
we consider the state of the event loop as halted.
<5> Once the event loop is halted,
we still need to read and evaluate test harness commands off the communications
link so that an external program can interact with the harness.

The harness keeps track of whether or not it is in the `micca` run-time
event loop and uses a variable to track that state.

(((chunk,harness static data)))
(((data,bslHarnessState)))

[source,c]
----
<<harness static data>>=
static enum {
    bslHalted,
    bslRunning,
} bslHarnessState ;
----

=== Handling fatal system errors

The `micca` run-time code diagnoses several fatal system errors.
These are essential ``panic'' conditions and, by default,
invokes `abort()` to terminate the process.
We need to do better than that in a test harness since we might want to
inquire and probe to determine the circumstances of the failure.
Fortunately, we can install our own error handler to prevent the
harness from terminating.

(((chunk,harness forward function declarations)))
(((function,bslErrorHandler)))

*****
[source,c]
----
<<harness forward function declarations>>=
static void
bslErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list alist) ;
----

The error handler arguments are dictated by the `micca` run-time.

errNum:: a number indicating the cause of the error.
fmt:: a `printf` style format string.
alist:: a variable length argument list for the items in the `fmt` string.
*****

(((chunk,harness static functions)))
(((function,bslErrorHandler)))

[source,c]
----
<<harness static functions>>=
static void
bslErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list alist)
{
    bslBeginResponse() ;
    bslAddWord("fatal") ;
    bslPushContext() ;
    bslVformatToContext(fmt, alist) ;
    bslPopContext() ;
    bslEndResponse() ;

    longjmp(bslFatalBuf, 1) ;                           // <1>
}
----
<1> This transfers control back to `bsl_Run`.

(((chunk,harness static data)))
(((data,bslFatalBuf)))

The `setjmp/longjmp` combination that performs the non-local goto needs
a variable to hold the context.

[source,c]
----
<<harness static data>>=
static jmp_buf bslFatalBuf ;
----

=== Harness initialization

The `bslInitialize` function sets up the communications and command
infrastructure for the test harness.
Most of the initialization work is involved in setting up the
TCP / IP communications socket.

(((chunk,harness forward function declarations)))
(((function,bslInitialize)))

[source,c]
----
<<harness forward function declarations>>=
static bool
bslInitialize(void) ;
----

(((chunk,harness static functions)))
(((function,bslInitialize)))

[source,c]
----
<<harness static functions>>=
static bool
bslInitialize(void)
{
    <<bslInitialize: create socket>>
    <<bslInitialize: bind socket>>
    <<bslInitialize: listen on socket>>
    <<bslInitialize: register signals>>

    // start with tracing off
    bslDefaultTraceHandler = mrt_RegisterTraceHandler(NULL) ;

    return true ;
}
----

Setting up the communications socket is standard POSIX systems
programming.

(((chunk,bslInitialize: create socket)))

[source,c]
----
<<bslInitialize: create socket>>=
bslServiceSock = socket(AF_INET, SOCK_STREAM, 0) ;
if (bslServiceSock == -1) {
    perror("unable to obtain AF_INET stream socket") ;
    return false ;
}
----

[source,c]
----
<<harness static data>>=
static int bslServiceSock = -1 ;
----

The socket will ultimately be used to listen for connections,
so we must bind to a port that clients will know.

(((chunk,bslInitialize: bind socket)))

[source,c]
----
<<bslInitialize: bind socket>>=
struct sockaddr_in hsrvAddr ;
memset(&hsrvAddr, 0, sizeof(hsrvAddr)) ;
#       ifdef __APPLE__
hsrvAddr.sin_len = sizeof(hsrvAddr) ;
#       endif /* __APPLE__ */
hsrvAddr.sin_family = AF_INET ;
hsrvAddr.sin_port = htons(HARNESS_PORT) ;

static char const host[] = "localhost" ;
struct hostent *hostAddr = gethostbyname(host) ;
if (hostAddr == NULL) {
    perror(host) ;
    return false ;
}
assert(hostAddr->h_addrtype == AF_INET) ;
memcpy(&hsrvAddr.sin_addr, hostAddr->h_addr_list[0], hostAddr->h_length) ;

int err = bind(bslServiceSock, (struct sockaddr const *)&hsrvAddr,
        sizeof(hsrvAddr)) ;
if (err == -1) {
    perror("bind()") ;
    return false ;
}
----

In addition to listening on the socket,
we register the file descriptor with the `micca` run-time.
The POSIX version of the `micca` run-time will perform callbacks
when file descriptors change state.

(((chunk,bslInitialize: listen on socket)))

[source,c]
----
<<bslInitialize: listen on socket>>=
mrt_RegisterFDService(bslServiceSock, bslAcceptConnection, NULL, NULL) ;
err = listen(bslServiceSock, 1) ;
if (err == -1) {
    perror("listen()") ;
    return false ;
}
----

We also want to handle the usual signals that indicate the harness
should be shut down.
Again the `micca` run-time for POSIX supplies functions to interface
signals to the event loop and obtain a callback when the signal
occurs.

(((chunk,bslInitialize: register signals)))

[source,c]
----
<<bslInitialize: register signals>>=
mrt_RegisterSignal(SIGQUIT, bslExitOnSignal) ;
mrt_RegisterSignal(SIGINT, bslExitOnSignal) ;
mrt_RegisterSignal(SIGTERM, bslExitOnSignal) ;
----

The `micca` run-time has a default trace handler
and we want to store that away when it is replaced by the
harness specific trace handler.

(((chunk,harness static data)))
(((data,bslDefaultTraceHandler)))

[source,c]
----
<<harness static data>>=
void (*bslDefaultTraceHandler)(MRT_TraceInfo const *traceInfo) ;
----

=== Accepting service connections

When a connection attempt occurs on the test harness socket,
control is transferred by the event loop to the `bslAcceptConnection`
function.

(((chunk,harness forward function declarations)))
(((function,bslAcceptConnection)))

[source,c]
----
<<harness forward function declarations>>=
static void bslAcceptConnection(int sock) ;
----

The implementation is a bit different than is usually used for a server
program.
First, a test harness is run for only a single session.
It does *not* service multiple clients, so the passive listening
socket is closed after the client connection is accepted.
Once the client connection is established,
it is also registered with the `micca` run-time to receive commands.

(((chunk,harness static functions)))
(((function,bslAcceptConnection)))

[source,c]
----
<<harness static functions>>=
static void
bslAcceptConnection(
    int sock)
{
    int fd = accept(sock, NULL, 0) ;

    int err = shutdown(bslServiceSock, SHUT_RDWR) ;
    if (err == -1) {
        perror("shutdown()") ;
        exit(EXIT_FAILURE) ;
    }
    mrt_UnregisterFDService(sock, true, false, false) ;
    bslServiceSock = -1 ;

    if (fd == -1) {
        perror("accept()") ;
        exit(EXIT_FAILURE) ;
    }

    mrt_RegisterFDService(fd, bslReadAndEvalCommand, NULL, NULL) ;
    bslCmdStream = fdopen(fd, "w+") ;                               // <1>
    err = setvbuf(bslCmdStream, NULL, _IOLBF, 0) ;                  // <2>
}
----
<1> It is easiest just to deal with the communications connection
as a standard stream.
<2> We want line buffering so that the response is sent on an ASCII record
basis.

The command stream is stored in a file scoped variable so that the
I/O functions can just use it directly.
Only handling a single client makes all this much simpler.

(((chunk,harness static data)))
(((data,bslCmdStream)))

[source,c]
----
<<harness static data>>=
static FILE *bslCmdStream ;
----

=== Evaluating command input

(((chunk,harness forward function declarations)))
(((function,bslReadAndEval)))

[source,c]
----
<<harness forward function declarations>>=
static void bslReadAndEvalCommand(int rfd) ;
----

(((chunk,harness static functions)))
(((function,bslReadAndEvalCommand)))

[source,c]
----
<<harness static functions>>=
static void
bslReadAndEvalCommand(
    int rfd)
{
    static char cmdBuffer[BUFSIZ] ;

    char *cmd = fgets(cmdBuffer, sizeof(cmdBuffer), bslCmdStream) ;
    if (cmd == NULL) {
        if (feof(bslCmdStream)) {
            dbgprintf("goodbye\n") ;
            bslClose() ;
            exit(EXIT_SUCCESS) ;
        } else if (ferror(bslCmdStream)) {
            if (errno == EINTR) {
                clearerr(bslCmdStream) ;
                return ;
            }
            perror("fgets()") ;
            bslClose() ;
            exit(EXIT_FAILURE) ;
        } else {
            printf("partial\n") ;
            return ;
        }
    }
    bslTrimSpaceRight(cmdBuffer) ;
    dbgprintf("%s\n", cmdBuffer) ;

    int argc = 0 ;
    char *const *argv = NULL ;
    static char parseBuffer[BUFSIZ] ;
    strcpy(parseBuffer, cmdBuffer) ;

    bslBeginResponse() ;
    bslAddWord("cmd") ;
    bslPushContext() ;

    int err = bslParseCommand(parseBuffer, &argc, &argv) ;
    if (err == -1) {
        bslAddWord("name") ;
        bslAddWord("unknown") ;
        bslAddWord("return") ;
        bslAddWord("error") ;
        bslPushContext() ;
        bslFormatToContext("failed to parse command: \"%s\"", cmdBuffer) ;
        bslPopContext() ;
    } else if (argc != 0) {
        bslExecCommand(argc, argv) ;
    } else {
        return ;
    }

    bslPopContext() ;
    bslEndResponse() ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslExitOnSignal)))

[source,c]
----
<<harness forward function declarations>>=
static void bslExitOnSignal(int signal) ;
----

(((chunk,harness static functions)))
(((function,bslExitOnSignal)))

[source,c]
----
<<harness static functions>>=
static void
bslExitOnSignal(
    int signal)
{
    dbgprintf("caught signal %d\n", signal) ;
    bslClose() ;
    exit(EXIT_SUCCESS) ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClose)))

[source,c]
----
<<harness forward function declarations>>=
static void bslClose(void) ;
----

(((chunk,harness static functions)))
(((function,bslClose)))

[source,c]
----
<<harness static functions>>=
static void
bslClose(void)
{
    if (bslServiceSock != -1) {
        shutdown(bslServiceSock, SHUT_RDWR) ;
        bslServiceSock = -1 ;
    }
    if (bslCmdStream != NULL) {
        mrt_UnregisterFDService(fileno(bslCmdStream), true, false, false) ;
        fclose(bslCmdStream) ;
    }
}
----

=== Harness instrumentation

(((chunk,harness external function declarations)))
(((function,bsl_Vprintf)))

[source,c]
----
<<harness external function declarations>>=
extern int bsl_Vprintf(char const *format, va_list args) ;
----

(((chunk,harness external function definitions)))
(((function,bsl_Vprintf)))

[source,c]
----
<<harness external function definitions>>=
int
bsl_Vprintf(
    char const *format,
    va_list args)
{
    if (!instrOn || bslCmdStream == NULL) {
        return 0 ;
    }

    static char resultBuf[BUFSIZ] ;
    int n = vsnprintf(resultBuf, sizeof(resultBuf), format, args) ;

    if (n < 0) {
        strncpy(resultBuf, "error formating response", sizeof(resultBuf)) ;
    } else if (n >= sizeof(resultBuf)) {
        strncpy(resultBuf, "instrumentation output truncated",
            sizeof(resultBuf)) ;
    } else {
        // trim off any whitespace
        bslTrimSpaceRight(resultBuf) ;
    }

    return fprintf(bslCmdStream, "instr {%s}\n", resultBuf) ;
}
----

(((chunk,harness external function declarations)))
(((function,bsl_Printf)))

[source,c]
----
<<harness external function declarations>>=
extern int bsl_Printf(char const *format, ...) ;
----

(((chunk,harness external function definitions)))
(((function,bsl_Printf)))

[source,c]
----
<<harness external function definitions>>=
int
bsl_Printf(
    char const *format,
    ...)
{
    va_list args ;

    va_start(args, format) ;
    int n = bsl_Vprintf(format, args) ;
    va_end(args) ;

    return n ;
}
----

=== Parsing harness commands

(((chunk,harness forward function declarations)))
(((function,bslParseCommand)))

[source,c]
----
<<harness forward function declarations>>=
static int bslParseCommand(char *line, int *pargc, char *const **pargv) ;
----

(((chunk,harness static functions)))
(((function,bslParseCommand)))

[source,c]
----
<<harness static functions>>=
static int
bslParseCommand(
    char *line,
    int *pargc,
    char *const **pargv)
{
    #define MAX_ARGS    64
    static char *args[MAX_ARGS] ;

    char **pArgv = args ;
    char **const argvEnd = pArgv + MAX_ARGS ;

    int quoteCount = 0 ;
    int parseState = OUTOFWORD ;
    int parseStackStorage[2] ;
    int *parseStackTop = parseStackStorage ;

    char *pWord = line ;
    for ( ; *line != ASCII_NUL ; line++) {
        char c = *line ;
        switch (parseState) {
        case OUTOFWORD:
            if (isgraph(c)) {
                if (c == ESCAPE_CHAR) {
                    *parseStackTop++ = INWORD ;
                    parseState = INESCAPE ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else if (c == BEGIN_QUOTE) {
                    *parseStackTop++ = OUTOFWORD ;
                    parseState = INQUOTE ;
                    ++quoteCount ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else {
                    // new word beginning
                    if (pArgv < argvEnd) {
                        *pArgv++ = pWord ;
                    } else {
                        fprintf(stderr, "exceeded max arguments") ;
                        return -1 ;
                    }
                    *pWord++ = c ;
                    parseState = INWORD ;
                }
            } // else the character is just space to skip
            break ;

        case INWORD:
            if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = INESCAPE ;
            } else if (c == BEGIN_QUOTE) {
                *parseStackTop++ = parseState ;
                parseState = INQUOTE ;
                ++quoteCount ;
            } else if (isspace(c)) {
                // end of word
                parseState = OUTOFWORD ;
                *pWord++ = ASCII_NUL ;
            } else {
                *pWord++ = c ;
            }
            break ;

        case INESCAPE:
            switch (c) {
                case 'a':
                    *pWord++ = '\a' ;
                    break ;
                case 'b':
                    *pWord++ = '\b' ;
                    break ;
                case 't':
                    *pWord++ = '\t' ;
                    break ;
                case 'n':
                    *pWord++ = '\n' ;
                    break ;
                case 'v':
                    *pWord++ = '\v' ;
                    break ;
                case 'f':
                    *pWord++ = '\f' ;
                    break ;
                case 'r':
                    *pWord++ = '\r' ;
                    break ;
                default:
                    *pWord++ = c ;
                    break ;
            }
            parseState = *--parseStackTop ;
            break ;

        case INQUOTE:
            if (c == BEGIN_QUOTE) {
                ++quoteCount ;
                *pWord++ = c ;
            } else if (c == END_QUOTE) {
                if (--quoteCount == 0) {
                    parseState = *--parseStackTop ;
                    // check if ending the quote also ended the word
                    if (parseState == OUTOFWORD) {
                        *pWord++ = ASCII_NUL ;
                    }
                } else {
                    *pWord++ = c ;
                }
            } else if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = INESCAPE ;
            } else {
                *pWord++ = c ;
            }
            break ;
        }
    }

    *pWord = ASCII_NUL ;
    *pArgv = NULL ;
    if (quoteCount == 0 && parseState != INESCAPE) {
        if (pargc) {
            *pargc = pArgv - args ;
        }
        if (pargv) {
            *pargv = args ;
        }
        return 0 ;
    } else {
        return -1 ;
    }
}
----

=== Executing harness commands

(((chunk,harness forward function declarations)))
(((function,bslExecCommand)))

[source,c]
----
<<harness forward function declarations>>=
static void bslExecCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslExecCommand)))

[source,c]
----
<<harness static functions>>=
static void
bslExecCommand(
    int argc,
    char *const *argv)
{
    BSL_CommandMap key = {
        .name = argv[0],
        .commandFunc = NULL
    } ;

    BSL_CommandMap const *cmd =
            bsearch(&key, commands, COUNTOF(commands), sizeof(commands[0]),
            bslCommandMapCompare) ;

    bslAddWord("name") ;
    bslAddWord(argv[0]) ;
    bslAddWord("result") ;
    bslPushContext() ;

    bool success ;
    if (cmd != NULL) {
        assert(cmd->commandFunc != NULL) ;
        success = cmd->commandFunc(argc, argv) ;
    } else {
        bslFormatToContext("unknown command, \"%s\"", argv[0]) ;
        success = false ;
    }

    bslPopContext() ;
    bslAddWord("code") ;
    bslAddWord(success ? "ok" : "error") ;
}
----

[source,c]
----
<<harness data types>>=
typedef bool BSL_CommandFunc(int, char * const*) ;

typedef struct bslcommandmap {
    char const *name ;
    BSL_CommandFunc *commandFunc ;
} BSL_CommandMap ;
----

(((chunk,harness forward function declarations)))
(((function,bslCommandMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslCommandMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslCommandMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslCommandMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_CommandMap const *cm1 = m1 ;
    BSL_CommandMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

(((chunk,harness static data)))
(((data.commands)))

[source,c]
----
<<harness static data>>=
static BSL_CommandMap const commands[] = { // must be in ascending "name" order
    {
        .name = "cancel",
        .commandFunc = bslCancelCommand
    },
    {
        .name = "create",
        .commandFunc = bslCreateCommand
    },
    {
        .name = "createasync",
        .commandFunc = bslCreateAsyncCommand
    },
    {
        .name = "delaysignal",
        .commandFunc = bslDelaySignalCommand
    },
    {
        .name = "delete",
        .commandFunc = bslDeleteCommand
    },
    {
        .name = "domainop",
        .commandFunc = bslDomainopCommand
    },
    {
        .name = "eloop",
        .commandFunc = bslEloopCommand
    },
    {
        .name = "instr",
        .commandFunc = bslInstrCommand
    },
    {
        .name = "null",
        .commandFunc = bslNullCommand
    },
    {
        .name = "query",
        .commandFunc = bslQueryCommand
    },
    {
        .name = "read",
        .commandFunc = bslReadCommand
    },
    {
        .name = "remaining",
        .commandFunc = bslRemainingCommand
    },
    {
        .name = "signal",
        .commandFunc = bslSignalCommand
    },
    {
        .name = "trace",
        .commandFunc = bslTraceCommand
    },
    {
        .name = "update",
        .commandFunc = bslUpdateCommand
    },
} ;
----

=== Harness commands implementation

==== Cancel command

[literal]
--
cancel <domain> <class> <inst> <event>
--

(((chunk,harness forward function declarations)))
(((function,bslCancelCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslCancelCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslCancelCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslCancelCommand(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"cancel <domain> <class> <inst> <event>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    MRT_EventCode eventNumber = event->number ;
    int pcode = mrt_PortalCancelDelayedEvent(portal, classId, instId,
            eventNumber) ;
    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Create command

[literal]
--
create <domain> <class> <inst>
--

(((chunk,harness forward function declarations)))
(((function,bslCreateCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslCreateCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslCreateCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslCreateCommand(
    int argc,
    char *const *argv)
{
    if (argc < 3 || argc > 4) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"create <domain> <class> ?<state>?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    MRT_StateCode initState = MRT_StateCode_IG ;
    if (argc == 4) {
        char *stateName = argv[3] ;
        BSL_StateMap const *const state = bslFindState(class, stateName) ;
        if (state == NULL) {
            return false ;
        }
        initState = state->number ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int pcode = mrt_PortalCreateInstance(portal, classId, initState) ;
    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }
    bslFormatToContext("%d", pcode) ;

    return true ;
}
----

==== Create async command

[literal]
--
createasync <domain> <class> <event> ?<arg1> <arg2> ...?
--

(((chunk,harness forward function declarations)))
(((function,bslCreateCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslCreateAsyncCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslCreateAsyncCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslCreateAsyncCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "\"createasync <domain> <class> <event> ?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *eventName = argv[3] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    BSL_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 4, argv + 4, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalCreateInstanceAsync(portal, classId, eventNumber,
            params, sizeof(params)) ;
    } else {
        pcode = mrt_PortalCreateInstanceAsync(portal, classId, eventNumber,
            NULL, 0) ;
    }

    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    bslFormatToContext("%d", pcode) ;
    return true ;
}
----

==== Delay signal command

[literal]
--
delaysignal <domain> <class> <inst> <delay> <event> ?<arg1> <arg2> ...?
--

(((chunk,harness forward function declarations)))
(((function,bslDelaySignalCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslDelaySignalCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslDelaySignalCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslDelaySignalCommand(
    int argc,
    char *const *argv)
{
    if (argc < 6) {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "\"delaysignal <domain> <class> <inst> <delay> <event> "
            "?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *delayTime = argv[4] ;
    MRT_DelayTime delay ;
    int converted = sscanf(delayTime, "%" SCNu32, &delay) ;
    if (converted != 1) {
        bslFormatToContext(failedConvertMsg, delayTime, SCNi32) ;
        return false ;
    }

    char *eventName = argv[5] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    BSL_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 6, argv + 6, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalSignalDelayedEvent(portal, classId, instId,
                eventNumber, params, sizeof(params), delay) ;
    } else {
        pcode = mrt_PortalSignalDelayedEvent(portal, classId, instId,
                eventNumber, NULL, 0, delay) ;
    }

    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Delete command

[literal]
--
delete <domain> <class> <inst>
--

(((chunk,harness forward function declarations)))
(((function,bslDeleteCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslDeleteCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslDeleteCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslDeleteCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"delete <domain> <class> <inst>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int pcode = mrt_PortalDeleteInstance(portal, classId, instId) ;
    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Domain operation command

(((chunk,harness forward function declarations)))
(((function,bslDomainopCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslDomainopCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslDomainopCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslDomainopCommand(
    int argc,
    char *const *argv)
{
    if (argc < 3) {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "domainop <domain> <operation> ?<arg1> <arg2> ...?",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *opName = argv[2] ;
    BSL_OperationMap const *const opMap = bslFindOperation(harness, opName) ;
    if (opMap == NULL) {
        return false ;
    }
    return opMap->func(argc - 3, argv + 3) ;
}
----

(((chunk,bosal harness tests)))
(((test,domainop-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-1.0 {
    Initialize lube domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop lube init
} -result {}
----

(((chunk,bosal harness tests)))
(((test,domainop-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.0 {
    Unknown domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop foo init
} -result {unknown domain, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-2.1)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.1 {
    No operation name
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop sio
} -result {wrong # of arguments: 2: expected, domainop <domain> <operation> ?<arg1> <arg2> ...?}\
-returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-2.2)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.2 {
    Unknown operations
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop sio foo
} -result {unknown operation, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-2.3)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.3 {
    Missing operation argument
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop lube Suspend_Autocycle_Session
} -result {wrong # arguments: got 0, expected 1} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,domainop-2.4)))

[source,tcl]
----
<<bosal harness tests>>=
test domainop-2.4 {
    Bad operation argument
} -setup {
} -cleanup {
} -body {
    harnessCmdResp domainop lube Suspend_Autocycle_Session foo
} -result {bad parameter: "foo"} -returnCodes error
----

==== Event loop Command

(((chunk,harness forward function declarations)))
(((function,bslEloopCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslEloopCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslEloopCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslEloopCommand(
    int argc,
    char *const *argv)
{
    static char const runMsg[] = "event loop is running" ;

    bool status = true ;

    if (argc == 1) {
        switch (bslHarnessState) {
        case bslHalted :
            bslAddWord("halted") ;
            break ;

        case bslRunning:
            bslAddWord("running") ;
            break ;

        default:
            bslFormatToContext("unknown harness state, \"%d\"",
                    bslHarnessState) ;
            status = false ;
            break ;
        }
    } else if (argc == 2) {
        if (strcmp(argv[1], "run") == 0) {
            bslHarnessState = bslRunning ;
            bslAddWord("running") ;
        } else if (strcmp(argv[1], "halt") == 0) {
            mrt_SyncToEventLoop() ;
            bslHarnessState = bslHalted ;
            bslAddWord("halted") ;
        } else if (strcmp(argv[1], "once") == 0) {
            if (bslHarnessState != bslRunning) {
                bool didEvent = mrt_DispatchSingleEvent() ;
                bslAddWord(didEvent ? "true" : "false") ;
            } else {
                bslAddWord(runMsg) ;
                status = false ;
            }
        } else if (strcmp(argv[1], "toc") == 0) {
            if (bslHarnessState != bslRunning) {
                bool didEvent = mrt_DispatchThreadOfControl(true) ;
                bslAddWord(didEvent ? "true" : "false") ;
            } else {
                bslAddWord(runMsg) ;
                status = false ;
            }
        } else {
            bslFormatToContext(
                "unknown eloop option, \"%s\": expected, "
                "\"run | halt | once | toc\"",
                argv[1]) ;
            status = false ;
        }
    } else if (argc == 3) {
        if (strcmp(argv[1], "toc") == 0) {
            if (bslHarnessState == bslRunning) {
                bslAddWord(runMsg) ;
                status = false ;
            } else {
                if (strcmp(argv[2], "wait") == 0) {
                    bool didEvent = mrt_DispatchThreadOfControl(true) ;
                    bslAddWord(didEvent ? "true" : "false") ;
                } else if (strcmp(argv[2], "nowait") == 0) {
                    bool didEvent = mrt_DispatchThreadOfControl(false) ;
                    bslAddWord(didEvent ? "true" : "false") ;
                } else {
                    bslFormatToContext(
                        "unknown toc option, \"%s\": expected, "
                        "\"toc wait | nowait\"", argv[2]) ;
                    status = false ;
                }
            }
        } else {
            bslFormatToContext(
                "bad eloop command format, \"%s\": expected, "
                "\"toc ?wait | nowait?\"",
                argv[1]) ;
            status = false ;
        }
    } else {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "\"eloop ?run | halt | once | toc ?wait | nowait?\"",
            argc) ;
        status = false ;
    }

    return status ;
}
----

==== Instrument command

(((chunk,harness forward function declarations)))
(((function,bslInstrCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslInstrCommand(int argc, char *const *argv) ;
----

[source,c]
----
<<harness static data>>=
static bool instrOn = false ;
----

(((chunk,harness static functions)))
(((function,bslInstrCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslInstrCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        bslAddWord(instrOn ? "on" : "off") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            instrOn = true ;
            bslAddWord("on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            instrOn = false ;
            bslAddWord("off") ;
        } else {
            bslFormatToContext(
                    "unknown instr option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
            status = false ;
        }
    } else {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, \"instr ?on | off?\"", argc) ;
        status = false ;
    }

    return status ;
}
----

==== Null command

(((chunk,harness forward function declarations)))
(((function,bslNullCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslNullCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslNullCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslNullCommand(
    int argc,
    char *const *argv)
{
    if (argc != 1) {
        bslFormatToContext("wrong # of arguments, %d: expected, null", argc) ;
        return false ;
    }

    return true ;
}
----

(((chunk,bosal harness tests)))
(((test,null-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test null-1.0 {
    Null command test
} -setup {
} -cleanup {
} -body {
    harnessCmdResp null
} -result {}
----

(((chunk,bosal harness tests)))
(((test,null-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test null-2.0 {
    Null command with wrong argument count
} -setup {
} -cleanup {
} -body {
    harnessCmdResp null foo
} -result {wrong # of arguments, 2: expected, null} -returnCodes error
----

==== Query command

(((chunk,harness forward function declarations)))
(((function,bslQueryCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryCommand(int, char *const *) ;
----

[literal]
--
query domains
query classes <domain>
query attributes <domain> <class>
query instances <domain> <class>
query states <domain> <class>
query events <domain> <class>
query current <domain> <class> <instance>
--

(((chunk,harness static functions)))
(((function,bslQueryCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslQueryCommand(
    int argc,
    char *const *argv)
{
    if (argc < 2) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "query <subcmd> ?<domain> <arg1> <arg2> ...?",
            argc) ;
        return false ;
    }

    char *subcmdName = argv[1] ;
    bool status ;
    if (strcmp(subcmdName, "domains") == 0) {
        status = bslQueryDomains(argc, argv) ;
    } else if (strcmp(subcmdName, "classes") == 0) {
        status = bslQueryClasses(argc, argv) ;
    } else if (strcmp(subcmdName, "attributes") == 0) {
        status = bslQueryAttrs(argc, argv) ;
    } else if (strcmp(subcmdName, "instances") == 0) {
        status = bslQueryInsts(argc, argv) ;
    } else if (strcmp(subcmdName, "states") == 0) {
        status = bslQueryStates(argc, argv) ;
    } else if (strcmp(subcmdName, "events") == 0) {
        status = bslQueryEvents(argc, argv) ;
    } else if (strcmp(subcmdName, "current") == 0) {
        status = bslQueryCurrent(argc, argv) ;
    } else {
        bslFormatToContext(
            "unknown subcommand, \"%s\": expected, "
            "\"domains | classes | attributes | instances "
            "states | events | current\"",
            subcmdName) ;
        status = false ;
    }

    return status ;
}
----

===== Query domains

(((chunk,harness forward function declarations)))
(((function,bslQueryDomains)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryDomains(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslQueryDomains)))

[source,c]
----
<<harness static functions>>=
static bool
bslQueryDomains(
    int argc,
    char *const *argv)
{
    if (argc != 2) {
        bslFormatToContext("wrong # of arguments, %d: expected, query domains",
                argc) ;
        return false ;
    }

    BSL_DomainHarness const *harness = bslHarnesses ;
    for (int count = bslHarnessCount ; count != 0 ; count--) {
        assert(harness->portal != NULL) ;
        bslAddWord(mrt_PortalDomainName(harness->portal)) ;
        harness++ ;
    }
    return true ;
}
----

(((chunk,bosal harness tests)))
(((test,query-domains-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-domains-1.0 {
    query domains successfully
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query domains
} -result {lube sio}
----

(((chunk,bosal harness tests)))
(((test,query-domains-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-domains-2.0 {
    query domains with too many arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query domains foo
} -result {wrong # of arguments, 3: expected, query domains} -returnCodes error
----

===== Query classes

(((chunk,harness forward function declarations)))
(((function,bslQueryClasses)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryClasses(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslQueryClasses)))

[source,c]
----
<<harness static functions>>=
static bool
bslQueryClasses(
    int argc,
    char *const *argv)
{
    if (argc != 3) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, \"query classes <domain>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int classCount = mrt_PortalDomainClassCount(portal) ;
    for (MRT_ClassId id = 0 ; id < classCount ; id++) {
        char const *className = NULL ;
        int pcode = mrt_PortalClassName(portal, id, &className) ;
        if (pcode == 0) {
            bslAddWord(className) ;
        } else {
            bslFormatToContext(mrt_PortalErrorString(pcode)) ;
            return false ;
        }
    }
    return true ;
}
----

(((chunk,bosal harness tests)))
(((test,query-classes-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-1.0 {
    query lube classes
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes lube
} -result {Lubrication_Schedule Injector_Design Injector Autocycle_Session Machinery Reservoir}
----

(((chunk,bosal harness tests)))
(((test,query-classes-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-2.0 {
    query classes -- unknown domain
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes foo
} -result {unknown domain, "foo"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,query-classes-2.1)))

[source,tcl]
----
<<bosal harness tests>>=
test query-classes-2.1 {
    query classes -- wrong number of arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp query classes foo bar
} -result {wrong # of arguments, 4: expected, "query classes <domain>"}\
-returnCodes error
----

===== Query attributes

(((chunk,harness forward function declarations)))
(((function,bslQueryAttrs)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryAttrs(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslQueryAttrs)))

[source,c]
----
<<harness static functions>>=
static bool
bslQueryAttrs(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"query attributes <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int attrCount = mrt_PortalClassAttributeCount(portal, classId) ;
    assert(attrCount >= 0) ;
    if (attrCount < 0) {
        bslFormatToContext(mrt_PortalErrorString(attrCount)) ;
        return false ;
    }

    for (MRT_AttrId attrId = 0 ; attrId < attrCount ; attrId++) {
        char const *attrName = NULL ;
        int pcode = mrt_PortalClassAttributeName(portal, classId, attrId,
                &attrName) ;
        if (pcode == 0) {
            bslAddWord(attrName) ;
        } else {
            bslFormatToContext(mrt_PortalErrorString(pcode)) ;
            return false ;
        }
    }

    return true ;
}
----

===== Query instances

(((chunk,harness forward function declarations)))
(((function,bslQueryInsts)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryInsts(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslQueryInsts)))

[source,c]
----
<<harness static functions>>=
static bool
bslQueryInsts(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"query instances <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int instCount = mrt_PortalClassInstanceCount(portal, classId) ;
    assert(instCount >= 0) ;
    if (instCount < 0) {
        bslFormatToContext(mrt_PortalErrorString(instCount)) ;
        return false ;
    }

    bslFormatToContext("total %d named ", instCount) ;

    bslPushContext() ;
    BSL_InstMap const *inst = classMap->insts ;
    for (unsigned namedCount = classMap->instCount ; namedCount != 0 ;
            namedCount--, inst++) {
        bslAddWord(inst->name) ;
    }
    bslPopContext() ;

    return true ;
}
----

===== Query states

(((chunk,harness forward function declarations)))
(((function,bslQueryStates)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryStates(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslQueryStates)))

[source,c]
----
<<harness static functions>>=
static bool
bslQueryStates(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"query states <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int stateCount = mrt_PortalClassStateCount(portal, classId) ;
    if (stateCount < 0) {
        bslFormatToContext(mrt_PortalErrorString(stateCount)) ;
        return false ;
    }

    for (MRT_StateCode stateId = 0 ; stateId < stateCount ; stateId++) {
        char const *stateName = NULL ;
        int pcode = mrt_PortalClassStateName(portal, classId, stateId,
                &stateName) ;
        if (pcode == 0) {
            bslAddWord(stateName) ;
        } else {
            bslFormatToContext(mrt_PortalErrorString(pcode)) ;
            return false ;
        }
    }

    return true ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslQueryEvents)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryEvents(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslQueryEvents)))

[source,c]
----
<<harness static functions>>=
static bool
bslQueryEvents(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"query events <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const classMap = bslFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int eventCount = mrt_PortalClassEventCount(portal, classId) ;
    if (eventCount < 0) {
        bslFormatToContext(mrt_PortalErrorString(eventCount)) ;
        return false ;
    }

    for (MRT_EventCode eventId = 0 ; eventId < eventCount ; eventId++) {
        char const *eventName = NULL ;
        int pcode = mrt_PortalClassEventName(portal, classId, eventId,
                &eventName) ;
        if (pcode == 0) {
            bslAddWord(eventName) ;
        } else {
            bslFormatToContext(mrt_PortalErrorString(pcode)) ;
            return false ;
        }
    }

    return true ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslQueryCurrent)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQueryCurrent(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslQueryCurrent)))

[source,c]
----
<<harness static functions>>=
static bool
bslQueryCurrent(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"query current <domain> <class> <instance>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    char *className = argv[3] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[4] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int statecode = mrt_PortalInstanceCurrentState(portal, classId, instId) ;
    if (statecode < 0) {
        bslFormatToContext(mrt_PortalErrorString(statecode)) ;
        return false ;
    }

    char const *stateName ;
    int pcode = mrt_PortalClassStateName(portal, classId, statecode, &stateName) ;
    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    bslAddWord(stateName) ;
    return true ;
}
----

==== Read Command

[literal]
--
read <domain> <class> <inst> ?<attr1> <attr2> ...?
--

(((chunk,harness forward function declarations)))
(((function,bslReadCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslReadCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslReadCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslReadCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"read <domain> <class> <inst> ?<attr1> <attr2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    bool status = true ;
    if (argc == 4) {
        // read all the attributes
        BSL_AttrMap const *attr = class->attrs ;
        for (unsigned attrCount = class->attrCount ; attrCount != 0 ;
                attrCount--, attr++) {
            bslAddWord(attr->name) ;
            bslPushContext() ;
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            bslPopContext() ;

            if (!status) {
                break ;
            }
        }
    } else {
        char *const *attrNames = argv + 4 ;
        for (int attrCount = argc - 4 ; attrCount != 0 ;
                attrCount--, attrNames++) {
            BSL_AttrMap const *const attr = bslFindAttr(class, *attrNames) ;
            if (attr == NULL) {
                bslInitBufContext() ;
                bslFormatToContext("unknown attribute, \"%s\"", *attrNames) ;
                status = false ;
                break ;
            }

            bslAddWord(*attrNames) ;
            bslPushContext() ;
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            bslPopContext() ;

            if (!status) {
                break ;
            }
        }
    }

    return status ;
}
----

(((chunk,bosal harness tests)))
(((test,read-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-1.0 {
    Read a single attribute
} -setup {
} -cleanup {
} -body {
    set result [harnessCmdResp read lube Injector_Design ihn4 Model]
    dict get $result Model
} -result {IHN4}
----

(((chunk,bosal harness tests)))
(((test,read-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-2.0 {
    Read all attributes
} -setup {
} -cleanup {
} -body {
    set result [harnessCmdResp read lube Injector_Design ihn4]
    set nattrs [dict size $result]
    set model [dict get $result Model]
    expr {$nattrs == 6 && $model eq "IHN4"}
} -result {1}
----

(((chunk,bosal harness tests)))
(((test,read-3.0)))

[source,tcl]
----
<<bosal harness tests>>=
test read-3.0 {
    Unknown attribute
} -setup {
} -cleanup {
} -body {
    harnessCmdResp read lube Injector_Design ihn4 foo
} -result {unknown attribute, "foo"} -returnCodes error
----

==== Remaining Command

[literal]
--
remaining <domain> <class> <inst> <event>
--

(((chunk,harness forward function declarations)))
(((function,bslRemainingCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslRemainingCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslRemainingCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslRemainingCommand(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"remaining <domain> <class> <inst> <event>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }
    MRT_EventCode eventNumber = event->number ;

    MRT_DelayTime delay ;
    int pcode = mrt_PortalRemainingDelayTime(portal, classId, instId,
            eventNumber, &delay) ;
    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    } else {
        bslFormatToContext("%" PRIu32, delay) ;
    }

    return true ;
}
----

==== Signal Command

(((chunk,harness forward function declarations)))
(((function,bslSignalCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslSignalCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslSignalCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslSignalCommand(
    int argc,
    char *const *argv)
{
    if (argc < 5) {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, "
            "\"signal <domain> <class> <inst> <event> ?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    BSL_EventMap const *event = bslFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    BSL_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 5, argv + 5, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalSignalEvent(portal, classId, instId, eventNumber,
            params, sizeof(params)) ;
    } else {
        pcode = mrt_PortalSignalEvent(portal, classId, instId, eventNumber,
            NULL, 0) ;
    }

    if (pcode < 0) {
        bslFormatToContext(mrt_PortalErrorString(pcode)) ;
        return false ;
    }

    return true ;
}
----

==== Trace Command

(((chunk,harness forward function declarations)))
(((function,bslTraceCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslTraceCommand(int argc, char *const *argv) ;
----

(((chunk,harness static functions)))
(((function,bslTraceCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslTraceCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        MRT_TraceHandler handler = mrt_RegisterTraceHandler(NULL) ;
        mrt_RegisterTraceHandler(handler) ;
        bslAddWord(handler == NULL ? "off" : "on") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            mrt_RegisterTraceHandler(bslTraceResponse) ;
            bslAddWord("on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            mrt_RegisterTraceHandler(bslDefaultTraceHandler) ;
            bslAddWord("off") ;
        } else {
            bslFormatToContext(
                    "unknown trace option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
            status = false ;
        }
    } else {
        bslFormatToContext(
            "wrong # of arguments: %d: expected, \"trace ?on | off?\"", argc) ;
        status = false ;
    }

    return status ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslTraceResponse)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTraceResponse(MRT_TraceInfo const *traceInfo) ;
----

(((chunk,harness static functions)))
(((function,bslTraceResponse)))

[source,c]
----
<<harness static functions>>=
static void
bslTraceResponse(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
        char const *newStateName ;
        if (newState == MRT_StateCode_IG) {
            newStateName = "IG" ;
        } else if (newState == MRT_StateCode_CH) {
            newStateName = "CH" ;
        } else {
            newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.newState] ;
        }

        fprintf(bslCmdStream,
                "trace {"
                "type transition "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "currstate %s "
                "newstate %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.currentState],
            newStateName,
            bslTimestamp()) ;
    }
        break ;

    case mrtPolymorphicEvent: {
        MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
                genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
        MRT_Class const *subclass ;
        char const *subname = NULL ;
        if (rel->relType == mrtRefGeneralization) {
            subclass = rel->relInfo.refGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
            subname = subclass->name ;
        } else if (rel->relType == mrtUnionGeneralization) {
            subclass = rel->relInfo.unionGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode] ;
            subname = subclass->name ;
        } else {
            printf("%s: bad relationship type in polymorphic event, %d\n",
                bslTimestamp(), rel->relType) ;
            break ;
        }
        fprintf(bslCmdStream,
                "trace {"
                "type polymorphic "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "relationship %s "
                "newevent %s "
                "subclass %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->pdb->genNames[
                traceInfo->info.polyTrace.genNumber],
            subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
            subname,
            bslTimestamp()) ;
    }
        break ;

    case mrtCreationEvent:
        fprintf(bslCmdStream,
                "trace {"
                "type creation "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->info.creationTrace.targetClass->name, targetName,
            bslTimestamp()) ;
        break ;

    default:
        fprintf(bslCmdStream,
                "trace {"
                "type error "
                "result {unknown trace event type, \"%u\"} "
                "time %s"
                "}\n",
            traceInfo->eventType,
            bslTimestamp()) ;
        break ;
    }
}
----

(((chunk,harness forward function declarations)))
(((function,bslTimestamp)))

[source,c]
----
<<harness forward function declarations>>=
static char const *bslTimestamp(void) ;
----

(((chunk,harness static functions)))
(((function,bslTimestamp)))

[source,c]
----
<<harness static functions>>=
static char const *
bslTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "too big" ;
    }

    return timestamp ;
}
----

(((chunk,bosal harness tests)))
(((test,trace-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-1.0 {
    Get trace status
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace
} -result {off}
----

(((chunk,bosal harness tests)))
(((test,trace-2.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-2.0 {
    Turn tracing on
} -setup {
} -cleanup {
    harnessCmdResp trace off
} -body {
    harnessCmdResp trace on
} -result {on}
----

(((chunk,bosal harness tests)))
(((test,trace-3.0)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-3.0 {
    Bad trace option
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace foo
} -result {unknown trace option, "foo": expected, "on | off"} -returnCodes error
----

(((chunk,bosal harness tests)))
(((test,trace-3.1)))

[source,tcl]
----
<<bosal harness tests>>=
test trace-3.1 {
    Wrong number of trace arguments
} -setup {
} -cleanup {
} -body {
    harnessCmdResp trace on heavy
} -result {wrong # of arguments: 3: expected, "trace ?on | off?"}\
-returnCodes error
----

==== Update Command

[literal]
--
update <domain> <class> <inst> ?<attr1> <value1> <attr2> <value2> ...?
--

(((chunk,harness forward function declarations)))
(((function,bslUpdateCommand)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslUpdateCommand(int, char *const *) ;
----

(((chunk,harness static functions)))
(((function,bslUpdateCommand)))

[source,c]
----
<<harness static functions>>=
static bool
bslUpdateCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        bslFormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"update <domain> <class> <inst> ?<attr1> <value1> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    BSL_DomainHarness const *const harness = bslFindHarness(domainName) ;
    if (harness == NULL) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    BSL_ClassMap const *const class = bslFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = bslFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    bool status = true ;
    int updateCount = argc - 4 ;
    if (updateCount % 2 != 0) {
        bslFormatToContext("updates must be given as name / value pairs") ;
        return false ;
    }

    char *const *attrName = argv + 4 ;
    char *const *valueString = argv + 5 ;
    for ( ; updateCount != 0 ;
            updateCount -= 2, attrName += 2, valueString += 2) {
        BSL_AttrMap const *const attr = bslFindAttr(class, *attrName) ;
        if (attr == NULL) {
            bslInitBufContext() ;
            bslFormatToContext("unknown attribute, \"%s\"", *attrName) ;
            break ;
        }

        bslAddWord(*attrName) ;
        bslPushContext() ;
        status = attr->updateFunc(portal, classId, instId, attr->id,
                *valueString) ;
        if (status) {
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            bslPopContext() ;
        }

        if (!status) {
            break ;
        }
    }

    return status ;
}
----

(((chunk,bosal harness tests)))
(((test,update-1.0)))

[source,tcl]
----
<<bosal harness tests>>=
test update-1.0 {
    Update a single attribute
} -setup {
    set oldwindow [dict get\
        [harnessCmdResp read lube Injector_Design ihn4 Delivery_window]\
        Delivery_window]
} -cleanup {
    harnessCmdResp update lube Injector_Design ihn4 Delivery_window $oldwindow
} -body {
    harnessCmdResp update lube Injector_Design ihn4 Delivery_window 42
    set result [harnessCmdResp read lube Injector_Design ihn4 Delivery_window]
    dict get $result Delivery_window
} -result {42}
----

=== Locating Domain Components

==== Finding a Harness

(((chunk,harness forward function declarations)))
(((function,bslFindHarness)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_DomainHarness const *const bslFindHarness(char const *domainName) ;
----

(((chunk,harness static functions)))
(((function,bslFindHarness)))

[source,c]
----
<<harness static functions>>=
static BSL_DomainHarness const *const
bslFindHarness(
    char const *domainName)
{
    assert(domainName != NULL) ;

    BSL_DomainHarness const *hiter = bslHarnesses ;
    int hcount = bslHarnessCount ;
    for ( ; hcount != 0 ; hcount--, hiter++) {
        assert(hiter->portal != NULL) ;
        assert(hiter->portal->name != NULL) ;
        char const *trialName = mrt_PortalDomainName(hiter->portal) ;
        if (strcmp(domainName, trialName) == 0) {
            return hiter ;
        }
    }
    bslFormatToContext("unknown domain, \"%s\"", domainName) ;
    return NULL ;
}
----

==== Finding a Domain Operation

(((chunk,harness forward function declarations)))
(((function,bslFindOperation)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_OperationMap const *const bslFindOperation(
    BSL_DomainHarness const *const harness, char const *opName) ;
----

(((chunk,harness static functions)))
(((function,bslFindOperation)))

[source,c]
----
<<harness static functions>>=
static BSL_OperationMap const *const
bslFindOperation(
    BSL_DomainHarness const *const harness,
    char const *opName)
{
    BSL_OperationMap key = {
        .name = opName,
        .func = NULL
    } ;

    BSL_OperationMap const *const opMap =
            bsearch(&key, harness->operations, harness->operationCount,
            sizeof(key), bslOperationMapCompare) ;
    if (opMap == NULL) {
        bslFormatToContext("unknown operation, \"%s\"", opName) ;
    }

    return opMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslOperationMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslOperationMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslOperationMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslOperationMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_OperationMap const *cm1 = m1 ;
    BSL_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Domain Class

(((chunk,harness forward function declarations)))
(((function,bslFindClass)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_ClassMap const *const bslFindClass(
    BSL_DomainHarness const *const harness, char const *className) ;
----

(((chunk,harness static functions)))
(((function,bslFindClass)))

[source,c]
----
<<harness static functions>>=
static BSL_ClassMap const *const
bslFindClass(
    BSL_DomainHarness const *const harness,
    char const *className)
{
    BSL_ClassMap key = {
        .name = className
    } ;

    BSL_ClassMap const *const classMap =
            bsearch(&key, harness->classes, harness->classCount,
            sizeof(key), bslClassMapCompare) ;
    if (classMap == NULL) {
        bslFormatToContext("unknown class, \"%s\"", className) ;
    }

    return classMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslClassMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslClassMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_OperationMap const *cm1 = m1 ;
    BSL_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class Attribute

(((chunk,harness forward function declarations)))
(((function,bslFindAttr)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_AttrMap const *const
bslFindAttr(
    BSL_ClassMap const *const class,
    char const *attrName) ;
----

(((chunk,harness static functions)))
(((function,bslFindAttr)))

[source,c]
----
<<harness static functions>>=
static BSL_AttrMap const *const
bslFindAttr(
    BSL_ClassMap const *const class,
    char const *attrName)
{
    BSL_AttrMap key = {
        .name = attrName
    } ;

    return (BSL_AttrMap const *const)
            bsearch(&key, class->attrs, class->attrCount,
            sizeof(key), bslAttrMapCompare) ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslAttrMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslAttrMapCompare(void const*, void const*) ;
----

(((chunk,harness static functions)))
(((function,bslAttrMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslAttrMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_AttrMap const *cm1 = m1 ;
    BSL_AttrMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class Instance

(((chunk,harness forward function declarations)))
(((function,bslFindInst)))

[source,c]
----
<<harness forward function declarations>>=
static int bslFindInst(BSL_ClassMap const *const class, char const *instName) ;
----

(((chunk,harness static functions)))
(((function,bslFindInst)))

[source,c]
----
<<harness static functions>>=
static int
bslFindInst(
    BSL_ClassMap const *const class,
    char const *instName)
{
    // First scan to see if we got a number.
    int instId = -1 ;
    int converted = sscanf(instName, "%i", &instId) ;
    if (converted == 1) {
        if (instId < 0) {
            bslFormatToContext("instance id's must be non-negative: "
                    "got, %i", instId) ;
        }
    } else {
        // Not a number, try to look up the name.
        BSL_InstMap key = {
            .name = instName
        } ;

        BSL_InstMap const *const instMap =
                bsearch(&key, class->insts, class->instCount,
                sizeof(key), bslInstMapCompare) ;
        if (instMap == NULL) {
            bslFormatToContext("unknown instance, \"%s\"", instName) ;
            instId = -1 ;
        } else {
            instId = instMap->id ;
        }
    }

    return instId ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslInstMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslInstMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslInstMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslInstMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_InstMap const *cm1 = m1 ;
    BSL_InstMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class Event

(((chunk,harness forward function declarations)))
(((function,bslFindEvent)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_EventMap const *bslFindEvent(BSL_ClassMap const *const class,
        char const *eventName) ;
----

(((chunk,harness static functions)))
(((function,bslFindEvent)))

[source,c]
----
<<harness static functions>>=
static BSL_EventMap const *
bslFindEvent(
    BSL_ClassMap const *const class,
    char const *eventName)
{
    BSL_EventMap key = {
        .name = eventName
    } ;

    BSL_EventMap const *eventMap = bsearch(&key, class->events,
            class->eventCount, sizeof(key), bslEventMapCompare) ;

    if (eventMap == NULL) {
        bslFormatToContext("unknown event, \"%s\"", eventName) ;
    }

    return eventMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslEventMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslEventMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_EventMap const *cm1 = m1 ;
    BSL_EventMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Finding a Class State

(((chunk,harness forward function declarations)))
(((function,bslFindState)))

[source,c]
----
<<harness forward function declarations>>=
static BSL_StateMap const *bslFindState(BSL_ClassMap const *const class,
        char const *stateName) ;
----

(((chunk,harness static functions)))
(((function,bslFindState)))

[source,c]
----
<<harness static functions>>=
static BSL_StateMap const *
bslFindState(
    BSL_ClassMap const *const class,
    char const *stateName)
{
    BSL_StateMap key = {
        .name = stateName
    } ;

    BSL_StateMap const *stateMap = bsearch(&key, class->states,
            class->stateCount, sizeof(key), bslStateMapCompare) ;

    if (stateMap == NULL) {
        bslFormatToContext("unknown state, \"%s\"", stateName) ;
    }

    return stateMap ;
}
----

(((chunk,harness forward function declarations)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness forward function declarations>>=
static int bslStateMapCompare(void const *m1, void const *m2) ;
----

(((chunk,harness static functions)))
(((function,bslClassMapCompare)))

[source,c]
----
<<harness static functions>>=
static int
bslStateMapCompare(
    void const *m1,
    void const *m2)
{
    BSL_StateMap const *cm1 = m1 ;
    BSL_StateMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

=== Generating Main

(((chunk,bosal code template commands)))
(((proc,generateMain)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateMain {} {
    variable includeMain

    if ($includeMain) {
        set div [diverter new]

        $div puts int
        $div puts main( ; $div push
        $div puts "int argc,"
        $div puts "char **argv)" ; $div pop
        $div puts "{" ; $div push
        $div puts "mrt_Initialize() ;"
        $div puts "bsl_Run() ;"
        $div puts "return 0 ;"
        $div pop ; $div puts "}"

        $div return
    }

    return
}
----

== Domain Dependent Code

=== Generate Command

(((chunk,required packages)))

[source,tcl]
----
<<required packages>>=
package require textutil::expander
----

(((chunk,bosal commands)))
(((proc,generate)))

[source,tcl]
----
<<bosal commands>>=
proc generate {options} {
    <<generate: set up template expansion>>
    <<generate: generate code>>
}
----

(((chunk,generate: set up template expansion)))

[source,tcl]
----
<<generate: set up template expansion>>=
textutil::expander expand
expand setbrackets <% %>
expand errmode [dict get $options expanderror]

variable GenCode::includeMain [dict get $options main]
----

(((chunk,generate: generate code)))

[source,tcl]
----
<<generate: generate code>>=
expand evalcmd "namespace eval [namespace current]::GenCode"
try {
    variable codeTemplate
    return [expand expand $codeTemplate]
} on error {result opts} {
    # puts $::errorInfo
    return -options $opts $result
} finally {
    rename expand {}
}
----

==== Code Template

(((chunk,bosal data)))
(((data,codeTemplate)))

[source,tcl]
----
<<bosal data>>=
variable codeTemplate [textutil::adjust::undent {
/*
<<edit warning>>
<<copyright info>>
*/

/*
 * Include Files
 */
#define _POSIX_C_SOURCE 200809L
#include "bosal.h"
#include "micca_rt.h"
#include "micca_rt_internal.h"
/*
 * Domain Header Files
 */
<%includeDomainHeaders%>
#include <sys/socket.h>
#include <sys/time.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <setjmp.h>
#include <ctype.h>
#include <time.h>
#include <strings.h>

/*
 * Macros
 */
#ifndef NDEBUG
#   define  dbgprintf(...)    printf(__VA_ARGS__)
#else
#   define  dbgprintf(...)
#endif /* NDEBUG */

/*
 * Special characters used in parsing commands.
 */
#define ASCII_NUL       '\0'
#define BEGIN_QUOTE     '{'
#define END_QUOTE       '}'
#define ESCAPE_CHAR     '\\'

/*
 * The state of the command parser.
 */
#define OUTOFWORD   0
#define INWORD      1
#define INESCAPE    2
#define INQUOTE     3

/*
 * Constants
 */
#ifndef HARNESS_PORT
#   define HARNESS_PORT 3906    /* default port number for TCP connection */
#endif /* HARNESS_PORT */
#ifndef BSL_NESTLIMIT
#   define  BSL_NESTLIMIT   4   /* maximum depth of text diversions */
#endif /* BSL_NESTLIMIT */

/*
 * Data Types
 */
<<harness data types>>

/*
 * Forward References
 */
<<harness forward function declarations>>

/*
 * Static Data
 */
<<harness static data>>
<%generateStateMaps%>
<%generateEventMaps%>
<%generateInstMaps%>
<%generateAttrMaps%>
<%generateClassMaps%>
<%generateOpMaps%>
<%generateHarnesses%>

/*
 * Static Functions
 */
<<harness static functions>>

/*
 * External Functions
 */
<<harness external function definitions>>
<%generateMain%>
}]
----

In the following sections,
we show the Tcl code that is executed during the template expansion.

=== Including the domain header files

The domain header files are derived from the name of a domain.
This matches the naming convension used by `micca` in producing
the header file.

(((chunk,bosal code template commands)))
(((proc,generateHarnesses)))

[source,tcl]
----
<<bosal code template commands>>=
proc includeDomainHeaders {} {
    set div [diverter new]

    forAllRefs domainRef [Domain findAll] {
        set domainName [readAttribute $domainRef Name]
        $div puts "#include \"$domainName.h\""
    }

    $div return
}
----

=== Generating domain mappings

A major part of the link between the domain independent code and
the harnessed domains is a set of mapping tables.
The mapping tables typically map string values to some internal
reference to the domain.
For example,
knowing how to execute a domain operation involves mapping the
name of the operation to a function that ultimately invokes the
``C'' function that is the domain operation.

The mapping tables are ordered alphabetically by the string key.
This allows us to use `bsearch` to find an entry.
The tables are not very large, so binary search is sufficient
for our purposes and easier to manage that a hash table.

==== Generating the domain harness

The top level mapping locates information about a domain and is a mapping
from the name of the domain to its descriptive data.

The following data structure describes an harnessed domain.

(((chunk,harness data types)))
(((type,BSL_DomainHarness)))

[source,c]
----
<<harness data types>>=
typedef struct bsldomainharness {
    MRT_DomainPortal const *portal ;
    struct bsloperationmap const *const operations ;
    unsigned operationCount ;
    struct bslclassmap const *const classes ;
    unsigned classCount ;
} BSL_DomainHarness ;
----

(((chunk,bosal code template commands)))
(((proc,generateHarnesses)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateHarnesses {} {
    set div [diverter new]

    $div puts "static BSL_DomainHarness const bslHarnesses\[] = {" ; $div push

    forAllRefs domRef [Domain findAll] {
        assignAttribute $domRef {Name domainName}
        $div puts "{" ; $div push
        $div puts ".portal = &${domainName}__PORTAL,"

        set opsRef [findRelated $domRef ~R5]
        if {[isEmptyRef $opsRef]} {
            set ops NULL
            set opsCount 0
        } else {
            set ops ${domainName}__OPMAP
            set opsCount COUNTOF($ops)
        }
        $div puts ".operations = $ops,"
        $div puts ".operationCount = $opsCount,"

        $div puts ".classes = ${domainName}__CLASSMAP,"
        $div puts ".classCount = COUNTOF(${domainName}__CLASSMAP)"

        $div pop ; $div puts "},"
    }

    $div pop ; $div puts "} ;"

    $div puts "static int const bslHarnessCount = COUNTOF(bslHarnesses) ;"

    $div return
}
----

==== Generating the operations map

(((chunk,harness data types)))
(((type,BSL_DomainOpFunc)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_DomainOpFunc(int, char *const *) ;
----

(((chunk,harness data types)))
(((type,BSL_OperationMap)))

[source,c]
----
<<harness data types>>=
typedef struct bsloperationmap {
    char const *name ;
    BSL_DomainOpFunc *func ;
} BSL_OperationMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateOpMap)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpMaps {} {
    set div [diverter new]

    set ops [pipe {
        DomainOperation findAll |
        deRef ~ |
        relation project ~ Domain Name |
        relation group ~ Ops Name
    }]

    relation foreach op $ops {
        relation assign $op
        $div puts "static BSL_OperationMap const ${Domain}__OPMAP\[] = {"
        $div push

        relation foreach op $Ops -ascending Name {
            set opName [relation extract $op Name]
            $div puts "{\"$opName\", ${Domain}_${opName}__OPFUNC},"
        }

        $div pop
        $div puts "} ;"
    }

    $div return
}
----

==== Generating the domain operation functions

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateOpFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateOpFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpFuncDeclarations {} {
    set div [diverter new]

    forAllRefs dopRef [DomainOperation findAll] {
        assignAttribute $dopRef Domain Name
        $div puts "static bool ${Domain}_${Name}__OPFUNC(int, char *const *) ;"
    }

    $div return
}
----

(((chunk,harness static functions)))

[source,c]
----
<<harness static functions>>=
<%generateOpFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateOpFuncDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateOpFuncDefinitions {} {
    set div [diverter new]

    forAllRefs dopRef [DomainOperation findAll] {
        assignAttribute $dopRef Domain Name ReturnDataType
        $div puts "static bool ${Domain}_${Name}__OPFUNC("
        $div puts "    int argc,"
        $div puts "    char *const *argv)"
        $div puts "{" ; $div push

        set paramRefs [findRelated $dopRef ~R6]
        set nparams [refMultiplicity $paramRefs]
        $div puts "if (argc != $nparams) {" ; $div push
        $div puts "bslFormatToContext(wrongNumArgsMsg, argc, $nparams) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        set argIndex 0
        set params [deRef $paramRefs]
        relation foreach param $params -ascending Number {
            relation assign $param {DataType type} {Name paramName}
            set typeinfo [GetTypeInfo $Domain $type $paramName]
            $div puts "[dict get $typeinfo declaration] ;"

            set scnfmt [dict get $typeinfo scan]
            set varref [dict get $typeinfo varref]
            if {$scnfmt ne {}} {
                $div puts "if (sscanf(argv\[$argIndex\], \"%\" $scnfmt,\
                    $varref) != 1) {" ; $div push
                $div puts "bslFormatToContext(badParamMsg, argv\[$argIndex\]) ;"
                $div puts "return false ;"
                $div pop ; $div puts "}"
            } else {
                $div puts "$paramName = argv\[$argIndex\] ;"
            }

            incr argIndex
        }

        set invokeParams [pipe {
            relation list $params Name -ascending Number |
            join ~ {, }
        }]
        set invocation "${Domain}_${Name}($invokeParams) ;"

        if {$ReturnDataType eq "void"} {
            $div puts $invocation
        } else {
            set rettypeinfo [GetTypeInfo $Domain $ReturnDataType result__OP]
            set decl [dict get $rettypeinfo declaration]
            $div puts "$decl = $invocation ;"
            $div puts "bslFormatToContext(\"%\" [dict get $rettypeinfo print],\
                    [dict get $rettypeinfo varref]) ;"
        }

        $div puts "return true ;"
        $div pop ; $div puts "}"
    }

    $div return
}
----

(((chunk,harness static data)))
(((data,wrongNumArgsMsg)))
(((data,badParamMsg)))

[source,c]
----
<<harness static data>>=
static char const wrongNumArgsMsg[] = "wrong # arguments: got %d, expected %d" ;
static char const badParamMsg[] = "bad parameter: \"%s\"" ;
----

==== Generating the class map

(((chunk,harness data types)))
(((type,BSL_ClassMap)))

[source,c]
----
<<harness data types>>=
typedef struct bslclassmap {
    char const *name ;
    MRT_ClassId id ;
    struct bslattrmap const *attrs ;
    unsigned attrCount ;
    struct bslinstmap const *insts ;
    unsigned instCount ;
    struct bsleventmap const *events ;
    unsigned eventCount ;
    struct bslstatemap const *states ;
    unsigned stateCount ;
} BSL_ClassMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateClassMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateClassMaps {} {
    set div [diverter new]

    set classGrps [pipe {
        Class findAll |
        deRef ~ |
        relation group ~ Classes Name Number
    }]

    relation foreach classGrp $classGrps {
        relation assign $classGrp {Domain domainName} Classes
        $div puts "static BSL_ClassMap const ${domainName}__CLASSMAP\[] = {"
        $div push

        relation foreach class $Classes -ascending Name {
            relation assign $class {Name className} Number
            $div puts "{" ; $div push

            $div puts ".name = \"$className\","
            $div puts ".id = $Number,"

            set attrRef [Attribute findWhere\
                    {$Domain eq $domainName && $Class eq $className}]
            if {[isEmptyRef $attrRef]} {
                set attrMap NULL
                set attrCount 0
            } else {
                set attrMap ${domainName}_${className}__ATTRMAP
                set attrCount COUNTOF(${domainName}_${className}__ATTRMAP)
            }
            $div puts ".attrs = $attrMap,"
            $div puts ".attrCount = $attrCount,"

            set instRef [ClassInstance findWhere\
                    {$Domain eq $domainName && $Class eq $className}]
            if {[isEmptyRef $instRef]} {
                set instMap NULL
                set instCount 0
            } else {
                set instMap ${domainName}_${className}__INSTMAP
                set instCount COUNTOF(${domainName}_${className}__INSTMAP)
            }
            $div puts ".insts = $instMap,"
            $div puts ".instCount = $instCount,"

            set eventRef [pipe {
                InstanceStateModel findWhere\
                    {$Domain eq $domainName && $Class eq $className} |
                findRelated ~ R50 |
                deRef ~ |
                relation semijoin ~ $::micca::Event
            }]
            if {[relation isempty $eventRef]} {
                set eventMap NULL
                set eventCount 0
            } else {
                set eventMap ${domainName}_${className}__EVENTMAP
                set eventCount COUNTOF(${domainName}_${className}__EVENTMAP)
            }
            $div puts ".events = $eventMap,"
            $div puts ".eventCount = $eventCount,"

            set stateRef [InstanceStateModel findWhere\
                    {$Domain eq $domainName && $Class eq $className}]
            if {[isEmptyRef $stateRef]} {
                set stateMap NULL
                set stateCount 0
            } else {
                set stateMap ${domainName}_${className}__STATEMAP
                set stateCount COUNTOF(${domainName}_${className}__STATEMAP)
            }
            $div puts ".states = $stateMap,"
            $div puts ".stateCount = $stateCount,"

            $div pop ; $div puts "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the attribute map

(((chunk,harness data types)))
(((type,BSL_AttrMap)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_AttrReadFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId) ;
typedef bool BSL_AttrUpdateFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId, char const *) ;
typedef struct bslattrmap {
    char const *name ;
    MRT_AttrId id ;
    BSL_AttrReadFunc *readFunc ;
    BSL_AttrUpdateFunc *updateFunc ;
} BSL_AttrMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateAttrMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrMaps {} {
    set div [diverter new]

    set attrGrps [pipe {
        Attribute findAll |
        deRef ~ |
        relation project ~ Domain Class Name |
        relation group ~ Attrs Name
    }]

    relation foreach attrGrp $attrGrps {
        relation assign $attrGrp {Domain domainName} {Class className} Attrs
        $div puts "static BSL_AttrMap const\
                ${domainName}_${className}__ATTRMAP\[] = {"
        $div push

        set attrNum -1
        relation foreach attr $Attrs -ascending Name {
            relation assign $attr {Name attrName}
            $div puts "{" ; $div push

            $div puts ".name = \"$attrName\","
            $div puts ".id = [incr attrNum],"
            $div puts ".readFunc = ${domainName}_${className}_${attrName}__RD,"
            $div puts ".updateFunc = ${domainName}_${className}_${attrName}__UP"

            $div pop ; $div puts "},"
            incr id
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the attribute read functions

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateAttrReadFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrReadFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrReadFuncDeclarations {} {
    set div [diverter new]

    forAllRefs attrRef [Attribute findAll] {
        assignAttribute $attrRef Domain Class Name
        $div puts "static bool\
            ${Domain}_${Class}_${Name}__RD(MRT_DomainPortal const *,\
            MRT_ClassId, MRT_InstId, MRT_AttrId) ;"
    }

    $div return
}
----

(((chunk,harness static functions)))

[source,c]
----
<<harness static functions>>=
<%generateAttrReadFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrReadFuncsDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrReadFuncDefinitions {} {
    set div [diverter new]

    forAllRefs attrRef [Attribute findAll] {
        assignAttribute $attrRef Domain Class Name DataType
        $div puts "static bool ${Domain}_${Class}_${Name}__RD("
        $div push
        $div puts "MRT_DomainPortal const *portal,"
        $div puts "MRT_ClassId classId,"
        $div puts "MRT_InstId instId,"
        $div puts "MRT_AttrId attrId)"
        $div pop
        $div puts "{" ; $div push

        set typeinfo [GetTypeInfo $Domain $DataType attrValue]
        set attrVar [dict get $typeinfo declaration]

        $div puts "$attrVar ;"

        set pAttrVar [dict get $typeinfo varref]

        $div puts "int pcode = mrt_PortalReadAttr(portal, classId, instId,\
                attrId, $pAttrVar, sizeof(attrValue)) ;"
        $div puts "if (pcode < 0) {" ; $div push
        $div puts "bslFormatToContext(mrt_PortalErrorString(pcode)) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        set varType [dict get $typeinfo type]
        set prifmt [dict get $typeinfo print]
        switch -exact -- $varType {
            scalar {
                $div puts "bslFormatToContext(\"%\" $prifmt, attrValue) ;"
            }
            string {
                $div puts "bslFormatToContext(\"%\" $prifmt, attrValue) ;"
            }
            array {
                set dim [dict get $typeinfo dimension]
                $div puts "for (int index = 0 ; $index < $dim ; index++) {"
                $div push
                $div puts "bslFormatToContext(\"%\" $prifmt \" \",\
                        attrValue\[index]) ;"
                $div pop ; $div puts "}"
            }
            default {
                error "unknown variable type, $varType"
            }
        }

        $div puts "return true ;"

        $div pop ; $div puts "}"
    }

    $div return
}
----

==== Generating the attribute update functions

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateAttrUpdateFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrUpdateFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrUpdateFuncDeclarations {} {
    set div [diverter new]

    forAllRefs attrRef [Attribute findAll] {
        assignAttribute $attrRef Domain Class Name
        $div puts "static bool\
            ${Domain}_${Class}_${Name}__UP(MRT_DomainPortal const *,\
            MRT_ClassId, MRT_InstId, MRT_AttrId, char const *) ;"
    }

    $div return
}
----

(((chunk,harness static functions)))

[source,c]
----
<<harness static functions>>=
<%generateAttrUpdateFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateAttrUpdateFuncsDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateAttrUpdateFuncDefinitions {} {
    set div [diverter new]

    forAllRefs attrRef [Attribute findAll] {
        assignAttribute $attrRef Domain Class Name DataType
        $div puts "static bool ${Domain}_${Class}_${Name}__UP("
        $div push
        $div puts "MRT_DomainPortal const *portal,"
        $div puts "MRT_ClassId classId,"
        $div puts "MRT_InstId instId,"
        $div puts "MRT_AttrId attrId,"
        $div puts "char const *value)"
        $div pop
        $div puts "{" ; $div push

        $div puts "int pcode ;"
        set typeinfo [GetTypeInfo $Domain $DataType convertedValue]
        switch -exact -- [dict get $typeinfo type] {
            scalar {
                $div puts "[dict get $typeinfo declaration] ;"
                set cvtRef [dict get $typeinfo varref]

                if {[dict get $typeinfo basetype] eq "bool"} {
                    $div puts "int nitems = bslScanBoolean(value, $cvtRef) ;"
                    set scnfmt \"bool\"
                } else {
                    set scnfmt [dict get $typeinfo scan]
                    $div puts "int nitems = sscanf(value, \"%\" $scnfmt,\
                            $cvtRef) ;"
                }
                $div puts "if (nitems == 1) {" ; $div push
                $div puts "pcode = mrt_PortalUpdateAttr(portal, classId,\
                    instId, attrId, $cvtRef, sizeof(convertedValue)) ;"
                $div pop ; $div puts "} else {" ; $div push
                $div puts "bslFormatToContext(failedConvertMsg,\
                        value, $scnfmt) ;"
                $div puts "return false ;"
                $div pop ; $div puts "}"
            }
            string {
                $div puts "pcode = mrt_PortalUpdateAttr(portal, classId,\
                    instId, attrId, value, strlen(value) + 1) ;"
            }
            array {
            }
        }

        $div puts "if (pcode < 0) {" ; $div push
        $div puts "bslFormatToContext(mrt_PortalErrorString(pcode)) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        $div puts "return true ;"

        $div pop ; $div puts "}"
    }

    $div return
}
----

(((chunk,harness static data)))
(((data,failedConvertMsg)))

[source,c]
----
<<harness static data>>=
static char const failedConvertMsg[] = "failed to convert, \"%s\" as \"%s\"" ;
----

==== Generate the instance map

(((chunk,harness data types)))
(((type,BSL_InstMap)))

[source,c]
----
<<harness data types>>=
typedef struct bslinstmap {
    char const *name ;
    MRT_InstId id ;
} BSL_InstMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateInstMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateInstMaps {} {
    set div [diverter new]

    set instGrps [pipe {
        ClassInstance findAll |
        deRef ~ |
        relation group ~ Insts Instance Number
    }]

    relation foreach instGrp $instGrps {
        relation assign $instGrp {Domain domainName} {Class className} Insts
        $div puts "static BSL_InstMap const\
                ${domainName}_${className}__INSTMAP\[] = {"
        $div push

        relation foreach inst $Insts -ascending Instance {
            relation assign $inst {Instance instName} {Number instNum}
            $div puts "{" ; $div push

            $div puts ".name = \"$instName\","
            $div puts ".id = $instNum,"

            $div pop ; $div puts "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generate the Event Map

(((chunk,harness data types)))
(((type,BSL_EventMap)))

[source,c]
----
<<harness data types>>=
typedef bool BSL_EventParamFunc(int, char * const*, MRT_EventParams) ;

typedef struct bsleventmap {
    char const *name ;
    MRT_EventCode number ;
    BSL_EventParamFunc *paramFunc ;
} BSL_EventMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateEventMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventMaps {} {
    set div [diverter new]

    set eventGrps [pipe {
        InstanceStateModel findAll |
        findRelated ~ R50 |
        deRef ~ |
        relation semijoin ~ $::micca::Event |
        relation group ~ Events Event Number PSigID
    }]

    relation foreach eventGrp $eventGrps {
        relation assign $eventGrp {Domain domainName} {Model className} Events
        $div puts "static BSL_EventMap const\
                ${domainName}_${className}__EVENTMAP\[] = {"
        $div push

        relation foreach event $Events -ascending Event {
            relation assign $event {Event eventName} {Number eventNum} PSigID
            $div puts "{" ; $div push

            $div puts ".name = \"$eventName\","
            $div puts ".number = $eventNum,"
            $div puts ".paramFunc = [expr {$PSigID ne {} ?\
                    "${domainName}_${className}_${eventName}__EPFUNC" :\
                    "NULL"}]"

            $div pop ; $div puts "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

==== Generating the Event Parameter Functions

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
<%generateEventParamFuncDeclarations%>
----

(((chunk,bosal code template commands)))
(((proc,generateEventParamFuncDeclarations)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventParamFuncDeclarations {} {
    set div [diverter new]

    # set eventRefs [Event findWhere {$PSigID ne {}}]

    set events [pipe {
        InstanceStateModel findAll |
        findRelated ~ R50 |
        deRef ~ |
        relation semijoin ~ $::micca::Event |
        relation restrictwith ~ {$PSigID ne {}}
    }]

    relation foreach event $events {
        relation assign $event {Domain domainName} {Model className}\
            {Event eventName}
        $div puts "static bool\
            ${domainName}_${className}_${eventName}__EPFUNC(\
            int, char * const*, MRT_EventParams) ;"
    }

    $div return
}
----

(((chunk,harness static functions)))

[source,c]
----
<<harness static functions>>=
<%generateEventParamFuncDefinitions%>
----

(((chunk,bosal code template commands)))
(((proc,generateEventParamFuncDefinitions)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateEventParamFuncDefinitions {} {
    set div [diverter new]

    set eventRefs [Event findWhere {$PSigID ne {}}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Domain domainName} {Model className}\
            {Event eventName}
        $div puts "static bool\
            ${domainName}_${className}_${eventName}__EPFUNC("
        $div push
        $div puts "int paramc,"
        $div puts "char * const *paramv,"
        $div puts "MRT_EventParams parambuf)"
        $div pop ; $div puts "{" ; $div push

        set paramRefs [findRelated $eventRef R69 ~R79]
        set nparams [refMultiplicity $paramRefs]
        $div puts "if (paramc != $nparams) {" ; $div push
        $div puts "bslFormatToContext(wrongNumArgsMsg, paramc, $nparams) ;"
        $div puts "return false ;"
        $div pop ; $div puts "}"

        set structName ${domainName}_${className}_${eventName}__EPARAMS
        $div puts "struct $structName *params =\
                (struct $structName *)parambuf ;"

        set parameters [pipe {
            deRef $paramRefs |
            relation join ~ $::micca::Argument |
            relation project ~ Domain PSigID Name Position DataType
        }]
        set pindex 0
        set nitemsDefined false
        relation foreach parameter $parameters -ascending Position {
            relation assign $parameter {Domain domainName} {Name paramName}\
                    {DataType dataType}
            set typeinfo [GetTypeInfo $domainName $dataType params->$paramName]
            set scnfmt [dict get $typeinfo scan]
            if {$scnfmt eq {}} {
                $div puts "params->$paramName = paramv\[$pindex\] ;"
            } else {
                if {!$nitemsDefined} {
                    $div puts "int nitems ;"
                    set nitemsDefined true
                }
                set reftovar [dict get $typeinfo varref]
                if {[dict get $typeinfo basetype] eq "bool"} {
                    $div puts "nitems = bslScanBoolean(paramv\[$pindex\],\
                            $reftovar) ;"
                    set scnfmt \"bool\"
                } else {
                    $div puts "nitems = sscanf(paramv\[$pindex\],\
                        \"%\" $scnfmt, $reftovar) ;"
                }
                $div puts "if (nitems != 1) {" ; $div push
                $div puts "bslFormatToContext(failedConvertMsg,\
                        paramv\[$pindex\], $scnfmt) ;"
                $div puts "return false ;"
                $div pop ; $div puts "}"
            }

            incr pindex
        }

        $div puts "return true ;"
        $div pop ; $div puts "}"
    }

    $div return
}
----

==== Generate the state map

(((chunk,harness data types)))
(((type,BSL_StateMap)))

[source,c]
----
<<harness data types>>=
typedef struct bslstatemap {
    char const *name ;
    MRT_StateCode number ;
} BSL_StateMap ;
----

(((chunk,bosal code template commands)))
(((proc,generateStateMaps)))

[source,tcl]
----
<<bosal code template commands>>=
proc generateStateMaps {} {
    set div [diverter new]

    set stateGrps [pipe {
        InstanceStateModel findAll |
        findRelated % R50 ~R55 R57 |
        deRef % |
        relation group % States Name Number
    } {} |%]

    relation foreach stateGrp $stateGrps {
        relation assign $stateGrp {Domain domainName} {Model className} States
        $div puts "static BSL_StateMap const\
                ${domainName}_${className}__STATEMAP\[] = {"
        $div push

        relation foreach state $States -ascending Name {
            relation assign $state {Name stateName} {Number stateNum}
            $div puts "{" ; $div push

            $div puts ".name = \"$stateName\","
            $div puts ".number = $stateNum,"

            $div pop ; $div puts "},"
        }

        $div pop ; $div puts "} ;"
    }

    $div return
}
----

== Bosal header file

(((chunk,bosal data)))
(((data.headerFile)))

[source,tcl]
----
<<bosal data>>=
variable headerFile [textutil::adjust::undent {
/*
<<edit warning>>
<<copyright info>>
*/
/*
 * This file is the header file for bosal. A typical use case is to
 * include it in the file which contains the "main" function. This
 * file corresponds to:
   <<version info>>
 */

#ifndef BOSAL_H_
#define BOSAL_H_

#include <stdarg.h>

/*
 * External Functions
 */
<<harness external function declarations>>

#endif /* BOSAL_H_ */}]
----
