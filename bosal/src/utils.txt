// vim:set syntax=asciidoc:

= Utility Procedures

== Introduction
Place holder.

== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path {::bosal ::rosea::InstCmds}

    <<helper data>>
    <<helper commands>>
}
----

=== DeclError

All error notification in the package is consolidated in
the `DeclError` procedure.

[float]
==== Implementation

The `DeclError` procedure locates a format string based on the error code
and applies its arguments to it.
We use the `::throw` command to raise the error to insure that we have
consistent error code information for the package.

(((bosal,Helpers,DeclError)))
[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list MICCA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of `errcode` values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

=== Checking for Duplicates

(((bosal,Helpers,CheckDuplicate)))
[source,tcl]
----
<<helper commands>>=
proc CheckDuplicate {class args} {
    set ref [$class findById {*}$args]
    if {[isNotEmptyRef $ref]} {
        tailcall DeclError DUP_INSTANCE_NAME $class $args
    }
    return
}
----

(((error code,DUP_ELEMENT_NAME)))
[source,tcl]
----
<<error code formats>>=
DUP_INSTANCE_NAME    {an element of class, "%s", already exists with\
        attributes, "%s"}
----

=== Handling Configuration Errors

One of the design elements of the configuration DSL is the use of
the `bosal` platform model to hold the configuration information.
This design approach allows us to encode the rules for what is a valid
domain configuration into the constraints.
Any attempt to define domain elements that violate those rules
will be caught at the end of the relvar transaction that end
the `configure` command.

The problem with this approach is that the error messages the are
returned refer to the classes of the platform model not those of
the domain we were attempting to define.

We will mitigate this problem by capturing the result returned by
TclRAL and turning it into error messages that are more meaningful
to the task of configuring a domain.
Unfortunately,
the messages produced by TclRAL are intended to be human readable,
so we will have to parse them into a form that is easier to deal
with programmatically.
Fortunately, the messages are very regular in structure so
the parsing code need not be very sophisticated.

Our strategy is to extract only the essential information from the
error message and then map the information onto a more meaningful error
message.
Part of what we want to include in the error message is the values
from the tuples failing the constraint.
These values contain information the user entered rather than the
abstractions of the platform model.

The essential information mapping is shown below.
Naturally enough, we hold it in a relvar.

[source,tcl]
----
<<config data>>=
relvar create Config_DataError {
    Relationship        string
    RefClass            string
    RefType             string
    Format              string
} {Relationship RefClass RefType}
----

The *Relationship* attribute is the name of the relationship in the
platform model that failed the constraint check.
The *RefClass* attribute is the platform model class that has the tuples
that failed the constraint check.
The *RefType* attribute defines the way in which the constraint failed.
The *Format* attribute is a string that contains the text of the
error message that we want to display.
The text in the *Format* attribute may also contain variable references
to attributes in the tuple of *RefClass* that failed.
The variable references in the *Format* will be substituted
with the values from the failing tuples in order to give specifics of
the error back to the user.

[float]
===== Implementation

The design of the `HandleConfigError` procedure is shown below.
It is a nested iteration over the lines of the error result, pulling
off the constraint violation details and then iterating over the
tuples that were found in the violation.

(((bosal,Config,HandleConfigError)))
[source,tcl]
----
<<config commands>>=
proc HandleConfigError {result} {
    set lines [split [string trimright $result] \n]
    set nlines [llength $lines]
    set lineno 0
    upvar #0 ::bosal::@Config@::errcount errcount
    while {$lineno < $nlines} {
        <<HandleConfigError: examine one failure>>
    }

    return
}
----

The information in the TclRAL error message is simple enough
and well structured enough that a regular expression can be used
to match and extract the interesting parts.

[source,tcl]
----
<<HandleConfigError: examine one failure>>=
set line [lindex $lines $lineno]
incr lineno
if {[regexp {^for[^:]+([^(]+)\(.+\), in relvar (.+)$} $line\
        match rnum refclass]} {
    set rnum [namespace tail $rnum]
    set refclass [namespace tail $refclass]

    # Now iterate over the "tuple" lines that follow the constraint message.
    while {$lineno < $nlines} {
        set tupline [lindex $lines $lineno]
        if {[regexp {^tuple {(.+)} (.+)$} $tupline match tuple phrase]} {
            incr lineno
            incr errcount
            <<HandleConfigError: examine one tuple>>
            <<HandleConfigError: format error message>>
        } else {
            break
        }
    }
} elseif {[regexp {procedural contraint, "([^"]+)", failed} $line match\
        constraint]} {
    # There is only one procedural constraint, R74C.
    # If an error is detected in the procedural constraint script,
    # messages will be printed there.
    log::error $result
    incr errcount
} else {
    log::error $result
    incr errcount
}
----

We match the phrase in the tuple message to create an enumeration of
the types of constraint violations.
These are just a bit simpler to handle and look up.

[source,tcl]
----
<<HandleConfigError: examine one tuple>>=
if {[string match {is not referenced*} $phrase]} {
    set reftype notrefed
} elseif {[string match {references no*} $phrase]} {
    set reftype refnone
} elseif {[string match {is referenced by multiple*} $phrase]} {
    set reftype refedmult
} elseif {[string match {*to by multiple*} $phrase]} {
    set reftype multrefed
} elseif {[string match {is not referred to*} $phrase]} {
    set reftype notrefto
} else {
    log::error "unknown constraint phrasing, \"$phrase\""
    continue
}
----

Finally, we look up the format information and generate an error message.
Using the `dict with` command allows us to take the tuple value from the
error message, treat it like a dictionary and get the values into
Tcl variable.
The `subst` command then will perform the variable substitutions in the
format string.

[source,tcl]
----
<<HandleConfigError: format error message>>=
set cde [relvar restrictone Config_DataError Relationship $rnum RefClass\
        $refclass RefType $reftype]
if {[relation isnotempty $cde]} {
    dict with tuple {
        log::error [subst -nocommands [relation extract $cde Format]]
    }
} else {
    log::error "$line\n$tupline"
}
----

We now need to enumerate all the platform model constraints that can be violated
and supply messages that provide less abstract and more useful user error
messages.
Because of the way the configuration data is stored into the platform model
classes,
not all violations are even possible.

[source,tcl]
----
<<config data>>=
relvar insert Config_DataError {
    Relationship        R4
    RefClass            Domain
    RefType             notrefed
    Format              {in harness, $Harness, domain, $Name, has no classes}
}
----
