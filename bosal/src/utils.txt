// vim:set syntax=asciidoc:

== Utility Code

The code in this section implements a set of utility functions
used by `bosal` generated test harnesses.

=== Trimming White Space

Since responses in the communciations protocol are whitespace separated
words,
it is easier to generate a trailing space character at the end of each
word added to a response.
After adding the final word, this space can be trimmed off.
This is simplier and avoids having to know which word added to a response
is the first one.
The following function performs the trimming.

(((chunk,harness forward function declarations)))
(((function,bslTrimSpaceRight)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTrimSpaceRight(char *const buf) ;
----

(((chunk,harness static function definitions)))
(((function,bslTrimSpaceRight)))

[source,c]
----
<<harness static function definitions>>=
static void
bslTrimSpaceRight(
    char *const buf)
{
    for (char *end = buf + strlen(buf) - 1 ;
            end > buf && isspace(*end) ; end--) {
        *end = ASCII_NUL ;
    }
}
----

=== Response Context [[response-context]]

To help build up responses,
we define the notion of a _response context_.
A response context is a set of buffers that can be used
to accumulate output in a nested fashion.
Since the responses generated by `bosal` are grouped into _words_
that are separated by whitespace,
it convenient to have distinct areas into which formatted output
can be generated before deciding if the output must be _quoted_
to make it a single word.
In this way,
when words are added to a context after the formatting is accomplished
it is much easier to determine if the new word contains characters
that must be quoted.

A context is defined as a character buffer, a current location
in the buffer where the next character is to be placed, and
the number of bytes remaining in the buffer.

[source,c]
----
<<harness data types>>=
typedef struct bslbufcontext {
    char buf[BUFSIZ] ;
    char *location ;
    size_t remaining ;
} BSL_BufContext ;
----

[source,c]
----
<<harness data types>>=
typedef enum {
    CmdContext = 0,
    TraceContext,
    InstrContext,
    FatalContext,
    NUMContexts         // must be last
} BSL_ContextId ;
----

We define an array of buffer context data structures to use as a stack of
contexts.

[source,c]
----
<<harness static data>>=
static BSL_BufContext contextStack[NUMContexts][BSL_NESTLIMIT] ;
static BSL_BufContext *contextTOS[NUMContexts] ;
----

The `bslBeginResponse()` function is used to initialize the context
in preparation for generated a response.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslBeginResponse(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslBeginResponse(BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;
    contextTOS[cntx] = &contextStack[cntx][0] ;     // <1>
    bslInitBufContext(contextTOS[cntx]) ;
}
----
<1> Beginning a response causes any other partial response to be
abandoned.

A response is ended by invoking `bslEndResponse()`.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bslEndResponse(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static inline int
bslEndResponse(BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;

    BSL_BufContext *bottom = &contextStack[cntx][0] ;

    for (BSL_BufContext *top = contextTOS[cntx] ; top > bottom ;
            top = contextTOS[cntx]) {                               // <1>
        bslPopContext(cntx) ;
    }
    return fprintf(bslCmdStream, "%s\n", bslContextGetBuf(bottom)) ;
}
----
<1> Ending a response performs an implicit `pop` of the entire
context stack.

When a new word is being formulated in a response,
the context is pushed using `bslPushContext()`.
Future response text is then placed in a new context so that it can
be later evaluated to determine if it is necessary to quote the
text to maintain word boundaries.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslPushContext(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslPushContext(
    BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;

    BSL_BufContext *bottom = &contextStack[cntx][0] ;
    BSL_BufContext *top = contextTOS[cntx] ;

    assert(top != NULL) ;
    assert(top < bottom + BSL_NESTLIMIT) ;

    if (top >= bottom + BSL_NESTLIMIT) {
        fprintf(stderr, "buffer context stack overflow\n") ;
        abort() ;
    }
    top += 1 ;
    contextTOS[cntx] = top ;
    bslInitBufContext(top) ;
}
----

When a word context is completed,
it is popped using `bslPopContext()`.
This adds any word accumulated in the context to the accumulated
response,
quoting things as necessary to adhere to the protocol.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslPopContext(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslPopContext(BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;

    BSL_BufContext *bottom = &contextStack[cntx][0] ;
    BSL_BufContext *top = contextTOS[cntx] ;

    assert(top != NULL) ;
    assert(top > bottom) ;

    if (top <= bottom) {
        fprintf(stderr, "buffer context stack underflow\n") ;
        abort() ;
    }

    bslTrimBufContextRight(top) ;
    char *currBuf = bslContextGetBuf(top) ;
    top -= 1 ;
    contextTOS[cntx] = top ;
    bsl_AddWord(top, currBuf) ;
}
----

A context may also be reset.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static inline void bslResetContext(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static inline void
bslResetContext(BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;

    bslInitBufContext(contextTOS[cntx]) ;
}
----

Responses are built up by adding words to the context.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static inline void bslAddWordToContext(BSL_ContextId cntx, char const *word) ;
----

[source,c]
----
<<harness static function definitions>>=
static inline void
bslAddWordToContext(BSL_ContextId cntx, char const *word)
{
    assert(cntx < NUMContexts) ;

    bsl_AddWord(contextTOS[cntx], word) ;
}
----

Initializing a buffer context sets all the bookkeeping back to the
beginning of the buffer.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslInitBufContext(BSL_BufContext *bufc) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslInitBufContext(BSL_BufContext *bufc)
{
    assert(bufc != NULL) ;

    bufc->location = bufc->buf ;
    *bufc->location = ASCII_NUL ;
    bufc->remaining = sizeof(bufc->buf) ;
}
----

Adding words means we must surround it by braces if it needs to be
quoted.


(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bsl_AddWord(BSL_BufContext *bufc, char const *word) ;
----

[source,c]
----
<<harness static function definitions>>=
static int
bsl_AddWord(
    BSL_BufContext *bufc,
    char const *word)
{
    int nbytes = snprintf(bufc->location, bufc->remaining,
            bslQuoteWord(word) ? "{%s} " : "%s ", word) ;

    if (nbytes < 0 || nbytes >= bufc->remaining) {
        return -1 ;
    } else {
        bufc->remaining -= nbytes ;
        bufc->location += nbytes ;
    }

    return nbytes ;
}
----

When a context is popped,
trailing whitespace is removed.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTrimBufContextRight(BSL_BufContext *bufc) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslTrimBufContextRight(
    BSL_BufContext *bufc)
{
    while (bufc->location > bufc->buf) {
        if (isspace(*(bufc->location - 1))) {
            *--bufc->location = ASCII_NUL ;
        } else {
            break ;
        }
    }
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static char *bslContextGetBuf(BSL_BufContext *bufc) ;
----

[source,c]
----
<<harness static function definitions>>=
static inline char *
bslContextGetBuf(
    BSL_BufContext *bufc)
{
    return bufc->buf ;
}
----

Finally, the heavy lifting is done by the formatted I/O functions
for a context.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bslVformatToContext(BSL_ContextId cntx, char const *format,
        va_list args) ;
----

[source,c]
----
<<harness static function definitions>>=
static int
bslVformatToContext(
    BSL_ContextId cntx,
    char const *format,
    va_list args)
{
    assert(cntx < NUMContexts) ;

    BSL_BufContext *bufc = contextTOS[cntx] ;

    int nbytes = vsnprintf(bufc->location, bufc->remaining, format, args) ;

    if (nbytes < 0 || nbytes >= bufc->remaining) {
        return -1 ;
    } else {
        bufc->remaining -= nbytes ;
        bufc->location += nbytes ;
    }

    return nbytes ;
}
----

[source,c]
----
<<harness static function definitions>>=
static int bslFormatToContext(BSL_ContextId cntx, char const *format, ...) ;
----

[source,c]
----
<<harness static function definitions>>=
static int
bslFormatToContext(
    BSL_ContextId cntx,
    char const *format,
    ...)
{
    va_list params ;
    va_start(params, format) ;
    int nbytes = bslVformatToContext(cntx, format, params) ;
    va_end(params) ;

    return nbytes ;
}
----

The following function determines if a text string needs to be quoted
in order to be considered a word.
It accomplished this by scanning the string until it can resolve whether
it contains embedded white space or embedded braces.
If embedded brace characters are found,
then scanning continues in an attempt to find matching pairs of braces.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQuoteWord(char const *pWord) ;
----

[source,c]
----
<<harness static function definitions>>=
static bool
bslQuoteWord(
    char const *pWord)
{
    assert(pWord != NULL) ;
    if (strlen(pWord) == 0) {
        return true ; // must quote the empty string
    }

    enum {
        OutOfQuote,
        InQuote
    } quoteState = OutOfQuote ;
    int quoteCount = 0 ;

    for (char c = *pWord++ ; c != ASCII_NUL ; c = *pWord++) {
        if (c == '\\') {
            pWord++ ;
            continue ;
        }
        switch (quoteState) {
        case OutOfQuote:
            if (isspace(c)) {
                return true ;
            } else if (c == BEGIN_QUOTE) {
                quoteCount++ ;
                quoteState = InQuote ;
            }
            break; 

        case InQuote:
            if (c == BEGIN_QUOTE) {
                quoteCount++ ;
            } else if (c == END_QUOTE) {
                assert(quoteCount > 0) ;
                if (--quoteCount == 0) {
                    quoteState = OutOfQuote ;
                }
            }
            break; 
        }
    }
    return quoteCount == 0 ? false : true ;
}
----

Scanning for boolean values we treat as special.
We want to accept the usual _true_ and _false_, but also
allow for numerical zero and one.

[source,c]
----
<<harness static function definitions>>=
static int bslScanBoolean(char const *value, bool *result) ;
----

[source,c]
----
<<harness static function definitions>>=
static int
bslScanBoolean(
    char const *value,
    bool *result)
{
    assert(value != NULL) ;
    assert(result != NULL) ;

    if (strcasecmp(value, "true") == 0) {
        *result = true ;
    } else if (strcasecmp(value, "false") == 0) {
        *result = false ;
    } else {
        char *end ;
        unsigned num = strtoul(value, &end, 0) ;
        if (*end == ASCII_NUL) {
            if (num == 0) {
                *result = false ;
            } else if (num == 1) {
                *result = true ;
            } else {
                return 0 ;
            }
        } else {
            return 0 ;
        }
    }

    return 1 ;
}
----

=== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

==== Text diversion [[text-diversion]]

The first time I encountered the idea of a text diversion was in
the venerable `m4` macro processor on UNIX.
The concept is to be able to have multiple streams being accumulated
and then later bring the diverted text back into the desired order.

For our usage here in generating code,
we need a way to make code indentation easier to manage so that
the generated code looks natural and as if hand coded.
So, we employ the idea of a text diversion.
When a new code block entered,
we *push* the diversion as a stack.
This causes subsequent text to be held separately.
When the diversion is later *popped*,
the text is placed into the next lowest stream, but indented to the
proper level (given the number of previously occuring pushes).

In Tcl, this is all rather easy to accomplish since _tcllib_ contains
all the components we need.
We will use in-memory FIFO channels to hold diverted text.
We use a stack to keep track of the stack of file channel handles.
Finally, indentation is handled by text utilities in _tcllib_.
The code is formulated as a TclOO class called, `diverter`.

(((class,diverter)))

[source,tcl]
----
<<bosal helper commands>>=
package require tcl::chan::events
package require tcl::chan::fifo
package require struct::stack
package require oo::util
package require textutil::adjust

oo::class create diverter {
    variable chan_stack
    constructor {{prefix {    }}} {
        my variable level_prefix
        set level_prefix $prefix
        classvariable stack_counter                             ; # <1>
        set chan_stack [::struct::stack s_[incr stack_counter]]
        $chan_stack push [::tcl::chan::fifo]
    }
    destructor {
        foreach dchan [$chan_stack get] {
            chan close $dchan
        }
        $chan_stack destroy
    }
    method puts {args} {
        set nargs [llength $args]
        set curr_chan [$chan_stack peek]
        if {$nargs == 1} {
            chan puts $curr_chan [lindex $args 0]
        } elseif {$nargs == 2} {
            lassign $args opt str
            chan puts $opt $curr_chan $str
        } else {
            error "wrong # of arguments: expected, \"puts ?-nonewline? string\""
        }
    }
    method push {} {
        $chan_stack push [::tcl::chan::fifo]
    }
    method pop {} {
        set top_chan [$chan_stack pop]
        chan flush $top_chan

        set curr_chan [$chan_stack peek]
        my variable level_prefix
        set diverted [::textutil::adjust::indent\
                [chan read $top_chan] $level_prefix]
        chan puts $curr_chan $diverted

        chan close $top_chan
    }
    method undivert {} {
        while {[$chan_stack size] > 1} {
            my pop
        }
        set curr_chan [$chan_stack peek]
        chan flush $curr_chan
        return [chan read $curr_chan]
    }
    method return {} {
        set result [my undivert]
        my destroy
        return -level 2 $result         ; # <2>
    }
}
----
<1> Used to make unique names for stack component of the diverter.
<2> Note that the `return` method returns all the diverted text,
destoys itself and returns out of the calling procedure.
This is convenient since the diversions are used to end the
procedures that are embedded in the template expansion and it results
in all the accumulated output being placed into the expansion.

==== Data type procedures

We need some common code to process ``C'' data types from the
`micca` domains.

Usually, we need to know the base ``C'' type of something.
Since it is possible to create a type alias for a type alias,
a bit of recursion is needed to resolve down to the underlying
``C'' data type.

(((procedure,UnaliasType)))

[source,tcl]
----
<<bosal helper commands>>=
proc UnaliasType {domain typename} {
    set aliasRef [TypeAlias findById Domain $domain TypeName $typename]
    if {[isEmptyRef $aliasRef]} {
        return $typename
    } else {
        return [UnaliasType $domain [readAttribute $aliasRef TypeDefinition]]
    }
}
----

The code generator has to create conversion wrapper functions for
``C'' data types.
This procedure summarizes the information needed by code generation.
This area may need additional work.

[source,tcl]
----
<<bosal helper commands>>=
# return a dictionary keyed by:
# print -- format string
# scan -- format string
# basetype -- unaliased type
# type -- scalar, string or array
# base  -- base type of array or string if type is not scalar
# dimension  -- array or string dimension if type is not scalar
# declaration -- variable declaration with the provided variable name
# varref -- reference to the provided variable name

proc GetTypeInfo {domain implType varName} {
    set basetype [UnaliasType $domain $implType]
    set info [typeCheck assignmentType $basetype]
    dict set info basetype $basetype
    switch -exact -- [dict get $info type] {
        scalar {
            set fmt [relvar restrictone FormatMap ImplType $basetype]
            if {[relation isempty $fmt]} {
                dict set info print "\"i\""
                dict set info scan "\"i\""
            } else {
                dict set info print [relation extract $fmt Print]
                dict set info scan [relation extract $fmt Scan]
            }
            dict set info varref &$varName
        }
        string {
            dict set info print "\"s\""
            dict set info scan "\"s\""
            dict set info varref $varName
        }
        array {
            set fmt [relvar restrictone FormatMap ImplType\
                [dict get $info base]]
            if {[relation isempty $fmt]} {
                dict set info print "\"d\""
                dict set info scan "\"d\""
            } else {
                dict set info print [relation extract $fmt Print]
                dict set info scan [relation extract $fmt Scan]
            }
            dict set info varref $varName
        }
    }

    dict set info declaration [typeCheck composeDeclaration $basetype $varName]

    return $info
}
----

This is a simple mapping relation for how to format and scan ``C''
basic data types.

[source,tcl]
----
<<bosal helper data>>=
# Create a simple map that maps "C" implementation types onto
# printf/scanf format strings.
relvar create FormatMap {
    ImplType string
    Print string
    Scan string
} ImplType

relvar set FormatMap [relation table {
    ImplType string             Print string         Scan  string   } {
    int                         {"d"}                {"i"}              } {
    unsigned                    {"u"}                {"i"}              } {
    {unsigned int}              {"u"}                {"i"}              } {
    short                       {"hd"}               {"hi"}             } {
    {short int}                 {"hd"}               {"hi"}             } {
    {unsigned short}            {"hu"}               {"hi"}             } {
    {unsigned short int}        {"hu"}               {"hi"}             } {
    long                        {"ld"}               {"li"}             } {
    {long int}                  {"ld"}               {"li"}             } {
    {unsigned long}             {"lu"}               {"li"}             } {
    {unsigned long int}         {"lu"}               {"li"}             } {
    size_t                      {"z"}                {"z"}              } {
    {long long}                 {"lld"}              {"lli"}            } {
    {long long int}             {"lld"}              {"lli"}            } {
    {unsigned long long}        {"llu"}              {"lli"}            } {
    {unsigned long long int}    {"llu"}              {"lli"}            } {
    {char *}                    {"s"}                {}                 } {
    {char const *}              {"s"}                {}                 } {
    {const char *}              {"s"}                {}                 } {
    {void *}                    {"p"}                {"p"}              } {
    {const void *}              {"p"}                {"p"}              } {
    {void const *}              {"p"}                {"p"}              } {
    float                       {"g"}                {"g"}              } {
    double                      {"lg"}               {"lg"}             } {
    {long double}               {"Lg"}               {"Lg"}             } {
    char                        {"hhd"}              {"hhi"}            } {
    {unsigned char}             {"hhu"}              {"hhi"}            } {
    void                        void                 {}                 } {
    bool                        {"u"}                {"u"}              } {
    uint8_t                     PRIu8                SCNi8              } {
    uint16_t                    PRIu16               SCNi16             } {
    uint32_t                    PRIu32               SCNi32             } {
    uint64_t                    PRIu64               SCNi64             } {
    int8_t                      PRId8                SCNi8              } {
    int16_t                     PRId16               SCNi16             } {
    int32_t                     PRId32               SCNi32             } {
    int64_t                     PRId64               SCNi64             } {
    intmax_t                    PRIdMAX              SCNiMAX            } {
    uintmax_t                   PRIuMAX              SCNiMAX            } {
    typename(time_t)            {"ld"}               {"li"}             } {
    MRT_ClassId                 {"hu"}               {"hi"}             } {
    MRT_AssignerId              {"hu"}               {"hi"}             } {
    MRT_InstId                  {"hu"}               {"hi"}             } {
    MRT_AttrId                  {"hu"}               {"hi"}             } {
    MRT_AttrSize                {"z"}                {"z"}              } {
    MRT_AttrOffset              {"lu"}               {"li"}             } {
    MRT_DelayTime               PRIu32               SCNi32             } {
    MRT_EventCode               PRIu8                SCNi8              } {
    MRT_StateCode               PRId8                SCNi8              } ]
----
