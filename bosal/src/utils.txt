// vim:set syntax=asciidoc:

== Utility Code

The code in this section implements a set of utility functions
used by `bosal` generated test harnesses.

=== Trimming White Space

Since responses in the communciations protocol are whitespace separated
words,
it is easier to generate a trailing space character at the end of each
word added to a response.
After adding the final word, this space can be trimmed off.
This is simplier and avoids having to know which word added to a response
is the first one.
The following function performs the trimming.

(((chunk,harness forward function declarations)))
(((function,bslTrimSpaceRight)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTrimSpaceRight(char *const buf) ;
----

(((chunk,harness static function definitions)))
(((function,bslTrimSpaceRight)))

[source,c]
----
<<harness static function definitions>>=
static void
bslTrimSpaceRight(
    char *const buf)
{
    for (char *end = buf + strlen(buf) - 1 ;
            end > buf && isspace(*end) ; end--) {
        *end = ASCII_NUL ;
    }
}
----

=== Response Context [[response-context]]

To help build up responses,
we define the notion of a _response context_.
A response context is a set of buffers that can be used
to accumulate output in a nested fashion.
Since the responses generated by `bosal` are grouped into _words_
that are separated by whitespace,
it convenient to have distinct areas into which formatted output can be
generated before deciding if the output contains embedded white space and must
be _quoted_ to make it a single word.
In this way,
when words are added to a context after the formatting is accomplished
it is much easier to determine if the new word contains characters
that must be quoted.

A context is defined as a character buffer, a current location
in the buffer where the next character is to be placed, and
the number of bytes remaining in the buffer.

(((chunk,harness data types)))

[source,c]
----
<<harness data types>>=
typedef struct bslbufcontext {
    char buf[BUFSIZ] ;
    char *location ;
    size_t remaining ;
} BSL_BufContext ;
----

A context stack is simply an array of buffer contexts with a pointer
to the current position in the stack.

The stacking operations are implemented in an array of buffer contexts
by manipulating the pointer to the current position.
We need to define the depth of the context stack that will be supported.
Static allocation is sufficient here since we know what depth responses
require.

(((chunk,harness constants)))

[source,c]
----
<<harness constants>>=
#ifndef BSL_NESTLIMIT
#   define  BSL_NESTLIMIT   4   /* maximum depth of text diversions */
#endif /* BSL_NESTLIMIT */
----

So a context stack consists of the storage for the buffer contexts
and a pointer to the buffer context that is the current one.

(((chunk,harness data types)))

[source,c]
----
<<harness data types>>=
typedef struct bslcontextstack {
    struct bslbufcontext *current ;
    struct bslbufcontext stack[BSL_NESTLIMIT] ;
} BSL_ContextStack ;
----

There are four different types of responses generated by a test harness.

(((chunk,harness data types)))

[source,c]
----
<<harness data types>>=
typedef enum {
    CmdContext = 0,
    TraceContext,
    InstrContext,
    FatalContext,
    NUMContexts         // must be last
} BSL_ContextId ;
----

We define an array of context stack data structures to use as the context
for each type of response from the test harness.

(((chunk,harness static data)))

[source,c]
----
<<harness static data>>=
static BSL_ContextStack responseContexts[NUMContexts] ;
----

The `bslBeginResponse()` function is used to initialize the context
in preparation for generated a response.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslBeginResponse(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslBeginResponse(
    BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;
    if (cntx >= NUMContexts) {
        fprintf(stderr, "%s: invalid response context number, \"%d\"\n",
                __func__, cntx) ;
        abort() ;
    }
    BSL_ContextStack *stack = &responseContexts[cntx] ;
    stack->current = stack->stack ;                     // <1>
    bslInitBufContext(stack->current) ;
}
----
<1> Beginning a response causes any other partial response to be
abandoned as we reset the current context to be the bottom of the stack.

A response is ended by invoking `bslEndResponse()`.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bslEndResponse(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static inline int
bslEndResponse(
    BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;
    if (cntx >= NUMContexts) {
        fprintf(stderr, "%s: invalid response context number, \"%d\"\n",
                __func__, cntx) ;
        abort() ;
    }

    BSL_ContextStack *stack = &responseContexts[cntx] ;

    while (stack->current > stack->stack) {
        bslContextStackPop(stack) ;                     // <1>
    }
    bslTrimBufContextRight(stack->current) ;

    return fprintf(bslCmdStream, "%s\n", stack->current->buf) ;
}
----
<1> Ending a response performs an implicit `pop` of the entire
context stack.

When a new word is being formulated in a response,
the context is pushed using `bslPushContext()`.
Future response text is then placed in a new context so that it can
be later evaluated to determine if it is necessary to quote the
text to maintain word boundaries.
Thus context pushes correspond to word boundaries in the response.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslContextStackPush(BSL_ContextStack *stack) ;
static void bslPushContext(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslContextStackPush(
    BSL_ContextStack *stack)
{
    assert(stack != NULL) ;
    assert(stack->current < stack->stack + BSL_NESTLIMIT) ;

    if (stack->current >= stack->stack + BSL_NESTLIMIT) {
        fprintf(stderr, "%s: buffer context stack overflow\n", __func__) ;
        abort() ;
    }
    stack->current++ ;
    bslInitBufContext(stack->current) ;
}

static void
bslPushContext(
    BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;
    if (cntx >= NUMContexts) {
        fprintf(stderr, "%s: invalid response context number, \"%d\"\n",
                __func__, cntx) ;
        abort() ;
    }

    BSL_ContextStack *stack = &responseContexts[cntx] ;
    bslContextStackPush(stack) ;
}
----

When a word context is completed,
it is popped using `bslPopContext()`.
This adds any word accumulated in the context to the accumulated
response,
quoting things as necessary to adhere to the protocol.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslContextStackPop(BSL_ContextStack *stack) ;
static void bslPopContext(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslContextStackPop(
    BSL_ContextStack *stack)
{
    assert(stack != NULL) ;
    assert(stack->current > stack->stack) ;

    if (stack->current <= stack->stack) {
        fprintf(stderr, "buffer context stack underflow\n") ;
        abort() ;
    }

    char *currBuf = stack->current->buf ;
    bslTrimBufContextRight(stack->current) ;
    stack->current-- ;
    bsl_AddWord(stack->current, currBuf) ;
}

static void
bslPopContext(
    BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;
    if (cntx >= NUMContexts) {
        fprintf(stderr, "%s: invalid response context number, \"%d\"\n",
                __func__, cntx) ;
        abort() ;
    }

    BSL_ContextStack *stack = &responseContexts[cntx] ;
    bslContextStackPop(stack) ;
}
----

A context may also be reset.
This is useful in those cases where a response is being built up
and it is necessary to clear things out because of an exceptional condition.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static inline void bslResetContext(BSL_ContextId cntx) ;
----

[source,c]
----
<<harness static function definitions>>=
static inline void
bslResetContext(
    BSL_ContextId cntx)
{
    assert(cntx < NUMContexts) ;
    if (cntx >= NUMContexts) {
        fprintf(stderr, "%s: invalid response context number, \"%d\"\n",
                __func__, cntx) ;
        abort() ;
    }

    BSL_ContextStack *stack = &responseContexts[cntx] ;
    bslInitBufContext(stack->current) ;
}
----

Responses are built up by adding words to the context.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static inline void bslAddWordToContext(BSL_ContextId cntx, char const *word) ;
----

[source,c]
----
<<harness static function definitions>>=
static inline void
bslAddWordToContext(
    BSL_ContextId cntx,
    char const *word)
{
    assert(cntx < NUMContexts) ;
    if (cntx >= NUMContexts) {
        fprintf(stderr, "%s: invalid response context number, \"%d\"\n",
                __func__, cntx) ;
        abort() ;
    }

    BSL_ContextStack *stack = &responseContexts[cntx] ;
    bsl_AddWord(stack->current, word) ;
}
----

Initializing a buffer context sets all the bookkeeping back to the
beginning of the buffer.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslInitBufContext(BSL_BufContext *bufc) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslInitBufContext(
    BSL_BufContext *bufc)
{
    assert(bufc != NULL) ;

    bufc->location = bufc->buf ;
    *bufc->location = ASCII_NUL ;
    bufc->remaining = sizeof(bufc->buf) ;
}
----

Adding words means we must surround it by braces if it needs to be
quoted.


(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bsl_AddWord(BSL_BufContext *bufc, char const *word) ;
----

[source,c]
----
<<harness static function definitions>>=
static int
bsl_AddWord(
    BSL_BufContext *bufc,
    char const *word)
{
    int nbytes = snprintf(bufc->location, bufc->remaining,
            bslQuoteWord(word) ? "{%s} " : "%s ", word) ;

    if (nbytes < 0 || nbytes >= bufc->remaining) {
        return -1 ;
    } else {
        bufc->remaining -= nbytes ;
        bufc->location += nbytes ;
    }

    return nbytes ;
}
----

When a context is popped,
trailing whitespace is removed.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTrimBufContextRight(BSL_BufContext *bufc) ;
----

[source,c]
----
<<harness static function definitions>>=
static void
bslTrimBufContextRight(
    BSL_BufContext *bufc)
{
    while (bufc->location > bufc->buf) {
        if (isspace(*(bufc->location - 1))) {
            *--bufc->location = ASCII_NUL ;
        } else {
            break ;
        }
    }
}
----

Finally, the heavy lifting is done by the formatted I/O functions
for a context.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bslVformatToContext(BSL_ContextId cntx, char const *format,
        va_list args) ;
----

[source,c]
----
<<harness static function definitions>>=
static int
bslVformatToContext(
    BSL_ContextId cntx,
    char const *format,
    va_list args)
{
    assert(cntx < NUMContexts) ;
    if (cntx >= NUMContexts) {
        fprintf(stderr, "%s: invalid response context number, \"%d\"\n",
                __func__, cntx) ;
        abort() ;
    }

    BSL_ContextStack *stack = &responseContexts[cntx] ;
    BSL_BufContext *bufc = stack->current ;

    int nbytes = vsnprintf(bufc->location, bufc->remaining, format, args) ;

    if (nbytes < 0 || nbytes >= bufc->remaining) {
        return -1 ;
    } else {
        bufc->remaining -= nbytes ;
        bufc->location += nbytes ;
    }

    return nbytes ;
}
----

[source,c]
----
<<harness forward function declarations>>=
static int bslFormatToContext(BSL_ContextId cntx, char const *format, ...) ;
----

[source,c]
----
<<harness static function definitions>>=
static int
bslFormatToContext(
    BSL_ContextId cntx,
    char const *format,
    ...)
{
    va_list params ;
    va_start(params, format) ;
    int nbytes = bslVformatToContext(cntx, format, params) ;
    va_end(params) ;

    return nbytes ;
}
----

The following function determines if a text string needs to be quoted
in order to be considered a word.
It accomplished this by scanning the string until it can resolve whether
it contains embedded white space or embedded braces.
If embedded brace characters are found,
then scanning continues in an attempt to find matching pairs of braces.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQuoteWord(char const *pWord) ;
----

[source,c]
----
<<harness static function definitions>>=
static bool
bslQuoteWord(
    char const *pWord)
{
    assert(pWord != NULL) ;
    if (strlen(pWord) == 0) {
        return true ; // must quote the empty string
    }

    enum {
        OutOfQuote,
        InQuote
    } quoteState = OutOfQuote ;
    int quoteCount = 0 ;

    for (char c = *pWord++ ; c != ASCII_NUL ; c = *pWord++) {
        if (c == '\\') {
            pWord++ ;
            continue ;
        }
        switch (quoteState) {
        case OutOfQuote:
            if (isspace(c)) {
                return true ;
            } else if (c == BEGIN_QUOTE) {
                quoteCount++ ;
                quoteState = InQuote ;
            }
            break; 

        case InQuote:
            if (c == BEGIN_QUOTE) {
                quoteCount++ ;
            } else if (c == END_QUOTE) {
                assert(quoteCount > 0) ;
                if (--quoteCount == 0) {
                    quoteState = OutOfQuote ;
                }
            }
            break; 
        }
    }
    return quoteCount == 0 ? false : true ;
}
----

Scanning for boolean values we treat as special.
We want to accept the usual _true_ and _false_, but also
allow for numerical zero and one.

[source,c]
----
<<harness static function definitions>>=
static int bslScanBoolean(char const *value, bool *result) ;
----

[source,c]
----
<<harness static function definitions>>=
static int
bslScanBoolean(
    char const *value,
    bool *result)
{
    assert(value != NULL) ;
    assert(result != NULL) ;

    if (strcasecmp(value, "true") == 0) {
        *result = true ;
    } else if (strcasecmp(value, "false") == 0) {
        *result = false ;
    } else {
        char *end ;
        unsigned num = strtoul(value, &end, 0) ;
        if (*end == ASCII_NUL) {
            if (num == 0) {
                *result = false ;
            } else if (num == 1) {
                *result = true ;
            } else {
                return 0 ;
            }
        } else {
            return 0 ;
        }
    }

    return 1 ;
}
----

=== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

==== Text diversion [[text-diversion]]

The first time I encountered the idea of a text diversion was in
the venerable `m4` macro processor on UNIX.
The concept is to be able to have multiple streams being accumulated
and then later bring the diverted text back into the desired order.

For our usage here in generating code,
we need a way to make code indentation easier to manage so that
the generated code looks natural and as if hand coded.
So, we employ the idea of a text diversion.
When a new code block entered,
we *push* the diversion as a stack.
This causes subsequent text to be held separately.
When the diversion is later *popped*,
the text is placed into the next lowest stream, but indented to the
proper level (given the number of previously occuring pushes).

In Tcl, this is all rather easy to accomplish since _tcllib_ contains
all the components we need.
We will use in-memory FIFO channels to hold diverted text.
We use a stack to keep track of the stack of file channel handles.
Finally, indentation is handled by text utilities in _tcllib_.
The code is formulated as a TclOO class called, `diverter`.

(((class,diverter)))

[source,tcl]
----
<<bosal helper commands>>=
package require tcl::chan::events
package require tcl::chan::fifo
package require struct::stack
package require oo::util
package require textutil::adjust

oo::class create diverter {
    variable chan_stack
    constructor {{prefix {    }}} {
        my variable level_prefix
        set level_prefix $prefix
        classvariable stack_counter                             ; # <1>
        set chan_stack [::struct::stack s_[incr stack_counter]]
        $chan_stack push [::tcl::chan::fifo]
    }
    destructor {
        foreach dchan [$chan_stack get] {
            chan close $dchan
        }
        $chan_stack destroy
    }
    method puts {args} {
        set nargs [llength $args]
        set curr_chan [$chan_stack peek]
        if {$nargs == 1} {
            chan puts $curr_chan [lindex $args 0]
        } elseif {$nargs == 2} {
            lassign $args opt str
            chan puts $opt $curr_chan $str
        } else {
            error "wrong # of arguments: expected, \"puts ?-nonewline? string\""
        }
    }
    method push {} {
        $chan_stack push [::tcl::chan::fifo]
    }
    method pop {} {
        set top_chan [$chan_stack pop]
        chan flush $top_chan

        set curr_chan [$chan_stack peek]
        my variable level_prefix
        set diverted [::textutil::adjust::indent\
                [chan read $top_chan] $level_prefix]
        chan puts $curr_chan $diverted

        chan close $top_chan
    }
    method undivert {} {
        while {[$chan_stack size] > 1} {
            my pop
        }
        set curr_chan [$chan_stack peek]
        chan flush $curr_chan
        return [chan read $curr_chan]
    }
    method return {} {
        set result [my undivert]
        my destroy
        return -level 2 $result         ; # <2>
    }
}
----
<1> Used to make unique names for stack component of the diverter.
<2> Note that the `return` method returns all the diverted text,
destoys itself and returns out of the calling procedure.
This is convenient since the diversions are used to end the
procedures that are embedded in the template expansion and it results
in all the accumulated output being placed into the expansion.

==== Data type procedures

We need some common code to process ``C'' data types from the
`micca` domains.

Usually, we need to know the base ``C'' type of something.
Since it is possible to create a type alias for a type alias,
a bit of recursion is needed to resolve down to the underlying
``C'' data type.

(((chunk,bosal helper commands)))
(((proc,UnaliasType)))

[source,tcl]
----
<<bosal helper commands>>=
proc UnaliasType {domain typename} {
    set nonqual [string map [list const {} volatile {} restrict {}]\
            $typename] ; # <1>
    set nonqual [string trim $nonqual]
    set nonqual [regsub -all {\s+} $nonqual { }]
    set aliasRef [TypeAlias findById Domain $domain TypeName $nonqual]
    if {[isEmptyRef $aliasRef]} {
        return $nonqual
    } else {
        return [UnaliasType $domain [readAttribute $aliasRef TypeDefinition]]
    }
}
----
<1> Get rid of any type qualifiers. They interfer with the anti-alias
look up.

The code generator has to create conversion wrapper functions for
``C'' data types.
This procedure summarizes the information needed by code generation.
This area may need additional work.

[source,tcl]
----
<<bosal helper commands>>=
# return a dictionary keyed by:
# print -- format string
# scan -- format string
# basetype -- unaliased type
# type -- scalar, string or array
# base  -- base type of array or string if type is not scalar
# dimension  -- array or string dimension if type is not scalar
# declaration -- variable declaration with the provided variable name
# varref -- reference to the provided variable name

proc GetTypeInfo {domain implType varName} {
    set basetype [UnaliasType $domain $implType]
    set info [typeCheck assignmentType $basetype]
    dict set info basetype $basetype
    switch -exact -- [dict get $info type] {
        scalar {
            set fmt [relvar restrictone FormatMap ImplType $basetype]
            if {[relation isempty $fmt]} {
                dict set info print "\"i\""
                dict set info scan "\"i\""
            } else {
                dict set info print [relation extract $fmt Print]
                dict set info scan [relation extract $fmt Scan]
            }
            dict set info varref &$varName
        }
        string {
            dict set info print "\"s\""
            dict set info scan "\"s\""
            dict set info varref $varName
        }
        array {
            set fmt [relvar restrictone FormatMap ImplType\
                [dict get $info base]]
            if {[relation isempty $fmt]} {
                dict set info print "\"d\""
                dict set info scan "\"d\""
            } else {
                dict set info print [relation extract $fmt Print]
                dict set info scan [relation extract $fmt Scan]
            }
            dict set info varref $varName
        }
    }

    dict set info declaration [typeCheck composeDeclaration $basetype $varName]

    return $info
}
----

This is a simple mapping relation for how to format and scan ``C''
basic data types.

[source,tcl]
----
<<bosal helper data>>=
# Create a simple map that maps "C" implementation types onto
# printf/scanf format strings.
relvar create FormatMap {
    ImplType string
    Print string
    Scan string
} ImplType

relvar set FormatMap [relation table {
    ImplType string             Print string         Scan  string   } {
    int                         {"d"}                {"i"}              } {
    unsigned                    {"u"}                {"i"}              } {
    {unsigned int}              {"u"}                {"i"}              } {
    short                       {"hd"}               {"hi"}             } {
    {short int}                 {"hd"}               {"hi"}             } {
    {unsigned short}            {"hu"}               {"hi"}             } {
    {unsigned short int}        {"hu"}               {"hi"}             } {
    long                        {"ld"}               {"li"}             } {
    {long int}                  {"ld"}               {"li"}             } {
    {unsigned long}             {"lu"}               {"li"}             } {
    {unsigned long int}         {"lu"}               {"li"}             } {
    size_t                      {"zu"}               {"zu"}             } {
    {long long}                 {"lld"}              {"lli"}            } {
    {long long int}             {"lld"}              {"lli"}            } {
    {unsigned long long}        {"llu"}              {"lli"}            } {
    {unsigned long long int}    {"llu"}              {"lli"}            } {
    {char *}                    {"s"}                {}                 } {
    {void *}                    {"p"}                {"p"}              } {
    float                       {"g"}                {"g"}              } {
    double                      {"lg"}               {"lg"}             } {
    {long double}               {"Lg"}               {"Lg"}             } {
    char                        {"hhd"}              {"hhi"}            } {
    {unsigned char}             {"hhu"}              {"hhi"}            } {
    bool                        {"u"}                {"u"}              } {
    uint8_t                     PRIu8                SCNi8              } {
    uint16_t                    PRIu16               SCNi16             } {
    uint32_t                    PRIu32               SCNi32             } {
    uint64_t                    PRIu64               SCNi64             } {
    int8_t                      PRId8                SCNi8              } {
    int16_t                     PRId16               SCNi16             } {
    int32_t                     PRId32               SCNi32             } {
    int64_t                     PRId64               SCNi64             } {
    intmax_t                    PRIdMAX              SCNiMAX            } {
    uintmax_t                   PRIuMAX              SCNiMAX            } {
    typename(time_t)            {"ld"}               {"li"}             } {
    MRT_ClassId                 {"hu"}               {"hi"}             } {
    MRT_AssignerId              {"hu"}               {"hi"}             } {
    MRT_InstId                  {"hu"}               {"hi"}             } {
    MRT_AttrId                  {"hu"}               {"hi"}             } {
    MRT_AttrSize                {"z"}                {"z"}              } {
    MRT_AttrOffset              {"lu"}               {"li"}             } {
    MRT_DelayTime               PRIu32               SCNi32             } {
    MRT_EventCode               PRIu8                SCNi8              } {
    MRT_StateCode               PRId8                SCNi8              } ]
----
