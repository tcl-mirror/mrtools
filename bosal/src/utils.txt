// vim:set syntax=asciidoc:

== Utility Code

The code in this section implements a set of utility functions
used `bosal` generated test harnesses.

=== Trimming White Space

(((chunk,harness forward function declarations)))
(((function,bslTrimSpaceRight)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTrimSpaceRight(char *const buf) ;
----

(((chunk,harness static functions)))
(((function,bslTrimSpaceRight)))

[source,c]
----
<<harness static functions>>=
static void
bslTrimSpaceRight(
    char *const buf)
{
    for (char *end = buf + strlen(buf) - 1 ;
            end > buf && isspace(*end) ; end--) {
        *end = ASCII_NUL ;
    }
}
----

=== Response Context

To help build up responses,
we define the notion of a _response context_.
A response context is a set of buffers that can be used
to accumulate output in a nested fashion.
Since the responses generated by `bosal` are grouped into _words_
that are separated by whitespace,
it convenient to have distinct areas into which formatted output
can be generated before deciding if the output must be _quoted_
to make it a single word.
In this way,
when words are added to a context after the formatting is accomplished
it is much easier to determine if the new word contains characters
that must be quoted.

A context is defined as a character buffer, a current location
in the buffer where the next character is to be placed, and
the number of bytes remaining in the buffer.

[source,c]
----
<<harness data types>>=
typedef struct bslbufcontext {
    char buf[BUFSIZ] ;
    char *location ;
    size_t remaining ;
} BSL_BufContext ;
----

We define an array of buffer context data structures to use as a stack of
contexts.
A simple pointer then defines the _current context_ as the top of the stack.
For simplicity,
the variables are declared as `static` as we will only ever have
one context stack.

[source,c]
----
<<harness static data>>=
static BSL_BufContext contextStack[BSL_NESTLIMIT] ;
static BSL_BufContext *contextTOS ;
----

The `bslBeginResponse()` function is used to initialize the context
in preparation for generated a response.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslBeginResponse(void) ;
----

[source,c]
----
<<harness static functions>>=
static void
bslBeginResponse(void)
{
    contextTOS = contextStack ;     // <1>
    bslInitBufContext() ;
}
----
<1> Beginning a response causes any other partial response to be
abandoned.

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bslEndResponse(void) ;
----

[source,c]
----
<<harness static functions>>=
static inline int
bslEndResponse(void)
{
    while (contextTOS > contextStack) {
        bslPopContext() ;
    }
    return fprintf(bslCmdStream, "%s\n", contextTOS->buf) ;
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslPushContext(void) ;
----

[source,c]
----
<<harness static functions>>=
static void
bslPushContext(void)
{
    assert(contextTOS != NULL) ;
    assert(contextTOS < contextStack + COUNTOF(contextStack)) ;
    if (contextTOS >= contextStack + COUNTOF(contextStack)) {
        fprintf(stderr, "buffer context stack overflow\n") ;
        abort() ;
    }
    contextTOS += 1 ;
    bslInitBufContext() ;
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslPopContext(void) ;
----

[source,c]
----
<<harness static functions>>=
static void
bslPopContext(void)
{
    assert(contextTOS > contextStack) ;
    if (contextTOS <= contextStack) {
        fprintf(stderr, "buffer context stack underflow\n") ;
        abort() ;
    }

    bslTrimBufContextRight() ;
    char *prevBuf = bslContextGetBuf() ;
    contextTOS -= 1 ;
    bslAddWord(prevBuf) ;
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslInitBufContext(void) ;
----

[source,c]
----
<<harness static functions>>=
static void
bslInitBufContext(void)
{
    assert(contextTOS != NULL) ;
    contextTOS->location = contextTOS->buf ;
    *contextTOS->location = ASCII_NUL ;
    contextTOS->remaining = sizeof(contextTOS->buf) ;
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bslAddWord(char const *word) ;
----

[source,c]
----
<<harness static functions>>=
static int
bslAddWord(
    char const *word)
{
    int nbytes = snprintf(contextTOS->location, contextTOS->remaining,
            bslQuoteWord(word) ? "{%s} " : "%s ", word) ;

    if (nbytes < 0 || nbytes >= contextTOS->remaining) {
        return -1 ;
    } else {
        contextTOS->remaining -= nbytes ;
        contextTOS->location += nbytes ;
    }

    return nbytes ;
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static void bslTrimBufContextRight(void) ;
----

[source,c]
----
<<harness static functions>>=
static void
bslTrimBufContextRight(void)
{
    while (contextTOS->location > contextTOS->buf) {
        if (isspace(*(contextTOS->location - 1))) {
            *--contextTOS->location = ASCII_NUL ;
        } else {
            break ;
        }
    }
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static char *bslContextGetBuf(void) ;
----

[source,c]
----
<<harness static functions>>=
static inline char *
bslContextGetBuf(void)
{
    return contextTOS->buf ;
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static int bslVformatToContext(char const *format, va_list args) ;
----

[source,c]
----
<<harness static functions>>=
static int
bslVformatToContext(
    char const *format,
    va_list args)
{
    int nbytes = vsnprintf(contextTOS->location, contextTOS->remaining,
            format, args) ;

    if (nbytes < 0 || nbytes >= contextTOS->remaining) {
        return -1 ;
    } else {
        contextTOS->remaining -= nbytes ;
        contextTOS->location += nbytes ;
    }

    return nbytes ;
}
----

[source,c]
----
<<harness static functions>>=
static int bslFormatToContext(char const *format, ...) ;
----

[source,c]
----
<<harness static functions>>=
static int
bslFormatToContext(
    char const *format,
    ...)
{
    va_list params ;
    va_start(params, format) ;
    int nbytes = bslVformatToContext(format, params) ;
    va_end(params) ;

    return nbytes ;
}
----

(((chunk,harness forward function declarations)))

[source,c]
----
<<harness forward function declarations>>=
static bool bslQuoteWord(char const *pWord) ;
----

[source,c]
----
<<harness static functions>>=
static bool
bslQuoteWord(
    char const *pWord)
{
    assert(pWord != NULL) ;
    if (strlen(pWord) == 0) {
        return true ; // must quote the empty string
    }

    enum {
        OutOfQuote,
        InQuote
    } quoteState = OutOfQuote ;
    int quoteCount = 0 ;

    for (char c = *pWord++ ; c != ASCII_NUL ; c = *pWord++) {
        if (c == '\\') {
            pWord++ ;
            continue ;
        }
        switch (quoteState) {
        case OutOfQuote:
            if (isspace(c)) {
                return true ;
            } else if (c == BEGIN_QUOTE) {
                quoteCount++ ;
                quoteState = InQuote ;
            }
            break; 

        case InQuote:
            if (c == BEGIN_QUOTE) {
                quoteCount++ ;
            } else if (c == END_QUOTE) {
                assert(quoteCount > 0) ;
                if (--quoteCount == 0) {
                    quoteState = OutOfQuote ;
                }
            }
            break; 
        }
    }
    return quoteCount == 0 ? false : true ;
}
----

[source,c]
----
<<harness static functions>>=
static int bslScanBoolean(char const *value, bool *result) ;
----

[source,c]
----
<<harness static functions>>=
static int
bslScanBoolean(
    char const *value,
    bool *result)
{
    assert(value != NULL) ;
    assert(result != NULL) ;

    if (strcasecmp(value, "true") == 0) {
        *result = true ;
    } else if (strcasecmp(value, "false") == 0) {
        *result = false ;
    } else {
        char *end ;
        unsigned num = strtoul(value, &end, 0) ;
        if (*end == ASCII_NUL) {
            if (num == 0) {
                *result = false ;
            } else if (num == 1) {
                *result = true ;
            } else {
                return 0 ;
            }
        } else {
            return 0 ;
        }
    }

    return 1 ;
}
----

=== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

[source,tcl]
----
<<bosal helper commands>>=
package require tcl::chan::events
package require tcl::chan::fifo
package require struct::stack
package require oo::util
package require textutil::adjust

oo::class create diverter {
    variable chan_stack
    constructor {{prefix {    }}} {
        my variable level_prefix
        set level_prefix $prefix
        classvariable stack_counter
        set chan_stack [::struct::stack s_[incr stack_counter]]
        $chan_stack push [::tcl::chan::fifo]
    }
    destructor {
        foreach dchan [$chan_stack get] {
            chan close $dchan
        }
        $chan_stack destroy
    }
    method puts {args} {
        set nargs [llength $args]
        set curr_chan [$chan_stack peek]
        if {$nargs == 1} {
            chan puts $curr_chan [lindex $args 0]
        } elseif {$nargs == 2} {
            lassign $args opt str
            chan puts $opt $curr_chan $str
        } else {
            error "wrong # of arguments: expected, \"puts ?-nonewline? string\""
        }
    }
    method push {} {
        $chan_stack push [::tcl::chan::fifo]
    }
    method pop {} {
        set top_chan [$chan_stack pop]
        chan flush $top_chan

        set curr_chan [$chan_stack peek]
        my variable level_prefix
        set diverted [::textutil::adjust::indent\
                [chan read $top_chan] $level_prefix]
        chan puts $curr_chan $diverted

        chan close $top_chan
    }
    method undivert {} {
        while {[$chan_stack size] > 1} {
            my pop
        }
        set curr_chan [$chan_stack peek]
        chan flush $curr_chan
        return [chan read $curr_chan]
    }
    method return {} {
        set result [my undivert]
        my destroy
        return -level 2 $result
    }
}
----

[source,tcl]
----
<<bosal helper commands>>=
proc UnaliasType {domain typename} {
    set aliasRef [TypeAlias findById Domain $domain TypeName $typename]
    if {[isEmptyRef $aliasRef]} {
        return $typename
    } else {
        return [UnaliasType $domain [readAttribute $aliasRef TypeDefinition]]
    }
}

# return a dictionary keyed by:
# print -- format string
# scan -- format string
# basetype -- unaliased type
# type -- scalar, string or array
# base  -- base type of array or string if type is not scalar
# dimension  -- array or string dimension if type is not scalar
# declaration -- variable declaration with the provided variable name
# varref -- reference to the provided variable name

proc GetTypeInfo {domain implType varName} {
    set basetype [UnaliasType $domain $implType]
    set info [typeCheck assignmentType $basetype]
    dict set info basetype $basetype
    switch -exact -- [dict get $info type] {
        scalar {
            set fmt [relvar restrictone FormatMap ImplType $basetype]
            if {[relation isempty $fmt]} {
                dict set info print "\"i\""
                dict set info scan "\"i\""
            } else {
                dict set info print [relation extract $fmt Print]
                dict set info scan [relation extract $fmt Scan]
            }
            dict set info varref &$varName
        }
        string {
            dict set info print "\"s\""
            dict set info scan "\"s\""
            dict set info varref $varName
        }
        array {
            set fmt [relvar restrictone FormatMap ImplType\
                [dict get $info base]]
            if {[relation isempty $fmt]} {
                dict set info print "\"d\""
                dict set info scan "\"d\""
            } else {
                dict set info print [relation extract $fmt Print]
                dict set info scan [relation extract $fmt Scan]
            }
            dict set info varref $varName
        }
    }

    dict set info declaration [typeCheck composeDeclaration $basetype $varName]

    return $info
}
----

[source,tcl]
----
<<bosal helper data>>=
# Create a simple map that maps "C" implementation types onto
# printf/scanf format strings.
relvar create FormatMap {
    ImplType string
    Print string
    Scan string
} ImplType

relvar set FormatMap [relation table {
    ImplType string             Print string         Scan  string   } {
    int                         {"d"}                {"i"}              } {
    unsigned                    {"u"}                {"i"}              } {
    {unsigned int}              {"u"}                {"i"}              } {
    short                       {"hd"}               {"hi"}             } {
    {short int}                 {"hd"}               {"hi"}             } {
    {unsigned short}            {"hu"}               {"hi"}             } {
    {unsigned short int}        {"hu"}               {"hi"}             } {
    long                        {"ld"}               {"li"}             } {
    {long int}                  {"ld"}               {"li"}             } {
    {unsigned long}             {"lu"}               {"li"}             } {
    {unsigned long int}         {"lu"}               {"li"}             } {
    size_t                      {"z"}                {"z"}              } {
    {long long}                 {"lld"}              {"lli"}            } {
    {long long int}             {"lld"}              {"lli"}            } {
    {unsigned long long}        {"llu"}              {"lli"}            } {
    {unsigned long long int}    {"llu"}              {"lli"}            } {
    {char *}                    {"s"}                {}                 } {
    {char const *}              {"s"}                {}                 } {
    {const char *}              {"s"}                {}                 } {
    {void *}                    {"p"}                {"p"}              } {
    {const void *}              {"p"}                {"p"}              } {
    {void const *}              {"p"}                {"p"}              } {
    float                       {"g"}                {"g"}              } {
    double                      {"lg"}               {"lg"}             } {
    {long double}               {"Lg"}               {"Lg"}             } {
    char                        {"hhd"}              {"hhi"}            } {
    {unsigned char}             {"hhu"}              {"hhi"}            } {
    void                        void                 {}                 } {
    bool                        {"u"}                {"u"}              } {
    uint8_t                     PRIu8                SCNi8              } {
    uint16_t                    PRIu16               SCNi16             } {
    uint32_t                    PRIu32               SCNi32             } {
    uint64_t                    PRIu64               SCNi64             } {
    int8_t                      PRId8                SCNi8              } {
    int16_t                     PRId16               SCNi16             } {
    int32_t                     PRId32               SCNi32             } {
    int64_t                     PRId64               SCNi64             } {
    intmax_t                    PRIdMAX              SCNiMAX            } {
    uintmax_t                   PRIuMAX              SCNiMAX            } {
    MRT_ClassId                 {"hu"}               {"hi"}             } {
    MRT_AssignerId              {"hu"}               {"hi"}             } {
    MRT_InstId                  {"hu"}               {"hi"}             } {
    MRT_AttrId                  {"hu"}               {"hi"}             } {
    MRT_AttrSize                {"z"}                {"z"}              } {
    MRT_AttrOffset              {"lu"}               {"li"}             } {
    MRT_DelayTime               PRIu32               SCNi32             } {
    MRT_EventCode               PRIu8                SCNi8              } {
    MRT_StateCode               PRId8                SCNi8              } ]
----
