// vim:set syntax=asciidoc:
= Simple Bookstore Model Translation

== Introduction [[introduction,Introduction]]

This document presents a translation of the case study model from the
book,
'Executable UML: A Foundation for Model-Driven Architecture'
by Stephen J. Mellor and Marc J. Balcer.
The translation is targeted at the Tcl implementation language using
the http://repos.modelrealization.com/cgi-bin/fossil/mrtools[`rosea`]
package.

== Model Details [[modeldetails,Model Details]]

My experience is that until they are translated and made into running programs,
all models contain small errors and inconsistencies.
This is not an indictment of the authors of the model or of the quality
of their work.
Because translatable models must be so detailed,
it is inevitable that inconsistencies and errors arise.
After all,
no one, no matter how carefully coded, expects a program to compile
the first time without errors.
When it happens it is usually a cause for celebration!
The same situation applies here.
We will endeavor to point out the errors and state clearly how we deal
with inconsistences.
Since the publishing of the book,
a set of errata have been published on the book's website.
We have taken those errata into account in this translation.

We must also remember that this domain is but one in what would be a larger
system to handle online ordering.
See Figure 17.1 on page 276 of the book to get an indication of
what that larger system might look like.
Consequently,
we will not deal with any parts of the translation that involve joining
multiple domains.
This is a bit disappointing as this part of assembling a system can be
quite complex and is required for all but the tiniest of systems.
The `rosea` package and its underlying Tcl language constructs are well
suited to many of the problems one faces during the construction of
bridge operations.
It would be an interesting undertaking to construct another domain
for the Online Bookstore application and show how bridging in the
`rosea` implementation could be accomplished, but we do not undertake
that in this translation.

It should also be noted that no domain level operations are defined
for the online bookstore domain and so no external programming
interface to the domain is provided.

What we will end up with in this translation is the code for the domain
itself and a set of scenarios that exercise the domain.
You can think of this translation as providing the code for domain
and a preliminary set of unit tests in the form of execution scenarios.
When I undertake system development using translation,
this is usually the first step in the process of building the system.
It is quite useful to be able to run a domain in isolation and construct
a set of unit tests to exercise it.
But it only a first step.
When building a system of multiple domains,
itegration of the domains is also required.
I usually build a set of running programs integrating one additional domain
until the system is fully built.
These intermediary applications are useful for regression testing and
for dealing with the inevitable changes that happen to domain models.
Often the tests developed for the single domain unit tests are useful
in integrating domains.
It is important to remember that building is not _one big step_ but rather
one of building many integration and test applications, the final one of
which contains everything and is the one delivered.

== Translation Conventions [[translationconventions,Translation Conventions]]

During the evolution of Executable UML,
the authors decided that referential attributes were optional.
In my opinion, this decision was a regression of the method.
It certainly can reduce the clutter of the class diagram graphic and
reduce the need for invented identifiers,
but it makes it much easier to skip over the details of how
relationships are actually formalized.
Also, combining referential attributes makes constraints on the data model
and does so in a declarativefootnote:[as opposed to a procedural way]
way.

Regardless of your view of referential attributes,
to translate using `rosea` requires them to be reinserted into the
implementation.
The `rosea` translation is very relation oriented and referential attributes
are an integral part of the the relation model of data.
`Rosea` also requires each class to have an identifier.
We will point out where we have added attributes to deal with the
particulars of `rosea`.


* Dealing with derived attributes

To make the correspondence to the text of the book explicit,
we will order the presentation in the same order as the book.
The domain is presented as three subsystems.
Within each subsystem,
the class definitions appear in the same order as the book.
Relationship definitions are dealt with differently.
In the book text,
each _side_ of the relationship is presented with the class that is a
participant in the relationship.
For `rosea`, we must define the relationships exactly once.
So we give relationship definitions with the class that contains
the referential attributes that formalize the relationship.
The exception to this is generalization relationships where we define
the generalization along with the superclass.
This ordering is used to clarify the translation's correspondence with the
book text. `Rosea` itself allows an arbitrary order for the definitions.


== Data Types [[datatypes,Data Types]]

* Explain Tcl types
* Explain rosea checks

== Product Specification Subsystem [[productspecificationsubsytem,Product Specification Subsystem]]

[source,tcl]
----
<<Product Specification Subsystem>>=
<<Product Class Definition>>
<<Publisher Class Definition>>
<<Author Class Definition>>
<<Authorship Class Definition>>
<<Book Product Class Definition>>
<<Recording Product Class Definition>>
<<Software Product Class Definition>>
<<Special Order Product Class Definition>>
<<Stocked Product Class Definition>>
<<Product Category Class Definition>>
<<Recording Class Definition>>
<<Artist Class Definition>>
<<Performance Credit Class Definition>>
<<Recording Format Class Definition>>
<<Platform Class Definition>>
<<Computer Software Class Definition>>
----

=== Product Class [[productclass,Product Class]]

(((Product Specification,Classes,Product)))
[source,tcl]
----
<<Product Class Definition>>=
class Product {
    attribute productID string -id 1
    attribute productName string
    attribute copyright string
    attribute unitPrice int
    attribute description string
    attribute website string
    attribute currentlyAvailable boolean

    attribute categoryID string ; # <1>
    reference R15 ProductCategory -link categoryID

    attribute groupCode string ; # <2>
    attribute publisherCode string
    reference R1 Publisher -link groupCode -link publisherCode

}
----
<1> Here we introduce a referential attribute to realize `R15`.
<2> Again, the need to be precise about how `R1` is realized requires,
referential attributes.
In this case there are two referential attributes corresponding to the
two identifying attributes of <<publisherclass,`Publisher`>>.

(((Product Specification,Relationships,R12)))
(((Product Specification,Relationships,R11)))
(((Product Specification,Relationships,R15)))
(((Product Specification,Relationships,R1)))
[source,tcl]
----
<<Product Class Definition>>=
generalization R12 Product SpecialOrderProduct StockedProduct
generalization R11 Product BookProduct RecordingProduct SoftwareProduct
association R15 Product 0..*--1 ProductCategory
association R1 Product 0..*--1 Publisher
----

=== Publisher Class [[publisherclass,Publisher Class]]

(((Product Specification,Classes,Publisher)))
[source,tcl]
----
<<Publisher Class Definition>>=
class Publisher {
    attribute groupCode string -id 1
    attribute publisherCode string -id 1
    attribute name string
    attribute address string
    attribute website string
}
----

=== Author Class [[authorclass,Author Class]]

(((Product Specification,Classes,Author)))
[source,tcl]
----
<<Author Class Definition>>=
class Author {
    attribute name string -id 1
    attribute website string
    attribute email string
}
----

=== Authorship Class [[authorshipclass,Authorship Class]]

(((Product Specification,Classes,Authorship)))
[source,tcl]
----
<<Authorship Class Definition>>=
class Authorship {
    attribute name string -id 1
    attribute productID string
    reference R2 Author -link name
    reference R2 BookProduct -link productID

    attribute preCredit string
    attribute postCredit string

    attribute previousName string
    reference R3 Authorship -link {previousName name}
}
----

(((Product Specification,Relationships,R3)))
(((Product Specification,Relationships,R2)))
[source,tcl]
----
<<Authorship Class Definition>>=
association R3 Authorship 0..1--0..1 Authorship -path {name previousName}
association R2 BookProduct 1..*--0..* Author -associator Authorship
----

=== Book Product Class [[bookproductclass,BookProduct Class]]

(((Product Specification,Classes,BookProduct)))
[source,tcl]
----
<<Book Product Class Definition>>=
class BookProduct {
    attribute productID string -id 1
    attribute bookNumber string
    attribute titleCode string
    attribute title string
    attribute subtitle string

    reference R11 Product -link productID
}
----

=== Recording Product Class [[recordingproductclass,Recording Product Class]]

(((Product Specification,Classes,Recording Product)))
[source,tcl]
----
<<Recording Product Class Definition>>=
class RecordingProduct {
    attribute productID string -id 1
    attribute runningTime int

    reference R11 Product -link productID

    attribute recordingID string -id 2
    attribute formatID string -id 2
    reference R16 Recording -link recordingID
    reference R16 RecordingFormat -link formatID
}
----

(((Product Specification,Relationships,R16)))
[source,tcl]
----
<<Recording Product Class Definition>>=
association R16 Recording 1..*--1..* RecordingFormat\
        -associator RecordingProduct
----

=== Software Product Class [[softwareproductclass,Software Product Class]]

(((Product Specification,Classes,Software Product)))
[source,tcl]
----
<<Software Product Class Definition>>=
class SoftwareProduct {
    attribute productID string -id 1
    attribute productVersion string

    attribute softwareID string
    reference R20 ComputerSoftware -link softwareID

    reference R11 Product -link productID

    attribute platformID string
    reference R19 Platform -link platformID
}
----

(((Product Specification,Relationships,R19)))
(((Product Specification,Relationships,R20)))
[source,tcl]
----
<<Software Product Class Definition>>=
association R19 SoftwareProduct 1..*--1 Platform
association R20 SoftwareProduct 1..*--1 ComputerSoftware
----

=== Special Order Product Class [[specialorderproductclass,Special Order Product Class]]

(((Product Specification,Classes,Special Order Product)))
[source,tcl]
----
<<Special Order Product Class Definition>>=
class SpecialOrderProduct {
    attribute productID string -id 1
    attribute specialOrderInstructions string
    attribute daysToDeliver int

    reference R12 Product -link productID
}
----

=== Stocked Product Class [[stockedproductclass,Stocked Product Class]]

(((Product Specification,Classes,Stocked Product)))
[source,tcl]
----
<<Stocked Product Class Definition>>=
class StockedProduct {
    attribute productID string -id 1
    attribute quantityOnHand int
    attribute reorderThreshold int
    attribute reorderIncrement int
    attribute reorderInstructions string

    reference R12 Product -link productID
}
----

=== Product Category Class [[productcategoryclass,Product Category Class]]

(((Product Specification,Classes,Product Category)))
[source,tcl]
----
<<Product Category Class Definition>>=
class ProductCategory {
    attribute categoryID string -id 1
    attribute categoryName string
    attribute parentCategoryID string

    reference R14 ProductCategory -link {parentCategoryID categoryID}
}
----

(((Product Specification,Relationships,R14)))
[source,tcl]
----
<<Product Category Class Definition>>=
association R14 ProductCategory 0..*--0..1 ProductCategory
----

=== Recording Class [[recordingclass,Recording Class]]

(((Product Specification,Classes,Recording)))
[source,tcl]
----
<<Recording Class Definition>>=
class Recording {
    attribute recordingID string -id 1
    attribute title string
}
----

=== Artist Class [[artistclass,Artist Class]]

(((Product Specification,Classes,Artist)))
[source,tcl]
----
<<Artist Class Definition>>=
class Artist {
    attribute artistID string -id 1
    attribute artistName string
}
----

=== Performance Credit Class [[performancecreditclass,Performance Credit Class]]

(((Product Specification,Classes,Performance Credit)))
[source,tcl]
----
<<Performance Credit Class Definition>>=
class PerformanceCredit {
    attribute role string

    attribute recordingID string -id 1
    attribute artistID string -id 1
    reference R17 Recording -link recordingID
    reference R17 Artist -link artistID

    attribute prevRecordingID string -id 2
    attribute prevArtistID string -id 2
    reference R18 PerformanceCredit\
        -refid 2\
        -link {recordingID prevRecordingID}\
        -link {artistID prevArtistID}
}
----

(((Product Specification,Relationships,R17)))
(((Product Specification,Relationships,R18)))
[source,tcl]
----
<<Performance Credit Class Definition>>=
association R17 Recording 1..*--1..* Artist -associator PerformanceCredit
association R18 PerformanceCredit 0..1--0..1 PerformanceCredit\
    -path {recordingID prevRecordingID artistID prevArtistID}
----

=== Recording Format Class [[recordingformatclass,Recording Format Class]]

(((Product Specification,Classes,Recording Format)))
[source,tcl]
----
<<Recording Format Class Definition>>=
class RecordingFormat {
    attribute formatID string -id 1
    attribute formatName string
}
----

=== Platform Class [[platformclass,Platform Class]]

(((Product Specification,Classes,Platform)))
[source,tcl]
----
<<Platform Class Definition>>=
class Platform {
    attribute platformID string -id 1
    attribute platformName string
}
----

=== Computer Software Class [[computersoftwareclass,Computer Software Class]]

(((Product Specification,Classes,Computer Software)))
[source,tcl]
----
<<Computer Software Class Definition>>=
class ComputerSoftware {
    attribute softwareID string -id 1
    attribute title string
}
----

== Ordering Subsystem [[orderingsubsytem,Ordering Subsystem]]

[source,tcl]
----
<<Ordering Subsystem>>=
<<Customer Class Definition>>
<<Order Class Definition>>
<<Product Selection Class Definition>>
<<Shopping Cart Class Definition>>
<<Credit Card Charge Class Definition>>
----

=== Customer Class [[customerclass,Customer Class]]

(((Ordering,Classes,Customer)))
[source,tcl]
----
<<Customer Class Definition>>=
class Customer {
    attribute email string -id 1
    attribute name string
    attribute shippingAddress string
    attribute phone string
    attribute purchasesMade int
}
----

=== Order Class [[orderclass,Order Class]]

(((Ordering,Classes,Order)))
[source,tcl]
----
<<Order Class Definition>>=
class Order {
    attribute orderID string -id 1
    attribute dateOrderPlaced string -default {}
    attribute totalValue int
    attribute recipient string
    attribute deliveryAddress string
    attribute contactPhone string

    attribute cartID string -default {}
    reference R10 ShoppingCart -link cartID

    attribute email string -default {}
    reference R5 Customer -link email

    statemodel {
        <<Order State Model>>
    }
}
----

(((Ordering,Relationships,R10)))
(((Ordering,Relationships,R5)))
[source,tcl]
----
<<Order Class Definition>>=
association R10 Order 0..1--1 ShoppingCart
association R5 Order 1..*--0..1 Customer
----

(((Ordering,State Models,Order)))
[source,tcl]
----
<<Order State Model>>=
transition @ - checkOut -> EstablishingCustomerandVerifyingPayment

state EstablishingCustomerandVerifyingPayment {
        cart accountNumber billingAddress cardExpirationDate
        cardholderName customerEmail} {
    R10 link $self $cart

    set customer [Customer findById email $customerEmail]
    if {[isEmptyRef $customer]} {
        set customer [Customer create\
            email $customerEmail\
            name [readAttribute $self recipient]\
            shippingAddress [readAttribute $self deliveryAddress]\
            phone [readAttribute $self contactPhone]\
            purchasesMade 0\
        ]
    } else {
        updateAttribute $customer\
            name [readAttribute $self recipient]\
            shippingAddress [readAttribute $self deliveryAddress]\
            phone [readAttribute $self contactPhone]\
    }

    R5 link $self $customer

    updateAttribute $self dateOrderPlaced [clock format [clock seconds]]

    signal $self submitCharge $accountNumber $billingAddress\
        $cardExpirationDate $cardholderName
}

transition EstablishingCustomerandVerifyingPayment - submitCharge ->\
    SubmittingCharge

state SubmittingCharge {accountNumber billingAddress cardExpirationDate
        cardholderName} {
    CreditCardCharge createasync makeCharge [list $self]\
        chargeID [uuid::uuid generate]\
        accountNumber $accountNumber\
        cardholderName $cardholderName\
        billingAddress $billingAddress\
        cardExpirationDate $cardExpirationDate\
        chargeAmount [readAttribute $self totalValue]
}

transition SubmittingCharge - paymentApproved -> BeingPackedandShipped
transition SubmittingCharge - paymentDeclined -> PaymentNotApproved

state PaymentNotApproved {} {
    set customer [findRelated $self R5]
    EE_OnLineCustomer::chargeDeclined [readAttribute $customer email]
}

state BeingPackedandShipped {} {
    set customer [findRelated $self R5]
    EE_OnLineCustomer::chargeApproved [readAttribute $customer email]

    Shipment createasync requestShipment [list $self]\
        shipmentID [uuid::uuid generate]\
        recipient [readAttribute $self recipient]\
        deliveryAddress [readAttribute $self deliveryAddress]\
        contactPhone [readAttribute $self contactPhone]\
        timePrepared {}\
        timePickedUp {}\
        timeDelivered {}\
        waitingToBePacked true
}
transition BeingPackedandShipped - orderDelivered -> DeliveredtoCustomer

state DeliveredtoCustomer {} {
    set customer [findRelated $self R5]
    EE_OnLineCustomer::orderReportedDelivered\
            [readAttribute $customer email]
}
----

=== Product Selection Class [[productselectionclass,Product Selection Class]]

(((Ordering,Classes,Product Selection)))
[source,tcl]
----
<<Product Selection Class Definition>>=
class ProductSelection {
    attribute quantity int
    attribute unitPriceOfSelection int
    attribute selectionValue int

    attribute productID string -id 1
    attribute cartID string -id 1
    reference R4 Product -link productID
    reference R4 ShoppingCart -link cartID

    statemodel {
        <<Product Selection State Model>>
    }
}
----

(((Ordering,Relationships,R4)))
[source,tcl]
----
<<Product Selection Class Definition>>=
association R4 ShoppingCart 0..*--1..* Product -associator ProductSelection
----

(((Ordering,State Models,Product Selection)))
[source,tcl]
----
<<Product Selection State Model>>=
transition @ - addSelection -> NewSelection

state NewSelection {cartID productID quantity} {
    set product [Product findById productID $productID]
    updateAttribute $self\
        quantity $quantity\
        productID $productID\
        cartID $cartID\
        unitPriceOfSelection [readAttribute $product unitPrice]

    signal $self changeQuantity $quantity
}
transition NewSelection - changeQuantity -> ChangingQuantity

state ChangingQuantity {quantity} {
    updateAttribute $self quantity $quantity
    if {$quantity == 0} {
        signal $self removeSelection
    } else {
        set cart [findRelated $self ~R4]
        signal $cart cartUpdated
    }
}
transition ChangingQuantity - removeSelection -> RemovingSelection

state RemovingSelection {} {
    set cart [findRelated $self ~R4]
    R4 unlink $self
    set remainingProduct [findRelated $cart R4]
    if {[isEmptyRef $remainingProduct]} {
        signal $cart cancel
    } else {
        signal $cart cartUpdated
    }
}
terminal RemovingSelection
----

=== ShoppingCart Class [[shoppingcartclass,ShoppingCart Class]]

(((Ordering,Classes,ShoppingCart)))
[source,tcl]
----
<<Shopping Cart Class Definition>>=
class ShoppingCart {
    attribute cartID string -id 1
    attribute totalValue int

    statemodel {
        <<Shopping Cart State Model>>
    }
}
----

(((Ordering,State Models,Shopping Cart)))
[source,tcl]
----
<<Shopping Cart State Model>>=
transition @ - startCart -> NewOrder

state NewOrder {productID quantity} {
    signal $self addSelection $productID $quantity
}
transition NewOrder - addSelection -> AddingSelectiontoOrder

state AddingSelectiontoOrder {productID quantity} {
    set product [Product findById productID $productID]
    set unitprice [readAttribute $product unitPrice]
    set newSelection [R4 link $self $product\
        quantity $quantity\
        unitPriceOfSelection $unitprice\
        selectionValue [expr {$unitprice * $quantity}]\
    ]
}
transition AddingSelectiontoOrder - addSelection -> AddingSelectiontoOrder
transition AddingSelectiontoOrder - cancel -> CancelingEntireOrder
transition AddingSelectiontoOrder - checkOut ->\
        EstablishingCustomerandVerifyingPayment

state CancelingEntireOrder {} {
    set selections [findRelated $self {R4 ProductSelection}]
    R4 unlink $selections
}
terminal CancelingEntireOrder

state EstablishingCustomerandVerifyingPayment {
        accountNumber billingAddress cardExpirationDate
        cardholderName customerEmail customerName customerPhone
        shippingAddress} {
    Order createasync checkOut [list $self $accountNumber\
        $billingAddress $cardExpirationDate $cardholderName\
        $customerEmail]\
        orderID [uuid::uuid generate]\
        totalValue [readAttribute $self totalValue]\
        recipient $customerName\
        deliveryAddress $shippingAddress\
        contactPhone $customerPhone
}
----

=== Credit Card Charge Class [[creditcardchargeclass,Credit Card Charge Class]]

(((Ordering,Classes,Credit Card Charge)))
[source,tcl]
----
<<Credit Card Charge Class Definition>>=
class CreditCardCharge {
    attribute chargeID string -id 1
    attribute accountNumber string
    attribute cardholderName string
    attribute billingAddress string
    attribute cardExpirationDate string
    attribute dateChargeMade string -default {}
    attribute chargeAmount int
    attribute approvalCode string -default {}

    attribute attemptOrderID string -default {}
    reference R7 Order -link {attemptOrderID orderID}

    attribute paidOrderID string -default {}
    reference R8 Order -link {paidOrderID orderID}

    statemodel {
        <<Credit Card Charge State Model>>
    }
}
----

(((Ordering,Relationships,R7)))
(((Ordering,Relationships,R8)))
[source,tcl]
----
<<Credit Card Charge Class Definition>>=
association R7 CreditCardCharge 0..*--1 Order
association R8 CreditCardCharge 0..1--1 Order
----

(((Ordering,State Model,Credit Card Charge)))
[source,tcl]
----
<<Credit Card Charge State Model>>=
transition @ - makeCharge -> RequestingChargeApproval

state RequestingChargeApproval {order} {
    R7 link $self $order
    updateAttribute $self dateChargeMade [clock format [clock seconds]]

    withAttribute $self accountNumber billingAddress cardholderName\
            cardExpirationDate chargeID chargeAmount {
        EE_CreditCardCompany::requestChargeApproval\
            $accountNumber\
            $billingAddress\
            $cardholderName\
            $cardExpirationDate\
            $chargeID\
            $chargeAmount
    }

    delaysignal $self 60000 chargeProcessingNotCompleted
}
transition RequestingChargeApproval - chargeProcessed -> ProcessingCompleted
transition RequestingChargeApproval - chargeProcessingNotCompleted ->\
    DeclineForTimeout

state ProcessingCompleted {resultCode} {
    updateAttribute $self approvalCode $resultCode
    set order [findRelated $self R7]
    canceldelayed $self $order chargeProcessingNotCompleted
    R8 link $self $order
    if {$resultCode eq "approved"} {
        signal $order paymentApproved
    } else {
        signal $order paymentDeclined
    }
}

state DeclineForTimeout {} {
    updateAttribute $self approvalCode connectionFailed
    set order [findRelated $self R7]
    signal $order paymentDeclined
}
----

== Shipping Subsystem [[shippingsubsytem,Shipping Subsystem]]

[source,tcl]
----
<<Shipping Subsystem>>=
<<Shipment Class Definition>>
<<Shipping Company Class Definition>>
<<Warehouse Clerk Class Definition>>
<<Warehouse Class Definition>>
<<Shipping Clerk Class Definition>>
<<Stock Clerk Class Definition>>
<<Off Duty Clerk Class Definition>>
<<Shipment Item Class Definition>>
----

=== Shipment Class [[shipmentclass,Shipment Class]]

(((Shipping,Classes,Shipment)))
[source,tcl]
----
<<Shipment Class Definition>>=
class Shipment {
    attribute shipmentID string -id 1
    attribute shippingCompany string
    reference R21 ShippingCompany -link {shippingCompany companyName}
    attribute trackingNumber string

    attribute recipient string
    attribute deliveryAddress string
    attribute contactPhone string
    attribute timePrepared string
    attribute timePickedUp string
    attribute timeDelivered string
    attribute waitingToBePacked boolean

    attribute warehouseName string -default {}
    reference R24 Warehouse -link warehouseName

    attribute clerkID string -default {}
    reference R22 WarehouseClerk -link clerkID

    attribute orderID string -default {}
    reference R6 Order -link orderID

    statemodel {
        <<Shipment State Model>>
    }

    <<Shipment Operations>>
}
----

(((Shipping,Relationships,R21)))
(((Shipping,Relationships,R24)))
(((Shipping,Relationships,R22)))
(((Shipping,Relationships,R6)))
[source,tcl]
----
<<Shipment Class Definition>>=
association R21 Shipment 0..*--0..1 ShippingCompany
association R24 Shipment 0..*--1 Warehouse
association R22 Shipment 0..*--0..1 WarehouseClerk
association R6 Shipment 0..1--1 Order
----

(((Shipping,State Model,Shipment)))
[source,tcl]
----
<<Shipment State Model>>=
transition @ - requestShipment -> PreparingShipment

state PreparingShipment {order} {
    R6 link $self $order

    set warehouse [Warehouse chooseWarehouse\
        [readAttribute $order orderID]
    R24 link $self $warehouse

    signal $warehouse shipmentReadyToPack
}
transition PreparingShipment - packed -> PackedandAwaitingTrackingNumber
transition PreparingShipment - trackingNumberAssigned ->\
    NumberAssignedandWaitingtobePacked

state PackedandAwaitingTrackingNumber {clerkID} {
    instop $self updatePackingInfo $clerkID
}
transition PackedandAwaitingTrackingNumber - trackingNumberAssigned ->\
    NumberAssigned

state NumberAssignedandWaitingtobePacked {
        shippingCompany trackingNumber} {
    instop $self updateTrackingInfo $shippingCompany $trackingNumber
}
transition NumberAssignedandWaitingtobePacked - packed -> Packed

state NumberAssigned {shippingCompany trackingNumber} {
    instop $self updateTrackingInfo $shippingCompany $trackingNumber
}
transition NumberAssigned - pickedUp -> InTransittoCustomer

state Packed {clerkID} {
    instop $self updatePackingInfo $clerkID
}
transition Packed - pickedUp -> InTransittoCustomer

state InTransittoCustomer {} {
    updateAttribute $self timePickedUp [clock format [clock seconds]]
}
transition InTransittoCustomer - deliveryConfirmed -> Delivered

state Delivered {timeDelivered} {
    updateAttribute $self timeDelivered [clock format [clock seconds]]
    set order [findRelated $self R6]
    signal $order orderDelivered
}
----

[source,tcl]
----
<<Shipment Operations>>=
instop updateTrackingInfo {shippingCompany trackingNumber} {
    updateAttribute $self trackingNumber $trackingNumber
    set company [ShippingCompany findById companyName $shippingCompany]
    R21 link $self $company
}

instop updatePackingInfo {clerkID} {
    updateAttribute $self timePrepared [clock format [clock seconds]]

    set clerk [ShippingClerk findById clerkID $clerkID]
    R22 link $self $clerk

    EE_ShippingCompany::shipmentReadyForPickup\
        [readAttribute $self shipmentID]
}
----

=== Shipping Company Class [[shippingcompanyclass,Shipping Company Class]]

(((Shipping,Classes,Shipping Company)))
[source,tcl]
----
<<Shipping Company Class Definition>>=
class ShippingCompany {
    attribute companyName string -id 1
    attribute trackingWebsite string
    attribute customerServicePhone string
    attribute localDispatchPhone string
    attribute localOffice string
    attribute localContact string
}
----

=== Warehouse Class [[warehouseclass,Warehouse Class]]

(((Shipping,Classes,Warehouse)))
[source,tcl]
----
<<Warehouse Class Definition>>=
class Warehouse {
    attribute warehouseName string -id 1
    attribute warehouseLocation string

    statemodel {
        <<Warehouse State Model>>
    }

    classop chooseWarehouse {orderID} {
        return [pipe {
            deRef $self |
            relation tag ~ Order -ascending warehouseName |
            relation restrictwith ~ {$Order == 0} |
            relation eliminate ~ Order |
            ::rosea::Helpers::ToRef [namespace current]::Warehouse ~
        }]
    }
}
----

(((Shipping,State Model,Warehouse)))
[source,tcl]
----
<<Warehouse State Model>>=
initialstate WaitingforaShipment
defaulttrans IG

state WaitingforaShipment {} {
    set readyShipment [findRelatedWhere $self ~R24 {$waitingToBePacked}]
    if {[isRefNotEmpty $readyShipment]} {
        signal $self shipmentReadyToPack
    }
}
transition WaitingforaShipment - shipmentReadyToPack -> WaitingforaFreeClerk

state WaitingforaFreeClerk {} {
    set freeClerk [findRelatedWhere $self {~R25 {~R27 ShippingClerk}}\
        {$awaitingAssignment}]
    if {[isRefNotEmpty $freeClerk]} {
        signal $self clerkFree
    }
}
transition WaitingforaFreeClerk - clerkFree -> AssigningClerktoShipment

state AssigningClerktoShipment {} {
    set readyShipment [findRelatedWhere $self ~R24 {$waitingToBePacked}]
    set freeClerk [findRelatedWhere $self {~R25 {~R27 ShippingClerk}}\
        {$awaitingAssignment}]
    R23 link $readyShipment $freeClerk
    updateAttribute $readyShipment waitingToBePacked false
    updateAttribute $freeClerk awaitingAssignment false

    signal $freeClerk clerkAssigned
    signal $self clerkAssignedToShipment
}
transition AssigningClerktoShipment - clerkAssignedToShipment ->\
        WaitingforaShipment
----

=== Warehouse Clerk Class [[warehouseclerkclass,Warehouse Clerk Class]]

(((Shipping,Classes,Warehouse Clerk)))
[source,tcl]
----
<<Warehouse Clerk Class Definition>>=
class WarehouseClerk {
    attribute clerkID string -id 1
    attribute clerkName string
    attribute goOffDutyAtEndOfJob boolean
}
----

(((Shipping,Relationships,RR)))
[source,tcl]
----
<<Warehouse Clerk Class Definition>>=
generalization R27 WarehouseClerk OffDutyClerk StockClerk ShippingClerk
----

=== Shipping Clerk Class [[shippingclerkclass,Shipping Clerk Class]]

(((Shipping,Classes,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk Class Definition>>=
class ShippingClerk {
    attribute clerkID string -id 1
    reference R27 WarehouseClerk -link clerkID

    attribute awaitingAssignment boolean

    attribute shipmentID string
    reference R23 Shipment -link shipmentID

    statemodel {
        <<Shipping Clerk State Model>>
    }
}
----

(((Shipping,Relationships,R23)))
[source,tcl]
----
<<Shipping Clerk Class Definition>>=
association R23 ShippingClerk 0..1--0..1 Shipment
----

(((Shipping,State Model,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk State Model>>=
transition @ - startShipping -> WaitingforaJob

state WaitingforaJob {} {
    updateAttribute $self awaitingAssignment true
    set warehouse [findRelated R27 R25]
    signal $warehouse clerkFree
}
transition WaitingforaJob - clerkAssigned -> SelectingBooks
transition WaitingforaJob - offDuty -> OffDuty

state SelectingBooks {} {
    EE_ShippingClerk::shipmentReadyToPack\
        [readAttribute $self shipmentID]
}
transition SelectingBooks - booksSelected -> PackingBox

state PackingBox {} {
    generate $self boxPacked
}
transition PackingBox - boxPacked -> SealingBox

state SealingBox {} {
    generate $self boxSealed
}
transition SealingBox - boxSealed -> AttachingShippingLabel

state AttachingShippingLabel {} {
    generate $self shippingLabelAttached
}
transition AttachingShippingLabel - shippingLabelAttached ->\
    DeliveringBoxtoLoadingDock

state DeliveringBoxtoLoadingDock {} {
    generate $self boxAtLoadingDoc
}
transition DeliveringBoxtoLoadingDock - boxAtLoadingDoc -> CompletingJob

state CompletingJob {} {
    set currentShipment [findRelated $self R23]
    signal $currentShipment packed [readAttribute $self clerkID]
    R23 unlink $self $currentShipment
    if {[readAttribute $self goOffDutyAtEndOfJob]} {
        signal $self offDuty
    } else {
        updateAttribute $self awaitingAssignment true
        set myWarehouse [findRelated $self R27 R25]
        signal $myWarehouse clerkFree
    }
}
transition CompletingJob - clerkAssigned -> SelectingBooks
transition CompletingJob - offDuty -> OffDuty

state OffDuty {} {
    R27 migrate $self OffDutyClerk
}
----

=== Stock Clerk Class [[stockclerkclass,Stock Clerk Class]]

(((Shipping,Classes,Stock Clerk)))
[source,tcl]
----
<<Stock Clerk Class Definition>>=
class StockClerk {
    attribute clerkID string -id 1
    reference R27 WarehouseClerk -link clerkID
    attribute idle boolean
}
----

=== Off Duty Clerk Class [[offdutyclerkclass,Off Duty Clerk Class]]

(((Shipping,Classes,Off Duty Clerk)))
[source,tcl]
----
<<Off Duty Clerk Class Definition>>=
class OffDutyClerk {
    attribute clerkID string -id 1
    reference R27 WarehouseClerk -link clerkID
}
----

=== Shipment Item Class [[shipmentitemclass,Shipment Item Class]]

(((Shipping,Classes,Shipment Item)))
[source,tcl]
----
<<Shipment Item Class Definition>>=
class ShipmentItem {
    attribute shipmentID string -id 1
    reference R9 Shipment -link shipmentID

    attribute productID string -id 1
    attribute cartID string -id 1
    reference R9 ProductSelection -link productID -link cartID

    attribute quantityShipped int
}
----

(((Shipping,Relationships,R9)))
[source,tcl]
----
<<Shipment Item Class Definition>>=
association R9 Shipment 1..*--0..* ProductSelection -associator ShipmentItem
----

== Product Specification Subsystem Population [[productspecificationsubsystempopulation,Product Specification Subsystem Population]]

[source,tcl]
----
<<Product Specification Population>>=
<<Product Population>>
<<Publisher Population>>
<<Author Population>>
<<Authorship Population>>
<<Book Product Population>>
<<Recording Product Population>>
<<Software Product Population>>
<<Special Order Product Population>>
<<Stocked Product Population>>
<<Product Category Population>>
<<Recording Population>>
<<Artist Population>>
<<Performance Credit Population>>
<<Recording Format Population>>
<<Platform Population>>
<<Computer Software Population>>
----

=== Product Population [[productpopulation,Product Population]]

(((Product Specification,Population,Product)))
[source,tcl]
----
<<Product Population>>=
class Product {
    productID
    productName
    copyright
    unitPrice
    description
    website 
    currentlyAvailable
    categoryID
    groupCode
    publisherCode
}\
    [set eumlid [uuid::uuid generate]]\
    "Executable UML: A Foundation for Model-Driven Architecture"\
    2002\
    2995\
    "Book on software development using models."\
    www.executableumlbook.com\
    true\
    [set techcategoryid [uuid::uuid generate]\
    0\
    201
----

=== Publisher Population [[publisherpopulation,Publisher Population]]

(((Product Specification,Population,Publisher)))
[source,tcl]
----
<<Publisher Population>>=
class Publisher {
    groupCode
    publisherCode
    name
    address
    website
}\
    0\
    201\
    Addison-Wesley\
    "New York"\
    www.aw.com
----

=== Author Population [[authorpopulation,Author Population]]

(((Product Specification,Population,Author)))
[source,tcl]
----
<<Author Population>>=
class Author {
    name
    website
    email
}\
    "Stephen J. Mellor"\
    stephenmellor.com\
    stephen@stephenmellor.com\
    "Marc J. Balcer"\
    marcbalcer.com\
    marc@marcbalcer.com
----

=== Authorship Population [[authorshippopulation,Authorship Population]]

(((Product Specification,Population,Authorship)))
[source,tcl]
----
<<Authorship Population>>=
class Authorship {
    name
    productID
    preCredit
    postCredit
    previousName
}\
    "Stephen J. Mellor"\
    $eumlid\
    {}\
    {}\
    {}\
    "Marc J. Balcer"\
    $eumlid\
    {}\
    {}\
    "Stephen J. Mellor"
----

=== Book Product Population [[bookproductpopulation,Book Product Population]]

(((Product Specification,Population,Book Product)))
[source,tcl]
----
<<Book Product Population>>=
class BookProduct {
    productID
    bookNumber
    titleCode
    title
    subtitle
}\
    $eumlid\
    "ISBN 0-201-74804-5"\
    74804-5\
    "Executable UML"\
    "A Foundation for Model-Driven Architecture"
----

=== Stocked Product Population [[stockedproductpopulation,Stocked Product Population]]

(((Product Specification,Population,Stocked Product)))
[source,tcl]
----
<<Stocked Product Population>>=
class StockedProduct {
    productID
    quantityOnHand
    reorderThreshold
    reorderIncrement
    reorderInstructions
}\
    $emlid\
    100\
    200\
    100\
    "Ship as quickly as possible"
----

=== Product Category Population [[productcategorypopulation,Product Category Population]]

(((Product Specification,Population,Product Category)))
[source,tcl]
----
<<Product Category Population>>=
class ProductCategory {
    categoryID string -id 1
    categoryName string
    parentCategoryID string
}\
    $techcategoryid\
    technical\
    {}
----

== Ordering Subsystem Population [[orderingsubsystempopulation,Ordering Subystem Population]]

[source,tcl]
----
<<Ordering Subsystem Population>>=
----

== Shipping Subsystem Population [[shippingsubsystempopulation,Shipping Subystem Population]]

[source,tcl]
----
<<Shipping Subsystem Population>>=
----

== Code Organization [[codeorganization,Code Organization]]

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<simplebookstore.tcl>>=
<<copyright info>>

package require Tcl 8.6
package require rosea
package require uuid

domain bookstore {
    <<Product Specification Subsystem>>
    <<Ordering Subsystem>>
    <<Shipping Subsystem>>
}
----

=== Initial Instance Population

[source,tcl]
----
<<sbs_population.tcl>>=
<<copyright info>>

domain bookstore {
    <<Product Specification Population>>
    <<Ordering Population>>
    <<Shipping Population>>
}
----

=== Execution Scenarios

[source,tcl]
----
<<scenario1.tcl>>=
<<copyright info>>

package require rosea

rosea configureFromFile simplebookstore.tcl
rosea generate
rosea populateFromFile sbs_population.tcl

foreach relvar [lsort [ral relvar names ::bookstore::*]] {
    set relvar [namespace tail $relvar]
    if {![string match {__Arch*} $relvar]} {
        puts $relvar
    }
}
----

/////

=== XX Class [[xxclass,XX Class]]

(((Ordering,Classes,XX)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,Relationships,RR)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,State Model,XX)))
[source,tcl]
----
<<XX State Model>>=
----
/////

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
