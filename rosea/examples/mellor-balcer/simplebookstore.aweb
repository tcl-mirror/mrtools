// vim:set syntax=asciidoc:
= Simple Bookstore Model Translation

== Introduction [[introduction,Introduction]]

This document presents a translation of the case study model from the
book,
'Executable UML: A Foundation for Model-Driven Architecture'
by Stephen J. Mellor and Marc J. Balcer.
The translation is targeted at the Tcl implementation language using
the http://repos.modelrealization.com/cgi-bin/fossil/mrtools[`rosea`]
package.
The model can be found in Appendix B in the book on page 313.

This document is also a
http://www.literateprogramming.com[literate program].
It contains all the code of the translation and the execution scenarios
that exercise the program.
The literate program source and all the output is available at the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools[Model Realization]
web site.

Translation using `rosea` is a semi-manual process.
The model diagrams are transcribed into a domain specific language (DSL)
that is provided by `rosea`.
The classes, relationships and state models are defined in a declarative
manner.
The state activities must be translated from action language into Tcl
using procedures provided by `rosea` to implement the model level actions.
For example,
action language statements to select related instances are translated
into invocations of the `findRelated` procedure.
Generally, action language statements translate one-for-one into lines
of Tcl code and the correspondence is direct once you understand the
conventions of Tcl programming.
Once transcribed into the `rosea` DSL,
a code generation phase is invoked.
Unlike translation for compiled languages,
this code generation does not produce any files.
Tcl is an interpreted language and so the commands and data required
by the run time component of `rosea` are simply created _in situ_.
Once generation is completed,
we can exercise the resulting program by signaling events or
invoking any operations that are provided.

In the next sections,
we explain some preliminary details that must precede the translation.
Some of these details have to do with the on-line bookstore model itself
and some deal with the specifics of translating using `rosea`.
After the preliminaries,
we present the translation organized into subsystems and presented
in the order found in the book.
Next we show a sample population of the model and that is followed by
procedures that stub out the explicit external entity functions found
in the model.
Finally, we present a set of scenarios to exercise the model.
The results of running the scenarios is given in two forms.
`Rosea` has many capabilties to deal with execution traces.
First, is a textual log of the event dispatch.
Second, is a sequence diagram.
The sequence diagram is just another view on the event dispatch data,
organized in the usual UML sequence diagram form.


== Model Details [[modeldetails,Model Details]]

My experience is that until they are translated and made into running programs,
all models contain small errors and inconsistencies.
This is not an reflection on the authors of the model or of the quality
of their work.
Because translatable models must be so detailed,
it is inevitable that inconsistencies and errors arise.
After all,
no one, no matter how carefully coded, expects a program to compile
the first time without errors.
When it happens it is usually a cause for celebration!
The same situation applies here.
We will endeavor to point out the errors and state clearly how we deal
with inconsistences.
Since the publishing of the book,
a set of errata have been published on the book's website.
We have taken those errata into account in this translation.

We must also remember that this domain is but one in what would be a larger
system to handle online ordering.
See Figure 17.1 on page 276 of the book to get an indication of
what that larger system might look like.
Consequently,
we will not deal with any parts of the translation that involve joining
multiple domains.
This is a bit disappointing as this part of assembling a system can be
quite complex and is required for all but the tiniest of systems.
The `rosea` package and its underlying Tcl language constructs are well
suited to many of the problems one faces during the construction of
bridge operations.
It would be an interesting undertaking to construct another domain
for the Online Bookstore application and show how bridging in the
`rosea` implementation could be accomplished, but we do not undertake
that in this translation.

It should also be noted that no domain level operations are defined
for the online bookstore domain and so no external programming
interface to the domain is provided.

What we will end up with in this translation is the code for the domain
itself and a set of scenarios that exercise the domain.
You can think of this translation as providing the code for domain
and a preliminary set of unit tests in the form of execution scenarios.
When I undertake system development using translation,
this is usually the first step in the process of building the system.
It is quite useful to be able to run a domain in isolation and construct
a set of unit tests to exercise it.
But it only a first step.
When building a system of multiple domains,
itegration of the domains is also required.
I usually build a set of running programs integrating one additional domain
until the system is fully built.
The order of integration follows the usual mantra of
[quote]
Analyze from the top down and build from the bottom up.

A better way of stating that is to analyze the most application dependent
portions first, but build the system infrastructure first.
This is because it is usually easier to build code to drive a partial
system than it is to build stubs intelligent enough to simulate
missing system components.

These intermediary applications are useful for regression testing and
for dealing with the inevitable changes that happen to domain models.
Often the tests developed for the single domain unit tests are useful
in integrating domains.
It is important to remember that building is not _one big step_ but rather
one of building many integration and test applications, the final one of
which contains everything and is the one delivered.
This is a rather long explanation of the fact that what you will find
in this document is only the first part of what it would take to build
a real online bookstore system.

== Translation Conventions [[translationconventions,Translation Conventions]]

During the evolution of Executable UML,
the authors of
_Executable UML_
decided that referential attributes and identifying constraints were optional.
In my opinion, this decision was a regression of the method.
It certainly can reduce the clutter of the class diagram graphic and
reduce the need for invented identifiers,
but it makes it much easier to skip over the details of how
relationships are actually formalized.
Also, combining referential attributes makes constraints on the data model
and does so in a declarativefootnote:[as opposed to a procedural way]
way.

Regardless of your view of referential attributes,
to translate using `rosea` requires them to be reinserted into the
implementation.
The `rosea` translation is very relation oriented and referential attributes
are an integral part of the the relation model of data.
`Rosea` also requires each class to have an identifier.
We will point out where we have added attributes to deal with the
particulars of `rosea`.
The added benefit of supplying the referential attributes is that
`rosea` performs referential integrity checks and insures that the model
does not violate any of the constraints expressed by the relationships
and identifiers.

`Rosea` does not support the notion of derived attributes.
We have a couple of options to deal with them:

. Delete the derived attributes and add code into the translation to
compute them whenever they are read.
. Keep the derived attribute and add the redundant code required to
keep them up to date when any of the dependent attributes change.

We have chosen the later approach in this translation since it makes
access to the class diagram data from outside the domain much easier.
We should also note that the model as presented in the appendix
does not state what the composition of the derived attributes are.
But we can make reasonable guesses from the context and will point
them out as we encounter them.

Creating instances is also slightly different in `rosea`.
Action language allows one to create a class instance without supplying
all the attributes a value at the time the creation operation is invoked.
Since `rosea` is relational in its orientation and since a class instance
in `rosea` is mapped to a tuple in a relational variable,
all the values of the attributes of an instance must be given a
valid value for the data type of the attribute at the time of the
creation operation.
This will involve some shuffling around of actions that perform
instance creation.
In particular,
this model creates a number of class instances asynchronously.
Often the model will pass along as event parameters the values of
attributes which are then set in the state activity first executed
when the creation event is delivered.
It is a simple matter to remove those values as event parameters and
supply them as attribute values at the signaling of the creation event.
Since `rosea` supports the notion of a default value,
we will also use that feature to reduce some of the tedium of
supplying attribute values at instance creation time.

The matter of allowing instances to be created without setting all the
attributes to a value is a bit more troubling in general.
Since most translations are targeted at statically compiled languages
with the implicit assumption that class instances are held in memory,
the idea of creating a class instance usually maps to allocating
a piece of memory of the appropriate size.
Assigning attributes piecemeal in this regime is easily done.
However, for software architectures targeted at databases or, like
`rosea`, have strong relational underpinnings,
piecemeal setting of attribute values is not allowedfootnote:[Well
databases can handle it with some awkward NULL value nonsense, but
`rosea` has no notion of a NULL and none of the three values logic
required to deal with NULL values.].
The danger of piecemeal attribute assignment during creation is that
the possibility exists that an attribute will not be given an intial value
during certain execution paths through a state activity.
For in memory data structures, this means an attribute might have an arbitrary
value or the value represented by all bits of the memory being zero.
Best practice is to have the model set the values of all attributes at instance
creation time.

To make the correspondence to the text of the book explicit,
we will order the presentation in the same order as the book.
The domain is presented as three subsystems.
Within each subsystem,
the class definitions appear in the same order as the book.
Relationship definitions are dealt with differently.
In the book text,
each _side_ of the relationship is presented with the class that is a
participant in the relationship
and the relationship is stated from point of view of the participating class.
For `rosea`, we must define the relationships exactly once.
So we give relationship definitions near the class that contains
the referential attributes that formalize the relationship.
The exceptions to this are association with an associative class and
generalization relationships
For associative classes,
we define the corresponding association with them
and we define the generalization along with the superclass.
This ordering is used to clarify the translation's correspondence with the
book text.
`Rosea` allows an arbitrary order for these definitions.

Readers will probably find it essential to refer to the text of the book
as you read the translation.
It's impractical to print all the text and graphics of the model in this
document if only because it would be a violation of copyright law.
However, we will include small portions of the model here when it server
to clarify the translation.
Consequently,
you will find much of the translation presented with little additional
text.
We will comment when clarity is required or when we are doing something
`rosea` specific, but little else is really required.

== Data Types [[datatypes,Data Types]]

* Explain Tcl types
* Explain rosea checks

== Product Specification Subsystem [[productspecificationsubsytem,Product Specification Subsystem]]

The Product Specification Subsytem consists of the following classes.

[source,tcl]
----
<<Product Specification Subsystem>>=
<<Product Class Definition>>
<<Publisher Class Definition>>
<<Author Class Definition>>
<<Authorship Class Definition>>
<<Book Product Class Definition>>
<<Recording Product Class Definition>>
<<Software Product Class Definition>>
<<Special Order Product Class Definition>>
<<Stocked Product Class Definition>>
<<Product Category Class Definition>>
<<Recording Class Definition>>
<<Artist Class Definition>>
<<Performance Credit Class Definition>>
<<Recording Format Class Definition>>
<<Platform Class Definition>>
<<Computer Software Class Definition>>
----

=== Product Class [[productclass,Product]]

(((Product Specification,Classes,Product)))
[source,tcl]
----
<<Product Class Definition>>=
class Product {
    attribute productID string -id 1
    attribute productName string
    attribute copyright string -check {$copyright > 0}
    attribute unitPrice int -check {$unitPrice > 0}
    attribute description string
    attribute website string
    attribute currentlyAvailable boolean

    attribute categoryID string ; # <1>
    reference R15 ProductCategory -link categoryID

    attribute groupCode string ; # <2>
    attribute publisherCode string
    reference R1 Publisher -link groupCode -link publisherCode

}
----
<1> Here we introduce a referential attribute to <<productcategoryclass>>
to realize `R15`.
<2> Again, the need to be precise about how `R1` is realized requires
referential attributes.
In this case there are two referential attributes corresponding to the
two identifying attributes of <<publisherclass>>.
We will generally follow the convention to name referential attributes
that we are supplying to be the same as the identifying attribute they
reference.
It is not always possible to do that, but we feel it clarifies matters
especially as we are reintroducing the referential attributes into the model.

(((Product Specification,Relationships,R12)))
(((Product Specification,Relationships,R11)))
(((Product Specification,Relationships,R15)))
(((Product Specification,Relationships,R1)))
[source,tcl]
----
<<Product Class Definition>>=
generalization R12 Product SpecialOrderProduct StockedProduct
generalization R11 Product BookProduct RecordingProduct SoftwareProduct
association R15 Product 0..*--1 ProductCategory
association R1 Product 0..*--1 Publisher
----

=== Publisher Class [[publisherclass,Publisher]]

(((Product Specification,Classes,Publisher)))
[source,tcl]
----
<<Publisher Class Definition>>=
class Publisher {
    attribute groupCode string -id 1 ; # <1>
    attribute publisherCode string -id 1
    attribute name string
    attribute address string
    attribute website string
}
----
<1> Per the model, there are two identifying attributes.

=== Author Class [[authorclass,Author]]

(((Product Specification,Classes,Author)))
[source,tcl]
----
<<Author Class Definition>>=
class Author {
    attribute name string -id 1 ; # <1>
    attribute website string
    attribute email string
}
----
<1> The implication of using `name` as an identifier is that authors
cannot have the same name.
Probably not true in the _real world_.

=== Authorship Class [[authorshipclass,Authorship]]

Authorship is an association class.
From the relational view,
association classes have referential attributes to refer to both the
participating classes.
Because `R2` is a many-to-many association,
those referential attributes also constitute an identifier.
It is also true that the instances of the association class correspond
one-to-one to the instances of the association itself and that the
number of instances is less than or equal to the product of the number of
instances of the participating classes.

(((Product Specification,Classes,Authorship)))
[source,tcl]
----
<<Authorship Class Definition>>=
class Authorship {
    attribute preCredit string -default {}
    attribute postCredit string -default {}

    attribute name string -id 1 ; # <1>
    reference R2 Author -link name
    attribute productID string -id 1
    reference R2 BookProduct -link productID

    attribute previousName string ; # <2>
    attribute previousProductID string
    reference R3 Authorship\
        -link {previousName name}\
        -link {previousProductID productID} ; # <3>
}
----
<1> The association class has referential attributes that refer to
both participating classes.
<2> `R3` is a reflexive association so we must introduce referential
attributes to realize the association.
Since there are two identifying attributes there will be two referential
attributes.
<3> The referential attribute linkage can be a bit confusing at first.
You can think of this as a form of _back linkage_.
As one Authorship instance follows another, the following instance
has referential attributes that refer back to the previous instance
in the ordering.
Hence the names of the referential attributes.
The start of the ordering is that instance which has
the empty string value for the `previousName` and `previousProductID`
attributes.

(((Product Specification,Relationships,R3)))
(((Product Specification,Relationships,R2)))
[source,tcl]
----
<<Authorship Class Definition>>=
association R3 Authorship 0..1--0..1 Authorship -path {name previousName}
association R2 BookProduct 1..*--0..* Author -associator Authorship
----

To be absolutely pedantic the `R3`,
relationship does not, in and of itself, guarantee a linear ordering.
It requires that the initial instance population or the action code set things
up correctly to achieve desired ordering.
In practice, this is easily done and the number of classes required to
guarantee an ordering by virtue of referential integrity constraints is
usually not worth it.
Another alternative is to realize this relationship using an attribute
that is ordered, such as a sequential integer.
Then, the ordered set of authors of a book could be found by selecting on the
`productID` and sorting by the ordering attribute.
Depending upon the way Authorship is being used might favor one approach
over another.
Here we just stick with the straight forward referential attributes.

=== Book Product Class [[bookproductclass,BookProduct]]

(((Product Specification,Classes,BookProduct)))
[source,tcl]
----
<<Book Product Class Definition>>=
class BookProduct {
    attribute productID string -id 1
    attribute bookNumber string
    attribute titleCode string
    attribute title string
    attribute subtitle string

    reference R11 Product -link productID ; # <1>
}
----
<1> All subclasses of a generalization have a referential attribute
back to the superclass of the generalization.
Since there is a one-to-one correspondence between a subclass and
its superclass, the referential attribute is also an identifying attribute.
The fact that an attribute can serve many roles happens often
and is another facet of the ability of referential attributes and
identity constraints to constraint the instance attributes values properly.

=== Recording Product Class [[recordingproductclass,Recording Product]]

In addition to being a subclass in a generalization,
the `Recording Product` class is also an associative class.
We follow the same pattern here as we established in the `Authorship`
class translation.

(((Product Specification,Classes,Recording Product)))
[source,tcl]
----
<<Recording Product Class Definition>>=
class RecordingProduct {
    attribute productID string -id 1
    attribute runningTime string

    reference R11 Product -link productID

    attribute recordingID string -id 2
    attribute formatID string -id 2
    reference R16 Recording -link recordingID
    reference R16 RecordingFormat -link formatID
}
----

(((Product Specification,Relationships,R16)))
[source,tcl]
----
<<Recording Product Class Definition>>=
association R16 Recording 1..*--1..* RecordingFormat\
        -associator RecordingProduct
----

=== Software Product Class [[softwareproductclass,Software Product]]

(((Product Specification,Classes,Software Product)))
[source,tcl]
----
<<Software Product Class Definition>>=
class SoftwareProduct {
    attribute productID string -id 1
    attribute productVersion string

    reference R11 Product -link productID

    attribute softwareID string
    reference R20 ComputerSoftware -link softwareID

    attribute platformID string
    reference R19 Platform -link platformID
}
----

(((Product Specification,Relationships,R19)))
(((Product Specification,Relationships,R20)))
[source,tcl]
----
<<Software Product Class Definition>>=
association R19 SoftwareProduct 1..*--1 Platform
association R20 SoftwareProduct 1..*--1 ComputerSoftware
----

=== Special Order Product Class [[specialorderproductclass,Special Order Product]]

(((Product Specification,Classes,Special Order Product)))
[source,tcl]
----
<<Special Order Product Class Definition>>=
class SpecialOrderProduct {
    attribute productID string -id 1
    attribute specialOrderInstructions string
    attribute daysToDeliver int

    reference R12 Product -link productID
}
----

=== Stocked Product Class [[stockedproductclass,Stocked Product]]

(((Product Specification,Classes,Stocked Product)))
[source,tcl]
----
<<Stocked Product Class Definition>>=
class StockedProduct {
    attribute productID string -id 1
    attribute quantityOnHand int
    attribute reorderThreshold int
    attribute reorderIncrement int
    attribute reorderInstructions string

    reference R12 Product -link productID
}
----

=== Product Category Class [[productcategoryclass,Product Category]]

(((Product Specification,Classes,Product Category)))
[source,tcl]
----
<<Product Category Class Definition>>=
class ProductCategory {
    attribute categoryID string -id 1
    attribute categoryName string
    attribute parentCategoryID string

    reference R14 ProductCategory -link {parentCategoryID categoryID}
}
----

(((Product Specification,Relationships,R14)))
[source,tcl]
----
<<Product Category Class Definition>>=
association R14 ProductCategory 0..*--0..1 ProductCategory
----

=== Recording Class [[recordingclass,Recording]]

(((Product Specification,Classes,Recording)))
[source,tcl]
----
<<Recording Class Definition>>=
class Recording {
    attribute recordingID string -id 1
    attribute title string
}
----

=== Artist Class [[artistclass,Artist]]

(((Product Specification,Classes,Artist)))
[source,tcl]
----
<<Artist Class Definition>>=
class Artist {
    attribute artistID string -id 1
    attribute artistName string
}
----

=== Performance Credit Class [[performancecreditclass,Performance Credit]]

(((Product Specification,Classes,Performance Credit)))
[source,tcl]
----
<<Performance Credit Class Definition>>=
class PerformanceCredit {
    attribute role string -default {}

    attribute recordingID string -id 1
    attribute artistID string -id 1
    reference R17 Recording -link recordingID
    reference R17 Artist -link artistID

    attribute prevRecordingID string
    attribute prevArtistID string
    reference R18 PerformanceCredit\
        -link {prevRecordingID recordingID}\
        -link {prevArtistID artistID}
}
----

(((Product Specification,Relationships,R17)))
(((Product Specification,Relationships,R18)))
[source,tcl]
----
<<Performance Credit Class Definition>>=
association R17 Recording 1..*--1..* Artist -associator PerformanceCredit
association R18 PerformanceCredit 0..1--0..1 PerformanceCredit\
    -path {recordingID prevRecordingID artistID prevArtistID}
----

=== Recording Format Class [[recordingformatclass,Recording Format]]

(((Product Specification,Classes,Recording Format)))
[source,tcl]
----
<<Recording Format Class Definition>>=
class RecordingFormat {
    attribute formatID string -id 1
    attribute formatName string
}
----

=== Platform Class [[platformclass,Platform]]

(((Product Specification,Classes,Platform)))
[source,tcl]
----
<<Platform Class Definition>>=
class Platform {
    attribute platformID string -id 1
    attribute platformName string
}
----

=== Computer Software Class [[computersoftwareclass,Computer Software]]

(((Product Specification,Classes,Computer Software)))
[source,tcl]
----
<<Computer Software Class Definition>>=
class ComputerSoftware {
    attribute softwareID string -id 1
    attribute title string
}
----

== Ordering Subsystem [[orderingsubsytem,Ordering Subsystem]]

The Ordering Subsystem consist of the following classes.

[source,tcl]
----
<<Ordering Subsystem>>=
<<Customer Class Definition>>
<<Order Class Definition>>
<<Product Selection Class Definition>>
<<Shopping Cart Class Definition>>
<<Credit Card Charge Class Definition>>
----

=== Customer Class [[customerclass,Customer]]

(((Ordering,Classes,Customer)))
[source,tcl]
----
<<Customer Class Definition>>=
class Customer {
    attribute email string -id 1
    attribute name string
    attribute shippingAddress string
    attribute phone string
    attribute purchasesMade int -default 0 ; # <1>
}
----
<1> When Customer instances are created, they have certainly not made
any purchases so we can specify a default value to ease the burden
of specifying attributes at creation time.

=== Order Class [[orderclass,Order]]

The `Order` class is the first we encounter that has a state model
associated with it.

(((Ordering,Classes,Order)))
[source,tcl]
----
<<Order Class Definition>>=
class Order {
    attribute orderID string -id 1
    attribute dateOrderPlaced string -default {}
    attribute totalValue int
    attribute recipient string
    attribute deliveryAddress string
    attribute contactPhone string

    attribute cartID string -default {} ; # <1>
    reference R10 ShoppingCart -link cartID

    attribute email string -default {} ; # <2>
    reference R5 Customer -link email

    statemodel {
        <<Order State Model>>
    }
}
----
<1> R10 is conditional, so when we create an instance of Order
we will start with it being unrelated to any `ShoppingCart`.
<2> Likewise, with R5 being conditional.

(((Ordering,Relationships,R10)))
(((Ordering,Relationships,R5)))
[source,tcl]
----
<<Order Class Definition>>=
association R10 Order 0..1--1 ShoppingCart
association R5 Order 1..*--0..1 Customer ; # <1>
----
<1> There is an interesting policy decision represented here.
A Customer is not a Customer unless he/she has placed at least one order.
Interesting -- not wrong or bad -- just interesting.

(((Ordering,State Models,Order)))
[source,tcl]
----
<<Order State Model>>=
transition @ - checkOut -> EstablishingCustomerandVerifyingPayment ; # <1>
----
<1> Here we encounter our first creation event.
In `rosea` the `@` is used to represent the pseudo-initial state
from which the creation event transitions.

[source,tcl]
----
<<Order State Model>>=
state EstablishingCustomerandVerifyingPayment {
        cart accountNumber billingAddress cardExpirationDate
        cardholderName customerEmail} {
    R10 link $self $cart

    set customer [Customer findById email $customerEmail]
    assignAttribute $self recipient deliveryAddress contactPhone
    if {[isEmptyRef $customer]} {
        set customer [Customer create\
            email $customerEmail\
            name $recipient\
            shippingAddress $deliveryAddress\
            phone $contactPhone
        ]
    } else {
        updateAttribute $customer\
            name $recipient\
            shippingAddress $deliveryAddress\
            phone $contactPhone
    }

    R5 link $self $customer

    updateAttribute $self dateOrderPlaced [clock format [clock seconds]]

    signal $self submitCharge $accountNumber $billingAddress\
        $cardExpirationDate $cardholderName
}

transition EstablishingCustomerandVerifyingPayment - submitCharge ->\
    SubmittingCharge
----

The translation of the state activity to Tcl is quite direct.
Action language `relate` commands correspond to the `link` subcommand
for the relationship involved, in this case `R10`.
We also see the differences that result from creating having to supply
the values of all the attributes of the created instance.
Using `rosea`, we must make a clear distinction between creating the instance
and updating the attributes of an existing instance.

[source,tcl]
----
<<Order State Model>>=
state SubmittingCharge {accountNumber billingAddress cardExpirationDate
        cardholderName} {
    CreditCardCharge createasync makeCharge [list $self]\
        chargeID [uuid::uuid generate]\
        accountNumber $accountNumber\
        cardholderName $cardholderName\
        billingAddress $billingAddress\
        cardExpirationDate $cardExpirationDate\
        chargeAmount [readAttribute $self totalValue] ; # <1>
}

transition SubmittingCharge - paymentApproved -> BeingPackedandShipped
transition SubmittingCharge - paymentDeclined -> PaymentNotApproved
----
<1> Generating an event to the class _creator_, _i.e._ generating a
creation event, is accomplished as the `createasync` subcommand on the
target class.
Again, all the values of the attributes must be supplied since
the instance must be created before the creation event is dispatched.
The `[list $self]` argument is the parameter of the creation event itself,
_i.e._ the instance reference of an order is a parameter to the `makeCharge`
event.

Note that we have factored the `makeCharge` event parameters.
In the model graphic on page 342,
you can see that there are many parameters passed with the event.
All of these parameters, except the `Order` instance reference,
are simply used to set the values of the `CreditCardCharge` instance
and so we have factored them out to the creation event generation
as discussed above.
This is an interesting example of how the idoms of action language have
to be translated into a different set of idoms in Tcl.

[source,tcl]
----
<<Order State Model>>=
state PaymentNotApproved {} {
    set customer [findRelated $self R5]
    # generate chargeDeclined(customerEmail: customer.email)
    #       to EE_OnlineCustomer
    EE_OnLineCustomer::chargeDeclined [readAttribute $customer email] ; # <1>
}

transition PaymentNotApproved - subCharge -> SubmittingCharge
----
<1> The action language text from the model is shown on the line immediately
above.
`Rosea` does not have any direct support for generating events to external
entities.
Instead,
we create explict bridge operations, in this case 
`EE_OnLineCustomer::chargeDeclined`, passing the required parameters.
That bridge operation can then map the semantics of a _declined charge_
onto the appropriate operation of the domain that represents the
Online Customer external entity.
In a `rosea` translation,
all the interactions with external entities are represented by
procedures.
Those procedures then handle whether the interaction is synchronous or
event based.
We will see examples of this in the <<externalentities>> section below.

[source,tcl]
----
<<Order State Model>>=
state BeingPackedandShipped {} {
    set customer [findRelated $self R5]
    EE_OnLineCustomer::chargeApproved [readAttribute $customer email]

    assignAttribute $self recipient deliveryAddress contactPhone
    Shipment createasync requestShipment [list $self]\
        shipmentID [uuid::uuid generate]\
        recipient $recipient\
        deliveryAddress $deliveryAddress\
        contactPhone $contactPhone
}
transition BeingPackedandShipped - orderDelivered -> DeliveredtoCustomer

state DeliveredtoCustomer {} {
    set customer [findRelated $self R5] ; # <1>
    EE_OnLineCustomer::orderReportedDelivered [readAttribute $customer email]
}
----
<1> So the question arises as to whether we should test the `customer`
instance reference for being empty.
After all, R5 is conditional on the `Customer` side.
In this case the answer is no, since all paths to this state come
through the *Establishing Customer and Verifying Payment* state where
a link to `R5` is made and so we have every expectation
that we will find a single instance related by `R5`.
We know that we will find at most one since `R5` has a multiplicity of one
and any attempt to link an order to multiple `Customers` will fail
referential integrity checks.
So, might we want make the test anyway just to be sure?
Again, the answer is no.
If somehow the `customer` instance reference does not refer to
exactly one instance then the `readAttribute` command will throw an
error (as documented in the manual for that command).
The lesson here is that superfluous multiplicity tests are not necessary
and only serve to clutter the code.
The referential integrity checks performed by `rosea` go a long way to
insure correct operation.

=== Product Selection Class [[productselectionclass,Product Selection]]

The `ProductSelection` class is an associative class and has a state model.
The state model is interesting because it has both a creation event
and a terminal state.
The state, `RemovingSelection`, is terminal and the instance is deleted
after executing the state activity for that state.

(((Ordering,Classes,Product Selection)))
[source,tcl]
----
<<Product Selection Class Definition>>=
class ProductSelection {
    attribute quantity int -default 0
    attribute unitPriceOfSelection int -default 0
    attribute selectionValue int -default 0

    attribute productID string -id 1 -default {} ; # <1>
    attribute cartID string -id 1 -default {}
    reference R4 Product -link productID
    reference R4 ShoppingCart -link cartID

    statemodel {
        <<Product Selection State Model>>
    }
}
----
<1> Note the referential attributes used needed for the class association
and that those attributes form an identifier.

(((Ordering,Relationships,R4)))
[source,tcl]
----
<<Product Selection Class Definition>>=
association R4 ShoppingCart 0..*--1..* Product -associator ProductSelection
----

(((Ordering,State Models,Product Selection)))
[source,tcl]
----
<<Product Selection State Model>>=
initialstate NewSelection ; # <1>
----
<1> As it turns out, we also do synchronous creation of this class
so we want to be explicit about the initial state.

[source,tcl]
----
<<Product Selection State Model>>=
transition @ - addSelection -> NewSelection

state NewSelection {cartID productID quantity} {
    set product [Product findById productID $productID]
    updateAttribute $self\
        productID $productID\
        cartID $cartID\
        unitPriceOfSelection [readAttribute $product unitPrice] ; # <1>

    signal $self changeQuantity $quantity
}
transition NewSelection - changeQuantity -> ChangingQuantity
----
<1> So this is a bit tricky here.
If an instance of `ProductSelection` is created asynchronously,
then this state actvity is executed.
We need to link up the references to the participating instances of
`Product` and `ShoppingCart`.
We do that by updating the `productId` and `cartID` referential attributes.
However, synchronous creation happens as a side effect of linking
instances of `Product` and `ShoppingCart` across R4.
In that case, the referential attributes are set by the `link` operation,
the instance is placed in the `NewSelection` state and the
above state activity is *not* executed.
This also implies that the synchonous creation must supply values for
the `quantity`, `unitPriceOfSelection` and `selectionValue` attributes.
Okay, I said it was a bit tricky.

Here we run into a quandary in the model.
The two state below signal the `cartUpdated` event to a `ShoppingCart`.
Unfortunately, the Shopping Cart state model (see page 340) does not
define a `cartUpdated` event.
So what to do?
Rather than signaling an event to the `ShoppingCart`,
we will invoke an instance based operation on it.
This means we do not have to modify the state diagram and it will give
us an opportunity to update the `totalValue` derived attribute.

[source,tcl]
----
<<Product Selection State Model>>=
state ChangingQuantity {quantityOfSelection} {
    withAttribute $self quantity unitPriceOfSelection selectionValue {
        set quantity $quantityOfSelection
        set selectionValue [expr {$quantity * $unitPriceOfSelection}]
    }
    if {$quantity == 0} {
        signal $self removeSelection
    } else {
        set cart [findRelated $self ~R4]
        instop $cart cartUpdated
    }
}
transition ChangingQuantity - removeSelection -> RemovingSelection

state RemovingSelection {} {
    set cart [findRelated $self ~R4]
    R4 unlink $self
    set remainingProduct [findRelated $cart R4]
    if {[isEmptyRef $remainingProduct]} {
        signal $cart cancel
    } else {
        instop $cart cartUpdated
    }
}
terminal RemovingSelection
----

=== ShoppingCart Class [[shoppingcartclass,ShoppingCart]]

(((Ordering,Classes,ShoppingCart)))
[source,tcl]
----
<<Shopping Cart Class Definition>>=
class ShoppingCart {
    attribute cartID string -id 1
    attribute totalValue int

    statemodel {
        <<Shopping Cart State Model>>
    }

    instop cartUpdated {} {
        updateAttribute $self totalValue [tcl::mathop::+ {*}[pipe {
                findRelated $self {R4 ProductSelection} |
                deRef ~ selectionValue |
                relation list ~ selectionValue
            }]]
    } ; # <1>
}
----
<1> The intent here is much simpler than the code looks.
We want to update the `totalValue` attribute to be the sum of
the values of the `selectionValue` attribute for all the
instances of `ProductSelection` related to this cart.
How we get there is a bit terse.
The `tcl::mathop::+` command will sum all of its arguments.
So we need to each `selectionValue` attribute value to be an argument
to the `+` command.
We gather all the `selectionValue` attribute values by:
. finding all the related `ProductSelection` instances.
. dereference the `selectionValue` attribute from those instances.
This yields a relation value where each tuple has a `selectionValue` attribute.
. projecting out a Tcl list from the `selectionValue` attributes.
+
The `pipe` command is a control structure command that sequences the
three commands taking the result of one command and substituting it as an
argument to the next command where the `~` argument is located.
The result of the `pipe` command is the Tcl list generated by the
final `relation list` command and the `{*}` operator
takes that list and makes it into individual arguments to the
`tcl::mathop::+` command.
This sequence could have been written in other ways, of course.
The example here shows some of the expressive power of the underlying
relational algebra but comes at the expense of understanding those
commands.

(((Ordering,State Models,Shopping Cart)))
[source,tcl]
----
<<Shopping Cart State Model>>=
transition @ - startCart -> NewOrder

state NewOrder {productID quantity} {
    signal $self addSelection $productID $quantity
}
transition NewOrder - addSelection -> AddingSelectiontoOrder

state AddingSelectiontoOrder {productID quantity} {
    set product [Product findById productID $productID]
    set unitprice [readAttribute $product unitPrice]
    set selectionvalue [expr {$unitprice * $quantity}]
    set newSelection [R4 link $self $product\
        quantity $quantity\
        unitPriceOfSelection $unitprice\
        selectionValue $selectionvalue\
    ] ; # <1>
    withAttribute $self totalValue {
        incr totalValue $selectionvalue
    }
}
transition AddingSelectiontoOrder - addSelection -> AddingSelectiontoOrder
transition AddingSelectiontoOrder - cancel -> CancelingEntireOrder
transition AddingSelectiontoOrder - checkOut ->\
        EstablishingCustomerandVerifyingPayment
----
<1> Linking `R4` results in the synchronous creation of an instance
of `ProductSelection`.
As discussed above,
we must supply the values of all the non-referential attributes of the
associative class.
The setting of the value of the referential attributes is handled
by the `R4 link` command.

[source,tcl]
----
<<Shopping Cart State Model>>=
state CancelingEntireOrder {} {
    set selections [findRelated $self {R4 ProductSelection}]
    R4 unlink $selections
}
terminal CancelingEntireOrder

state EstablishingCustomerandVerifyingPayment {
        accountNumber billingAddress cardExpirationDate
        cardholderName customerEmail customerName customerPhone
        shippingAddress} {
    Order createasync checkOut [list $self $accountNumber\
        $billingAddress $cardExpirationDate $cardholderName\
        $customerEmail]\
        orderID [uuid::uuid generate]\
        totalValue [readAttribute $self totalValue]\
        recipient $customerName\
        deliveryAddress $shippingAddress\
        contactPhone $customerPhone
}
----

=== Credit Card Charge Class [[creditcardchargeclass,Credit Card Charge]]

(((Ordering,Classes,Credit Card Charge)))
[source,tcl]
----
<<Credit Card Charge Class Definition>>=
class CreditCardCharge {
    attribute chargeID string -id 1
    attribute accountNumber string
    attribute cardholderName string
    attribute billingAddress string
    attribute cardExpirationDate string
    attribute dateChargeMade string -default {}
    attribute chargeAmount int
    attribute approvalCode string -default {}

    attribute attemptOrderID string -default {}
    reference R7 Order -link {attemptOrderID orderID}

    attribute paidOrderID string -default {}
    reference R8 Order -link {paidOrderID orderID}

    statemodel {
        <<Credit Card Charge State Model>>
    }
}
----

(((Ordering,Relationships,R7)))
(((Ordering,Relationships,R8)))
[source,tcl]
----
<<Credit Card Charge Class Definition>>=
association R7 CreditCardCharge 0..*--1 Order
association R8 CreditCardCharge 0..1--0..1 Order ; #<1>
----
<1> This looks like an error in the model.

(((Ordering,State Model,Credit Card Charge)))
[source,tcl]
----
<<Credit Card Charge State Model>>=
transition @ - makeCharge -> RequestingChargeApproval

state RequestingChargeApproval {order} {
    R7 link $self $order
    updateAttribute $self dateChargeMade [clock format [clock seconds]]

    withAttribute $self accountNumber billingAddress cardholderName\
            cardExpirationDate chargeAmount {
        EE_CreditCardCompany::requestChargeApproval\
            $accountNumber\
            $billingAddress\
            $cardholderName\
            $cardExpirationDate\
            [readAttribute $self chargeID]\
            $chargeAmount
    }

    delaysignal 60000 $self chargeProcessingNotCompleted
}
transition RequestingChargeApproval - chargeProcessed -> ProcessingCompleted
transition RequestingChargeApproval - chargeProcessingNotCompleted ->\
    DeclineForTimeout

state ProcessingCompleted {resultCode} {
    updateAttribute $self approvalCode $resultCode
    set order [findRelated $self R7]
    canceldelayed $self $order chargeProcessingNotCompleted
    R8 link $self $order
    if {$resultCode eq "approved"} {
        signal $order paymentApproved
    } else {
        signal $order paymentDeclined
    }
}

state DeclineForTimeout {} {
    updateAttribute $self approvalCode connectionFailed
    set order [findRelated $self R7]
    signal $order paymentDeclined
}
----

== Shipping Subsystem [[shippingsubsytem,Shipping Subsystem]]

[source,tcl]
----
<<Shipping Subsystem>>=
<<Shipment Class Definition>>
<<Shipping Company Class Definition>>
<<Warehouse Clerk Class Definition>>
<<Warehouse Class Definition>>
<<Shipping Clerk Class Definition>>
<<Stock Clerk Class Definition>>
<<Off Duty Clerk Class Definition>>
<<Shipment Item Class Definition>>
----

=== Shipment Class [[shipmentclass,Shipment]]

(((Shipping,Classes,Shipment)))
[source,tcl]
----
<<Shipment Class Definition>>=
class Shipment {
    attribute shipmentID string -id 1
    attribute shippingCompany string -default {}
    reference R21 ShippingCompany -link {shippingCompany companyName}
    attribute trackingNumber string -default {}

    attribute recipient string
    attribute deliveryAddress string
    attribute contactPhone string
    attribute timePrepared string -default {}
    attribute timePickedUp string -default {}
    attribute timeDelivered string -default {}
    attribute waitingToBePacked boolean -default true

    attribute warehouseName string -default {}
    reference R24 Warehouse -link warehouseName

    attribute clerkID string -default {}
    reference R22 WarehouseClerk -link clerkID

    attribute orderID string -default {}
    reference R6 Order -link orderID

    statemodel {
        <<Shipment State Model>>
    }

    <<Shipment Operations>>
}
----

(((Shipping,Relationships,R21)))
(((Shipping,Relationships,R24)))
(((Shipping,Relationships,R22)))
(((Shipping,Relationships,R6)))
[source,tcl]
----
<<Shipment Class Definition>>=
association R21 Shipment 0..*--0..1 ShippingCompany ; #<1>
association R24 Shipment 0..*--1 Warehouse
association R22 Shipment 0..*--0..1 WarehouseClerk
association R6 Shipment 0..1--1 Order
----
<1> The model has this relationship as unconditional on the Shipping
Company side.
This is problematic when a Shipment is created.
At that point in time we have no shipping company or tracking number.
We could probably choose a company and get a number before the
Shipment is created, but that work seems to be handled by the
Shipment state model.
That state model implies that we could pack the shipment or
receive a tracking number in either order.
Consequently, the easiest thing to do is to weaken the relationship
to make it conditional on the ShippingCompany side to await the
final company and tracking number assignment.

(((Shipping,State Model,Shipment)))
[source,tcl]
----
<<Shipment State Model>>=
transition @ - requestShipment -> PreparingShipment

state PreparingShipment {order} {
    R6 link $self $order

    set warehouse [Warehouse chooseWarehouse [readAttribute $order orderID]]
    R24 link $self $warehouse

    set items [findRelated $order R10 {R4 ProductSelection}] ; #<1>
    R9 link $items $self

    signal $warehouse shipmentReadyToPack ; #<2>
}
transition PreparingShipment - packed -> PackedandAwaitingTrackingNumber
transition PreparingShipment - trackingNumberAssigned ->\
    NumberAssignedandWaitingtobePacked

state PackedandAwaitingTrackingNumber {clerkID} {
    instop $self updatePackingInfo $clerkID
}
transition PackedandAwaitingTrackingNumber - trackingNumberAssigned ->\
    NumberAssigned

state NumberAssignedandWaitingtobePacked {
        shippingCompany trackingNumber} {
    instop $self updateTrackingInfo $shippingCompany $trackingNumber
}
transition NumberAssignedandWaitingtobePacked - packed -> Packed

state NumberAssigned {shippingCompany trackingNumber} {
    instop $self updateTrackingInfo $shippingCompany $trackingNumber
}
transition NumberAssigned - pickedUp -> InTransittoCustomer

state Packed {clerkID} {
    instop $self updatePackingInfo $clerkID
}
transition Packed - pickedUp -> InTransittoCustomer

state InTransittoCustomer {} {
    updateAttribute $self timePickedUp [clock format [clock seconds]]
}
transition InTransittoCustomer - deliveryConfirmed -> Delivered

state Delivered {timeDelivered} {
    updateAttribute $self timeDelivered [clock format [clock seconds]]
    set order [findRelated $self R6]
    signal $order orderDelivered
}
----
<1> The model doesn't seem to establish R9 with the Shipment.
We do so here assuming no items are shipped initially.
Presumably the Shipping Clerk will have to update the quantity
shipped as the items are packed.
<2> This event should be going to the Warehouse.
The model graphic ships it off to an external entity,
yet the event name appears on the Warehouse state diagram and it is
the Warehouse class that assigns Shipping Clerks for packing.

[source,tcl]
----
<<Shipment Operations>>=
instop updateTrackingInfo {shippingCompany trackingNumber} {
    updateAttribute $self trackingNumber $trackingNumber
    set company [ShippingCompany findById companyName $shippingCompany]
    R21 link $self $company
}

instop updatePackingInfo {clerkID} {
    updateAttribute $self timePrepared [clock format [clock seconds]]

    set clerk [ShippingClerk findById clerkID $clerkID]
    R22 link $self $clerk

    EE_ShippingCompany::shipmentReadyForPickup\
        [readAttribute $self shipmentID]
}
----

=== Shipping Company Class [[shippingcompanyclass,Shipping Company]]

(((Shipping,Classes,Shipping Company)))
[source,tcl]
----
<<Shipping Company Class Definition>>=
class ShippingCompany {
    attribute companyName string -id 1
    attribute trackingWebsite string
    attribute customerServicePhone string
    attribute localDispatchPhone string
    attribute localOffice string
    attribute localContact string
}
----

=== Warehouse Class [[warehouseclass,Warehouse]]

(((Shipping,Classes,Warehouse)))
[source,tcl]
----
<<Warehouse Class Definition>>=
class Warehouse {
    attribute warehouseName string -id 1
    attribute warehouseLocation string

    statemodel {
        <<Warehouse State Model>>
    }

    classop chooseWarehouse {orderID} {
        return [pipe {
            relation tag [set [namespace current]] Order\
                    -ascending warehouseName |
            relation restrictwith ~ {$Order == 0} |
            relation eliminate ~ Order |
            ::rosea::Helpers::ToRef [namespace current] ~
        }]
    }
}
----

(((Shipping,State Model,Warehouse)))
[source,tcl]
----
<<Warehouse State Model>>=
initialstate WaitingforaShipment
defaulttrans IG

state WaitingforaShipment {} {
    set readyShipment [findRelatedWhere $self ~R24 {$waitingToBePacked}]
    if {[isNotEmptyRef $readyShipment]} {
        signal $self shipmentReadyToPack
    }
}
transition WaitingforaShipment - shipmentReadyToPack -> WaitingforaFreeClerk

state WaitingforaFreeClerk {} {
    set freeClerk [findRelatedWhere $self {~R25 {~R27 ShippingClerk}}\
        {$awaitingAssignment eq "true"}]
    puts $freeClerk
    if {[isNotEmptyRef $freeClerk]} {
        signal $self clerkFree
    }
}
transition WaitingforaFreeClerk - clerkFree -> AssigningClerktoShipment

state AssigningClerktoShipment {} {
    set readyShipment [findRelatedWhere $self ~R24 {$waitingToBePacked}]
    set freeClerk [findRelatedWhere $self {~R25 {~R27 ShippingClerk}}\
        {$awaitingAssignment}]
    R23 link $readyShipment $freeClerk
    updateAttribute $readyShipment waitingToBePacked false
    updateAttribute $freeClerk awaitingAssignment false

    signal $freeClerk clerkAssigned
    signal $self clerkAssignedToShipment
}
transition AssigningClerktoShipment - clerkAssignedToShipment ->\
        WaitingforaShipment
----

=== Warehouse Clerk Class [[warehouseclerkclass,Warehouse Clerk]]

(((Shipping,Classes,Warehouse Clerk)))
[source,tcl]
----
<<Warehouse Clerk Class Definition>>=
class WarehouseClerk {
    attribute clerkID string -id 1
    attribute clerkName string
    attribute goOffDutyAtEndOfJob boolean -default false

    attribute warehouseName string
    reference R25 Warehouse -link warehouseName
}
----

(((Shipping,Relationships,RR)))
[source,tcl]
----
<<Warehouse Clerk Class Definition>>=
generalization R27 WarehouseClerk OffDutyClerk StockClerk ShippingClerk
association R25 WarehouseClerk 1..*--1 Warehouse
----

=== Shipping Clerk Class [[shippingclerkclass,Shipping Clerk]]

(((Shipping,Classes,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk Class Definition>>=
class ShippingClerk {
    attribute clerkID string -id 1
    reference R27 WarehouseClerk -link clerkID

    attribute awaitingAssignment boolean -default true

    attribute shipmentID string -default {}
    reference R23 Shipment -link shipmentID

    statemodel {
        <<Shipping Clerk State Model>>
    }
}
----

(((Shipping,Relationships,R23)))
[source,tcl]
----
<<Shipping Clerk Class Definition>>=
association R23 ShippingClerk 0..1--0..1 Shipment
----

(((Shipping,State Model,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk State Model>>=
transition @ - startShipping -> WaitingforaJob

state WaitingforaJob {} {
    updateAttribute $self awaitingAssignment true
    set warehouse [findRelated R27 R25]
    signal $warehouse clerkFree
}
transition WaitingforaJob - clerkAssigned -> SelectingBooks
transition WaitingforaJob - offDuty -> OffDuty

state SelectingBooks {} {
    EE_ShippingClerk::shipmentReadyToPack\
        [readAttribute $self shipmentID]
}
transition SelectingBooks - booksSelected -> PackingBox

state PackingBox {} {
    generate $self boxPacked
}
transition PackingBox - boxPacked -> SealingBox

state SealingBox {} {
    generate $self boxSealed
}
transition SealingBox - boxSealed -> AttachingShippingLabel

state AttachingShippingLabel {} {
    generate $self shippingLabelAttached
}
transition AttachingShippingLabel - shippingLabelAttached ->\
    DeliveringBoxtoLoadingDock

state DeliveringBoxtoLoadingDock {} {
    generate $self boxAtLoadingDoc
}
transition DeliveringBoxtoLoadingDock - boxAtLoadingDoc -> CompletingJob

state CompletingJob {} {
    set currentShipment [findRelated $self R23]
    signal $currentShipment packed [readAttribute $self clerkID]
    R23 unlink $self $currentShipment
    if {[readAttribute $self goOffDutyAtEndOfJob]} {
        signal $self offDuty
    } else {
        updateAttribute $self awaitingAssignment true
        set myWarehouse [findRelated $self R27 R25]
        signal $myWarehouse clerkFree
    }
}
transition CompletingJob - clerkAssigned -> SelectingBooks
transition CompletingJob - offDuty -> OffDuty

state OffDuty {} {
    R27 migrate $self OffDutyClerk
}
----

=== Stock Clerk Class [[stockclerkclass,Stock Clerk]]

(((Shipping,Classes,Stock Clerk)))
[source,tcl]
----
<<Stock Clerk Class Definition>>=
class StockClerk {
    attribute clerkID string -id 1
    reference R27 WarehouseClerk -link clerkID
    attribute idle boolean -default true
}
----

=== Off Duty Clerk Class [[offdutyclerkclass,Off Duty Clerk]]

(((Shipping,Classes,Off Duty Clerk)))
[source,tcl]
----
<<Off Duty Clerk Class Definition>>=
class OffDutyClerk {
    attribute clerkID string -id 1
    reference R27 WarehouseClerk -link clerkID
}
----

=== Shipment Item Class [[shipmentitemclass,Shipment Item]]

(((Shipping,Classes,Shipment Item)))
[source,tcl]
----
<<Shipment Item Class Definition>>=
class ShipmentItem {
    attribute shipmentID string -id 1
    reference R9 Shipment -link shipmentID

    attribute productID string -id 1
    attribute cartID string -id 1
    reference R9 ProductSelection -link productID -link cartID

    attribute quantityShipped int -default 0
}
----

(((Shipping,Relationships,R9)))
[source,tcl]
----
<<Shipment Item Class Definition>>=
association R9 Shipment 0..*--1..* ProductSelection -associator ShipmentItem
----

== Product Specification Subsystem Population [[productspecificationsubsystempopulation,Product Specification Subsystem Population]]

[source,tcl]
----
<<Product Specification Population>>=
<<Product Population>>
<<Publisher Population>>
<<Author Population>>
<<Authorship Population>>
<<Book Product Population>>
<<Recording Product Population>>
<<Software Product Population>>
<<Special Order Product Population>>
<<Stocked Product Population>>
<<Product Category Population>>
<<Recording Population>>
<<Artist Population>>
<<Performance Credit Population>>
<<Recording Format Population>>
<<Platform Population>>
<<Computer Software Population>>
----

=== Product Population [[productpopulation,Product Population]]

(((Product Specification,Population,Product)))
[source,tcl]
----
<<Product Population>>=
set producttag 100
set eumlid 780201
set recid 7789930
set wordid 938763

class Product {
    productID
    productName
    copyright
    unitPrice
    description
    website 
    currentlyAvailable
    categoryID
    groupCode
    publisherCode
}\
    $eumlid\
    {Executable UML: A Foundation for Model-Driven Architecture}\
    2002\
    2995\
    {Book on software development using models.}\
    www.executableumlbook.com\
    true\
    [set bookid [incr categorytag]]\
    0\
    201\
\
    $recid\
    {Carnival Music for Children}\
    1955\
    1000\
    {Music as heard at old time carnivals}\
    {}\
    true\
    [set musicid [incr categorytag]]\
    1\
    523\
\
    $wordid\
    {Word 2020 for MacOSX}\
    2020\
    5995\
    {Infamous word processing program}\
    www.microsoft.com\
    true\
    [set swid [incr categorytag]]\
    2\
    666
----

=== Publisher Population [[publisherpopulation,Publisher Population]]

(((Product Specification,Population,Publisher)))
[source,tcl]
----
<<Publisher Population>>=
class Publisher {
    groupCode
    publisherCode
    name
    address
    website
} {
    0
    201
    Addison-Wesley
    {New York, NY}
    www.aw.com

    1
    523
    {Old-Time Music}
    {St. Louis, MO}
    www.otm.com

    2
    666
    {Microsoft, Inc.}
    {Seattle, WA}
    www.microsoft.com
}
----

=== Author Population [[authorpopulation,Author Population]]

(((Product Specification,Population,Author)))
[source,tcl]
----
<<Author Population>>=
class Author {
    name
    website
    email
}\
    {Stephen J. Mellor}\
    stephenmellor.com\
    stephen@stephenmellor.com\
\
    {Marc J. Balcer}\
    marcbalcer.com\
    marc@marcbalcer.com
----

=== Authorship Population [[authorshippopulation,Authorship Population]]

(((Product Specification,Population,Authorship)))
[source,tcl]
----
<<Authorship Population>>=
class Authorship {
    name
    productID
    previousName
    previousProductID
}\
    {Stephen J. Mellor}\
    $eumlid\
    {}\
    {}\
\
    {Marc J. Balcer}\
    $eumlid\
    {Stephen J. Mellor}\
    $eumlid
----

=== Book Product Population [[bookproductpopulation,Book Product Population]]

(((Product Specification,Population,Book Product)))
[source,tcl]
----
<<Book Product Population>>=
class BookProduct {
    productID
    bookNumber
    titleCode
    title
    subtitle
}\
    $eumlid\
    {ISBN 0-201-74804-5}\
    74804-5\
    {Executable UML}\
    {A Foundation for Model-Driven Architecture}
----

=== Recording Product Population [[recordingproductpopulation,Recording Product Population]]

(((Product Specification,Population,Recording Product)))
[source,tcl]
----
<<Recording Product Population>>=
class RecordingProduct {
    productID
    runningTime
    recordingID
    formatID
}\
    $recid\
    3:23\
    [set cmusid [incr recordingtag]]\
    [set cdid [incr formattag]]
----

=== Software Product Population [[softwareproductpopulation,Software Product Population]]

(((Product Specification,Population,Software Product)))
[source,tcl]
----
<<Software Product Population>>=
class SoftwareProduct {
    productID
    productVersion
    softwareID
    platformID
}\
    $wordid\
    20.17.3\
    [set softid [incr softwaretag]]\
    [set platformid [incr platformtag]]
----

=== Special Order Product Population [[specialorderproductpopulation,Special Order Product Population]]

(((Product Specification,Population,Special Order Product)))
[source,tcl]
----
<<Special Order Product Population>>=
class SpecialOrderProduct {
    productID
    specialOrderInstructions
    daysToDeliver
}\
    $recid\
    {Their part number: 30557}\
    10
----

=== Stocked Product Population [[stockedproductpopulation,Stocked Product Population]]

(((Product Specification,Population,Stocked Product)))
[source,tcl]
----
<<Stocked Product Population>>=
class StockedProduct {
    productID
    quantityOnHand
    reorderThreshold
    reorderIncrement
    reorderInstructions
}\
    $eumlid\
    100\
    200\
    100\
    {Ship as quickly as possible}\
\
    $wordid\
    55\
    25\
    55\
    {Get a discount}
----

=== Product Category Population [[productcategorypopulation,Product Category Population]]

(((Product Specification,Population,Product Category)))
[source,tcl]
----
<<Product Category Population>>=
class ProductCategory {
    categoryID
    categoryName
    parentCategoryID
}\
    $bookid\
    book\
    {}\
\
    $musicid\
    music\
    {}\
\
    $swid\
    software\
    {}
----

=== Recording Population [[recordingpopulation,Recording Population]]

(((Product Specification,Population,Recording)))
[source,tcl]
----
<<Recording Population>>=
class Recording {
    recordingID
    title
}\
    $cmusid\
    {Carnival Music for Children}
----

=== Artist Population [[artistpopulation,Artist Population]]

(((Product Specification,Population,Artist)))
[source,tcl]
----
<<Artist Population>>=
class Artist {
    artistID
    artistName
}\
    [set artist1id [incr artisttag]]\
    {Mary Jane}\
\
    [set artist2id [incr artisttag]]\
    {Fred Smith}
----

=== Performance Credit Population [[performancecreditpopulation,Performance Credit Population]]

(((Product Specification,Population,Performance Credit)))
[source,tcl]
----
<<Performance Credit Population>>=
class PerformanceCredit {
    recordingID
    artistID
    prevRecordingID
    prevArtistID
}\
    $cmusid\
    $artist1id\
    {}\
    {}\
\
    $cmusid\
    $artist2id\
    $cmusid\
    $artist1id
----

=== Recording Format Population [[recordingformatpopulation,Recording Format Population]]

(((Product Specification,Population,Recording Format)))
[source,tcl]
----
<<Recording Format Population>>=
class RecordingFormat {
    formatID
    formatName
}\
    $cdid\
    CD
----

=== Platform Population [[xxpopulation,Platform Population]]

(((Product Specification,Population,Platform)))
[source,tcl]
----
<<Platform Population>>=
class Platform {
    platformID
    platformName
}\
    $platformid\
    MacOSX
----

=== Computer Software Population [[computersoftwarepopulation,Computer Software Population]]

(((Product Specification,Population,Computer Software)))
[source,tcl]
----
<<Computer Software Population>>=
class ComputerSoftware {
    softwareID
    title
}\
    $softid\
    {Word 2020 for MacOSX}
----

== Ordering Subsystem Population [[orderingsubsystempopulation,Ordering Subystem Population]]

There are no initial instances in the Ordering subsystem.
All instances are created at run time.
Most instances are created asynchronously by events.
The requirement that *Customers* must have placed an order means that
those instances are created when an *Order* is created.

== Shipping Subsystem Population [[shippingsubsystempopulation,Shipping Subystem Population]]

[source,tcl]
----
<<Shipping Population>>=
<<Shipping Company Population>>
<<Warehouse Population>>
<<Warehouse Clerk Population>>
<<Shipping Clerk Population>>
<<Stock Clerk Population>>
<<Off Duty Clerk Population>>
----

=== Shipping Company Population [[shippingcompanypopulation,Shipping Company Population]]

(((Shipping,Population,Shipping Company)))
[source,tcl]
----
<<Shipping Company Population>>=
class ShippingCompany {
    companyName
    trackingWebsite
    customerServicePhone
    localDispatchPhone
    localOffice
    localContact
} {
    FedEx
    www.fedex.com
    222-555-1212
    223-555-1212
    {200 Elm St., Anywhere, CA 94000}
    {George Shipper}

    UPS
    www.ups.com
    224-555-1212
    225-555-1212
    {220 Elm St., Anywhere, CA 94000}
    {John Parcel}
}
----

=== Warehouse Population [[warehousepopulation,Warehouse Population]]

(((Shipping,Population,Warehouse)))
[source,tcl]
----
<<Warehouse Population>>=
class Warehouse {
    warehouseName
    warehouseLocation
} {
    {Acme Bookstore Warehouse}
    {100 Broad St., Somewhere, CA 94000}

    {My Fulfillment}
    {100 Fremont St., Somewhere, CA 94000}
}
----

=== Warehouse Clerk Population [[warehouseclerkpopulation,Warehouse Clerk Population]]

(((Shipping,Population,Warehouse Clerk)))
[source,tcl]
----
<<Warehouse Clerk Population>>=
class WarehouseClerk {
    clerkID
    clerkName
    warehouseName
}\
    [set clerk1id [incr clerktag]]\
    {Fred Smith}\
    {Acme Bookstore Warehouse}\
\
    [set clerk2id [incr clerktag]]\
    {John Industrious}\
    {Acme Bookstore Warehouse}\
\
    [set clerk3id [incr clerktag]]\
    {George Slacker}\
    {My Fulfillment}
----

=== Shipping Clerk Population [[shippingclerkpopulation,Shipping Clerk Population]]

(((Shipping,Population,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk Population>>=
class ShippingClerk {
    clerkID
}\
    $clerk1id
----

=== Stock Clerk Population [[stockclerkpopulation,Stock Clerk Population]]

(((Shipping,Population,Stock Clerk)))
[source,tcl]
----
<<Stock Clerk Population>>=
class StockClerk {
    clerkID
}\
    $clerk2id
----

=== Off Duty Clerk Population [[offdutyclerkpopulation,Off Duty Clerk Population]]

(((Shipping,Population,Off Duty Clerk)))
[source,tcl]
----
<<Off Duty Clerk Population>>=
class OffDutyClerk {
    clerkID
}\
    $clerk3id
----

== External Entities [[externalentities,External Entities]]

[source,tcl]
----
<<External Entity Stubs>>=
namespace eval ::bookstore::EE_CreditCardCompany {
    proc requestChargeApproval {accountNumber billingAddress cardholderName
                cardExpirationDate chargeID chargeAmount} {
        puts [info level 0]

        set chargeRef\
            [::bookstore::CreditCardCharge findById chargeID $chargeID]
        after 100 [list rosea tunnel $chargeRef\
                signal chargeProcessed approved]
    }
}

namespace eval ::bookstore::EE_OnLineCustomer {
    proc chargeDeclined {email} {
        puts [info level 0]
    }
    proc chargeApproved {email} {
        puts [info level 0]
    }
    proc orderReportedDelivered {email} {
        puts [info level 0]
    }
}
----

== Execution Scenarios [[executionscenarios,Execution Scenarios]]

[source,tcl]
----
<<Common Execution Setup>>=
package require rosea
<<Common Execution Utilities>>

rosea configureFromFile simplebookstore.tcl
rosea generate
rosea populateFromFile sbs_population.tcl

<<External Entity Stubs>>

rosea trace control on
----

[source,tcl]
----
<<Common Execution Takedown>>=
rosea trace control off
----

[source,tcl]
----
<<Common Execution Utilities>>=
proc ::syncToStop {cmd code result op} {
    set ::done 1
}

proc ::syncToStateActivity {class state {timeout 3000}} {
    set activityproc ::bookstore::${class}::__Activity::${state}

    trace add execution $activityproc leave syncToStop

    set totimer [after $timeout set ::done TIMEOUT]
    vwait ::done
    after cancel $totimer
    trace remove execution $activityproc leave syncToStop

    if {$::done eq "TIMEOUT"} {
        error "Sync to $class / $state timed out"
    }
    return $::done
}

proc ::logTraces {filenamebase} {
    set logchan [::open $filenamebase.log w]
    try {
        puts $logchan [rosea trace format [rosea trace decode all]]
    } finally {
        ::chan close $logchan
    }
    rosea trace diagram all $filenamebase.diag
}
----

=== Scenario 1  [[scenario1,Scenario 1]]

[source,tcl]
----
<<scenario1.tcl>>=
<<copyright info>>
<<Common Execution Setup>>

set exumlref [bookstore::Product findWhere {[string match {Ex*} $productName]}]
set id [rosea::InstCmds::readAttribute $exumlref productID]
bookstore::ShoppingCart createasync startCart [list $id 1]\
    cartID [incr carttag] totalValue 0
syncToStateActivity ShoppingCart AddingSelectiontoOrder

set selection [bookstore::ProductSelection findById\
        cartID $carttag productID $id]
rosea::tunnel $selection signal changeQuantity 0
syncToStateActivity ShoppingCart CancelingEntireOrder

logTraces scenario1
<<Common Execution Takedown>>
----

[literal]
.State Machine Traces For Scenario 1
--
include::scenario1.log[]
--

image::scenario1.pdf[title="Scenario 1 Sequence Diagram"]

=== Scenario 2  [[scenario2,Scenario 2]]

[source,tcl]
----
<<scenario2.tcl>>=
<<copyright info>>
<<Common Execution Setup>>

set cartid [incr carttag]

set ref [bookstore::Product findWhere {
    [string match {Executable*} $productName]}]
set id [rosea::InstCmds::readAttribute $ref productID]
bookstore::ShoppingCart createasync startCart [list $id 1]\
    cartID $cartid totalValue 0
syncToStateActivity ShoppingCart AddingSelectiontoOrder

set ref [bookstore::Product findWhere {
    [string match {Carnival*} $productName]}]
set id [rosea::InstCmds::readAttribute $ref productID]
set cartRef [bookstore::ShoppingCart findById cartID $cartid]
rosea::tunnel $cartRef signal addSelection $id 2
syncToStateActivity ShoppingCart AddingSelectiontoOrder

rosea::tunnel $cartRef signal checkOut\
        {5555 6666 7777 8888}\
        {100 E Main St., Anywhere, CO 88888}\
        {10/17}\
        {Fred Smith}\
        fsmith@gmail.com\
        {Fred Smith}\
        {222-555-1212}\
        {100 E Main St., Anywhere, CO 88888}

syncToStateActivity ShippingClerk SelectingBooks

logTraces scenario2
<<Common Execution Takedown>>
----

[literal]
.State Machine Traces For Scenario 2
--
include::scenario2.log[]
--

image::scenario2.pdf[title="Scenario 2 Sequence Diagram"]

== Code Organization [[codeorganization,Code Organization]]

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<simplebookstore.tcl>>=
<<copyright info>>

package require Tcl 8.6
package require rosea
package require uuid

domain bookstore {
    <<Product Specification Subsystem>>
    <<Ordering Subsystem>>
    <<Shipping Subsystem>>
}
----

=== Initial Instance Population

[source,tcl]
----
<<sbs_population.tcl>>=
<<copyright info>>

domain bookstore {
    <<Product Specification Population>>
    <<Shipping Population>>
}
----

/////

=== XX Class [[xxclass,XX]]

(((Ordering,Classes,XX)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,Relationships,RR)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,State Model,XX)))
[source,tcl]
----
<<XX State Model>>=
----
/////

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
