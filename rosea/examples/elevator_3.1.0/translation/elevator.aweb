// vim:set syntax=asciidoc:
= Translating the Elevator Model

== Introduction [[introduction,Introduction]]

This document presents a translation of

This document is also a
http://www.literateprogramming.com[literate program].
It contains all the code of the translation and the execution scenarios
that exercise the program.
The literate program source and all the output is available at the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools[Model Realization]
web site.


=== How to Read This Document [[howtoreadthisdocument,How to Read This Document]]

This document presents the translation


== Model Details [[modeldetails,Model Details]]

Model Details

== Translation Conventions [[translationconventions,Translation Conventions]]

Translation Conventions

== Data Types [[datatypes,Data Types]]

`Rosea` requires attributes to be given an data type.
That data type is, of course, an implementation data type and must
be one of the Tcl data types supported by TclRAL.
It may seem strange to discuss types in a dynamically typed language such
as Tcl where, at the script level, all values have a string representation.
Tcl uses a form of _duck typing_.
Values are converted to the type required by the operation and should they
fail to be converted an error is thrown.
In Tcl, `string` is the universal type.
Attributes with types other than string will be converted to that type
when they are updated into an instance.
This is an integrity check.
If you declare an attribute as `int`, then whatever value you assign to
the attribute must be convertable to an int because presumably you
intend to perform some arithmetic on the value.
`Rosea` prevent assignment of values to attributes that cannot possibly
be converted to the correct type.

That said,
data types like `int` are usually too permissive.
It is usually a subset of values of the type that are desired.
`Rosea` does allow an expression to be evaluated on an attribute value
as a check that it is reasonable.
We will use this feature in several situations.

Comments on the mapping of domain data types to implementation data types
are given below.

== Translating the Data Model [[translating-data-model]]

=== Accessible Shaft Level Class [[accessible-shaft-level-class,Accessible Shaft Level]]

(((Data Model,Class,Accessible Shaft Level)))
(((chunk,Accessible Shaft Level attribute definition)))
[source,tcl]
----
<<Accessible Shaft Level attribute definition>>=
attribute Floor int -id 1
attribute Shaft string -id 1
attribute Bank string
attribute Stop_requested boolean -default false

reference R3 Shaft_Level -link Floor -link Shaft
reference R3 Bank_Level -link Floor -link Bank
----

=== R3

(((Data Model,Relationship,R3)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R3 Shaft_Level 1..*--0..1 Bank_Level\
        -associator Accessible_Shaft_Level
----

=== Bank Class [[bank-class,Bank]]

(((Data Model,Class,Bank)))
(((chunk,Bank attribute definition)))
[source,tcl]
----
<<Bank attribute definition>>=
attribute Name string -id 1
attribute Passenger_load_time int -default 5000
attribute Block_clear_time int -default 5000
attribute Max_close_attempts int -default 3
attribute Avg_cabin_speed double -default 1.0
attribute Avg_stop_duration int -default 10
----

=== Bank Level Class [[bank-level-class,Bank Level]]

(((Data Model,Class,Bank Level)))
(((chunk,Bank Level attribute definition)))
[source,tcl]
----
<<Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1

reference R29 Bank -link {Bank Name}
reference R29 Floor -refid 2 -link {Floor Number}           ; # <1>
----
<1> Note that the Number attribute of Floor is a secondary identifier
and we must state that as part of the reference.

=== R29

(((Data Model,Relationship,R29)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R29 Bank 0..*--1..* Floor -associator Bank_Level
----

=== R38

(((Data Model,Relationship,R38)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
generalization R38 Bank_Level\
        Top_Bank_Level Middle_Bank_Level Bottom_Bank_Level
----

=== Building Class [[building-class,Building]]

(((Data Model,Class,Building)))
(((chunk,Building attribute definition)))
[source,tcl]
----
<<Building attribute definition>>=
attribute Name string -id 1
attribute Average_floor_gap double
----

=== Cabin Class [[cabin-class,Cabin]]

(((Data Model,Class,Cabin)))
(((chunk,Cabin attribute definition)))
[source,tcl]
----
<<Cabin attribute definition>>=
attribute Shaft string -id 1
attribute Travel_direction string -check {$Travel_direction in {up down}}
attribute Current_floor int

reference R2 Shaft -link {Shaft ID}
reference R43 Shaft_Level -link Shaft -link {Current_floor Floor}
----

=== R2

(((Data Model,Relationship,R2)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R2 Cabin 1--1 Shaft
----

=== R43

(((Data Model,Relationship,R43)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R43 Cabin 0..*--1 Shaft_Level
----

=== Door Class [[door-class,Door]]

(((Data Model,Class,Door)))
(((chunk,Door attribute definition)))
[source,tcl]
----
<<Door attribute definition>>=
attribute Shaft string -id 1
attribute Close_attempts_remaining int -default 5
attribute Open_wait_time int -default 1000
attribute Lock_requested boolean -default false
attribute Held boolean -default false
attribute Emergency_hold boolean -default false

reference R4 Cabin -link Shaft
----

=== R4

(((Data Model,Relationship,R4)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R4 Door 1--1 Cabin
----

=== Floor Class [[floor-class,Floor]]

(((Data Model,Class,Floor)))
(((chunk,Floor attribute definition)))
[source,tcl]
----
<<Floor attribute definition>>=
attribute Name string -id 1
attribute Number int -id 2
attribute Height double
----

=== Floor Service Class [[floor-service-class,Floor Service]]

(((Data Model,Class,Floor Service)))
(((chunk,Floor Service attribute definition)))
[source,tcl]
----
<<Floor Service attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1
attribute Shaft string -id 1
attribute Direction string -check {$Direction in {up down}}

reference R49 Bank_Level -link Bank -link Floor
reference R49 Accessible_Shaft_Level -link Floor -link Shaft
----

=== R49

(((Data Model,Relationship,R49)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R49 Bank_Level 0..*--0..* Accessible_Shaft_Level\
        -associator Floor_Service
----

=== Top Bank Level Class [[top-bank-level-class,Top Bank Level]]

(((Data Model,Class,Top Bank Level)))
(((chunk,Top Bank Level attribute definition)))
[source,tcl]
----
<<Top Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1
attribute Calling_down boolean -default false

reference R38 Bank_Level -link Bank -link Floor
reference R5 Bank -link {Bank Name}
----

=== R5

(((Data Model,Relationship,R5)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R5 Top_Bank_Level 1--1 Bank
----

=== Middle Bank Level Class [[middle-bank-level-class,Middle Bank Level]]

(((Data Model,Class,Middle Bank Level)))
(((chunk,Middle Bank Level attribute definition)))
[source,tcl]
----
<<Middle Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1
attribute Calling_up boolean -default false
attribute Calling_down boolean -default false

reference R38 Bank_Level -link Bank -link Floor
----

=== Bottom Bank Level Class [[bottom-bank-level-class,Bottom Bank Level]]

(((Data Model,Class,Bottom Bank Level)))
(((chunk,Bottom Bank Level attribute definition)))
[source,tcl]
----
<<Bottom Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1
attribute Calling_up boolean -default false

reference R38 Bank_Level -link Bank -link Floor
reference R6 Bank -link {Bank Name}
----

=== R6

(((Data Model,Relationship,R6)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R6 Bottom_Bank_Level 1--1 Bank
----

=== Shaft Class [[shaft-class,Shaft]]

(((Data Model,Class,Shaft)))
(((chunk,Shaft attribute definition)))
[source,tcl]
----
<<Shaft attribute definition>>=
attribute ID string -id 1
attribute Bank string
attribute In_service boolean -default true

reference R1 Bank -link {Bank Name}
----

=== R1

(((Data Model,Relationship,R1)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R1 Shaft 1..*--1 Bank
----

=== Shaft Level Class [[shaft-level-class,Shaft Level]]

(((Data Model,Class,Shaft Level)))
(((chunk,Shaft Level attribute definition)))
[source,tcl]
----
<<Shaft Level attribute definition>>=
attribute Floor int -id 1
attribute Shaft string -id 1

reference R28 Floor -link {Floor Number} -refid 2
reference R28 Shaft -link {Shaft ID}
----

=== R28

(((Data Model,Relationship,R28)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R28 Shaft 1..*--1..* Floor -associator Shaft_Level
----

=== Transfer Class [[transfer-class,Transfer]]

(((Data Model,Class,Transfer)))
(((chunk,Transfer attribute definition)))
[source,tcl]
----
<<Transfer attribute definition>>=
attribute Destination_floor int -id 1
attribute Shaft string -id 1

reference R53 Cabin -link Shaft
reference R53 Accessible_Shaft_Level -link {Destination_floor Floor} -link Shaft
----

=== R53

(((Data Model,Relationship,R53)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R53 Cabin 0..1--0..1 Accessible_Shaft_Level -associator Transfer
----

== Population [[population]]

Population

(((chunk,elevator population)))
[source,tcl]
----
<<elevator population>>=
class Building {
    Name        Average_floor_gap} {
    Acme        5.0
}

class Bank {
    Name} {
    B1
}

class Floor {
    Name            Number          Height} {
    F1              1               5.0
    F2              2               5.0
    F3              3               5.0
}

class Bank_Level {
    Bank            Floor} {
    B1              1
    B1              2
    B1              3
}

class Top_Bank_Level {
    Bank            Floor} {
    B1              3
}

class Middle_Bank_Level {
    Bank            Floor} {
    B1              2
}

class Bottom_Bank_Level {
    Bank            Floor} {
    B1              1
}

class Shaft {
    ID          Bank} {
    S1          B1
}

class Shaft_Level {
    Floor           Shaft} {
    1               S1
    2               S1
    3               S1
}

class Accessible_Shaft_Level {
    Floor           Shaft           Bank} {
    1               S1              B1
    2               S1              B1
    3               S1              B1
}

class Cabin {
    Shaft           Travel_direction    Current_floor} {
    S1              up                  1
}

class Door {
    Shaft} {
    S1
}
----

== Translating the State Models [[translating-state-models]]

=== Accessible Shaft Level State Model [[accessible-shaft-level-state-model]]

(((Dynamics Model,State Model,Accessible Shaft Level)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
initialstate NOT_REQUESTED
defaulttrans CH

transition NOT_REQUESTED - Stop_request -> Registering_stop
transition NOT_REQUESTED - Floor_calling -> Registering_floor_call

transition REQUESTED - Stop_request -> Registering_stop
transition REQUESTED - Floor_calling -> Registering_floor_call
transition REQUESTED - Stop_serviced -> Clear_stop_request
transition REQUESTED - Serviced_floor_request -> Clear_floor_request

transition Registering_stop - Stop_registered -> Requesting_service

transition Registering_floor_call - Floor_call_registered -> Requesting_service

transition Requesting_service - Wait_for_service -> REQUESTED

transition Clear_floor_request - Check_stop_request -> Clear_stop_request

transition Clear_stop_request - All_requested_cleared -> NOT_REQUESTED
transition Clear_stop_request - Opposite_floor_call_pending -> REQUESTED

state NOT_REQUESTED {} {
}

state REQUESTED {} {
}

state Registering_stop {} {
}

state Registering_floor_call {} {
}

state Requesting_service {} {
}

state Clear_floor_request {} {
}

state Clear_stop_request {} {
}
----

=== Floor Service State Model [[floor-service-state-model]]

(((Dynamics Model,State Model,Floor Service)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
initialstate WAITING_FOR_CABIN
defaulttrans CH

transition WAITING_FOR_CABIN - Cabin_arrived -> Check_bank_level_type

transition REJECT_REQUESTS_OPPOSITE_REQUESTED_SERVICE_DIR - Cancel -> COMPLETED

transition Check_bank_level_type - Middle_floor ->\
        REJECT_REQUESTS_OPPOSITE_REQUESTED_SERVICE_DIR
transition Check_bank_level_type - Top_or_bottom_floor -> COMPLETED

state WAITING_FOR_CABIN {} {
}

state REJECT_REQUESTS_OPPOSITE_REQUESTED_SERVICE_DIR {} {
}

state COMPLETED {} {
}

state Check_bank_level_type {} {
}
----

=== Shaft State Model [[shaft-state-model]]

(((Dynamics Model,State Model,Shaft)))
(((chunk,Shaft state model definition)))
[source,tcl]
----
<<Shaft state model definition>>=
initialstate WAITING_FOR_STOP_OR_CALL_REQUEST
defaulttrans CH

transition WAITING_FOR_STOP_OR_CALL_REQUEST - Transfer_competed ->\
        Searching_for_best_destination
transition WAITING_FOR_STOP_OR_CALL_REQUEST - Service_requested ->\
        Searching_for_best_destination
transition WAITING_FOR_STOP_OR_CALL_REQUEST - Take_out_of_service ->\
        CANCELING_TRANSFER

transition Searching_for_best_destination - No_destination ->\
        WAITING_FOR_STOP_OR_CALL_REQUEST
transition Searching_for_best_destination - Create_transfer ->\
        Creating_or_updating_transfer

transition Creating_or_updating_transfer - Transfer_requested ->\
    WAITING_FOR_STOP_OR_CALL_REQUEST

transition CANCELING_TRANSFER - No_transfer_in_progress -> OUT_OF_SERVICE
transition CANCELING_TRANSFER - Transfer_completed -> OUT_OF_SERVICE

state WAITING_FOR_STOP_OR_CALL_REQUEST {} {
}

state Searching_for_best_destination {} {
}

state Creating_or_updating_transfer {} {
}

state CANCELING_TRANSFER {} {
}

state OUT_OF_SERVICE {} {
}

----

=== Transfer State Model [[transfer-state-model]]

(((Dynamics Model,State Model,Transfer)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
initialstate CREATED
defaulttrans CH

transition CREATED - Execute -> Creating_or_updating_transfer
transition CREATED - Doors_closed -> IG

transition WAITING_FOR_CABIN - Destination_change_request ->\
        Changing_destination_before_cabin_moves
transition WAITING_FOR_CABIN - Ready_to_move -> Dispatching_cabin
transition WAITING_FOR_CABIN - Doors_closed -> IG

transition CABIN_IN_MOTION - Destination_change_request -> Request_redirect
transition CABIN_IN_MOTION - Cabin_redirected -> Match_new_destination_of_cabin
transition CABIN_IN_MOTION - Cabin_at_destination ->\
        Check_for_active_floor_service

transition CALL_IN_PROGRESS - Destination_change_request -> IG
transition CALL_IN_PROGRESS - Doors_closed -> Canceling_floor_service

transition WAITING_FOR_REQUESTS_TO_CLEAR - Destination_change_request -> IG
transition WAITING_FOR_REQUESTS_TO_CLEAR - Doors_closed -> IG
transition WAITING_FOR_REQUESTS_TO_CLEAR - Requests_cleared -> Delete

transition Creating_or_updating_transfer - Wait_for_cabin -> WAITING_FOR_CABIN

transition Changing_destination_before_cabin_moves - Stationary_update ->\
        WAITING_FOR_CABIN

transition Dispatching_cabin - Cabin_dispatched -> CABIN_IN_MOTION

transition Request_redirect -> Redirect_requested -> CABIN_IN_MOTION

transition Match_new_destination_of_cabin - Update_in_motion -> CABIN_IN_MOTION

transition Check_for_active_floor_service - Call_in_progress -> CALL_IN_PROGRESS
transition Check_for_active_floor_service - Wait_to_clear ->\
        WAITING_FOR_REQUESTS_TO_CLEAR

transition Canceling_floor_service - Wait_to_clear ->\
        WAITING_FOR_REQUESTS_TO_CLEAR

state CREATED {} {
}

state Creating_or_updating_transfer {} {
}

state Changing_destination_before_cabin_moves {} {
}

state WAITING_FOR_CABIN {} {
}

state Dispatching_cabin {} {
}

state Request_redirect {} {
}

state CABIN_IN_MOTION {} {
}

state Match_new_destination_of_cabin {} {
}

state Check_for_active_floor_service {} {
}

state CALL_IN_PROGRESS {} {
}

state Canceling_floor_service {} {
}

state WAITING_FOR_REQUESTS_TO_CLEAR {} {
}

terminal Delete
state Delete {} {
}
----

=== Cabin State Model [[cabin-state-model]]

(((Dynamics Model,State Model,Cabin)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
defaulttrans CH

transition MOVING - Try_redirect -> Changing_destination
transition MOVING - Arrived_at_floor -> TRANSFERRING_PASSENGERS

transition TRANSFERRING_PASSENGERS - Try_redirect -> IG
transition TRANSFERRING_PASSENGERS - New_transfer -> Are_we_already_there?

transition SECURING_DOORS - Doors_secure -> LOCKING_TRANSFER

transition LOCKING_TRANSFER - Go -> Requesting_transport_to_destination

transition Requesting_transport_to_destination - Transport_in_progress ->\
        MOVING
transition Requesting_transport_to_destination - Transport_unavailable ->\
        OUT_OF_SERVICE

transition Changing_destination - Change_requested -> MOVING

transition Are_we_already_there? - Already_there -> TRANSFERRING_PASSENGERS
transition Are_we_already_there? - Prepare_to_move -> SECURING_DOORS

state MOVING {} {
}

state TRANSFERRING_PASSENGERS {} {
}

state SECURING_DOORS {} {
}

state LOCKING_TRANSFER {} {
}

state OUT_OF_SERVICE {} {
}

state Requesting_transport_to_destination {} {
}

state Changing_destination {} {
}

state Are_we_already_there? {} {
}

----

=== Door State Model [[door-state-model]]

(((Dynamics Model,State Model,Door)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
initialstate CLOSED
defaulttrans CH

transition OPENING - Door_opened -> OPEN_DELAY
transition OPENING - Passenger_open -> IG
transition OPENING - Passenger_close -> CLOSING
transition OPENING - Lock -> IG
transition OPENING - Cant_close_door -> CANT_CLOSE

transition OPEN_DELAY - Passenger_open -> IG
transition OPEN_DELAY - Passenger_close -> Cancel_open_delay
transition OPEN_DELAY - Lock -> IG
transition OPEN_DELAY - Time_to_close -> HOLDING_OPEN

transition HOLDING_OPEN - Passenger_open -> IG
transition HOLDING_OPEN - Passenger_close -> IG
transition HOLDING_OPEN - Lock -> IG
transition HOLDING_OPEN - Hold_released -> CLOSING

transition CLOSING - Door_closed -> CLOSED
transition CLOSING - Door_blocked -> OPENING
transition CLOSING - Passenger_open -> OPENING
transition CLOSING - Passenger_close -> IG
transition CLOSING - Lock -> IG

transition CLOSED - Passenger_open -> OPENING
transition CLOSED - Passenger_close -> IG
transition CLOSED - Lock -> LOCKED
transition CLOSED - Unlock -> Unlock_for_arrival

transition LOCKED - Passenger_open -> IG
transition LOCKED - Passenger_close -> IG
transition LOCKED - Unlock -> Unlock_for_arrival

transition Cancel_open_delay - Open_delay_canceled -> HOLDING_OPEN

transition Unlock_for_arrival - Open_on_arrival -> OPENING
----

== Translating the Processing [[translating-activities]]

=== Door State Activities

==== OPENING

(((Activity,Door,OPENING)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# my bank .= /R4/R2/R1/Bank
# if (—Close attempts remaining) { // Count type is always >= 0
# 	Open door( Shaft ) => SIO
# 	UI.Door opening( Shaft )
# } else
# 	Cant close door -> me

state OPENING {} {
    # set my_bank [findRelated $self R4 R2 R1]
    assignAttribute $self Close_attempts_remaining Shaft
    incr Close_attempts_remaining -1
    updateAttribute $self Close_attempts_remaining $Close_attempts_remaining
    if {$Close_attempts_remaining > 0} {
        SIO::Open_door $Shaft
        UI::Door_opening $Shaft
    } else {
        signal $self Cant_close_door
    }
}
----

==== OPEN_DELAY

(((Activity,Door,OPEN DELAY)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# UI.Door opened( Shaft )
# Time to close -> me after Open wait time

state OPEN_DELAY {} {
    assignAttribute $self Shaft Open_wait_time
    UI::Door_opened [readAttribute $self Shaft]
    delaysignal $Open_wait_time $self Time_to_close
}
----

==== HOLDING_OPEN

(((Activity,Door,HOLDING OPEN)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# if (not Held)
#   Hold released -> me

state HOLDING_OPEN {} {
    if {![readAttribute $self Held]} {
        signal $self Hold_released
    }
}
----

==== CLOSING

(((Activity,Door,CLOSING)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# if (Emergency hold)
#   Emergency hold -> me
# else {
#   // Start closing the door
#   Close door( Shaft ) => SIO
#   UI.Door closing( Shaft )
#   // If the close fails, reopen for a potentially shorter
#   // duration to wait for obstruction to clear
#   Open wait time = /R4/R2/R1/Bank.Block clear time
# }

state CLOSING {} {
    if {[readAttribute $self Emergency_hold]} {
        signal $self Emergency_hold
    } else {
        set shaft [readAttribute $self Shaft]
        SIO::Close_door $shaft
        UI::Door_closing $shaft

        set bank [findRelated $self R4 R2 R1]
        updateAttribute $self Open_wait_time\
                [readAttribute $bank Block_clear_time]
    }
}
----

==== CLOSED

(((Activity,Door,CLOSED)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# UI.Door closed( Shaft )
# Close attempts remaining = /R4/R2/R1/Bank.Max close attempts
# if ( Lock requested )
#   Lock -> me
# Door closed -> /R4/R53/Transfer // May be none

state CLOSED {} {
    assignAttribute $self Shaft Lock_requested
    UI::Door_closed $Shaft
    if {$Lock_requested} {
        signal $self Lock
    }
    set transfers [findRelated $self R4 {R53 Transfer}]
    signal $transfers Doors_closed
}
----

==== LOCKED

(((Activity,Door,LOCKED)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# // Tell the cabin that we’re ready to go
# Lock requested.unset
# // Do not clear lock in unlocking state because
# // Cabin might set it on arrival before we execute the
# // Unlock action. So it must be done here.
# Doors secure -> /R4/Cabin

state LOCKED {} {
    updateAttribute $self Lock_requested false
    set cabin [findRelated $self R4]
    signal $cabin Doors_secure
}
----

==== CANT_CLOSE

(((Activity,Door,CAN'T CLOSE)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# // Take the shaft out of service
# Take out of service -> /R4/R2/Shaft

state CANT_CLOSE {} {
    set shaft [findRelated $self R4 R2]
    signal $shaft Take_out_of_service
}
----

==== Cancel open delay

(((Activity,Door,Cancel open delay)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# Cancel Time to close -> me
# Open delay canceled -> me

state Cancel_open_delay {} {
    canceldelayed $self $self Time_to_close
    signal $self Open_delay_canceled
}
----

==== Unlock for arrival

(((Activity,Door,Unlock for arrival)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# // The Cabin has either just arrived at a floor
# // or the Cabin was called at its current location
# // Unlock (become alert to passenger door open/close requests)
# // Initialize the door close retry counter to zero
# // Load the door close timer with NORMAL open time
# // Proceed to door opening state
# Open wait time = /R4/R2/R1/Bank.Pass load time
# Open on arrival -> me

state Unlock_for_arrival {} {
    set bank [findRelated $self R4 R2 R1]
    updateAttribute $self Open_wait_time\
            [readAttribute $bank Passenger_load_time]
    signal $self Open_on_arrival
}
----

=== Cabin State Activities

==== Requesting transport to destination

(((Activity,Cabin,Requesting transport to destination)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
# if (TRAN.Goto floor( Dest floor: /R53/Transfer.Destination floor, Shaft ) )
#   Transport in progress -> me
# else
#   Transport unavailable -> me

state Requesting_transport_to_destination {} {
    assignAttribute $self Shaft
    set xfer [findRelated $self {R53 Transfer}]
    assignAttribute $xfer Destination_floor
    set avail [TRAN::Goto_floor $Destination_floor $Shaft]
    if {$avail} {
        signal $self Transport_in_progress
    } else {
        signal $self Transport_unavailable
    }
}
----

== External Entities [[external-entities,External Entities]]

=== SIO

(((External Entity,SIO,Open door)))
(((chunk,sio external entity)))
[source,tcl]
----
<<sio external entity>>=
proc Open_door {shaft} {
    chan puts "SIO::Open_door $shaft"
    set door [elevator::Door findById Shaft $shaft]
    after 5000 [list rosea tunnel $door signal Door_opened]
}
----

(((External Entity,SIO,Close door)))
(((chunk,sio external entity)))
[source,tcl]
----
<<sio external entity>>=
proc Close_door {shaft} {
    chan puts "SIO::Close_door $shaft"
    set door [elevator::Door findById Shaft $shaft]
    after 5000 [list rosea tunnel $door signal Door_closed]
}
----

=== UI

(((External Entity,UI,Door opening)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_opening {shaft} {
    chan puts "UI::Door_opening $shaft"
}
----

(((External Entity,UI,Door opened)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_opened {shaft} {
    chan puts "UI::Door_opened $shaft"
}
----

(((External Entity,UI,Door closing)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_closing {shaft} {
    chan puts "UI::Door_closing $shaft"
}
----

(((External Entity,UI,Door closed)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_closed {shaft} {
    chan puts "UI::Door_closed $shaft"
}
----

== Code Organization [[codeorganization,Code Organization]]

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

(((chunk,copyright info)))
[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2017 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

(((chunk,elevator.tcl)))
[source,tcl]
----
<<elevator.tcl>>=
<<copyright info>>

package require Tcl 8.6
package require rosea 1.6

rosea configure {
    domain elevator {
        <<Accessible Shaft Level class definition>>
        <<Bank class definition>>
        <<Building class definition>>
        <<Cabin class definition>>
        <<Door class definition>>
        <<Floor class definition>>
        <<Floor Service class definition>>
        <<Bank Level class definition>>
        <<Top Bank Level class definition>>
        <<Middle Bank Level class definition>>
        <<Bottom Bank Level class definition>>
        <<Shaft class definition>>
        <<Shaft Level class definition>>
        <<Transfer class definition>>
        <<relationship definitions>>
    }
}

rosea generate

rosea populate {
    domain elevator {
        <<elevator population>>
    }
}

namespace eval ::elevator::SIO {
    <<sio external entity>>
}

namespace eval ::elevator::UI {
    <<ui external entity>>
}

package require comm
comm::comm configure -port 50000

chan puts "listening at port [comm::comm configure -port]"

vwait forever
after 1000
exit
----

(((chunk,Accessible Shaft Level class definition)))
[source,tcl]
----
<<Accessible Shaft Level class definition>>=
class Accessible_Shaft_Level {
    <<Accessible Shaft Level attribute definition>>
    statemodel {
        <<Accessible Shaft Level state model definition>>
    }
}
----

(((chunk,Bank class definition)))
[source,tcl]
----
<<Bank class definition>>=
class Bank {
    <<Bank attribute definition>>
}
----

(((chunk,Building class definition)))
[source,tcl]
----
<<Building class definition>>=
class Building {
    <<Building attribute definition>>
}
----

(((chunk,Cabin class definition)))
[source,tcl]
----
<<Cabin class definition>>=
class Cabin {
    <<Cabin attribute definition>>
    statemodel {
        <<Cabin state model definition>>
    }
}
----

(((chunk,Door class definition)))
[source,tcl]
----
<<Door class definition>>=
class Door {
    <<Door attribute definition>>
    statemodel {
        <<Door state model definition>>
    }
}
----

(((chunk,Floor class definition)))
[source,tcl]
----
<<Floor class definition>>=
class Floor {
    <<Floor attribute definition>>
}
----

(((chunk,Floor Service class definition)))
[source,tcl]
----
<<Floor Service class definition>>=
class Floor_Service {
    <<Floor Service attribute definition>>
    statemodel {
        <<Floor Service state model definition>>
    }
}
----

(((chunk,Bank Level class definition)))
[source,tcl]
----
<<Bank Level class definition>>=
class Bank_Level {
    <<Bank Level attribute definition>>
}
----

(((chunk,Top Bank Level class definition)))
[source,tcl]
----
<<Top Bank Level class definition>>=
class Top_Bank_Level {
    <<Top Bank Level attribute definition>>
}
----

(((chunk,Middle Bank Level class definition)))
[source,tcl]
----
<<Middle Bank Level class definition>>=
class Middle_Bank_Level {
    <<Middle Bank Level attribute definition>>
}
----

(((chunk,Bottom Bank Level class definition)))
[source,tcl]
----
<<Bottom Bank Level class definition>>=
class Bottom_Bank_Level {
    <<Bottom Bank Level attribute definition>>
}
----

(((chunk,Shaft class definition)))
[source,tcl]
----
<<Shaft class definition>>=
class Shaft {
    <<Shaft attribute definition>>
    statemodel {
        <<Shaft state model definition>>
    }
}
----

(((chunk,Shaft Level class definition)))
[source,tcl]
----
<<Shaft Level class definition>>=
class Shaft_Level {
    <<Shaft Level attribute definition>>
}
----

(((chunk,Transfer class definition)))
[source,tcl]
----
<<Transfer class definition>>=
class Transfer {
    <<Transfer attribute definition>>
    statemodel {
        <<Transfer state model definition>>
    }
}
----

/////

=== XX Class [[xxclass,XX]]

(((Ordering,Classes,XX)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,Relationships,RR)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,State Model,XX)))
[source,tcl]
----
<<XX State Model>>=
----
/////

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
