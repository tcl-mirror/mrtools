// vim:set syntax=asciidoc:
= Translating the Elevator Model

== Introduction [[introduction,Introduction]]

This document presents a translation of the Elevator Management Domain

This document is also a
http://www.literateprogramming.com[literate program].
It contains all the code of the translation and the execution scenarios
that exercise the program.
The literate program source and all the output is available at the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools[Model Realization]
web site.


=== How to Read This Document [[howtoreadthisdocument,How to Read This Document]]

How to Read This Document

== Model Details [[modeldetails,Model Details]]

Model Details

== Translation Conventions [[translationconventions,Translation Conventions]]

Translation Conventions

== Data Types [[datatypes,Data Types]]

`Rosea` requires attributes to be given an data type.
That data type is, of course, an implementation data type and must
be one of the Tcl data types supported by TclRAL.
It may seem strange to discuss types in a dynamically typed language such
as Tcl where, at the script level, all values have a string representation.
Tcl uses a form of _duck typing_.
Values are converted to the type required by the operation and should they
fail to be converted an error is thrown.
In Tcl, `string` is the universal type.
Attributes with types other than string will be converted to that type
when they are updated into an instance.
This is an integrity check.
If you declare an attribute as `int`, then whatever value you assign to
the attribute must be convertable to an int because presumably you
intend to perform some arithmetic on the value.
`Rosea` prevent assignment of values to attributes that cannot possibly
be converted to the correct type.

That said,
data types like `int` are usually too permissive.
It is usually a subset of values of the type that are desired.
`Rosea` does allow an expression to be evaluated on an attribute value
as a check that it is reasonable.
We will use this feature in several situations.

Comments on the mapping of domain data types to implementation data types
are given below.

== Translating the Data Model [[translating-data-model]]

=== Accessible Shaft Level Class [[accessible-shaft-level-class,Accessible Shaft Level]]

(((Data Model,Class,Accessible Shaft Level)))
(((chunk,Accessible Shaft Level attribute definition)))
[source,tcl]
----
<<Accessible Shaft Level attribute definition>>=
attribute Floor string -id 1
attribute Shaft int -id 1
attribute Bank string
attribute Stop_requested boolean -default false

reference R3 Shaft_Level -link Floor -link Shaft
reference R3 Bank_Level -link Floor -link Bank
----

=== R3

(((Data Model,Relationship,R3)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R3 Shaft_Level 1..*--0..1 Bank_Level\
        -associator Accessible_Shaft_Level
----

=== Bank Class [[bank-class,Bank]]

(((Data Model,Class,Bank)))
(((chunk,Bank attribute definition)))
[source,tcl]
----
<<Bank attribute definition>>=
attribute Name string -id 1
attribute Passenger_load_time int
attribute Block_clear_time int
attribute Max_close_attempts int
attribute Average_cabin_speed double
attribute Average_stop_duration int
----

=== Bank Level Class [[bank-level-class,Bank Level]]

(((Data Model,Class,Bank Level)))
(((chunk,Bank Level attribute definition)))
[source,tcl]
----
<<Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor string -id 1

reference R29 Bank -link {Bank Name}
reference R29 Floor -link {Floor Name}
----

=== R29

(((Data Model,Relationship,R29)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R29 Bank 0..*--1..* Floor -associator Bank_Level
----

=== R38

(((Data Model,Relationship,R38)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
generalization R38 Bank_Level\
        Top_Bank_Level Middle_Bank_Level Bottom_Bank_Level
----

=== Building Class [[building-class,Building]]

(((Data Model,Class,Building)))
(((chunk,Building attribute definition)))
[source,tcl]
----
<<Building attribute definition>>=
attribute Name string -id 1
attribute Average_floor_gap double
----

=== Cabin Class [[cabin-class,Cabin]]

(((Data Model,Class,Cabin)))
(((chunk,Cabin attribute definition)))
[source,tcl]
----
<<Cabin attribute definition>>=
attribute Shaft int -id 1
attribute Travel_direction string -check {$Travel_direction in {up down}}
attribute Current_floor string

reference R2 Shaft -link {Shaft ID}
reference R43 Shaft_Level -link Shaft -link {Current_floor Floor}
----

=== R2

(((Data Model,Relationship,R2)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R2 Cabin 1--1 Shaft
----

=== R43

(((Data Model,Relationship,R43)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R43 Cabin 0..*--1 Shaft_Level
----

=== Door Class [[door-class,Door]]

(((Data Model,Class,Door)))
(((chunk,Door attribute definition)))
[source,tcl]
----
<<Door attribute definition>>=
attribute Shaft int -id 1
attribute Close_attempts_remaining int
attribute Open_wait_time int
attribute Lock_requested boolean -default false
attribute Held boolean -default false
attribute Emergency_hold boolean -default false

reference R4 Cabin -link Shaft
----

=== R4

(((Data Model,Relationship,R4)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R4 Door 1--1 Cabin
----

=== Floor Class [[floor-class,Floor]]

(((Data Model,Class,Floor)))
(((chunk,Floor attribute definition)))
[source,tcl]
----
<<Floor attribute definition>>=
attribute Name string -id 1
attribute Number int -id 2
attribute Height double
----

=== Floor Service Class [[floor-service-class,Floor Service]]

(((Data Model,Class,Floor Service)))
(((chunk,Floor Service attribute definition)))
[source,tcl]
----
<<Floor Service attribute definition>>=
attribute Bank string -id 1
attribute Floor string -id 1
attribute Shaft int -id 1
attribute Direction string -check {$Direction in {up down}}

reference R49 Bank_Level -link Bank -link Floor
reference R49 Accessible_Shaft_Level -link Floor -link Shaft
----

=== R49

(((Data Model,Relationship,R49)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R49 Bank_Level 0..*--0..* Accessible_Shaft_Level\
        -associator Floor_Service
----

=== Top Bank Level Class [[top-bank-level-class,Top Bank Level]]

(((Data Model,Class,Top Bank Level)))
(((chunk,Top Bank Level attribute definition)))
[source,tcl]
----
<<Top Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor string -id 1
attribute Calling_down boolean -default false

reference R38 Bank_Level -link Bank -link Floor
reference R5 Bank -link {Bank Name}
----

=== R5

(((Data Model,Relationship,R5)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R5 Top_Bank_Level 1--1 Bank
----

=== Middle Bank Level Class [[middle-bank-level-class,Middle Bank Level]]

(((Data Model,Class,Middle Bank Level)))
(((chunk,Middle Bank Level attribute definition)))
[source,tcl]
----
<<Middle Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor string -id 1
attribute Calling_up boolean -default false
attribute Calling_down boolean -default false

reference R38 Bank_Level -link Bank -link Floor
----

=== Bottom Bank Level Class [[bottom-bank-level-class,Bottom Bank Level]]

(((Data Model,Class,Bottom Bank Level)))
(((chunk,Bottom Bank Level attribute definition)))
[source,tcl]
----
<<Bottom Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor string -id 1
attribute Calling_up boolean -default false

reference R38 Bank_Level -link Bank -link Floor
reference R6 Bank -link {Bank Name}
----

=== R6

(((Data Model,Relationship,R6)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R6 Bottom_Bank_Level 1--1 Bank
----

=== Shaft Class [[shaft-class,Shaft]]

(((Data Model,Class,Shaft)))
(((chunk,Shaft attribute definition)))
[source,tcl]
----
<<Shaft attribute definition>>=
attribute ID int -id 1
attribute Bank string
attribute In_service boolean -default true

reference R1 Bank -link {Bank Name}
----

=== R1

(((Data Model,Relationship,R1)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R1 Shaft 1..*--1 Bank
----

=== Shaft Level Class [[shaft-level-class,Shaft Level]]

(((Data Model,Class,Shaft Level)))
(((chunk,Shaft Level attribute definition)))
[source,tcl]
----
<<Shaft Level attribute definition>>=
attribute Floor string -id 1
attribute Shaft int -id 1

reference R28 Floor -link {Floor Name}
reference R28 Shaft -link {Shaft ID}
----

=== R28

(((Data Model,Relationship,R28)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R28 Shaft 1..*--1..* Floor -associator Shaft_Level
----

=== Transfer Class [[transfer-class,Transfer]]

(((Data Model,Class,Transfer)))
(((chunk,Transfer attribute definition)))
[source,tcl]
----
<<Transfer attribute definition>>=
attribute Destination_floor string -id 1
attribute Shaft int -id 1

reference R53 Cabin -link Shaft
reference R53 Accessible_Shaft_Level -link {Destination_floor Floor} -link Shaft
----

=== R53

(((Data Model,Relationship,R53)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R53 Cabin 0..1--0..1 Accessible_Shaft_Level -associator Transfer
----

== Population [[population]]

Population

(((chunk,elevator population)))
[source,tcl]
----
<<elevator population>>=
class Building {
    Name                    Average_floor_gap} {
    {Pigsley Central}       3.2
}

class Bank {
    Name            Passenger_load_time Block_clear_time    Max_close_attempts  Average_cabin_speed Average_stop_duration} {
    Penthouse       4                   2                   25                  9.0                 9
    {Lower Floors}  4                   2                   25                  7.0                 9
    Freight         7                   5                   25                  5.0                 14
}

class Floor {
    Name    Number  Height} {
    PH      12      35.2
    8       11      32.0
    7       10      28.8
    6       9       25.6
    5       8       22.4
    4       7       19.2
    3       6       16.0
    2       5       12.8
    1       4       9.6
    L       3       6.4
    P1      2       3.2
    P2      1       0.0
}

class Bank_Level {
    Bank            Floor} {
    Penthouse       PH
    Penthouse       8
    Penthouse       L
    Penthouse       P1
    {Lower Floors}  7
    {Lower Floors}  6
    {Lower Floors}  5
    {Lower Floors}  4
    {Lower Floors}  3
    {Lower Floors}  2
    {Lower Floors}  1
    {Lower Floors}  L
    {Lower Floors}  P1
    {Lower Floors}  P2
    Freight         PH
    Freight         8
    Freight         7
    Freight         6
    Freight         5
    Freight         4
    Freight         3
    Freight         2
    Freight         1
    Freight         L
    Freight         P1
    Freight         P2
}

class Top_Bank_Level {
    Bank            Floor} {
    Penthouse       PH
    {Lower Floors}  7
    Freight         PH
}

class Middle_Bank_Level {
    Bank            Floor} {
    Penthouse       8
    Penthouse       L
    {Lower Floors}  6
    {Lower Floors}  5
    {Lower Floors}  4
    {Lower Floors}  3
    {Lower Floors}  2
    {Lower Floors}  1
    {Lower Floors}  L
    {Lower Floors}  P1
    Freight         8
    Freight         7
    Freight         6
    Freight         5
    Freight         4
    Freight         3
    Freight         2
    Freight         1
    Freight         L
    Freight         P1
}

class Bottom_Bank_Level {
    Bank            Floor} {
    Penthouse       P1
    {Lower Floors}  P2
    Freight         P2
}

class Shaft {
    ID          Bank} {
    1           Penthouse
    2           Penthouse
    3           {Lower Floors}
    4           {Lower Floors}
    5           {Lower Floors}
    6           Freight
}

class Shaft_Level {
    Shaft   Floor} {
    1       PH
    1       8
    1       7
    1       6
    1       5
    1       4
    1       3
    1       2
    1       1
    1       L
    1       P1
    1       P2
    2       PH
    2       8
    2       7
    2       6
    2       5
    2       4
    2       3
    2       2
    2       1
    2       L
    2       P1
    2       P2
    3       PH
    3       8
    3       7
    3       6
    3       5
    3       4
    3       3
    3       2
    3       1
    3       L
    3       P1
    3       P2
    4       PH
    4       8
    4       7
    4       6
    4       5
    4       4
    4       3
    4       2
    4       1
    4       L
    4       P1
    4       P2
    5       PH
    5       8
    5       7
    5       6
    5       5
    5       4
    5       3
    5       2
    5       1
    5       L
    5       P1
    5       P2
    6       PH
    6       8
    6       7
    6       6
    6       5
    6       4
    6       3
    6       2
    6       1
    6       L
    6       P1
    6       P2
}

class Accessible_Shaft_Level {
    Shaft   Floor   Bank} {
    6       PH      Freight
    6       8       Freight
    6       7       Freight
    6       6       Freight
    6       5       Freight
    6       4       Freight
    6       3       Freight
    6       2       Freight
    6       1       Freight
    6       L       Freight
    6       P1      Freight
    6       P2      Freight
    4       7       {Lower Floors}
    4       6       {Lower Floors}
    4       5       {Lower Floors}
    4       4       {Lower Floors}
    4       3       {Lower Floors}
    4       2       {Lower Floors}
    4       1       {Lower Floors}
    4       L       {Lower Floors}
    4       P1      {Lower Floors}
    4       P2      {Lower Floors}
    5       7       {Lower Floors}
    5       6       {Lower Floors}
    5       5       {Lower Floors}
    5       4       {Lower Floors}
    5       3       {Lower Floors}
    5       2       {Lower Floors}
    5       1       {Lower Floors}
    5       L       {Lower Floors}
    5       P1      {Lower Floors}
    5       P2      {Lower Floors}
    1       PH      Penthouse
    1       8       Penthouse
    1       L       Penthouse
    1       P1      Penthouse
    2       PH      Penthouse
    2       8       Penthouse
    2       L       Penthouse
    2       P1      Penthouse
    3       7       {Lower Floors}
    3       6       {Lower Floors}
    3       5       {Lower Floors}
    3       4       {Lower Floors}
    3       3       {Lower Floors}
    3       2       {Lower Floors}
    3       1       {Lower Floors}
    3       L       {Lower Floors}
    3       P1      {Lower Floors}
    3       P2      {Lower Floors}
}

class Cabin {
    Shaft           Travel_direction    Current_floor} {
    1               up                  3
    2               down                PH
    3               up                  L
    4               down                5
    5               down                L
    6               up                  5
}

class Door {
    Shaft   Close_attempts_remaining    Open_wait_time} {
    1       25                          4
    2       25                          4
    3       25                          4
    4       25                          4
    5       25                          4
    6       25                          7
}

assigner R53 {
    ID  } {
    1
    2
    3
    4
    5
    6
}
----

== Translating the State Models [[translating-state-models]]

=== Accessible Shaft Level State Model [[accessible-shaft-level-state-model]]

(((Dynamics Model,State Model,Accessible Shaft Level)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
initialstate NOT_REQUESTED
defaulttrans CH

transition NOT_REQUESTED - Stop_request -> Registering_stop
transition NOT_REQUESTED - Floor_calling -> Registering_floor_call

transition REQUESTED - Stop_request -> Registering_stop
transition REQUESTED - Floor_calling -> Registering_floor_call
transition REQUESTED - Stop_serviced -> Clear_stop_request
transition REQUESTED - Serviced_floor_request -> Clear_floor_request

transition Registering_stop - Stop_registered -> Requesting_service

transition Registering_floor_call - Floor_call_registered -> Requesting_service

transition Requesting_service - Wait_for_service -> REQUESTED

transition Clear_floor_request - Check_stop_request -> Clear_stop_request

transition Clear_stop_request - All_requested_cleared -> NOT_REQUESTED
transition Clear_stop_request - Opposite_floor_call_pending -> REQUESTED
----

=== Floor Service State Model [[floor-service-state-model]]

(((Dynamics Model,State Model,Floor Service)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
initialstate WAITING_FOR_CABIN
defaulttrans CH

transition WAITING_FOR_CABIN - Cabin_arrived -> Check_bank_level_type

transition HOLDING_SERVICE_DIRECTION - Cancel -> COMPLETED

transition Check_bank_level_type - Middle_floor -> HOLDING_SERVICE_DIRECTION
transition Check_bank_level_type - Top_or_bottom_floor -> COMPLETED
----

=== Transfer State Model [[transfer-state-model]]

(((Dynamics Model,State Model,Transfer)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
initialstate CREATED
defaulttrans CH

transition CREATED - Execute -> Creating_or_updating_transfer
transition CREATED - Door_closed -> IG

transition WAITING_FOR_CABIN - Destination_change_request ->\
        Changing_destination_before_cabin_moves
transition WAITING_FOR_CABIN - Ready_to_move -> Dispatching_cabin
transition WAITING_FOR_CABIN - Door_closed -> IG

transition CABIN_IN_MOTION - Destination_change_request -> Request_redirect
transition CABIN_IN_MOTION - Cabin_redirected -> Match_new_destination_of_cabin
transition CABIN_IN_MOTION - Cabin_at_destination -> Check_for_cabin_reversal

transition CALL_IN_PROGRESS - Destination_change_request -> IG
transition CALL_IN_PROGRESS - Door_closed -> Canceling_floor_service

transition WAITING_FOR_REQUESTS_TO_CLEAR - Destination_change_request -> IG
transition WAITING_FOR_REQUESTS_TO_CLEAR - Door_closed -> IG
transition WAITING_FOR_REQUESTS_TO_CLEAR - Requests_cleared -> Delete

transition Creating_or_updating_transfer - Wait_for_cabin -> WAITING_FOR_CABIN

transition Changing_destination_before_cabin_moves - Stationary_update ->\
        WAITING_FOR_CABIN

transition Dispatching_cabin - Cabin_dispatched -> CABIN_IN_MOTION

transition Request_redirect -> Redirect_requested -> CABIN_IN_MOTION

transition Match_new_destination_of_cabin - Update_in_motion -> CABIN_IN_MOTION

transition Check_for_active_floor_service - Call_in_progress -> CALL_IN_PROGRESS
transition Check_for_active_floor_service - Wait_to_clear ->\
        WAITING_FOR_REQUESTS_TO_CLEAR

transition Check_for_cabin_reversal - Reversal_checked ->\
        Check_for_active_floor_service

transition Canceling_floor_service - Wait_to_clear ->\
        WAITING_FOR_REQUESTS_TO_CLEAR
----

=== Cabin State Model [[cabin-state-model]]

(((Dynamics Model,State Model,Cabin)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
initialstate PICKUP_DROPOFF
defaulttrans CH

transition MOVING - Try_redirect -> Changing_destination
transition MOVING - Arrived_at_floor -> PICKUP_DROPOFF

transition PICKUP_DROPOFF - Try_redirect -> IG
transition PICKUP_DROPOFF - New_transfer -> Are_we_already_there?

transition SECURING_DOORS - Doors_secure -> READY_TO_GO

transition READY_TO_GO - Go -> Requesting_transport

transition Requesting_transport - Transport_in_progress -> MOVING
transition Requesting_transport - Transport_unavailable -> OUT_OF_SERVICE

transition Changing_destination - Change_requested -> MOVING

transition Are_we_already_there? - Already_there -> PICKUP_DROPOFF
transition Are_we_already_there? - Prepare_to_move -> SECURING_DOORS
----

=== Door State Model [[door-state-model]]

(((Dynamics Model,State Model,Door)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
initialstate CLOSED
defaulttrans CH

transition OPENING - Door_opened -> OPEN
transition OPENING - Passenger_open -> IG
transition OPENING - Passenger_close -> CLOSING
transition OPENING - Lock -> IG
transition OPENING - Cant_close_door -> CANT_CLOSE
transition OPENING - Keep_trying -> CANT_CLOSE

transition OPEN - Passenger_open -> IG
transition OPEN - Passenger_close -> Cancel_open_delay
transition OPEN - Lock -> IG
transition OPEN - Time_to_close -> HOLDING_OPEN

transition HOLDING_OPEN - Passenger_open -> IG
transition HOLDING_OPEN - Passenger_close -> IG
transition HOLDING_OPEN - Lock -> IG
transition HOLDING_OPEN - Hold_released -> CLOSING

transition CLOSING - Door_closed -> CLOSED
transition CLOSING - Door_blocked -> OPENING
transition CLOSING - Passenger_open -> OPENING
transition CLOSING - Passenger_close -> IG
transition CLOSING - Lock -> IG

transition CLOSED - Passenger_open -> OPENING
transition CLOSED - Passenger_close -> IG
transition CLOSED - Lock -> LOCKED

transition LOCKED - Passenger_open -> IG
transition LOCKED - Passenger_close -> IG
transition LOCKED - Unlock -> OPENING

transition Cancel_open_delay - Open_delay_canceled -> HOLDING_OPEN

transition Count_block - Cant_close_door -> CANT_CLOSE
transition Count_block - Keep_trying -> OPENING
----

=== R53 Assigner State Model [[r53-assigner-state-model]]

(((Dynamics Model,State Model,R53)))
(((chunk,R53 state model definition)))
[source,tcl]
----
<<R53 state model definition>>=
initialstate NO_TRANSFER
defaulttrans CH

transition NO_TRANSFER - Service_requested -> Searching_for_new_destination

transition TRANSFER_IN_PROGRESS - Transfer_completed ->\
        Searching_for_new_destination
transition TRANSFER_IN_PROGRESS - Service_requested ->\
        Searching_for_alternate_destination

transition Searching_for_new_destination - No_destination -> NO_TRANSFER
transition Searching_for_new_destination - Transfer_created ->\
        TRANSFER_IN_PROGRESS

transition Searching_for_alternate_destination - Dest_change_evaluated ->\
        TRANSFER_IN_PROGRESS
----

== Translating the Processing [[translating-processing]]

=== Door State Activities

==== OPENING

(((Activity,Door,OPENING)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state OPENING {} {
# Open door( Shaft ) => SIO
# UI.Door opening( Shaft )

    assignAttribute $self Shaft
    SIO::Open_door $Shaft
    UI::Door_opening $Shaft
}
----

==== OPEN

(((Activity,Door,OPEN)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state OPEN {} {
# UI.Door opened( Shaft )
# my Bank .= /R4/R2/Bank
# Time to close -> me after Blocked ? \
# my Bank.Block clear time : my Bank.Passenger load time

    assignAttribute $self Shaft Open_wait_time
    UI::Door_opened [readAttribute $self Shaft]
    set my_Bank [findRelated $self R4 R2 R1]
    set close_time [expr {[readAttribute $self Blocked] ?\
        [readATtribute $my_Bank Block_clear_time] :\
        [readAttribute $my_Bank Passenger_load_time]}]
    delaysignal $close_time $self Time_to_close
}
----

==== HOLDING_OPEN

(((Activity,Door,HOLDING OPEN)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state HOLDING_OPEN {} {
# [!Held] Hold released -> me

    if {![readAttribute $self Held]} {
        signal $self Hold_released
    }
}
----

==== CLOSING

(((Activity,Door,CLOSING)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state CLOSING {} {
# [!Emergency hold] {
#    Close door( Shaft ) => SIO
#    UI.Door closing( Shaft )
# }
# [Emergency hold] Emergency hold -> me

    if {![readAttribute $self Emergency_hold]} {
        SIO::Close_door $shaft
        UI::Door_closing $shaft
    } else {
        signal $self Emergency_hold
    }
}
----

==== CLOSED

(((Activity,Door,CLOSED)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state CLOSED {} {
# UI.Door closed( Shaft )
# Close attempts.reset
# Blocked.unset
# [Lock requested] Lock -> me
# Door closed -> /R4/R53/Transfer // May be none

    UI::Door_closed $Shaft

    updateAttribute $self Close_attempts_remaining 0 Blocked false
    assignAttribute $self Shaft Lock_requested
    if {[readAttribute $self Lock_requested]} {
        signal $self Lock
    }
    set transfers [findRelated $self R4 {R53 Transfer}]
    signal $transfers Door_closed
}
----

==== LOCKED

(((Activity,Door,LOCKED)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# // Tell the cabin that we’re ready to go
# Lock requested.unset
# Doors secure -> /R4/Cabin

state LOCKED {} {
    updateAttribute $self Lock_requested false
    set cabin [findRelated $self R4]
    signal $cabin Doors_secure
}
----

==== CANT_CLOSE

(((Activity,Door,CAN'T CLOSE)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state CANT_CLOSE {} {
# // Take the shaft out of service
# Take out of service -> /R4/R2/Shaft

    set shaft [findRelated $self R4 R2]
    signal $shaft Take_out_of_service
}
----

==== Cancel open delay

(((Activity,Door,Cancel open delay)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state Cancel_open_delay {} {
# Cancel Time to close -> me
# Open delay canceled -> me

    canceldelayed $self $self Time_to_close
    signal $self Open_delay_canceled
}
----

==== Count block

(((Activity,Door,Count block)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state Count_block {} {
# if (++Close attempts > /R4/R2/Bank.Max close attempts)
#     Can’t close door -> me
# else {
#     Blocked.set
#     Keep trying -> me
# }

    assignAttribute $self Close_attempts
    incr Close_attempts
    updateAttribute $self Close_attempts $Close_Attempts
    set my_Bank [findRelated $self R4 R2 R1]
    if {$Close_attempts > [readAttribute $my_Bank Max_close_attempts} {
        signal $self Cant_close_door
    } else {
        updateAttribute $self Blocked true
        signl $self Keep_trying
    }
}
----

==== EMERGENCY HOLD

(((Activity,Door,EMERGENCY HOLD)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
state EMERGENCY_HOLD {} {
    // place holder for yet unspecified activity
}
----

=== Cabin State Activities

==== MOVING

(((Activity,Cabin,MOVING)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state MOVING {} {
}
----

==== PICKUP_DROPOFF

(((Activity,Cabin,PICKUP DROPOFF)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state PICKUP_DROPOFF {} {
# Cabin at destination -> /R53/Transfer
# Unlock -> /R4/Door
# if (not /R2/Shaft.In service )
#   Take out of service -> me

    set xfer [findRelated $self {R53 Transfer}]
    signal $xfer Cabin_at_destination

    set door [findRelated $self ~R4]
    signal $door Unlock

    set shaft [findRelated $self R2]
    if {![readAttribute $shaft In_service]} {
        signal $self Take_out_of_service
    }
}
----

==== SECURING DOORS

(((Activity,Cabin,SECURING DOORS)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state SECURING_DOORS {} {
# /R4/Door.Lock requested.set
# Lock -> /R4/Door

    set door [findRelated $self ~R4]
    updateAttribute $door Lock_requested true
    signal $door Lock
}
----

==== READY TO GO

(((Activity,Cabin,READY TO GO)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state READY_TO_GO {} {
# Ready to go -> /R53/Transfer

    set xfer [findRelated $self {R53 Transfer}]
    signal $xfer Ready_to_go
}
----

==== OUT OF SERVICE

(((Activity,Cabin,OUT OF SERVICE)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state OUT_OF_SERVICE {} {
# /R4/Door.Emergency hold.set
# Passenger open -> /R4/Door

    set door [findRelated $self ~R4]
    updateAttribute $door Emergency_hold true
    signal $door Passenger_open
}
----

==== Requesting transport

(((Activity,Cabin,Requesting transport)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state Requesting_transport {} {
# if (TRAN.Goto floor( Dest floor: /R53/Transfer.Destination floor, Shaft ) )
#   Transport in progress -> me
# else
#   Transport unavailable -> me

    assignAttribute $self Shaft
    set xfer [findRelated $self {R53 Transfer}]
    assignAttribute $xfer Destination_floor
    set avail [TRAN::Goto_floor $Destination_floor $Shaft]
    if {$avail} {
        signal $self Transport_in_progress
    } else {
        signal $self Transport_unavailable
    }
}
----

==== Changing destination

(((Activity,Cabin,Changing destination)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state Changing_destination {new_dest} {
# if ( TRAN.Go to floor( Dest floor: in.new dest, Shaft ) )
#   Cabin redirected( Updated dest: in.new dest ) -> /R53/Transfer
# Change requested -> me

    assignAttribute $self Shaft
    set avail [TRAN::Goto_floor $new_dest $Shaft]
    if {$avail} {
        set xfer [findRelated $self {R53 Transfer}]
        signal $xfer Cabin_redirected updated_dest $new_dest
    }
    signal $self Change_requested
}
----

==== Are we already there?

(((Activity,Cabin,Are we already there?)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state Are_we_already_there? {} {
# if ( /R53/Transfer.Destination floor == /R43/is at/Shaft Level/Floor )
#   Already there -> me
# else
#   Prepare to move -> me

    set xfer [findRelated $self {R53 Transfer}]
    assignAttribute $xfer Destination_floor
    set shaft_level [findRelated $self R43]
    assignAttribute $shaft_level Floor
    if {$Destination_floor == $Floor} {
        signal $self Already_there
    } else {
        signal $self Prepare_to_move
    }
}
----

=== Cabin Class Methods [[cabin-class-methods]]

==== Count stops oneway

(((Method,Cabin,Count stops oneway)))
(((chunk,Cabin operations definition)))
[source,tcl]
----
<<Cabin operations definition>>=
# // Cabin.Count stops oneway( aslevs: Accessible Shaft Level,
#       search dir: Direction ) : Count

# // Returns the number of Accessible Shaft Levels to be serivced with the
# // Cabin proceeding in the provided search direction

# // Count all aslevs with a stop requested or a floor call in the
# // search direction

# =>> ?in.aslevs(Stop requested) + ?(
#     in.aslevs(not Stop requested) ##
#           Floor Service(Direction : in.search dir).(*I) )

# // Note: ? is the cardinality (how many?) operator
# // In a projection predicate *I is shorthand for "select all primary ID attrs"

instop Count_stops_oneway {aslevs search_dir} {
    set sreqs [relation restrictwith $aslevs {$Stop_requested}]

    set nsreqs [pipe {
        relation minus $aslevs $sreqs |
        relation project ~ Bank Floor Shaft
    }]
    set fcalls [pipe {
        Floor_Service findWhere {$Direction eq $search_dir} |
        deRef ~ |
        relation project ~ Bank Floor Shaft |
        relation join $nsreqs ~
    }]

    return [expr {
        [relation cardinality $sreqs] + [relation cardinality $fcalls]
    }]
}
----

==== Count stops roundtrip

(((Method,Cabin,Count stops roundtrip)))
(((chunk,Cabin operations definition)))
[source,tcl]
----
<<Cabin operations definition>>=
# // Cabin.Count stops roundtrip( aslevs: Accessible Shaft Level ) : Count

# // Returns the number of Accessible Shaft Levels to be serviced with the
# // Cabin passing in both directions

# // Count all floor service calls in either direction
# floor calls either dir #= in.aslevs ## Floor Service.(*I)

# // Count all stop requests with no floor calls
# stops without calls #= in.aslevs(Stop requested) #- floor calls either dir

# // Return the total
# =>> ?floor calls either dir + ?stops without calls

instop Count_stops_roundtrip {aslevs} {
    set floor_calls_either_dir [pipe {
        Floor_Service findAll |
        deRef ~ |
        relation join $aslevs ~ |
        relation project ~ Bank Floor Shaft
    }]

    set stops_without_calls [pipe {
        relation restrictwith $aslevs {$Stop_requested} |
        relation project ~ Floor Shaft Bank |
        relation minus ~ $floor_calls_either_dir
    }]

    return [expr {[relation cardinality $floor_calls_either_dir] +\
            [relation cardinality $stops_without_calls]}]
}
----

==== Estimate delay

(((Method,Cabin,Estimate delay)))
(((chunk,Cabin operations definition)))
[source,tcl]
----
<<Cabin operations definition>>=
# // Cabin.Estimate delay( calling floor : Floor name,
# //      service dir : Direction ) : Duration

# // Returns the distance in floor units from this Cabin to the specified floor
# // The algorithm is described and illustrated in the
# // Bank Select technical note. mint.elevator.tn.6

# // Get start, destination and direction data

# calling fnum, calling height = Floor( Name: in.calling floor ).(Number, Height)
# cabin fnum, cabin height = /R43/R28/Floor.(Number, Height)
# top fnum = /R2/Shaft/Floor(+^Number) // max operator
# bottom fnum = Ordinal.least // operation on Ordinal type
# floor gap = Building.Average floor gap // Singleton selection, no restriction clause

# // Useful guards
# [calling up][calling down] = (in.service dir == .up)
# [cabin high][cabin low] = (cabin fnum > calling fnum)
# // sets true-false if true and vice versa

# // Test the simple case
# if (calling fnum == cabin fnum)
#     =>> _0.0 // distance is zero

# // Two key factors determine the number of reversals required to reach
# // the calling floor:
# //     1) Which side of the calling arrow are we at?
# //     2) Is our travel direction the same as the calling arrow?

# // Mark high/low coordinates on shaft
# // and relative cabin/calling floor position
# //

# [behind the call arrow] = ( [cabin low] and [calling up] ) or ( [cabin high] and [calling down] )
# // single guard on LHS is set to true or false

# [dir match] = (Travel direction == in.service dir)

# // All shaft levels accessible in cabin's shaft with floor numbers
# // --- numbered aslevs ---
# // | Floor | Shaft | Bank | Stop Requested | Number |
# // ---
# numbered aslevs #= /R2/R28/R3/Accessible Shaft Level ## Floor.(Name >> Floor, Number)

# [dir match][behind the call arrow] {
#     //
#     // Case 1: Cabin is moving in the same direction and behind call arrow tail
#     // ..[cab->]....(call->)

#     // Route:
#     // 
#     // Simplest route, it's a straight shot:
#     //
#     //   a> Toward call in correct direction

#     // Count stops and calls in the Cabin's travel direction only (ignore reverse calls).
#     // Don't count the cabin or calling floor

#     countable aslevs ..= numbered aslevs(Number: cabin fnum<>calling fnum)
#     stops = Count stops oneway(aslevs: countable aslevs, search dir: Travel direction)
#     distance = cabin height.separation(calling height)
# }

# [dir match][!behind the call arrow] {
#     //
#     // Case 2: Cabin is moving in the same direction, but is ahead of the call arrow
#     // ..(call->)....[cab->]
#     // 
#     // Route: 
#     // 
#     // We'll have to take the long way around proceeding:
#     //
#     //   a> to turn 1 (top or bottom of shaft) and back
#     //   b> toward the calling floor in the opposite direction passing it
#     //   c> to turn 2 (opposite of turn 1) and then back to the calling floor
#     //      in the matching direction where it will be serviced
#     //

#     // Set turn 1 and 2 to the appropriate shaft ends
#     [cabin high]
#         turn 1, turn2 = top fnum, bottom fnum
#     [cabin low]
#         turn 1, turn2 = bottom fnum, top fnum

#     // 2a> Toward turn 1
#     countable aslevs ..= numbered aslevs(Number: cabin floor<>|turn 1)
#     stops += Count stops roundtrip( aslevs: countable aslevs )
#     distance = cabin height.separation( Floor(turn 1).Height ) * 2 + floor gap
#     HERE !! -- where does "cabin floor" come from

#     // 2b> From the nearest accessible shaft level to the calling floor
#     countable aslevs ..= numbered aslevs(Number: cabin floor<>|calling fnum)
#     stops += Count stops oneway( aslevs: countable aslevs, search dir: Travel direction.opposite )
#     distance += cabin height.separation( calling height )

#     // 2c> To turn 2 and back to the calling floor
#     countable aslevs ..= numbered aslevs(Number: calling floor<>|turn2)
#     stops += Count stops roundtrip( aslevs: countable aslevs )
#     distance += cabin height.separation( Floor(turn2).Height ) * 2
# }

# [!dir match][behind the call arrow]{
#     //
#     // Case 3: Cabin is moving oppsosite the calling direction behind the call
#     //
#     // Route:
#     //
#     // a> toward the end of the top or bottom of shaft
#     // b> back twoard the call in the service direction
#     // 

#     // 3a> To end of shaft and back to the current location
#     [cabin high]
#         turn = top fnum
#     [cabin low]
#         turn = bottom fnum

#     countable aslevs ..= numbered aslevs(Number: cabin fnum<>turn)
#     stops += Count stops roundtrip( aslevs: countable aslevs )
#     distance += cabin height.separation( Floor(turn).Height ) * 2

#     // 3b> back toward call in service direction
#     countable aslevs ..= numbered aslevs(Number: cabin fnum<>|calling fnum)
#     stops += Count stops oneway( aslevs: countable aslevs, service dir: Travel direction.opposite)
#     distance += cabin height.separation( calling floor height )
# }

# [!dir match][!behind the call arrow]{
#     //
#     // Cabin is moving in the opposite direction ahead of the call
#     //
#     // Route:
#     // a> Toward call in opposite direction
#     // b> Toward top or bottom of shaft and back

#     // 4a> Toward call in opposite direction
#     countable aslevs ..= numbered aslevs(Number: cabin fnum|<>|calling fnum)
#     stops += Count stops oneway( aslevs: countable aslevs, service dir: Travel direction.opposite)
#     distance += cabin height.separation( calling floor height )

#     // 4b> Toward top or bottom of shaft and back
#     [cabin high]
#         turn = bottom fnum
#     [cabin low]
#         turn = top fnum

#     countable aslevs ..= numbered aslevs(Number: calling floor<>|turn)
#     stops += Count stops roundtrip( aslevs: countable aslevs )
#     distance += cabin height.separation( Floor(turn).Height ) * 2
# }
    
# transit delay = distance / /R2/R1/Bank.Avg cabin speed
# stop delay = stops * /R2/R1/Bank.Avg stop duration

# =>> transit delay + stop delay

instop Estimate_delay {calling_floor service_dir} {
    set clfloor [Floor findWhere {$Name eq $calling_floor}]
    assignAttribute $clfloor {Number calling_fnum} {Height calling_height}
    set cfloor [findRelated $self R43 R28]
    assignAttribute $cfloor {Number cabin_fnum} {Height cabin_height}

    set top_fnum [pipe {
        findRelated $self R2 R28 |
        deRef ~ |
        relation summarizeby ~ {} fs TopFloor int {rmax($fs, "Number")} |
        relation extract ~ TopFloor
    }]
    set bottom_fnum [pipe {
        findRelated $self R2 R28 |
        deRef ~ |
        relation summarizeby ~ {} fs BottomFloor int {rmin($fs, "Number")} |
        relation extract ~ BottomFloor
    }]
    set floor_gap [pipe {
        Building findAll |
        readAttribute ~ Average_floor_gap
    }]

    set calling_up [expr {$service_dir eq "up"}]
    set calling_down [expr {$service_dir eq "down"}]
    set cabin_high [expr {$cabin_fnum > $calling_fnum}]
    set cabin_low [expr {$cabin_fnum < $calling_fnum}]

    if {$calling_fnum == $cabin_fnum} {
        return 0.0
    }

    set behind_the_call_arrow [expr {($cabin_low && $calling_up) ||\
            ($cabin_high && $calling_down)}]
    set dir_match\
            [expr {[readAttribute $self Travel_direction] eq $service_dir}]
    set floor_name_map [pipe {
        Floor findAll |
        deRef ~ |
        relation project ~ Name Number |
        relation rename ~ Name Floor
    }]
    set numbered_aslevs [pipe {
        findRelated $self R2 {R28 Shaft_Level} {R3 Accessible_Shaft_Level} |
        deRef ~ |
        relation join ~ $floor_name_map
    }]

    set distance 0.0
    set travel_dir [readAttribute $self Travel_direction]
    set opposite_travel_dir [expr {$travel_dir eq "up" ? "down" : "up"}]

    if {$dir_match && $behind_the_call_arrow} {
        # Case 1

        set countable_aslevs [relation restrictwith $numbered_aslevs\
                {$Number > $cabin_fnum && $Number < $calling_fnum}]
        set stops [instop $self Count_stops_oneway $countable_aslevs $travel_dir]

        set distance [expr {abs($cabin_height - $calling_height)}]
    } elseif {$dir_match && !$behind_the_call_arrow} {
        # Case 2

        if {$cabin_high} {
            set turn_1 $top_fnum
            set turn_2 $bottom_fnum
        }
        if {$cabin_low} {
            set turn_1 $bottom_fnum
            set turn_2 $top_fnum
        }

        # 2a
        set countable_aslevs [relation restrictwith $numbered_aslevs\
                {$Number > $cabin_fnum && $Number < $turn_1}]
        incr stops [instop $self Count_stops_roundtrip $countable_aslevs]
        set turn_1_height [pipe {
            Floor findWhere {$Number == $turn_1} |
            readAttribute ~ Height
        }]
        set distance [expr {$distance +\
                abs($cabin_height - $turn_1_height) * 2. + $floor_gap}]

        # 2b
        set countable_aslevs [relation restrictwith $numbered_aslevs\
                {$Number > $cabin_fnum && $Number < $calling_fnum}]
        # using cabin_fnum for "cabin floor"

        incr stops [instop $self Count_stops_oneway $countable_aslevs\
                $opposite_travel_dir]
        set distance [expr {$distance + abs($cabin_height - $calling_height)}]

        # 2c
        set countable_aslevs [relation restrictwith $numbered_aslevs\
                {$Number > $cabin_fnum && $Number < $turn_2}]
        incr stops [instop $self Count_stops_roundtrip $countable_aslevs]
        set turn_2_height [pipe {
            Floor findWhere {$Number == $turn_2} |
            readAttribute ~ Height
        }]
        set distance [expr {$distance + abs($cabin_height - $turn_2_height) * 2.}]
    } elseif {!$dir_match && $behind_the_call_arrow} {
        # Case 3

        if {$cabin_high} {
            set turn $top_fnum
        }
        if {$cabin_low} {
            set turn $bottom_fnum
        }

        # 3a
        set countable_aslevs [relation restrictwith $numbered_aslevs\
                {$Number > $cabin_fnum && $Number < $turn}]
        incr stops [instop $self Count_stops_roundtrip $countable_aslevs]
        set turn_height [pipe {
            Floor findWhere {$Number == $turn} |
            readAttribute ~ Height
        }]
        set distance [expr {$distance + abs($cabin_height - $turn_height) * 2.}]

        # 3b
        set countable_aslevs [relation restrictwith $numbered_aslevs\
                {$Number > $cabin_fnum && $Number < $calling_fnum}]
        incr stops [instop $self Count_stops_oneway $countable_aslevs\
                $opposite_travel_dir]
        set distance [expr {$distance + abs($cabin_height - $calling_height)}]
    } elseif {!$dir_match && !$behind_the_call_arrow} {
        # Case 4

        if {$cabin_high} {
            set turn $bottom_fnum
        }
        if {$cabin_low} {
            set turn $top_fnum
        }

        # 4a
        set countable_aslevs [relation restrictwith $numbered_aslevs\
                {$Number > $cabin_fnum && $Number < $calling_fnum}]
        incr stops [instop $self Count_stops_oneway $countable_aslevs\
                $opposite_travel_dir]

        # 4b
        set countable_aslevs [relation restrictwith $numbered_aslevs\
                {$Number > $calling_floor && $Number < $turn}]
        incr stops [instop $self Count_stops_roundtrip $countable_aslevs]
        set turn_height [pipe {
            Floor findWhere {$Number == $turn} |
            readAttribute ~ Height
        }]
        set distance [expr {$distance + abs($cabin_height - $turn_height) * 2.}]
    }

    set bankRef [findRelated $self R2 R1]
    assignAttribute $bankRef Average_cabin_speed Average_stop_duration
    return [expr {$distance / $Average_cabin_speed +\
            $stops * $Average_stop_duration}]
}
----

==== Ping

(((Method,Cabin,Ping)))
(((chunk,Cabin operations definition)))
[source,tcl]
----
<<Cabin operations definition>>=
# // Cabin.Ping( dir: Direction ) : Acessible Shaft Level

# // Search ahead of the Cabin in the indicated direction
# // return the nearest ASL with a stop request and/or a Floor Service calling
# // in that direction. If none is found, return the empty set.

# // Get all bank levels between cabin and end of shaft in the indicated
# // direction

# current floor number = /R43/R28/Floor.Number // Need ordinal, not floor name
# case ( in.dir ) {
# .up:
#     aslevs ahead of cabin ..= Accessible Shaft Level( 
#         /R3/R28/Floor.Number: >= current floor number, Bank: Bank
#     )
# .down:
#     aslevs ahead of cabin ..= Accessible Shaft Level( 
#         /R3/R28/Floor.Number: < current floor number, Bank: Bank
#     )
# }
# HERE !! -- don't understand the "Bank: Bank", Bank is not an attribute

# // Return the nearest floor ahead of the cabin with a stop requested or a
# // floor service call in the specified direction
# =>> aslevs ahead of cabin( 
#         -^Floor.distance(its.Floor) AND
#         (Stop requested OR /R49/Floor Service.Direction : in.dir)
#     )
# HERE !! -- don't understand the "(its.Floor)"

# // The Ordinal type's distance operation returns the absolute value of the
# // difference

instop Ping {dir} {
    set current_floor_number [pipe {
        findRelated $self R43 R28 |
        readAttribute ~ Number
    }]

    set accessible_floors [pipe {
        Accessible_Shaft_Level findAll |
        deRef ~ |
        relation join ~ [deRef [Shaft_Level findAll]]\
            [deRef [Floor findAll]] -using {Floor Name}
    }]
    switch -exact -- $dir {
        up {
            set aslevs_ahead_of_cabin [relation restrictwith\
                $accessible_floors {$Floor >= $current_floor_number}]
        }
        down {
            set aslevs_ahead_of_cabin [relation restrictwith\
                $accessible_floors {$Floor < $current_floor_number}]
        }
        default {
            error "unknown direction, \"$dir\""
        }
    }

    # HERE -- missing "Floor.distance()" thing
    set aslevs_ahead_of_cabin [pipe {
        relation join $aslevs_ahead_of_cabin [deRef [Floor_Service findAll]] %
        relation restrictwith ~ {$Stop_requested || $Direction eq $dir} %
        relation project ~ Floor Shaft Bank Stop_requested %
        toRef Accessible_Shaft_Level ~
    } {} %~]
}
----

==== Ping both ways

(((Method,Cabin,Ping both ways)))
(((chunk,Cabin operations definition)))
[source,tcl]
----
<<Cabin operations definition>>=
# // Cabin.Ping both ways() : Acessible Shaft Level
# //
# // Search ahead of the Cabin in the indicated direction return the nearest ASL
# // with a stop request and/or a Floor Service calling in the travel direction.
# // If there are none, return the furthest ASL with a Floor Service
# // calling opposite the travel direction if any can be found. Otherwise, just
# // return an empty set.
# //
# // Search in the Cabin's current travel direction
# fwd dest .= Ping( dir: Travel direction )
# [!found] =>> fwd dest
# [found] {
#     rev dest .= Ping( dir: Travel direction.opposite )
#     [!found] Travel direction.toggle
#     =>> rev dest // Empty if there is no destination in either direction
# }
# // Scrall note: I'm trying to move away from if-then's as much as possible to
# // encourage DFD thinking. Still working on defining a consistent set of
# // names for the zero, one, many case. [found] = [!empty] = [one]. A guard
# // is always set relative to the nearest action, so the first [!found] is
# // relative to the first Ping while the second is relative to the second Ping

instop Ping_both_ways {} {
    set tdir [readAttribute $self Travel_direction]
    set op_tdir [expr {$tdir eq "up" ? "down" : "up"}]
    set fwd_dest [instop $self Ping $tdir]

    if {[isEmptyRef $fwd_dest]} {
        return $fwd_dest
    } else {
        set rev_dest [instop Ping $op_tdir]
        if {[isEmptyRef $rev_dest]} {
            updateAttribute $self Travel_direction $op_tdir
        }
        return $rev_dest
    }
}
----

==== Update location

(((Method,Cabin,Update location)))
(((chunk,Cabin operations definition)))
[source,tcl]
----
<<Cabin operations definition>>=
# // Cabin.Update location( floor : Level Name )

# // Updates the current location of the cabin as it moves
# // and notifies the UI of the new location

# &R43 /R2/R28/Shaft Level( in.Floor ) ; UI.New location( Shaft, floor: Current floor )

# // ; symbol is shorthand for typing a guard twice
# // for simple action sequences
# // longhand form is
# //     do x first [done]
# //     [done] do y

instop Update_location {floor} {
    set shlevel [findRelatedWhere $self {R2 {R28 Shaft_Level}}\
        {$Floor eq $floor}]
    R43 link $shlevel $self
    assignAttribute $self Shaft Current_floor
    UI::New_location $Shaft $Current_floor
}
----

=== Transfer State Activities

==== CREATED

(((Activity,Transfer,CREATED)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state CREATED {} {
}
----

==== Creating or updating transfer

(((Activity,Transfer,Creating or updating transfer)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# UI.Set destination( Shaft, floor: Destination floor )
# New transfer -> /R53/Cabin
# Wait for cabin -> me

state Creating_or_updating_transfer {} {
    assignAttribute $self
    UI::Set_destination $Shaft $Destination_floor
    set cabin [findRelated $self ~R53]
    signal $cabin New_transfer
    signal $self Wait_for_cabin
}
----

==== Changing destination before cabin moves

(((Activity,Transfer,Changing destination before cabin moves)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# // The cabin isn’t moving, so we can safely relink to the new destination
# Destination floor = in.updated dest
# Stationary update -> me

state Changing_destination_before_cabin_moves {new_dest} {
    set new_asl [Accessible_Shaft_Level findById\
        Shaft [readAttribute $self Shaft] Floor $new_dest]
    R53 reference $self $new_asl
    signal $self Stationary_update
}
----

==== WAITING FOR CABIN

(((Activity,Transfer,WAITING FOR CABIN)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state WAITING_FOR_CABIN {} {
}
----

==== Dispatching cabin

(((Activity,Transfer,Dispatching cabin)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Go -> /R53/Cabin
# Cabin dispatched -> me

state Dispatching_cabin {} {
    set cabin [findRelated $self ~R53]
    signal $cabin Go
    signal $self Cabin_dispatched
}
----

==== Request redirect

(((Activity,Transfer,Request redirect)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Try redirect( in.new dest ) -> /R53/Cabin
# Cabin redirect requested -> me

state Request_redirect {new_dest} {
    set cabin [findRelated $self ~R53]
    signal $cabin Try_redirect $new_dest
    signal $self Cabin_redirect_requested
}
----

==== CABIN IN MOTION

(((Activity,Transfer,CABIN IN MOTION)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state CABIN_IN_MOTION {} {
}
----

==== Match new destination of cabin

(((Activity,Transfer,Match new destination of cabin)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Destination floor = in.updated dest
# Update in motion -> me

state Match_new_destination_of_cabin {updated_dest} {
    set new_asl [Accessible_Shaft_Level findById\
        Shaft [readAttribute $self Shaft] Floor $new_dest]
    R53 reference $self $new_asl
    signal $self Update_in_motion
}
----

==== Check for cabin reversal

(((Activity,Transfer,Check for cabin reversal)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# // If the Cabin arrives and there is a floor request in the opposite direction
# // and no stop request or call in the Cabin’s current travel direction,
# // we must reverse the cabin’s travel direction
# freqs ..= /R53/R49/Floor Service
# if ( freqs( Direction: /R53/Cabin.Travel direction.opposite ) and
#	    not freqs( Direction: /R53/Cabin.Travel direction ) and
#	    not /R53/Accessible Shaft Level.Stop requested)
#	/R53/Cabin.Travel direction.toggle
# Reversal checked -> me

state Check_for_cabin_reversal {} {
    set cabin [findRelated $self {~R53}]
    set tdir [readAttribute $cabin Travel_direction]
    set tdir_op [expr {$tdir eq "up" ? "down" : "up"}]
    set aslev [findRelated $self {R53 Accessible_Shaft_Level}]
    assignAttribute $aslev Stop_requested

    set op_freqs [findRelatedWhere $aslev {{~R49 Floor_Service}}\
            {$Direction eq $tdir_op}]
    set in_freq [findRelatedWhere $aslev {{~R49 Floor_Service}}\
            {$Direction eq $tdir}]

    if {[isNotEmptyRef $op_freq] && [isEmptyRef $in_freq] && !$Stop_requested} {
        updateAttribute $cabin Travel_direction $tdir_op
    }

    signal $self Reversal_checked
}
----

==== Check for active floor service

(((Activity,Transfer,Check for active floor service)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# UI.Cabin arrived( Shaft )
# pending floor service .=
#       /R53/R49/Floor Service( Direction: /R53/Cabin.Travel direction )
# if (pending floor service) {
#   Call in progress -> me
#   Cabin arrived -> pending floor service
# } else {
#   Serviced stop -> /R53/Accessible Shaft Level
#   Wait to clear -> me
# }

state Check_for_active_floor_service {} {
    UI::Cabin arrived [readAttribute $self Shaft]
    set cabin [findRelated $self ~R53]
    assignAttribute $cabin Travel_direction
    set pending_floor_service [findRelatedWhere $self {R53 {R49 Floor_Service}}\
            {$Direction eq $Travel_direction}]
    if {[isNotEmptyRef $pending_floor_service]} {
        signal $self Call_in_progress
        signal $pending_floor_service Cabin_arrived
    } else {
        set asl [findRelated $self R53]
        signal $asl Service_stop
        signal $self Wait_to_Clear
    }
}
----

==== CALL IN PROGRESS

(((Activity,Transfer,CALL IN PROGRESS)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state CALL_IN_PROGRESS {} {
}
----

==== Canceling floor service

(((Activity,Transfer,Canceling floor service)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Cancel -> /R53/R49/Floor Service( Direction: /R53/Cabin.Travel direction )
# Wait to clear -> me

state Canceling_floor_service {} {
    set cabin [findRelated $self ~R53]
    assignAttribute $cabin Travel_direction
    set pending_floor_service [findRelatedWhere $self {R53 {R49 Floor_Service}}\
            {$Direction eq $Travel_direction}]
    signal $pending_floor_service Cancel
    signal $self Wait_to_clear
}
----

==== WAITING FOR REQUESTS TO CLEAR

(((Activity,Transfer,WAITING FOR REQUESTS TO CLEAR)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state WAITING_FOR_REQUESTS_TO_CLEAR {} {
}
----

==== Delete

(((Activity,Transfer,Delete)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Transfer completed -> /R53/R2/Shaft

state Delete {} {
    set shaft [findRelated $self ~R53 R2]
    signal $shaft Transfer_complete
}

terminal Delete
----

=== Floor Service State Activities

==== WAITING FOR CABIN

(((Activity,Floor Service,WAITING FOR CABIN)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
state WAITING_FOR_CABIN {} {
}
----

==== HOLDING SERVICE DIRECTION

(((Activity,Floor Service,HOLDING SERVICE DIRECTION)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
state HOLDING_SERVICE_DIRECTION {} {
}
----

==== COMPLETED

(((Activity,Floor Service,COMPLETED)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
# Serviced floor request( dir: Direction ) -> /R49/Accessible Shaft Level

state COMPLETED {} {
    set aslev [findRelated $self R49]
    signal $aslev Serviced_floor_request [readAttribute $self Direction]
}
----

==== Check bank level type

(((Activity,Floor Service,Check bank level type)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
# if (/R49/R38/Middle Bank Level)
#   Middle floor -> me
# else
#   Top or bottom floor -> me

state Check_bank_level_type {} {
    set bl [findRelated $self ~R49 {~R38 Middle_Bank_Level}]
    if {[isNotEmptyRef $bl]} {
        signal $self Middle_floor
    } else {
        signal $self Top_or_bottom_floor
    }
}
----

=== Accessible Shaft Level State Activities

==== NOT REQUESTED

(((Activity,Accessible Shaft Level,NOT REQUESTED)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
state NOT_REQUESTED {} {
}
----

==== REQUESTED

(((Activity,Accessible Shaft Level,REQUESTED)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
state REQUESTED {} {
}
----

==== Registering Stop

(((Activity,Accessible Shaft Level,Registering Stop)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# Stop requested.set
# Stop registered -> me

state Registering_stop {} {
    updateAttribute $self Stop_requested true
    signal $self Stop_registered
}
----

==== Registering floor call

(((Activity,Accessible Shaft Level,Registering floor call)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# Bank Level( Bank, Floor ) &R49 Accessible Shaft
# Level( Shaft, Floor ) & Floor Service( Direction: in.dir )
# Floor call registered -> me

state Registering_floor_call {dir} {
    set bank_level [findRelated $self R3]
    R49 link $bank_level $self Direction $dir ; # creates Floor_Service instance
    signal $self Floor_call_registered
}
----

==== Requesting service

(((Activity,Accessible Shaft Level,Requesting service)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# Service requested -> R53(Shaft)
# Wait for service -> me

state Requesting_service {} {
    R53 signal [list ID [readAttribute $self Shaft]] Service_requested
    signal $self Wait_for_service
}
----

==== Clear floor request

(((Activity,Accessible Shaft Level,Clear floor request)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# Clear floor request( in.dir ) -> /R49/Bank Level
# !* /R49/Floor Service( Direction: in.dir )
# Check stop request -> me

state Clear_floor_request {dir} {
    set bank_level [findRelated $self ~R49]
    signal $bank_level Clear_floor_request $dir
    set floor_service [findRelatedWhere $self {{~R49 Floor_Service}}\
            {$Direction eq $dir}]
    delete $floor_service
    signal $self Check_stop_request
}
----

==== Clear stop request

(((Activity,Accessible Shaft Level,Clear stop request)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# // Clear the stop request if registered
# if (Stop requested) {
#   UI.Clear stop request( Floor, Shaft )
#   Stop requested.unset
# }
# if /R49/Floor Service
#   Opposite floor call pending -> me
# else
#   All requests cleared -> me
#
# Requests cleared -> /R53/Transfer

state Clear_stop_request {} {
    if {[readAttribute $self Stop_requested]} {
        assignAttribute $self Floor Shaft
        UI::Clear_stop_request $Floor $Shaft
        updateAttribute $self Stop_requested false
    }

    set floor_service [findRelat4ed $self {~R49 Floor_Service}]
    if {[isNotEmptyRef $floor_service]} {
        signal $self Opposite_floor_call_pending
    } else {
        signal $self All_requests_cleared
    }

    set xfer [findRelated $self {~R53 Transfer}]
    signal $xfer Requests_cleared
}
----

=== R53 Assigner State Activities

==== NO TRANSFER

(((Activity,R53 Assigner,NO TRANSFER)))
(((chunk,R53 state model definition)))
[source,tcl]
----
<<R53 state model definition>>=
state NO_TRANSFER {} {
}
----

==== Searching for new destination

(((Activity,R53 Assigner,Searching for new destination)))
(((chunk,R53 state model definition)))
[source,tcl]
----
<<R53 state model definition>>=
# // My Cabin is stationary and has no Transfer at the moment
# destination aslev .= /Shaft/R2/Cabin.Ping_both_ways()
# if (destination aslev) {
#     Execute -> /Shaft/Cabin &R53 destination aslev & *Transfer
#     Transfer created -> me
# } else
#     No destination -> me

state Searching_for_new_destination {} {
    set shaftRef [idInstance $self]
    set cabin [findRelated $shaftRef ~R2]
    set destination_aslev [instop $cabin Ping_both_ways]
    if {[isNotEmptyRef $destination_aslev]} {
        set xfer [Transfer create\
                Destination_floor [readAttribute $destination_aslev Floor]\
                Shaft [readAttribute $shaftRef ID]]
        signal $xfer Execute
        signal $self Transfer_created
    } else {
        signal $self No_destination
    }
}
----

==== TRANSFER IN PROGRESS

(((Activity,R53 Assigner,TRANSFER IN PROGRESS)))
(((chunk,R53 state model definition)))
[source,tcl]
----
<<R53 state model definition>>=
state TRANSFER_IN_PROGRESS {} {
}
----

=== Searching for alternate destination

(((Activity,R53 Assigner,Searching for alternate destination)))
(((chunk,R53 state model definition)))
[source,tcl]
----
<<R53 state model definition>>=
# my cabin .= /Shaft/R2/Cabin
# xfer .= my cabin/R53/Transfer
# call in progress .= xfer/R49/Floor Service( Direction: Travel direction )
# fwd dest .= my cabin.Ping( dir: Travel direction )
# if (fwd dest)
#     destination aslev .= fwd dest
# else if (not call in progress) {
#     // Search opposite the travel direction only if not servicing
#     // a floor request in the current direction
#     rev dest .= my cabin.Ping( dir: Travel direction.opposite )
#     if (rev dest)
#         my cabin.Travel direction.toggle
#     destination aslev .= rev dest // may be empty
# }
# if (destination aslev and destination aslev.Floor != xfer.Destination floor )
#     Dest change request( new dest: destination aslev.floor ) -> xfer
# Dest change evaluated -> me

state Searching_for_alternate_destination {} {
    set my_cabin [pipe {
        idInstance $self |
        findRelated % ~R2
    } {} |%]
    set xfer [findRelated $my_cabin {R53 Transfer}]
    assignAttribute $my_cabin Travel_direction
    set call_in_progress [findRelated $xfer {R53 {~R49 Floor_Service}}\
            {$Direction eq $Travel_direction}]
    set fwd_dest [instop $my_cabin Ping $Travel_direction]
    if {[isNotEmptyRef $fwd_dest]} {
        set destination_aslev $fwd_dest
    } elseif {[isEmptyRef $call_in_progress]} {
        set opposite_dir [expr {$Travel_direction eq "up" ? "down" : "up"}]
        set rev_dest [instop $my_cabin Ping $opposite_dir]
        if {[isNotEmptyRef $rev_dest]} {
            updateAttribute $my_cabin Travel_direction $opposite_dir
        }
        set destination_aslev $rev_dest
    }

    if {[isNotEmptyRef $destination_aslev] &&\
            [readAttribute $destination_aslev Floor] ne\
            [readAttribute $xfer Destination_floor]} {
        signal $xfer\
                Dest_change_request [readAttribute $destination_aslev Floor]
    }

    signal $self Dest_change_evaluated
}
----

=== Bank Level Class Methods

==== Choose shaft

(((Method,Bank Level,Choose shaft)))
(((chunk,Bank Level operations definition)))
[source,tcl]
----
<<Bank Level operations definition>>=
# // Bank Level.Choose shaft( calling floor : Level Name,
#   service dir: Direction ) : Shaft ID

# // Invokes the Estimate delay method on all related instances of Cabin and
# // returns the Shaft ID of the one with the shortest delay

# // Scrall: The 1, in the restriction clause selects at most one
# =>> /R29/R1/R2/Shaft/Cabin(1, ^-Estimate delay( calling floor: Floor,
#   in.service dir ) ).Shaft

# // A Bank must have at least one Cabin (R1/R2) and each Cabin will report some
# // delay value, so a single Shaft value will always be returned

instop Choose_shaft {calling_floor service_dir} {
    set cabins [findRelated $self ~R29 ~R1 ~R2]
    return [pipe {
        deRef $cabins |
        relation extend ~ dtup Delay double {
            [instop\
                [toRef Cabin [tuple relation [tuple project $dtup Shaft]]]\
                Estimate_delay $calling_floor $service_dir]
        } |
        relation rank ~ -ascending Delay DelayRank |
        relation restrictwith ~ {$DelayRank == 1} |
        relation tag ~ DelayTag |
        relation restrictwith ~ {$DelayTag == 0} |
        relation extract ~ Shaft
    }]
}
----

==== Clear floor request

(((Method,Bank Level,Clear floor request)))
(((chunk,Bank Level operations definition)))
[source,tcl]
----
<<Bank Level operations definition>>=
# // Bank Level.Clear floor request( dir: Direction )

# // The subclass calling up/down request is cleared and the UI is notified.

# // Scrall: the system defined _<class>_subclass variable is generated for
# // each superclass as an enumeration of all subclass names

# case ( _subclass name ) {
#     .Top Bank Level:
#         if (in.dir : .down)
#             /R38/Top Bank Level.Calling down.unset
#     .Bottom Bank Level:
#         if (in.dir : .up)
#             /R38/Bottom Bank Level.Calling up.unset
#     .Middle Bank Level:
#         case ( in.dir ) {
#             .up: /R38/Middle Bank Level.Calling up.unset
#             .down: /R38/Middle Bank Level.Calling down.unset
#         }
# }

# UI.Clear floor request( Bank, Floor, in.dir )

instop Clear_floor_request {dir} {
    instop $self Set_calling_direction $dir false
    assignAttribute $self
    UI::Clear_floor_request $Bank $Floor $dir
}
----

==== Floor request

(((Method,Bank Level,Floor request)))
(((chunk,Bank Level operations definition)))
[source,tcl]
----
<<Bank Level operations definition>>=
# // Bank Level.Floor request( dir: Direction ) : Boolean

# // The associated subclass calling up/down attribute is set to register an up
# // or down call.  If floor was not already calling the Shaft most likely to
# // provide the quickest service is chosen and the associated Accessible Shaft
# // Level is notified.  Success is returned if the floor was not already
# // registered as calling in the requested service direction.

# // Scrall: If a path from a superclass instance to a generalization
# // relationship appears in a case statement, an enumerated type is generated
# // with a value for each subclass name. Also, the "." symbol represents the
# // superclass instance for any path expressions inside the case block.

# case ( /R38 ) {
#     .Top Bank Level:
#         if (in.dir == .down)
#             /R38/Top Bank Level.Calling down.set
#         else
#             [error]
#     .Bottom Bank Level:
#         if (in.dir == .up)
#             /R38/Bottom Bank Level.Calling up.set
#         else
#             [error]
#     .Middle Bank Level:
#         case ( in.dir ) {
#             .up: /R38/Middle Bank Level.Calling up.set
#             .down: /R38/Middle Bank Level.Calling down.set
#         }
# }

# [!error] {
#     // Notify the Accessible Shaft Level so that it can request service
#     Floor calling( in.dir ) -> 
#         Accessible Shaft Level (Bank, Floor,
#             Shaft: Choose shaft( calling floor: Floor, service dir: in.dir ) )
#     =>> true
# }

# [error] =>> false

instop Floor_request {dir} {
    set didSetDir [instop $self Set_calling_direction $dir true]
    if {$didSetDir} {
        assignAttribute $self {Bank myBank} {Floor myFloor}
        set shaft [instop $self Choose_shaft $myFloor $dir]
        set aslev [Accessible_Shaft_Level findWhere\
            {$Bank eq $myBank && $Floor eq $myFloor && $Shaft eq $shaft}]
        signal $aslev Floor_calling $dir
    }

    return $didSetDir
}
----

==== Set calling direction

This class method contains common code factored from the Clear floor request
and Floor request methods.

(((Method,Bank Level,Set calling direction)))
(((chunk,Bank Level operations definition)))
[source,tcl]
----
<<Bank Level operations definition>>=
# This is common code between Floor request and Clear floor request
# factored into an instance operation.

instop Set_calling_direction {dir value} {
    set top [findRelated $self {~R38 Top_Bank_Level}]
    if {[isNotEmptyRef $top]} {
        if {$dir eq "down"} {
            updateAttribute $top Calling_down true
            return true
        } else {
            return false
        }
    }

    set bottom [findRelated $self {~R38 Bottom_Bank_Level}]
    if {[isNotEmptyRef $bottom]} {
        if {$dir eq "up"} {
            updateAttribute $bottom Calling_up $value
            return true
        } else {
            return false
        }
    }

    set middle [findRelated $self {~R38 Middle_Bank_Level}]
    if {[isNotEmptyRef $middle]} {
        switch -exact -- $dir {
            up {
                updateAttribute $middle Calling_up $value
            }
            down {
                updateAttribute $middle Calling_down $value
            }
            default {
                error "unknown direction, \"$dir\""
            }
        }
        return true
    }

    return false
}
----

== Domain Operations [[domain-operations,Domain Operations]]

=== Arrived at floor

(((Domain Operations,Arrived at floor)))
(((chunk,domain operations)))
[source,tcl]
----
<<domain operations>>=
# //
# // ELEV.Arrived at floor( cabin : Nominal )
# //
# // The Transport domain has delivered a Cabin to its destination
# // Send the appropriate event to the Cabin instance

# Arrived at floor -> Cabin( Shaft : in.cabin )

operation Arrived_at_floor {cabin} {
    signal [Cabin findById Shaft $cabin] Arrived_at_floor
}
----

=== Floor request

(((Domain Operations,Floor request)))
(((chunk,domain operations)))
[source,tcl]
----
<<domain operations>>=
# //
# // ELEV.Floor request( bank : Name, floor : Ordinal, dir : Direction ) :
# //      ( new direction : Boolean, found : Boolean)

# HERE !! -- perplexed as to why floor is ordinal? Bank Level.Floor is
# of type Level Name

# // Registers a floor service request and returns the success status

# blev .= Bank Level( in.bank, in.floor )
# if (blev)
#     =>> ( new direction: blev.Floor request( in.dir ), Found: true )
# else
#     =>> ( new direction: false, found: false )

operation Floor_request {bank floor dir} {
    set blev [Bank_Level findById Bank $bank Floor $floor]
    if {[isNotEmptyRef $blev]} {
        set new_direction [instop $blev Floor_request $dir]
        set found true
    } else {
        set new_direction false
        set found false
    }

    return [list $new_direction $found]
}
----

=== Hold door open

(((Domain Operations,Hold door open)))
(((chunk,domain operations)))
[source,tcl]
----
<<domain operations>>=
# //
# // ELEV.Hold door open( shaft : Nominal ) : Boolean

# // Sets the requested Door's held status. Returns false if the
# // Door is not found.

# d .= Door( in.shaft )
# if (d) {
#     d.Held.set
#     =>> true
# } else
#     =>> false

operation Hold_door_open {shaft} {
    set d [Door findById Shaft $shaft]
    if {[isNotEmptyRef $d]} {
        updateAttribute $d Held true
        return true
    } else {
        return false
    }
}
----

=== Release door hold

(((Domain Operations,Release door hold)))
(((chunk,domain operations)))
[source,tcl]
----
<<domain operations>>=
# // ELEV.Release door hold( shaft : Nominal ) : Boolean

# // Clears the requested Door's held status. Returns false if the 
# // Door is not found.

# d .= Door( in.shaft )
# if (d) {
#     d.Held.unset
#     =>> true
# } else
#     =>> false

operation Release_door_hold {shaft} {
    set d [Door findById Shaft $shaft]
    if {[isNotEmptyRef $d]} {
        updateAttribute $d Held false
        return true
    } else {
        return false
    }
}
----

=== Stop request

(((Domain Operations,Stop request)))
(((chunk,domain operations)))
[source,tcl]
----
<<domain operations>>=
# // ELEV.Stop request( shaft : Nominal, floor : Name ) : Boolean

# // Registers a stop request at a Shaft Level. Returns false if the 
# // Shaft Level is not accessible or does not exist.

# Stop requested -> Accessible Shaft Level( in.shaft, in.floor )
# [empty] =>> false
# [!empty] =>> true

operation Stop_request {shaft floor} {
    set aslev [Accessible_Shaft_Level findById Shaft $shaft Floor $floor]
    signal $aslev Stop_request
    return [isNotEmptyRef $aslev]
}
----

=== Update location

(((Domain Operations,Update location)))
(((chunk,domain operations)))
[source,tcl]
----
<<domain operations>>=
# // ELEV.Update location( shaft : Nominal, floor: Level Name )

# // The Transport domain has moved the Cabin past the specified floor
# // Calls the associated cabin method

# Cabin( in.shaft ).Update location( new location: in.floor )

operation Update_location {shaft floor} {
    set cabin [Cabin findById Shaft $shaft]
    instop $cabin Update_location $floor
}
----

== External Entities [[external-entities,External Entities]]

=== SIO

==== Open door

(((External Entity,SIO,Open door)))
(((chunk,sio external entity)))
[source,tcl]
----
<<sio external entity>>=
proc Open_door {shaft} {
    chan puts "SIO::Open_door $shaft"
}
----

==== Close door

(((External Entity,SIO,Close door)))
(((chunk,sio external entity)))
[source,tcl]
----
<<sio external entity>>=
proc Close_door {shaft} {
    chan puts "SIO::Close_door $shaft"
}
----

=== UI

==== Door opening

(((External Entity,UI,Door opening)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_opening {shaft} {
    chan puts "UI::Door_opening $shaft"
}
----

==== Door opened

(((External Entity,UI,Door opened)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_opened {shaft} {
    chan puts "UI::Door_opened $shaft"
}
----

==== Door closing

(((External Entity,UI,Door closing)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_closing {shaft} {
    chan puts "UI::Door_closing $shaft"
}
----

==== Door closed

(((External Entity,UI,Door closed)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_closed {shaft} {
    chan puts "UI::Door_closed $shaft"
}
----

==== Set destination

(((External Entity,UI,Set destination)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Set_destination {shaft floor} {
    chan puts "UI::Set_destination $shaft $floor"
}
----

==== Clear floor request

(((External Entity,UI,Clear floor request)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Clear_floor_request {bank floor shaft} {
    chan puts "UI::Clear_floor_request $bank $floor $shaft"
}
----

==== Clear stop request

(((External Entity,UI,Clear stop request)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Clear_stop_request {floor shaft} {
    chan puts "UI::Clear_stop_request $floor $shaft"
}
----

==== New location

(((External Entity,UI,New location)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc New_location {shaft floor} {
    chan puts "UI::New_location $shaft $floor"
}
----

=== TRAN

==== Goto floor

(((External Entity,TRAN,Goto floor)))
(((chunk,tran external entity)))
[source,tcl]
----
<<tran external entity>>=
proc Goto_floor {floor shaft} {
    chan puts "TRAN::Goto_floor $floor $shaft"
    return true
}
----

== Code Organization [[codeorganization,Code Organization]]

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

(((chunk,copyright info)))
[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2017 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

(((chunk,elevator.tcl)))
[source,tcl]
----
<<elevator.tcl>>=
<<copyright info>>

package require Tcl 8.6
package require rosea 1.6

rosea configure {
    domain elevator {
        <<domain operations>>
        <<Accessible Shaft Level class definition>>
        <<Bank class definition>>
        <<Building class definition>>
        <<Cabin class definition>>
        <<Door class definition>>
        <<Floor class definition>>
        <<Floor Service class definition>>
        <<Bank Level class definition>>
        <<Top Bank Level class definition>>
        <<Middle Bank Level class definition>>
        <<Bottom Bank Level class definition>>
        <<Shaft class definition>>
        <<Shaft Level class definition>>
        <<Transfer class definition>>
        <<R53 assigner definition>>
        <<relationship definitions>>
    }
}

rosea generate elevator

rosea populate {
    domain elevator {
        <<elevator population>>
    }
}

namespace eval ::elevator {
    proc toRef {relvar relvalue} {
        tailcall ::rosea::Helpers::ToRef ::elevator::$relvar $relvalue
    }
}

namespace eval ::elevator::SIO {
    <<sio external entity>>
}

namespace eval ::elevator::UI {
    <<ui external entity>>
}

namespace eval ::elevator::TRAN {
    <<tran external entity>>
}
----

(((chunk,elevator_main.tcl)))

[source,tcl]
----
<<elevator_main.tcl>>=
<<copyright info>>

source elevator.tcl

package require comm
comm::comm configure -port 50000

chan puts "listening at port [comm::comm configure -port]"

vwait forever
after 1000
exit
----

(((chunk,Accessible Shaft Level class definition)))
[source,tcl]
----
<<Accessible Shaft Level class definition>>=
class Accessible_Shaft_Level {
    <<Accessible Shaft Level attribute definition>>
    statemodel {
        <<Accessible Shaft Level state model definition>>
    }
}
----

(((chunk,Bank class definition)))
[source,tcl]
----
<<Bank class definition>>=
class Bank {
    <<Bank attribute definition>>
}
----

(((chunk,Building class definition)))
[source,tcl]
----
<<Building class definition>>=
class Building {
    <<Building attribute definition>>
}
----

(((chunk,Cabin class definition)))
[source,tcl]
----
<<Cabin class definition>>=
class Cabin {
    <<Cabin attribute definition>>
    <<Cabin operations definition>>
    statemodel {
        <<Cabin state model definition>>
    }
}
----

(((chunk,Door class definition)))
[source,tcl]
----
<<Door class definition>>=
class Door {
    <<Door attribute definition>>
    statemodel {
        <<Door state model definition>>
    }
}
----

(((chunk,Floor class definition)))
[source,tcl]
----
<<Floor class definition>>=
class Floor {
    <<Floor attribute definition>>
}
----

(((chunk,Floor Service class definition)))
[source,tcl]
----
<<Floor Service class definition>>=
class Floor_Service {
    <<Floor Service attribute definition>>
    statemodel {
        <<Floor Service state model definition>>
    }
}
----

(((chunk,Bank Level class definition)))
[source,tcl]
----
<<Bank Level class definition>>=
class Bank_Level {
    <<Bank Level attribute definition>>
    <<Bank Level operations definition>>
}
----

(((chunk,Top Bank Level class definition)))
[source,tcl]
----
<<Top Bank Level class definition>>=
class Top_Bank_Level {
    <<Top Bank Level attribute definition>>
}
----

(((chunk,Middle Bank Level class definition)))
[source,tcl]
----
<<Middle Bank Level class definition>>=
class Middle_Bank_Level {
    <<Middle Bank Level attribute definition>>
}
----

(((chunk,Bottom Bank Level class definition)))
[source,tcl]
----
<<Bottom Bank Level class definition>>=
class Bottom_Bank_Level {
    <<Bottom Bank Level attribute definition>>
}
----

(((chunk,Shaft class definition)))
[source,tcl]
----
<<Shaft class definition>>=
class Shaft {
    <<Shaft attribute definition>>
}
----

(((chunk,Shaft Level class definition)))
[source,tcl]
----
<<Shaft Level class definition>>=
class Shaft_Level {
    <<Shaft Level attribute definition>>
}
----

(((chunk,Transfer class definition)))
[source,tcl]
----
<<Transfer class definition>>=
class Transfer {
    <<Transfer attribute definition>>
    statemodel {
        <<Transfer state model definition>>
    }
}
----

(((chunk,R53 assigner definition)))
[source,tcl]
----
<<R53 assigner definition>>=
assigner R53 {
    identifyby Shaft

    <<R53 state model definition>>
}
----

/////

=== XX Class [[xxclass,XX]]

(((Ordering,Classes,XX)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,Relationships,RR)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,State Model,XX)))
[source,tcl]
----
<<XX State Model>>=
----
/////

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
