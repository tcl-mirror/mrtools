// vim:set syntax=asciidoc:
= Translating the Elevator Model

== Introduction [[introduction,Introduction]]

This document presents a translation of

This document is also a
http://www.literateprogramming.com[literate program].
It contains all the code of the translation and the execution scenarios
that exercise the program.
The literate program source and all the output is available at the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools[Model Realization]
web site.


=== How to Read This Document [[howtoreadthisdocument,How to Read This Document]]

How to Read This Document

== Model Details [[modeldetails,Model Details]]

Model Details

== Translation Conventions [[translationconventions,Translation Conventions]]

Translation Conventions

== Data Types [[datatypes,Data Types]]

`Rosea` requires attributes to be given an data type.
That data type is, of course, an implementation data type and must
be one of the Tcl data types supported by TclRAL.
It may seem strange to discuss types in a dynamically typed language such
as Tcl where, at the script level, all values have a string representation.
Tcl uses a form of _duck typing_.
Values are converted to the type required by the operation and should they
fail to be converted an error is thrown.
In Tcl, `string` is the universal type.
Attributes with types other than string will be converted to that type
when they are updated into an instance.
This is an integrity check.
If you declare an attribute as `int`, then whatever value you assign to
the attribute must be convertable to an int because presumably you
intend to perform some arithmetic on the value.
`Rosea` prevent assignment of values to attributes that cannot possibly
be converted to the correct type.

That said,
data types like `int` are usually too permissive.
It is usually a subset of values of the type that are desired.
`Rosea` does allow an expression to be evaluated on an attribute value
as a check that it is reasonable.
We will use this feature in several situations.

Comments on the mapping of domain data types to implementation data types
are given below.

== Translating the Data Model [[translating-data-model]]

=== Accessible Shaft Level Class [[accessible-shaft-level-class,Accessible Shaft Level]]

(((Data Model,Class,Accessible Shaft Level)))
(((chunk,Accessible Shaft Level attribute definition)))
[source,tcl]
----
<<Accessible Shaft Level attribute definition>>=
attribute Floor int -id 1
attribute Shaft string -id 1
attribute Bank string
attribute Stop_requested boolean -default false

reference R3 Shaft_Level -link Floor -link Shaft
reference R3 Bank_Level -link Floor -link Bank
----

=== R3

(((Data Model,Relationship,R3)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R3 Shaft_Level 1..*--0..1 Bank_Level\
        -associator Accessible_Shaft_Level
----

=== Bank Class [[bank-class,Bank]]

(((Data Model,Class,Bank)))
(((chunk,Bank attribute definition)))
[source,tcl]
----
<<Bank attribute definition>>=
attribute Name string -id 1
attribute Passenger_load_time int -default 5000
attribute Block_clear_time int -default 5000
attribute Max_close_attempts int -default 3
attribute Avg_cabin_speed double -default 1.0
attribute Avg_stop_duration int -default 10
----

=== Bank Level Class [[bank-level-class,Bank Level]]

(((Data Model,Class,Bank Level)))
(((chunk,Bank Level attribute definition)))
[source,tcl]
----
<<Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1

reference R29 Bank -link {Bank Name}
reference R29 Floor -refid 2 -link {Floor Number}           ; # <1>
----
<1> Note that the Number attribute of Floor is a secondary identifier
and we must state that as part of the reference.

=== R29

(((Data Model,Relationship,R29)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R29 Bank 0..*--1..* Floor -associator Bank_Level
----

=== R38

(((Data Model,Relationship,R38)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
generalization R38 Bank_Level\
        Top_Bank_Level Middle_Bank_Level Bottom_Bank_Level
----

=== Building Class [[building-class,Building]]

(((Data Model,Class,Building)))
(((chunk,Building attribute definition)))
[source,tcl]
----
<<Building attribute definition>>=
attribute Name string -id 1
attribute Average_floor_gap double
----

=== Cabin Class [[cabin-class,Cabin]]

(((Data Model,Class,Cabin)))
(((chunk,Cabin attribute definition)))
[source,tcl]
----
<<Cabin attribute definition>>=
attribute Shaft string -id 1
attribute Travel_direction string -check {$Travel_direction in {up down}}
attribute Current_floor int

reference R2 Shaft -link {Shaft ID}
reference R43 Shaft_Level -link Shaft -link {Current_floor Floor}
----

=== R2

(((Data Model,Relationship,R2)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R2 Cabin 1--1 Shaft
----

=== R43

(((Data Model,Relationship,R43)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R43 Cabin 0..*--1 Shaft_Level
----

=== Door Class [[door-class,Door]]

(((Data Model,Class,Door)))
(((chunk,Door attribute definition)))
[source,tcl]
----
<<Door attribute definition>>=
attribute Shaft string -id 1
attribute Close_attempts_remaining int -default 5
attribute Open_wait_time int -default 1000
attribute Lock_requested boolean -default false
attribute Held boolean -default false
attribute Emergency_hold boolean -default false

reference R4 Cabin -link Shaft
----

=== R4

(((Data Model,Relationship,R4)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R4 Door 1--1 Cabin
----

=== Floor Class [[floor-class,Floor]]

(((Data Model,Class,Floor)))
(((chunk,Floor attribute definition)))
[source,tcl]
----
<<Floor attribute definition>>=
attribute Name string -id 1
attribute Number int -id 2
attribute Height double
----

=== Floor Service Class [[floor-service-class,Floor Service]]

(((Data Model,Class,Floor Service)))
(((chunk,Floor Service attribute definition)))
[source,tcl]
----
<<Floor Service attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1
attribute Shaft string -id 1
attribute Direction string -check {$Direction in {up down}}

reference R49 Bank_Level -link Bank -link Floor
reference R49 Accessible_Shaft_Level -link Floor -link Shaft
----

=== R49

(((Data Model,Relationship,R49)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R49 Bank_Level 0..*--0..* Accessible_Shaft_Level\
        -associator Floor_Service
----

=== Top Bank Level Class [[top-bank-level-class,Top Bank Level]]

(((Data Model,Class,Top Bank Level)))
(((chunk,Top Bank Level attribute definition)))
[source,tcl]
----
<<Top Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1
attribute Calling_down boolean -default false

reference R38 Bank_Level -link Bank -link Floor
reference R5 Bank -link {Bank Name}
----

=== R5

(((Data Model,Relationship,R5)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R5 Top_Bank_Level 1--1 Bank
----

=== Middle Bank Level Class [[middle-bank-level-class,Middle Bank Level]]

(((Data Model,Class,Middle Bank Level)))
(((chunk,Middle Bank Level attribute definition)))
[source,tcl]
----
<<Middle Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1
attribute Calling_up boolean -default false
attribute Calling_down boolean -default false

reference R38 Bank_Level -link Bank -link Floor
----

=== Bottom Bank Level Class [[bottom-bank-level-class,Bottom Bank Level]]

(((Data Model,Class,Bottom Bank Level)))
(((chunk,Bottom Bank Level attribute definition)))
[source,tcl]
----
<<Bottom Bank Level attribute definition>>=
attribute Bank string -id 1
attribute Floor int -id 1
attribute Calling_up boolean -default false

reference R38 Bank_Level -link Bank -link Floor
reference R6 Bank -link {Bank Name}
----

=== R6

(((Data Model,Relationship,R6)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R6 Bottom_Bank_Level 1--1 Bank
----

=== Shaft Class [[shaft-class,Shaft]]

(((Data Model,Class,Shaft)))
(((chunk,Shaft attribute definition)))
[source,tcl]
----
<<Shaft attribute definition>>=
attribute ID string -id 1
attribute Bank string
attribute In_service boolean -default true

reference R1 Bank -link {Bank Name}
----

=== R1

(((Data Model,Relationship,R1)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R1 Shaft 1..*--1 Bank
----

=== Shaft Level Class [[shaft-level-class,Shaft Level]]

(((Data Model,Class,Shaft Level)))
(((chunk,Shaft Level attribute definition)))
[source,tcl]
----
<<Shaft Level attribute definition>>=
attribute Floor int -id 1
attribute Shaft string -id 1

reference R28 Floor -link {Floor Number} -refid 2
reference R28 Shaft -link {Shaft ID}
----

=== R28

(((Data Model,Relationship,R28)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R28 Shaft 1..*--1..* Floor -associator Shaft_Level
----

=== Transfer Class [[transfer-class,Transfer]]

(((Data Model,Class,Transfer)))
(((chunk,Transfer attribute definition)))
[source,tcl]
----
<<Transfer attribute definition>>=
attribute Destination_floor int -id 1
attribute Shaft string -id 1

reference R53 Cabin -link Shaft
reference R53 Accessible_Shaft_Level -link {Destination_floor Floor} -link Shaft
----

=== R53

(((Data Model,Relationship,R53)))
(((chunk,relationship definitions)))
[source,tcl]
----
<<relationship definitions>>=
association R53 Cabin 0..1--0..1 Accessible_Shaft_Level -associator Transfer
----

== Population [[population]]

Population

(((chunk,elevator population)))
[source,tcl]
----
<<elevator population>>=
class Building {
    Name        Average_floor_gap} {
    Acme        5.0
}

class Bank {
    Name} {
    B1
}

class Floor {
    Name            Number          Height} {
    F1              1               5.0
    F2              2               5.0
    F3              3               5.0
}

class Bank_Level {
    Bank            Floor} {
    B1              1
    B1              2
    B1              3
}

class Top_Bank_Level {
    Bank            Floor} {
    B1              3
}

class Middle_Bank_Level {
    Bank            Floor} {
    B1              2
}

class Bottom_Bank_Level {
    Bank            Floor} {
    B1              1
}

class Shaft {
    ID          Bank} {
    S1          B1
}

class Shaft_Level {
    Floor           Shaft} {
    1               S1
    2               S1
    3               S1
}

class Accessible_Shaft_Level {
    Floor           Shaft           Bank} {
    1               S1              B1
    2               S1              B1
    3               S1              B1
}

class Cabin {
    Shaft           Travel_direction    Current_floor} {
    S1              up                  1
}

class Door {
    Shaft} {
    S1
}
----

== Translating the State Models [[translating-state-models]]

=== Accessible Shaft Level State Model [[accessible-shaft-level-state-model]]

(((Dynamics Model,State Model,Accessible Shaft Level)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
initialstate NOT_REQUESTED
defaulttrans CH

transition NOT_REQUESTED - Stop_request -> Registering_stop
transition NOT_REQUESTED - Floor_calling -> Registering_floor_call

transition REQUESTED - Stop_request -> Registering_stop
transition REQUESTED - Floor_calling -> Registering_floor_call
transition REQUESTED - Stop_serviced -> Clear_stop_request
transition REQUESTED - Serviced_floor_request -> Clear_floor_request

transition Registering_stop - Stop_registered -> Requesting_service

transition Registering_floor_call - Floor_call_registered -> Requesting_service

transition Requesting_service - Wait_for_service -> REQUESTED

transition Clear_floor_request - Check_stop_request -> Clear_stop_request

transition Clear_stop_request - All_requested_cleared -> NOT_REQUESTED
transition Clear_stop_request - Opposite_floor_call_pending -> REQUESTED
----

=== Floor Service State Model [[floor-service-state-model]]

(((Dynamics Model,State Model,Floor Service)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
initialstate WAITING_FOR_CABIN
defaulttrans CH

transition WAITING_FOR_CABIN - Cabin_arrived -> Check_bank_level_type

transition REJECT_REQUESTS_OPPOSITE_REQUESTED_SERVICE_DIR - Cancel -> COMPLETED

transition Check_bank_level_type - Middle_floor ->\
        REJECT_REQUESTS_OPPOSITE_REQUESTED_SERVICE_DIR
transition Check_bank_level_type - Top_or_bottom_floor -> COMPLETED
----

=== Shaft State Model [[shaft-state-model]]

(((Dynamics Model,State Model,Shaft)))
(((chunk,Shaft state model definition)))
[source,tcl]
----
<<Shaft state model definition>>=
initialstate WAITING_FOR_STOP_OR_CALL_REQUEST
defaulttrans CH

transition WAITING_FOR_STOP_OR_CALL_REQUEST - Transfer_competed ->\
        Searching_for_best_destination
transition WAITING_FOR_STOP_OR_CALL_REQUEST - Service_requested ->\
        Searching_for_best_destination
transition WAITING_FOR_STOP_OR_CALL_REQUEST - Take_out_of_service ->\
        CANCELING_TRANSFER

transition Searching_for_best_destination - No_destination ->\
        WAITING_FOR_STOP_OR_CALL_REQUEST
transition Searching_for_best_destination - Create_transfer ->\
        Creating_or_updating_transfer

transition Creating_or_updating_transfer - Transfer_requested ->\
    WAITING_FOR_STOP_OR_CALL_REQUEST

transition CANCELING_TRANSFER - No_transfer_in_progress -> OUT_OF_SERVICE
transition CANCELING_TRANSFER - Transfer_completed -> OUT_OF_SERVICE
----

=== Transfer State Model [[transfer-state-model]]

(((Dynamics Model,State Model,Transfer)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
initialstate CREATED
defaulttrans CH

transition CREATED - Execute -> Creating_or_updating_transfer
transition CREATED - Door_closed -> IG

transition WAITING_FOR_CABIN - Destination_change_request ->\
        Changing_destination_before_cabin_moves
transition WAITING_FOR_CABIN - Ready_to_move -> Dispatching_cabin
transition WAITING_FOR_CABIN - Door_closed -> IG

transition CABIN_IN_MOTION - Destination_change_request -> Request_redirect
transition CABIN_IN_MOTION - Cabin_redirected -> Match_new_destination_of_cabin
transition CABIN_IN_MOTION - Cabin_at_destination ->\
        Check_for_active_floor_service

transition CALL_IN_PROGRESS - Destination_change_request -> IG
transition CALL_IN_PROGRESS - Door_closed -> Canceling_floor_service

transition WAITING_FOR_REQUESTS_TO_CLEAR - Destination_change_request -> IG
transition WAITING_FOR_REQUESTS_TO_CLEAR - Door_closed -> IG
transition WAITING_FOR_REQUESTS_TO_CLEAR - Requests_cleared -> Delete

transition Creating_or_updating_transfer - Wait_for_cabin -> WAITING_FOR_CABIN

transition Changing_destination_before_cabin_moves - Stationary_update ->\
        WAITING_FOR_CABIN

transition Dispatching_cabin - Cabin_dispatched -> CABIN_IN_MOTION

transition Request_redirect -> Redirect_requested -> CABIN_IN_MOTION

transition Match_new_destination_of_cabin - Update_in_motion -> CABIN_IN_MOTION

transition Check_for_active_floor_service - Call_in_progress -> CALL_IN_PROGRESS
transition Check_for_active_floor_service - Wait_to_clear ->\
        WAITING_FOR_REQUESTS_TO_CLEAR

transition Canceling_floor_service - Wait_to_clear ->\
        WAITING_FOR_REQUESTS_TO_CLEAR
----

=== Cabin State Model [[cabin-state-model]]

(((Dynamics Model,State Model,Cabin)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
initialstate TRANSFERRING_PASSENGERS
defaulttrans CH

transition MOVING - Try_redirect -> Changing_destination
transition MOVING - Arrived_at_floor -> TRANSFERRING_PASSENGERS
transition MOVING - Take_out_of_service -> EMERGENCY_BRAKING

transition TRANSFERRING_PASSENGERS - Try_redirect -> IG
transition TRANSFERRING_PASSENGERS - New_transfer -> Are_we_already_there?

transition SECURING_DOORS - Doors_secure -> LOCKING_TRANSFER

transition LOCKING_TRANSFER - Go -> Requesting_transport_to_destination

transition EMERGENCY_BRAKING - Arrived_at_floor -> OUT_OF_SERVICE

transition Requesting_transport_to_destination - Transport_in_progress ->\
        MOVING
transition Requesting_transport_to_destination - Transport_unavailable ->\
        OUT_OF_SERVICE

transition Changing_destination - Change_requested -> MOVING

transition Are_we_already_there? - Already_there -> TRANSFERRING_PASSENGERS
transition Are_we_already_there? - Prepare_to_move -> SECURING_DOORS
----

=== Cabin Operations [[cabin-operations]]

[source,tcl]
----
<<Cabin operations definition>>=
instop Ping {dir} {
    chan puts "Cabin.Ping $dir"
}
----

=== Door State Model [[door-state-model]]

(((Dynamics Model,State Model,Door)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
initialstate CLOSED
defaulttrans CH

transition OPENING - Door_opened -> OPEN_DELAY
transition OPENING - Passenger_open -> IG
transition OPENING - Passenger_close -> CLOSING
transition OPENING - Lock -> IG
transition OPENING - Cant_close_door -> CANT_CLOSE

transition OPEN_DELAY - Passenger_open -> IG
transition OPEN_DELAY - Passenger_close -> Cancel_open_delay
transition OPEN_DELAY - Lock -> IG
transition OPEN_DELAY - Time_to_close -> HOLDING_OPEN

transition HOLDING_OPEN - Passenger_open -> IG
transition HOLDING_OPEN - Passenger_close -> IG
transition HOLDING_OPEN - Lock -> IG
transition HOLDING_OPEN - Hold_released -> CLOSING

transition CLOSING - Door_closed -> CLOSED
transition CLOSING - Door_blocked -> OPENING
transition CLOSING - Passenger_open -> OPENING
transition CLOSING - Passenger_close -> IG
transition CLOSING - Lock -> IG

transition CLOSED - Passenger_open -> OPENING
transition CLOSED - Passenger_close -> IG
transition CLOSED - Lock -> LOCKED
transition CLOSED - Unlock -> Unlock_for_arrival

transition LOCKED - Passenger_open -> IG
transition LOCKED - Passenger_close -> IG
transition LOCKED - Unlock -> Unlock_for_arrival

transition Cancel_open_delay - Open_delay_canceled -> HOLDING_OPEN

transition Unlock_for_arrival - Open_on_arrival -> OPENING
----

== Translating the Processing [[translating-activities]]

=== Door State Activities

==== OPENING

(((Activity,Door,OPENING)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# if (—Close attempts remaining) { // Count type is always >= 0
# 	Open door( Shaft ) => SIO
# 	UI.Door opening( Shaft )
# } else
# 	Cant close door -> me

state OPENING {} {
    assignAttribute $self Close_attempts_remaining Shaft
    incr Close_attempts_remaining -1
    updateAttribute $self Close_attempts_remaining $Close_attempts_remaining
    if {$Close_attempts_remaining > 0} {
        SIO::Open_door $Shaft
        UI::Door_opening $Shaft
    } else {
        signal $self Cant_close_door
    }
}
----

==== OPEN_DELAY

(((Activity,Door,OPEN DELAY)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# UI.Door opened( Shaft )
# Time to close -> me after Open wait time

state OPEN_DELAY {} {
    assignAttribute $self Shaft Open_wait_time
    UI::Door_opened [readAttribute $self Shaft]
    delaysignal $Open_wait_time $self Time_to_close
}
----

==== HOLDING_OPEN

(((Activity,Door,HOLDING OPEN)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# if (not Held)
#   Hold released -> me

state HOLDING_OPEN {} {
    if {![readAttribute $self Held]} {
        signal $self Hold_released
    }
}
----

==== CLOSING

(((Activity,Door,CLOSING)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# if (Emergency hold)
#   Emergency hold -> me
# else {
#   // Start closing the door
#   Close door( Shaft ) => SIO
#   UI.Door closing( Shaft )
#   // If the close fails, reopen for a potentially shorter
#   // duration to wait for obstruction to clear
#   Open wait time = /R4/R2/R1/Bank.Block clear time
# }

state CLOSING {} {
    if {[readAttribute $self Emergency_hold]} {
        signal $self Emergency_hold
    } else {
        set shaft [readAttribute $self Shaft]
        SIO::Close_door $shaft
        UI::Door_closing $shaft

        set bank [findRelated $self R4 R2 R1]
        updateAttribute $self Open_wait_time\
                [readAttribute $bank Block_clear_time]
    }
}
----

==== CLOSED

(((Activity,Door,CLOSED)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# UI.Door closed( Shaft )
# Close attempts remaining = /R4/R2/R1/Bank.Max close attempts
# if ( Lock requested )
#   Lock -> me
# Door closed -> /R4/R53/Transfer // May be none

state CLOSED {} {
    assignAttribute $self Shaft Lock_requested
    UI::Door_closed $Shaft
    if {$Lock_requested} {
        signal $self Lock
    }
    set transfers [findRelated $self R4 {R53 Transfer}]
    signal $transfers Door_closed
}
----

==== LOCKED

(((Activity,Door,LOCKED)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# // Tell the cabin that we’re ready to go
# Lock requested.unset
# // Do not clear lock in unlocking state because
# // Cabin might set it on arrival before we execute the
# // Unlock action. So it must be done here.
# Doors secure -> /R4/Cabin

state LOCKED {} {
    updateAttribute $self Lock_requested false
    set cabin [findRelated $self R4]
    signal $cabin Doors_secure
}
----

==== CANT_CLOSE

(((Activity,Door,CAN'T CLOSE)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# // Take the shaft out of service
# Take out of service -> /R4/R2/Shaft

state CANT_CLOSE {} {
    set shaft [findRelated $self R4 R2]
    signal $shaft Take_out_of_service
}
----

==== Cancel open delay

(((Activity,Door,Cancel open delay)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# Cancel Time to close -> me
# Open delay canceled -> me

state Cancel_open_delay {} {
    canceldelayed $self $self Time_to_close
    signal $self Open_delay_canceled
}
----

==== Unlock for arrival

(((Activity,Door,Unlock for arrival)))
(((chunk,Door state model definition)))
[source,tcl]
----
<<Door state model definition>>=
# // The Cabin has either just arrived at a floor
# // or the Cabin was called at its current location
# // Unlock (become alert to passenger door open/close requests)
# // Initialize the door close retry counter to zero
# // Load the door close timer with NORMAL open time
# // Proceed to door opening state
# Open wait time = /R4/R2/R1/Bank.Pass load time
# Open on arrival -> me

state Unlock_for_arrival {} {
    set bank [findRelated $self R4 R2 R1]
    updateAttribute $self Open_wait_time\
            [readAttribute $bank Passenger_load_time]
    signal $self Open_on_arrival
}
----

=== Cabin State Activities

==== MOVING

(((Activity,Cabin,MOVING)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
state MOVING {} {
}
----

==== TRANSFERRING PASSENGERS

(((Activity,Cabin,TRANSFERRING PASSENGERS)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
# Cabin at destination -> /R53/Transfer
# Unlock -> /R4/Door
# if (not /R2/Shaft.In service )
#   Take out of service -> me

<<Cabin state model definition>>=
state TRANSFERRING_PASSENGERS {} {
    set xfer [findRelated $self {R53 Transfer}]
    signal $xfer Cabin_at_destination

    set door [findRelated $self ~R4]
    signal $door Unlock

    set shaft [findRelated $self R2]
    if {![readAttribute $shaft In_service]} {
        signal $self Take_out_of_service
    }
}
----

==== SECURING DOORS

(((Activity,Cabin,SECURING DOORS)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
# /R4/Door.Lock requested.set
# Lock -> /R4/Door

state SECURING_DOORS {} {
    set door [findRelated $self ~R4]
    updateAttribute $door Lock_requested true
    signal $door Lock
}
----

==== LOCKING TRANSFER

(((Activity,Cabin,LOCKING TRANSFER)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
# Ready to move -> /R53/Transfer

state LOCKING_TRANSFER {} {
    set xfer [findRelated $self {R53 Transfer}]
    signal $xfer Ready_to_move
}
----

==== OUT OF SERVICE

(((Activity,Cabin,OUT OF SERVICE)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
# /R4/Door.Emergency hold.set
# Passenger open -> /R4/Door

state OUT_OF_SERVICE {} {
    set door [findRelated $self ~R4]
    updateAttribute $door Emergency_hold true
    signal $door Passenger_open
}
----

==== EMERGENCY BRAKING

(((Activity,Cabin,EMERGENCY BRAKING)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
# Stop at nearest floor( Shaft ) => TRAN

state EMERGENCY_BRAKING {} {
    assignAttribute $self Shaft
    TRAN::Stop_at_nearest_floor $Shaft
}
----

==== Requesting transport to destination

(((Activity,Cabin,Requesting transport to destination)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
# if (TRAN.Goto floor( Dest floor: /R53/Transfer.Destination floor, Shaft ) )
#   Transport in progress -> me
# else
#   Transport unavailable -> me

state Requesting_transport_to_destination {} {
    assignAttribute $self Shaft
    set xfer [findRelated $self {R53 Transfer}]
    assignAttribute $xfer Destination_floor
    set avail [TRAN::Goto_floor $Destination_floor $Shaft]
    if {$avail} {
        signal $self Transport_in_progress
    } else {
        signal $self Transport_unavailable
    }
}
----

==== Changing destination

(((Activity,Cabin,Changing destination)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
# if ( TRAN.Go to floor( Dest floor: in.new dest, Shaft ) )
#   Cabin redirected( Updated dest: in.new dest ) -> /R53/Transfer
# Change requested -> me

state Changing_destination {new_dest} {
    assignAttribute $self Shaft
    set avail [TRAN::Goto_floor $new_dest $Shaft]
    if {$avail} {
        set xfer [findRelated $self {R53 Transfer}]
        signal $xfer Cabin_redirected updated_dest $new_dest
    }
    signal $self Change_requested
}
----

==== Are we already there?

(((Activity,Cabin,Are we already there?)))
(((chunk,Cabin state model definition)))
[source,tcl]
----
<<Cabin state model definition>>=
# if ( /R53/Transfer.Destination floor == /R43/is at/Shaft Level/Floor )
#   Already there -> me
# else
#   Prepare to move -> me

state Are_we_already_there? {} {
    set xfer [findRelated $self {R53 Transfer}]
    assignAttribute $xfer Destination_floor
    set shaft_level [findRelated $self R43]
    assignAttribute $shaft_level Floor
    if {$Destination_floor == $Floor} {
        signal $self Already_there
    } else {
        signal $self Prepare_to_move
    }
}
----

=== Transfer State Activities

==== CREATED

(((Activity,Transfer,CREATED)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state CREATED {} {
}
----

==== Creating or updating transfer

(((Activity,Transfer,Creating or updating transfer)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# UI.Set destination( Shaft, floor: Destination floor )
# New transfer -> /R53/Cabin
# Wait for cabin -> me

state Creating_or_updating_transfer {} {
    assignAttribute $self
    UI::Set_destination $Shaft $Destination_floor
    set cabin [findRelated $self ~R53]
    signal $cabin New_transfer
    signal $self Wait_for_cabin
}
----

==== Changing destination before cabin moves

(((Activity,Transfer,Changing destination before cabin moves)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# // The cabin isn’t moving, so we can safely relink to the new destination
# Destination floor = in.updated dest
# Stationary update -> me

state Changing_destination_before_cabin_moves {new_dest} {
    updateAttribute $self Destination_floor $new_dest           ; # <1>
    signal $self Stationary_update
}
----
<1> NOTE: this is a problem. `updateAttribute` does not allow changing
identifying attributes. Attempting to create a new instance of Transfer
linked up properly also doesn't work because we can't get the
new instance into the correct state.
Rosea does not have a good way to handle identifying attribute changes
for an associative class that also has a state model.

==== WAITING FOR CABIN

(((Activity,Transfer,WAITING FOR CABIN)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state WAITING_FOR_CABIN {} {
}
----

==== Dispatching cabin

(((Activity,Transfer,Dispatching cabin)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Go -> /R53/Cabin
# Cabin dispatched -> me

state Dispatching_cabin {} {
    set cabin [findRelated $self ~R53]
    signal $cabin Go
    signal $self Cabin_dispatched
}
----

==== Request redirect

(((Activity,Transfer,Request redirect)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Try redirect( in.new dest ) -> /R53/Cabin
# Cabin redirect requested -> me

state Request_redirect {new_dest} {
    set cabin [findRelated $self ~R53]
    signal $cabin Try_redirect $new_dest
    signal $self Cabin_redirect_requested
}
----

==== CABIN IN MOTION

(((Activity,Transfer,CABIN IN MOTION)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state CABIN_IN_MOTION {} {
}
----

==== Match new destination of cabin

(((Activity,Transfer,Match new destination of cabin)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Destination floor = in.updated dest
# Update in motion -> me

state Match_new_destination_of_cabin {updated_dest} {
    updateAttribute $self Destination_floor $updated_dest           ; # <1>
    signal $self Update_in_motion
}
----
<1> See note above about the issue here.

==== Check for active floor service

(((Activity,Transfer,Check for active floor service)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
# UI.Cabin arrived( Shaft )
# pending floor service .=
#       /R53/R49/Floor Service( Direction: /R53/Cabin.Travel direction )
# if (pending floor service) {
#   Call in progress -> me
#   Cabin arrived -> pending floor service
# } else {
#   Serviced stop -> /R53/Accessible Shaft Level
#   Wait to clear -> me
# }

<<Transfer state model definition>>=
state Check_for_active_floor_service {} {
    UI::Cabin arrived [readAttribute $self Shaft]
    set cabin [findRelated $self ~R53]
    assignAttribute $cabin Travel_direction
    set pending_floor_service [findRelatedWhere $self {R53 {R49 Floor_Service}}\
            {$Direction eq $Travel_direction}]
    if {[isNotEmptyRef $pending_floor_service]} {
        signal $self Call_in_progress
        signal $pending_floor_service Cabin_arrived
    } else {
        set asl [findRelated $self R53]
        signal $asl Service_stop
        signal $self Wait_to_Clear
    }
}
----

==== CALL IN PROGRESS

(((Activity,Transfer,CALL IN PROGRESS)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state CALL_IN_PROGRESS {} {
}
----

==== Canceling floor service

(((Activity,Transfer,Canceling floor service)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Cancel -> /R53/R49/Floor Service( Direction: /R53/Cabin.Travel direction )
# Wait to clear -> me

state Canceling_floor_service {} {
    set cabin [findRelated $self ~R53]
    assignAttribute $cabin Travel_direction
    set pending_floor_service [findRelatedWhere $self {R53 {R49 Floor_Service}}\
            {$Direction eq $Travel_direction}]
    signal $pending_floor_service Cancel
    signal $self Wait_to_clear
}
----

==== WAITING FOR REQUESTS TO CLEAR

(((Activity,Transfer,WAITING FOR REQUESTS TO CLEAR)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
state WAITING_FOR_REQUESTS_TO_CLEAR {} {
}
----

==== Delete

(((Activity,Transfer,Delete)))
(((chunk,Transfer state model definition)))
[source,tcl]
----
<<Transfer state model definition>>=
# Transfer completed -> /R53/R2/Shaft

state Delete {} {
    set shaft [findRelated $self ~R53 R2]
    signal $shaft Transfer_complete
}

terminal Delete
----

=== Shaft State Activities

==== WAITING FOR STOP OR CALL REQUEST

(((Activity,Shaft,WAITING FOR STOP OR CALL REQUEST)))
(((chunk,Shaft state model definition)))
[source,tcl]
----
<<Shaft state model definition>>=
# if (not In service)
#   Take out of service -> me

state WAITING_FOR_STOP_OR_CALL_REQUEST {} {
    if {![readAttribute $self In_service]} {
        signal $self Take_out_of_service
    }
}
----

==== Searching for best destination

(((Activity,Shaft,Searching for best destination)))
(((chunk,Shaft state model definition)))
[source,tcl]
----
<<Shaft state model definition>>=
# xfer in progress .= /R2/R53/Transfer
# search dir = /R2/Cabin.Travel direction
# call in progress .= xfer in progress/Floor Service( Direction: search dir )
# // Look for a requesting accessible shaft level in the current travel direction
# destination aslev .= /R2/Cabin.Ping( dir: search dir )
# if (not destination aslev and not call in progress ) {
#   // Try looking in the opposite direction
#   destination slev .= /R2/Cabin.Ping( dir: search dir.toggle )
#   if (destination aslev)
#       // if the best destination is behind the cabin’s travel direction,
#       // the cabin can’t be in the middle of an xfer. So we can safely
#       // toggle the cabin’s direction.
#       Cabin.Travel direction = search dir
# }
# if (destination aslev)
#   Create transfer( floor: destination aslev.Floor ) -> me
# else
#   No destination -> me

state Searching_for_best_destination {} {
    set cabin [findRelated $self ~R2]
    set xfer_in_progress [findRelated $cabin {R53 Transfer}]
    set search_dir [readAttribute $cabin Travel_direction]
    set call_in_progress [findRelatedWhere $xfer_in_progress\
            {R53 {~R49 Floor_Service}} {$Direction eq $search_dir}]
    set destination_aslev [instop $cabin Ping $search_dir]
    if {[isEmptyRef $destination_aslev]} {
        set opposite_dir [expr {$search_dir eq "up" ? "down" : "up"}]
        set destination_aslev [instop $cabin Ping $opposite_dir]
        if {[isNotEmptyRef $destination_aslev]} {
            updateAttribute $cabin Travel_direction $opposite_dir
        }
    }

    if {[isNotEmptyRef $destination_aslev]} {
        signal $self Create_transfer [readAttribute $destination_aslev Floor]
    } else {
        signal $self No_destination
    }
}
----

==== Creating or updating transfer

(((Activity,Shaft,Creating or updating transfer)))
(((chunk,Shaft state model definition)))
[source,tcl]
----
<<Shaft state model definition>>=
# // If there is an existing Transfer to a location other than what has been
# // selected try to change it. If the destination is the same as what has been
# // selected, then don't do anything - just leave it. If there is no existing
# // Transfer, then create a new one with the selected destination.
#
# dest aslev .= /R28/R3/Accessible Shaft Level( Floor : in.floor )
# xfer in progress .= /R2/R53/Transfer
# if (not xfer in progress) {
#   new xfer .= /R2/Cabin &R53 dest aslev & *Transfer
#   Execute -> new xfer
# } else if ( existing xfer.Destination != in.floor )
#   // Request change if possible
#   Dest change request( new dest: in.floor ) -> xfer in progress
# Xfer requested -> me

state Creating_or_updating_transfer {floor} {
    set dest_aslev [findRelatedWhere $self\
        {{R28 Shaft_Level} {R3 Accessible_Shaft_Level}} {$Floor == $floor}]
    set xfer_in_progress [findRelated $self ~R2 {R53 Transfer}]
    if {[isEmptyRef $xfer_in_progress]} {
        set cabin [findRelated $self ~R2]
        set xfer [R53 link $cabin $dest_aslev]
        signal $xfer Execute
    } elseif {[readAttribute $xfer_in_progress] != $floor} {
        signal $xfer_in_progress Dest_change_request $floor
    }

    signal $self Xfer_requested
}
----

==== CANCELING TRANSFER

(((Activity,Shaft,CANCELING TRANSFER)))
(((chunk,Shaft state model definition)))
[source,tcl]
----
<<Shaft state model definition>>=
# // Take this shaft out of service
# In service.unset
#
# // Stop its cabin at the nearest floor
# Take out of service -> /R2/Cabin
#
# // Cancel any in progress transfer
# Cancel -> /R2/R53/Transfer
# [notarget] No transfer in progress -> me
#
# UI.Shaft out of service( shaft: ID )

state CANCELING_TRANSFER {} {
    updateAttribute $self In_service false

    set cabin [findRelated $self ~R2]
    signal $cabin Take_out_of_service

    set xfer [findRelated $cabin {R53 Transfer}]
    signal $xfer Cancel

    if {[isEmptyRef $xfer]} {
        signal $self No_transfer_in_progress
    }
}
----

==== OUT OF SERVICE

(((Activity,Shaft,OUT OF SERVICE)))
(((chunk,Shaft state model definition)))
[source,tcl]
----
<<Shaft state model definition>>=
# // Clear all floor calls and stop requests
#
# /R28/R54/Requested Shaft Level.Clear()

state OUT_OF_SERVICE {} {
}
----

=== Floor Service State Activities

==== WAITING FOR CABIN

(((Activity,Floor Service,WAITING FOR CABIN)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
state WAITING_FOR_CABIN {} {
}
----

==== REJECT REQUESTS OPPOSITE REQUESTED SERVICE DIR

(((Activity,Floor Service,REJECT REQUESTS OPPOSITE REQUESTED SERVICE DIR)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
state REJECT_REQUESTS_OPPOSITE_REQUESTED_SERVICE_DIR {} {
}
----

==== COMPLETED

(((Activity,Floor Service,COMPLETED)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
# Serviced floor request( dir: Direction ) -> /R49/Accessible Shaft Level

state COMPLETED {} {
    set aslev [findRelated $self R49]
    signal $aslev Serviced_floor_request [readAttribute $self Direction]
}
----

==== Check bank level type

(((Activity,Floor Service,Check bank level type)))
(((chunk,Floor Service state model definition)))
[source,tcl]
----
<<Floor Service state model definition>>=
# if (/R49/R38/Middle Bank Level)
#   Middle floor -> me
# else
#   Top or bottom floor -> me

state Check_bank_level_type {} {
    set bl [findRelated ~R49 {~R38 Middle_Bank_Level}]
    if {[isNotEmptyRef $bl]} {
        signal $self Middle_floor
    } else {
        signal $self Top_or_bottom_floor
    }
}
----

=== Accessible Shaft Level State Activities

==== NOT REQUESTED

(((Activity,Accessible Shaft Level,NOT REQUESTED
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
state NOT_REQUESTED {} {
}
----

==== REQUESTED

(((Activity,Accessible Shaft Level,REQUESTED)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
state REQUESTED {} {
}
----

==== Registering Stop

(((Activity,Accessible Shaft Level,Registering Stop)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# Stop requested.set
# Stop registered -> me

state Registering_stop {} {
    updateAttribute $self Stop_requested true
    signal $self Stop_requested
}
----

==== Registering floor call

(((Activity,Accessible Shaft Level,Registering floor call)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# Bank Level( Bank, Floor ) &R49 Accessible Shaft
# Level( Shaft, Floor ) & Floor Service( Direction: in.dir )
# Floor call registered -> me

state Registering_floor_call {dir} {
    set bank_level [findRelated R3]
    R49 link $bank_level $self Direction $dir
    signal $self Floor_call_registered
}
----

==== Requesting service

(((Activity,Accessible Shaft Level,Requesting service)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# Service requested -> /R3/R28/Shaft
# Wait for service -> me

state Requesting_service {} {
    set shaft [findRelated $self ~R3 ~R28]
    signal $shaft Service_requested
    signal $self Wait_for_service
}
----

==== Clear floor request

(((Activity,Accessible Shaft Level,Clear floor request)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# Clear floor request( in.dir ) -> /R49/Bank Level
# !* /R49/Floor Service( Direction: in.dir )
# Check stop request -> me

state Clear_floor_request {dir} {
    set bank_level [findRelated $self ~R49]
    signal $bank_level Clear_floor_request $dir
    set floor_service [findRelatedWhere $self {{~R49 Floor_Service}}\
            {$Direction eq $dir}]
    delete $floor_service
    signal $self Check_stop_request
}
----

==== Clear stop request

(((Activity,Accessible Shaft Level,Clear stop request)))
(((chunk,Accessible Shaft Level state model definition)))
[source,tcl]
----
<<Accessible Shaft Level state model definition>>=
# // Clear the stop request if registered
# if (Stop requested) {
#   UI.Clear stop request( Floor, Shaft )
#   Stop requested.unset
# }
# if /R49/Floor Service( Direction : in.dir.opposite )
#   Opposite floor call pending -> me
# else
#   All requests cleared -> me
#
# Requests cleared -> /R53/Transfer

state Clear_stop_request {} {
    if {[readAttribute $self Stop_requested]} {
        assignAttribute $self Floor Shaft
        UI::Clear_stop_request $Floor $Shaft
        updateAttribute $self Stop_requested false
    }

    # NOTE, no input parameter "dir"
    # signalling "All requests cleared" for now
    signal $self All_requests_cleard

    set xfer [findRelated $self {~R53 Transfer}]
    signal $xfer Requests_cleared
}
----

=== Bank Level State Activities

==== XX

(((Activity,Bank Level,XX)))
(((chunk,Bank Level state model definition)))
[source,tcl]
----
<<Bank Level state model definition>>=
----

== External Entities [[external-entities,External Entities]]

=== SIO

==== Open door

(((External Entity,SIO,Open door)))
(((chunk,sio external entity)))
[source,tcl]
----
<<sio external entity>>=
proc Open_door {shaft} {
    chan puts "SIO::Open_door $shaft"
}
----

==== Close door

(((External Entity,SIO,Close door)))
(((chunk,sio external entity)))
[source,tcl]
----
<<sio external entity>>=
proc Close_door {shaft} {
    chan puts "SIO::Close_door $shaft"
}
----

=== UI

==== Door opening

(((External Entity,UI,Door opening)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_opening {shaft} {
    chan puts "UI::Door_opening $shaft"
}
----

==== Door opened

(((External Entity,UI,Door opened)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_opened {shaft} {
    chan puts "UI::Door_opened $shaft"
}
----

==== Door closing

(((External Entity,UI,Door closing)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_closing {shaft} {
    chan puts "UI::Door_closing $shaft"
}
----

==== Door closed

(((External Entity,UI,Door closed)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Door_closed {shaft} {
    chan puts "UI::Door_closed $shaft"
}
----

==== Set destination

(((External Entity,UI,Set destination)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Set_destination {shaft floor} {
    chan puts "UI::Set_destination $shaft $floor"
}
----

==== Cabin arrived

(((External Entity,UI,Cabin arrived)))
(((chunk,ui external entity)))
[source,tcl]
----
<<ui external entity>>=
proc Cabin_arrived {shaft} {
    chan puts "UI::Cabin_arrived $shaft"
}
----

=== TRAN

==== Goto floor

(((External Entity,TRAN,Goto floor)))
(((chunk,tran external entity)))
[source,tcl]
----
<<tran external entity>>=
proc Goto_Floor {floor shaft} {
    chan puts "TRAN::Goto_floor $floor $shaft"
    return true
}
----

==== Stop at nearest floor

(((External Entity,TRAN,Stop at nearest floor)))
(((chunk,tran external entity)))
[source,tcl]
----
<<tran external entity>>=
proc Stop_at_nearest_floor {shaft} {
    chan puts "TRAN::Stop_at_nearest_floor $shaft"
}
----

== Code Organization [[codeorganization,Code Organization]]

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

(((chunk,copyright info)))
[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2017 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

(((chunk,elevator.tcl)))
[source,tcl]
----
<<elevator.tcl>>=
<<copyright info>>

package require Tcl 8.6
package require rosea 1.6

rosea configure {
    domain elevator {
        <<Accessible Shaft Level class definition>>
        <<Bank class definition>>
        <<Building class definition>>
        <<Cabin class definition>>
        <<Door class definition>>
        <<Floor class definition>>
        <<Floor Service class definition>>
        <<Bank Level class definition>>
        <<Top Bank Level class definition>>
        <<Middle Bank Level class definition>>
        <<Bottom Bank Level class definition>>
        <<Shaft class definition>>
        <<Shaft Level class definition>>
        <<Transfer class definition>>
        <<relationship definitions>>
    }
}

rosea generate

rosea populate {
    domain elevator {
        <<elevator population>>
    }
}

namespace eval ::elevator::SIO {
    <<sio external entity>>
}

namespace eval ::elevator::UI {
    <<ui external entity>>
}

namespace eval ::elevator::TRAN {
    <<tran external entity>>
}

package require comm
comm::comm configure -port 50000

chan puts "listening at port [comm::comm configure -port]"

vwait forever
after 1000
exit
----

(((chunk,Accessible Shaft Level class definition)))
[source,tcl]
----
<<Accessible Shaft Level class definition>>=
class Accessible_Shaft_Level {
    <<Accessible Shaft Level attribute definition>>
    statemodel {
        <<Accessible Shaft Level state model definition>>
    }
}
----

(((chunk,Bank class definition)))
[source,tcl]
----
<<Bank class definition>>=
class Bank {
    <<Bank attribute definition>>
}
----

(((chunk,Building class definition)))
[source,tcl]
----
<<Building class definition>>=
class Building {
    <<Building attribute definition>>
}
----

(((chunk,Cabin class definition)))
[source,tcl]
----
<<Cabin class definition>>=
class Cabin {
    <<Cabin attribute definition>>
    <<Cabin operations definition>>
    statemodel {
        <<Cabin state model definition>>
    }
}
----

(((chunk,Door class definition)))
[source,tcl]
----
<<Door class definition>>=
class Door {
    <<Door attribute definition>>
    statemodel {
        <<Door state model definition>>
    }
}
----

(((chunk,Floor class definition)))
[source,tcl]
----
<<Floor class definition>>=
class Floor {
    <<Floor attribute definition>>
}
----

(((chunk,Floor Service class definition)))
[source,tcl]
----
<<Floor Service class definition>>=
class Floor_Service {
    <<Floor Service attribute definition>>
    statemodel {
        <<Floor Service state model definition>>
    }
}
----

(((chunk,Bank Level class definition)))
[source,tcl]
----
<<Bank Level class definition>>=
class Bank_Level {
    <<Bank Level attribute definition>>
}
----

(((chunk,Top Bank Level class definition)))
[source,tcl]
----
<<Top Bank Level class definition>>=
class Top_Bank_Level {
    <<Top Bank Level attribute definition>>
}
----

(((chunk,Middle Bank Level class definition)))
[source,tcl]
----
<<Middle Bank Level class definition>>=
class Middle_Bank_Level {
    <<Middle Bank Level attribute definition>>
}
----

(((chunk,Bottom Bank Level class definition)))
[source,tcl]
----
<<Bottom Bank Level class definition>>=
class Bottom_Bank_Level {
    <<Bottom Bank Level attribute definition>>
}
----

(((chunk,Shaft class definition)))
[source,tcl]
----
<<Shaft class definition>>=
class Shaft {
    <<Shaft attribute definition>>
    statemodel {
        <<Shaft state model definition>>
    }
}
----

(((chunk,Shaft Level class definition)))
[source,tcl]
----
<<Shaft Level class definition>>=
class Shaft_Level {
    <<Shaft Level attribute definition>>
}
----

(((chunk,Transfer class definition)))
[source,tcl]
----
<<Transfer class definition>>=
class Transfer {
    <<Transfer attribute definition>>
    statemodel {
        <<Transfer state model definition>>
    }
}
----

/////

=== XX Class [[xxclass,XX]]

(((Ordering,Classes,XX)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,Relationships,RR)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,State Model,XX)))
[source,tcl]
----
<<XX State Model>>=
----
/////

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
