// vim:set syntax=asciidoc:
= Relation Oriented Software Execution Architecture

[abstract]
This document describes a Tcl package named, +rosea+.
+rosea+ is an execution architecture intended as the target for
translating XUML models using Tcl as the implementation language.

== Introduction [[introduction,Introduction]]

This document is about a Tcl package named, +rosea+.
+rosea+ is a data and execution domain that is intended as the
target for translating XUML models using Tcl as the implementation
language.

This document is also a literate program.
As such, it contains all the descriptions, source code and test cases
for the +rosea+ package.
The conventions of the literate program are explained
<<literate-programming,below>>.

=== Design Strategy [[design-strategy,Design Strategy]]

One of main design choices for +rosea+ was to base its data
architecture on TclRAL.
TclRAL is a relational algebra library.
It is available as a ``C'' based extension under the package name +ral+.

The choice of TclRAL allows the data architecture to implement referential
integrity constraints.
Indeed the contraints that are part of TclRAL were designed specifically
to support the integrity requirements of XUML.
Many XUML execution architectures to not attempt to enforce the
referential integrity inherent in the class model relationships in XUML.
This is understandable for some platforms, such as embedded micro-controllers,
where the cost of enforcement is relatively high and the class of
applications fielded on the platforms tend to have static instance and
relationships populations.
With static populations,
the referential integrity can be checked at initialization time and
is usually not compromised when the system runs.

However,
when running on a more capable compute platform,
we want to take advantage of the referential integrity constraints
as a convenient, declarative way to better insure the correct operation
of the software.
By targeting Tcl as the implmentation language and using TclRAL as
the basis of the data architecture,
we achieve an XUML execution architecture that is very robust with
respect to insuring that the resulting program transitions from
one correct state to another.

==== Comparing Approaches [[comparing-approaches,Comparing Approaches]]

Comparing Approaches

* TclRAL and a bunch of procedures
* TclOO based
** each relvar a class
** each tuple an object
** large amount of OO machinery that is not used
** problems with lifetimes of object commands
* namespace ensemble based

=== Namespace Ensemble Approach [[namespace-ensemble-approach,Namespace Ensemble Approach]]
Namespace Ensemble Approach

* No unnecessary OO machinery that is not used.
* Convenient way to encapsulate a domain.

Parts of the puzzle

* procedures in the +rosea+ package to handle common XUML semantics
* configuration language to compute the mechanisms data structures and
layout the domain in the correct way.

Mapping concepts to Tcl implementation constructs.

["blockdiag",title="Basic Mapping of XUML Concepts"]
------
blockdiag {
    class longnode [width=150]
    domain [label="Domain"]
    namespace [label="Namespace"]
    class [label="XUML Class"]
    relvar [label="TclRAL relvar"]
    instance [label="XUML Instance"]
    tuple [label="Tuple in a relvar"]
    relationship [label="XUML Relationship"]
    constraint [label="TclRAL constraint"]
    classop [label="Class Operation"]
    clenscmd [label="Ensemble Subcommand", class=longnode]
    domop [label="Domain Operation"]
    domenscmd [label="Ensemble Subcommand", class=longnode]
    instop [label="Instance Operation"]
    inenscmd [label="Ensemble Subcommand", class=longnode]
    stateact [label="State Activity"]
    proc [label="Tcl proc"]

    domain -> namespace
    class -> relvar
    instance -> tuple
    relationship -> constraint
    domop -> domenscmd
    classop -> clenscmd
    instop -> inenscmd
    stateact -> proc
}
------

=== Relation Values, Relvars and Instance References -- Oh My!

Although the ideas of variables and values are well know,
it is worth clarifying the differences between variables and
values and how TclRAL constructs are involved.
Some of the confusion in this area arises from the conventional
use of symbol names in programing languages to stand for both
the variable and its value.

For example, consider the following ``C'' code.

[source,c,numbered]
----
int counter ;

counter = 27 ;

counter = counter + 3 ;
----

As line 1 shows, +counter+ is clearly a variable of integer type.
It is assigned the _value_ 27 on line 3.
Line 5 assigns the _value_ held by +counter+ added to the _value_ +3+ into the
_variable_, +counter+.
In ``C'' and many other languages, the interpretation of the symbol +counter+
depends upon whether it stands for a value in an expression
or as the target of an assignment.
In ``C'' parlance, the meaning is determined by whether +counter+ is
used as
http://en.wikipedia.org/wiki/Value_(computer_science)[an _lvalue_ or an _rvalue_].
Normally, we do not speak in such ultra-precise terms since context
shows whether we are interested in the _value_ contained by the _variable_
or whether we are talking about the memory allocated to the _variable_.

A _relation value_ is defined as a _heading_ and a _body_
which is a set of tuples that correspond to the heading.
The heading consists of a set of named attributes and their corresponding
data types.
The tuples that are the body of the relation value form a set,
_i.e._ there are no duplicated tuples.
In TclRAL, a relation value has a string representation
(like all well behaved Tcl values)
that is a two element list representing the heading and the body.
Relation values in TclRAL are first class Tcl values and consequently
may be assigned to an ordinary Tcl variable and undergo the normal
lifecycle of values.
This latter point is important as we shall see later.

A _relation variable_ (or relvar) is a special type of variable
that holds a _relation value_.
The concept of a relvar is supplied by TclRAL and a relvar is _not_ an
ordinary Tcl variable.
TclRAL maintains a _shadow_ variable system for relvars.
The naming conventions follow those of ordinary Tcl variables in that
they can be qualified using namespace syntax.
The reason that relation variables are distinct from Tcl variables is that they
are also subject to _constraints_ for identity and referential integrity.
This is one of the major distinguishing aspects of relvars.
TclRAL has the subcommand, +relvar+, which operates directly on relvars and
a distinct subcommand, +relation+, that operates on relation values.

However, we still need some way to refer to a particular tuple in a
relvar.
The correspondance that we are implying here is that an XUML class is
represented as a relvar and an XUML class instances is represented
as a tuple in the relation value stored in the corresponding relvar.
For example,
in XUML events are signaled to instances.
We will find it necessary to refer to particular instances when
signaling events.
We will also find it necessary to refer to sets of tuples when, for example,
we search for instances that meet some criteria.
Consequently, we define an _instance reference_ concept.
In the relational view,
the only way that you can refer to tuples in the relation values contained
in relvars is by the _values_ of identifying attributes.
There is no notion of indexing and order within the relation values is
not specified.
Each relvar must have at least one identifier.
An identifier is a set of attributes (often a single attribute but
not always), the values of which must be distinct from those of the
other tuples in the relvar.
So to refer to an instance we need to know the relvar in questions and
the values of the attributes that constitute an identifier.
So we will represent an instance reference as a two element list as follows:

* A fully qualified relvar name.
* A relation value whose heading contains those attributes of the
relvar that correspond to an identifier.

This representation has several useful characteristics.

* An empty relation value indicates the _nil_ reference.
* The cardinality of the relation value can be greater than one and as
such represents a reference to a set of instances.

So we do not need to distinguish between an instance reference
and an instance reference set as distinct entities as
is often done in architectures that target staticly typed languages.
Our representation of an instance reference can refer to zero, one or
as many instances as needed.

We will need several operations on instance references.

==== ToRef Command

The +ToRef+ command takes a fully qualified relvar name and a relation value
that is a subset of the value held in the relvar and returns an instance
reference to the values.

(((rosea,Helper,ToRef)))

[source,tcl]
----
<<helper commands>>=
proc ToRef {relvar relvalue} {
    tailcall list $relvar [relation project $relvalue\
        {*}[lindex [relvar identifiers $relvar] 0]] ; # <1>
}
----
<1> Let's step through this one command at a time,
starting at the inner nesting.
* +relvar identifiers+ returns a list of the identifiers of the relvar.
Since each relvar has at least one identifier, we can always index off
the first identifier.
* +relation project+ returns a new relation value that contains only
the attributes requested.
In this case we are asking for those attributes that form one of the
identifiers.
* We compose the two element list that defines an instance reference
and we can use +tailcall+ since this is the last command in the procedure.

[source,tcl]
----
<<helper command tests>>=
test ToRef-1.0 {
    Compute a reference to a relvar tuple
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
} -cleanup {
    relvar unset A
} -body {
    set value [relation create {Attr1 int Attr2 string} {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }]
    ::rosea::Helpers::ToRef [namespace current]::A $value
} -result {::rosea::test::A {{Attr1 int} {{Attr1 20} {Attr1 40}}}} -match ref
----

==== Dereferencing an Instance

We will also need to obtain the tuples referenced by an instance reference.
In other words we will need to derefence the instance.
The +deRef+ command takes an instance reference and returns a relation
value that contains all the tuples from the associated relvar that
match the identifying attribute values contained in the reference.
Optionally,
the +deRef+ command takes a set of attribute names.
In this case the returned instance will be a _projection_ of
the full instance relation, containing only the attributes
that form an identifier and the attributes given as arguments.

(((rosea,Helper,DeRef)))
[source,tcl]
----
<<helper commands>>=
namespace export deRef
proc deRef {instref args} {
    lassign $instref relvar ref
    set inst [relation semijoin $ref [relvar set $relvar]] ; # <1>
    if {[llength $args] != 0} {
        set inst [relation project $inst\
            {*}[relation attributes $ref] {*}$args]
    }
    return $inst
}
----
<1> Dereferencing the instance is just a simple matter of ++semijoin++ing the
relation value in the instance reference to the value contained in the
relvar.
In TclRAL, +semijoin+ returns a relation value whose heading
matches that of its final argument which in our case is that of the
referenced relvar value.

[source,tcl]
----
<<helper command tests>>=
test deRef-1.0 {
    Dereference to get a relation value
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }
} -cleanup {
    relvar unset A
} -body {
    set ref [list [namespace current]::A {{Attr1 int} {{Attr1 40}}}]
    rosea::Helpers::deRef $ref
} -result {{Attr1 int Attr2 string} {{Attr1 40 Attr2 bar}}} -match relation
----

[source,tcl]
----
<<helper command tests>>=
test deRef-1.1 {
    Dereference to get a projection of the instance
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
        Attr3   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo Attr3 buzz
    } {
        Attr1 40 Attr2 bar Attr3 zub
    }
} -cleanup {
    relvar unset A
} -body {
    set ref [list [namespace current]::A {{Attr1 int} {{Attr1 40}}}]
    rosea::Helpers::deRef $ref Attr3
} -result {{Attr1 int Attr3 string} {{Attr1 40 Attr3 zub}}} -match relation
----

==== Counting References

Since commands that search for instances return instance references
we will need some commands that can determine if we are indeed referring
to anything.

(((rosea,Helper,isNilRef)))
[source,tcl]
----
<<helper commands>>=
proc isNilRef {instref} {
    tailcall relation isempty [lindex $instref 1]
}
----

Note that in relational algebra the empty relation, _i.e._ what we
have call here the _nil reference_ is perfectly valid.
It is well defined that dereferencing a nil reference simply
returns a relation values that contains no tuples.
Despite our use of the _nil_ term,
it should _not_ be mistaken for the same concept in most programming
languages where +nil+ is usually implemented as a special
address and dereferencing the +nil+ pointer is not allowed.

(((rosea,Helper,isNotNilRef)))
[source,tcl]
----
<<helper commands>>=
proc isNotNilRef {instref} {
    tailcall relation isnotempty [lindex $instref 1]
}
----

(((rosea,Helper,refMultiplicity)))
[source,tcl]
----
<<helper commands>>=
proc refMultiplicity {instref} {
    tailcall relation cardinality [lindex $instref 1]
}
----

(((rosea,Helper,isRefSingular)))
[source,tcl]
----
<<helper commands>>=
proc isRefSingular {instref} {
    expr {[refMultiplicity $instref] == 1}
}
----

==== Instance Reference Equality

(((rosea,Helper,isRefEqual)))
[source,tcl]
----
<<helper commands>>=
proc isRefEqual {ref1 ref2} {
    lassign $ref1 relvar1 inst1
    lassign $ref2 relvar2 inst2
    return [expr {$relvar1 eq $relvar2 &&\
            [relation is $inst1 == $inst2]}]
}
----

==== Iterating on References

We will find it convenient to iterate on the instances referred to
by an instance reference.
Recall, that an instance reference can refer to many tuples
and there are times when we want to visit each instance and run
some code.
As is typical in Tcl and following the pattern of the +foreach+
command,
we construct a control structure procedure to perform the iteration.
The +forAllRefs+ command assigns an instance reference from a set
to a variable and executes a script for each instance.
Each iteration insures that the instance reference assigned to the
variable references only a single tuple.

(((rosea,Helper,forAllRefs)))
[source,tcl]
----
<<helper commands>>=
proc forAllRefs {varname instref body} {
    lassign $instref relvar refs
    upvar 1 $varname inst
    relation foreach ref $refs {
        set inst [list $relvar $ref]
        uplevel 1 $body
    } ; # <1>
    return
}
----
<1> The key command here is +relation foreach+ which performs the
iteration, one tuple at a time.

=== Navigating the Model

In the relation model of data,
one can specify a set of constraints and have those constraints
enforced on the relvar values.
For TclRAL,
the form of these constraints was specifically design to match
those needed by XUML.
From a relational algebra point of view,
the constraints declare the multiplicity and conditionality of
the association between tuples in relvars.

From an XUML point of view,
model relationships enforce both referential integrity and provide
a way to navigate around the class data.
It is common for state activities to read and update
data in the model and to use the relationship declarations
of the model to find related instances.
Ultimately for an architecture based on relational algebra,
navigating the XUML class model via relationships
must be translated into a sequence of +semijoin+ operations.
In this section we discuss the concepts and syntax for accomplishing
that.

Conventionally,
XUML action languages specify the relationship navigation
by giving the relationship name and the destination class name, _e.g._

====
self -> R23[MOTOR]
====

would be a statement to select the instances across +R23+ that are
from the +MOTOR+ class.
This technique has an ambiguity for reflexive relationshipsfootnote:[
A reflexive relationship is one formed between a class and itself]
as it gives no way to determine the direction of the traversal
when the starting and ending of the traversal is the same class.
This has usually been resolved by using the relationship annotation
from the class model.

However, we specifically avoid using the model annotation to disambiguate
the reflexive relationship case.
Changing model annotation should not invalidate action language statements.
The approach we adopt in +rosea+ is to give each relationship an
explicit direction and to use the destination class only in those
cases where the relationship type allows for multiple paths.
We will specify navigation in forward direction using the relationship
name, _i.e._ +R1+, and in the reverse direction using the relationship
prefixed by a tilde character, _i.e._ +~R1+.

We will consider each type of relationship and show how the use of
a direction and sometimes a destination class allows for the navigation
of the class model.
Note also that this choice of specifying the relationship navigation
has no bearing on the XUML view of relationships in general.
We are not implying that the concept of a direction is a model level concept.
It is a particular technique that will be used as part of the syntax
for specifying the navigation operations for the +rosea+ archiecture.

==== Simple Associations

The figure below shows the case of a simple associative
relationship.
We choose the direction of the relationships to
be the same as the direction of reference.
So we deem the source of the navigation to be the class
that contains the referential attributes and the destination of
the navigation to be the referred to class.
For the case of singular relationships,
the choice of where to place the referential attributes is sometimes
arbitrary,
but wherever the analyst has placed the referential attribute determines
the direction of the relationship.

image::assoc-link.pdf[title="Simple Associative Relationships"]

So, starting with an instance of +X+ we can find the related +Y+ instance
or instances by navigating across +R1+.
The reverse navigation from +Y+ to +X+ is across +~R1+.

==== Generalization

The figure below shows the case of a generalization relationship.
In a generalization,
the subclasses always contain the referential attributes and therefore
always refer to the superclass and the direction of a
generalization is always from the subclasses to the superclass.

image::partition-link.pdf[title="Generalization Relationship"]

So we can say that we navigate from a subclass, say +X+,
to the superclass, +S+, by +R1+.
In the case of navigating from the superclass to a subclass,
we will find it necessary to specify the destination class name
when navigating from superclass to subclass.
So navigation from +S+ to +Y+ is specified as +~R1 Y+.
Because of the nature of a generalization,
navigating from superclass to a specific subclass will result in at most
one instance (and possibly zero) being found and 
navigating from subclass to superclass results in exactly one found instance.

==== Associative Classes

For associations implemented via an associative class,
it is the associative class that holds the referential attributes and
it will hold attributes that refer to both participating classes.
In this case,
the direction of the relationship must be arbitrarily assigned.
In the diagram below,
we have decided that the forward direction is traversing from +X+ to +Y+.

image::correl-link.pdf[title="Associative Class Relationship"]

So given an instance of +X+, we can navigate to +Y+ via +R1+ and,
conversely, navigate from +Y+ to +X+ via +~R1+.

Associative classes may also be the target of relationship navigation.
So we may wish to go from +X+ to +A+.
In this case we represent that as +R1 A+,
_i.e._ we go forward along +R1+ but stop at +A+.
Conversely,
we can navigate from +Y+ to +A+ along +~R1 A+.

==== Architecture Link Information

Given these syntax conventions,
we can design the data structures necessary to
support the run-time navigation of relationships as a series
of relational algebra +semijoin+ operations.
The diagram below shows a class diagram of the required data.

image::link-classes.pdf[title="Link Information Class Diagram"]

This is the first of several architectural data structures that
will be used to directly support the +rosea+ run-time.
We shall see others, for example, for state transitions.

=== Domain Organization [[domain-organization,Domain Organization]]

Domain Organization

["blockdiag",title="Namespace Organization for a Domain"]
------
blockdiag {
    class rvsetstyle [shape = roundedbox, stacked] ;
    class rvstyle [shape = roundedbox] ;
    class procstyle [shape = ellipse, stacked, width = 175, height = 50] ;

    domain [label = "::<domain name>", color = "#bbffb0"] ;
    relvars [label = "<class relvars>", class = "rvsetstyle"] ;
    classcmds [label = "<class ensemble\ncommands>", class = "procstyle"] ;
    relcmds [label = "<relationship\nensemble commands>",
        class = "procstyle"] ;
    arch [label = "::__Arch", color = "#ffe870"] ;

    class1 [label = "::<class 1>", color = "#ffe870"] ;
    class2 [label = "::<class 2>", color = "#ffe870"] ;
    classdots [shape = "dots"] ;
    classN [label = "::<class N>", color = "#ffe870"] ;

    domain -> relvars, classcmds, relcmds,
            class1, class2, classdots, classN, arch ;
    domain -> classdots [style = "none"] ;

    c2dots [shape = "dots"] ;
    class2 -> c2dots ;
    cNdots [shape = "dots"] ;
    classN -> cNdots ;

    archinfo [label = "<arch relvars>", class = "rvsetstyle"] ;

    arch -> archinfo ;

    instance [label = "__<class>__INSTANCE", class = "rvstyle"] ;
    activity [label = "::__Activity", color = "#ff8b70"] ;
    classop [label = "::<class op procs>", class = "procstyle"] ;
    instop [label = "::<inst op procs>", class = "procstyle"] ;

    class1 -> instance, activity, classop, instop ;

    state [label = "::<state activity>", class = "procstyle"] ;

    activity -> state ;
}
------

==== Class Relvars
Class Relvars

==== Class Ensemble Commands
Class Ensemble Commands

==== Relationship Ensemble Commands
Relationship Ensemble Commands

==== Class Namespaces
Class Namespaces

==== Class Activity Procedures
Class Activities

==== Architecture Relvars

["blockdiag",title="Relvars Containing Architecture Information"]
------
blockdiag {
    class rvsetstyle [shape = roundedbox, stacked] ;
    class rvstyle [shape = roundedbox] ;

    archinfo [label = "<arch relvars>", class = "rvsetstyle"] ;

    trans [label = "__Transition", class = "rvstyle"]
    istate [label = "__InitialState", class = "rvstyle"]
    deftrans [label = "__DefaultTrans", class = "rvstyle"]
    term [label = "__Terminal", class = "rvstyle"]
    link [label = "__Link", class = "rvstyle"]
    assoclink [label = "__AssociationLink", class = "rvstyle"]
    partlink [label = "__PartitionLink", class = "rvstyle"]

    archinfo -> trans, istate, deftrans, term, link, assoclink, partlink ;
}
------

=== Package Organization [[package-organization,Package Organization]]

Package Organization

["blockdiag",title="Namespace Organization for a rosea Package"]
------
blockdiag {
    class ns1st [color= "#bbffb0"]
    class ns2nd [color= "#ffe870"]

    rosea [label="::rosea",class=ns1st]
    helpcmd [label="::Helpers",class=ns2nd]
    classcmd [label="::ClassCmds",class=ns2nd]
    instcmd [label="::InstCmds",class=ns2nd]
    relcmd [label="::RelCmds",class=ns2nd]
    dispatchcmd [label="::Dispatch",class=ns2nd]
    configcmd [label="::Config",class=ns2nd]
    tracecmd [label="::Trace",class=ns2nd]

    rosea -> helpcmd, classcmd, instcmd, relcmd, dispatchcmd, configcmd,
        tracecmd
}
------

== Package Procedures

In this section we begin showing all the procedures associated
with the +rosea+ run time itself.
These will be divided into sections that correspond to the figure
above that showed how the namespace for the packge would be organized.

We start with some preliminaries.
Since we are using TclRAL extensively,
we need to pull in the package.

[source,tcl]
----
<<required packages>>=
package require ral
package require ralutil
----

We will find it convenient to import some of the commands from
TclRAL since we will be using them repeatedly.

[source,tcl]
----
<<tclral imports>>=
namespace import ::ral::relvar
namespace import ::ral::relation
namespace import ::ral::tuple
namespace import ::ral::relformat
namespace import ::ralutil::pipe
----

The namespace is organized as shown <<package-organization,above>>.

[source,tcl]
----
<<rosea namespace layout>>=
<<helper commands namespace>>
<<class commands namespace>>
<<instance commands namespace>>
<<relationship commands namespace>>
<<dispatch commands namespace>>
<<configuration commands namespace>>
<<trace commands namespace>>
----

=== A Diversion for Testing

[source,tcl]
----
<<test utility procs>>=
proc refMatch {expected actual} {
    lassign $expected erelvar einst
    lassign $actual arelvar ainst
    return [expr {$erelvar eq $arelvar && [ral relation is $einst == $ainst]}]
}
customMatch ref [namespace current]::refMatch

proc relationMatch {expected actual} {
    return [::ral::relation is $expected == $actual]
}
customMatch relation [namespace current]::relationMatch
----

=== Class Commands

In this section we show the class oriented commands of +rosea+.
These commands are the target of the ensemble mappings for each
of the classes in a domain.
Class oriented commands fall into these categories:

* Commands that search for instances.
* Commands that create and destroy instances.
* Commands that update the value of the underlying relvar.

First we create the namespace where the commands will reside.

[source,tcl]
----
<<class commands namespace>>=
namespace eval ClassCmds {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers ; # <1>
    <<class commands>>
}
----
<1> The helper commands are used everywhere so it is convenient to
include them in the command resolution path.

==== Find All Instances

The simplest search for instances is just to return them all.
The +findAll+ command returns an instance reference that refers to
all the tuples of the relvar.

(((rosea,ClassCmds,findAll)))
[source,tcl]
----
<<class commands>>=
proc findAll {relvar} {
    tailcall ToRef $relvar [relvar set $relvar]
}
----

==== Find Instances by Their Identifier

Sometimes the values of the identifying attributes are known.
The +findById+ command returns a reference to at most one
tuple found in the relvar.

(((rosea,ClassCmds,findById)))
[source,tcl]
----
<<class commands>>=
proc findById {relvar args} {
    tailcall ToRef $relvar [relvar restrictone $relvar {*}$args]
}
----

[source,tcl]
----
<<class command tests>>=
test findById-1.0 {
    Find tuple by value of the identifier
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }
} -cleanup {
    relvar unset A
} -body {
    rosea::ClassCmds::findById [namespace current]::A Attr1 20
} -result {::rosea::test::A {{Attr1 int} {{Attr1 20}}}} -match ref
----

==== Find Instances Meeting a Criteria

The general case is to find instances based on the result of
evaluating an expression.
The +findWhere+ command takes an expression and returns an
instance reference for those tuples where the expression evaluates
to true.
During execution, the values of the attributes will be placed in Tcl
variable that have the same name as the attribute.
So the +expr+ argument may refer to those variables.

(((rosea,ClassCmds,findWhere)))
[source,tcl]
----
<<class commands>>=
proc findWhere {relvar expr} {
    tailcall ToRef $relvar [uplevel 1 [list ral relation restrictwith\
        [relvar set $relvar] $expr]]
}
----

[source,tcl]
----
<<class command tests>>=
test findWhere-1.0 {
    Find tuples based on an expression
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    } {
        Attr1 60 Attr2 baz
    }
} -cleanup {
    relvar unset A
} -body {
    rosea::ClassCmds::findWhere [namespace current]::A {
        $Attr1 > 20 && $Attr1 < 60
    }
} -result {::rosea::test::A {{Attr1 int} {{Attr1 40}}}} -match ref
----

==== More Testing Infrastructure

[source,tcl]
----
<<test utility procs>>=
proc setupDomain {name} {
    set domns [namespace current]::$name
    namespace eval $domns {}
    ::rosea::GenerateArchStructures $domns
}

proc cleanupDomain {name} {
    set domns [namespace current]::$name
    relvar constraint delete {*}[relvar constrain names ${domns}::*]
    relvar unset {*}[relvar names ${domns}::*]
    namespace delete $domns
}

proc addClass {domain class heading id} {
    set domns [namespace current]::$domain
    set idheading [list]
    foreach attr $id {
        lappend idheading $attr [dict get $heading $attr]
    }
    relvar create ${domns}::__${class}__INSTANCE\
        [concat $idheading [list __State string]]\
        $id
    relvar create ${domns}::$class $heading $id
    namespace eval ${domns}::${class}::__Activity {}
}

proc addState {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__Arch::__State $args
}

proc addEvent {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__Arch::__Event $args
}

proc addTransition {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__Arch::__Transition $args
}

proc addInitialState {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__Arch::__InitialState $args
}

proc addAssocLink {domain linkattrs assocattrs} {
    dict set linkattrs Class\
        [namespace current]::${domain}::[dict get $linkattrs Class]
    dict set assocattrs SrcClass\
        [namespace current]::${domain}::[dict get $assocattrs SrcClass]
    dict set assocattrs DstClass\
        [namespace current]::${domain}::[dict get $assocattrs DstClass]
    set prev [dict get $assocattrs PrevSrcClass]
    if {$prev ne {}} {
        dict set assocattrs PrevSrcClass [namespace current]::${domain}::$prev
    }

    relvar eval {
        relvar insert [namespace current]::${domain}::__Arch::__Link $linkattrs
        relvar insert [namespace current]::${domain}::__Arch::__AssociationLink\
                $assocattrs
    }
}

proc addParitionLink {domain linkattrs partattrs} {
    dict set linkattrs Class\
        [namespace current]::${domain}::[dict get $linkattrs Class]
    dict set partattrs DstClass\
        [namespace current]::${domain}::[dict get $partattrs DstClass]
    dict set partattrs SrcClass\
        [namespace current]::${domain}::[dict get $partattrs SrcClass]
    relvar eval {
        relvar insert [namespace current]::${domain}::__Arch::__Link $linkattrs
        relvar insert [namespace current]::${domain}::__Arch::__PartitionLink\
                $partattrs
    }
}
----

==== Create an Instance

The +create+ command creates instances.
If the class has a state model, then the instance is placed in the
initial state.
The return value is a instance reference to the newly created instance.

(((rosea,ClassCmds,create)))
[source,tcl]
----
<<class commands>>=
proc create {relvar args} {
    set ref [ToRef $relvar [relvar insert $relvar $args]] ; # <1>
    lassign [SplitRelvarName $relvar] domain class
    set initstate [relvar restrictone ${domain}::__Arch::__InitialState\
        Class $relvar] ; # <2>
    if {[relation isnotempty $initstate]} {
        CreateInstanceState $domain $class [relation extract $initstate State]\
                [lindex $ref 1]
    }
    return $ref
}
----
<1> Here we see the correspondence between an XUML class instance and
a tuple in a relvar.
The instance is create by inserting a tuple into the relvar.
<2> If there is a state model associated with the class,
then there will be an initial state defined.
In that case, we must add a tuple to the +\__<class>\__INSTANCE+
relvar so we can track the current state for event transitions.

[source,tcl]
----
<<class command tests>>=
test create-1.0 {
    Create an instance -- no state model
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
} -cleanup {
    cleanupDomain foo
} -body {
    rosea::ClassCmds::create [namespace current]::foo::c1 A1 20 A2 bar
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 20}}}} -match ref
----

==== Create an Instance In a Given State

(((rosea,ClassCmds,createin)))
[source,tcl]
----
<<class commands>>=
proc createin {relvar state args} {
    lassign [SplitRelvarName $relvar] domain class
    set initstate [relvar restrictone ${domain}::__Arch::__State\
        Class $relvar State $state]
    if {[relation isempty $initstate]} {
        tailcall DeclError UNKNOWN_STATE $state $relvar
    }
    set ref [ToRef $relvar [relvar insert $relvar $args]]
    CreateInstanceState $domain $class $state [lindex $ref 1]
    return $ref
}
----

(((error code,UNKNOWN_STATE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_STATE   {unknown state, "%s", for class, "%s"}
----

[source,tcl]
----
<<class command tests>>=
test createin-1.0 {
    Create an instance in a given state
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addState foo Class c1 State Idle
    addInitialState foo Class c1 State Idle
} -cleanup {
    cleanupDomain foo
} -body {
    set ref [::rosea::ClassCmds::createin [namespace current]::foo::c1\
        Idle A1 40 A2 bar]
    set statetest [pipe {
        relvar restrictone ::rosea::test::foo::__c1__INSTANCE A1 40 |
        relation extract ~ __State
    }]
    expr {$statetest eq "Idle" &&\
        [refMatch {::rosea::test::foo::c1 {{A1 int} {{A1 40}}}} $ref]}
} -result {1}
----

We factor some common code to create the instance tuple that tracks
the state of the instance into a procedure.

[source,tcl]
----
<<class commands>>=
proc CreateInstanceState {domain class state value} {
    set tuple [concat\
        [tuple get [relation tuple $value]]\
        [list __State $state]\
    ]
    relvar insert ${domain}::__${class}__INSTANCE $tuple
    return
}
----

==== Asynchronous Instance Creation

(((rosea,ClassCmds,signal)))

[source,tcl]
----
<<class commands>>=
proc createasync {relvar event eventparams args} {
    set event [relvar restrictone\
        [namespace qualifiers $relvar]::__Arch::__TransitionEVENT\
        Class $relvar Event $event]
    if {[relation isempty $event]} {
        tailcall DeclError UNKNOWN_EVENT $event $relvar
    }
    set instref [createin $relvar @ {*}$args]
    ::rosea::InstCmds signal $instref $event {*}$eventparams
    return $instref
}
----

(((error code,UNKNOWN_STATE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_EVENT   {unknown event, "%s", for class, "%s"}
----

==== Delete an Instance

(((rosea,ClassCmds,delete)))

[source,tcl]
----
<<class commands>>=
proc delete {relvar instref} {
    lassign $instref refrelvar refinsts
    if {$refrelvar ne $relvar} {
        tailcall DeclError WRONG_RELVAR $refrelvar $relvar
    }
    set deleted 0
    relation foreach inst $refinsts {
        incr deleted [relvar deleteone $relvar\
            {*}[tuple get [relation tuple $inst]]]
    }

    lassign [SplitRelvarName $relvar] domain class
    set instrelvar ${domain}::__${class}__INSTANCE
    if {[relvar exists $instrelvar]} {
        relation foreach inst $refinsts {
            relvar deleteone $instrelvar {*}[tuple get [relation tuple $inst]]]
        }
    }
    return $deleted
}
----

(((error code,WRONG_RELVAR)))
[source,tcl]
----
<<error code formats>>=
WRONG_RELVAR   {instance associated with relvar, "%s", expected "%s"}
----

==== Updating Class Values

(((rosea,ClassCmds,update)))

[source,tcl]
----
<<class commands>>=
proc update {relvar relvalue} {
    tailcall relvar updateper $relvar $relvalue
}
----

=== Relationship Commands

[source,tcl]
----
<<relationship commands namespace>>=
namespace eval RelCmds {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers
    <<relationship data>>
    <<relationship commands>>
}
----

==== Linking Instances Across Relationships

Linking Instances Across Relationships

[source,tcl]
----
<<relationship commands>>=
proc linkSimple {rname instref1 instref2} {
    lassign $instref1 relvar1 inst1
    set domain1 [namespace qualifiers $relvar1]

    lassign $instref2 relvar2 inst2
    set domain2 [namespace qualifiers $relvar2]

    if {$domain1 ne $domain2} {
        error "cannot link across domains"
    }

    set archns ${domain1}::__Arch

    set reflink [relvar restrictone ${archns}::__RefLink Relationship $rname]
    if {[relation isempty $reflink]} {
        error "unknown relationship $rname"
    }
    relation assign $reflink\
        {ReferringClass referringClass}\
        {ReferencedClass referencedClass}\
        {ReferringAttrs referringAttrs}

    if {$relvar1 eq $referringClass && $relvar2 eq $referencedClass} {
        set rgrelvar $relvar1
        set rginst $inst1
        set rtrelvar $relvar2
        set rtinst $inst2
    } elseif {$relvar2 eq $referringClass && $relvar1 eq $referencedClass} {
        set rgrelvar $relvar2
        set rginst $inst2
        set rtrelvar $relvar1
        set rtinst $inst1
    } else {
        error "$relvar1 and $relvar2 don't participate in $rname,\
                expected $referringClass and $referencedClass"
    }

    if {[relation cardinality $rtinst] != 1} {
        error "referred to reference must be singular"
    }

    set rtrelvalue [pipe {
        relvar set $rtrelvar |
        relation semijoin $rtinst ~ 
    }]

    set rtattrvalue [pipe {
        relation extend $referringAttrs rfa RefValue string {
            [relation extract $rtrelvalue\
                [tuple extract $rfa ReferencedAttribute]]
        } |
        relation dict ~ ReferringAttribute RefValue
    }]

    relation foreach linkinst $rginst {
        relvar updateone $rgrelvar rgtup\
                [tuple get [relation tuple $linkinst]] {
            tuple update $rgtup {*}$rtattrvalue
        }
    }

    return
}
----

[source,tcl]
----
<<relationship commands>>=
proc linkAssoc {rname instref1 instref2 args} {
    lassign $instref1 relvar1 inst1
    set domain1 [namespace qualifiers $relvar1]

    lassign $instref2 relvar2 inst2
    set domain2 [namespace qualifiers $relvar2]

    if {$domain1 ne $domain2} {
        error "cannot link across domains"
    }

    set archns ${domain1}::__Arch

    set assocref [relvar restrictone ${archns}::__AssocRef Relationship $rname]
    if {[relation isempty $assocref]} {
        error "unknown relationship $rname"
    }

    relation assign $assocref\
        {AssocClass assocClass}\
        {References references}

    set ref1 [relation restrictwith $references {$Participant eq $relvar1}]
    if {[relation isempty $ref1]} {
        error "$relvar1 not a participant in $rname"
    }
    if {[relation cardinality $ref1] > 1} {
        set ref2 [relation restrictwith $ref1 {$Role eq "target"}]
        set ref1 [relation minus $ref1 $ref2]
    } else {
        set ref2 [relation restrictwith $references {$Participant eq $relvar2}]
        if {[relation isempty $ref2]} {
            error "$relvar2 not a participant in $rname"
        }
    }

    set values1 [pipe {
        relvar set $relvar1 |
        relation semijoin $inst1 ~
    }]
    set values2 [pipe {
        relvar set $relvar2 |
        relation semijoin $inst2 ~
    }]

    set rattr1 [relation extract $ref1 ReferringAttrs]
    set rattr2 [relation extract $ref2 ReferringAttrs]

    set assoctuples [list]
    relation foreach v1 $values1 {
        set refto1 [pipe {
            relation extend $rattr1 rfa RefValue string {
                [relation extract $v1 [tuple extract $rfa ReferencedAttribute]]
            } |
            relation dict ~ ReferringAttribute RefValue
        }]
        relation foreach v2 $values2 {
            set refto2 [pipe {
                relation extend $rattr2 rfa RefValue string {
                    [relation extract $v2\
                        [tuple extract $rfa ReferencedAttribute]]
                } |
                relation dict ~ ReferringAttribute RefValue
            }]

            lappend assoctuples [dict merge $args $refto1 $refto2]
        }
    }

    return [ToRef $assocClass [relvar insert $assocClass {*}$assoctuples]]
}
----

==== Unlinking Instances Across Relationships

Unlinking Instances Across Relationships

[source,tcl]
----
<<relationship commands>>=
proc unlinkSimple {rname instref} {
    lassign $instref relvar inst

    set archns [namespace qualifiers $relvar]::__Arch

    set reflink [relvar restrictone ${archns}::__RefLink Relationship $rname]
    if {[relation isempty $reflink]} {
        error "unknown relationship $rname"
    }
    relation assign $reflink\
        {ReferringClass referringClass}\
        {ReferencedClass referencedClass}\
        {ReferringAttrs referringAttrs}

    if {$relvar eq $referringClass} {
        set rgrelvar $relvar
        set rginst $inst
    } elseif {$relvar eq $referencedClass} {
        lassign [::rosea::InstCmds::findRelated $instref ~$rname]\
            rgrelvar rginst
    } else {
        error "$relvar doesn't participate in $rname,\
                expected $referringClass or $referencedClass"
    }

    set rtattrvalue [pipe {
        relation extend $referringAttrs rfa RefValue string {{}} |
        relation dict ~ ReferringAttribute RefValue
    }]

    relation foreach linkinst $rginst {
        relvar updateone $rgrelvar rgtup\
                [tuple get [relation tuple $linkinst]] {
            tuple update $rgtup {*}$rtattrvalue
        }
    }

    return
}
----

[source,tcl]
----
<<relationship commands>>=
proc unlinkAssoc {rname instref} {
}
----

==== Migrating Subclasss Across Generalizations

For the case of generalization relationships,
the notion of linking and unlinking across the relationship
doesn't make much sense.
To understand why,
recall that in the XUML usage a generalization relationship
partitions the superclass instances into a disjoint union of
the subclasses.
This means that each subclass instance is unconditionally related
to exactly one superclass instance.
If you were to unlink a subclass from its superclass the only operations
that would not violate referential integrity is to link a
new subclass instance or delete both the superclass and subclass instances.
So the only meaningful operation that does not violate referential integrity
is to _migrate_ a subclass instance.
Conceptually, migration consists of:

* Unlink the superclass and subclass.
* Delete the subclass instance.
* Create a new instance of a subclass of the generalization.
* Link the new instance to the superclass.

One additional complication is that the newly created subclass instance
may have attributes that need to be set.

[source,tcl]
----
<<relationship commands>>=
proc migrate {rname instref subclass args} {
    lassign $instref relvar inst
    set domns [namespace qualifiers $relvar]
    set archns ${domns}::__Arch

    namespace upvar ${archns}\
            __AssociationLink AssociationLink

    set link [pipe {
        relvar restrictone ${archns}::__Link Name $rname Class $relvar |
        relation join ~ $AssociationLink -using {Name Name Class SrcClass}
    }]
    if {[relation isempty $link]} {
        error "no relationship $rname to superclass $relvar"
    }
    #puts [relformat $link link]
    set superinst [pipe {
        relvar set [relation extract $link DstClass] |
        relation semijoin $inst ~ -using [relation extract $link Attrs]
    }]

    set sublink [relvar restrictone ${archns}::__SubLink Relationship $rname\
            SubClass ${domns}::$subclass]
    if {[relation isempty $sublink]} {
        error "no subclass, $subclass"
    }
    #puts [relformat $sublink sublink]
    set refedvalues [pipe {
        relation extract $sublink AttrRefs |
        relation extend ~ rval Value string {
            [relation extract $superinst\
                [tuple extract $rval ReferencedAttribute]]
        } |
        relation dict ~ ReferringAttribute Value
    }]

    relvar eval {
        ::rosea::ClassCmds::delete $relvar $instref
        set ref [::rosea::ClassCmds::create ${domns}::$subclass\
                {*}[dict merge $args $refedvalues]]
    }
    return $ref
}
----

=== Instance Commands

[source,tcl]
----
<<instance commands namespace>>=
namespace eval InstCmds {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers
    <<instance data>>
    <<instance commands>>
}
----

==== Finding Related Instances

[source,tcl]
----
<<instance data>>=
pipe {
    relvar set $DstClass |
    relation $op $related ~ -using $Attrs
} relatedQuery

pipe {
    relation semijoin $assoc $AssociationLink\
            -using {Name Name SrcClass PrevSrcClass} |
    relation join ~ $Link -using {Name Name SrcClass Class}
} nextlinkQuery

<<instance commands>>=
proc FindRelatedInsts {instref op args} {
    set srcrelvar [lindex $instref 0]
    lassign [SplitRelvarName $srcrelvar] domain

    namespace upvar ${domain}::__Arch\
            __Link Link\
            __AssociationLink AssociationLink\
            __PartitionLink PartitionLink
    variable relatedQuery
    variable nextlinkQuery

    set related [deRef $instref]
    foreach linkage $args {
        lassign $linkage lname dst

        set linkclass [expr {$dst eq {} ? $srcrelvar : "${domain}::$dst"}]
        set link [relvar restrictone ${domain}::__Arch::__Link\
                Name $lname Class $linkclass]
        if {[ral relation isempty $link]} {
            tailcall DeclError UNKNOWN_LINKAGE $lname $linkclass
        }
        set assoc [relation join $AssociationLink $link\
                -using {Name Name SrcClass Class}]
        if {[relation isnotempty $assoc]} {
            relation assign $assoc SrcClass DstClass Attrs
            if {$SrcClass ne $srcrelvar} {
                tailcall DeclError PATH_ERROR $lname $SrcClass $DstClass\
                    $srcrelvar
            }

            set related [eval $relatedQuery]
            set assoc [eval $nextlinkQuery]
            if {[relation isnotempty $assoc]} {
                relation assign $assoc DstClass Attrs
                set related [eval $relatedQuery]
            }
        } else {
            set partition [relation join $PartitionLink $link\
                -using {Name Name DstClass Class}]
            relation assign $partition SrcClass DstClass Attrs
            if {$SrcClass ne $srcrelvar} {
                tailcall DeclError PATH_ERROR $linkage $srcrelvar
            }

            set related [eval $relatedQuery]
        }
        set srcrelvar $DstClass
    }

    return [list $srcrelvar $related]
}
----

(((error code,UNKNOWN_LINKAGE)))
(((error code,PATH_ERROR)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_LINKAGE {unknown relationship, "%s", for class, "%s"}
PATH_ERROR      {relationship, "%s", from "%s" to "%s", does not start at "%s"}
----

[source,tcl]
----
<<instance commands>>=
namespace export findRelated
proc findRelated {instref args} {
    tailcall ToRef {*}[FindRelatedInsts $instref semijoin {*}$args]
}

namespace export findUnrelated
proc findUnrelated {instref args} {
    tailcall ToRef {*}[FindUnRelatedInsts $instref semiminus {*}$args]
}

namespace export findRelatedWhere
proc findRelatedWhere {instref rchain expr} {
    lassign [FindRelatedInst $instref semijoin {*}$rchain] relvar insts
    tailcall ToRef $relvar [uplevel 1 ral relation restrictwith $insts $expr]
}

namespace export findUnrelatedWhere
proc findUnrelatedWhere {instref rchain expr} {
    lassign [FindRelatedInst $instref semiminus {*}$rchain] relvar insts
    tailcall ToRef $relvar [uplevel 1 ral relation restrictwith $insts $expr]
}
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.0 {
    Navigate a relationship -- simple association
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addClass foo c2 {B1 int B2 string} B1
    addAssocLink foo {Name R1 Class c1 Attrs {A1 B1}}\
        {Name R1 SrcClass c1 DstClass c2 PrevSrcClass {}}
    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {::rosea::test::foo::c2 {{B1 int} {{B1 5}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.1 {
    Navigate a relationship -- multiple simple association
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addClass foo c2 {B1 int B2 string} B1
    addClass foo c3 {C1 int C2 string} C1

    addAssocLink foo {Name R1 Class c1 Attrs {A1 B1}}\
        {Name R1 SrcClass c1 DstClass c2 PrevSrcClass {}}
    addAssocLink foo {Name R2 Class c2 Attrs {B1 C1}}\
        {Name R2 SrcClass c2 DstClass c3 PrevSrcClass {}}

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
    rosea::ClassCmds::create [namespace current]::foo::c3 C1 5 C2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1 R2
} -result {::rosea::test::foo::c3 {{C1 int} {{C1 5}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.2 {
    Navigate a relationship -- unknown link
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {unknown relationship, "R1", for class, "::rosea::test::foo::c1"}\
-returnCodes error
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.3 {
    Navigate a relationship -- bad path
} -setup {
    setupDomain foo
    addClass foo X {A1 int A2 string} A1
    addClass foo Y {B1 int B2 string} B1
    addClass foo A {A1 int B1 int} {A1 B1}
    addClass foo c1 {A1 int A2 string} A1

    # Forward direction is from X -> Y via A
    addAssocLink foo {Name R1 Class X Attrs {A1 A1}}\
        {Name R1 SrcClass X DstClass A PrevSrcClass {}}
    addAssocLink foo {Name R1 Class A Attrs {B1 B1}}\
        {Name R1 SrcClass A DstClass Y PrevSrcClass X}
    addAssocLink foo {Name ~R1 Class Y Attrs {B1 B1}}\
        {Name ~R1 SrcClass Y DstClass A PrevSrcClass {}}
    addAssocLink foo {Name ~R1 Class A Attrs {A1 A1}}\
        {Name ~R1 SrcClass A DstClass X PrevSrcClass Y}
    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref {R1 A}
} -result {relationship, "R1", from "::rosea::test::foo::A" to\
    "::rosea::test::foo::Y", does not start at "::rosea::test::foo::c1"}\
-returnCodes error
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-2.0 {
    Navigate a relationship -- associative class
} -setup {
    setupDomain foo
    addClass foo X {A1 int A2 string} A1
    addClass foo Y {B1 int B2 string} B1
    addClass foo A {A1 int B1 int} {A1 B1}
    # Forward direction is from X -> Y via A
    addAssocLink foo {Name R1 Class X Attrs {A1 A1}}\
        {Name R1 SrcClass X DstClass A PrevSrcClass {}}
    addAssocLink foo {Name R1 Class A Attrs {B1 B1}}\
        {Name R1 SrcClass A DstClass Y PrevSrcClass X}
    addAssocLink foo {Name ~R1 Class Y Attrs {B1 B1}}\
        {Name ~R1 SrcClass Y DstClass A PrevSrcClass {}}
    addAssocLink foo {Name ~R1 Class A Attrs {A1 A1}}\
        {Name ~R1 SrcClass A DstClass X PrevSrcClass Y}

    set ref [rosea::ClassCmds::create [namespace current]::foo::X A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::Y B1 10 B2 bar
    rosea::ClassCmds::create [namespace current]::foo::A A1 5 B1 10
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {::rosea::test::foo::Y {{B1 int} {{B1 10}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-3.0 {
    Navigate a generalization
} -setup {
    setupDomain foo
    addClass foo S {S1 int S2 string} S1
    addClass foo X {X1 int X2 string} X1
    addClass foo Y {Y1 int Y2 string} Y1

    addAssocLink foo {Name R1 Class X Attrs {X1 S1}}\
        {Name R1 SrcClass X DstClass S PrevSrcClass {}}
    addParitionLink foo {Name ~R1 Class X Attrs {S1 X1}}\
        {Name ~R1 DstClass X SrcClass S}
    addAssocLink foo {Name R1 Class Y Attrs {Y1 S1}}\
        {Name R1 SrcClass Y DstClass S PrevSrcClass {}}
    addParitionLink foo {Name ~R1 Class Y Attrs {S1 Y1}}\
        {Name ~R1 DstClass Y SrcClass S}

    set ref [rosea::ClassCmds::create [namespace current]::foo::S S1 5 S2 baz]
    rosea::ClassCmds::create [namespace current]::foo::X X1 5 X2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref {~R1 X}
} -result {::rosea::test::foo::X {{X1 int} {{X1 5}}}} -match ref
----

==== Updating Instances

[source,tcl]
----
<<required packages>>=
package require struct::set
----

[source,tcl]
----
<<instance commands>>=
namespace export updateAttribute
proc updateAttribute {ref args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_ERROR $args
    }

    lassign $ref relvar insts
    set idupdates [::struct::set intersect $args [relation attributes $insts]]
    if {![::struct::set empty $idupdates]} {
        tailcall DeclError ID_UPDATE $idupdates
    }

    set cmd [list relation extend $insts exttuple]
    set heading [relation heading [relvar set $relvar]]
    foreach {attr value} $args {
        lappend cmd $attr [dict get $heading $attr] \"$value\"
    }
    relvar updateper $relvar [eval $cmd]
    return
}
----

(((error code,ARG_ERROR)))
(((error code,ID_UPDATE)))
[source,tcl]
----
<<error code formats>>=
ARG_ERROR      {attribute updates must be name / value pairs, got "%s"}
ID_UPDATE      {cannot update identifying attributes, "%s"}
----

[source,tcl]
----
<<instance command tests>>=
test updateAttribute-1.0 {
    Update single attribute value
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::updateAttribute $ref A2 foo
    relation extract [::rosea::Helpers::deRef $ref] A2
} -result {foo}
----

[source,tcl]
----
<<instance command tests>>=
test updateAttribute-1.1 {
    Update multiple attribute values
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string A3 int} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1\
            A1 5 A2 baz A3 27]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::updateAttribute $ref A3 42 A2 foo
    relation extract [::rosea::Helpers::deRef $ref] A2 A3
} -result {foo 42}
----

==== Reading Instances

[source,tcl]
----
<<instance commands>>=
namespace export readAttribute
proc readAttribute {ref args} {
    if {![isRefSingular $ref]} {
        tailcall DeclError SINGLE_REF_REQUIRED [refMultiplicity $dstref]
    }

    return [expr {[llength $args] == 0 ? {} :\
        [relation extract [deRef $ref {*}$args] {*}$args]}]
}
----

[source,tcl]
----
<<instance command tests>>=
test readAttribute-1.0 {
    Read single attribute value
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::readAttribute $ref A2
} -result {baz}
----

[source,tcl]
----
<<instance command tests>>=
test readAttribute-1.1 {
    Read multiple attribute values
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::readAttribute $ref A1 A2
} -result {5 baz}
----

==== Signaling Instances

[source,tcl]
----
<<helper commands>>=
proc SelfInstRef {{level 2}} {
    upvar $level self srcself
    return [expr {[info exists srcself] ? $srcself : {{} {{} {}}}}]
}
----

[source,tcl]
----
<<instance commands>>=
namespace export signal
proc signal {dstset event args} {
    set srcref [SelfInstRef]
    if {![::rosea::Dispatch::MapPolymorphicEvent ::rosea::Dispatch::SignalEvent\
            $srcref $dstset $event $args]} {
        ::rosea::Dispatch::SignalEvent $srcref $dstset $event $args
    }
    return
}
----

[source,tcl]
----
<<instance commands>>=
namespace export delaysignal
proc delaysignal {time dstset event args} {
    if {!([string is integer -strict $time] && $time >= 0)} {
        tailcall DeclError INVALID_TIME $time
    }
    set srcref [SelfInstRef]
    if {![::rosea::Dispatch::MapPolymorphicEvent\
            [list ::rosea::Dispatch::SignalDelayedEvent $time]\
            $srcref $dstset $event $args]} {
        ::rosea::Dispatch::SignalDelayedEvent $time $srcref $dstset $event $args
    }
    return
}
----

(((error code,INVALID_TIME)))
[source,tcl]
----
<<error code formats>>=
INVALID_TIME    {invalid time value, "%s"}
----

[source,tcl]
----
<<instance commands>>=
namespace export canceldelayed
proc canceldelayed {srcref dstset event} {
    set srcmult [refMultiplicity $srcref]
    if {$srcmult > 1} {
        tailcall DeclError SINGLE_REF_REQUIRED $srcmult
    }
    forAllRefs dstref $dstset {
        ::rosea::Dispatch::CancelDelayedSignal $srcref $event $dstref
    }
    return
}
----

(((error code,INVALID_TIME)))
[source,tcl]
----
<<error code formats>>=
SINGLE_REF_REQUIRED     {single valued reference required, %d found}
----

[source,tcl]
----
<<instance commands>>=
namespace export delayremaining
proc delayremaining {srcref dstref event} {
    set srcmult [refMultiplicity $srcref]
    if {$srcmult > 1} {
        tailcall DeclError SINGLE_REF_REQUIRED $srcmult
    }
    if {![isRefSingular $dstref]} {
        tailcall DeclError SINGLE_REF_REQUIRED [refMultiplicity $dstref]
    }
    tailcall ::rosea::Dispatch::SignalTimeRemaining $srcref $event $dstref
}
----

=== Dispatch Commands

[source,tcl]
----
<<dispatch commands namespace>>=
namespace eval Dispatch {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers
    <<dispatch data>>
    <<dispatch commands>>
}
----

[source,tcl]
----
<<dispatch commands>>=
proc MapPolymorphicEvent {frwdcmd srcref dstrefs event arglist} {
    lassign $dstrefs dstrelvar dstinsts ; # <1>
    set archns [namespace qualifiers $dstrelvar]::__Arch
    set polyevent [relvar restrictone ${archns}::__PolymorphicEvent\
        Class $dstrelvar Event $event]
    if {[relation isempty $polyevent]} {
        return false
    }

    variable polymapQuery
    set partitions [eval $polymapQuery] ; # <2>

    relation foreach inst $dstinsts { # <3>
        relation foreach partition $partitions {
            relation assign $partition
            relation foreach dstlink $DstLinks {
                relation assign $dstlink
                set related [relation semijoin $inst [relvar set $DstClass]\
                    -using $Attrs] ; # <4>
                if {[relation isnotempty $related]} {
                    {*}$frwdcmd $srcref [ToRef $DstClass $related] $event\
                            $arglist
                    break
                }
            }
        }
    }
    return true
}
----
<1> First we must determine if the event is polymorphic.
If not, then we just return and the event will be signaled as a
transition event.
<2> See query explanation <<polymapQuery,below>>.
<3> There are three nested iterations.
The outside loop iterates over the superclass instances
since we may be signaling several instances in the same call.
The next iteration is over all the hierarchies that orginate from
the superclass.
Typically, this is only one, but it can be several for a compound
generalization.
Finally, we iterate over all the subclass links.
<4> We must traverse the relationship to find the one subclass that is
actually linked and forward the event on to that one.
Once forwarding has happened, we can stop looking any futher since
we _know_ that there is exactly one subclass linked up to any given
superclass instance because the partition constraint enforces that.

[[polymapQuery,polymorphic event query]]
The essential query for dispatching a polymorphic event is to find the set of
hierarchies originating at the source relvar.

[source,tcl]
----
<<dispatch data>>=
pipe {
    relvar set ${archns}::__PartitionLink |
    relation restrictwith ~ {$SrcClass eq $dstrelvar} |
    relation join ~ [relvar set ${archns}::__Link]\
        -using {Name Name DstClass Class} |
    relation group ~ DstLinks DstClass Attrs
} polymapQuery
----

This query is accomplished by finding all the partition link tuples that
originate at the relvar which is the target of the event signaling.
These are joined with the link superclass to pick up the attributes
that are used to relate tuples across the partition.
The result of the join is grouped so we may consider all the superclass to
subclass links for a given hierarchy.
We want to do this because we know that a superclass instance will reference
exactly one subclass from among all the subclasses in the generalization and
it is to that subclass instance that the event will be forwarded.

The heading of the result of this query will be:

[width="50%",options="header",title="Heading of Polymorphic Event Mapping Query Result"]
|=========================
    |Name       |SrcClass   2+^h|DstLinks
    |string     |string     2+^|Relation
1.2+|       1.2+|             h|DstClass     h|Attrs
                               |string        |list
|=========================

Note that the *DstLinks* attribute is relation valued.footnote:[That is what
the +group+ operation does]

[source,tcl]
----
<<test utility procs>>=
proc addPolymorphic {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__Arch::__PolymorphicEvent\
            $args
}

proc polysignal {srcref dstref event paramlist} {
    puts -nonewline [info level 0]
}
----

[source,tcl]
----
<<dispatch command tests>>=
test MapPolymorphicEvent-1.0 {
    Map a polymorphic event
} -setup {
    setupDomain bar
    addClass bar S {S1 int S2 string} S1
    addClass bar X {X1 int X2 string} X1
    addClass bar Y {Y1 int Y2 string} Y1

    addAssocLink bar {Name R1 Class X Attrs {X1 S1}}\
        {Name R1 SrcClass X DstClass S PrevSrcClass {}}
    addParitionLink bar {Name ~R1 Class X Attrs {S1 X1}}\
        {Name ~R1 DstClass X SrcClass S}
    addAssocLink bar {Name R1 Class Y Attrs {Y1 S1}}\
        {Name R1 SrcClass Y DstClass S PrevSrcClass {}}
    addParitionLink bar {Name ~R1 Class Y Attrs {S1 Y1}}\
        {Name ~R1 DstClass Y SrcClass S}

    addPolymorphic bar Class S Event e1
    set ref [rosea::ClassCmds::create [namespace current]::bar::S S1 5 S2 baz]
    rosea::ClassCmds::create [namespace current]::bar::X X1 5 X2 bar
} -cleanup {
    cleanupDomain bar
} -body {
    rosea::Dispatch::MapPolymorphicEvent [namespace current]::polysignal\
        {} $ref e1 {}
} -result {true} -output {::rosea::test::polysignal {} {::rosea::test::bar::X {{X1 int} {{X1 5}}}} e1 {}}
----

[source,tcl]
----
<<dispatch data>>=
variable event_queue [list]
----

[source,tcl]
----
<<dispatch commands>>=
proc SignalEvent {srcref dstset event arglist} {
    variable event_queue
    forAllRefs dstref $dstset {
        set eventInfo [dict create\
            src $srcref\
            event $event\
            dst $dstref\
            params $arglist\
        ]
        if {[isRefEqual $srcref $dstref]} {
            set eqindex 0
            foreach cmpevent $event_queue {
                if {![isRefEqual [dict get $cmpevent src]\
                        [dict get $cmpevent dst]]} {
                    break
                }
                incr eqindex
            }
            set event_queue [linsert $event_queue $eqindex $eventInfo]
        } else {
            lappend event_queue $eventInfo
        }
        ::after 0 [namespace code DispatchEvent]
    }
}
----

[source,tcl]
----
<<dispatch command tests>>=
test SignalEvent-1.0 {
    Signal an event
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addState foo Class c1 State s1
    addState foo Class c1 State s2
    addEvent foo Class c1 Event e1
    addInitialState foo Class c1 State s1
    addTransition foo Class c1 State s1 Event e1 NewState s2

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::InstCmds::signal $ref e1
} -cleanup {
    after cancel [namespace eval ::rosea::Dispatch namespace code DispatchEvent]
    cleanupDomain foo
} -body {
    set event [lindex $::rosea::Dispatch::event_queue 0]
    dict get $event dst
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
----

[source,tcl]
----
<<dispatch commands>>=
proc DispatchEvent {} {
    variable event_queue
    if {[llength $event_queue] != 0} {
        # Pull the event from the front of the queue.
        set eventInfo [lindex $event_queue 0]
        set event_queue [lrange $event_queue 1 end]

        set dstref [dict get $eventInfo dst]
        lassign $dstref relvar ref
        lassign [SplitRelvarName $relvar] domain class
        set archns ${domain}::__Arch

        set instrelvar ${domain}::__${class}__INSTANCE
        set state [relation semijoin $ref [relvar set $instrelvar]]
        if {[relation isempty $state]} {
            tailcall DeclError EVENT_IN_FLIGHT [dict get $eventInfo event]\
                $ref
        }
        set currstate [relation extract $state __State]
        set event [dict get $eventInfo event]

        set newState [pipe {
            relvar restrictone ${archns}::__Transition\
                Class $relvar State $currstate Event $event |
            relation extract ~ NewState
        }]

        if {$newState eq "CH"} {
            tailcall DeclError CANT_HAPPEN_EVENT [dict get $eventInfo src]\
                $event $dstref $currstate
        } elseif {$newState ne "IG"} {
            set idattrs [tuple get [ral relation tuple $ref]]
            relvar updateone $instrelvar is $idattrs {
                tuple update $is __State $newState
            }
            try {
                relvar eval {
                    ${relvar}::__Activity::$newState $dstref\
                            {*}[dict get $eventInfo params]
                }
            } finally {
                set term [relvar restrictone ${domain}::__Arch::__Terminal\
                        Class $relvar State $newState]
                if {[relation isnotempty $term]} {
                    relvar deleteone $relvar {*}$idattrs
                    relvar deleteone $instrelvar {*}$idattrs
                }
            }
        }
    }
    return
}
----

(((error code,EVENT_IN_FLIGHT)))
(((error code,CANT_HAPPEN_EVENT)))
[source,tcl]
----
<<error code formats>>=
EVENT_IN_FLIGHT     {event, "%s", sent to "%s", which does not exist}
CANT_HAPPEN_EVENT   {can't happen transition, %s - %s -> %s ==> %s -> CH}
----

[source,tcl]
----
<<dispatch command tests>>=
test DispatchEvent-1.0 {
    Dispatch an event and execute a state action
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addState foo Class c1 State s1
    addState foo Class c1 State s2
    addEvent foo Class c1 Event e1
    addInitialState foo Class c1 State s1
    addTransition foo Class c1 State s1 Event e1 NewState s2
    proc [namespace current]::foo::c1::__Activity::s2 {self} {
        set ::done $self
    }

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::InstCmds::signal $ref e1
} -cleanup {
    cleanupDomain foo
} -body {
    vwait ::done
    set ::done
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
----

[source,tcl]
----
<<dispatch data>>=
relvar create __DELAYEDSIGNAL {
    SrcInstRef      list
    Event           string
    DstInstRef      list
    TimerId         string
    Expire          bignum
} {SrcInstRef Event DstInstRef}
----

[source,tcl]
----
<<dispatch commands>>=
proc SignalDelayedEvent {time srcref dstset event arglist} {
    forAllRefs dstref $dstset {
        # Cancel any existing delayed signal that might have been in place.
        CancelDelayedSignal $srcref $event $dstref
        relvar insert __DELAYEDSIGNAL [list\
            SrcInstRef  $srcref\
            Event       $event\
            DstInstRef  $dstref\
            TimerId     [::after $time\
                        [list ::rosea::Dispatch::DispatchDelayedEvent\
                            $srcref $event $dstref $arglist]]\
            Expire      [expr {entier([clock milliseconds]) + entier($time)}]\
        ]
    }
    return
}
----

[source,tcl]
----
<<dispatch commands>>=
proc DispatchDelayedEvent {srcref event dstref params} {
    DeleteDelayedSignal $srcref $event $dstref
    variable event_queue
    lappend event_queue [dict create\
        src $srcref\
        event $event\
        dst $dstref\
        params $params\
    ]
    tailcall DispatchEvent
}
----

[source,tcl]
----
<<dispatch command tests>>=
test DispatchDelayedEvent-1.0 {
    Dispatch a delayed event and execute a state action
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addState foo Class c1 State s1
    addState foo Class c1 State s2
    addEvent foo Class c1 Event e1
    addInitialState foo Class c1 State s1
    addTransition foo Class c1 State s1 Event e1 NewState s2
    proc [namespace current]::foo::c1::__Activity::s2 {self} {
        set ::done $self
    }

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::InstCmds::delaysignal 100 $ref e1
} -cleanup {
    cleanupDomain foo
} -body {
    vwait ::done
    set ::done
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
----

[source,tcl]
----
<<dispatch commands>>=
proc CancelDelayedSignal {srcref event dstref} {
    variable __DELAYEDSIGNAL
    set sig [FindDelayedSignal $srcref $event $dstref]
    if {[relation isnotempty $sig]} {
        ::after cancel [relation extract $sig TimerId]
        DeleteDelayedSignal $srcref $event $dstref
    }
}
----

[source,tcl]
----
<<dispatch command tests>>=
test CancelDelayedSignal-1.0 {
    Cancel a delayed event
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addState foo Class c1 State s1
    addState foo Class c1 State s2
    addEvent foo Class c1 Event e1
    addInitialState foo Class c1 State s1
    addTransition foo Class c1 State s1 Event e1 NewState s2

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    rosea::InstCmds::delaysignal 100 $ref e1
    set src {{} {{} {}}}
    rosea::InstCmds::canceldelayed $src $ref e1
    relation cardinality [rosea::Dispatch::FindDelayedSignal $src e1 $ref]
} -result {0}
----

[source,tcl]
----
<<dispatch commands>>=
proc SignalTimeRemaining {srcref event dstref} {
    set sig [FindDelayedSignal $srcref $event $dstref]
    if {[relation isnotempty $sig]} {
        set remaining [expr {[relation extract $sig Expire] -\
            [clock milliseconds]}]
        if {$remaining < 0} {
            set remaining 0
        }
    } else {
        set remaining 0
    }

    return $remaining
}
----

[source,tcl]
----
<<dispatch command tests>>=
test SignalTimeRemaining-1.0 {
    Obtain remaining time on a delayed signal
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addState foo Class c1 State s1
    addState foo Class c1 State s2
    addEvent foo Class c1 Event e1
    addInitialState foo Class c1 State s1
    addTransition foo Class c1 State s1 Event e1 NewState s2

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    rosea::InstCmds::delaysignal 100 $ref e1
    set src {{} {{} {}}}
    set remain [rosea::InstCmds::delayremaining $src $ref e1]
    rosea::InstCmds::canceldelayed $src $ref e1
    expr {$remain <= 100 && $remain >= 95}
} -result {1}
----

[source,tcl]
----
<<dispatch commands>>=
proc FindDelayedSignal {srcref event dstref} {
    variable __DELAYEDSIGNAL
    return [relation restrictwith $__DELAYEDSIGNAL {
            [isRefEqual $SrcInstRef $srcref] && $Event eq $event &&\
            [isRefEqual $DstInstRef $dstref]}]
}
----

[source,tcl]
----
<<dispatch commands>>=
proc DeleteDelayedSignal {srcref event dstref} {
    relvar delete __DELAYEDSIGNAL dsig {
        [isRefEqual [tuple extract $dsig SrcInstRef] $srcref] &&\
        [tuple extract $dsig Event] eq $event &&\
        [isRefEqual [tuple extract $dsig DstInstRef] $dstref]
    }
}
----

=== Helper Commands

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    <<tclral imports>>
    <<helper data>>
    <<helper commands>>
}
----

[source,tcl]
----
<<helper commands>>=
proc SplitRelvarName {relvar} {
    tailcall list [namespace qualifiers $relvar] [namespace tail $relvar]
}
----

[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list ROSEA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

== Configuration Language

In this section we consider the domain specific language (DSL) that is used
to configure a domain under +rosea+.
Let's use this opportunity to recap our intent.

+Rosea+ is divided into two main parts:

* A set of procedures that implement the run-time execution model.
These procedures are data-driven and assume the existence of particular
data structures and namespace organizations.
These are the procedures that have been described in the previous section.
* A configuration language to populate the data structures and organize
the namespaces as needed by the run-time mechanisms.

Strictly speaking, the configuration language will not do anything that
cannot be done manually.
Indeed,
as we have been testing the run-time mechanisms above,
we have done so using _ad hoc_ constructed data and namespaces.
But such an undertaking is too error prone for productive uses and
some type of configuration scheme is needed.
Configuring the run-time mechanisms via a DSL has the added benefit of creating
a well defined interface that will insulate the package user from minor changes
in the mechanisms.

The configuration DSL itself will be a Tcl script.
Commands in that script will define the aspects of a domain such
as its classes, attributes and relationships.
The DSL script will be evaluated in a context where the command names
will resolve without any qualification.

There are two basic approaches to the DSL that were considered.

* As each DSL command is executed, create the corresponding run-time
structure.
One can view that as a type of on-the-fly interpretation.
* Consume all the DSL commands, storing away any data that is required
and then generate the run-time structure at the end.

The first approach is certainly simpler to code
but has some decided disadvantages.
To create the run-time structure as each command is executed will impose
a rather strict ordering of the commands.
For example,
TclRAL insists that the participating relvars exist before a constraint
may be defined upon them.
This would imply that the DSL would have to be ordered in that way.
Also, defining state models needs some semantic checking to insure
a reasonable and consistent model is defined.
That checking is hard to do in an on-the-fly interpretation scheme.

These disadvantages lead us to choose the second alternative,
namely, build the configuration DSL commands to store away their data
and then generate the run-time structures from the stored data.
This approach requires significantly more programming but leads to
considerable flexibility.
It has the added benefit of allowing much easier and extensive
introspection of the domain than could be possible if we were just
examining the run-time structures themselves.


=== Config Namespace Layout

The +::rosea::Config+ namespace has a relatively more complex layout.
The reason for this is that we want to create a set of child namespaces
that mirror the nesting of the configuration language statements.
At the top level,
the +domain+ command is used to define each domain.
The +domain+ command accepts a script body that then defines the
components of the domain.
That script will be evaluated in a namespace where the commands that
define the domain components, _e.g._ +class+ and relationship commands,
resolve appropriately.
This lets us put commands for the body specifying a particular component into a
namespace which prevents any problems of accidentially invoking commands that
are inappropriate in that context of the DSL.

We layout the +::rosea::Config+ namespace as shown below.

[source,tcl]
----
<<configuration commands namespace>>=
namespace eval Config {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace path [namespace parent]::Helpers
    <<config data>>
    <<config commands>>
    <<domain config namespace layout>>
}
----

=== Evaluating Configuration Scripts

You can evaluate the configuration script by simply gathering it together
and passing it to the core +namespace eval+ command.
Unfortunately,
the first error that is encountered will terminate the evaluation.
This is decidedly inconvenient as you would prefer to continue on and
come up with a list of errors for the evaluation much like a
conventional language compiler would do when compiling a source file.
Discovering errors one at a time is tediously unproductive.

Of course, it is possible to continue evaluating after an error but
that requires a bit more code.
We will also want to be able to evaluate scripts in different namespace
contexts as we described above.
We will accomplish all this by taking advantage of the core +::apply+ command
and its ability to execute a lambda function in a given namespace.
So given a script body and an namespace we can evaluate it as shown below.

[source,tcl]
----
<<config commands>>=
namespace export ConfigEvaluate

proc ConfigEvaluate {ns body} {
    variable evalLambda
    tailcall ::apply [concat $evalLambda $ns] $body
}
----

The lambda function that performs the command evaluation is given below.
We hold the evaluation lambda as a piece of data.

[source,tcl]
----
<<config data>>=
variable evalLambda {{body} {
    upvar #0 ::rosea::Config::errcount errcount ; # <1>
    upvar #0 ::rosea::Config::configlineno configlineno
    set cmdline $configlineno
    set command {}
    foreach line [split $body \n] { # <2>
        append command $line \n
        incr cmdline ; # <3>
        if {[info complete $command]} {
            try {
                eval $command
            } on error {result} {
                log::error "line $configlineno: \"$result\""
                incr errcount
            }
            set command {} ; # <4>
            set configlineno $cmdline
        }
    }
    return $errcount
}}
----
<1> We need to keep track of all the errors encountered and
what line of the script we are currently dealing with.
<2> We split the body along lines and then reassemble the lines
into a complete command. The +info complete+ command tells us when
we have something that has some chance of being a real command.
<3> We need to keep track of where we are in the +body+.
<4> After evaluating a command we begin to assemble another one and
set our location counter to where that command starts.

So one of our top level +rosea+ commands is to configure a domain from
a script.

[source,tcl]
----
<<rosea exports>>=
namespace export configure

<<rosea imports>>=
namespace import ::rosea::Helpers::DeclError

<<rosea commands>>=
proc configure {script} {
    namespace upvar Config errcount errcount configlineno configlineno
    set errcount 0
    set configlineno 1
    try {
        relvar eval { # <1>
            Config::ConfigEvaluate ::rosea::Config $script
        }
    } on error {result} {
        log::error $result
        incr errcount
    }
    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----
<1> Evaluating the script must be done as a +relvar+ transaction
as we will need to defer the constraint checking until all the domain
components have been defined.

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
CONFIG_ERRORS     {encountered %d configuration script errors}
----

=== Defining a Domain

The _script_ handed to the +configure+ command should contain
invocations of the +domain+ command.

====
+domain+ _name_ _body_
====

+name+::
    The name of the domain. A domain name must be a non-empty string.
+body+::
    A Tcl script containing invocation of the domain definition commands
    to specify the details of the domain configuration.

As we described above,
the domain configuration commands will take the data in their
arguments and store it away.
After we have finished all the configuration scripts,
then the +generate+ command is used to layout the data structures
and namespace as needed.

In this section we start this process by showing some of the data
structures we will use to store the configuration data as it is
being collected.
Below is a UML class diagram for the data that the DSL will populate
for a domain definition.

image::config-domain.pdf[title="Domain Configuration Class Diagram"]

Since we are deep into TclRAL in this package,
the class diagram above will be implemented as a set of TclRAL relvars
and constraints.
We will establish a pattern of showing a class diagram followed by
the TclRAL relvar definitions and finally the code for the configuration
command.

[source,tcl]
----
<<config data>>=
relvar create Domain {
    Name    string
} Name

relvar create DomainElement {
    Domain  string
    Element string
} {Domain Element}

relvar association R1\
    DomainElement Domain *\
    Domain Name 1

relvar create Class {
    Domain  string
    Name    string
} {Domain Name}

relvar create Relationship {
    Domain  string
    Name    string
} {Domain Name}

relvar partition R2 DomainElement {Domain Element}\
    Class {Domain Name}\
    Relationship {Domain Name}

relvar create DomainOperation {
    Domain      string
    Name        string
    Parameters  list
    Body        string
} {Domain Name}

relvar association R7\
    DomainOperation Domain *\
    Domain Name 1
----

When configurating a domain,
we will evaluate the configuration script in the +DomainDef+ child namespace.
That namespace will define commands for all the components of the
domain.
We will use a similar arrangement for other nested aspects of
defining parts of the domain.

[source,tcl]
----
<<config commands>>=
proc domain {name body} {
    namespace upvar DomainDef DomainName DomainName ; # <1>
    set DomainName $name

    relvar uinsert ::rosea::Config::Domain [list Name $name] ; # <2>
    try {
        if {$name eq {}} {
            tailcall DeclError EMPTY_NAME domain
        }

        ConfigEvaluate [namespace current]::DomainDef  $body

        # At this point we have the definition of the domain and enough
        # information to tie together the referential attributes and
        # the association definitions.
        <<bind association references>>
    } on error {result opts} {
        log::error $result
        upvar #0 ::rosea::Config::errcount errcount
        incr errcount
    }
}
----
<1> We place the domain name into the child namespace where the context
implies that all the components defined are to be part of this domain.
<2> We allow the +domain+ command to be invoked more than once.
Domains are open ended definitions and the +uinsert+ command will not
throw an error upon a duplicate.

We will defer the discussion about binding the associations and their
attribute referenced until later when we have covered those commands.
For now,
we will say that there are semantics evaluations and checks that can only
be done after the entire domain configuration script has been processed.
The reason for this lies mainly with the way the DSL script commands
were defined to make them convenient when translating from an XUML model.

(((error code,EMPTY_NAME)))
[source,tcl]
----
<<error code formats>>=
EMPTY_NAME      {the empty string is not a value name for a %s}
----

[source,tcl]
----
<<config command tests>>=
test configure-1.0 {
    Define domain
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
        }
    }
    relation extract [relvar set ::rosea::Config::Domain] Name
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test configure-1.1 {
    Define domain -- bad name
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain {} {
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

We need some more testing support.
After running configuration commands, we will need to clean
up the configuration data.

[source,tcl]
----
<<test utility procs>>=
proc cleanupConfigData {} {
    relvar eval {
        foreach rname [relvar names ::rosea::Config::*] {
            if {![string match ::rosea::Config::__* $rname]} {
                relvar set $rname [relation emptyof [relvar set $rname]]
            }
        }
    }
}
----

=== Defining Domain Components

In this section we discuss the commands that are used to define
the components of a domain.
We define child namespaces for those domain component commands
that have a nested structure.
In this case,
it is the +class+ command that requires additional configuration commands.

We start with the namespace layout for the +DomainDef+ namespace.

[source,tcl]
----
<<domain config namespace layout>>=
namespace eval DomainDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::rosea::Config::ConfigEvaluate
    namespace import ::rosea::Helpers::DeclError
    <<domain config data>>
    <<domain config commands>>

    <<class config namespace layout>>
}
----

=== Defining Classes

====
+class+ _name_ _body_
====

+name+::
    The name of the class. A class name must be a non-empty string.
+body+::
    A Tcl script containing invocation of the class definition commands
    to specify the details of the class configuration.

Below is a UML class diagram of the configuration data for defining
classes.
There are a substantial number of rules about what constitutes a
proper XUML class.
This diagram is intended to enforce those rules.
For example,
every class must have at least one identifier.
That rule is enforced by relationship, +R4+.
Every class must have at least one attribute and that rule is
enforced by relationship, +R3+.
The use of a schema such as this insures that evaluating a class
definition script results in a consistent class definition.

image::config-classes.pdf[title="Classes Configuration Class Diagram"]

As before,
the TclRAL relvar defintions corresponding to the class model are
are direct text transliteration of the model graphic.

[source,tcl]
----
<<config data>>=
relvar create Attribute {
    Domain  string
    Class   string
    Name    string
    Type    string
} {Domain Class Name}

relvar association R3\
    Attribute {Domain Class} +\
    Class {Domain Name} 1

relvar create Identifier {
    Domain  string
    Class   string
    Number  int
} {Domain Class Number}

relvar association R4\
    Identifier {Domain Class} +\
    Class {Domain Name} 1

relvar create IdentifyingAttribute {
    Domain      string
    Class       string
    Attribute   string
    Number      int
} {Domain Class Attribute Number}

relvar correlation R5 IdentifyingAttribute\
    {Domain Class Number} + Identifier {Domain Class Number}\
    {Domain Class Attribute} * Attribute {Domain Class Name}

relvar create DefaultValue {
    Domain      string
    Class       string
    Attribute   string
    Value       string
} {Domain Class Attribute}

relvar association R6\
    DefaultValue {Domain Class Attribute} ?\
    Attribute {Domain Class Name} 1

relvar create AttributeReference {
    Domain              string
    ReferringClass      string
    ReferringAttribute  string
    ReferringRole       string
    ReferencedClass     string
    ReferencedAttribute string
    ReferencedRole      string
    ReferencedIdNumber  int
    Relationship        string
} {Domain ReferringClass ReferringAttribute ReferringRole\
    ReferencedClass ReferencedAttribute ReferencedRole ReferencedIdNumber\
    Relationship}

relvar association R13\
    AttributeReference {Domain ReferringClass ReferringAttribute} *\
    Attribute {Domain Class Name} 1

relvar create ReferencedIdAttribute {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Attribute       string
    Number          int
} {Domain Class Relationship Role Attribute Number}
----

[source,tcl]
----
<<domain config commands>>=
proc class {name body} {
    namespace upvar [namespace current] DomainName DomainName ; # <1>
    namespace upvar ClassDef ClassName ClassName
    set ClassName $name

    try {
        if {$name eq {}} {
            tailcall DeclError EMPTY_NAME class
        }
        relvar insert ::rosea::Config::DomainElement [list\
            Domain  $DomainName\
            Element $name\
        ]
        relvar insert ::rosea::Config::Class [list\
            Domain  $DomainName\
            Name    $name\
        ]

        ConfigEvaluate [namespace current]::ClassDef  $body
    } on error {result opts} {
        log::error $result
        upvar #0 ::rosea::Config::errcount errcount
        incr errcount
    }
}
----
<1> Again we arrange for namespace variables to hold the current
domain and class names to provide the context of the definition.

=== Defining Classes Components

Since there are several aspects of classes,
the +class+ command takes a _script_ argument which should
invoke the commands we discuss in this section.
Following our pattern,
we define a namespace where the class body script is evaluated.

[source,tcl]
----
<<class config namespace layout>>=
namespace eval ClassDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::rosea::Config::ConfigEvaluate
    namespace import ::rosea::Helpers::DeclError

    <<class config commands>>
    <<attribute config namespace layout>>
}
----

==== Defining Attributes

Within a class definitions,
the +attribute+ command specifies the attributes of the class.

=====
+attribute+ _name_ _type_ ?_option value_ ...?
=====

+name+::
    The name of the attribute. Attributes names may not be the empty string.
+type+::
    The type of the attribute. The _type_ may be any type that is acceptable
    to the +::ral::tuple+ command.
+option value+::
    A set of _option/value_ pairs that define the characteristics of the
    attribute.
    Valid options are:
    +-default+ _value_:::
        Specifies a default value that will be supplied if an instance
        is created and no value is provided for the attribute.
    +-id+ _number_:::
        Specifies that the attribute is part of the identifier given by
        _number_.
        All classes must have at least one identifier.
        Classes may have multiple identifiers and each is given a
        separate number. Typically, _number_ is a small integer
        such as 1, 2 or 3.

.A Note About Identifiers
*******
For lack of a better way to distinguish identifiers,
integer numbers are used.
The most common case is for a class to have a single identifier
and for that identifier to have a single attribute.
So typically, one attribute of the class will be marked as +-id 1+.
Identifiers must also be minimal identifiers,
_i.e._ one identifier's attributes must not be a subset (proper or improper)
of the attributes of another identifier.
The rule of minimal identifiers is _not_ enforced by the class configuration
UML model but TclRAL will insist upon it when the underlying relvar is
created.
*******

The implementation of the +attribute+ command simply creates tuples
in the relvars to hold the attribute characteristics.

[source,tcl]
----
<<class config commands>>=
proc attribute {name type args} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME attribute
    }
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    relvar insert ::rosea::Config::Attribute [list\
        Domain  $DomainName\
        Class   $ClassName\
        Name    $name\
        Type    $type\
    ]

    foreach {option value} $args {
        switch -exact -- $option {
            -default {
                relvar insert ::rosea::Config::DefaultValue [list\
                    Domain      $DomainName\
                    Class       $ClassName\
                    Attribute   $name\
                    Value       $value\
                ]
            }
            -id {
                relvar uinsert ::rosea::Config::Identifier [list\
                    Domain      $DomainName\
                    Class       $ClassName\
                    Number      $value\
                ]
                relvar insert ::rosea::Config::IdentifyingAttribute [list\
                    Domain      $DomainName\
                    Class       $ClassName\
                    Attribute   $name\
                    Number      $value\
                ]
            }
            default {
                tailcall DeclError UNKNOWN_OPTION attribute $option
            }
        }
    }
}
----

==== Defining References

One of the more complicated aspects of XUML is understanding
class relationships and how the fundamental notions of
referential integrity constraints from relational algebra are implemented.
For our purposes,
we have chosen to specify relationships in two pieces:

. Specifying that some attributes are _referential_. Attribute references
are the means by which relationships are realized.
They define attributes whose values are equal to the value of a
corresponding attribute in the related class.
. Specifying the relationship characteristics such as the classes involved
and the multiplicity and conditionality of the relationship.

The reason we have taken this approach is that it corresponds closely
to the UML graphic that we are translating.
The referential nature of an attribute is denoted in the graphic as a
characteristic of the attribute and relationships have a separate graphical
representation.
The result of this decision is that the most common case of simple
associations can be specified with the least amount of text.
The tradeoff is that the most general case of a reflexive, class-based
association requires more specification to resolve an inherent ambiguity.

======
+reference+ _relationship_ _class_ ?_option value_ ...?
======

+relationship+::
    The name of the relationship to which the reference applies.
+class+::
    The name of the class to which the reference refers.
+option value+::
    A set of _option/value_ pairs that define the characteristics of the
    reference.
    Valid options are:
    +-link+ _attribute reference_:::
        The +-link+ option specifies an attribute reference.
        The _attribute reference_ value is a one or two element list.
        The first element is the name of an attribute in the class being
        defined.
        The second element is the name of an attribute in the class given
        by the _class_ argument.
        The +-link+ option specifies that an attribute in the class being
        defined is a reference to (_i.e._ will have the same value as)
        an attribute in the _class_ class.
        If the second element of the _attribute reference_ is missing,
        then the name of the referenced attribute is assumed to be
        the same as the referencing attribute.
        Multiple +-link+ options may be given for a given _relationships_.
        The link options define a one-to-one correspondance between the
        referring attributes and an identifier in _class_.
    +-refid+ _number_:::
        The +refid+ option gives the _number_ of the identifier to which
        reference is directed.
        If missing, then +refid+ defaults to 1.
        Typically, references in the class being defined refer to the primary
        identifier in _class_.
        However, if they refer to another identifier, then the +refid+
        option is necessary.
        All the attributes given by the +-link+ options, as a group,
        must reference a specific identifier in _class_.

[source,tcl]
----
<<class config commands>>=
proc reference {relname rclass args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    set refnum 1

    foreach {option value} $args {
        switch -exact -- $option {
            -refid {
                set refnum $value
            }
            -link {
                if {[llength $value] < 1 || [llength $value] > 2} {
                    tailcall DeclError ARG_FORMAT $value
                }
                lassign $value referring referenced
                if {$referenced eq {}} {
                    set referenced $referring
                }
                relvar insert ::rosea::Config::AttributeReference [list\
                    Domain              $DomainName\
                    ReferringClass      $ClassName\
                    ReferringAttribute  $referring\
                    ReferringRole       source\
                    ReferencedClass     $rclass\
                    ReferencedAttribute $referenced\
                    ReferencedRole      target\
                    ReferencedIdNumber  $refnum\
                    Relationship        $relname
                ]
            }
            default {
                tailcall DeclError UNKNOWN_OPTION reference $option
            }
        }
    }
}
----

(((error code,ARG_FORMAT)))
(((error code,UNKNOWN_OPTION)))
[source,tcl]
----
<<error code formats>>=
ARG_FORMAT      {options and values must come in pairs, got "%s"}
UNKNOWN_OPTION  {unknown %s command option, "%s"}
----

[source,tcl]
----
<<config command tests>>=
test configure-2.0 {
    Define domain and classes
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class c1 {
                attribute a1 string -id 1
                attribute a2 string -default 20
            }
            class c2 {
                attribute a1 string -id 1
                attribute a2 string -default 40
            }
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {2}
----

[source,tcl]
----
<<config command tests>>=
test configure-2.1 {
    Define domain -- bad attribute option
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class c1 {
                attribute a1 string -foo 1 -id 1
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

=== Defining Class Operations

[source,tcl]
----
<<config data>>=
relvar create ClassOperation {
    Domain  string
    Class   string
    Name    string
    Parameters  list
    Body        string
} {Domain Class Name}

relvar association R8\
    ClassOperation {Domain Class} * Class {Domain Name} 1

relvar create __SystemClassOp {
    Name    string
    Prefix  list
} Name

relvar insert __SystemClassOp {
    Name    findAll
    Prefix  ::rosea::ClassCmds::findAll
} {
    Name    findById
    Prefix  ::rosea::ClassCmds::findById
} {
    Name    findWhere
    Prefix  ::rosea::ClassCmds::findWhere
} {
    Name    create
    Prefix  ::rosea::ClassCmds::create
} {
    Name    createin
    Prefix  ::rosea::ClassCmds::createin
} {
    Name    createasync
    Prefix  ::rosea::ClassCmds::createasync
} {
    Name    delete
    Prefix  ::rosea::ClassCmds::delete
} {
    Name    update
    Prefix  ::rosea::ClassCmds::update
}
----

[source,tcl]
----
<<class config commands>>=
proc classop {name params body} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME "class operation"
    }
    set sysop [relvar restrictone ::rosea::Config::__SystemClassOp Name $name]
    if {[relation isnotempty $sysop]} {
        tailcall DeclError SYS_CLASS_OP $name
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    relvar insert ::rosea::Config::ClassOperation [list\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name\
        Parameters  $params\
        Body        $body\
    ]
}
----

(((error code,SYS_CLASS_OP)))
[source,tcl]
----
<<error code formats>>=
SYS_CLASS_OP      {name conflict with system defined class operation, "%s"}
----


=== Defining Instances Operations

[source,tcl]
----
<<config data>>=
relvar create InstanceOperation {
    Domain  string
    Class   string
    Name    string
    Parameters  list
    Body        string
} {Domain Class Name}

relvar association R10\
    InstanceOperation {Domain Class} * Class {Domain Name} 1

relvar create __SystemInstOp {
    Name    string
    Prefix  list
} Name

relvar insert __SystemInstOp {
    Name    findRelated
    Prefix  ::rosea::InstCmds::findRelated
} {
    Name    findUnrelated
    Prefix  ::rosea::InstCmds::findById
} {
    Name    findRelatedWhere
    Prefix  ::rosea::InstCmds::findRelatedWhere
} {
    Name    findUnrelatedWhere
    Prefix  ::rosea::InstCmds::findUnrelatedWhere
} {
    Name    updateAttribute
    Prefix  ::rosea::InstCmds::updateAttribute
} {
    Name    readAttribute
    Prefix  ::rosea::InstCmds::readAttribute
} {
    Name    signal
    Prefix  ::rosea::InstCmds::signal
} {
    Name    delaysignal
    Prefix  ::rosea::InstCmds::delaysignal
} {
    Name    canceldelayed
    Prefix  ::rosea::InstCmds::canceldelayed
} {
    Name    delayremaining
    Prefix  ::rosea::InstCmds::delayremaining
} {
    Name    deRef
    Prefix  ::rosea::Helpers::deRef
}
----

[source,tcl]
----
<<class config commands>>=
proc instop {name params body} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME "instance operation"
    }
    set sysop [relvar restrictone ::rosea::Config::__SystemInstOp Name $name]
    if {[relation isnotempty $sysop]} {
        tailcall DeclError SYS_INST_OP $name
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    relvar insert ::rosea::Config::InstanceOperation [list\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name\
        Parameters  $params\
        Body        $body\
    ]
}
----

(((error code,SYS_INST_OP)))
[source,tcl]
----
<<error code formats>>=
SYS_INST_OP      {name conflict with system defined instance operation, "%s"}
----

=== Defining Relationships

image::config-relation.pdf[title="Relationship Configuration Class Diagram"]

[source,tcl]
----
<<config data>>=
relvar create Association {
    Domain      string
    Name        string
} {Domain Name}

relvar create Generalization {
    Domain      string
    Name        string
} {Domain Name}

relvar partition R30\
    Relationship {Domain Name}\
        Association {Domain Name}\
        Generalization {Domain Name}

relvar create SimpleAssociation {
    Domain      string
    Name        string
} {Domain Name}

relvar create ClassBasedAssociation {
    Domain      string
    Name        string
} {Domain Name}

relvar partition R31\
    Association {Domain Name}\
        SimpleAssociation {Domain Name}\
        ClassBasedAssociation {Domain Name}

relvar create SimpleReferringClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Conditionality  boolean
    Multiplicity    boolean
} {Domain Class Relationship Role}

relvar association R32\
    SimpleReferringClass {Domain Relationship} 1\
    SimpleAssociation {Domain Name} 1

relvar create SimpleReferencedClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Conditionality  boolean
} {Domain Class Relationship Role}

relvar association R33\
    SimpleReferencedClass {Domain Relationship} 1\
    SimpleAssociation {Domain Name} 1

relvar create SourceClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Conditionality  boolean
    Multiplicity    boolean
} {Domain Class Relationship Role}

relvar association R34\
    SourceClass {Domain Relationship} 1\
    ClassBasedAssociation {Domain Name} 1

relvar create TargetClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Conditionality  boolean
    Multiplicity    boolean
} {Domain Class Relationship Role}

relvar association R35\
    TargetClass {Domain Relationship} 1\
    ClassBasedAssociation {Domain Name} 1

relvar create AssociatorClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar association R42\
    AssociatorClass {Domain Relationship} 1\
    ClassBasedAssociation {Domain Name} 1

relvar create Superclass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar association R36\
    Superclass {Domain Relationship} 1\
    Generalization {Domain Name} 1

relvar create Subclass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar association R37\
    Subclass {Domain Relationship} +\
    Generalization {Domain Name} 1

relvar create ReferringClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar partition R38\
    ReferringClass {Domain Class Relationship Role}\
        SimpleReferringClass {Domain Class Relationship Role}\
        AssociatorClass {Domain Class Relationship Role}\
        Subclass {Domain Class Relationship Role}

relvar create ReferencedClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar partition R39\
    ReferencedClass {Domain Class Relationship Role}\
        SimpleReferencedClass {Domain Class Relationship Role}\
        SourceClass {Domain Class Relationship Role}\
        TargetClass {Domain Class Relationship Role}\
        Superclass {Domain Class Relationship Role}

relvar create ClassRole {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar partition R40\
    ClassRole {Domain Class Relationship Role}\
        ReferringClass {Domain Class Relationship Role}\
        ReferencedClass {Domain Class Relationship Role}

relvar correlation R41 ClassRole\
    {Domain Relationship} + Relationship {Domain Name}\
    {Domain Class} * Class {Domain Name}

relvar correlation R11 ReferencedIdAttribute\
    {Domain Class Relationship Role} +\
        ReferencedClass {Domain Class Relationship Role}\
    {Domain Class Attribute Number} *\
        IdentifyingAttribute {Domain Class Attribute Number}

relvar correlation R12 AttributeReference\
    {Domain ReferringClass Relationship ReferringRole} +\
        ReferringClass {Domain Class Relationship Role}\
    {Domain ReferencedClass Relationship ReferencedRole ReferencedAttribute\
            ReferencedIdNumber} +\
        ReferencedIdAttribute {Domain Class Relationship Role Attribute Number}
----

==== Defining Associations

...............
association name <source> <spec> <target>
    ?-associator <associator class>?
    ?-path {<source attr> <target attr>} ...?


    <spec> ==>      1--1
                    0..1--1
                    0..1--0..1
                    1..n--1
                    0..n--1
                    1..n--0..1
                    0..n--0..1
                    1..n--1..n
                    0..n--1..n
                    1..n--0..n
                    0..n--0..n
...............

[source,tcl]
----
<<config data>>=
relvar create __AssocInfo {
    Spec                string
    NeedsAssociator     boolean
    ReflexiveAllowed    boolean
    ReferringCond       boolean
    ReferringMult       boolean
    ReferencedCond      boolean
    ReferencedMult      boolean
} Spec

relvar insert __AssocInfo {
    Spec 1--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec 0..1--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec 0..1--0..1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult false
        ReferencedCond true ReferencedMult false
} {
    Spec 1..n--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec 0..n--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec 1..n--0..1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec 0..n--0..1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec 1..n--1..n NeedsAssociator true ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec 0..n--1..n NeedsAssociator true ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec 1..n--0..n NeedsAssociator true ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec 0..n--0..n NeedsAssociator true ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult true
}
----

The consequence of
the decision to specify the realization of relationships as
attribute references separately from the specification
of an association itself is that we will have to hold,
temporarily, some data about associations until all of the classes
are defined.
Then we will bind the attribute references to the relationship characteristics.
This is done below.
For now we show the data that must be kept aside to perform the binding
of the attribute references to the corresopnding associations.

[source,tcl]
----
<<config data>>=
relvar create ClassAssoc {
    Domain              string
    Relationship        string
    AssocClass          string
    SourceClass         string
} {Domain Relationship AssocClass SourceClass}

relvar create NonReflexiveAssoc {
    Domain              string
    Relationship        string
    AssocClass          string
    SourceClass         string
    TargetClass         string
} {Domain Relationship AssocClass SourceClass}

relvar create ReflexiveAssoc {
    Domain              string
    Relationship        string
    AssocClass          string
    SourceClass         string
} {Domain Relationship AssocClass SourceClass}

relvar create ReflexivePath {
    Domain              string
    Relationship        string
    AssocClass          string
    SourceClass         string
    SourceAttr          string
    TargetAttr          string
} {Domain Relationship AssocClass SourceClass SourceAttr}

relvar partition X1\
    ClassAssoc {Domain Relationship AssocClass SourceClass}\
        NonReflexiveAssoc {Domain Relationship AssocClass SourceClass}\
        ReflexiveAssoc {Domain Relationship AssocClass SourceClass}
relvar association X2\
    ReflexivePath {Domain Relationship AssocClass SourceClass} +\
    ReflexiveAssoc {Domain Relationship AssocClass SourceClass} 1
----

[source,tcl]
----
<<domain config commands>>=
proc association {name source spec target args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    set associator {}
    set path {}

    foreach {option value} $args {
        switch -exact -- $option {
            -associator {
                set associator $value
            }
            -path {
                set path $value
                if {[llength $path] % 2 != 0} {
                    tailcall DeclError ARG_FORMAT $path
                }
            }
            default {
                tailcall DeclError UNKNOWN_OPTION association $option
            }
        }
    }

    set ainfo [relvar restrictone ::rosea::Config::__AssocInfo Spec $spec]
    if {[relation isempty $ainfo]} {
        tailcall DeclError BAD_RELATIONSHIP_SPEC $spec
    }
    set needsassoc [relation extract $ainfo NeedsAssociator]
    if {$needsassoc && $associator eq {}} {
        tailcall DeclError NEED_ASSOCIATOR $spec
    }
    if {$source eq $target} {
        if {![relation extract $ainfo ReflexiveAllowed]} {
            tailcall DeclError REFLEXIVE_NOT_ALLOWED $spec
        }
        if {$needsassoc && $path eq {}} {
            tailcall DeclError NEED_REFLEXIVE_PATH $name $source $spec $target
        }
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName

    relvar insert ::rosea::Config::DomainElement [list\
        Domain  $DomainName\
        Element $name\
    ]

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    relvar insert ::rosea::Config::Relationship $reltuple
    relvar insert ::rosea::Config::Association $reltuple

    if {$associator eq {}} {
        relvar insert ::rosea::Config::SimpleAssociation $reltuple
        relvar insert ::rosea::Config::SimpleReferringClass [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
            Conditionality  [relation extract $ainfo ReferringCond]\
            Multiplicity    [relation extract $ainfo ReferringMult]\
        ]
        relvar insert ::rosea::Config::ReferringClass [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::SimpleReferencedClass [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
            Conditionality  [relation extract $ainfo ReferencedCond]\
        ]
        relvar insert ::rosea::Config::ReferencedClass [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
        ]
    } else {
        relvar insert ::rosea::Config::ClassAssoc [list\
            Domain              $DomainName\
            Relationship        $name\
            AssocClass          $associator\
            SourceClass         $source\
        ]
        if {[llength $path] == 0} {
            relvar insert ::rosea::Config::NonReflexiveAssoc [list\
                Domain              $DomainName\
                Relationship        $name\
                AssocClass          $associator\
                SourceClass         $source\
                TargetClass         $target\
            ]
        } else {
            relvar insert ::rosea::Config::ReflexiveAssoc [list\
                Domain              $DomainName\
                Relationship        $name\
                AssocClass          $associator\
                SourceClass         $source\
            ]
            foreach {sourceattr targetattr} $path {
                relvar insert ::rosea::Config::ReflexivePath [list\
                    Domain              $DomainName\
                    Relationship        $name\
                    AssocClass          $associator\
                    SourceClass         $source\
                    SourceAttr          $sourceattr\
                    TargetAttr          $targetattr\
                ]
            }
        }

        relvar insert ::rosea::Config::ClassBasedAssociation $reltuple
        relvar insert ::rosea::Config::SourceClass [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
            Conditionality  [relation extract $ainfo ReferringCond]\
            Multiplicity    [relation extract $ainfo ReferringMult]\
        ]
        relvar insert ::rosea::Config::ReferencedClass [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::TargetClass [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
            Conditionality  [relation extract $ainfo ReferencedCond]\
            Multiplicity    [relation extract $ainfo ReferencedMult]\
        ]
        relvar insert ::rosea::Config::ReferencedClass [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
        ]
        relvar insert ::rosea::Config::AssociatorClass [list\
            Domain          $DomainName\
            Class           $associator\
            Relationship    $name\
            Role            associator\
        ]
        relvar insert ::rosea::Config::ReferringClass [list\
            Domain          $DomainName\
            Class           $associator\
            Relationship    $name\
            Role            associator\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $associator\
            Relationship    $name\
            Role            associator\
        ]
    }
}
----

(((error code,BAD_RELATIONSHIP_SPEC)))
(((error code,NEED_ASSOCIATOR)))
(((error code, NEED_REFLEXIVE_PATH)))
(((error code, REFLEXIVE_NOT_ALLOWED)))
[source,tcl]
----
<<error code formats>>=
BAD_RELATIONSHIP_SPEC  {bad relationship specifier, "%s"}
NEED_ASSOCIATOR {relationship of type, "%s", requires associative class}
NEED_REFLEXIVE_PATH {traversal path must be specified for reflexive\
        association, %s, %s %s %s}
REFLEXIVE_NOT_ALLOWED   {associations of type, "%s", cannot be reflexive}
----

[source,tcl]
----
<<bind association references>>=
variable ReferencedClass
variable ReferringClass
variable ReferencedIdAttribute
variable AttributeReference
variable NonReflexiveAssoc
variable ReflexivePath

#puts [relformat $ReferencedClass ReferencedClass]
#puts [relformat $ReferringClass ReferringClass]
#puts [relformat $AttributeReference AttributeReference]
#puts [relformat $NonReflexiveAssoc NonReflexiveAssoc]
#puts [relformat $ReflexivePath ReflexivePath]

relation foreach nra $NonReflexiveAssoc {
    relation assign $nra
    relvar update ::rosea::Config::AttributeReference ar {
        [tuple extract $ar Domain] eq $Domain &&
        [tuple extract $ar Relationship] eq $Relationship &&
        [tuple extract $ar ReferringClass] eq $AssocClass
    } {tuple update $ar ReferringRole associator}

    relvar update ::rosea::Config::AttributeReference ar {
        [tuple extract $ar Domain] eq $Domain &&
        [tuple extract $ar Relationship] eq $Relationship &&
        [tuple extract $ar ReferringClass] eq $AssocClass &&
        [tuple extract $ar ReferencedClass] eq $SourceClass
    } {tuple update $ar ReferencedRole source}
}

relation foreach rp $ReflexivePath {
    relation assign $rp
    relvar update ::rosea::Config::AttributeReference ar {
        [tuple extract $ar Domain] eq $Domain &&
        [tuple extract $ar Relationship] eq $Relationship &&
        [tuple extract $ar ReferringClass] eq $AssocClass
    } {tuple update $ar ReferringRole associator}

    relvar update ::rosea::Config::AttributeReference ar {
        [tuple extract $ar Domain] eq $Domain &&
        [tuple extract $ar Relationship] eq $Relationship &&
        [tuple extract $ar ReferringClass] eq $AssocClass &&
        [tuple extract $ar ReferringAttribute] eq $SourceAttr
    } {tuple update $ar ReferencedRole source}
}

pipe {
    relvar set ::rosea::Config::AttributeReference |
    relation project ~ Domain ReferencedClass Relationship ReferencedRole\
            ReferencedAttribute ReferencedIdNumber |
    relation rename ~ ReferencedClass Class ReferencedRole Role\
            ReferencedAttribute Attribute ReferencedIdNumber Number |
    relvar union ::rosea::Config::ReferencedIdAttribute
}

#puts [relformat $AttributeReference AttributeReference]
#puts [relformat $ReferencedIdAttribute ReferencedIdAttribute]
----

[source,tcl]
----
<<config command tests>>=
test configure-3.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class x {
                attribute a1 string -id 1
                attribute a2 string -default 20
            }
            class y {
                attribute a1 string -id 1
                reference R1 x -link a1
            }
            association R1 y 1--1 x
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {2}
----

[source,tcl]
----
<<config command tests>>=
test configure-3.1 {
    Define reflexive simple association
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class x {
                attribute a1 string -id 1
                attribute prev string -id 2
                attribute a2 string -default 20
                reference R1 x -link {prev a1}
            }
            association R1 x 1--1 x
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test configure-3.2 {
    Define class based association
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class a {
                attribute x1 string -id 1
                attribute y1 string -id 1
                reference R1 x -link x1
                reference R1 y -link y1
            }
            class x {
                attribute x1 string -id 1
                attribute x2 string -default 20
            }
            class y {
                attribute y1 string -id 1
            }
            association R1 x 1..n--1..n y -associator a
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {3}
----

[source,tcl]
----
<<config command tests>>=
test configure-3.3 {
    Define reflexive class based association
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class a {
                attribute x1 string -id 1
                attribute next string -id 1
                reference R1 x -link x1 -link {next x1}
            }
            class x {
                attribute x1 string -id 1
                attribute x2 string -default 20
            }
            association R1 x 1..n--1..n x -associator a -path {x1 next}
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {2}
----

==== Defining Generalizations

...............
generalization name super sub1 sub2 ...
...............

[source,tcl]
----
<<domain config commands>>=
proc generalization {name super args} {
    if {[llength $args] < 2} {
        tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName

    relvar insert ::rosea::Config::DomainElement [list\
        Domain  $DomainName\
        Element $name\
    ]

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    relvar insert ::rosea::Config::Relationship $reltuple
    relvar insert ::rosea::Config::Generalization $reltuple

    set supertuple [list\
        Domain          $DomainName\
        Class           $super\
        Relationship    $name\
        Role            target\
    ]
    relvar insert ::rosea::Config::Superclass $supertuple
    relvar insert ::rosea::Config::ReferencedClass $supertuple
    relvar insert ::rosea::Config::ClassRole $supertuple

    foreach sub $args {
        set subtuple [list\
            Domain          $DomainName\
            Class           $sub\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::Subclass $subtuple
        relvar insert ::rosea::Config::ReferringClass $subtuple
        relvar insert ::rosea::Config::ClassRole $subtuple
    }
}
----

(((error code,TOO_FEW_SUBCLASSES)))
[source,tcl]
----
<<error code formats>>=
TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
----

[source,tcl]
----
<<config command tests>>=
test configure-4.0 {
    Define generalization
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class super {
                attribute a1 string -id 1
                attribute a2 string -default 20
            }
            class sub1 {
                attribute a1 string -id 1
                reference R1 super -link a1
            }
            class sub2 {
                attribute a1 string -id 1
                reference R1 super -link a1
            }
            generalization R1 super sub1 sub2
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {3}
----

=== Defining Domain Operations

...............
operation name params body
...............

[source,tcl]
----
<<domain config commands>>=
proc operation {name params body} {
    namespace upvar ::rosea::Config::DomainDef DomainName DomainName

    relvar insert ::rosea::Config::DomainOperation [list\
        Domain      $DomainName\
        Name        $name\
        Parameters  $params\
        Body        $body\
    ]
}
----

== Generating Domains

[source,tcl]
----
<<rosea exports>>=
namespace export generate

<<rosea commands>>=
proc generate {{prefix {}}} {
    if {$prefix ne {}} {
        if {[string range $prefix 0 1] ne "::"} {
            error "relative namespaces not allowed"
        } elseif {![namespace exists $prefix]} {
            namespace eval $prefix
        }
        set prefix [string trimright $prefix :]
    }

    namespace upvar Config\
        Domain Domain\
        DomainElement DomainElement\
        Class Class\
        Attribute Attribute\
        DefaultValue DefaultValue\
        Identifier Identifier\
        IdentifyingAttribute IdentifyingAttribute\
        Relationship Relationship\
        Association Association\
        SimpleAssociation SimpleAssociation\
        SimpleReferringClass SimpleReferringClass\
        SimpleReferencedClass SimpleReferencedClass\
        ClassBasedAssociation ClassBasedAssociation\
        AssociatorClass AssociatorClass\
        SourceClass SourceClass\
        TargetClass TargetClass\
        Generalization Generalization\
        Superclass Superclass\
        Subclass Subclass\
        AttributeReference AttributeReference\
        ReferencedIdAttribute ReferencedIdAttribute\
        ReferringClass ReferringClass\
        ReferencedClass ReferencedClass\
        DomainOperation DomainOperation\
        ClassOperation ClassOperation\
        InstanceOperation InstanceOperation\
        __SystemClassOp SystemClassOp\
        __SystemInstOp SystemInstOp

    # Query for the heading
    pipe {
        relation semijoin $class $Attribute -using {Domain Domain Name Class} |
        relation project ~ Name Type |
        relation dict ~ Name Type
    } headingQuery

    pipe {
        relation semijoin $class $Identifier -using {Domain Domain Name Class}\
                $IdentifyingAttribute |
        relation group ~ Attributes Attribute
    } idQuery

    relation foreach domain $Domain {
        set domns ${prefix}::[relation extract $domain Name]
        namespace eval $domns {
            <<tclral imports>>
        }
        namespace eval $domns [list\
            namespace import {*}[relation list $SystemInstOp Prefix]
        ]
        set archns [GenerateArchStructures $domns]

        set domops [relation semijoin $domain $DomainOperation\
                -using {Name Domain}]
        relation foreach domop $domops {
            relation assign $domop\
                {Name name} {Parameters parameters} {Body body}
            namespace eval ${domns} [list namespace export $name]
            proc ${domns}::$name $parameters [list relvar eval $body]
        }

        set classes [relation semijoin $domain $DomainElement $Class]
        relation foreach class $classes {
            set className ${domns}::[relation extract $class Name]
            namespace eval $className {
                <<tclral imports>>
                namespace eval __Activity {
                    <<tclral imports>>
                }
            }
            # create class relvars
            set heading [eval $headingQuery]
            set ids [eval $idQuery]
            set idset [list]
            relation foreach id $ids -ascending Number {
                lappend idset [relation list\
                        [relation extract $id Attributes] Attribute]
            }
            # create the relvar
            relvar create $className $heading {*}$idset

            set defaultvalues [pipe {
                relation semijoin $class $Attribute\
                    -using {Domain Domain Name Class} |
                relation join ~ $DefaultValue\
                    -using {Domain Domain Class Class Name Attribute}
            }]
            #puts [relformat $defaultvalues defaultvalues]

            if {[relation isnotempty $defaultvalues]} {
                set defheading [relation dict $defaultvalues Name Type]
                set defvalues [relation dict $defaultvalues Name Value]
                relvar trace add variable $className insert [list\
                    ::rosea::Helpers::InsertTrace $defheading $defvalues]
            }

            set opmap [dict create]
            set classops [relation semijoin $class $ClassOperation\
                -using {Domain Domain Name Class}]
            relation foreach classop $classops {
                relation assign $classop\
                    {Name opname}\
                    {Parameters params}\
                    {Body opbody}

                set params [linsert $params 0 class]
                proc ${className}::$opname $params $opbody
                dict set opmap $opname [list ${className}::$opname $className]
            }

            set sysmap [pipe {
                relation update $SystemClassOp sco 1 {
                    tuple update $sco Prefix\
                        [concat [tuple extract $sco Prefix] [list $className]]
                } |
                relation dict ~ Name Prefix
            }]

            namespace ensemble create\
                -command $className\
                -map [dict merge $opmap $sysmap]

            namespace eval ${className}::__Activity [list\
                namespace import {*}[relation list $SystemInstOp Prefix]
            ]

            set instops [relation semijoin $class $InstanceOperation\
                -using {Domain Domain Name Class}]
            relation foreach instop $instops {
                relation assign $instop\
                    {Name opname}\
                    {Parameters params}\
                    {Body opbody}

                proc ${className}::__Activity::$opname $params $opbody
            }
        }

        set rships [relation semijoin $domain $DomainElement $Relationship]
        set sassocs [relation semijoin $rships $Association $SimpleAssociation]
        relation foreach sassoc $sassocs {
            set refing [relation semijoin $sassoc $SimpleReferringClass\
                    -using {Domain Domain Name Relationship}]
            set refed [relation semijoin $sassoc $SimpleReferencedClass\
                    -using {Domain Domain Name Relationship}]

            set reference [pipe {
                relation join $AttributeReference $refing\
                    -using {Domain Domain ReferringClass Class\
                    Relationship Relationship ReferringRole Role} |
                relation rename ~ Conditionality ReferringCond\
                        Multiplicity ReferringMult |
                relation join ~ $refed -using {Domain Domain\
                    ReferencedClass Class Relationship\
                    Relationship ReferencedRole Role} |
                relation project ~ Domain Relationship\
                    ReferringClass ReferringAttribute\
                    ReferencedClass ReferencedAttribute\
                    ReferringCond ReferringMult Conditionality |
                relation group ~ ReferringAttrs\
                        ReferringAttribute ReferencedAttribute
            }]
            #puts [relformat $reference reference]

            relation assign $reference\
                {Domain domain}\
                {Relationship relationship}\
                {ReferringClass referringClass}\
                {ReferencedClass referencedClass}\
                {ReferringCond referringCond}\
                {ReferringMult referringMult}\
                {Conditionality referencedCond}\
                {ReferringAttrs referringAttrs}
            set attrrefs [relation tag $referringAttrs RefOrder]
            #puts [relformat $attrrefs attrrefs]
            set srcattrs [relation list $attrrefs ReferringAttribute\
                    -ascending RefOrder]
            set destattrs [relation list $attrrefs ReferencedAttribute\
                    -ascending RefOrder]
            lassign [WeaveLists $srcattrs $destattrs] forwattrs revattrs

            relvar association ${domns}::$relationship\
                 ${domns}::$referringClass $srcattrs\
                [MapCondMultToConstraint $referringCond $referringMult]\
                ${domns}::$referencedClass $destattrs\
                [MapCondMultToConstraint $referencedCond false]

            relvar eval {
                relvar insert ${archns}::__Link [list\
                    Name    $relationship\
                    Class   ${domns}::$referringClass\
                    Attrs   $forwattrs\
                ]
                relvar insert ${archns}::__AssociationLink [list\
                    Name            $relationship\
                    SrcClass        ${domns}::$referringClass\
                    DstClass        ${domns}::$referencedClass\
                    PrevSrcClass    {}\
                ]
                relvar insert ${archns}::__Link [list\
                    Name    ~$relationship\
                    Class   ${domns}::$referencedClass\
                    Attrs   $revattrs\
                ]
                relvar insert ${archns}::__AssociationLink [list\
                    Name            ~$relationship\
                    SrcClass        ${domns}::$referencedClass\
                    DstClass        ${domns}::$referringClass\
                    PrevSrcClass    {}\
                ]
                relvar insert ${archns}::__RefLink [list\
                    Relationship    $relationship\
                    ReferringClass  ${domns}::$referringClass\
                    ReferencedClass ${domns}::$referencedClass\
                    ReferringAttrs  $referringAttrs\
                ]
            }

            namespace ensemble create\
                -command ${domns}::$relationship\
                -map [dict create\
                    link [list ::rosea::RelCmds::linkSimple $relationship]\
                    unlink [list ::rosea::RelCmds::unlinkSimple $relationship]\
                ]
        }

        set cassocs [relation semijoin $rships $Association\
                $ClassBasedAssociation]
        relation foreach cassoc $cassocs {
            set sourceclass [relation semijoin $cassoc $SourceClass\
                -using {Domain Domain Name Relationship}]
            set targetclass [relation semijoin $cassoc $TargetClass\
                -using {Domain Domain Name Relationship}]

            set assocrefs [pipe {
                relation semijoin $cassoc $AssociatorClass\
                        -using {Domain Domain Name Relationship}\
                    $ReferringClass $AttributeReference\
                        -using {Domain Domain Class ReferringClass\
                        Relationship Relationship Role ReferringRole} |
                relation project ~ Domain ReferringClass ReferringAttribute\
                    ReferencedClass ReferencedAttribute ReferencedRole\
                    Relationship |
                relation join ~ [relation union $sourceclass $targetclass]\
                        -using {Domain Domain Relationship Relationship\
                        ReferencedClass Class ReferencedRole Role} |
                relation group ~ ReferringAttrs\
                        ReferringAttribute ReferencedAttribute |
                relation group ~ References ReferencedClass ReferencedRole\
                        Conditionality Multiplicity ReferringAttrs

            }]
            #puts [relformat $assocrefs assocrefs]

            relation foreach assocref $assocrefs {
                relation assign $assocref\
                    {Domain domain}\
                    {ReferringClass associator}\
                    {Relationship relationship}\
                    {References references}
                set assoclinks [relation create {Participant string Role string\
                    ReferringAttrs {Relation {ReferringAttribute string\
                        ReferencedAttribute string}}}]
                relation foreach reference $references {
                    relation assign $reference\
                        {ReferencedClass referencedClass}\
                        {ReferencedRole referencedRole}\
                        {Conditionality conditionality}\
                        {Multiplicity multiplicity}\
                        {ReferringAttrs referringAttrs}

                    set attrrefs [relation tag $referringAttrs RefOrder]
                    set assocattrs($referencedRole)\
                        [relation list $attrrefs ReferringAttribute\
                            -ascending RefOrder]
                    set refattrs($referencedRole)\
                        [relation list $attrrefs ReferencedAttribute\
                            -ascending RefOrder]
                    set multcond($referencedRole)\
                        [MapCondMultToConstraint $conditionality $multiplicity]
                    set refclass($referencedRole) ${domns}::$referencedClass

                    set assoclinks [relation insert $assoclinks [list\
                        Participant $refclass($referencedRole)\
                        Role $referencedRole\
                        ReferringAttrs $referringAttrs\
                    ]]
                }

                relvar correlation ${domns}::$relationship\
                    ${domns}::$associator\
                    $assocattrs(source) $multcond(target) $refclass(source)\
                        $refattrs(source)\
                    $assocattrs(target) $multcond(source) $refclass(target)\
                        $refattrs(target)

                lassign [WeaveLists $refattrs(source) $assocattrs(source)]\
                    forwattrs revattrs
                relvar eval {
                    relvar insert ${archns}::__Link [list\
                        Name    $relationship\
                        Class   $refclass(source)\
                        Attrs   $forwattrs\
                    ]
                    relvar insert ${archns}::__AssociationLink [list\
                        Name            $relationship\
                        SrcClass        $refclass(source)\
                        DstClass        ${domns}::$associator\
                        PrevSrcClass    {}\
                    ]
                    relvar insert ${archns}::__Link [list\
                        Name    ~$relationship\
                        Class   ${domns}::$associator\
                        Attrs   $revattrs\
                    ]
                    relvar insert ${archns}::__AssociationLink [list\
                        Name            ~$relationship\
                        SrcClass        ${domns}::$associator\
                        DstClass        $refclass(source)\
                        PrevSrcClass    $refclass(target)\
                    ]
                    relvar insert ${archns}::__AssocRef [list\
                        Relationship    $relationship\
                        AssocClass      ${domns}::$associator\
                        References      $assoclinks\
                    ]
                }

                lassign [WeaveLists $refattrs(target) $assocattrs(target)]\
                    forwattrs revattrs
                relvar eval {
                    relvar insert ${archns}::__Link [list\
                        Name    $relationship\
                        Class   ${domns}::$associator\
                        Attrs   $revattrs\
                    ]
                    relvar insert ${archns}::__AssociationLink [list\
                        Name            $relationship\
                        SrcClass        ${domns}::$associator\
                        DstClass        $refclass(target)\
                        PrevSrcClass    $refclass(source)\
                    ]
                    relvar insert ${archns}::__Link [list\
                        Name    ~$relationship\
                        Class   $refclass(target)\
                        Attrs   $forwattrs\
                    ]
                    relvar insert ${archns}::__AssociationLink [list\
                        Name            ~$relationship\
                        SrcClass        $refclass(target)\
                        DstClass        ${domns}::$associator\
                        PrevSrcClass    {}\
                    ]
                }
            }

            namespace ensemble create\
                -command ${domns}::$relationship\
                -map [dict create\
                    link [list ::rosea::RelCmds::linkAssoc $relationship]\
                    unlink [list ::rosea::RelCmds::unlinkAssoc $relationship]\
                ]
        }

        set gens [relation semijoin $rships $Generalization]
        relation foreach gen $gens {
            set subrefs [pipe {
                relation semijoin $gen $Subclass\
                        -using {Domain Domain Name Relationship}\
                    $ReferringClass $AttributeReference\
                        -using {Domain Domain Class ReferringClass\
                        Relationship Relationship Role ReferringRole} |
                relation project ~ Domain ReferringClass ReferringAttribute\
                    ReferencedClass ReferencedAttribute Relationship |
                relation group ~ ReferringAttrs\
                        ReferringAttribute ReferencedAttribute
            }]
            #puts [relformat $subrefs subrefs]

            set subparts [list]
            relation foreach subref $subrefs {
                relation assign $subref\
                    {Domain domain}\
                    {ReferringClass subclass}\
                    {ReferencedClass superclass}\
                    {Relationship relationship}\
                    {ReferringAttrs referringAttrs}

                set attrrefs [relation tag $referringAttrs RefOrder]
                set subattrs [relation list $attrrefs ReferringAttribute\
                        -ascending RefOrder]
                set superattrs [relation list $attrrefs ReferencedAttribute\
                        -ascending RefOrder]
                lassign [WeaveLists $subattrs $superattrs]\
                        forwattrs revattrs

                lappend subparts ${domns}::$subclass $subattrs

                relvar eval {
                    relvar insert ${archns}::__Link [list\
                        Name    $relationship\
                        Class   ${domns}::$subclass\
                        Attrs   $forwattrs\
                    ]
                    relvar insert ${archns}::__AssociationLink [list\
                        Name            $relationship\
                        SrcClass        ${domns}::$subclass\
                        DstClass        ${domns}::$superclass\
                        PrevSrcClass    {}\
                    ]
                    relvar insert ${archns}::__Link [list\
                        Name    ~$relationship\
                        Class   ${domns}::$subclass\
                        Attrs   $revattrs\
                    ]
                    relvar insert ${archns}::__PartitionLink [list\
                        Name        ~$relationship\
                        DstClass    ${domns}::$subclass\
                        SrcClass    ${domns}::$superclass\
                    ]
                    relvar uinsert ${archns}::__SuperLink [list\
                        Relationship    $relationship\
                        SuperClass      ${domns}::$superclass\
                    ]
                    relvar insert ${archns}::__SubLink [list\
                        Relationship    $relationship\
                        SubClass        ${domns}::$subclass\
                        AttrRefs        $referringAttrs\
                    ]
                }
            }

            relvar partition ${domns}::$relationship ${domns}::$superclass\
                    $superattrs {*}$subparts
            namespace ensemble create\
                -command ${domns}::$relationship\
                -map [dict create migrate [list ::rosea::RelCmds::migrate\
                        $relationship]]
        }
    }
    #puts [relformat [relvar set ${archns}::__Link] Link]
    #puts [relformat [relvar set ${archns}::__AssociationLink] AssociationLink]
    #puts [relformat [relvar set ${archns}::__PartitionLink] PartitionLink]
    #puts [relformat [relvar set ${archns}::__RefLink] RefLink]
    #puts [relformat [relvar set ${archns}::__AssocRef] AssocRef]
    #puts [relformat [relvar set ${archns}::__SuperLink] SuperLink]
    #puts [relformat [relvar set ${archns}::__SubLink] SubLink]
}

proc MapCondMultToConstraint {cond mult} {
    if {$cond && $mult} {
        return *
    } elseif {$cond && !$mult} {
        return ?
    } elseif {!$cond && $mult} {
        return +
    } elseif {!($cond || $mult)} {
        return 1
    }
}

proc WeaveLists {l1 l2} {
    set w1 [list]
    set w2 [list]
    foreach a $l1 b $l2 {
        lappend w1 $a $b
        lappend w2 $b $a
    }
    return [list $w1 $w2]
}
----

[source,tcl]
----
<<helper commands>>=
proc InsertTrace {defheading defvalues op relvar tuple} {
    tuple create\
        [dict merge $defheading [tuple heading $tuple]]\
        [dict merge $defvalues [tuple get $tuple]]
}
----

[source,tcl]
----
<<config command tests>>=
test generate-1.0 {
    Generate domain relvars
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class X {
                attribute x1 string -id 1
                attribute x2 string -default 20
            }
            class Y {
                attribute y1 string -id 1
            }
        }
    }
    rosea generate
    set rvnames [relvar names ::foo::*]
    expr {"::foo::X" in $rvnames && "::foo::Y" in $rvnames}
} -result {1}
----

[source,tcl]
----
<<test utility procs>>=
proc removeDomain {domns} {
    relvar constraint delete {*}[relvar constraint names ${domns}::*]
    relvar unset {*}[relvar names ${domns}::*]
    namespace delete $domns
}
----

[source,tcl]
----
<<config command tests>>=
test generate-1.1 {
    Generate domain relvars -- multiple identifiers
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class X {
                attribute x1 string -id 1
                attribute y1 string -id 1
                attribute z1 int -id 2
                attribute x2 string -default 20
            }
        }
    }
    rosea generate
    relvar identifiers ::foo::X
} -result {{x1 y1} z1}
----

[source,tcl]
----
<<config command tests>>=
test generate-2.0 {
    generate constraints for simple associative relationshp
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class x {
                attribute a1 string -id 1
                attribute a2 string -default 20
            }
            class y {
                attribute a1 string -id 1
                reference R1 x -link a1
            }
            association R1 y 1--1 x
        }
    }
    rosea generate
    relvar constraint info ::foo::R1
} -result {association ::foo::R1 ::foo::y a1 1 ::foo::x a1 1}
----

[source,tcl]
----
<<config command tests>>=
test generate-3.0 {
    generate constraints for class based associative relationshp
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class a {
                attribute ax1 string -id 1
                attribute ax2 string -id 1
                attribute ay1 string -id 1
                attribute ay2 string -id 1
                reference R1 x -link {ax1 x1} -link {ax2 x2}
                reference R1 y -link {ay1 y1} -link {ay2 y2}
            }
            class x {
                attribute x1 string -id 1
                attribute x2 string -id 1
                attribute x3 string -default 20
            }
            class y {
                attribute y1 string -id 1
                attribute y2 string -id 1
            }
            association R1 x 0..n--1..n y -associator a
        }
    }
    rosea generate
    relvar constraint info ::foo::R1
} -result {correlation ::foo::R1 ::foo::a {ax1 ax2} + ::foo::x {x1 x2} {ay1 ay2} * ::foo::y {y1 y2}}
----

[source,tcl]
----
<<config command tests>>=
test generate-4.0 {
    generate constraints for generalization relationship
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class super {
                attribute s1 string -id 1
                attribute s2 string -id 1
                attribute a2 string -default 20
            }
            class sub1 {
                attribute sb1 string -id 1
                attribute sb2 string -id 1
                reference R1 super -link {sb1 s1} -link {sb2 s2}
            }
            class sub2 {
                attribute sb3 string -id 1
                attribute sb4 string -id 1
                reference R1 super -link {sb3 s1} -link {sb4 s2}
            }
            generalization R1 super sub1 sub2
        }
    }
    rosea generate
    relvar constraint info ::foo::R1
} -result {partition ::foo::R1 ::foo::super {s1 s2} ::foo::sub2 {sb3 sb4} ::foo::sub1 {sb1 sb2}}
----

[source,tcl]
----
<<config command tests>>=
test generate-4.1 {
    generate linkage information for generalization
} -setup {
    rosea configure {
        domain foo {
            class S {
                attribute s1 string -id 1
                attribute s2 string -id 1
                attribute a2 int -default 20
            }
            class X {
                attribute x1 string -id 1
                attribute x2 string -id 1
                reference R1 S -link {x1 s1} -link {x2 s2}
            }
            class Y {
                attribute y1 string -id 1
                attribute y2 string -id 1
                reference R1 S -link {y1 s1} -link {y2 s2}
            }
            generalization R1 S X Y
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    relvar eval {
        foo::S create s1 a s2 b
        foo::X create x1 a x2 b
    }
    set ref [foo::X findWhere {$x1 eq "a"}]
    foo::R1 migrate $ref Y
} -result {::foo::Y {{y1 string y2 string} {{y1 a y2 b}}}} -match ref
----

[source,tcl]
----
<<config command tests>>=
test generate-5.0 {
    generate class based operations
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class c1 {
                attribute a1 string -id 1
                attribute a2 string

                classop echo {id} {
                    return $id
                }
            }
        }
    }
    rosea generate
    ::foo::c1 echo 27
} -result {27}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.0 {
    generate multiple classes and relationships, navigate
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    rosea configure {
        domain meta {
            class Class {
                attribute Domain string -id 1
                attribute Name string -id 1
            }

            class Attribute {
                attribute Domain string -id 1
                attribute Class string -id 1
                attribute Name string -id 1
                attribute Type string

                reference R3 Class -link Domain -link {Class Name}
            }
            association R3 Attribute 1..n--1 Class

            operation showAttrs {class} {
                set c1 [meta::Class findWhere\
                        {$Domain eq "foo" && $Name eq $class}]
                set attrs [findRelated $c1 ~R3]
                return [deRef $attrs]
            }
        }
    }
    rosea generate
    relvar eval {
        meta::Class create Domain foo Name c1
        meta::Attribute create Domain foo Class c1 Name a1 Type string
        meta::Attribute create Domain foo Class c1 Name a2 Type string
    }
    meta::showAttrs c1
} -result {{Domain string Class string Name string Type string} {{Domain foo Class c1 Name a1 Type string} {Domain foo Class c1 Name a2 Type string}}}\
    -match relation
----

[source,tcl]
----
<<config command tests>>=
test generate-6.1 {
    generate multiple classes and a relationship, link instances together
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 1..n--1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    relvar eval {
        set c1 [meta::C1 create Id foo A1 20]
        meta::C2 create Id bar C1Id {}
        meta::C2 create Id baz C1Id {}
        set c2 [meta::C2 create Id fub C1Id {}]
        meta::R1 link $c1 [meta::C2 findAll]
    }
    #puts [relformat [relvar set ::meta::C2] C2]
    rosea::InstCmds::readAttribute $c2 C1Id
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.2 {
    generate multiple classes and a relationship, unlink instances
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 0..n--0..1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    relvar eval {
        set c1 [meta::C1 create Id foo A1 20]
        meta::C2 create Id bar C1Id foo
        meta::C2 create Id baz C1Id foo
        set c2 [meta::C2 create Id fub C1Id foo]
    }
    meta::R1 unlink [meta::C2 findWhere {[string match b* $Id]}]
    #puts [relformat [relvar set ::meta::C2] C2]
    rosea::InstCmds::readAttribute $c2 C1Id
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.3 {
    generate multiple classes and a relationship, unlink by referred to instance
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 0..n--0..1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    relvar eval {
        set c1 [meta::C1 create Id foo A1 20]
        meta::C2 create Id bar C1Id foo
        meta::C2 create Id baz C1Id foo
        set c2 [meta::C2 create Id fub C1Id foo]
    }
    meta::R1 unlink $c1
    #puts [relformat [relvar set ::meta::C2] C2]
    rosea::InstCmds::readAttribute $c2 C1Id
} -result {}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.4 {
    generate class-based association and link instances
} -setup {
    rosea configure {
        domain foo {
            class A {
                attribute ax1 string -id 1
                attribute ax2 string -id 1
                attribute ay1 string -id 1
                attribute ay2 string -id 1
                reference R1 X -link {ax1 x1} -link {ax2 x2}
                reference R1 Y -link {ay1 y1} -link {ay2 y2}
            }
            class X {
                attribute x1 string -id 1
                attribute x2 string -id 1
                attribute x3 int
            }
            class Y {
                attribute y1 string -id 1
                attribute y2 string -id 1
                attribute y3 int
            }
            association R1 X 1..n--1..n Y -associator A
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    relvar eval {
        ::foo::X create x1 x1-1 x2 x2-1 x3 27
        ::foo::X create x1 x1-2 x2 x2-2 x3 47
        ::foo::Y create y1 y1-1 y2 y2-1 y3 57
        ::foo::Y create y1 y1-2 y2 y2-2 y3 67

        set assoc [::foo::R1 link [::foo::X findAll] [::foo::Y findAll]]
    }
    #puts [relformat [relvar set ::foo::A] A]
    ::rosea::Helpers::refMultiplicity $assoc
} -result {4}
----

=== Structuring Architectural Data

[source,tcl]
----
<<rosea commands>>=
proc GenerateArchStructures {domns} {
    set archns ${domns}::__Arch
    namespace eval ${archns} {}
    relvar create ${archns}::__State {
        Class string
        State string
    } {Class State}
    relvar create ${archns}::__Event {
        Class string
        Event string
    } {Class Event}
    relvar create ${archns}::__Transition {
        Class string
        State string
        Event string
        NewState string
    } {Class State Event}
    relvar create ${archns}::__InitialState {
        Class string
        State string
    } Class
    relvar create ${archns}::__Terminal {
        Class string
        State string
    } {Class State}
    relvar create ${archns}::__PolymorphicEvent {
        Class           string
        Event           string
    } {Class Event}
    relvar create ${archns}::__Link {
        Name            string
        Class           string
        Attrs           list
    } {Name Class}
    relvar create ${archns}::__AssociationLink {
        Name            string
        SrcClass        string
        DstClass        string
        PrevSrcClass    string
    } {Name SrcClass}
    relvar create ${archns}::__PartitionLink {
        Name            string
        DstClass        string
        SrcClass        string
    } {Name DstClass}
    relvar partition ${archns}::R3\
        ${archns}::__Link {Name Class}\
            ${archns}::__AssociationLink {Name SrcClass}\
            ${archns}::__PartitionLink {Name DstClass}
    relvar create ${archns}::__SuperLink {
        Relationship    string
        SuperClass      string
    } Relationship
    relvar create ${archns}::__SubLink {
        Relationship    string
        SubClass        string
        AttrRefs        {Relation {ReferringAttribute string\
                        ReferencedAttribute string}}
    } {Relationship SubClass}
    relvar association ${archns}::R4\
        ${archns}::__SubLink Relationship +\
        ${archns}::__SuperLink Relationship 1
    relvar create ${archns}::__RefLink {
        Relationship    string
        ReferringClass  string
        ReferencedClass string
        ReferringAttrs  {Relation {ReferringAttribute string\
                            ReferencedAttribute string}}
    } Relationship
    relvar create ${archns}::__AssocRef {
        Relationship    string
        AssocClass      string
        References      {Relation {Participant string Role string\
                    ReferringAttrs {Relation\
                    {ReferringAttribute string ReferencedAttribute string}}}}
    } Relationship

    return $archns
}
----

== Code Organization

In this section we show the organization of the files that can be
tangled from the literate source.
Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<rosea.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6

package require logger
<<required packages>>

namespace eval ::rosea {
    <<rosea exports>>
    namespace ensemble create

    variable version 1.0a1

    logger::initNamespace [namespace current]

    <<tclral imports>>
    <<rosea data>>
    <<rosea commands>>
    <<rosea namespace layout>>

    <<rosea imports>>
}

package provide rosea $::rosea::version
----

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded rosea 1.0a1 [list source [file join $dir rosea.tcl]]
----

=== Unit Tests

[source,tcl]
----
<<rosea.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger

<<required packages>>

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

logger::setlevel $options(level)

source ../src/rosea.tcl
chan puts "testing rosea version: [package require rosea]"

package require tcltest
eval tcltest::configure $argv

namespace eval ::rosea::test {
    namespace import ::tcltest::*
    <<tclral imports>>

    <<test utility procs>>
    <<helper command tests>>
    <<class command tests>>
    <<relationship command tests>>
    <<instance command tests>>
    <<dispatch command tests>>
    <<config command tests>>

    cleanupTests
}
----


////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk defintion ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
== Index
