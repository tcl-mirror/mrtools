// vim:set syntax=asciidoc:
= Relation Oriented Software Execution Architecture

[abstract]
This document describes a Tcl package named, +rosea+.
+rosea+ is an execution architecture intended as the target for
translating XUML models using Tcl as the implementation language.

== Introduction [[introduction,Introduction]]

This document is about a Tcl package named, +rosea+.
+rosea+ is a data and execution domain that is intended as the
target for translating XUML models using Tcl as the implementation
language.

This document is also a literate program.
As such, it contains all the descriptions, source code and test cases
for the +rosea+ package.
The conventions of the literate program are explained
<<literate-programming,below>>.

//////////
----
<<manual description>>=
This manpage describes the [package rosea] package.
[package Rosea] is a data and execution architecture for translating
XUML models using Tcl as the implementation language.
----
//////////

=== Design Strategy [[design-strategy,Design Strategy]]

One of main design choices for +rosea+ was to base its data
architecture on TclRAL.
TclRAL is a relational algebra library.
It is available as a ``C'' based extension under the package name +ral+.

The choice of TclRAL allows the data architecture to implement referential
integrity constraints.
Indeed the contraints that are part of TclRAL were designed specifically
to support the integrity requirements of XUML.
Many XUML execution architectures to not attempt to enforce the
referential integrity inherent in the class model relationships in XUML.
This is understandable for some platforms, such as embedded micro-controllers,
where the cost of enforcement is relatively high and the class of
applications fielded on the platforms tend to have static instance and
relationships populations.
With static populations,
the referential integrity can be checked at initialization time and
is usually not compromised when the system runs.

However,
when running on a more capable compute platform,
we want to take advantage of the referential integrity constraints
as a convenient, declarative way to better insure the correct operation
of the software.
By targeting Tcl as the implmentation language and using TclRAL as
the basis of the data architecture,
we achieve an XUML execution architecture that is very robust with
respect to insuring that the resulting program transitions from
one correct state to another.

==== Comparing Approaches [[comparing-approaches,Comparing Approaches]]

Comparing Approaches

* TclRAL and a bunch of procedures
* TclOO based
** each relvar a class
** each tuple an object
** large amount of OO machinery that is not used
** problems with lifetimes of object commands
* namespace ensemble based

=== Namespace Ensemble Approach [[namespace-ensemble-approach,Namespace Ensemble Approach]]
Namespace Ensemble Approach

* No unnecessary OO machinery that is not used.
* Convenient way to encapsulate a domain.

Parts of the puzzle

* procedures in the +rosea+ package to handle common XUML semantics
* configuration language to compute the mechanisms data structures and
layout the domain in the correct way.

Mapping concepts to Tcl implementation constructs.

["blockdiag",title="Basic Mapping of XUML Concepts"]
------
blockdiag {
    class longnode [width=150]
    domain [label="Domain"]
    namespace [label="Namespace"]
    class [label="XUML Class"]
    relvar [label="TclRAL relvar"]
    instance [label="XUML Instance"]
    tuple [label="Tuple in a relvar"]
    relationship [label="XUML Relationship"]
    constraint [label="TclRAL constraint"]
    classop [label="Class Operation"]
    clenscmd [label="Ensemble Subcommand", class=longnode]
    domop [label="Domain Operation"]
    domenscmd [label="Ensemble Subcommand", class=longnode]
    instop [label="Instance Operation"]
    inenscmd [label="Ensemble Subcommand", class=longnode]
    stateact [label="State Activity"]
    proc [label="Tcl proc"]

    domain -> namespace
    class -> relvar
    instance -> tuple
    relationship -> constraint
    domop -> domenscmd
    classop -> clenscmd
    instop -> inenscmd
    stateact -> proc
}
------

=== Relation Values, Relvars and Instance References -- Oh My!

Although the ideas of variables and values are well known,
it is worth clarifying the differences between variables and
values and how TclRAL constructs are involved.
Some of the confusion in this area arises from the conventional
use of symbol names in programing languages to stand for both
the variable and its value.

For example, consider the following ``C'' code.

[source,c,numbered]
----
int counter ;

counter = 27 ;

counter = counter + 3 ;
----

As line 1 shows, +counter+ is clearly a variable of integer type.
It is assigned the _value_ 27 on line 3.
Line 5 assigns the _value_ held by +counter+ added to the _value_ +3+ into the
_variable_, +counter+.
In ``C'' and many other languages, the interpretation of the symbol +counter+
depends upon whether it stands for a value in an expression
or as the target of an assignment.
In ``C'' parlance, the meaning is determined by whether +counter+ is
used as
http://en.wikipedia.org/wiki/Value_(computer_science)[an _lvalue_ or an _rvalue_].
Normally, we do not speak in such ultra-precise terms since context
shows whether we are interested in the _value_ contained by the _variable_
or whether we are talking about the memory allocated to the _variable_.

We can speak of relation values by analogy to _scalar_ values.
A _relation value_ is defined as a _heading_ and a _body_.
The heading consists of a set of named attributes and their corresponding
data types.
The body is a set of named values that correspond to the heading.
The tuples that are the body of the relation value form a set,
_i.e._ there are no duplicated tuples.
In TclRAL, a relation value has a string representation
(like all well behaved Tcl values)
that is a two element list representing the heading and the body.
Relation values in TclRAL are first class Tcl values integrated
into the internal Tcl type system and consequently
may be assigned to an ordinary Tcl variable and undergo the normal
lifecycle of values.
This latter point is important as we shall see later.

A _relation variable_ (or relvar) is a special type of variable
that holds a _relation value_.
The concept of a relvar is supplied by TclRAL and a relvar is _not_ an
ordinary Tcl variable.
TclRAL maintains a _shadow_ variable system for relvars.
The naming conventions follow those of ordinary Tcl variables in that
they can be qualified using namespace syntax.
The reason that relation variables are distinct from Tcl variables is that they
are also subject to _constraints_ for identity and referential integrity.
This is one of the major distinguishing aspects of relvars.
TclRAL has the subcommand, +relvar+, which operates directly on relvars and
a distinct subcommand, +relation+, that operates on relation values.
The command distinction helps to clarify the value / variable distinction.

We must also consider how we will deal with class instances.
For example,
in XUML events are signaled to instances of classes.
The correspondance that we are making is that an XUML class is
represented as a relvar and an XUML class instance is represented
as a tuple in the relation value stored in the class relvar.
So, we will find it necessary to refer to particular instances when
signaling events.
We will also find it necessary to refer to sets of instances when, for example,
we search for instances that meet some criteria.

With these considerations,
we define an _instance reference_ concept.
In the relational view,
the only way that you can refer to tuples in the relation values contained
in relvars is by the _values_ of identifying attributes.
There is no notion of indexing and order within the relation values is
not specified.
Each relvar must have at least one identifier.
An identifier is a set of attributes (often a single attribute but
not always), the values of which must be distinct from those of the
other tuples in the relvar.
To refer to an instance we need to know the relvar in questions and
the values of the attributes that constitute an identifier.
We will represent an instance reference as a two element list:

* A fully qualified relvar name.
* A relation value whose heading consists of the set attributes
that correspond to an identifier of the relvar.

This representation has several useful characteristics.

* An empty relation value indicates the _nil_ reference.
* The cardinality of the relation value can be greater than one and as
such represents a reference to a set of instances.
* An instance reference is just an ordinary Tcl value that can be stored
in an ordinary Tcl variable whose scope and lifetime is properly managed by Tcl
itself.

So we do not need to distinguish between an instance reference
and an instance reference set as distinct entities
(with potentially different data types)
as is often done in architectures that target staticly typed languages.
Our representation of an instance reference can refer to zero, one or
as many instances as needed.

Having defined an instance reference,
we will need several operations on them.

==== Creating References

Internally,
+rosea+ commands have need to create an instance references.
The +ToRef+ command takes a fully qualified relvar name and a relation value
that is a subset of the value held in the relvar and returns an instance
reference to the values.
This command is typically not used by application code.

[float]
===== Implementation
(((rosea,Helper,ToRef)))
[source,tcl]
----
<<helper commands>>=
proc ToRef {relvar relvalue} {
    tailcall list $relvar [relation project $relvalue\
        {*}[lindex [relvar identifiers $relvar] 0]] ; # <1>
}
----
<1> Let's step through this one command at a time,
starting at the inner nesting.
* +relvar identifiers+ returns a list of the identifiers of the relvar.
Since each relvar has at least one identifier, we can always index off
the first identifier.
* +relation project+ returns a new relation value that contains only
the attributes requested.
In this case we are asking for those attributes that form one of the
identifiers.
* We compose the two element list that defines an instance reference
and we can use +tailcall+ since this is the last command in the procedure.

[float]
===== Tests
[source,tcl]
----
<<helper command tests>>=
test ToRef-1.0 {
    Compute a reference to a relvar tuple
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
} -cleanup {
    relvar unset A
} -body {
    set value [relation create {Attr1 int Attr2 string} {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }]
    ::rosea::Helpers::ToRef [namespace current]::A $value
} -result {::rosea::test::A {{Attr1 int} {{Attr1 20} {Attr1 40}}}} -match ref
----

==== Dereferencing an Instance

We will also need to obtain the tuples referenced by an instance reference.
In other words we will need to derefence the instance.

[float]
===== Synopsis
====
+deRef+ _instref_ _?attr1 attr2 ...?_
====

The +deRef+ command takes an instance reference and returns a relation
value that contains all the tuples from the associated relvar that
match the identifying attribute values contained in the reference.
Optionally,
the +deRef+ command takes a set of attribute names.
In this case the returned instance will be a _projection_ of
the full instance relation, containing only the attributes
that form an identifier and the attributes given as arguments.

///////
----
<<manual architecture instance commands>>=
[call [cmd deRef] [arg instref] [opt [arg "attr1 attr2 ..."]]]

The [cmd deRef] command returns a relation value containing the
class instances referred to by [arg instref].
If no [arg attrN] arguments are given,
then the heading of the returned relation value contains all the
class attributes.
Otherwise, supplying [arg attr] names will result in the returned
relation value having only the given attributes plus a set of
identifying attributes.
----
///////

[float]
===== Implementation
(((rosea,Helper,DeRef)))
[source,tcl]
----
<<instance commands>>=
proc deRef {instref args} {
    lassign $instref relvar ref
    set inst [relation semijoin $ref [relvar set $relvar]] ; # <1>
    if {[llength $args] != 0} {
        set inst [relation project $inst\
            {*}[relation attributes $ref] {*}$args] ; # <2>
    }
    return $inst
}
----
<1> Dereferencing the instance is just a simple matter of ++semijoin++ing the
relation value in the instance reference to the value contained in the
relvar.
Like the core +::set+ command, invoking the +relvar set+ command without
any relation value simply returns the current value held in the _relvar_.
The +relation semijoin+ command returns a relation value whose heading
matches that of its final argument which in our case is that of the
referenced relvar value.
<2> If we are requesting specific attributes, then we project those out.
Note also that we need to project out the attributes of the +instref+ so
that we will have an identifier on the resulting relation value.
This allows us to use the result as an argument to the class +update+ command.

[float]
===== Tests
[source,tcl]
----
<<helper command tests>>=
test deRef-1.0 {
    Dereference to get a relation value
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }
} -cleanup {
    relvar unset A
} -body {
    set ref [list [namespace current]::A {{Attr1 int} {{Attr1 40}}}]
    rosea::InstCmds::deRef $ref
} -result {{Attr1 int Attr2 string} {{Attr1 40 Attr2 bar}}} -match relation
----

[source,tcl]
----
<<helper command tests>>=
test deRef-1.1 {
    Dereference to get a projection of the instance
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
        Attr3   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo Attr3 buzz
    } {
        Attr1 40 Attr2 bar Attr3 zub
    }
} -cleanup {
    relvar unset A
} -body {
    set ref [list [namespace current]::A {{Attr1 int} {{Attr1 40}}}]
    rosea::InstCmds::deRef $ref Attr3
} -result {{Attr1 int Attr3 string} {{Attr1 40 Attr3 zub}}} -match relation
----

==== Counting References

Since commands that search for instances return instance references
we will need some commands that can determine if we are indeed referring
to anything.

[float]
===== Synopsis
====
+isEmptyRef+ _instref_
====

The +isEmptyRef+ command returns a boolean indicating if +instref+
does not refer to any instances.

///////
----
<<manual architecture instance commands>>=
[call [cmd isEmptyRef] [arg instref]]

The [cmd isEmptyRef] command returns true if [arg instref] refers to
no instances and false otherwise.
----
///////


[float]
===== Implementation
(((rosea,InstCmds,isEmptyRef)))
[source,tcl]
----
<<instance commands>>=
proc isEmptyRef {instref} {
    tailcall relation isempty [lindex $instref 1]
}
----

Note that in relational algebra the empty relation, _i.e._ what we
have called here the _empty reference_ is perfectly valid.
It is well defined that dereferencing a empty reference simply
returns a relation value that contains no tuples.
It should _not_ be mistaken for the concept of the _nil_ or _NULL_ pointer
available in many languages where it is usually implemented as a special
address and dereferencing the +nil+ pointer is not allowed.
Nor should the empty reference be confused with the idea of a
+NULL+ attribute value as implemented by Relational Database Management
Systems that support SQL as a query language.footnote:[
Despite the similarity of the relationship concepts between TclRAL and
many RDMS, we have no concept of a +NULL+ value nor do we find any
need for one.
The kindest thing that can be said about SQL +NULL+ values is that is
a serious misfeature.
At worst it is simply an abomination.
]

[float]
===== Synopsis
====
+isNotEmptyRef+ _instref_
====

The +isNotEmptyRef+ command returns a boolean indicating if +instref+
refers to any instances.

///////
----
<<manual architecture instance commands>>=
[call [cmd isNotEmptyRef] [arg instref]]

The [cmd isNotEmptyRef] command returns true if [arg instref] refers to
any instances and false otherwise.
----
///////


[float]
===== Implementation
(((rosea,InstCmds,isNotEmptyRef)))
[source,tcl]
----
<<instance commands>>=
proc isNotEmptyRef {instref} {
    tailcall relation isnotempty [lindex $instref 1]
}
----

[float]
===== Synopsis
====
+refMultiplicity+ _instref_
====

The +refMultiplicity+ command returns the number of instances
referred to by +instref+.

///////
----
<<manual architecture instance commands>>=
[call [cmd refMultiplicity] [arg instref]]

The [cmd refMultiplicity] command returns the number of instances referenced
by [arg instref].
----
///////

[float]
===== Implementation
(((rosea,InstCmds,refMultiplicity)))
[source,tcl]
----
<<instance commands>>=
proc refMultiplicity {instref} {
    tailcall relation cardinality [lindex $instref 1]
}
----

[float]
===== Synopsis
====
+isRefSingular+ _instref_
====

The +isRefSingular+ command returns true if +instref+ refers to only one
instance.

///////
----
<<manual architecture instance commands>>=
[call [cmd isRefSingular] [arg instref]]

The [cmd isRefSingular] command returns true if [arg instref] refers to
exactly one instance and false otherwise.
----
///////


[float]
===== Implementation
(((rosea,InstCmds,isRefSingular)))
[source,tcl]
----
<<instance commands>>=
proc isRefSingular {instref} {
    expr {[refMultiplicity $instref] == 1}
}
----

==== Instance Reference Equality

The concept of reference equality is well defined.
It is the same idea as set equality.

[float]
===== Synopsis
====
+isRefEqual+ _instref1_ _instref2_
====

The +isRefEqual+ command returns true if +instref1+ and +instref2+ both
refer to the same set of tuples.

///////
----
<<manual architecture instance commands>>=
[call [cmd isRefEqual] [arg instref1] [arg instref2]]

The [cmd isRefEqual] command returns true if [arg instref1] and [arg instref2]
both refers to the same instances and false otherwise.
----
///////

[float]
===== Implementation
(((rosea,InstCmds,isRefEqual)))
[source,tcl]
----
<<instance commands>>=
proc isRefEqual {instref1 instref2} {
    lassign $instref1 relvar1 inst1
    lassign $instref2 relvar2 inst2
    return [expr {$relvar1 eq $relvar2 && [relation is $inst1 == $inst2]}]
}
----

==== Instance Reference Set Operations

[float]
===== Implementation
(((rosea,InstCmds,RefSetCommand)))
[source,tcl]
----
<<instance commands>>=
proc RefSetCommand {op instref1 instref2} {
    lassign $instref1 relvar1 inst1
    lassign $instref2 relvar2 inst2
    if {$relvar1 ne $relvar2} {
        tailcall DeclError SAME_CLASS $relvar1 $relvar2
    }
    return [list $relvar1 [relation $op $inst1 $inst2]]
}
----

(((error code,SAME_CLASS)))
[source,tcl]
----
<<error code formats>>=
SAME_CLASS   {operation is only allow for references of the same class,\
                got "%s" and "%s"}
----

///////
----
<<manual architecture instance commands>>=
[call [cmd refUnion] [arg instref1] [arg instref2]]

The [cmd refUnion] command computes the set union of the two instance
references given as arguments.
----
///////

[float]
===== Implementation
(((rosea,InstCmds,refUnion)))
[source,tcl]
----
<<instance commands>>=
proc refUnion {op instref1 instref2} {
    tailcall RefSetCommand union $instref1 $instref2
}
----

///////
----
<<manual architecture instance commands>>=
[call [cmd refIntersect] [arg instref1] [arg instref2]]

The [cmd refIntersect] command computes the set intersection of the two instance
references given as arguments.
----
///////

[float]
===== Implementation
(((rosea,InstCmds,refIntersect)))
[source,tcl]
----
<<instance commands>>=
proc refIntersect {op instref1 instref2} {
    tailcall RefSetCommand intersect $instref1 $instref2
}
----

///////
----
<<manual architecture instance commands>>=
[call [cmd refMinus] [arg instref1] [arg instref2]]

The [cmd refMinus] command computes the set differenct of [arg instref1]
minus [arg instref2].
----
///////

[float]
===== Implementation
(((rosea,InstCmds,refMinus)))
[source,tcl]
----
<<instance commands>>=
proc refMinus {op instref1 instref2} {
    tailcall RefSetCommand minus $instref1 $instref2
}
----

==== Iterating on References

We will find it convenient to iterate on the instances referred to
by an instance reference.
Recall, that an instance reference can refer to many tuples
and there are times when we want to visit each instance and run
some code.
As is typical in Tcl and following the pattern of the +foreach+ command,
we implement a control structure procedure to perform the iteration.

[float]
===== Synopsis
====
+forAllRefs+ _varname_ _instref_ _body_
====

The +forAllRefs+ command assigns an instance reference from a set
to a variable and executes a script for each instance.
Each iteration insures that the instance reference assigned to the
variable references only a single tuple.

///////
----
<<manual architecture instance commands>>=
[call [cmd forAllRefs] [arg varname] [arg instref] [arg script]]

The [cmd forAllRefs] command iterates across all the instance referred
to by [arg instref].
It assigns a singular instance reference into [arg varname] and then
executes [arg script].
----
///////


[float]
===== Implementation
(((rosea,InstCmds,forAllRefs)))
[source,tcl]
----
<<instance commands>>=
proc forAllRefs {varname instref body} {
    lassign $instref relvar refs
    upvar 1 $varname inst
    relation foreach ref $refs {
        set inst [list $relvar $ref]
        uplevel 1 $body
    } ; # <1>
    return
}
----
<1> The key command here is +relation foreach+ which performs an
iteration across a relation value, one tuple at a time.
We need only construct a new instance reference for each singular
relation value that +relation foreach+ generates.

=== Forming and Breaking Relationships

In XUML,
the real world associations between classes are modeled as relationships.
Relationships have their foundation in the referential integrity
concepts of relational algebra.
In this section,
we discuss how relationships are formed and broken and how
XUML relationships correspond to TclRAL referential integrity.

When translating an XUML class model onto a data architecture that
is based on relational algebra,
we must consider two fundamental ways classes may be associated with each
other.

* Building a correlation between instances.
* Dividing a set of instances into a disjoint union.

XUML models associate the instances of classes together to model
the semantics of subject matter rules.
From a relational algebra point of view,
class instances from two clases
may be correlated by representing each class as a
relvar and building a third class to contain attributes that
refer to the identifiers of the participating classes.
We will call this a _class based association_ and we will call
the class that performs the correlation by holding referential
attributes an _associator_.

// HERE we need a diagram showing some association.

Each instance of the associator class represents an instance
of the correlation that is formed between the instances of the
participating class.
So forming the relationship between class instances amounts to
creating instances of the associator class with the referential
attributes set to the proper values of the identifiers of the
participating classes.
Correspondingly,
destroying the correlation can be accomplished by deleting
instances of the associator class.

It is important to say at this point, that whether or not
adding or deleting instances of the associator class is a valid
operation depends upon the _multiplicity_ and _conditionality_
of the relationships.
So, it may be the case that adding an instance of an associator
will be rejected on the basis that the multiplicity of the
relationship (and therefore the relational algebraic referential
constraint) does not allow instances of a particular class to
be referenced multiple times or demands that an instance be
referenced at least once.

Analyzing the properties of the associator classes will show that
under the circumstances of one-to-one and one-to-many associations,
we can simplify our schema by placing the required referential
attributes into one of the participating classes and thereby eliminate
the need for a separate associator class.
We will call such arrangements _simple associations_.
They are quite common and usually form the preponderance of
relationships in any XUML model.
In the case of many-to-many associations or when the associator
class itself has attributes other than the required referential ones,
then simplifying the schema by eliminating the associator
and moving the referential attributes into one of the participant
classes is not available.

// HERE add diagram showing how the simplification can work.

For simple associations,
instances of the relationship are manipulated by updating the
values of the referential attributes that are part of the refering
class.
Again, whether such updates are valid will depend upon the multiplicity
and conditionality specified for the relationship.

Under one paritcular circumstance we have a small problem in attempting
to update a referential attribute.
Consider the case of a one-to-many relationship that is conditional
on the many side.
If we implement that by placing referential attributes in the
class on the many side, then we must decide what value to use when
updating the referential attributes for the case when we want to delete
the association.
Traditionally,
this is solved in data base management system using a *null* value.
We specifically eschew NULL valued logic as an abomination.
We must also account for the fact that Tcl has no null value
and, consequently, TclRAL has no concept of a null value.
In this situation,
a null would represent a value that is not a valid value for
the data type of the referential attributes.
In some languages you may define _algebraic data types_ that can
implement this concept.
That is not available to us in Tcl but, by special dispensation,
TclRAL does allow the empty string as a valid value of any data type.
Now as it turns out,
the empty string is a perfectly valid value and under many circumstances cannot
be used as some extraordinary value to indicate the absence of an instance of a
correlation.
As tempting as it may be,
the empty string really isn't the same as a null value or even the
same as a pointer value of all zero bits (_i.e._ as is defined in
many programming languages).

In this particular circumstance we must make some decision.
The options are:

* Translate the XUML relationship to use a class-based assocator
to implement it.
In this case the instances of the associator correspond to the
instances of the correlation and there is no quandry.
* Use the empty string as a _special_ value to indicte the lack of
a correlation.
This often works because the empty string can be used as a
value outside of the range of the data type of the referential attribute.
* Find some other extraordinary value that can represent a missing
correlation (_e.g._ -999 for some positive valued integer type).

In practice, the empty string works very well and allows
us to keep the simpler formulation of the correlation, but using a
associator class _always_ works.

XUML action languages support the operations of _link_ and _unlink_
as a means of creating and deleting associations between class instances.
For many XUML translation architectures,
particularly those targeting a statically typed programming language,
relationships are represented using pointer values.
In those cases, the _link_ and _unlink_ operations are translated into
updating pointer values.
For example, +STSA+ uses this technique.
When using relational algebra to implement a correlation type
relationship,
we need only create or delete instances of the associator
or update values of referential attributes to control the
association of class instances.

There are a few inferences we can draw from this.

* For class-based associations it is alway necessary to unlink
instances before re-linking them to other instances.
This arises because the instance of the associator class has
a direct correspondance to an instance of the relationship.
* For simple associations it is never necessary to unlink
an instance if it is to be relinked immediately.
This arises because we are only going to update a referential attribute
value.

In +rosea+, we provide +link+ and +unlink+ commands for
associative relationships as part of the namespace ensemble
created for the relationship.

The complement to correlation is partition.
In the XUML usage of the a generalization relationship,
the instances of the superclass are partitioned into a disjoint union
of the subclasses.
This partitioning insures that each subclass instance refers to
exactly one superclass instance and each superclass instance is
referenced by exactly on subclass instance from among the set of subclasses
of the generalization.

A close consideration of partitioning shows that there is no real need
for operations to link and unlink instances in a generalization relationship.
Since the characteristics of a parition insure that there
is a one-to-one correpondence between class instances,
the parition is created when the superclass and subclass are created
with the subclass have the proper values for its referential attributes.
Equally, an instance of the partition is deleted when the corresponding
superclass and subclass instances are deleted.
The only operation that is useful for a generalization relationship is that of
_migrating_ the generalization from one subclass to a different one and that is
the only operation provided by +rosea+ for generalization relationships.

=== Navigating the Model

In the relation model of data,
one can specify a set of constraints and have those constraints
enforced on the relvar values.
For TclRAL,
the form of these constraints was specifically designed to match
those needed by XUML.
From a relational algebra point of view,
the constraints declare the multiplicity and conditionality of
the association between tuples in relvars.

From an XUML point of view,
model relationships enforce both referential integrity and provide
a way to navigate around the class data.
It is common for state activities to read and update
data in the model and to use the relationship declarations
of the model to find related instances.
It is in this way that the semantics of the real-world association
that the relationship models is realized by the code execution.
Ultimately for an architecture based on relational algebra,
navigating the XUML class model via relationships
must be translated into a sequence of +semijoin+ operations.
In this section we discuss the concepts and syntax for accomplishing
that.

Conventionally,
XUML action languages specify the relationship navigation
by giving the relationship name and the destination class name, _e.g._

====
self -> R23[MOTOR]
====

would be a statement to select the instances across +R23+ that are
from the +MOTOR+ class.
This technique has an ambiguity for reflexive relationshipsfootnote:[
A reflexive relationship is one formed between a class and itself]
as it gives no way to determine the direction of the traversal
when the starting and ending of the traversal is the same class.
This usually has been resolved by using the relationship annotation
from the class model.

However, we specifically avoid using the model annotation to disambiguate
the reflexive relationship case.
We consider the phrases associated with the relationship in a model as
vital semantic annotation but that they should have no bearing on
how the model executes.
Changing model annotation should not invalidate action language statements.
The approach we adopt in +rosea+ is to give each relationship an
explicit direction and to use the destination class only in those
cases where the relationship type allows for multiple paths.
We will specify navigation in the forward direction using the relationship
name, _i.e._ +R1+, and in the reverse direction using the relationship
name prefixed by a tilde character, _i.e._ +~R1+.
Note that the use of the tilde character introduces a syntax convention for
the relationship traversal direction.

We will consider each type of relationship and show how the use of
a direction and sometimes a destination class allows for the navigation
of the class model.
Note also that this choice of specifying the relationship navigation
has no bearing on the XUML view of relationships in general.
We are not implying that the concept of a direction is a model level concept.
It is a particular technique that will be used as part of the syntax
for specifying the navigation operations for the +rosea+ archiecture.

==== Simple Associations

The figure below shows the case of a simple associative
relationship.
We choose the direction of the relationships to
be the same as the direction of reference of the referential attributes.
So we deem the source of the navigation to be the class
that contains the referential attributes and the destination of
the navigation to be the referenced class.
For the case of singular relationships,
the choice of where to place the referential attributes is sometimes
arbitrary,
but wherever the analyst has placed the referential attribute determines
the direction of the relationship.

image::assoc-link.pdf[title="Simple Associative Relationships"]

So, starting with an instance of +X+ we can find the related +Y+ instance
or instances by navigating across +R1+.
The reverse navigation from +Y+ to +X+ is across +~R1+.

==== Generalization

The figure below shows the case of a generalization relationship.
In a generalization,
the subclasses always contain the referential attributes and therefore
always refer to the superclass and the direction of a
generalization is always from the subclasses to the superclass.

image::partition-link.pdf[title="Generalization Relationship"]

So we can say that we navigate from a subclass, say +X+,
to the superclass, +S+, by +R1+.
In the case of navigating from the superclass to a subclass,
we will find it necessary to specify the destination class name.
So navigation from +S+ to +Y+ is specified as +~R1 Y+.
Because of the nature of a generalization,
navigating from superclass to a specific subclass will result in at most
one instance (and possibly zero) being found and 
navigating from subclass to superclass results in exactly one found instance.

==== Associative Classes

For class based associations,
it is the associator class that holds the referential attributes and
it will hold attributes that refer to both participating classes.
In this case,
the direction of the relationship must be arbitrarily assigned.
In the diagram below,
we have decided that the forward direction is traversing from +X+ to +Y+.

image::correl-link.pdf[title="Associative Class Relationship"]

So given an instance of +X+, we can navigate to +Y+ via +R1+ and,
conversely, navigate from +Y+ to +X+ via +~R1+.

Associator classes may also be the target of relationship navigation.
So we may wish to go from +X+ to +A+.
In this case we represent that as +R1 A+,
_i.e._ we go forward along +R1+ but stop at +A+.
Conversely,
we can navigate from +Y+ to +A+ along +~R1 A+.

==== Architecture Link Information

Given these syntax conventions,
we can design the data structures necessary to
support the run-time navigation of relationships as a series
of relational algebra +semijoin+ operations.
The diagram below shows a class diagram of the required data.

image::link-classes.pdf[title="Link Information Class Diagram"]

This is the first of several architectural data structures that
will be used to directly support the +rosea+ run-time.
We shall see others, for example, for state transitions.

=== Domain Organization [[domain-organization,Domain Organization]]

Domain Organization

["blockdiag",title="Namespace Organization for a Domain"]
------
blockdiag {
    class rvsetstyle [shape = roundedbox, stacked] ;
    class rvstyle [shape = roundedbox] ;
    class procstyle [shape = ellipse, stacked, width = 175, height = 50] ;

    domain [label = "::<domain name>", color = "#bbffb0"] ;
    relvars [label = "<class relvars>", class = "rvsetstyle"] ;
    classcmds [label = "<class ensemble\ncommands>", class = "procstyle"] ;
    relcmds [label = "<relationship\nensemble commands>",
        class = "procstyle"] ;
    arch [label = "::__Arch", color = "#ffe870"] ;

    class1 [label = "::<class 1>", color = "#ffe870"] ;
    class2 [label = "::<class 2>", color = "#ffe870"] ;
    classdots [shape = "dots"] ;
    classN [label = "::<class N>", color = "#ffe870"] ;

    domain -> relvars, classcmds, relcmds,
            class1, class2, classdots, classN, arch ;
    domain -> classdots [style = "none"] ;

    c2dots [shape = "dots"] ;
    class2 -> c2dots ;
    cNdots [shape = "dots"] ;
    classN -> cNdots ;

    archinfo [label = "<arch relvars>", class = "rvsetstyle"] ;

    arch -> archinfo ;

    instance [label = "__<class>__STATEINST", class = "rvstyle"] ;
    activity [label = "::__Activity", color = "#ff8b70"] ;
    classop [label = "::<class op procs>", class = "procstyle"] ;
    instop [label = "::<inst op procs>", class = "procstyle"] ;

    class1 -> instance, activity, classop, instop ;

    state [label = "::<state activity>", class = "procstyle"] ;

    activity -> state ;
}
------

==== Class Relvars
Class Relvars

==== Class Ensemble Commands
Class Ensemble Commands

==== Relationship Ensemble Commands
Relationship Ensemble Commands

==== Class Namespaces
Class Namespaces

==== Class Activity Procedures
Class Activities

==== Architecture Relvars

["blockdiag",title="Relvars Containing Architecture Information"]
------
blockdiag {
    class rvsetstyle [shape = roundedbox, stacked] ;
    class rvstyle [shape = roundedbox] ;

    archinfo [label = "<arch relvars>", class = "rvsetstyle"] ;

    state [label = "State", class = "rvstyle"]
    event [label = "Event", class = "rvstyle"]
    trans [label = "Transition", class = "rvstyle"]
    istate [label = "InitialState", class = "rvstyle"]
    term [label = "Terminal", class = "rvstyle"]
    link [label = "Link", class = "rvstyle"]
    assoclink [label = "AssociationLink", class = "rvstyle"]
    partlink [label = "PartitionLink", class = "rvstyle"]
    partdst [label = "PartitionDst", class = "rvstyle"]
    suplink [label = "SuperLink", class = "rvstyle"]
    sublink [label = "SubLink", class = "rvstyle"]
    reflink [label = "RefLink", class = "rvstyle"]
    assocref [label = "AssocRef", class = "rvstyle"]

    archinfo -> state, event, trans, istate, term,
        link, assoclink, partlink, partdst,
        suplink, sublink, reflink, assocref ;
}
------

=== Package Organization [[package-organization,Package Organization]]

Package Organization

["blockdiag",title="Namespace Organization for a rosea Package"]
------
blockdiag {
    class ns1st [color= "#bbffb0"]
    class ns2nd [color= "#ffe870"]

    rosea [label="::rosea",class=ns1st]
    classcmd [label="::ClassCmds",class=ns2nd]
    instcmd [label="::InstCmds",class=ns2nd]
    relcmd [label="::RelCmds",class=ns2nd]
    dispatchcmd [label="::Dispatch",class=ns2nd]
    configcmd [label="::Config",class=ns2nd]
    populatecmd [label="::Populate",class=ns2nd]
    tracecmd [label="::Trace",class=ns2nd]
    helpcmd [label="::Helpers",class=ns2nd]

    rosea -> classcmd, instcmd, relcmd, configcmd,
        populatecmd, tracecmd, dispatchcmd, helpcmd
}
------

== Package Procedures

In this section we begin showing all the procedures associated
with the +rosea+ run time itself.
These will be divided into sections that correspond to the figure
above that showed how the namespace for the packge would be organized.

We start with some preliminaries.
Since we are using TclRAL extensively,
we need to pull in the package.

[source,tcl]
----
<<required packages>>=
package require ral
package require ralutil
----

We will find it convenient to import some of the commands from
TclRAL since we will be using them repeatedly.

[source,tcl]
----
<<tclral imports>>=
namespace import ::ral::relation
namespace import ::ral::tuple
namespace import ::ral::relformat
namespace import ::ralutil::pipe
----

The namespace is organized as shown <<package-organization,above>>.

[source,tcl]
----
<<rosea namespace layout>>=
<<helper commands namespace>>
<<class commands namespace>>
<<instance commands namespace>>
<<relationship commands namespace>>
<<dispatch commands namespace>>
<<configuration commands namespace>>
<<population commands namespace>>
<<trace commands namespace>>
----

=== A Diversion for Testing

[source,tcl]
----
<<test utility procs>>=
proc refMatch {expected actual} {
    lassign $expected erelvar einst
    lassign $actual arelvar ainst
    return [expr {$erelvar eq $arelvar && [ral relation is $einst == $ainst]}]
}
customMatch ref [namespace current]::refMatch

proc relationMatch {expected actual} {
    return [::ral::relation is $expected == $actual]
}
customMatch relation [namespace current]::relationMatch
----

=== Class Commands

In this section we show the class oriented commands of +rosea+.
These commands are the architecture supplied class based based
operations.
These commands are the target of the ensemble mappings for each
of the classes in a domain.
Every class in the domain will have an ensemble command that is the
same name as the class.
All classes will have the commands discussed in this section plus any class
based operations that are defined for the class.
The invocation synopses below show how to invoke the class named
ensemble command.
The implementation has a different interface since the command ensemble
mechanism of Tcl will supply additional arguments.

Class oriented commands fall into these categories:

* Commands that search for instances.
* Commands that create and destroy instances.
* Commands that update the value of the underlying relvar.

First we create the namespace where the commands will reside.

[source,tcl]
----
<<class commands namespace>>=
namespace eval ClassCmds {
    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path [namespace parent]::Helpers ; # <1>
    <<class commands>>
}
----
<1> The helper commands are used everywhere so it is convenient to
include them in the command resolution path.

==== Find All Instances

The simplest search for instances is just to return them all.
The +findAll+ command returns an instance reference that refers to
all the instances of a class.

[float]
===== Synopsis
====
_class_ +findAll+
====

Returns an instance reference that refers to all the instances of _class_.

///////
----
<<manual architecture class commands>>=
[call [arg class] [cmd findAll]]

The [cmd findAll] command returns an instance reference that refers to
all the instances of [arg class].

[example {
set wms [WashingMachine findAll]
}]
----
///////

[float]
===== Implementation
(((rosea,ClassCmds,findAll)))
[source,tcl]
----
<<class commands>>=
proc findAll {relvar} {
    tailcall ToRef $relvar [relvar set $relvar]
}
----

==== Find an Instance by its Identifier

Sometimes the values of the identifying attributes are known and
we can directly locate the instance.

[float]
===== Synopsis
====
_class_ +findById+ _idattr1_ _idvalue1_ ...
====

+idattN+::
    The name of an identifying attribute.
+idvalueN+::
    The value of an identifying attribute.

The +findById+ subcommand returns a reference to at most one
instance of _class_.
The arguments are a set of name / value pairs for the attributes
that form an identifier for _class_.
The returned reference will be the empty reference if no instance
could be found that matches the values of the identifying attributes.

///////
----
<<manual architecture class commands>>=
[call [arg class] [cmd findById] [arg "idattr1 idvalue1 ..."]]

The [cmd findById] command returns an instance reference that refers to
at most on instance of [arg class] whose identifier values match those
give by the attribute name / value argument pairs.

[example {
set wc [WashingCycle findById CycleType Normal]
}]
----
///////

[float]
===== Implementation
(((rosea,ClassCmds,findById)))
[source,tcl]
----
<<class commands>>=
proc findById {relvar args} {
    tailcall ToRef $relvar [relvar restrictone $relvar {*}$args]
}
----

[float]
===== Tests
[source,tcl]
----
<<class command tests>>=
test findById-1.0 {
    Find tuple by value of the identifier
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }
} -cleanup {
    relvar unset A
} -body {
    rosea::ClassCmds::findById [namespace current]::A Attr1 20
} -result {::rosea::test::A {{Attr1 int} {{Attr1 20}}}} -match ref
----

==== Find Instances Meeting a Criteria

The general case is to find instances based on the result of
evaluating an expression.

[float]
===== Synopsis
====
_class_ +findWhere+ _expression_
====

+expression+::
    A Tcl expression which selects which instances are returned in the
    reference.

The +findWhere+ command takes an expression and returns an
instance reference for those instances of _class_
where the expression evaluates to true.
During execution, the values of the attributes will be placed in Tcl
variable that have the same name as the attribute.
The _expression_ argument may refer to the attribute-named variables
so that the selection can be based on the values in the instance.

///////
----
<<manual architecture class commands>>=
[call [arg class] [cmd findWhere] [arg expression]]

Returns an instance reference to instances of [arg class] where
[arg expression] evaluates to true.
During the evaluation of [arg expression],
the attributes of each tuple in [arg class] are assigned into Tcl
variable of the same name and [arg expression] may reference those
variables in determining the selection of tuples.

[example {
set hotcycles [WashingCycle findWhere {$WashWaterTemp eq "Hot"}]
}]
----
///////

[float]
===== Implementation
(((rosea,ClassCmds,findWhere)))
[source,tcl]
----
<<class commands>>=
proc findWhere {relvar expr} {
    tailcall ToRef $relvar [uplevel 1 [list ::ral relation restrictwith\
        [relvar set $relvar] $expr]]
}
----

[float]
===== Tests
[source,tcl]
----
<<class command tests>>=
test findWhere-1.0 {
    Find tuples based on an expression
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    } {
        Attr1 60 Attr2 baz
    }
} -cleanup {
    relvar unset A
} -body {
    # Make sure the expression is evaluated in the proper context
    # and can access local variables
    set lower 20
    set upper 60
    rosea::ClassCmds::findWhere [namespace current]::A {
        $Attr1 > $lower && $Attr1 < $upper
    }
} -result {::rosea::test::A {{Attr1 int} {{Attr1 40}}}} -match ref
----

==== More Testing Infrastructure

[source,tcl]
----
<<test utility procs>>=
proc setupDomain {name} {
    set domns [namespace current]::$name
    namespace eval $domns {}
    ::rosea::GenerateArchStructures $domns
}

proc cleanupDomain {name} {
    set domns [namespace current]::$name
    relvar constraint delete {*}[relvar constrain names ${domns}::*]
    relvar unset {*}[relvar names ${domns}::*]
    namespace delete $domns
}

proc addClass {domain class heading id} {
    set domns [namespace current]::$domain
    set idheading [list]
    foreach attr $id {
        lappend idheading $attr [dict get $heading $attr]
    }
    relvar create ${domns}::__${class}__STATEINST\
        [concat $idheading [list __State string]]\
        $id
    relvar create ${domns}::$class $heading $id
    namespace eval ${domns}::${class}::__Activity {}
}

proc addState {domain args} {
    relvar insert [namespace current]::${domain}::__Arch::State $args
}

proc addEvent {domain args} {
    relvar insert [namespace current]::${domain}::__Arch::Event $args
}

proc addTransition {domain args} {
    relvar insert [namespace current]::${domain}::__Arch::Transition $args
}

proc addInitialState {domain args} {
    relvar insert [namespace current]::${domain}::__Arch::InitialState $args
}

proc addAssocLink {domain linkattrs assocattrs} {
    relvar eval {
        relvar insert [namespace current]::${domain}::__Arch::Link $linkattrs
        relvar insert [namespace current]::${domain}::__Arch::AssociationLink\
                $assocattrs
    }
}

proc addParitionLink {domain linkattrs} {
    relvar insert [namespace current]::${domain}::__Arch::Link $linkattrs
    relvar insert [namespace current]::${domain}::__Arch::PartitionLink\
            $linkattrs
}

proc addPartitionDst {domain dstattrs} {
    relvar insert [namespace current]::${domain}::__Arch::PartitionDst\
        $dstattrs
}
----

==== Create an Instance

The +create+ command creates instances.
If the class has a state model, then the instance is placed in its
default initial state.

[float]
===== Synopsis
====
_class_ +create+ _attr1_ _value1_ _attr2_ _value2_ ...
====

+attrN+::
    The name of an attribute of _class_.
+valueN+::
    The corresponding value to be given to the attribute.

When creating an instance,
it is necessary to give each attribute a value,
unless a default value was defined for the attribute.
The command returns an instance reference to the newly created instance.

///////
----
<<manual architecture class commands>>=
[call [arg class] [cmd create] [arg "attr1 value1 attr2 value2 ..."]]

The [cmd create] command creates an instance of [arg class].
The attributes of the class will be set
according to the attribute names / value pairs given as arguments.
All attributes must be given a value unless a particular attribute
was configured to have a default value.
In that case,
the attribute need not be included in the arguments and its default
value will be used instead.

If [arg class] has an associated state model,
then the newly created instance will be placed in the default initial state.
However, no state activity is executed.

The command returns a reference to the newly created instance.

[example {
set wm [WashingMachine create MachineID washer2 CycleType Normal]
}]
----
///////

[float]
===== Implementation
(((rosea,ClassCmds,create)))
[source,tcl]
----
<<class commands>>=
proc create {relvar args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }
    set ref [ToRef $relvar [relvar insert $relvar $args]] ; # <1>
    lassign [SplitRelvarName $relvar] domain class
    CreateInInitialStateFromRef $domain $class $ref
    return $ref
}
----
<1> Here we see the correspondence between an XUML class instance and
a tuple in a relvar.
The instance is create by inserting a tuple into the relvar.

[float]
===== Tests
[source,tcl]
----
<<class command tests>>=
test create-1.0 {
    Create an instance -- no state model
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
} -cleanup {
    cleanupDomain foo
} -body {
    rosea::ClassCmds::create [namespace current]::foo::c1 A1 20 A2 bar
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 20}}}} -match ref
----

==== Create an Instance in a Given State

It is sometimes desirable to create an instance in a state other than
its default initial state.

[float]
===== Synopsis
====
_class_ +createin+ _state_ _attr1_ _value1_ _attr2_ _value2_ ...
====

+state+::
    The name of the state in which the new instance is placed.
    The action of that state is *not* executed.
+attrN+::
    The name of an attribute of _class_.
+valueN+::
    The corresponding value to be given to the attribute.

When creating an instance,
it is necessary to give each attribute a value,
unless a default value was defined for the attribute.
The command returns an instance reference to the newly created instance.

///////
----
<<manual architecture class commands>>=
[call [arg class] [cmd createin] [arg state]\
    [arg "attr1 value1 attr2 value2 ..."]]

The [cmd createin] command creates an instance of [arg class]
and places the newly created instance into the [arg state] state.
No state activity is executed.
It is an error to invoke [cmd createin] if [arg class] does not have
an associated state machine.

The attributes of the class will be set
according to the attribute names / value pairs given as arguments.
All attributes must be given a value unless a particular attribute
was configured to have a default value.
In that case,
the attribute need not be included in the arguments and its default
value will be used instead.

The command returns a reference to the newly created instance.

[example {
set wm [WashingMachine createin Washing MachineID washer2 CycleType Normal]
}]
----
///////

[float]
===== Implementation
(((rosea,ClassCmds,createin)))
[source,tcl]
----
<<class commands>>=
proc createin {relvar state args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }
    lassign [SplitRelvarName $relvar] domain class
    set initstate [relvar restrictone ${domain}::__Arch::State\
        Class $class State $state]
    if {[relation isempty $initstate]} { # <1>
        tailcall DeclError UNKNOWN_STATE $state $relvar
    }
    set ref [ToRef $relvar [relvar insert $relvar $args]]
    CreateStateInstanceFromRef $domain $class $state $ref
    return $ref
}
----
<1> First, we must make sure that requested state is indeed a state of the
class.

(((error code,UNKNOWN_STATE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_STATE   {unknown state, "%s", for class, "%s"}
----

[float]
===== Tests
[source,tcl]
----
<<class command tests>>=
test createin-1.0 {
    Create an instance in a given state
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    relvar eval {
        addState foo Class c1 State Idle
        addEvent foo Class c1 Event e1
        addTransition foo Class c1 State Idle Event e1 NewState Idle
        addInitialState foo Class c1 State Idle
    }
} -cleanup {
    cleanupDomain foo
} -body {
    set ref [::rosea::ClassCmds::createin [namespace current]::foo::c1\
        Idle A1 40 A2 bar]
    set statetest [pipe {
        relvar restrictone ::rosea::test::foo::__c1__STATEINST A1 40 |
        relation extract ~ __State
    }]
    expr {$statetest eq "Idle" &&\
        [refMatch {::rosea::test::foo::c1 {{A1 int} {{A1 40}}}} $ref]}
} -result {1}
----

We factor out the code to create the instance tuple that tracks
the state of the instance.

(((rosea,Helper,CreateStateInstance)))
[source,tcl]
----
<<helper commands>>=
proc CreateStateInstance {domns class state value} {
    tailcall relvar insert ${domns}::__${class}__STATEINST\
            [concat $value [list __State $state]]
}
----

(((rosea,Helper,CreateStateInstanceFromRef)))
[source,tcl]
----
<<helper commands>>=
proc CreateStateInstanceFromRef {domns class state ref} {
    tailcall CreateStateInstance $domns $class $state\
        [tuple get [relation tuple [lindex $ref 1]]]
}
----

(((rosea,Helper,CreateInInitialState)))
[source,tcl]
----
<<helper commands>>=
proc CreateInInitialState {domns class value} {
    set initstate [relvar restrictone ${domns}::__Arch::InitialState\
        Class $class]
    if {[relation isnotempty $initstate]} {
        CreateStateInstance $domns $class [relation extract $initstate State]\
            $value
    }
    return
}
----

(((rosea,Helper,CreateInInitialStateFromRef)))
[source,tcl]
----
<<helper commands>>=
proc CreateInInitialStateFromRef {domns class ref} {
    set initstate [relvar restrictone ${domns}::__Arch::InitialState\
        Class $class]
    if {[relation isnotempty $initstate]} {
        CreateStateInstanceFromRef $domns $class\
            [relation extract $initstate State] $ref
    }
    return
}
----

==== Asynchronous Instance Creation

The above creation commands are used to create class instances
synchronously.
For those cases,
the instance is placed in an initial state
(if it has an associated state model),
but no state activity is executed as part of the creation.

By contrast,
asynchronous creation signals an event to a newly created instance
to cause a transition and, necessarily, have a state activity executed.
These events are sometimes referred to as _creation_ events.

[float]
===== Synopsis
====
_class_ +createasync+ _event_ _eventparams_ _attr1_ _value1_ _attr2_ _value2_ ...
====

+event+::
    The name of the event to send to the newly created instance.
+eventparams+::
    A list of event parameters that are to be sent along with the event.
    If the event does not carry any parameters, then this argument must
    be specified as the empty list.
+attrN+::
    The name of an attribute of _class_.
+valueN+::
    The corresponding value to be given to the attribute.

The command returns an instance reference to the newly created instance.
Note however, that the event transition will *not* have occurred.
When creating an instance,
it is necessary to give each attribute a value,
unless a default value was defined for the attribute.

///////
----
<<manual architecture class commands>>=
[call [arg class] [cmd createasync] [arg event] [arg eventparams]\
    [arg "attr1 value1 attr2 value2 ..."]]

The [cmd createasync] command creates an instance of [arg class]
and places the newly created instance into a pseudo-initial state.
Then [arg event] along with the event parameters given by
[arg eventparams] is signaled to the newly created instance.
[arg Eventparams] is intepreted as a list of parameter values that
must match the parameters of the state into which [arg event]
causes a transition.
It is an error to invoke [cmd createin] if [arg class] does not have
an associated state machine or if [arg class] does not have a
transition specified to originate from the pseudo-initial state
of "@".

The attributes of the class will be set
according to the attribute names / value pairs given as arguments.
All attributes must be given a value unless a particular attribute
was configured to have a default value.
In that case,
the attribute need not be included in the arguments and its default
value will be used instead.

The command returns a reference to the newly created instance.
Note however, that the event transition will [emph not] have occurred.

[example {
set r [Reactor createin Process {temp 300} VesselId A270]
}]
----
///////

[float]
===== Implementation
(((rosea,ClassCmds,createasync)))
[source,tcl]
----
<<class commands>>=
proc createasync {relvar event eventparams args} {
    lassign [SplitRelvarName $relvar] domain class
    set knownevent [relvar restrictone ${domain}::__Arch::Event\
        Class $class Event $event]
    if {[relation isempty $knownevent]} { # <1>
        tailcall DeclError UNKNOWN_EVENT $event $class
    }
    set instref [createin $relvar @ {*}$args] ; # <2>
    ::rosea::Trace::TraceCreation [SelfInstRef 1] $event $instref
    ::rosea::InstCmds::signal $instref $event {*}$eventparams
    return $instref
}
----
<1> We must make sure that the event is one to which the instance responds.
<2> The ``@'' state is a special initial pseudo-state from which the
creation event causes a transition.

(((error code,UNKNOWN_STATE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_EVENT   {unknown event, "%s", for class, "%s"}
----

==== Updating Class Values

It is often more convenient to perform operations on a set of
instances and then have the results of the operations updated.
This command will update an entire set of non-identifying attribute values.

[float]
===== Synopsis
====
_class_ +update+ _relationvalue_
====

Update the non-identifying attributes of _class_ based on the values
in the heading of _relationvalue_.
The head of _relationvalue_ must include the attributes of at least
one identifier.
The tuples in _class_ that match the identifying attribute values will
have the remaining non-identifying attributes changed to match the
values found in _relationvalue_

///////
----
<<manual architecture class commands>>=
[call [arg class] [cmd update] [arg relationvalue]]

The [cmd update] command updates into [arg class] all the non-identifying
attributes contained in [arg relationvalue].
One way to modify attribute values as a set is to dereference a set
of instances, perform a series of operations via the [cmd "ral relation"]
command to yield a new relation value that is then used to update
the instances of [arg class].

Assuming that the [arg ref] variable contains an instance reference
to a class, [arg Vessel], that has attributes [arg Temp] and [arg Volume],
the following code will add 10 to the [arg Temp] and double the [arg Volume]
for all instances referred to by [arg ref]

[example {
Vessel update [relation update [deRef $ref Temp Volume] newtuple {1} {
    tuple update $newtuple\ 
        Temp [expr {[tuple extract $newtuple Temp] + 10}]\ 
        Volume [expr {[tuple extract $newtuple Volume] * 2.0}]
}]
}]
----
///////

[float]
===== Implementation
(((rosea,ClassCmds,update)))
[source,tcl]
----
<<class commands>>=
proc update {relvar relvalue} {
    tailcall ToRef $relvar [relvar updateper $relvar $relvalue]
}
----

[float]
===== Tests
[source,tcl]
----
<<class command tests>>=
test update-1.0 {
    Update a set of attribute values
} -setup {
    setupDomain foo
    addClass foo c1 {A1 string Temp int Volume double} A1
    rosea::ClassCmds::create [namespace current]::foo::c1\
        A1 tank1 Temp 100 Volume 3.3
    rosea::ClassCmds::create [namespace current]::foo::c1\
        A1 tank2 Temp 200 Volume 6.3
    rosea::ClassCmds::create [namespace current]::foo::c1\
        A1 tank3 Temp 300 Volume 10.3
} -cleanup {
    cleanupDomain foo
} -body {
    set ref [rosea::ClassCmds::findAll [namespace current]::foo::c1]
    # This adds 10 to the Temp and multiplies the Volume by 2 for
    # all the instances. We do it by extending relation value with
    # new attributes and then eliminating the old attributes and renaming
    # the new attributes to have the old attribute names.
    set newvalues [relation update [rosea::InstCmds::deRef $ref Temp Volume]\
            newtuple {1} {
        tuple update $newtuple\
            Temp [expr {[tuple extract $newtuple Temp] + 10}]\
            Volume [expr {[tuple extract $newtuple Volume] * 2.0}]
    }]
    log::debug [relformat $newvalues newvalues]
    set ref [rosea::ClassCmds::update [namespace current]::foo::c1 $newvalues]
    # Extract one of the instances and make sure the attribute values
    # were properly updated.
    pipe {
        rosea::InstCmds::deRef $ref |
        relation restrictwith ~ {$Temp < 200} |
        relation extract ~ Temp Volume
    }
} -result {110 6.6}
----

=== Relationship Commands

In this section we show the relationship oriented commands of +rosea+.
These commands are supplied by the architecture and are the
the commands to which the relationship ensemble is mapped.

We place the relationship commands into a separate namespace.

[source,tcl]
----
<<relationship commands namespace>>=
namespace eval RelCmds {
    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path [list\
        [namespace parent]::Helpers\
        [namespace parent]::InstCmds\
    ]
    <<relationship commands>>
}
----

==== Linking Instances Across Relationships

We first consider linking across simple relationships.
Later we discuss linking for class based associations.
They are very similar, but class bases associations may require
additional arguments.

[float]
===== Synopsis
====
_relationship_ +link+ _instref1_ _instref2_
====

+instref1+::
    An instance reference to a class that participates in
    _relationship_.
+instref1+::
    An instance reference to the other class that participates in
    _relationship_.

The +link+ command create an relationship linkage for the simple
association, _relationship_.

///////
----
<<manual architecture relationship commands>>=
[call [arg relationship] [cmd link] [arg instref1] [arg instref2]]
----
///////

[float]
===== Implementation
As we discussed above,
linking across simple relationships is accomplished by
updating referential attributes.
The implementation must account for two complications.

First, we want to be able to give instance references in any order
so we will need to be able to determine which class is the
referring class and which is the referenced class.
Second, the linking is accomplished by storing the values of the
referenced attributes into the referential attributes and so we need
to know the correspondence between the two sets of attributes and
query the referenced attributes to get their values.

[source,tcl]
----
<<relationship commands>>=
proc linkSimple {rname instref1 instref2} {
    lassign $instref1 relvar1 inst1
    lassign [SplitRelvarName $relvar1] domain1 class1

    lassign $instref2 relvar2 inst2
    lassign [SplitRelvarName $relvar2] domain2 class2

    if {$domain1 ne $domain2} {
        tailcall DeclError NO_CROSS_DOMAIN $domain1 $domain2
    }

    set archns ${domain1}::__Arch

    set reflink [relvar restrictone ${archns}::RefLink Relationship $rname]
    if {[relation isempty $reflink]} {
        tailcall DeclError UNKNOWN_RELATIONSHIP $rname
    }
    relation assign $reflink\
        {ReferringClass referringClass}\
        {ReferencedClass referencedClass}\
        {ReferringAttrs referringAttrs}

    # First we determine which of the argument instance references are from the
    # referring class and which from the referenced class.
    if {$class1 eq $referringClass && $class2 eq $referencedClass} {
        set fromrelvar $relvar1
        set frominsts $inst1
        set torelvar $relvar2
        set toinst $inst2
    } elseif {$class2 eq $referringClass && $class1 eq $referencedClass} {
        set fromrelvar $relvar2
        set frominsts $inst2
        set torelvar $relvar1
        set toinst $inst1
    } else {
        tailcall DeclError NON_PARTICIPANTS $relvar1 $relvar2 $rname\
            $referringClass $referencedClass
    }

    # You may link many referring instances to the same referenced instance,
    # but there can only be one referenced instance
    if {[relation cardinality $toinst] != 1} {
        tailcall MUST_BE_SINGULAR $torelvar [relation cardinality $toinst]
    }

    # The update we want to perform is to modify the values of the referential
    # attributes to match the values of the referenced attributes. First we
    # deference the referenced instance.  We perform the implied semijoin in
    # place since we have already split apart the instance reference into its
    # components.
    set refedvalue [relation semijoin $toinst [relvar set $torelvar]]

    # Our stategy for updating the referential attributes is to create a
    # dictionary whose keys are the referential attribute names the values are
    # those of the referenced attributes.  It is important to maintain the
    # correspondence between the referential and referenced attributes. The
    # architectural data structures do this by have the ReferringAttrs as a
    # relation valued attribute.  So it is a matter of extending that relation
    # to include the values and extracting the dictionary.
    set tovalues [pipe {
        relation extend $referringAttrs rfa RefValue string {
            [relation extract $refedvalue\
                [tuple extract $rfa ReferencedAttribute]]
        } |
        relation dict ~ ReferringAttribute RefValue
    }]

    # Now we iterate across the referring instances updating the referential
    # attributes to be the values of the dictionary we just computed.
    relation foreach frominst $frominsts {
        relvar updateone $fromrelvar fromtup\
                [tuple get [relation tuple $frominst]] {
            tuple update $fromtup {*}$tovalues
        }
    }

    return
}
----

(((error code,NO_CROSS_DOMAIN)))
(((error code,UNKNOWN_RELATIONSHIP)))
(((error code,NON_PARTICIPANTS)))
(((error code,MUST_BE_SINGULAR)))
[source,tcl]
----
<<error code formats>>=
NO_CROSS_DOMAIN         {cannot link instances across domains,\
                            got "%s" and "%s"}
UNKNOWN_RELATIONSHIP    {unknown relationship, "%s"}
NON_PARTICIPANTS        {"%s" and "%s" don't participate in %s,\
                            expected "%s" and "%s"}
MUST_BE_SINGULAR        {number of refered to instances for "%s" must be one,\
                            got %d}
----

When a class based association is linked,
we must create an instance of the associator class.
In general,
The associator may have additional attributes other than the referential
attributes involved in the association.
If so, then values must be supplied for those attributes.

///////
----
<<manual architecture relationship commands>>=
[call [arg relationship] [cmd link] [arg instref1] [arg instref2]\
    [opt [arg "attr1 value1 attr2 value2 ..."]]]
----
///////

[float]
===== Implementation
[source,tcl]
----
<<relationship commands>>=
proc linkAssoc {rname instref1 instref2 args} {
    lassign $instref1 relvar1 inst1
    lassign [SplitRelvarName $relvar1] domain1 class1

    lassign $instref2 relvar2 inst2
    lassign [SplitRelvarName $relvar2] domain2 class2

    if {$domain1 ne $domain2} {
        tailcall DeclError NO_CROSS_DOMAIN $domain1 $domain2
    }

    set archns ${domain1}::__Arch

    set assocref [relvar restrictone ${archns}::AssocRef Relationship $rname]
    if {[relation isempty $assocref]} {
        tailcall DeclError UNKNOWN_RELATIONSHIP $rname
    }

    relation assign $assocref\
        {AssocClass assocClass}\
        {References references}

    # For class based associations, we need to identify the participants
    # and check that the instance references refer to relvar that
    # indeed participate in the relationship.
    set ref1 [relation restrictwith $references {$Participant eq $class1}]
    if {[relation isempty $ref1]} {
        tailcall DeclError NOT_IN_ASSOCIATION $class1 $rname
    }
    # Reflexive associations have to be considered. If the association is
    # reflexive then the above query will yield two tuples since the
    # Participants are the same name. In this case, we query for the "target"
    # as a means of disambiguating the reflexive relationship.
    if {[relation cardinality $ref1] > 1} {
        set ref2 [relation restrictwith $ref1 {$Role eq "target"}]
        set ref1 [relation minus $ref1 $ref2]
    } else {
        # For the non-reflexive case, we can just find the other participant,
        # checking that it is indeed there.
        set ref2 [relation restrictwith $references {$Participant eq $class2}]
        if {[relation isempty $ref2]} {
            tailcall DeclError NOT_IN_ASSOCIATION $class2 $rname
        }
    }

    # Dereference the referenced values via the instance reference.
    set values1 [pipe {
        relvar set $relvar1 |
        relation semijoin $inst1 ~
    }]
    set values2 [pipe {
        relvar set $relvar2 |
        relation semijoin $inst2 ~
    }]

    # We use a similar strategy here as with "linkSimple". We want to create
    # dictionaries with the referring attributes as keys and the referenced
    # values as the dictionary values.
    set rattr1 [relation extract $ref1 ReferringAttrs]
    set rattr2 [relation extract $ref2 ReferringAttrs]

    # Since linking a class based associations amounts to inserting tuples in
    # the associator relvar, we will accumulate the set of tuples and perform a
    # single "relvar insert".
    set assoctuples [list]
    relation foreach v1 $values1 { # <1>
        set refto1 [pipe {
            relation extend $rattr1 rfa RefValue string {
                [relation extract $v1 [tuple extract $rfa ReferencedAttribute]]
            } |
            relation dict ~ ReferringAttribute RefValue
        }]
        relation foreach v2 $values2 {
            set refto2 [pipe {
                relation extend $rattr2 rfa RefValue string {
                    [relation extract $v2\
                        [tuple extract $rfa ReferencedAttribute]]
                } |
                relation dict ~ ReferringAttribute RefValue
            }]

            # It may be the case that the associator class has other
            # attributes. Those are passed as attribute/value pairs in the
            # "args". The merge order is important here just in case the caller
            # tried to set one of the referential attributes in the invocation.
            lappend assoctuples [dict merge $args $refto1 $refto2]
        }
    }

    return [ToRef ${domain1}::$assocClass\
            [relvar insert ${domain1}::$assocClass {*}$assoctuples]]
}
----
<1> The instance references may refer to multiple instances so we need to
compute the Cartesian product of the instance references.
The nested iteration will insure that we end up with an associator
instance for each instance in each of the instance references.

(((error code,NOT_IN_ASSOCIATION)))
[source,tcl]
----
<<error code formats>>=
NOT_IN_ASSOCIATION         {"%s" $relvar1 not a participant in "%s"}
----

==== Unlinking Instances Across Relationships

Unlinking Instances Across Relationships

///////
----
<<manual architecture relationship commands>>=
[call [arg relationship] [cmd unlink] [arg instref1]]
----
///////


[float]
===== Implementation
[source,tcl]
----
<<relationship commands>>=
proc unlinkSimple {rname instref} {
    lassign $instref relvar inst
    lassign [SplitRelvarName $relvar] domain class

    set archns ${domain}::__Arch

    set reflink [relvar restrictone ${archns}::RefLink Relationship $rname]
    if {[relation isempty $reflink]} {
        tailcall DeclError UNKNOWN_RELATIONSHIP $rname
    }
    relation assign $reflink\
        {ReferringClass referringClass}\
        {ReferencedClass referencedClass}\
        {ReferringAttrs referringAttrs}

    if {$class eq $referringClass} {
        set fromrelvar $relvar
        set frominsts $inst
    } elseif {$class eq $referencedClass} {
        lassign [::rosea::InstCmds::findRelated $instref ~$rname]\
            fromrelvar frominsts
    } else {
        tailcall DeclError NOT_IN_ASSOCIATION $relvar $rname
    }

    set tovalues [pipe {
        relation extend $referringAttrs rfa RefValue string {{}} |
        relation dict ~ ReferringAttribute RefValue
    }]

    relation foreach frominst $frominsts {
        relvar updateone $fromrelvar fromtup\
                [tuple get [relation tuple $frominst]] {
            tuple update $fromtup {*}$tovalues
        }
    }

    return
}
----


[float]
===== Implementation
[source,tcl]
----
<<relationship commands>>=
proc unlinkAssoc {rname instref} {
    lassign $instref relvar insts
    lassign [SplitRelvarName $relvar] domain class

    set archns ${domain}::__Arch

    set assocref [relvar restrictone ${archns}::AssocRef Relationship $rname]
    if {[relation isempty $assocref]} {
        tailcall DeclError UNKNOWN_RELATIONSHIP $rname
    }
    relation assign $assocref\
        {Relationship relationship}\
        {AssocClass associator}\
        {References references}

    if {$class eq $associator} {
        set associnsts [deRef $instref]
    } else {
        set part [relation restrictwith $references {$Participant eq $class}]
        set partcard [relation cardinality $part]
        if {$partcard == 0} {
            tailcall DeclError NOT_IN_ASSOCIATION $class $rname
        } elseif {$partcard > 1} {
            tailcall DeclError AMBIGUOUS_UNLINK $rname $relvar
        } else {
            # find associative class instances
            set navdir [expr {[relation extract $part Role] eq "source" ?\
                $relationship : ~$relationship}]
            set associnsts [deRef [::rosea::InstCmds::findRelated $instref\
                [list $navdir [namespace tail $associator]]]]
        }
    }
    # Just remove the associator tuples that are the relationship links.
    relvar minus ${domain}::$associator $associnsts
    return $associnsts
}
----

(((error code,AMBIGUOUS_UNLINK)))
[source,tcl]
----
<<error code formats>>=
AMBIGUOUS_UNLINK         {"%s" is reflexive and linking via "%s" is ambiguous}
----

==== Migrating Subclasss Across Generalizations

For the case of generalization relationships,
the notion of linking and unlinking across the relationship
doesn't make much sense.
To understand why,
recall that in the XUML usage a generalization relationship
partitions the superclass instances into a disjoint union of
the subclasses.
This means that each subclass instance is unconditionally related
to exactly one superclass instance.
If you were to unlink a subclass from its superclass the only operations
that would not violate referential integrity is to link a
new subclass instance or delete both the superclass and subclass instances.
So the only meaningful operation that does not violate referential integrity
is to _migrate_ a subclass instance.
Conceptually, migration consists of:

* Unlink the superclass and subclass.
* Delete the subclass instance.
* Create a new instance of a subclass of the generalization.
* Link the new instance to the superclass.

One additional complication is that the newly created subclass instance
may have attributes that need to be set.
These are included in the invocation of +migrate+ as attribute name /
value pairs.

///////
----
<<manual architecture relationship commands>>=
[call [arg relationship] [cmd migrate] [arg instref1] [arg subclass]\
    [opt [arg "attr1 value1 attr2 value2 ..."]]]
----
///////


[float]
===== Implementation
[source,tcl]
----
<<relationship commands>>=
proc migrate {rname instref subclass args} {
    if {![isRefSingular $instref]} {
        tailcall DeclError SINGLE_REF_REQUIRED [refMultiplicity $instref]
    }
    lassign $instref relvar inst
    lassign [SplitRelvarName $relvar] domns class
    set archns ${domns}::__Arch

    set link [relvar restrictone ${archns}::AssociationLink Name $rname\
            SrcClass $class]
    if {[relation isempty $link]} {
        tailcall DeclError NO_SUBCLASS $rname $relvar
    }
    #puts [relformat $link link]

    # Traverse the relationship to the superclass. We need to get the values of
    # the referenced attributes to use in creating the new subclass instance.
    set superinst [pipe {
        relvar set ${domns}::[relation extract $link DstClass] |
        relation semijoin $inst ~ -using [relation extract $link Attrs]
    }]

    set sublink [relvar restrictone ${archns}::SubLink Relationship $rname\
            SubClass $subclass]
    if {[relation isempty $sublink]} {
        tailcall DeclError NO_SUBCLASS $rname $subclass
    }
    #puts [relformat $sublink sublink]

    # Using the same relation extend strategy, we compute a dictionary of the
    # attribute names / values as they must appear in the subclass we are about
    # to create.
    set refedvalues [pipe {
        relation extract $sublink ReferringAttrs |
        relation extend ~ rval Value string {
            [relation extract $superinst\
                [tuple extract $rval ReferencedAttribute]]
        } |
        relation dict ~ ReferringAttribute Value
    }]

    # We use the class commands to delete the old subclass instance and create
    # the new one. This will make sure that if the subclass has a state model
    # that the initial state is set correctly.
    relvar eval {
        ::rosea::InstCmds::delete $instref
        set ref [::rosea::ClassCmds::create ${domns}::$subclass\
                {*}[dict merge $args $refedvalues]]
    }
    return $ref
}
----

(((error code,NO_SUBCLASS)))
[source,tcl]
----
<<error code formats>>=
NO_SUBCLASS         {relationship "%s" does not have a "%s"}
----

==== Signaling an Assigner

///////
----
<<manual architecture relationship commands>>=
[call [arg relationship] [cmd signal] [arg event]\
    [opt [arg "param1 param2 ..."]]]
----
///////

[source,tcl]
----
<<relationship commands>>=
proc signalAssigner {rname event args} {
    lassign [SplitRelvarName $rname] domain relationship
    set assignrelvar ${domain}::__${relationship}__STATEINST
    if {![relvar exists $assignrelvar]} {
        tailcall DeclError NO_ASSIGNER $rname
    }

    set dstref [pipe {
        relvar set $assignrelvar |
        relation project ~ {*}[lindex [relvar identifiers $assignrelvar] 0] |
        list $rname ~
    }]
    set srcref [SelfInstRef]
    ::rosea::Dispatch::SignalEvent $srcref $dstref $event $args

    return
}
----

(((error code,NO_ASSIGNER)))
[source,tcl]
----
<<error code formats>>=
NO_ASSIGNER         {relationship, "%s", does not have an assigner}
----

==== Signaling a Multi-Assigner

///////
----
<<manual architecture relationship commands>>=
[call [arg relationship] [cmd signal] [arg idvalues] [arg event]\
    [opt [arg "param1 param2 ..."]]]
----
///////

[source,tcl]
----
<<relationship commands>>=
proc signalMultiAssigner {rname idvalues event args} {
    lassign [SplitRelvarName $rname] domain relationship
    set assignrelvar ${domain}::__${relationship}__STATEINST
    if {![relvar exists $assignrelvar]} {
        tailcall DeclError NO_ASSIGNER $rname
    }
    set idattrs [lindex [relvar identifiers $assignrelvar] 0]
    # We will insist that the idvalues contain the necessary identifying
    # attributes.
    if {![struct::set equal [dict keys $idvalues] $idattrs]} {
        tailcall DeclError NO_IDENTIFIER [dict keys $idvalues] $idattrs
    }
    set assigninsts [relvar set $assignrelvar]
    set assignrefs [relation project $assigninsts {*}$idattrs]

    # We need to find the tuple in "assignrefs" that matches the attributes and
    # values in "idvalues". We will do this by creating a relation value from
    # the idvalues list and semijoining that to "assignrefs". If we come up
    # non-empty, then we have found our multi-assigner instance.
    set heading [relation heading $assignrefs]
    set dstinst [pipe {
        tuple create $heading $idvalues |
        tuple relation ~ |
        relation semijoin ~ $assignrefs
    }]
    if {[relation isempty $dstinst]} {
        tailcall DeclError UNKNOWN_ASSIGNER $idvalues $rname
    }

    set dstref [list $rname $dstinst]
    ::rosea::Dispatch::SignalEvent [SelfInstRef] $dstref $event $args

    return
}
----

(((error code,UNKNOWN_ASSIGNER)))
[source,tcl]
----
<<error code formats>>=
NO_IDENTIFIER       {bad identifying attributes, expected "%s", got "%s"}
UNKNOWN_ASSIGNER    {unknown assigner instance, "%s", for relationship, "%s"}
----

==== Creating a Multi-Assigner

///////
----
<<manual architecture relationship commands>>=
[call [arg relationship] [cmd create]\
    [opt [arg "attr1 value1 attr2 value2 ..."]]]
----
///////

[source,tcl]
----
<<relationship commands>>=
proc createMultiAssigner {rname args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }
    lassign [SplitRelvarName $rname] domain relationship
    set assignrelvar ${domain}::__${relationship}__STATEINST
    if {![relvar exists $assignrelvar]} {
        tailcall DeclError NO_ASSIGNER $rname
    }
    set idattrs [lindex [relvar identifiers $assignrelvar] 0]
    if {![struct::set equal [dict keys $args] $idattrs]} {
        tailcall DeclError NO_IDENTIFIER [dict keys $args] $idattrs
    }
    CreateInInitialState $domain $relationship $args
}
----

=== Instance Commands

In this section we discuss the +rosea+ commands that operate on instance
references.
These commands form the foundation of operations that state activities
use to access the underlying execution architecture.

As shown above,
the instance commands are placed in their own namespace.
This make it easier to provide unqualified access to these commands
via the +namespace path+ settings.

[source,tcl]
----
<<instance commands namespace>>=
namespace eval InstCmds {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers
    <<instance data>>
    <<instance commands>>
}
----

==== Finding Related Instances

Navigating the class diagram to find related instances is a fundamental
operation in most state activities.
There are two features of navigating that we provide to make
tranlation easier.

* Often several relationships are traversed to get to the desired destination.
We provide the ability to specify a relationship chain to traverse
multiple relationships in a single invocation.
This interface saves the nesting that would be otherwise required
if only a single relationship could be traversed in one invocation.
* Although much less common, it is sometimes useful to find the set
of _unrelated_ instances.
We provide that functionality since obtaining the unrelated instance set
is otherwise tedious and TclRAL provides the necessary mechanism in
the +semiminus+ command.

We factor all the common processing into a procedure below and then provide
specific procedures intended for the state activities.

[source,tcl]
----
<<instance commands>>=
proc FindRelatedInsts {instref op args} {
    set srcrelvar [lindex $instref 0]
    lassign [SplitRelvarName $srcrelvar] domain class

    # This procedure queries the architectural data about relationship linkage,
    # so we bring the relvar variables into scope.
    namespace upvar ${domain}::__Arch\
            Link Link\
            AssociationLink AssociationLink\
            PartitionLink PartitionLink\
            PartitionDst PartitionDst
    #puts [relformat $Link Link]
    #puts [relformat $AssociationLink AssociationLink]
    #puts [relformat $PartitionLink PartitionLink]
    #puts [relformat $PartitionDst PartitionDst]
    variable relatedQuery ; # <1>

    # The strategy here is to iterage over the relationship chain to build
    # semijoin (or semiminus) commands from the architectural data values.
    set related [deRef $instref]
    foreach linkage $args {
        # Recall that the linkage specification may contain a destination class
        # for those types of linkages where there may be multiple paths along
        # the relationship (i.e. to associative classes or subclasses).
        lassign $linkage lname dst

        set link [relvar restrictone ${domain}::__Arch::Link\
                Name $lname SrcClass $class]
        if {[ral relation isempty $link]} {
            tailcall DeclError UNKNOWN_LINKAGE $lname $class
        }
        # First we determine if we are dealing with an associative link or a
        # partition link.
        set assoc [relation join $link $AssociationLink]
        if {[relation isnotempty $assoc]} {
            relation assign $assoc DstClass Attrs
            # Check if additional path information was provided.
            if {$dst eq {}} {
                # Find the set of instances related to the current set.
                set related [eval $relatedQuery]
                # We must see if this is a class-based association.  If so,
                # then the first traversal was to the associator and we must
                # traverse again to the other class.
                set assoc [relation semijoin $assoc $AssociationLink\
                    -using {Name Name SrcClass PrevSrcClass}]
                if {[relation isnotempty $assoc]} {
                    relation assign $assoc DstClass Attrs
                    set related [eval $relatedQuery]
                }
            } else {
                # If a destination was specified in the linkage, then we need
                # to verify that it is actually part of the relationship.
                if {$dst ne $DstClass} {
                    tailcall DeclError PATH_ERROR $lname $class $DstClass\
                        $dst
                }
                set related [eval $relatedQuery]
            }
        } else {
            # If the linkage is not associative, then it must be a superclass
            # to subclass traversal. Recall that subclass to superclass
            # traversal is just an ordinary associative linkage. In this case
            # we simply find the partition linkage information.
            set partdst [relvar restrictone ${domain}::__Arch::PartitionDst\
                Name $lname SrcClass $class DstClass $dst]
            if {[relation isempty $partdst]} {
                tailcall DeclError PATH_ERROR $lname $class $DstClass $dst
            }
            relation assign $partdst DstClass Attrs
            set related [eval $relatedQuery]
        }
        # Continue the iteration by setting the next source to the current
        # destination class.
        set class $DstClass
        set srcrelvar ${domain}::$class
    }
    # N.B. that we are not returning an instance reference but rather the
    # complete relation value of the related instances. This allows us
    # to further filter the result in the "findRelatedWhere" command.
    return [list $srcrelvar $related]
}
----
<1> This query fetches to related instances across a single linkage.
See the query below.

(((error code,UNKNOWN_LINKAGE)))
(((error code,PATH_ERROR)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_LINKAGE {unknown relationship, "%s", for class, "%s"}
PATH_ERROR      {relationship, "%s", from "%s" to "%s", does not end at "%s"}
----

The query to obtain the related instances is used many places and so
worth factoring out.

[source,tcl]
----
<<instance data>>=
pipe {
    relvar set ${domain}::$DstClass |
    relation $op $related ~ -using $Attrs
} relatedQuery
----

The set of commands intended for state activities are just
variations on the invocation of +FindRelatedInsts+.

[float]
===== Synopsis
====
+findRelated+ _instref_ _relationship1 relationship2 ..._
====

+instref+::
    An instance reference that is the start of the relationship chain
    navigation.
+relationshipN+::
    A relationship specifier for the navigation chain.
    Each relationship specifier is a one or two element list.
    If a single element, then it is the name of a relationship (_e.g._ R27)
    that is to be traversed in the forward direction or the
    name of a relationship prefixed by a tilde (_e.g._ \~R27) giving the
    name of a relationship to be traversed in its reverse direction.
    If a two element list, then the traversal may have alternate paths
    and the second element names the class to which the traversal should
    happen.
    For class based associations this would be the name of the associator class
    and for generalizations this would be the name of one of the subclasses.

The +findRelated+ command returns an instance reference to the set
of instances that are found along the relationship navigation chain.

///////
----
<<manual architecture instance commands>>=
[call [cmd findRelated] [arg instref]\
    [opt [arg "relationship1 relationship2 ..."]]]
----
///////


[float]
===== Implementation
[source,tcl]
----
<<instance commands>>=
proc findRelated {instref args} {
    tailcall ToRef {*}[FindRelatedInsts $instref semijoin {*}$args]
}
----


///////
----
<<manual architecture instance commands>>=
[call [cmd findUnrelated] [arg instref]\
    [opt [arg "relationship1 relationship2 ..."]]]
----
///////

[float]
===== Implementation
[source,tcl]
----
<<instance commands>>=
proc findUnrelated {instref args} {
    tailcall ToRef {*}[FindRelatedInsts $instref semiminus {*}$args]
}
----

///////
----
<<manual architecture instance commands>>=
[call [cmd findRelatedWhere] [arg instref] [arg rchain] [arg expression]]
----
///////

[float]
===== Implementation
[source,tcl]
----
<<instance commands>>=
proc findRelatedWhere {instref rchain expr} {
    lassign [FindRelatedInsts $instref semijoin {*}$rchain] relvar insts
    tailcall ToRef $relvar [uplevel 1\
        [list ::ral relation restrictwith $insts $expr]]
}
----

///////
----
<<manual architecture instance commands>>=
[call [cmd findUnrelatedWhere] [arg instref] [arg rchain] [arg expression]]
----
///////

[float]
===== Implementation
[source,tcl]
----
<<instance commands>>=
proc findUnrelatedWhere {instref rchain expr} {
    lassign [FindRelatedInsts $instref semiminus {*}$rchain] relvar insts
    tailcall ToRef $relvar [uplevel 1\
        [list ::ral relation restrictwith $insts $expr]]
}
----

[float]
===== Tests
[source,tcl]
----
<<instance command tests>>=
test findRelated-1.0 {
    Navigate a relationship -- simple association
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addClass foo c2 {B1 int B2 string} B1
    addAssocLink foo {Name R1 SrcClass c1}\
        {Name R1 SrcClass c1 DstClass c2 Attrs {A1 B1} PrevSrcClass {}}
    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {::rosea::test::foo::c2 {{B1 int} {{B1 5}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.1 {
    Navigate a relationship -- multiple simple association
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addClass foo c2 {B1 int B2 string} B1
    addClass foo c3 {C1 int C2 string} C1

    addAssocLink foo {Name R1 SrcClass c1}\
        {Name R1 SrcClass c1 DstClass c2 Attrs {A1 B1} PrevSrcClass {}}
    addAssocLink foo {Name R2 SrcClass c2}\
        {Name R2 SrcClass c2 DstClass c3 Attrs {B1 C1} PrevSrcClass {}}

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
    rosea::ClassCmds::create [namespace current]::foo::c3 C1 5 C2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1 R2
} -result {::rosea::test::foo::c3 {{C1 int} {{C1 5}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.2 {
    Navigate a relationship -- unknown link
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {unknown relationship, "R1", for class, "c1"}\
-returnCodes error
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.3 {
    Navigate a relationship -- bad path
} -setup {
    setupDomain foo
    addClass foo X {A1 int A2 string} A1
    addClass foo Y {B1 int B2 string} B1
    addClass foo A {A1 int B1 int} {A1 B1}
    addClass foo c1 {A1 int A2 string} A1

    # Forward direction is from X -> Y via A
    addAssocLink foo {Name R1 SrcClass X}\
        {Name R1 SrcClass X DstClass A Attrs {A1 A1} PrevSrcClass {}}
    addAssocLink foo {Name R1 SrcClass A}\
        {Name R1 SrcClass A DstClass Y Attrs {B1 B1} PrevSrcClass X}
    addAssocLink foo {Name ~R1 SrcClass Y}\
        {Name ~R1 SrcClass Y DstClass A Attrs {B1 B1} PrevSrcClass {}}
    addAssocLink foo {Name ~R1 SrcClass A}\
        {Name ~R1 SrcClass A DstClass X Attrs {A1 A1} PrevSrcClass Y}
    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref {R1 A}
} -result {unknown relationship, "R1", for class, "c1"}\
    -returnCodes error
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-2.0 {
    Navigate a relationship -- associative class
} -setup {
    setupDomain foo
    addClass foo X {A1 int A2 string} A1
    addClass foo Y {B1 int B2 string} B1
    addClass foo A {A1 int B1 int} {A1 B1}
    # Forward direction is from X -> Y via A
    addAssocLink foo {Name R1 SrcClass X}\
        {Name R1 SrcClass X DstClass A Attrs {A1 A1} PrevSrcClass {}}
    addAssocLink foo {Name R1 SrcClass A}\
        {Name R1 SrcClass A DstClass Y Attrs {B1 B1} PrevSrcClass X}
    addAssocLink foo {Name ~R1 SrcClass Y}\
        {Name ~R1 SrcClass Y DstClass A Attrs {B1 B1} PrevSrcClass {}}
    addAssocLink foo {Name ~R1 SrcClass A}\
        {Name ~R1 SrcClass A DstClass X Attrs {A1 A1} PrevSrcClass Y}

    set ref [rosea::ClassCmds::create [namespace current]::foo::X A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::Y B1 10 B2 bar
    rosea::ClassCmds::create [namespace current]::foo::A A1 5 B1 10
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {::rosea::test::foo::Y {{B1 int} {{B1 10}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-2.1 {
    Navigate a relationship -- path to associative class
} -setup {
    setupDomain foo
    addClass foo X {A1 int A2 string} A1
    addClass foo Y {B1 int B2 string} B1
    addClass foo A {A1 int B1 int} {A1 B1}
    # Forward direction is from X -> Y via A
    addAssocLink foo {Name R1 SrcClass X}\
        {Name R1 SrcClass X DstClass A Attrs {A1 A1} PrevSrcClass {}}
    addAssocLink foo {Name R1 SrcClass A}\
        {Name R1 SrcClass A DstClass Y Attrs {B1 B1} PrevSrcClass X}
    addAssocLink foo {Name ~R1 SrcClass Y}\
        {Name ~R1 SrcClass Y DstClass A Attrs {B1 B1} PrevSrcClass {}}
    addAssocLink foo {Name ~R1 SrcClass A}\
        {Name ~R1 SrcClass A DstClass X Attrs {A1 A1} PrevSrcClass Y}

    set ref [rosea::ClassCmds::create [namespace current]::foo::X A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::Y B1 10 B2 bar
    rosea::ClassCmds::create [namespace current]::foo::A A1 5 B1 10
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref {R1 A}
} -result {::rosea::test::foo::A {{A1 int B1 int} {{A1 5 B1 10}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-3.0 {
    Navigate a generalization
} -setup {
    setupDomain foo
    addClass foo S {S1 int S2 string} S1
    addClass foo X {X1 int X2 string} X1
    addClass foo Y {Y1 int Y2 string} Y1

    addAssocLink foo {Name R1 SrcClass X}\
        {Name R1 SrcClass X DstClass S Attrs {X1 S1} PrevSrcClass {}}
    addAssocLink foo {Name R1 SrcClass Y}\
        {Name R1 SrcClass Y DstClass S Attrs {Y1 S1} PrevSrcClass {}}
    relvar eval {
        addParitionLink foo {Name ~R1 SrcClass S}
        addPartitionDst foo {Name ~R1 SrcClass S DstClass X Attrs {S1 X1}}
        addPartitionDst foo {Name ~R1 SrcClass S DstClass Y Attrs {S1 Y1}}
    }

    set ref [rosea::ClassCmds::create [namespace current]::foo::S S1 5 S2 baz]
    rosea::ClassCmds::create [namespace current]::foo::X X1 5 X2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref {~R1 X}
} -result {::rosea::test::foo::X {{X1 int} {{X1 5}}}} -match ref
----

==== Updating Attributes

Another fundamental operation for a state activity is to update the
values of attributes.


We will find it convenient deal with attribute names as sets and
will rely on the +tcllib+ package for this.

[source,tcl]
----
<<required packages>>=
package require struct::set
----

///////
----
<<manual architecture instance commands>>=
[call [cmd updateAttribute] [arg instref] [opt [arg "attr1 value1 ..."]]]
----
///////

[float]
===== Implementation
[source,tcl]
----
<<instance commands>>=
proc updateAttribute {instref args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_ERROR $args
    }

    lassign $instref relvar insts

    # We do not allow updates to the values of identifying attributes.  Changes
    # to identifiers must be accomplished by creating and deleting instances.
    # So we want to make sure that none of the attributes listed in the
    # arguments are actually identifying attributes.
    set idattrs [::struct::set union {*}[relvar identifiers $relvar]]
    set idupdates [::struct::set intersect [dict keys $args] $idattrs]
    if {![::struct::set empty $idupdates]} {
        tailcall DeclError ID_UPDATE $idupdates
    }

    # The update strategy is to use the "relvar updateper" command. This
    # command was tailored for this particular purpose. It takes a relation
    # value uses the identifiers in that value and will update non-identifying
    # attributes. So we can create a relation value by extending the instance
    # reference value with the attributes to be updated.  Conveniently, the
    # instance reference contains the identifying attributes.  To perform the
    # extend operation we will need the type of the attribute which we can get
    # from the heading of the relvar.
    set cmd [list relation extend $insts exttuple]
    set heading [relation heading [relvar set $relvar]]
    foreach {attr value} $args {
        lappend cmd $attr [dict get $heading $attr] \"$value\"
    }
    relvar updateper $relvar [eval $cmd]
    return
}
----

(((error code,ARG_ERROR)))
(((error code,ID_UPDATE)))
[source,tcl]
----
<<error code formats>>=
ARG_ERROR      {attribute updates must be name / value pairs, got "%s"}
ID_UPDATE      {cannot update identifying attributes, "%s"}
----

[source,tcl]
----
<<instance command tests>>=
test updateAttribute-1.0 {
    Update single attribute value
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::updateAttribute $ref A2 foo
    relation extract [::rosea::InstCmds::deRef $ref] A2
} -result {foo}
----

[source,tcl]
----
<<instance command tests>>=
test updateAttribute-1.1 {
    Update multiple attribute values
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string A3 int} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1\
            A1 5 A2 baz A3 27]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::updateAttribute $ref A3 42 A2 foo
    relation extract [::rosea::InstCmds::deRef $ref] A2 A3
} -result {foo 42}
----

[source,tcl]
----
<<instance command tests>>=
test updateAttribute-1.2 {
    Update identifying attributes
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::updateAttribute $ref A1 27
} -result {cannot update identifying attributes, "A1"} -returnCodes error
----

==== Reading Attributes

The complement to updating attributes is, of course, to read them.
Reading attributes is just a matter of dereferencing the instance reference
and extracting the requested attributes.
We deal with the boundary case of reading no attributes by returning
the empty string.

///////
----
<<manual architecture instance commands>>=
[call [cmd readAttribute] [arg instref] [opt [arg "attr1 attr2 ..."]]]
----
///////

[source,tcl]
----
<<instance commands>>=
proc readAttribute {ref args} {
    # We insist upon a singular reference for reading attributes.  Multiple
    # references can be handled by dereferences and using TclRAL "relation"
    # commands.
    if {![isRefSingular $ref]} {
        tailcall DeclError SINGLE_REF_REQUIRED [refMultiplicity $dstref]
    }

    return [expr {[llength $args] == 0 ? {} :\
        [relation extract [deRef $ref {*}$args] {*}$args]}]
}
----

[source,tcl]
----
<<instance command tests>>=
test readAttribute-1.0 {
    Read single attribute value
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::readAttribute $ref A2
} -result {baz}
----

[source,tcl]
----
<<instance command tests>>=
test readAttribute-1.1 {
    Read multiple attribute values
} -setup {
    setupDomain bar
    addClass bar c1 {A1 int A2 string} A1
    set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain bar
} -body {
    ::rosea::InstCmds::readAttribute $ref A1 A2
} -result {5 baz}
----

==== Deleting Instances

///////
----
<<manual architecture instance commands>>=
[call [cmd delete] [arg instref]]
----
///////

(((rosea,InstCmds,delete)))
[source,tcl]
----
<<instance commands>>=
proc delete {instref} {
    lassign $instref relvar insts
    set tuples [deRef $instref]
    relvar minus $relvar $tuples

    lassign [SplitRelvarName $relvar] domain class
    set instrelvar ${domain}::${class}::__${class}__STATEINST
    if {[relvar exists $instrelvar]} {
        relvar minus $instrelvar [relvar semijoin $insts $instrelvar]
    }

    return
}
----

==== Signaling Instances

Most state activities (maybe all) end up updating attribute values or
signaling events or both.
Here we discuss the implementation of signaling an event.

For events, we track both the source and the target of the event.
However, we don't want to force caller to provide the source.
What we are truly seeking to know is whether the signal comes from
within a state activity.
We can make this determination because state actiities have a local
variable named +self+ defined.
The following procedure determines if +self+ exists in the caller.
During translation, some caution must be used to insure that domain
operations to not declare a +self+ variable.

[source,tcl]
----
<<helper commands>>=
proc SelfInstRef {{level 2}} {
    upvar $level self srcself
    return [expr {[info exists srcself] ? $srcself : {{} {{} {}}}}]
}
----

One complication with signaling events is dealing with polymorphic
events.
Polymorphic events are sent to a superclass instance and, at run time,
mapped to an event in the subclass instance to which the superclass
instance is currently related.
In general the rules of mapping polymorphic events can be complex,
so we factor that into a procedure.
Otherwise, the +signal+ procedure is simplified means of invoking
a dispatch procedure that queues an event and hooks that action
into the Tcl event loop.

///////
----
<<manual architecture instance commands>>=
[call [cmd signal] [arg instref] [arg event] [opt [arg "param1 param2 ..."]]]
----
///////

[source,tcl]
----
<<instance commands>>=
proc signal {dstset event args} {
    set srcref [SelfInstRef]
    if {![::rosea::Dispatch::MapPolymorphicEvent ::rosea::Dispatch::SignalEvent\
            $srcref $dstset $event $args]} {
        ::rosea::Dispatch::SignalEvent $srcref $dstset $event $args
    }
    return
}
----

Similar logic applies to signaling a delayed event

///////
----
<<manual architecture instance commands>>=
[call [cmd delaysignal] [arg time] [arg instref] [arg event]\
    [opt [arg "param1 param2 ..."]]]
----
///////

[source,tcl]
----
<<instance commands>>=
proc delaysignal {time dstset event args} {
    if {!([string is integer -strict $time] && $time >= 0)} {
        tailcall DeclError INVALID_TIME $time
    }
    set srcref [SelfInstRef]
    if {![::rosea::Dispatch::MapPolymorphicEvent\
            [list ::rosea::Dispatch::SignalDelayedEvent $time]\
            $srcref $dstset $event $args]} {
        ::rosea::Dispatch::SignalDelayedEvent $time $srcref $dstset $event $args
    }
    return
}
----

(((error code,INVALID_TIME)))
[source,tcl]
----
<<error code formats>>=
INVALID_TIME    {invalid time value, "%s"}
----

///////
----
<<manual architecture instance commands>>=
[call [cmd canceldelayed] [arg srcref] [arg dstref] [arg event]]
----
///////

[source,tcl]
----
<<instance commands>>=
proc canceldelayed {srcref dstset event} {
    set srcmult [refMultiplicity $srcref]
    if {$srcmult > 1} {
        tailcall DeclError SINGLE_OR_EMPTY_REF_REQUIRED $srcmult
    }
    forAllRefs dstref $dstset {
        ::rosea::Dispatch::CancelDelayedSignal $srcref $event $dstref
    }
    return
}
----

(((error code,SINGLE_REF_REQUIRED)))
[source,tcl]
----
<<error code formats>>=
SINGLE_OR_EMPTY_REF_REQUIRED {single valued or nil reference required, %d found}
----

///////
----
<<manual architecture instance commands>>=
[call [cmd delayremaining] [arg srcref] [arg dstref] [arg event]]
----
///////

[source,tcl]
----
<<instance commands>>=
proc delayremaining {srcref dstref event} {
    set srcmult [refMultiplicity $srcref]
    if {$srcmult > 1} {
        tailcall DeclError SINGLE_OR_EMPTY_REF_REQUIRED $srcmult
    }
    if {![isRefSingular $dstref]} {
        tailcall DeclError SINGLE_REF_REQUIRED [refMultiplicity $dstref]
    }
    tailcall ::rosea::Dispatch::SignalTimeRemaining $srcref $event $dstref
}
----

(((error code,SINGLE_REF_REQUIRED)))
[source,tcl]
----
<<error code formats>>=
SINGLE_REF_REQUIRED     {single valued reference required, %d found}
----

///////
----
<<manual architecture instance commands>>=
[call [cmd instop] [arg instref] [arg operation] [opt [arg "arg1 arg2 ..."]]]
----
///////

[source,tcl]
----
<<instance commands>>=
proc instop {instref op args} {
    tailcall [lindex $instref 0]::instop $instref $op {*}$args
}
----

=== Dispatch Commands

Dispatch commands are those commands in the +rosea+ execution architecure
that queue and dispatch state machine events and provide the mapping
between the XUML semantics of state machine execution and the Tcl event
loop.
The Tcl has first class support for event based programming
and in this section we show how those facilities are used to implement
the Moore type state machines that are part of the XUML execution model.
In our case we will use the +::after+ command to provide access
to the event loop.

[source,tcl]
----
<<dispatch commands namespace>>=
namespace eval Dispatch {
    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path [list\
        [namespace parent]::Helpers\
        [namespace parent]::InstCmds\
    ]
    <<dispatch data>>
    <<dispatch commands>>
}
----

[source,tcl]
----
<<dispatch commands>>=
proc MapPolymorphicEvent {frwdcmd srcref dstrefs event arglist} {
    lassign $dstrefs dstrelvar dstinsts ; # <1>
    lassign [SplitRelvarName $dstrelvar] domain dstclass
    set archns ${domain}::__Arch
    set polyevent [relvar restrictone ${archns}::PolymorphicEvent\
        Class $dstclass Event $event]
    if {[relation isempty $polyevent]} {
        return false
    }

    variable polymapQuery
    set partitions [eval $polymapQuery] ; # <2>

    relation foreach inst $dstinsts { # <3>
        relation foreach partition $partitions {
            relation assign $partition
            relation foreach dstlink $DstLinks {
                relation assign $dstlink
                set related [relation semijoin $inst\
                    [relvar set ${domain}::$DstClass] -using $Attrs] ; # <4>
                if {[relation isnotempty $related]} {
                    set dstreference [ToRef ${domain}::$DstClass $related]
                    ::rosea::Trace::TracePolymorphic $srcref\
                        $event $dstreference ${domain}::SrcClass $Name
                    {*}$frwdcmd $srcref $dstreference $event $arglist
                    break
                }
            }
        }
    }
    return true
}
----
<1> First we must determine if the event is polymorphic.
If not, then we just return and the event will be signaled as a
transition event.
<2> See query explanation <<polymapQuery,below>>.
<3> There are three nested iterations.
The outside loop iterates over the superclass instances
since we may be signaling several instances in the same call.
The next iteration is over all the hierarchies that orginate from
the superclass.
Typically, this is only one, but it can be several for a compound
generalization.
Finally, we iterate over all the subclass links.
<4> We must traverse the relationship to find the one subclass that is
actually linked and forward the event on to that one.
Once forwarding has happened, we can stop looking any futher since
we _know_ that there is exactly one subclass linked up to any given
superclass instance because the partition constraint enforces that.

[[polymapQuery,polymorphic event query]]
The essential query for dispatching a polymorphic event is to find the set of
hierarchies originating at the source relvar.

[source,tcl]
----
<<dispatch data>>=
pipe {
    relvar set ${archns}::PartitionDst |
    relation restrictwith ~ {$SrcClass eq $dstclass} |
    relation group ~ DstLinks DstClass Attrs
} polymapQuery
----

This query is accomplished by finding all the partition link tuples that
originate at the relvar which is the target of the event signaling.
These are joined with the link superclass to pick up the attributes
that are used to relate tuples across the partition.
The result of the join is grouped so we may consider all the superclass to
subclass links for a given hierarchy.
We want to do this because we know that a superclass instance will reference
exactly one subclass from among all the subclasses in the generalization and
it is to that subclass instance that the event will be forwarded.

The heading of the result of this query will be:

[width="50%",options="header",title="Heading of Polymorphic Event Mapping Query Result"]
|=========================
    |Name       |SrcClass   2+^h|DstLinks
    |string     |string     2+^|Relation
1.2+|       1.2+|             h|DstClass     h|Attrs
                               |string        |list
|=========================

Note that the *DstLinks* attribute is relation valued.footnote:[That is what
the +group+ operation does]

[source,tcl]
----
<<test utility procs>>=
proc addPolymorphic {domain args} {
    relvar insert [namespace current]::${domain}::__Arch::PolymorphicEvent\
            $args
}

proc polysignal {srcref dstref event paramlist} {
    puts -nonewline [info level 0]
}
----

[source,tcl]
----
<<dispatch command tests>>=
test MapPolymorphicEvent-1.0 {
    Map a polymorphic event
} -setup {
    setupDomain bar
    addClass bar S {S1 int S2 string} S1
    addClass bar X {X1 int X2 string} X1
    addClass bar Y {Y1 int Y2 string} Y1

    addAssocLink bar {Name R1 SrcClass X}\
        {Name R1 SrcClass X DstClass S Attrs {X1 S1} PrevSrcClass {}}
    addAssocLink bar {Name R1 SrcClass Y}\
        {Name R1 SrcClass Y DstClass S Attrs {Y1 S1} PrevSrcClass {}}
    relvar eval {
        addParitionLink bar {Name ~R1 SrcClass S}
        addPartitionDst bar {Name ~R1 SrcClass S DstClass X Attrs {S1 X1}}
        addPartitionDst bar {Name ~R1 SrcClass S DstClass Y Attrs {S1 Y1}}
    }

    addPolymorphic bar Class S Event e1
    set ref [rosea::ClassCmds::create [namespace current]::bar::S S1 5 S2 baz]
    rosea::ClassCmds::create [namespace current]::bar::X X1 5 X2 bar
} -cleanup {
    cleanupDomain bar
} -body {
    rosea::Dispatch::MapPolymorphicEvent [namespace current]::polysignal\
        {} $ref e1 {}
} -result {true} -output {::rosea::test::polysignal {} {::rosea::test::bar::X {{X1 int} {{X1 5}}}} e1 {}}
----

[source,tcl]
----
<<dispatch data>>=
variable event_queue [list]
variable inTransaction false
----

[source,tcl]
----
<<dispatch commands>>=
proc SignalEvent {srcref dstset event arglist} {
    variable event_queue
    forAllRefs dstref $dstset {
        set eventInfo [dict create\
            src $srcref\
            event $event\
            dst $dstref\
            params $arglist\
        ]
        if {[isRefEqual $srcref $dstref]} {
            set eqindex 0
            foreach cmpevent $event_queue {
                if {![isRefEqual [dict get $cmpevent src]\
                        [dict get $cmpevent dst]]} {
                    break
                }
                incr eqindex
            }
            set event_queue [linsert $event_queue $eqindex $eventInfo]
        } else {
            lappend event_queue $eventInfo
        }
        ::after 0 [namespace code DispatchEvent]
    }
}
----

[source,tcl]
----
<<dispatch command tests>>=
test SignalEvent-1.0 {
    Signal an event
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    relvar eval {
        addState foo Class c1 State s1
        addState foo Class c1 State s2
        addEvent foo Class c1 Event e1
        addInitialState foo Class c1 State s1
        addTransition foo Class c1 State s1 Event e1 NewState s2
        addTransition foo Class c1 State s2 Event e1 NewState s1
    }

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::InstCmds::signal $ref e1
} -cleanup {
    after cancel [namespace eval ::rosea::Dispatch namespace code DispatchEvent]
    cleanupDomain foo
} -body {
    set event [lindex $::rosea::Dispatch::event_queue 0]
    dict get $event dst
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
----

[source,tcl]
----
<<dispatch commands>>=
proc DispatchEvent {} {
    variable event_queue
    variable inTransaction

    set eqlen [llength $event_queue]
    if {$eqlen != 0} {
        # Pull the event from the front of the queue.
        set eventInfo [lindex $event_queue 0]
        set event_queue [lrange $event_queue 1 end]

        set dstref [dict get $eventInfo dst]
        lassign $dstref relvar ref
        lassign [SplitRelvarName $relvar] domain class
        set archns ${domain}::__Arch

        set instrelvar ${domain}::__${class}__STATEINST
        set state [relation semijoin $ref [relvar set $instrelvar]]
        if {[relation isempty $state]} {
            tailcall DeclError EVENT_IN_FLIGHT [dict get $eventInfo event]\
                $ref
        }
        set currstate [relation extract $state __State]
        set event [dict get $eventInfo event]

        set newState [pipe {
            relvar restrictone ${archns}::Transition\
                Class $class State $currstate Event $event |
            relation extract ~ NewState
        }]
        ::rosea::Trace::TraceTransition [dict get $eventInfo src]\
            $event $dstref $currstate $newState [dict get $eventInfo params]

        if {$newState eq "CH"} {
            tailcall DeclError CANT_HAPPEN_EVENT [dict get $eventInfo src]\
                $event $dstref $currstate
        } elseif {$newState ne "IG"} {
            set idattrs [tuple get [ral relation tuple $ref]]
            relvar updateone $instrelvar is $idattrs {
                tuple update $is __State $newState
            }
            try {
                if {$eqlen == 1 && !$inTransaction} {
                    relvar transaction begin
                    set inTransaction true
                }
                ${relvar}::__Activity::$newState $dstref\
                        {*}[dict get $eventInfo params]
            } finally {
                if {[llength $event_queue] == 0 && $inTransaction} {
                    relvar transaction end
                    set inTransaction false
                }
                set term [relvar restrictone ${domain}::__Arch::Terminal\
                        Class $class State $newState]
                if {[relation isnotempty $term]} {
                    relvar deleteone $relvar {*}$idattrs
                    relvar deleteone $instrelvar {*}$idattrs
                }
            }
        }
    }
    return
}
----

(((error code,EVENT_IN_FLIGHT)))
(((error code,CANT_HAPPEN_EVENT)))
[source,tcl]
----
<<error code formats>>=
EVENT_IN_FLIGHT     {event, "%s", sent to "%s", which does not exist}
CANT_HAPPEN_EVENT   {can't happen transition, %s - %s -> %s ==> %s -> CH}
----

[source,tcl]
----
<<dispatch command tests>>=
test DispatchEvent-1.0 {
    Dispatch an event and execute a state action
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    relvar eval {
        addState foo Class c1 State s1
        addState foo Class c1 State s2
        addEvent foo Class c1 Event e1
        addInitialState foo Class c1 State s1
        addTransition foo Class c1 State s1 Event e1 NewState s2
        addTransition foo Class c1 State s2 Event e1 NewState s1
    }
    proc [namespace current]::foo::c1::__Activity::s2 {self} {
        set ::done $self
    }

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::InstCmds::signal $ref e1
} -cleanup {
    cleanupDomain foo
} -body {
    vwait ::done
    set ::done
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
----

[source,tcl]
----
<<dispatch data>>=
relvar create DelayedSignal {
    SrcInstRef      list
    Event           string
    DstInstRef      list
    TimerId         string
    Expire          bignum
} {SrcInstRef Event DstInstRef}
----

[source,tcl]
----
<<dispatch commands>>=
proc SignalDelayedEvent {time srcref dstset event arglist} {
    forAllRefs dstref $dstset {
        # Cancel any existing delayed signal that might have been in place.
        CancelDelayedSignal $srcref $event $dstref
        relvar insert DelayedSignal [list\
            SrcInstRef  $srcref\
            Event       $event\
            DstInstRef  $dstref\
            TimerId     [::after $time\
                        [list ::rosea::Dispatch::DispatchDelayedEvent\
                            $srcref $event $dstref $arglist]]\
            Expire      [expr {entier([clock milliseconds]) + entier($time)}]\
        ]
    }
    return
}
----

[source,tcl]
----
<<dispatch commands>>=
proc DispatchDelayedEvent {srcref event dstref params} {
    DeleteDelayedSignal $srcref $event $dstref
    variable event_queue
    lappend event_queue [dict create\
        src $srcref\
        event $event\
        dst $dstref\
        params $params\
    ]
    tailcall DispatchEvent
}
----

[source,tcl]
----
<<dispatch command tests>>=
test DispatchDelayedEvent-1.0 {
    Dispatch a delayed event and execute a state action
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    relvar eval {
        addState foo Class c1 State s1
        addState foo Class c1 State s2
        addEvent foo Class c1 Event e1
        addInitialState foo Class c1 State s1
        addTransition foo Class c1 State s1 Event e1 NewState s2
        addTransition foo Class c1 State s2 Event e1 NewState s1
    }
    proc [namespace current]::foo::c1::__Activity::s2 {self} {
        set ::done $self
    }

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::InstCmds::delaysignal 100 $ref e1
} -cleanup {
    cleanupDomain foo
} -body {
    vwait ::done
    set ::done
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
----

[source,tcl]
----
<<dispatch commands>>=
proc CancelDelayedSignal {srcref event dstref} {
    variable DelayedSignal
    set sig [FindDelayedSignal $srcref $event $dstref]
    if {[relation isnotempty $sig]} {
        ::after cancel [relation extract $sig TimerId]
        DeleteDelayedSignal $srcref $event $dstref
    }
}
----

[source,tcl]
----
<<dispatch command tests>>=
test CancelDelayedSignal-1.0 {
    Cancel a delayed event
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    relvar eval {
        addState foo Class c1 State s1
        addState foo Class c1 State s2
        addEvent foo Class c1 Event e1
        addInitialState foo Class c1 State s1
        addTransition foo Class c1 State s1 Event e1 NewState s2
        addTransition foo Class c1 State s2 Event e1 NewState s1
    }

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    rosea::InstCmds::delaysignal 100 $ref e1
    set src {{} {{} {}}}
    rosea::InstCmds::canceldelayed $src $ref e1
    relation cardinality [rosea::Dispatch::FindDelayedSignal $src e1 $ref]
} -result {0}
----

[source,tcl]
----
<<dispatch commands>>=
proc SignalTimeRemaining {srcref event dstref} {
    set sig [FindDelayedSignal $srcref $event $dstref]
    if {[relation isnotempty $sig]} {
        set remaining [expr {[relation extract $sig Expire] -\
            [clock milliseconds]}]
        if {$remaining < 0} {
            set remaining 0
        }
    } else {
        set remaining 0
    }

    return $remaining
}
----

[source,tcl]
----
<<dispatch command tests>>=
test SignalTimeRemaining-1.0 {
    Obtain remaining time on a delayed signal
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    relvar eval {
        addState foo Class c1 State s1
        addState foo Class c1 State s2
        addEvent foo Class c1 Event e1
        addInitialState foo Class c1 State s1
        addTransition foo Class c1 State s1 Event e1 NewState s2
        addTransition foo Class c1 State s2 Event e1 NewState s1
    }

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    rosea::InstCmds::delaysignal 100 $ref e1
    set src {{} {{} {}}}
    set remain [rosea::InstCmds::delayremaining $src $ref e1]
    rosea::InstCmds::canceldelayed $src $ref e1
    expr {$remain <= 100 && $remain >= 95}
} -result {1}
----

[source,tcl]
----
<<dispatch commands>>=
proc FindDelayedSignal {srcref event dstref} {
    variable DelayedSignal
    return [relation restrictwith $DelayedSignal {
            [isRefEqual $SrcInstRef $srcref] && $Event eq $event &&\
            [isRefEqual $DstInstRef $dstref]}]
}
----

[source,tcl]
----
<<dispatch commands>>=
proc DeleteDelayedSignal {srcref event dstref} {
    relvar delete DelayedSignal dsig {
        [isRefEqual [tuple extract $dsig SrcInstRef] $srcref] &&\
        [tuple extract $dsig Event] eq $event &&\
        [isRefEqual [tuple extract $dsig DstInstRef] $dstref]
    }
}
----

=== Helper Commands

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    <<tclral imports>>
    namespace import ::ral::relvar
    <<helper data>>
    <<helper commands>>
}
----

[source,tcl]
----
<<helper commands>>=
proc SplitRelvarName {relvar} {
    tailcall list [namespace qualifiers $relvar] [namespace tail $relvar]
}
----

[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list ROSEA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

== Configuration Language

In this section we consider the domain specific language (DSL) that is used
to configure a domain under +rosea+.
Let's use this opportunity to recap our intent.

+Rosea+ is divided into two main parts:

* A set of procedures that implement the run-time execution model.
These procedures are data-driven and assume the existence of particular
data structures and namespace organizations.
These are the procedures that have been described in the previous section.
* A configuration language to populate the data structures and organize
the namespaces as needed by the run-time mechanisms.

Strictly speaking, the configuration language will not do anything that
cannot be done manually.
Indeed,
as we have been testing the run-time mechanisms above,
we have done so using _ad hoc_ constructed data and namespaces.
But such an undertaking is too error prone for productive uses and
some type of configuration scheme is needed.
Configuring the run-time mechanisms via a DSL has the added benefit of creating
a well defined interface that will insulate the package user from minor changes
in the mechanisms.

The configuration language itself will be a Tcl script.
Commands in that script will define the aspects of a domain such
as its classes, attributes and relationships.
The DSL script will be evaluated in a context where the command names
will conveniently resolve without any qualification.

There are two basic approaches to the DSL that were considered.

* As each DSL command is executed, create the corresponding run-time
structure.
One can view that as a type of on-the-fly interpretation.
* Consume all the DSL commands, storing away any data that is required
and then generate the run-time structure at the end.

The first approach is certainly simpler to code
but has some decided disadvantages.
To create the run-time structure as each command is executed will impose
a rather strict ordering of the commands.
For example,
TclRAL insists that the participating relvars exist before a constraint
may be defined upon them.
This would imply that the DSL would have to be ordered in that way.
Also, defining state models needs some semantic checking to insure
a reasonable and consistent model is defined.
That checking is hard to do in an on-the-fly interpretation scheme.

These disadvantages lead us to choose the second alternative,
namely, build the configuration DSL commands to store away their data
and then generate the run-time structures from the stored data.
This approach requires significantly more programming but leads to
considerable flexibility.
It has the added benefit of allowing much easier and extensive
introspection of the domain than could be possible if we were just
examining the run-time structures themselves.


=== Config Namespace Layout

The +::rosea::Config+ namespace has a relatively more complex layout.
The reason for this is that we want to create a set of child namespaces
that mirror the nesting of the configuration language statements.
At the top level,
the +domain+ command is used to define each domain.
The +domain+ command accepts a script body that then defines the
components of the domain.
That script will be evaluated in a namespace where the commands that
define the domain components, _e.g._ +class+ and relationship commands,
resolve appropriately.
This lets us put commands for the body specifying a particular component into a
namespace which prevents any problems of accidentially invoking commands that
are inappropriate in that context of the DSL.

We layout the +::rosea::Config+ namespace as shown below.

[source,tcl]
----
<<configuration commands namespace>>=
namespace eval Config {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path [namespace parent]::Helpers
    <<config data>>
    <<config commands>>
    <<domain config namespace layout>>
}
----

=== Evaluating Configuration Scripts

You can evaluate the configuration script by simply gathering it together
and passing it to the core +namespace eval+ command.
Unfortunately,
the first error that is encountered will terminate the evaluation.
This is decidedly inconvenient as you would prefer to continue on and
come up with a list of errors for the evaluation much like a
conventional language compiler would do when compiling a source file.
Discovering errors one at a time is tediously unproductive.

Of course, it is possible to continue evaluating after an error but
that requires a bit more code.
We will also want to be able to evaluate scripts in different namespace
contexts as we described above.
We will accomplish all this by taking advantage of the core +::apply+ command
and its ability to execute a lambda function in a given namespace.
So given a script body and an namespace we can evaluate it as shown below.

[source,tcl]
----
<<config commands>>=
namespace export ConfigEvaluate

proc ConfigEvaluate {ns body} {
    variable evalLambda
    tailcall ::apply [concat $evalLambda $ns] $body
}
----

The lambda function that performs the command evaluation is given below.
We hold the evaluation lambda as a piece of data.

[source,tcl]
----
<<config data>>=
variable evalLambda {{body} {
    upvar #0 ::rosea::Config::errcount errcount ; # <1>
    upvar #0 ::rosea::Config::configlineno configlineno
    set cmdline $configlineno
    set command {}
    foreach line [split $body \n] { # <2>
        append command $line \n
        incr cmdline ; # <3>
        if {[info complete $command]} {
            try {
                eval $command
            } on error {result} {
                log::error "line $configlineno: \"$result\""
                incr errcount
            }
            set command {} ; # <4>
            set configlineno $cmdline
        }
    }
    return $errcount
}}
----
<1> We need to keep track of all the errors encountered and
what line of the script we are currently dealing with.
<2> We split the body along lines and then reassemble the lines
into a complete command. The +info complete+ command tells us when
we have something that has some chance of being a real command.
<3> We need to keep track of where we are in the +body+.
<4> After evaluating a command we begin to assemble another one and
set our location counter to where that command starts.

So one of our top level +rosea+ commands is to configure a domain from
a script.

[float]
===== Synopsis
====
+configure+ _script_
====

+script+::
    A Tcl script that is executed in an environment that will resolve
    _domain configuration_ commands that may be used to define
    the characteristics of a domain.

///////
----
<<manual package commands>>=
[call [cmd "::rosea configure"] [arg script]]
The [cmd configure] command executes [arg script] as a Tcl script
in an environments where commands in [arg script] may be used to
define the characteristics of a XUML domain.
The configuration [arg script] should invoke Configuration Commands as
described [sectref "Configuration Commands" below].
The [cmd configure] command may be invoked multiple times
to accumulate the domain configuration information for an entire
application.
One typical arrangement is to invoke [cmd configure]
once for each domain in the application with with [arg script]
containing the definition of a single domain.
----
///////

[float]
===== Implementation
[source,tcl]
----
<<rosea exports>>=
namespace export configure

<<rosea commands>>=
proc configure {script} {
    namespace upvar Config errcount errcount configlineno configlineno
    set errcount 0
    set configlineno 1
    try {
        relvar eval { # <1>
            ConfigEvaluate ::rosea::Config $script
        }
    } on error {result} {
        log::error $result
        incr errcount
    }
    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----
<1> Evaluating the script must be done as a +relvar+ transaction
as we will need to defer the constraint checking until all the domain
components have been defined.

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
CONFIG_ERRORS     {encountered %d configuration script errors}
----

///////
----
<<manual package commands>>=
[call [cmd "::rosea configureFromFile"] [arg filename]]
The [cmd configureFromFile] command executes the [cmd configure]
command on the script that is contained in the file named, [arg filename].
----
///////


[float]
===== Implementation
[source,tcl]
----
<<rosea exports>>=
namespace export configureFromFile

<<rosea commands>>=
proc configureFromFile {filename} {
    set f [::open $filename r]
    try {
        configure [read $f]
    } finally {
        ::chan close $f
    }
}
----

=== Defining a Domain

The _script_ handed to the +configure+ command should contain
invocations of the +domain+ command.

====
+domain+ _name_ _body_
====

+name+::
    The name of the domain. A domain name must be a non-empty string.
+body+::
    A Tcl script containing invocation of the domain definition commands
    to specify the details of the domain configuration.

///////
----
<<manual configuration commands>>=
[call [cmd domain] [arg name] [arg body]]

The [cmd domain] command executes [arg body] as a Tcl script in an environment
where the characteristcs of the domain may be defined.
The domain is given [arg name] as a name which may not be the empty string.
The [cmd domain] command may be invoked multiple times for the
same [arg name] and the resulting domain definitions are simply accumulated.
The [arg body] of the domain configuration script should invoke
Domain Configuration Commands as
described [sectref "Domain Configuration Commands" below].
----
///////

As we described above,
the domain configuration commands will take the data in their
arguments and store it away.
After we have finished all the configuration scripts,
then the +generate+ command is used to layout the data structures
and namespace as needed.

The structure of the data that is populated by the configuration
scripts is rather complicated itself.
There are many rules as to what is allowed or not allowed
when configuring the characteristics of a domain.
It is important that these rules be enforced to insure that the
generated domain is correct.
To accomplish that we will formulate a model of the domain rules.
Such models-of-models are usually called _meta-models_.
An unfortunate consequence of using a meta-model is that they tend
to be rather abstract and it is easy to confuse the rules associated
with building models with the rules associated with some particular
application domain.
We will strive to make the distinction clear.
To further confound the situation,
we will implement the meta-models as a set of TclRAL relvars and
relvar constraints.
This means we are putting TclRAL commands to two distinct uses:
first as a basis for the data architecture of the generated domains
and second as the basis for accumulating the domain definition
during configuration.
Again, we will strive to make the distinction clear.

In this section we start the process of configuring a domain by showing some of
the data structures we will use to store the configuration data as it is being
collected.
We will present these meta-model diagrams in small groups that are
associated with the configuration commands being discussed.
We will establish a pattern of presenting the meta-model class diagram
followed by a dicussion of the rules it enforces and finally show
the configuration code and how it populates the meta-model relvars.

Below is a UML class diagram for a domain and some of its component parts.

image::config-domain.pdf[title="Domain Configuration Class Diagram"]

A *Domain* is characterized by a Name and Location
and consists of a set of *Domain Elements* (*R1*).
*Domain Elements* are of three types (*R2*),
*Domain Operation*, *Relationship* and *Class*.
*R2* insures that no two elements have the same name and this makes sure that
there are no naming conflicts in the namespace ensemble into which the domain
is placed when it is generated.
A *Class* may also have a set of operations (*R8*).
These operations are of two types (*R7*), *Instance Operation* and
*Class Operation*.
The difference between the two is that *Instance Operation* will have
a generated +self+ argument that refers to the instance on which the
operation is performed.
In turn,
operations may be either user defined or system defined (*R9* and *R10*).
System operations are one of the *Supplied Operation* (*R16* and *R15*)
A *Supplied Operation* is mapped to a Tcl *Command* and may be supplied
to all classes and instances or to those where *RequiresStateModel* is true.

As we will see repeated many times below,
the above UML class diagram has a direct textual correspondance to
TclRAL +relvar+ commands.

[source,tcl]
----
<<config data>>=
relvar create Domain {
    Name        string
    Location    string
} Name

relvar create DomainElement {
    Domain  string
    Element string
} {Domain Element}

relvar association R1\
    DomainElement Domain *\
    Domain Name 1

relvar create Class {
    Domain  string
    Name    string
} {Domain Name}

relvar create Relationship {
    Domain  string
    Name    string
} {Domain Name}

relvar create DomainOperation {
    Domain      string
    Name        string
    Parameters  list
    Body        string
} {Domain Name}

relvar partition R2 DomainElement {Domain Element}\
    Class {Domain Name}\
    Relationship {Domain Name}\
    DomainOperation {Domain Name}
----

When configurating a domain,
we will evaluate the configuration script in the +DomainDef+ child namespace.
That namespace will define commands for all the components of the
domain.
We will use a similar arrangement for other nested aspects of
defining parts of the domain.

[source,tcl]
----
<<config commands>>=
proc domain {name body} {
    namespace upvar DomainDef DomainName DomainName ; # <1>
    set DomainName $name

    relvar uinsert ::rosea::Config::Domain [list Name $name Location {}] ; # <2>
    try {
        if {$name eq {}} {
            tailcall DeclError EMPTY_NAME domain
        }

        ConfigEvaluate [namespace current]::DomainDef  $body

        # At this point we have the definition of the domain and enough
        # information to tie together the referential attributes and
        # the association definitions.
        <<bind association references>>

        # We must also compute how polymorphic events are inherited
        # down generalization hierarchies.
        <<propagate polymorphic events>>
    } on error {result opts} {
        log::error $result
        upvar #0 ::rosea::Config::errcount errcount
        incr errcount
    }
}
----
<1> We place the domain name into the child namespace where the context
implies that all the components defined are to be part of this domain.
<2> We allow the +domain+ command to be invoked more than once.
Domains are open ended definitions and the +uinsert+ command will not
throw an error upon a duplicate.

(((error code,EMPTY_NAME)))
[source,tcl]
----
<<error code formats>>=
EMPTY_NAME      {the empty string is not a value name for a %s}
----

After evaluating the domain configuration script,
it is necessary to patch up the association data.
We will defer the discussion about binding the associations and their
attribute referenced until later when we have covered those commands.
For now,
we will say that there are semantics evaluations and checks that can only
be done after the entire domain configuration script has been processed.
The reason for this lies mainly with the way the DSL script commands
were defined to make them convenient when translating from an XUML model.
Polymorphic events also must be dealt with after the domain configuration
is in place.
Again we will discuss this further below.

Although we have said that domain configurations are cumulative,
clearly the need to resolve association bindings and polymorphic event
inheritance means that domain configurations cannot be split arbitrarily.
You will need to be aware that certain divisions of domain configuration
will end up separating information that is needed at the end of the
configuration process.

[float]
===== Tests
[source,tcl]
----
<<config command tests>>=
test configure-1.0 {
    Define domain
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            # A domain may be empty of components.
        }
    }
    relation extract [relvar set ::rosea::Config::Domain] Name
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test configure-1.1 {
    Define domain -- bad name
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain {} {
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

We need some more testing support.
After running configuration commands, we will need to clean
up the configuration data.

[source,tcl]
----
<<test utility procs>>=
proc cleanupConfigData {} {
    set preserved {
        ::rosea::Config::TransitionRule
        ::rosea::Config::SuppliedOperation
        ::rosea::Config::SuppliedInstanceOperation
        ::rosea::Config::SuppliedClassOperation
    }
    relvar eval {
        foreach rname [relvar names ::rosea::Config::*] {
            if {!($rname in $preserved ||\
                    [string match {__*} [namespace tail $rname]])} {
                relvar set $rname [relation emptyof [relvar set $rname]]
            }
        }
    }
}
----

=== Defining Domain Components

In this section we discuss the commands that are used to define
the components of a domain.
We define child namespaces for those domain component commands
that have a nested structure.
In this case,
it is the +class+ command that requires additional configuration commands.

We start with the namespace layout for the +DomainDef+ namespace.

[source,tcl]
----
<<domain config namespace layout>>=
namespace eval DomainDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace import ::rosea::Config::ConfigEvaluate
    namespace import ::rosea::Helpers::DeclError
    <<domain config commands>>

    <<class config namespace layout>>
    <<assigner config namespace layout>>
}
----

=== Defining Classes

====
+class+ _name_ _body_
====

+name+::
    The name of the class. A class name must be a non-empty string.
+body+::
    A Tcl script containing invocation of the class definition commands
    to specify the details of the class configuration.

///////
----
<<manual domain configuration commands>>=
[call [cmd class] [arg name] [arg body]]

The [cmd class] command executes [arg body] as a Tcl script in an environment
where the characteristcs of the class may be defined.
The class is given [arg name] as a name which may not be the empty string.
----
///////

Below is a UML class diagram of the configuration data for defining
classes.
There are a substantial number of rules about what constitutes a
proper XUML class.
This diagram is intended to enforce those rules.
For example,
every class must have at least one identifier.
That rule is enforced by relationship, +R4+.
Every class must have at least one attribute and that rule is
enforced by relationship, +R3+.
The use of a schema such as this insures that evaluating a class
definition script results in a consistent class definition.

image::config-classes.pdf[title="Classes Configuration Class Diagram"]

As before,
the TclRAL relvar defintions corresponding to the class model are
are direct text transliteration of the model graphic.

[source,tcl]
----
<<config data>>=
relvar create Attribute {
    Domain  string
    Class   string
    Name    string
    Type    string
} {Domain Class Name}

relvar association R3\
    Attribute {Domain Class} +\
    Class {Domain Name} 1

relvar create Identifier {
    Domain  string
    Class   string
    Number  int
} {Domain Class Number}

relvar association R4\
    Identifier {Domain Class} +\
    Class {Domain Name} 1

relvar create IdentifyingAttribute {
    Domain      string
    Class       string
    Attribute   string
    Number      int
} {Domain Class Attribute Number}

relvar correlation R5 IdentifyingAttribute\
    {Domain Class Number} + Identifier {Domain Class Number}\
    {Domain Class Attribute} * Attribute {Domain Class Name}

relvar create DefaultValue {
    Domain      string
    Class       string
    Attribute   string
    Value       string
} {Domain Class Attribute}

relvar association R6\
    DefaultValue {Domain Class Attribute} ?\
    Attribute {Domain Class Name} 1

relvar create AttributeReference {
    Domain              string
    ReferringClass      string
    ReferringAttribute  string
    ReferringRole       string
    ReferencedClass     string
    ReferencedAttribute string
    ReferencedRole      string
    ReferencedIdNumber  int
    Relationship        string
} {Domain ReferringClass ReferringAttribute ReferringRole\
    ReferencedClass ReferencedAttribute ReferencedRole ReferencedIdNumber\
    Relationship}

relvar association R13\
    AttributeReference {Domain ReferringClass ReferringAttribute} *\
    Attribute {Domain Class Name} 1

relvar create ReferencedIdAttribute {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Attribute       string
    Number          int
} {Domain Class Relationship Role Attribute Number}
----

[source,tcl]
----
<<domain config commands>>=
proc class {name body} {
    namespace upvar [namespace current] DomainName DomainName ; # <1>
    namespace upvar ClassDef ClassName ClassName
    set ClassName $name

    try {
        if {$name eq {}} {
            tailcall DeclError EMPTY_NAME class
        }
        relvar insert ::rosea::Config::DomainElement [list\
            Domain  $DomainName\
            Element $name\
        ]
        relvar insert ::rosea::Config::Class [list\
            Domain  $DomainName\
            Name    $name\
        ]
        set instops [pipe {
            relvar set ::rosea::Config::SuppliedInstanceOperation |
            relation extend ~ ioptuple\
                Domain string {[set DomainName]}\
                Class string {[set ClassName]}
        }]
        relvar union ::rosea::Config::SystemInstanceOperation $instops
        relvar union ::rosea::Config::InstanceOperation $instops
        relvar union ::rosea::Config::Operation $instops
        set classops [pipe {
            relvar set ::rosea::Config::SuppliedClassOperation |
            relation extend ~ coptuple\
                Domain string {[set DomainName]}\
                Class string {[set ClassName]}
        }]
        relvar union ::rosea::Config::SystemClassOperation $classops
        relvar union ::rosea::Config::ClassOperation $classops
        relvar union ::rosea::Config::Operation $classops

        ConfigEvaluate [namespace current]::ClassDef  $body
    } on error {result opts} {
        log::error $result
        upvar #0 ::rosea::Config::errcount errcount
        incr errcount
    }
}
----
<1> Again we arrange for namespace variables to hold the current
domain and class names to provide the context of the definition.

=== Defining Classes Components

Since there are several aspects of classes,
the +class+ command takes a _script_ argument which should
invoke the commands we discuss in this section.
Following our pattern,
we define a namespace where the class body script is evaluated.

[source,tcl]
----
<<class config namespace layout>>=
namespace eval ClassDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace import ::rosea::Config::ConfigEvaluate
    namespace import ::rosea::Helpers::DeclError

    <<class config commands>>

    <<state model config namespace layout>>
}
----

==== Defining Attributes

Within a class definitions,
the +attribute+ command specifies the attributes of the class.

=====
+attribute+ _name_ _type_ ?_option value_ ...?
=====

+name+::
    The name of the attribute. Attributes names may not be the empty string.
+type+::
    The type of the attribute. The _type_ may be any type that is acceptable
    to the +::ral::tuple+ command.
+option value+::
    A set of _option/value_ pairs that define the characteristics of the
    attribute.
    Valid options are:
    +-default+ _value_:::
        Specifies a default value that will be supplied if an instance
        is created and no value is provided for the attribute.
    +-id+ _number_:::
        Specifies that the attribute is part of the identifier given by
        _number_.
        All classes must have at least one identifier.
        Classes may have multiple identifiers and each is given a
        separate number. Typically, _number_ is a small integer
        such as 1, 2 or 3.

///////
----
<<manual class configuration commands>>=
[call [cmd attribute] [arg name] [arg datatype] [opt [arg "option value ..."]]]
----
///////

.A Note About Identifiers
*******
For lack of a better way to distinguish identifiers,
integer numbers are used.
The most common case is for a class to have a single identifier
and for that identifier to have a single attribute.
So typically, one attribute of the class will be marked as +-id 1+.
Identifiers must also be minimal identifiers,
_i.e._ one identifier's attributes must not be a subset (proper or improper)
of the attributes of another identifier.
The rule of minimal identifiers is _not_ enforced by the class configuration
UML model but TclRAL will insist upon it when the underlying relvar is
created.
*******

The implementation of the +attribute+ command simply creates tuples
in the relvars to hold the attribute characteristics.

[source,tcl]
----
<<class config commands>>=
proc attribute {name type args} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME attribute
    }
    if {[string range $name 0 1] eq "__"} {
        tailcall DeclError RESERVED_NAME $name
    }
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    relvar insert ::rosea::Config::Attribute [list\
        Domain  $DomainName\
        Class   $ClassName\
        Name    $name\
        Type    $type\
    ]

    foreach {option value} $args {
        switch -exact -- $option {
            -default {
                relvar insert ::rosea::Config::DefaultValue [list\
                    Domain      $DomainName\
                    Class       $ClassName\
                    Attribute   $name\
                    Value       $value\
                ]
            }
            -id {
                relvar uinsert ::rosea::Config::Identifier [list\
                    Domain      $DomainName\
                    Class       $ClassName\
                    Number      $value\
                ]
                relvar insert ::rosea::Config::IdentifyingAttribute [list\
                    Domain      $DomainName\
                    Class       $ClassName\
                    Attribute   $name\
                    Number      $value\
                ]
            }
            default {
                tailcall DeclError UNKNOWN_OPTION attribute $option
            }
        }
    }
}
----

(((error code,RESERVED_NAME)))
[source,tcl]
----
<<error code formats>>=
RESERVED_NAME {names beginning with two underscore characters are reserved,\
        "%s"}
    
----

==== Defining References

One of the more complicated aspects of XUML is understanding
class relationships and how the fundamental notions of
referential integrity constraints from relational algebra are implemented.
For our purposes,
we have chosen to specify relationships in two pieces:

. Specifying that some attributes are _referential_. Attribute references
are the means by which relationships are realized.
They define attributes whose values are equal to the value of a
corresponding attribute in the related class.
. Specifying the relationship characteristics such as the classes involved
and the multiplicity and conditionality of the relationship.

The reason we have taken this approach is that it corresponds closely
to the UML graphic that we are translating.
The referential nature of an attribute is denoted in the graphic as a
characteristic of the attribute and relationships have a separate graphical
representation.
The result of this decision is that the most common case of simple
associations can be specified with the least amount of text.
The tradeoff is that the most general case of a reflexive, class-based
association requires more specification to resolve an inherent ambiguity.

======
+reference+ _relationship_ _class_ ?_option value_ ...?
======

+relationship+::
    The name of the relationship to which the reference applies.
+class+::
    The name of the class to which the reference refers.
+option value+::
    A set of _option/value_ pairs that define the characteristics of the
    reference.
    Valid options are:
    +-link+ _attribute reference_:::
        The +-link+ option specifies an attribute reference.
        The _attribute reference_ value is a one or two element list.
        The first element is the name of an attribute in the class being
        defined.
        The second element is the name of an attribute in the class given
        by the _class_ argument.
        The +-link+ option specifies that an attribute in the class being
        defined is a reference to (_i.e._ will have the same value as)
        an attribute in the _class_ class.
        If the second element of the _attribute reference_ is missing,
        then the name of the referenced attribute is assumed to be
        the same as the referencing attribute.
        Multiple +-link+ options may be given for a given _relationships_.
        The link options must define a one-to-one correspondance between
        referring attributes and an identifier in _class_.
    +-refid+ _number_:::
        The +refid+ option gives the _number_ of the identifier to which
        reference is directed.
        If missing, then +refid+ defaults to 1.
        Typically, references in the class being defined refer to the primary
        identifier in _class_.
        However, if they refer to another identifier, then the +refid+
        option is necessary.
        All the attributes given by the +-link+ options, as a group,
        must reference a specific identifier in _class_.

///////
----
<<manual class configuration commands>>=
[call [cmd reference] [arg relationship] [arg class]\
        [opt [arg "option value ..."]]]
----
///////

[source,tcl]
----
<<class config commands>>=
proc reference {relname rclass args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    set refnum 1

    foreach {option value} $args {
        switch -exact -- $option {
            -refid {
                set refnum $value
            }
            -link {
                if {[llength $value] < 1 || [llength $value] > 2} {
                    tailcall DeclError ARG_FORMAT $value
                }
                lassign $value referring referenced
                if {$referenced eq {}} {
                    set referenced $referring
                }
                relvar insert ::rosea::Config::AttributeReference [list\
                    Domain              $DomainName\
                    ReferringClass      $ClassName\
                    ReferringAttribute  $referring\
                    ReferringRole       source\
                    ReferencedClass     $rclass\
                    ReferencedAttribute $referenced\
                    ReferencedRole      target\
                    ReferencedIdNumber  $refnum\
                    Relationship        $relname
                ]
            }
            default {
                tailcall DeclError UNKNOWN_OPTION reference $option
            }
        }
    }
}
----

(((error code,ARG_FORMAT)))
(((error code,UNKNOWN_OPTION)))
[source,tcl]
----
<<error code formats>>=
ARG_FORMAT      {options and values must come in pairs, got "%s"}
UNKNOWN_OPTION  {unknown %s command option, "%s"}
----

[source,tcl]
----
<<config command tests>>=
test configure-2.0 {
    Define domain and classes
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class c1 {
                attribute a1 string -id 1
                attribute a2 string -default 20
            }
            class c2 {
                attribute a1 string -id 1
                attribute a2 string -default 40
            }
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {2}
----

[source,tcl]
----
<<config command tests>>=
test configure-2.1 {
    Define domain -- bad attribute option
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class c1 {
                attribute a1 string -foo 1 -id 1
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

=== Defining Operations

[source,tcl]
----
<<config data>>=
relvar create Operation {
    Domain  string
    Class   string
    Name    string
} {Domain Class Name}

relvar association R8\
    Operation {Domain Class} * Class {Domain Name} 1

relvar create InstanceOperation {
    Domain  string
    Class   string
    Name    string
} {Domain Class Name}

relvar create ClassOperation {
    Domain  string
    Class   string
    Name    string
} {Domain Class Name}

relvar partition R7 Operation {Domain Class Name}\
    InstanceOperation {Domain Class Name}\
    ClassOperation {Domain Class Name}

relvar create UserInstanceOperation {
    Domain      string
    Class       string
    Name        string
    Parameters  string
    Body        string
} {Domain Class Name}

relvar create SystemInstanceOperation {
    Domain      string
    Class       string
    Name        string
} {Domain Class Name}

relvar partition R9 InstanceOperation {Domain Class Name}\
    UserInstanceOperation {Domain Class Name}\
    SystemInstanceOperation {Domain Class Name}

relvar create UserClassOperation {
    Domain  string
    Class   string
    Name    string
    Parameters  string
    Body        string
} {Domain Class Name}

relvar create SystemClassOperation {
    Domain  string
    Class   string
    Name    string
} {Domain Class Name}

relvar partition R10 ClassOperation {Domain Class Name}\
    UserClassOperation {Domain Class Name}\
    SystemClassOperation {Domain Class Name}

relvar create SuppliedOperation {
    Name                string
    Command             string
    RequiresStateModel  boolean
} Name

relvar create SuppliedClassOperation {
    Name    string
} Name

relvar create SuppliedInstanceOperation {
    Name    string
} Name

relvar partition R14 SuppliedOperation Name\
    SuppliedClassOperation Name\
    SuppliedInstanceOperation Name

relvar association R15\
    SystemClassOperation Name *\
    SuppliedClassOperation Name 1

relvar association R16\
    SystemInstanceOperation Name *\
    SuppliedInstanceOperation Name 1
----

=== Defining Class Operations

[source,tcl]
----
<<config data>>=
relvar eval {
    relvar insert SuppliedOperation {
        Name                findAll
        Command             ::rosea::ClassCmds::findAll
        RequiresStateModel  false
    } {
        Name                findById
        Command             ::rosea::ClassCmds::findById
        RequiresStateModel  false
    } {
        Name                findWhere
        Command             ::rosea::ClassCmds::findWhere
        RequiresStateModel  false
    } {
        Name                create
        Command             ::rosea::ClassCmds::create
        RequiresStateModel  false
    } {
        Name                createin
        Command             ::rosea::ClassCmds::createin
        RequiresStateModel  true
    } {
        Name                createasync
        Command             ::rosea::ClassCmds::createasync
        RequiresStateModel  true
    } {
        Name                update
        Command             ::rosea::ClassCmds::update
        RequiresStateModel  false
    }

    relvar insert SuppliedClassOperation {
        Name    findAll
    } {
        Name    findById
    } {
        Name    findWhere
    } {
        Name    create
    } {
        Name    createin
    } {
        Name    createasync
    } {
        Name    update
    }
}
----

///////
----
<<manual class configuration commands>>=
[call [cmd classop] [arg name] [arg params] [arg body]]
----
///////

[source,tcl]
----
<<class config commands>>=
proc classop {name params body} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME "class operation"
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    set sysop [relvar restrictone ::rosea::Config::Operation\
        Domain $DomainName Class $ClassName Name $name]
    if {[relation isnotempty $sysop]} {
        tailcall DeclError DUP_OP_NAME $name
    }

    set optuple [list Domain $DomainName Class $ClassName Name $name]
    relvar insert ::rosea::Config::Operation $optuple
    relvar insert ::rosea::Config::ClassOperation $optuple

    lappend optuple Parameters $params Body $body
    relvar insert ::rosea::Config::UserClassOperation $optuple
}
----

(((error code,DUP_OP_NAME)))
[source,tcl]
----
<<error code formats>>=
DUP_OP_NAME      {operation call, "%s", already exists}
----

=== Defining Instances Operations

[source,tcl]
----
<<config data>>=
relvar eval {
    relvar insert SuppliedOperation {
        Name                findRelated
        Command             ::rosea::InstCmds::findRelated
        RequiresStateModel  false
    } {
        Name                findUnrelated
        Command             ::rosea::InstCmds::findById
        RequiresStateModel  false
    } {
        Name                findRelatedWhere
        Command             ::rosea::InstCmds::findRelatedWhere
        RequiresStateModel  false
    } {
        Name                findUnrelatedWhere
        Command             ::rosea::InstCmds::findUnrelatedWhere
        RequiresStateModel  false
    } {
        Name                updateAttribute
        Command             ::rosea::InstCmds::updateAttribute
        RequiresStateModel  false
    } {
        Name                readAttribute
        Command             ::rosea::InstCmds::readAttribute
        RequiresStateModel  false
    } {
        Name                delete
        Command             ::rosea::InstCmds::delete
        RequiresStateModel  false
    } {
        Name                signal
        Command             ::rosea::InstCmds::signal
        RequiresStateModel  true
    } {
        Name                delaysignal
        Command             ::rosea::InstCmds::delaysignal
        RequiresStateModel  true
    } {
        Name                canceldelayed
        Command             ::rosea::InstCmds::canceldelayed
        RequiresStateModel  true
    } {
        Name                delayremaining
        Command             ::rosea::InstCmds::delayremaining
        RequiresStateModel  true
    } {
        Name                deRef
        Command             ::rosea::InstCmds::deRef
        RequiresStateModel  false
    } {
        Name                isEmptyRef
        Command             ::rosea::InstCmds::isEmptyRef
        RequiresStateModel  false
    } {
        Name                isNotEmptyRef
        Command             ::rosea::InstCmds::isNotEmptyRef
        RequiresStateModel  false
    } {
        Name                refMultiplicity
        Command             ::rosea::InstCmds::refMultiplicity
        RequiresStateModel  false
    } {
        Name                isRefSingular
        Command             ::rosea::InstCmds::isRefSingular
        RequiresStateModel  false
    } {
        Name                isRefEqual
        Command             ::rosea::InstCmds::isRefEqual
        RequiresStateModel  false
    } {
        Name                forAllRefs
        Command             ::rosea::InstCmds::forAllRefs
        RequiresStateModel  false
    }

    relvar insert SuppliedInstanceOperation {
        Name    findRelated
    } {
        Name    findUnrelated
    } {
        Name    findRelatedWhere
    } {
        Name    findUnrelatedWhere
    } {
        Name    updateAttribute
    } {
        Name    readAttribute
    } {
        Name    delete
    } {
        Name    signal
    } {
        Name    delaysignal
    } {
        Name    canceldelayed
    } {
        Name    delayremaining
    } {
        Name    deRef
    } {
        Name    isEmptyRef
    } {
        Name    isNotEmptyRef
    } {
        Name    refMultiplicity
    } {
        Name    isRefSingular
    } {
        Name    isRefEqual
    } {
        Name    forAllRefs
    }
}
----

///////
----
<<manual class configuration commands>>=
[call [cmd instop] [arg name] [arg params] [arg body]]
----
///////

[source,tcl]
----
<<class config commands>>=
proc instop {name params body} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME "instance operation"
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    set sysop [relvar restrictone ::rosea::Config::Operation\
        Domain $DomainName Class $ClassName Name $name]
    if {[relation isnotempty $sysop]} {
        tailcall DeclError DUP_OP_NAME $name
    }

    set optuple [list Domain $DomainName Class $ClassName Name $name]
    relvar insert ::rosea::Config::Operation $optuple
    relvar insert ::rosea::Config::InstanceOperation $optuple

    lappend optuple Parameters $params Body $body
    relvar insert ::rosea::Config::UserInstanceOperation $optuple
}
----

=== Defining Relationships

image::config-relation.pdf[title="Relationship Configuration Class Diagram"]

[source,tcl]
----
<<config data>>=
relvar create Association {
    Domain      string
    Name        string
} {Domain Name}

relvar create Generalization {
    Domain      string
    Name        string
} {Domain Name}

relvar partition R30 Relationship {Domain Name}\
    Association {Domain Name}\
    Generalization {Domain Name}

relvar create SimpleAssociation {
    Domain      string
    Name        string
} {Domain Name}

relvar create ClassBasedAssociation {
    Domain      string
    Name        string
} {Domain Name}

relvar partition R31 Association {Domain Name}\
    SimpleAssociation {Domain Name}\
    ClassBasedAssociation {Domain Name}

relvar create SimpleReferringClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Conditionality  boolean
    Multiplicity    boolean
} {Domain Class Relationship Role}

relvar association R32\
    SimpleReferringClass {Domain Relationship} 1\
    SimpleAssociation {Domain Name} 1

relvar create SimpleReferencedClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Conditionality  boolean
} {Domain Class Relationship Role}

relvar association R33\
    SimpleReferencedClass {Domain Relationship} 1\
    SimpleAssociation {Domain Name} 1

relvar create SourceClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Conditionality  boolean
    Multiplicity    boolean
} {Domain Class Relationship Role}

relvar association R34\
    SourceClass {Domain Relationship} 1\
    ClassBasedAssociation {Domain Name} 1

relvar create TargetClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
    Conditionality  boolean
    Multiplicity    boolean
} {Domain Class Relationship Role}

relvar association R35\
    TargetClass {Domain Relationship} 1\
    ClassBasedAssociation {Domain Name} 1

relvar create AssociatorClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar association R42\
    AssociatorClass {Domain Relationship} 1\
    ClassBasedAssociation {Domain Name} 1

relvar create Superclass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar association R36\
    Superclass {Domain Relationship} 1\
    Generalization {Domain Name} 1

relvar create Subclass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar association R37\
    Subclass {Domain Relationship} +\
    Generalization {Domain Name} 1

relvar create ReferringClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar partition R38 ReferringClass {Domain Class Relationship Role}\
    SimpleReferringClass {Domain Class Relationship Role}\
    AssociatorClass {Domain Class Relationship Role}\
    Subclass {Domain Class Relationship Role}

relvar create ReferencedClass {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar partition R39 ReferencedClass {Domain Class Relationship Role}\
    SimpleReferencedClass {Domain Class Relationship Role}\
    SourceClass {Domain Class Relationship Role}\
    TargetClass {Domain Class Relationship Role}\
    Superclass {Domain Class Relationship Role}

relvar create ClassRole {
    Domain          string
    Class           string
    Relationship    string
    Role            string
} {Domain Class Relationship Role}

relvar partition R40 ClassRole {Domain Class Relationship Role}\
    ReferringClass {Domain Class Relationship Role}\
    ReferencedClass {Domain Class Relationship Role}

relvar correlation R41 ClassRole\
    {Domain Relationship} + Relationship {Domain Name}\
    {Domain Class} * Class {Domain Name}

relvar correlation R11 ReferencedIdAttribute\
    {Domain Class Relationship Role} +\
        ReferencedClass {Domain Class Relationship Role}\
    {Domain Class Attribute Number} *\
        IdentifyingAttribute {Domain Class Attribute Number}

relvar correlation R12 AttributeReference\
    {Domain ReferringClass Relationship ReferringRole} +\
        ReferringClass {Domain Class Relationship Role}\
    {Domain ReferencedClass Relationship ReferencedRole ReferencedAttribute\
            ReferencedIdNumber} +\
        ReferencedIdAttribute {Domain Class Relationship Role Attribute Number}
----

==== Defining Associations

...............
association name <source> <spec> <target>
    ?-associator <associator class>?
    ?-path {<source attr> <target attr>} ...?


    <spec> ==>      1--1
                    0..1--1
                    0..1--0..1
                    1..n--1
                    0..n--1
                    1..n--0..1
                    0..n--0..1
                    1..n--1..n
                    0..n--1..n
                    1..n--0..n
                    0..n--0..n
...............

///////
----
<<manual domain configuration commands>>=
[call [cmd association] [arg name] [arg source] [arg spec] [arg target]\
    [opt [arg "option value ..."]]]

The [cmd association] command defines a referential association called,
[arg name], between
a [arg source] class and a [arg target] class.
The multiplicity and conditionality of the association is specified
by [arg spec].
The [arg spec] argument must be a string from one of the following:
[list_begin itemized]
[item] 1--1
[item] 0..1--1 [emph or] ?--1
[item] 0..1--0..1 [emph or] ?--?
[item] 1..n--1 [emph or] +--1
[item] 0..n--1 [emph or] *--1
[item] 1..n--0..1 [emph or] +--?
[item] 0..n--0..1 [emph or] *--?
[item] 1..n--1..n [emph or] +--+
[item] 0..n--1..n [emph or] *--+
[item] 1..n--0..n [emph or] +--*
[item] 0..n--0..n [emph or] *--*
[list_end]

Options must be one of the following:
[list_begin options]
[opt_def [option -associator] [arg class]]
The [option -associator] option define the association to be
[emph "class based"] and specifies [arg class] as the association class.
[opt_def [option -path] [arg attribute_list]]
The [option -path] option defines the direction of reference for
reflexive associations.
[list_end]
----
///////

[source,tcl]
----
<<config data>>=
relvar create __AssocInfo {
    Spec                string
    NeedsAssociator     boolean
    ReflexiveAllowed    boolean
    ReferringCond       boolean
    ReferringMult       boolean
    ReferencedCond      boolean
    ReferencedMult      boolean
} Spec

relvar insert __AssocInfo {
    Spec 1--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec 0..1--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec 0..1--0..1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult false
        ReferencedCond true ReferencedMult false
} {
    Spec 1..n--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec 0..n--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec 1..n--0..1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec 0..n--0..1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec 1..n--1..n NeedsAssociator true ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec 0..n--1..n NeedsAssociator true ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec 1..n--0..n NeedsAssociator true ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec 0..n--0..n NeedsAssociator true ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec ?--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec ?--? NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult false
        ReferencedCond true ReferencedMult false
} {
    Spec +--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec *--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec +--? NeedsAssociator false ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec *--? NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec +--+ NeedsAssociator true ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec *--+ NeedsAssociator true ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec +--* NeedsAssociator true ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec *--* NeedsAssociator true ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult true
}
----

The consequence of
the decision to specify the realization of relationships as
attribute references separately from the specification
of an association itself is that we will have to hold,
temporarily, some data about associations until all of the classes
are defined.
Then we will bind the attribute references to the relationship characteristics.
This is done below.
For now we show the data that must be kept aside to perform the binding
of the attribute references to the corresopnding associations.

[source,tcl]
----
<<config data>>=
relvar create ClassAssoc {
    Domain              string
    Relationship        string
    AssocClass          string
    SourceClass         string
} {Domain Relationship AssocClass SourceClass}

relvar create NonReflexiveAssoc {
    Domain              string
    Relationship        string
    AssocClass          string
    SourceClass         string
    TargetClass         string
} {Domain Relationship AssocClass SourceClass}

relvar create ReflexiveAssoc {
    Domain              string
    Relationship        string
    AssocClass          string
    SourceClass         string
} {Domain Relationship AssocClass SourceClass}

relvar create ReflexivePath {
    Domain              string
    Relationship        string
    AssocClass          string
    SourceClass         string
    SourceAttr          string
    TargetAttr          string
} {Domain Relationship AssocClass SourceClass SourceAttr}

relvar partition X1 ClassAssoc {Domain Relationship AssocClass SourceClass}\
    NonReflexiveAssoc {Domain Relationship AssocClass SourceClass}\
    ReflexiveAssoc {Domain Relationship AssocClass SourceClass}
relvar association X2\
    ReflexivePath {Domain Relationship AssocClass SourceClass} +\
    ReflexiveAssoc {Domain Relationship AssocClass SourceClass} 1
----

[source,tcl]
----
<<domain config commands>>=
proc association {name source spec target args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    set associator {}
    set path {}

    foreach {option value} $args {
        switch -exact -- $option {
            -associator {
                set associator $value
            }
            -path {
                set path $value
                if {[llength $path] % 2 != 0} {
                    tailcall DeclError ARG_FORMAT $path
                }
            }
            default {
                tailcall DeclError UNKNOWN_OPTION association $option
            }
        }
    }

    set ainfo [relvar restrictone ::rosea::Config::__AssocInfo Spec $spec]
    if {[relation isempty $ainfo]} {
        tailcall DeclError BAD_RELATIONSHIP_SPEC $spec
    }
    set needsassoc [relation extract $ainfo NeedsAssociator]
    if {$needsassoc && $associator eq {}} {
        tailcall DeclError NEED_ASSOCIATOR $spec
    }
    if {$source eq $target} {
        if {![relation extract $ainfo ReflexiveAllowed]} {
            tailcall DeclError REFLEXIVE_NOT_ALLOWED $spec
        }
        if {$needsassoc && $path eq {}} {
            tailcall DeclError NEED_REFLEXIVE_PATH $name $source $spec $target
        }
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName

    relvar insert ::rosea::Config::DomainElement [list\
        Domain  $DomainName\
        Element $name\
    ]

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    relvar insert ::rosea::Config::Relationship $reltuple
    relvar insert ::rosea::Config::Association $reltuple

    if {$associator eq {}} {
        relvar insert ::rosea::Config::SimpleAssociation $reltuple
        relvar insert ::rosea::Config::SimpleReferringClass [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
            Conditionality  [relation extract $ainfo ReferringCond]\
            Multiplicity    [relation extract $ainfo ReferringMult]\
        ]
        relvar insert ::rosea::Config::ReferringClass [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::SimpleReferencedClass [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
            Conditionality  [relation extract $ainfo ReferencedCond]\
        ]
        relvar insert ::rosea::Config::ReferencedClass [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
        ]
    } else {
        relvar insert ::rosea::Config::ClassAssoc [list\
            Domain              $DomainName\
            Relationship        $name\
            AssocClass          $associator\
            SourceClass         $source\
        ]
        if {[llength $path] == 0} {
            relvar insert ::rosea::Config::NonReflexiveAssoc [list\
                Domain              $DomainName\
                Relationship        $name\
                AssocClass          $associator\
                SourceClass         $source\
                TargetClass         $target\
            ]
        } else {
            relvar insert ::rosea::Config::ReflexiveAssoc [list\
                Domain              $DomainName\
                Relationship        $name\
                AssocClass          $associator\
                SourceClass         $source\
            ]
            foreach {sourceattr targetattr} $path {
                relvar insert ::rosea::Config::ReflexivePath [list\
                    Domain              $DomainName\
                    Relationship        $name\
                    AssocClass          $associator\
                    SourceClass         $source\
                    SourceAttr          $sourceattr\
                    TargetAttr          $targetattr\
                ]
            }
        }

        relvar insert ::rosea::Config::ClassBasedAssociation $reltuple
        relvar insert ::rosea::Config::SourceClass [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
            Conditionality  [relation extract $ainfo ReferringCond]\
            Multiplicity    [relation extract $ainfo ReferringMult]\
        ]
        relvar insert ::rosea::Config::ReferencedClass [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $source\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::TargetClass [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
            Conditionality  [relation extract $ainfo ReferencedCond]\
            Multiplicity    [relation extract $ainfo ReferencedMult]\
        ]
        relvar insert ::rosea::Config::ReferencedClass [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $target\
            Relationship    $name\
            Role            target\
        ]
        relvar insert ::rosea::Config::AssociatorClass [list\
            Domain          $DomainName\
            Class           $associator\
            Relationship    $name\
            Role            associator\
        ]
        relvar insert ::rosea::Config::ReferringClass [list\
            Domain          $DomainName\
            Class           $associator\
            Relationship    $name\
            Role            associator\
        ]
        relvar insert ::rosea::Config::ClassRole [list\
            Domain          $DomainName\
            Class           $associator\
            Relationship    $name\
            Role            associator\
        ]
    }
}
----

(((error code,BAD_RELATIONSHIP_SPEC)))
(((error code,NEED_ASSOCIATOR)))
(((error code, NEED_REFLEXIVE_PATH)))
(((error code, REFLEXIVE_NOT_ALLOWED)))
[source,tcl]
----
<<error code formats>>=
BAD_RELATIONSHIP_SPEC  {bad relationship specifier, "%s"}
NEED_ASSOCIATOR {relationship of type, "%s", requires associative class}
NEED_REFLEXIVE_PATH {traversal path must be specified for reflexive\
        association, %s, %s %s %s}
REFLEXIVE_NOT_ALLOWED   {associations of type, "%s", cannot be reflexive}
----

[source,tcl]
----
<<bind association references>>=
variable ReferencedClass
variable ReferringClass
variable ReferencedIdAttribute
variable AttributeReference
variable NonReflexiveAssoc
variable ReflexivePath

#puts [relformat $ReferencedClass ReferencedClass]
#puts [relformat $ReferringClass ReferringClass]
#puts [relformat $AttributeReference AttributeReference]
#puts [relformat $NonReflexiveAssoc NonReflexiveAssoc]
#puts [relformat $ReflexivePath ReflexivePath]

relation foreach nra $NonReflexiveAssoc {
    relation assign $nra
    relvar update ::rosea::Config::AttributeReference ar {
        [tuple extract $ar Domain] eq $Domain &&
        [tuple extract $ar Relationship] eq $Relationship &&
        [tuple extract $ar ReferringClass] eq $AssocClass
    } {tuple update $ar ReferringRole associator}

    relvar update ::rosea::Config::AttributeReference ar {
        [tuple extract $ar Domain] eq $Domain &&
        [tuple extract $ar Relationship] eq $Relationship &&
        [tuple extract $ar ReferringClass] eq $AssocClass &&
        [tuple extract $ar ReferencedClass] eq $SourceClass
    } {tuple update $ar ReferencedRole source}
}

relation foreach rp $ReflexivePath {
    relation assign $rp
    relvar update ::rosea::Config::AttributeReference ar {
        [tuple extract $ar Domain] eq $Domain &&
        [tuple extract $ar Relationship] eq $Relationship &&
        [tuple extract $ar ReferringClass] eq $AssocClass
    } {tuple update $ar ReferringRole associator}

    relvar update ::rosea::Config::AttributeReference ar {
        [tuple extract $ar Domain] eq $Domain &&
        [tuple extract $ar Relationship] eq $Relationship &&
        [tuple extract $ar ReferringClass] eq $AssocClass &&
        [tuple extract $ar ReferringAttribute] eq $SourceAttr
    } {tuple update $ar ReferencedRole source}
}

pipe {
    relvar set ::rosea::Config::AttributeReference |
    relation project ~ Domain ReferencedClass Relationship ReferencedRole\
            ReferencedAttribute ReferencedIdNumber |
    relation rename ~ ReferencedClass Class ReferencedRole Role\
            ReferencedAttribute Attribute ReferencedIdNumber Number |
    relvar union ::rosea::Config::ReferencedIdAttribute
}

#puts [relformat $AttributeReference AttributeReference]
#puts [relformat $ReferencedIdAttribute ReferencedIdAttribute]
----

[source,tcl]
----
<<config command tests>>=
test configure-3.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class x {
                attribute a1 string -id 1
                attribute a2 string -default 20
            }
            class y {
                attribute a1 string -id 1
                reference R1 x -link a1
            }
            association R1 y 1--1 x
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {2}
----

[source,tcl]
----
<<config command tests>>=
test configure-3.1 {
    Define reflexive simple association
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class x {
                attribute a1 string -id 1
                attribute prev string -id 2
                attribute a2 string -default 20
                reference R1 x -link {prev a1}
            }
            association R1 x 1--1 x
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test configure-3.2 {
    Define class based association
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class a {
                attribute x1 string -id 1
                attribute y1 string -id 1
                reference R1 x -link x1
                reference R1 y -link y1
            }
            class x {
                attribute x1 string -id 1
                attribute x2 string -default 20
            }
            class y {
                attribute y1 string -id 1
            }
            association R1 x 1..n--1..n y -associator a
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {3}
----

[source,tcl]
----
<<config command tests>>=
test configure-3.3 {
    Define reflexive class based association
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class a {
                attribute x1 string -id 1
                attribute next string -id 1
                reference R1 x -link x1 -link {next x1}
            }
            class x {
                attribute x1 string -id 1
                attribute x2 string -default 20
            }
            association R1 x 1..n--1..n x -associator a -path {x1 next}
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {2}
----

==== Defining Generalizations

...............
generalization name super sub1 sub2 ...
...............

///////
----
<<manual domain configuration commands>>=
[call [cmd generalization] [arg name] [arg superclass] [arg subclass1]\
    [arg "subclass2 ..."]]
----
///////

[source,tcl]
----
<<domain config commands>>=
proc generalization {name super args} {
    if {[llength $args] < 2} {
        tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName

    relvar insert ::rosea::Config::DomainElement [list\
        Domain  $DomainName\
        Element $name\
    ]

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    relvar insert ::rosea::Config::Relationship $reltuple
    relvar insert ::rosea::Config::Generalization $reltuple

    set supertuple [list\
        Domain          $DomainName\
        Class           $super\
        Relationship    $name\
        Role            target\
    ]
    relvar insert ::rosea::Config::Superclass $supertuple
    relvar insert ::rosea::Config::ReferencedClass $supertuple
    relvar insert ::rosea::Config::ClassRole $supertuple

    foreach sub $args {
        set subtuple [list\
            Domain          $DomainName\
            Class           $sub\
            Relationship    $name\
            Role            source\
        ]
        relvar insert ::rosea::Config::Subclass $subtuple
        relvar insert ::rosea::Config::ReferringClass $subtuple
        relvar insert ::rosea::Config::ClassRole $subtuple
    }
}
----

(((error code,TOO_FEW_SUBCLASSES)))
[source,tcl]
----
<<error code formats>>=
TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
----

[source,tcl]
----
<<config command tests>>=
test configure-4.0 {
    Define generalization
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class super {
                attribute a1 string -id 1
                attribute a2 string -default 20
            }
            class sub1 {
                attribute a1 string -id 1
                reference R1 super -link a1
            }
            class sub2 {
                attribute a1 string -id 1
                reference R1 super -link a1
            }
            generalization R1 super sub1 sub2
        }
    }
    relation cardinality [relvar set ::rosea::Config::Class]
} -result {3}
----

==== Defining Assigners

[source,tcl]
----
<<assigner config namespace layout>>=
namespace eval AssignerDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace import ::rosea::Config::ConfigEvaluate
    namespace import ::rosea::Helpers::DeclError

    <<assigner config commands>>
}
----


[float]
===== Synopsis
====
+assigner+ _association_ _script_
====

///////
----
<<manual domain configuration commands>>=
[call [cmd assigner] [arg association] [arg script]]
----
///////

[source,tcl]
----
<<domain config commands>>=
proc assigner {rname body} {
    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar AssignerDef\
        RelationshipName RelationshipName\
        multiClass multiClass\
        multiIdNum multiIdNum\
        InitialState InitialState\
        DefaultTrans DefaultTrans

    set RelationshipName $rname
    set multiClass {}
    set multiIdNum 1
    set InitialState {}
    set DefaultTrans {}

    try {
        ConfigEvaluate [namespace current]::AssignerDef $body

        if {$DefaultTrans eq {}} {
            set DefaultTrans CH
        }
        relvar insert ::rosea::Config::StateModel [list\
            Domain          $DomainName\
            Model           $rname\
            InitialState    $InitialState\
            DefaultTrans    $DefaultTrans\
        ]
        set assigntuple [list\
            Domain          $DomainName\
            Relationship    $rname\
        ]
        relvar insert ::rosea::Config::AssignerStateModel $assigntuple
        if {$multiClass eq {}} {
            relvar insert ::rosea::Config::SingleAssigner $assigntuple
        } else {
            lappend assigntuple Class $multiClass Number $multiIdNum
            relvar insert ::rosea::Config::MultipleAssigner $assigntuple
        }
    } on error {result opts} {
        log::error $result
        upvar #0 ::rosea::Config::errcount errcount
        incr errcount
    }
}
----

///////
----
<<manual assigner configuration commands>>=
[call [cmd state] [arg name] [arg parameters] [arg body]]
----
///////

[source,tcl]
----
<<assigner config commands>>=
proc state {name params body} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME state
    }
    if {$name in {CH IG}} {
        tailcall DeclError PSEUDO_STATE $name state
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::AssignerDef\
        RelationshipName RelationshipName

    variable InitialState

    if {$InitialState eq {}} {
        set InitialState $name
    }

    relvar insert ::rosea::Config::State [list\
        Domain          $DomainName\
        Model           $RelationshipName\
        Name            $name\
        Parameters      $params\
        Action          $body\
        IsFinal         false\
    ]
    relvar insert ::rosea::Config::StatePlace [list\
        Domain          $DomainName\
        Model           $RelationshipName\
        Name            $name\
    ]
    return
}
----

///////
----
<<manual assigner configuration commands>>=
[call [cmd transition] [arg source] [arg -] [arg event] [arg ->] [arg target]]
----
///////

[source,tcl]
----
<<assigner config commands>>=
proc transition {source - event -> target} {
    if {$event eq {}} {
        tailcall DeclError EMPTY_NAME event
    }
    if {$source in {CH IG}} {
        tailcall DeclError PSEUDO_STATE $name "transition source state"
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::AssignerDef\
        RelationshipName RelationshipName

    set eventtuple [list\
        Domain  $DomainName\
        Model   $RelationshipName\
        Event   $event\
    ]
    relvar uinsert ::rosea::Config::Event $eventtuple
    relvar uinsert ::rosea::Config::EffectiveEvent $eventtuple
    relvar uinsert ::rosea::Config::LocalEvent $eventtuple

    set tranrule [relvar restrictone ::rosea::Config::TransitionRule\
        Name $target]
    set transtuple [list\
        Domain  $DomainName\
        Model   $RelationshipName\
        State   $source\
        Event   $event\
    ]
    relvar insert ::rosea::Config::TransitionPlace $transtuple

    if {[relation isnotempty $tranrule]} {
        lappend transtuple TransRule $target
        set tpsubtype NonStateTransition
    } else {
        lappend transtuple NewState $target
        set tpsubtype StateTransition
    }
    relvar insert ::rosea::Config::$tpsubtype $transtuple
    return
}
----

///////
----
<<manual assigner configuration commands>>=
[call [cmd initialstate] [arg name]]
----
///////

[source,tcl]
----
<<assigner config commands>>=
proc initialstate {name} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME initialstate
    }
    if {$name in {CH IG}} {
        tailcall DeclError PSEUDO_STATE $name initialstate
    }
    variable InitialState $name
    return
}
----

(((error code,PSEUDO_STATE)))
[source,tcl]
----
<<error code formats>>=
PSEUDO_STATE    {the transition action, "%s", is not valid as %s}
----

///////
----
<<manual assigner configuration commands>>=
[call [cmd defaulttrans] [arg "CH | IG"]]
----
///////

[source,tcl]
----
<<assigner config commands>>=
proc defaulttrans {name} {
    if {$name ni {CH IG}} {
        tailcall DeclError EXPECTED_PSEUDO_STATE $name
    }
    variable DefaultTrans $name
    return
}
----

(((error code,EXPECTED_PSEUDO_STATE)))
[source,tcl]
----
<<error code formats>>=
EXPECTED_PSEUDO_STATE    {expected CH or IG, got "%s"}
----

///////
----
<<manual assigner configuration commands>>=
[call [cmd identifyby] [arg name] [opt [arg "-id idnumber"]]]
----
///////

[source,tcl]
----
<<assigner config commands>>=
proc identifyby {name args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    variable multiClass $name

    foreach {option value} $args {
        switch -exact -- $option {
            -id {
                variable multiIdNum $value
            }
            default {
                tailcall DeclError UNKNOWN_OPTION  identifyby $option
            }
        }
    }

    return
}
----

[source,tcl]
----
<<config command tests>>=
test configure-7.0 {
    Define assigner
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class Customer {
                attribute Name string -id 1
            }
            class Clerk {
                attribute Name string -id 1
                attribute Customer string
                reference R1 Customer -link {Customer Name}
            }
            association R1 Clerk 0..1--0..1 Customer
            assigner R1 {
                state s1 {a b} {
                    puts $a $b
                }
                transition s1 - e1 -> s2

                state s2 {} {
                    puts "in s2"
                }
                transition s2 - e1 -> s1
            }
        }
    }
    relation cardinality [relvar set ::rosea::Config::SingleAssigner]
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test configure-7.1 {
    Define mulit assigner
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class Customer {
                attribute Name string -id 1
            }
            class Clerk {
                attribute Name string -id 1
                attribute Customer string
                attribute Department string
                reference R1 Customer -link {Customer Name}
                reference R2 Department -link {Department Name}
            }
            class Department {
                attribute Name string -id 1
            }
            association R1 Clerk 0..1--0..1 Customer
            association R2 Clerk 1..n--1 Department
            assigner R1 {
                identifyby Department
                state s1 {a b} {
                    puts $a $b
                }
                transition s1 - e1 -> s2

                state s2 {} {
                    puts "in s2"
                }
                transition s2 - e1 -> s1
            }
        }
    }
    relation cardinality [relvar set ::rosea::Config::MultipleAssigner]
} -result {1}
----

=== Defining Domain Operations

...............
operation name params body
...............

///////
----
<<manual domain configuration commands>>=
[call [cmd operation] [arg name] [arg parameters] [arg body]]
----
///////

[source,tcl]
----
<<domain config commands>>=
proc operation {name params body} {
    namespace upvar ::rosea::Config::DomainDef DomainName DomainName

    relvar insert ::rosea::Config::DomainElement [list\
        Domain      $DomainName\
        Element     $name\
    ]
    relvar insert ::rosea::Config::DomainOperation [list\
        Domain      $DomainName\
        Name        $name\
        Parameters  $params\
        Body        $body\
    ]
}
----

=== Defining State Models

image::config-statemodel.pdf[title="State Model Configuration Class Diagram"]

[source,tcl]
----
<<config data>>=
relvar create StateModel {
    Domain          string
    Model           string
    InitialState    string
    DefaultTrans    string
} {Domain Model}

relvar create InstanceStateModel {
    Domain          string
    Class           string
} {Domain Class}

relvar association R51\
    InstanceStateModel {Domain Class} ?\
    Class {Domain Name} 1

relvar create AssignerStateModel {
    Domain          string
    Relationship    string
} {Domain Relationship}

relvar association R52\
    AssignerStateModel {Domain Relationship} ?\
    Association {Domain Name} 1

relvar partition R50 StateModel {Domain Model}\
    InstanceStateModel {Domain Class}\
    AssignerStateModel {Domain Relationship}

relvar create SingleAssigner {
    Domain          string
    Relationship    string
} {Domain Relationship}

relvar create MultipleAssigner {
    Domain          string
    Relationship    string
    Class           string
    Number          int
} {Domain Relationship}

relvar partition R53 AssignerStateModel {Domain Relationship}\
    SingleAssigner {Domain Relationship}\
    MultipleAssigner {Domain Relationship}

relvar association R54\
    MultipleAssigner {Domain Class Number} ?\
    Identifier {Domain Class Number} 1

relvar create State {
    Domain          string
    Model           string
    Name            string
    Parameters      string
    Action          string
    IsFinal         boolean
} {Domain Model Name}

relvar association R55\
    State {Domain Model} +\
    StateModel {Domain Model} 1

relvar association R58\
    StateModel {Domain Model InitialState} ?\
    State {Domain Model Name} 1

relvar create TransitionRule {
    Name    string
} Name

relvar insert TransitionRule {Name IG} {Name CH}

relvar association R59\
    StateModel DefaultTrans *\
    TransitionRule Name 1

relvar create CreationState {
    Domain          string
    Model           string
    Name            string
} {Domain Model Name}

relvar create StatePlace {
    Domain          string
    Model           string
    Name            string
} {Domain Model Name}

relvar partition R57 StatePlace {Domain Model Name}\
    State {Domain Model Name}\
    CreationState {Domain Model Name}
----

image::config-event.pdf[title="Event Configuration Class Diagram"]

[source,tcl]
----
<<config data>>=
relvar create Event {
    Domain  string
    Model   string
    Event   string
} {Domain Model Event}

relvar create DeferredEvent {
    Domain  string
    Model   string
    Event   string
} {Domain Model Event}

relvar create EffectiveEvent {
    Domain  string
    Model   string
    Event   string
} {Domain Model Event}

relvar partition R80 Event {Domain Model Event}\
    DeferredEvent {Domain Model Event}\
    EffectiveEvent {Domain Model Event}

relvar create DeferralPath {
    Domain          string
    Model           string
    Event           string
    Relationship    string
    Role            string
} {Domain Model Event Relationship Role}

relvar correlation R86 DeferralPath\
    {Domain Model Event} + DeferredEvent {Domain Model Event}\
    {Domain Model Relationship Role} * Superclass\
        {Domain Class Relationship Role}

relvar create PolymorphicEvent {
    Domain  string
    Model   string
    Event   string
} {Domain Model Event}

relvar create InheritedEvent {
    Domain  string
    Model   string
    Event   string
} {Domain Model Event}

relvar partition R81 DeferredEvent {Domain Model Event}\
    PolymorphicEvent {Domain Model Event}\
    InheritedEvent {Domain Model Event}

relvar create MappedEvent {
    Domain      string
    Model       string
    Event       string
    ParentModel string
} {Domain Model Event}

relvar association R84\
    MappedEvent {Domain ParentModel Event} *\
    DeferredEvent {Domain Model Event} 1

relvar create LocalEvent {
    Domain  string
    Model   string
    Event   string
} {Domain Model Event}

relvar partition R82 EffectiveEvent {Domain Model Event}\
    MappedEvent {Domain Model Event}\
    LocalEvent {Domain Model Event}

relvar create NonLocalEvent {
    Domain          string
    Model           string
    Event           string
    Relationship    string
    Role            string
} {Domain Model Event}

relvar partition R83 NonLocalEvent {Domain Model Event}\
    MappedEvent {Domain Model Event}\
    InheritedEvent {Domain Model Event}

relvar association R85\
    NonLocalEvent {Domain Model Relationship Role} *\
    Subclass {Domain Class Relationship Role} 1
----

image::config-transition.pdf[title="Transitions Configuration Class Diagram"]

[source,tcl]
----
<<config data>>=
relvar create TransitionPlace {
    Domain  string
    Model   string
    State   string
    Event   string
} {Domain Model State Event}

relvar correlation R70 TransitionPlace\
    {Domain Model State} * StatePlace {Domain Model Name}\
    {Domain Model Event} * EffectiveEvent {Domain Model Event}

relvar create StateTransition {
    Domain      string
    Model       string
    State       string
    Event       string
    NewState    string
} {Domain Model State Event}

relvar create NonStateTransition {
    Domain      string
    Model       string
    State       string
    Event       string
    TransRule   string
} {Domain Model State Event}

relvar partition R71 TransitionPlace {Domain Model State Event}\
    StateTransition {Domain Model State Event}\
    NonStateTransition {Domain Model State Event}

relvar association R72\
    StateTransition {Domain Model NewState} *\
    State {Domain Model Name} 1

relvar association R73\
    NonStateTransition TransRule *\
    TransitionRule Name 1
----

[source,tcl]
----
<<state model config namespace layout>>=
namespace eval StateModelDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace import ::rosea::Config::ConfigEvaluate
    namespace import ::rosea::Helpers::DeclError

    <<state model config commands>>
}
----

///////
----
<<manual class configuration commands>>=
[call [cmd statemodel] [arg name] [arg parameters] [arg body]]
----
///////

[source,tcl]
----
<<class config commands>>=
proc statemodel {body} {
    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    variable ClassName

    namespace upvar StateModelDef\
        InitialState InitialState\
        DefaultTrans DefaultTrans\
        Terminals Terminals

    set InitialState {}
    set DefaultTrans {}
    set Terminals [list]

    try {
        ConfigEvaluate [namespace current]::StateModelDef $body

        if {$DefaultTrans eq {}} {
            set DefaultTrans CH
        }
        relvar insert ::rosea::Config::StateModel [list\
            Domain          $DomainName\
            Model           $ClassName\
            InitialState    $InitialState\
            DefaultTrans    $DefaultTrans\
        ]
        relvar insert ::rosea::Config::InstanceStateModel [list\
            Domain          $DomainName\
            Class           $ClassName\
        ]

        foreach terminal $Terminals {
            relvar updateone ::rosea::Config::State stup [list\
                    Domain $DomainName Model $ClassName Name $terminal] {
                tuple update $stup IsFinal true
            }
        }
    } on error {result opts} {
        log::error $result
        upvar #0 ::rosea::Config::errcount errcount
        incr errcount
    }
}
----

///////
----
<<manual statemodel configuration commands>>=
[call [cmd state] [arg name] [arg parameters] [arg body]]
----
///////

[source,tcl]
----
<<state model config commands>>=
proc state {name params body} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME state
    }
    if {$name in {CH IG}} {
        tailcall DeclError PSEUDO_STATE $name state
    }

    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    variable InitialState

    if {$InitialState eq {}} {
        set InitialState $name
    }

    relvar insert ::rosea::Config::State [list\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Parameters      $params\
        Action          $body\
        IsFinal         false\
    ]
    relvar insert ::rosea::Config::StatePlace [list\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
    ]
    return
}
----

///////
----
<<manual statemodel configuration commands>>=
[call [cmd transition] [arg source] [arg -] [arg event] [arg ->] [arg target]]
----
///////

[source,tcl]
----
<<state model config commands>>=
proc transition {source - event -> target} {
    if {$event eq {}} {
        tailcall DeclError EMPTY_NAME event
    }
    if {$source in {CH IG}} {
        tailcall DeclError PSEUDO_STATE $name "transition source state"
    }
    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    if {$source eq "@"} {
        if {$target in {CH IG}} {
            tailcall DeclError BAD_CREATION_TARGET $target
        }
        set cstuple [list\
            Domain          $DomainName\
            Model           $ClassName\
            Name            @\
        ]
        relvar uinsert ::rosea::Config::CreationState $cstuple
        relvar uinsert ::rosea::Config::StatePlace $cstuple
    }

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $event\
    ]
    relvar uinsert ::rosea::Config::Event $eventtuple
    relvar uinsert ::rosea::Config::EffectiveEvent $eventtuple
    relvar uinsert ::rosea::Config::LocalEvent $eventtuple

    set tranrule [relvar restrictone ::rosea::Config::TransitionRule\
        Name $target]
    set transtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        State   $source\
        Event   $event\
    ]
    relvar insert ::rosea::Config::TransitionPlace $transtuple

    if {[relation isnotempty $tranrule]} {
        lappend transtuple TransRule $target
        set tpsubtype NonStateTransition
    } else {
        lappend transtuple NewState $target
        set tpsubtype StateTransition
    }
    relvar insert ::rosea::Config::$tpsubtype $transtuple
    return
}
----

(((error code,BAD_CREATION_TARGET)))
[source,tcl]
----
<<error code formats>>=
BAD_CREATION_TARGET {the target of a creation event must be a state,\
        got "%s"}
----

///////
----
<<manual statemodel configuration commands>>=
[call [cmd initialstate] [arg name]]
----
///////

[source,tcl]
----
<<state model config commands>>=
proc initialstate {name} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME initialstate
    }
    if {$name in {CH IG}} {
        tailcall DeclError PSEUDO_STATE $name initialstate
    }
    variable InitialState $name
    return
}
----

///////
----
<<manual statemodel configuration commands>>=
[call [cmd defaulttrans] [arg "CH | IG"]]
----
///////

[source,tcl]
----
<<state model config commands>>=
proc defaulttrans {name} {
    if {$name ni {CH IG}} {
        tailcall DeclError EXPECTED_PSEUDO_STATE $name
    }
    variable DefaultTrans $name
    return
}
----

///////
----
<<manual statemodel configuration commands>>=
[call [cmd terminal] [opt [arg "state ..."]]]
----
///////

[source,tcl]
----
<<state model config commands>>=
proc terminal {args} {
    variable Terminals
    ::struct::set add Terminals $args
    return
}
----

[source,tcl]
----
<<config command tests>>=
test configure-5.0 {
    Define statemodel
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class c1 {
                attribute a1 string -id 1
                statemodel {
                    state s1 {a b} {
                        puts $a $b
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                        puts "in s2"
                    }
                    transition s2 - e1 -> s1
                }
            }
        }
    }
    relation cardinality [relvar set ::rosea::Config::StateModel]
} -result {1}
----

///////
----
<<manual class configuration commands>>=
[call [cmd polymorphic] [opt [arg "event ..."]]]
----
///////

[source,tcl]
----
<<class config commands>>=
proc polymorphic {args} {
    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName

    foreach polyevent $args {
        set eventtuple [list\
            Domain $DomainName\
            Model $ClassName\
            Event $polyevent\
        ]
        relvar insert ::rosea::Config::PolymorphicEvent $eventtuple
        relvar insert ::rosea::Config::DeferredEvent $eventtuple
        relvar insert ::rosea::Config::Event $eventtuple
    }
    return
}
----

[source,tcl]
----
<<propagate polymorphic events>>=
# Create Deferral Path instances

variable PolymorphicEvent
variable DeferredEvent
variable Superclass
variable Subclass
variable DeferralPath

set dpaths [pipe {
    relation restrictwith $PolymorphicEvent {$Domain eq $name} |
    relation semijoin ~ $DeferredEvent |
    relation join ~ $Superclass -using {Domain Domain Model Class}
}]
relvar insert ::rosea::Config::DeferralPath {*}[relation body $dpaths]
#puts [relformat $DeferralPath DeferralPath]

set supers [relation semiminus $Subclass $Superclass\
    -using {Domain Domain Class Class}]
#puts [relformat $supers supers]

relation foreach super $supers {
    PropagatePolyEvents $super
}

if {[relation isnotempty $PolymorphicEvent]} {
#puts [relformat [relvar set ::rosea::Config::Event] Event]
#puts [relformat [relvar set ::rosea::Config::DeferredEvent] DeferredEvent]
#puts [relformat [relvar set ::rosea::Config::EffectiveEvent] EffectiveEvent]
#puts [relformat [relvar set ::rosea::Config::PolymorphicEvent] PolymorphicEvent]
#puts [relformat [relvar set ::rosea::Config::InheritedEvent] InheritedEvent]
#puts [relformat [relvar set ::rosea::Config::MappedEvent] MappedEvent]
#puts [relformat [relvar set ::rosea::Config::LocalEvent] LocalEvent]
#puts [relformat [relvar set ::rosea::Config::NonLocalEvent] NonLocalEvent]
}
----

[source,tcl]
----
<<helper commands>>=
proc PropagatePolyEvents {super} {
    namespace upvar ::rosea::Config\
        DeferredEvent DeferredEvent\
        LocalEvent LocalEvent\
        Superclass Superclass\
        Subclass Subclass\
        DeferralPath DeferralPath\
        Generalization Generalization

    set subs [pipe {
        relation semijoin $super\
            $Generalization -using {Domain Domain Relationship Name}\
            $Subclass -using {Domain Domain Name Relationship}
    }]
    #puts [relformat $subs subs]

    relation foreach sub $subs {
        set defrdevents [pipe {
            relation semijoin $super $DeferralPath\
                -using {Domain Domain Class Model Relationship Relationship}\
                $DeferredEvent |
            relation update ~ deftup {1} {
                tuple update $deftup Model [relation extract $sub Class]
            }
        }]
        #puts [relformat $defrdevents defrdevents]
        set locals [relation semijoin $sub $LocalEvent\
            -using {Domain Domain Class Model}]

        set isleaf [pipe {
            relation semijoin $sub $Superclass\
                    -using {Domain Domain Class Class} |
            relation isempty ~
        }]


        if {$isleaf} {
            relvar minus ::rosea::Config::LocalEvent\
                    [relation intersect $LocalEvent $defrdevents]

            set newmapped [relation minus $defrdevents $locals]
            relvar union ::rosea::Config::Event $newmapped
            relvar union ::rosea::Config::EffectiveEvent $newmapped
            relvar union ::rosea::Config::MappedEvent [relation extend\
                $defrdevents metuple\
                ParentModel string {[relation extract $super Class]}]
        } else {
            relvar union ::rosea::Config::Event $defrdevents
            relvar union ::rosea::Config::DeferredEvent $defrdevents
            relvar union ::rosea::Config::InheritedEvent $defrdevents
            relvar union ::rosea::Config::DeferralPath [relation join\
                $defrdevents $Superclass -using {Domain Domain Model Class}]
        }
        relvar union ::rosea::Config::NonLocalEvent [relation extend\
            $defrdevents nletuple\
            Relationship string {[relation extract $sub Relationship]}\
            Role string {[relation extract $sub Role]}]

        set nextsupers [relation semijoin $sub $Superclass\
            -using {Domain Domain Class Class}]
        #puts [relformat $nextsupers nextsupers]
        relation foreach nextsuper $nextsupers {
            PropagatePolyEvents $nextsuper
        }
    }
}
----

[source,tcl]
----
<<config command tests>>=
test configure-6.0 {
    Define polymorphic events
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class S {
                attribute id string -id 1

                polymorphic e1 e2
            }
            class X {
                attribute id string -id 1
                reference R1 S -link id
            }
            class Y {
                attribute id string -id 1
                reference R1 S -link id
            }
            generalization R1 S X Y
        }
    }
    relation cardinality [relvar set ::rosea::Config::NonLocalEvent]
} -result {4}
----

[source,tcl]
----
<<config command tests>>=
test configure-6.1 {
    Define polymorphic events -- inherit across one level
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class S {
                attribute id string -id 1

                polymorphic e1 e2
            }
            class X {
                attribute id string -id 1
                reference R1 S -link id
            }
            class Y {
                attribute id string -id 1
                reference R1 S -link id
            }
            generalization R1 S X Y

            class A {
                attribute id string -id 1
                reference R2 X -link id
            }
            class B {
                attribute id string -id 1
                reference R2 X -link id
            }
            generalization R2 X A B
        }
    }
    relation cardinality [relvar set ::rosea::Config::NonLocalEvent]
} -result {8}
----

[source,tcl]
----
<<config command tests>>=
test configure-6.2 {
    Define polymorphic events -- consume in leaf subclasses
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class S {
                attribute id string -id 1

                polymorphic e1 e2
            }
            class X {
                attribute id string -id 1
                reference R1 S -link id

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            class Y {
                attribute id string -id 1
                reference R1 S -link id

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            generalization R1 S X Y
        }
    }
    relation cardinality [relvar set ::rosea::Config::MappedEvent]
} -result {4}
----

[source,tcl]
----
<<config command tests>>=
test configure-6.3 {
    Define polymorphic events -- inject polymorphic event mid-level
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class S {
                attribute id string -id 1

                polymorphic e1 e2
            }
            class X {
                attribute id string -id 1
                reference R1 S -link id

                polymorphic e3
            }
            class Y {
                attribute id string -id 1
                reference R1 S -link id
            }
            generalization R1 S X Y

            class A {
                attribute id string -id 1
                reference R2 X -link id
            }
            class B {
                attribute id string -id 1
                reference R2 X -link id
            }
            generalization R2 X A B
        }
    }
    relation cardinality [relvar set ::rosea::Config::NonLocalEvent]
} -result {10}
----

[source,tcl]
----
<<config command tests>>=
test configure-6.4 {
    Define polymorphic events -- multiple hierarchies
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class S {
                attribute id string -id 1

                polymorphic e1 e2
            }
            class X {
                attribute id string -id 1
                reference R1 S -link id
            }
            class Y {
                attribute id string -id 1
                reference R1 S -link id
            }
            generalization R1 S X Y

            class A {
                attribute id string -id 1
                reference R2 S -link id
            }
            class B {
                attribute id string -id 1
                reference R2 S -link id
            }
            generalization R2 S A B
        }
    }
    relation cardinality [relvar set ::rosea::Config::NonLocalEvent]
} -result {8}
----

[source,tcl]
----
<<config command tests>>=
test configure-6.5 {
    Define polymorphic events -- common subclass
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            class S {
                attribute id string -id 1

                polymorphic e1 e2
            }
            class X {
                attribute id string -id 1
                attribute zid string -id 2
                reference R1 S -link id
                reference R2 Z -link zid
            }
            class Y {
                attribute id string -id 1
                reference R1 S -link id
            }
            generalization R1 S X Y

            class Z {
                attribute zid string -id 1

                polymorphic e3
            }

            class A {
                attribute zid string -id 1
                reference R2 Z -link zid
            }
            generalization R2 Z A X
        }
    }
    relation cardinality [relvar set ::rosea::Config::NonLocalEvent]
} -result {6}
----

== Generating Domains

After specifying the domain using the configuration DSL,
the second step in translating a model is to generate all the
architectural data values and class and relationship ensemble commands.
In this step we set about to query to data that was accumulated during
the configuration process.
Generating the domains should happen after all the configuration is
complete.
It is allowable to invoke the +configure+ command multiple times
and domain configurations are cumulative in the sense that a configuration
script may refer to the same domain many times and the additional
configuration is simply added to any previous one.

But at some point configuration is finished and that must be followed
by an invocation of +generate+.
Unlike the +configure+ command, +generate+ should be invoked only once.

After generation is completed, there are still two more steps to complete
the translation of the XUML model, namely population and bridging.
We will discuss those steps below.

Generation is a rather complicated undertaking so we will be dividing it
up into many smaller parts to make it a little clearer what we are trying
to accomplish.
Given the relational schema used to accumulate the configuration script
information,
you can anticipate that generating the domain involves a set of
queries on that information.
In more conventional situations, _e.g._ when +pycca+ generates ``C'' source,
the results of those queries are used to generate programming language text
files which are then handed over to a language compiler.
But, since this is Tcl, we will avoid all the unnecessary intermediate
files and just execute Tcl commands directly.
This is much more in keeping with the dynamic style of Tcl.

///////
----
<<manual package commands>>=
[call [cmd "::rosea generate"] [opt [arg nsqual]] [opt [arg pattern]]]
----
///////

[source,tcl]
----
<<rosea exports>>=
namespace export generate

<<rosea commands>>=
proc generate {{prefix {}} {pattern *}} {
    if {$prefix ne {}} {
        if {[string range $prefix 0 1] ne "::"} {
            tailcall DeclError FULLY_QUALIFIED $prefix
        }
        set prefix [string trimright $prefix :]
        namespace eval $prefix {}
    }

    namespace upvar Config\
        Domain Domain\
        DomainElement DomainElement\
        Class Class\
        Attribute Attribute\
        DefaultValue DefaultValue\
        Identifier Identifier\
        IdentifyingAttribute IdentifyingAttribute\
        Relationship Relationship\
        Association Association\
        SimpleAssociation SimpleAssociation\
        SimpleReferringClass SimpleReferringClass\
        SimpleReferencedClass SimpleReferencedClass\
        ClassBasedAssociation ClassBasedAssociation\
        AssociatorClass AssociatorClass\
        SourceClass SourceClass\
        TargetClass TargetClass\
        Generalization Generalization\
        Superclass Superclass\
        Subclass Subclass\
        AttributeReference AttributeReference\
        ReferencedIdAttribute ReferencedIdAttribute\
        ReferringClass ReferringClass\
        ReferencedClass ReferencedClass\
        DomainOperation DomainOperation\
        SuppliedOperation SuppliedOperation\
        UserClassOperation UserClassOperation\
        SystemClassOperation SystemClassOperation\
        UserInstanceOperation UserInstanceOperation\
        SystemInstanceOperation SystemInstanceOperation\
        InstanceStateModel InstanceStateModel\
        StateModel StateModel\
        StatePlace StatePlace\
        State State\
        EffectiveEvent EffectiveEvent\
        DeferredEvent DeferredEvent\
        TransitionPlace TransitionPlace\
        StateTransition StateTransition\
        NonStateTransition NonStateTransition\
        AssignerStateModel AssignerStateModel\
        SingleAssigner SingleAssigner\
        MultipleAssigner MultipleAssigner

    # Query for the heading
    pipe {
        relation semijoin $class $Attribute -using {Domain Domain Name Class} |
        relation project ~ Name Type |
        relation dict ~ Name Type
    } headingQuery

    pipe {
        relation semijoin $class $Identifier -using {Domain Domain Name Class}\
                $IdentifyingAttribute |
        relation group ~ Attributes Attribute
    } idQuery

    # Iterate over all domains.
    set genDomain [relation restrictwith $Domain\
            {[string match $pattern $Domain]}]
    relation foreach domain $Domain {
        set domainName [relation extract $domain Name]
        relvar updateone Config::Domain dtup [list Name $domainName] {
            tuple update $dtup Location $prefix
        }
        set domns ${prefix}::$domainName
        # We start by creating a namespace to house the domain.
        namespace eval $domns {
            <<tclral imports>>
        }
        set archns [GenerateArchStructures $domns]

        relvar eval {
            set domops [relation semijoin $domain $DomainOperation\
                    -using {Name Domain}]
            relation foreach domop $domops {
                relation assign $domop\
                    {Name name} {Parameters parameters} {Body body}
                proc ${domns}::$name $parameters [list ral relvar eval $body]
            }

            namespace eval $domns [list\
                namespace export {*}[relation list $domops Name]\
            ]
            namespace eval $domns namespace ensemble create

            set statemodels [relation semijoin $domain $StateModel\
                -using {Name Domain}]

            # Much of the architectural data can be built in large queries
            # across the entire domain capturing the data for all the classes
            # in the domain.
            relvar union ${archns}::InitialState [pipe {
                relation project $statemodels Model InitialState |
                relation rename ~ Model Class InitialState State
            }]


            set states [relation semijoin $domain $StatePlace\
                -using {Name Domain}]
            relvar union ${archns}::State [pipe {
                relation project $states Model Name |
                relation rename ~ Model Class Name State
            }]
            relvar union ${archns}::Terminal [pipe {
                relation semijoin $domain $State -using {Name Domain} |
                relation restrict ~ termtuple\
                        {[tuple extract $termtuple IsFinal]} |
                relation project ~ Model Name |
                relation rename ~ Model Class Name State
            }]
            set events [relation semijoin $domain $EffectiveEvent\
                -using {Name Domain}]
            relvar union ${archns}::Event [pipe {
                relation project $events Model Event |
                relation rename ~ Model Class
            }]

            set alltrans [pipe {
                relation join $states $events |
                relation rename ~ Name State
            }]
            set statetrans [relation semijoin $domain $StateTransition\
                -using {Name Domain}]
            set nontrans [pipe {
                relation semijoin $domain $NonStateTransition\
                    -using {Name Domain} |
                relation rename ~ TransRule NewState
            }]
            set deftrans [pipe {
                relation minus $alltrans $TransitionPlace |
                relation join ~ $StateModel |
                relation eliminate ~ InitialState |
                relation rename ~ DefaultTrans NewState
            }]
            relvar union ${archns}::Transition [pipe {
                relation union $statetrans $nontrans $deftrans |
                relation eliminate ~ Domain |
                relation rename ~ Model Class
            }]
            #puts [relformat [relvar set ${archns}::State] State]
            #puts [relformat [relvar set ${archns}::Event] Event]
            #puts [relformat [relvar set ${archns}::Transition] Transition]

            relvar union ${archns}::PolymorphicEvent [pipe {
                relation semijoin $domain $DeferredEvent\
                    -using {Name Domain} |
                relation project ~ Model Event |
                relation rename ~ Model Class
            }]
        }

        set classes [relation semijoin $domain $DomainElement $Class]
        relation foreach class $classes {
            set className ${domns}::[relation extract $class Name]
            namespace eval $className {
                <<tclral imports>>
            }
            namespace eval $className [list namespace path\
                    [list $domns ::rosea::InstCmds]]
            # create class relvars
            set heading [eval $headingQuery]
            set ids [eval $idQuery]
            set idset [list]
            relation foreach id $ids -ascending Number {
                lappend idset [relation list\
                        [relation extract $id Attributes] Attribute]
            }
            # create the relvar
            relvar create $className $heading {*}$idset

            set defaultvalues [pipe {
                relation semijoin $class $Attribute\
                    -using {Domain Domain Name Class} |
                relation join ~ $DefaultValue\
                    -using {Domain Domain Class Class Name Attribute}
            }]
            #puts [relformat $defaultvalues defaultvalues]

            if {[relation isnotempty $defaultvalues]} {
                set defheading [relation dict $defaultvalues Name Type]
                set defvalues [relation dict $defaultvalues Name Value]
                relvar trace add variable $className insert [list\
                    ::rosea::Helpers::InsertTrace $defheading $defvalues]
            }

            # Check if we need an "instance" relvar to hold current state.
            set hasStateModel [pipe {
                relation semijoin $class $StateModel\
                    -using {Domain Domain Name Model} |
                relation isnotempty
            }]
            if {$hasStateModel} {
                set instid [lindex $idset 0]
                set instheading [list]
                foreach attr $instid {
                    lappend instheading $attr [dict get $heading $attr]
                }
                lappend instheading __State string
                relvar create\
                    ${domns}::__[relation extract $class Name]__STATEINST\
                    $instheading $instid

                set actns ${className}::__Activity
                namespace eval $actns {
                    <<tclral imports>>
                }
                namespace eval $actns [list\
                    namespace path [list\
                        ::rosea::InstCmds\
                        $className\
                        $domns\
                    ]\
                ]
                #puts "$actns path = [namespace eval $actns namespace path]"
                set states [pipe {
                    relation semijoin $class $State\
                        -using {Domain Domain Name Model} |
                    relation project ~ Name Parameters Action
                }]
                relation foreach state $states {
                    relation assign $state\
                        {Name stateName}\
                        {Parameters params}\
                        {Action stateAction}
                    set params [linsert $params 0 self]
                    proc ${actns}::$stateName $params $stateAction
                }
            }

            set opmap [dict create]
            set classops [relation semijoin $class $UserClassOperation\
                -using {Domain Domain Name Class}]
            relation foreach classop $classops {
                relation assign $classop\
                    {Name opname}\
                    {Parameters params}\
                    {Body opbody}

                set params [linsert $params 0 class]
                proc ${className}::$opname $params $opbody
                dict set opmap $opname [list ${className}::$opname\
                        $className]
            }

            set sysmap [pipe {
                relation restrictwith $SuppliedOperation\
                        {!$RequiresStateModel} |
                relation join $SystemClassOperation ~ |
                relation update ~ sco 1 {
                    tuple update $sco Command\
                        [concat [tuple extract $sco Command]\
                        [list $className]]
                } |
                relation dict ~ Name Command
            }]
            if {$hasStateModel} {
                set sysmap [dict merge $sysmap [pipe {
                    relation restrictwith $SuppliedOperation\
                        {$RequiresStateModel} |
                    relation join $SystemClassOperation ~ |
                    relation update ~ sco 1 {
                        tuple update $sco Command\
                            [concat [tuple extract $sco Command]\
                            [list $className]]
                    } |
                    relation dict ~ Name Command
                }]]
            }

            namespace ensemble create\
                -command $className\
                -map [dict merge $opmap $sysmap]

            set opmap [dict create]
            set instops [relation semijoin $class $UserInstanceOperation\
                -using {Domain Domain Name Class}]
            relation foreach instop $instops {
                relation assign $instop\
                    {Name opname}\
                    {Parameters params}\
                    {Body opbody}

                proc ${className}::$opname [linsert $params 0 self] $opbody
                dict set opmap $opname ${className}::$opname
            }
            set sysmap [pipe {
                relation restrictwith $SuppliedOperation\
                        {!$RequiresStateModel} |
                relation join $SystemInstanceOperation ~ |
                relation dict ~ Name Command
            }]
            if {$hasStateModel} {
                set sysmap [dict merge $sysmap [pipe {
                    relation restrictwith $SuppliedOperation\
                        {$RequiresStateModel} |
                    relation join $SystemInstanceOperation ~ |
                    relation dict ~ Name Command
                }]]
            }
            namespace ensemble create\
                -command ${className}::instop\
                -parameters instref\
                -map [dict merge $opmap $sysmap]
        }

        set rships [relation semijoin $domain $DomainElement $Relationship]
        set sassocs [relation semijoin $rships $Association\
                $SimpleAssociation]
        relation foreach sassoc $sassocs {
            set refing [relation semijoin $sassoc $SimpleReferringClass\
                    -using {Domain Domain Name Relationship}]
            set refed [relation semijoin $sassoc $SimpleReferencedClass\
                    -using {Domain Domain Name Relationship}]

            set reference [pipe {
                relation join $AttributeReference $refing\
                    -using {Domain Domain ReferringClass Class\
                    Relationship Relationship ReferringRole Role} |
                relation rename ~ Conditionality ReferringCond\
                        Multiplicity ReferringMult |
                relation join ~ $refed -using {Domain Domain\
                    ReferencedClass Class Relationship\
                    Relationship ReferencedRole Role} |
                relation project ~ Domain Relationship\
                    ReferringClass ReferringAttribute\
                    ReferencedClass ReferencedAttribute\
                    ReferringCond ReferringMult Conditionality |
                relation group ~ ReferringAttrs\
                        ReferringAttribute ReferencedAttribute
            }]
            #puts [relformat $reference reference]

            relation assign $reference\
                {Relationship relationship}\
                {ReferringClass referringClass}\
                {ReferencedClass referencedClass}\
                {ReferringCond referringCond}\
                {ReferringMult referringMult}\
                {Conditionality referencedCond}\
                {ReferringAttrs referringAttrs}
            set attrrefs [relation tag $referringAttrs RefOrder]
            #puts [relformat $attrrefs attrrefs]
            set srcattrs [relation list $attrrefs ReferringAttribute\
                    -ascending RefOrder]
            set destattrs [relation list $attrrefs ReferencedAttribute\
                    -ascending RefOrder]
            lassign [WeaveLists $srcattrs $destattrs] forwattrs revattrs

            relvar association ${domns}::$relationship\
                 ${domns}::$referringClass $srcattrs\
                [MapCondMultToConstraint $referringCond $referringMult]\
                ${domns}::$referencedClass $destattrs\
                [MapCondMultToConstraint $referencedCond false]

            relvar eval {
                relvar insert ${archns}::Link [list\
                    Name        $relationship\
                    SrcClass    $referringClass\
                ]
                relvar insert ${archns}::AssociationLink [list\
                    Name            $relationship\
                    SrcClass        $referringClass\
                    DstClass        $referencedClass\
                    Attrs   $forwattrs\
                    PrevSrcClass    {}\
                ]
                relvar insert ${archns}::Link [list\
                    Name        ~$relationship\
                    SrcClass    $referencedClass\
                ]
                relvar insert ${archns}::AssociationLink [list\
                    Name            ~$relationship\
                    SrcClass        $referencedClass\
                    DstClass        $referringClass\
                    Attrs           $revattrs\
                    PrevSrcClass    {}\
                ]
                relvar insert ${archns}::RefLink [list\
                    Relationship    $relationship\
                    ReferringClass  $referringClass\
                    ReferencedClass $referencedClass\
                    ReferringAttrs  $referringAttrs\
                ]
            }

            set rpath ${domns}::$relationship
            set ensemblemap [dict create\
                link [list ::rosea::RelCmds::linkSimple $relationship]\
                unlink [list ::rosea::RelCmds::unlinkSimple $relationship]\
            ]
            # Determine if we have any assigners
            set assigner [relation semijoin $sassoc $SingleAssigner\
                -using {Domain Domain Name Relationship}]
            if {[relation isnotempty $assigner]} {
                dict set ensemblemap signal\
                    [list ::rosea::RelCmds::signalAssigner $rpath]
            } else {
                set assigner [relation semijoin $sassoc $MultipleAssigner\
                    -using {Domain Domain Name Relationship}]
                if {[relation isnotempty $assigner]} {
                    dict set ensemblemap signal [list\
                        ::rosea::RelCmds::signalMultiAssigner $rpath]
                    dict set ensemblemap create [list\
                        ::rosea::RelCmds::createMultiAssigner $rpath]
                }
            }
            namespace ensemble create -command $rpath -map $ensemblemap
        }

        set cassocs [relation semijoin $rships $Association\
                $ClassBasedAssociation]
        relation foreach cassoc $cassocs {
            set sourceclass [relation semijoin $cassoc $SourceClass\
                -using {Domain Domain Name Relationship}]
            set targetclass [relation semijoin $cassoc $TargetClass\
                -using {Domain Domain Name Relationship}]

            set assocrefs [pipe {
                relation semijoin $cassoc $AssociatorClass\
                        -using {Domain Domain Name Relationship}\
                    $ReferringClass $AttributeReference\
                        -using {Domain Domain Class ReferringClass\
                        Relationship Relationship Role ReferringRole} |
                relation project ~ Domain ReferringClass ReferringAttribute\
                    ReferencedClass ReferencedAttribute ReferencedRole\
                    Relationship |
                relation join ~ [relation union $sourceclass $targetclass]\
                        -using {Domain Domain Relationship Relationship\
                        ReferencedClass Class ReferencedRole Role} |
                relation group ~ ReferringAttrs\
                        ReferringAttribute ReferencedAttribute |
                relation group ~ References ReferencedClass ReferencedRole\
                        Conditionality Multiplicity ReferringAttrs

            }]
            #puts [relformat $assocrefs assocrefs]

            relation foreach assocref $assocrefs {
                relation assign $assocref\
                    {ReferringClass associator}\
                    {Relationship relationship}\
                    {References references}
                set assoclinks [relation create\
                    {Participant string Role string\
                    ReferringAttrs {Relation {ReferringAttribute string\
                        ReferencedAttribute string}}}]
                relation foreach reference $references {
                    relation assign $reference\
                        {ReferencedClass referencedClass}\
                        {ReferencedRole referencedRole}\
                        {Conditionality conditionality}\
                        {Multiplicity multiplicity}\
                        {ReferringAttrs referringAttrs}

                    set attrrefs [relation tag $referringAttrs RefOrder]
                    set assocattrs($referencedRole)\
                        [relation list $attrrefs ReferringAttribute\
                            -ascending RefOrder]
                    set refattrs($referencedRole)\
                        [relation list $attrrefs ReferencedAttribute\
                            -ascending RefOrder]
                    set multcond($referencedRole)\
                        [MapCondMultToConstraint $conditionality\
                            $multiplicity]
                    set refclass($referencedRole) $referencedClass

                    set assoclinks [relation insert $assoclinks [list\
                        Participant $refclass($referencedRole)\
                        Role $referencedRole\
                        ReferringAttrs $referringAttrs\
                    ]]
                }

                relvar correlation ${domns}::$relationship\
                    ${domns}::$associator\
                    $assocattrs(source) $multcond(target)\
                        ${domns}::$refclass(source) $refattrs(source)\
                    $assocattrs(target) $multcond(source)\
                        ${domns}::$refclass(target) $refattrs(target)

                lassign [WeaveLists $refattrs(source) $assocattrs(source)]\
                    forwattrs revattrs
                relvar eval {
                    relvar insert ${archns}::Link [list\
                        Name    $relationship\
                        SrcClass   $refclass(source)\
                    ]
                    relvar insert ${archns}::AssociationLink [list\
                        Name            $relationship\
                        SrcClass        $refclass(source)\
                        DstClass        $associator\
                        Attrs           $forwattrs\
                        PrevSrcClass    {}\
                    ]
                    relvar insert ${archns}::Link [list\
                        Name        ~$relationship\
                        SrcClass    $associator\
                    ]
                    relvar insert ${archns}::AssociationLink [list\
                        Name            ~$relationship\
                        SrcClass        $associator\
                        DstClass        $refclass(source)\
                        Attrs   $revattrs\
                        PrevSrcClass    $refclass(target)\
                    ]
                    relvar insert ${archns}::AssocRef [list\
                        Relationship    $relationship\
                        AssocClass      $associator\
                        References      $assoclinks\
                    ]

                    lassign [WeaveLists $refattrs(target) $assocattrs(target)]\
                        forwattrs revattrs
                    relvar insert ${archns}::Link [list\
                        Name        $relationship\
                        SrcClass    $associator\
                    ]
                    relvar insert ${archns}::AssociationLink [list\
                        Name            $relationship\
                        SrcClass        $associator\
                        DstClass        $refclass(target)\
                        Attrs   $revattrs\
                        PrevSrcClass    $refclass(source)\
                    ]
                    relvar insert ${archns}::Link [list\
                        Name        ~$relationship\
                        SrcClass    $refclass(target)\
                    ]
                    relvar insert ${archns}::AssociationLink [list\
                        Name            ~$relationship\
                        SrcClass        $refclass(target)\
                        DstClass        $associator\
                        Attrs   $forwattrs\
                        PrevSrcClass    {}\
                    ]
                }
            }

            set rpath ${domns}::$relationship
            set ensemblemap [dict create\
                link [list ::rosea::RelCmds::linkAssoc $relationship]\
                unlink [list ::rosea::RelCmds::unlinkAssoc $relationship]\
            ]
            # Determine if we have any assigners
            set assigner [relation semijoin $cassoc $SingleAssigner\
                -using {Domain Domain Name Relationship}]
            if {[relation isnotempty $assigner]} {
                dict set ensemblemap signal\
                    [list ::rosea::RelCmds::signalAssigner $rpath]
            } else {
                set assigner [relation semijoin $cassoc $MultipleAssigner\
                    -using {Domain Domain Name Relationship}]
                if {[relation isnotempty $assigner]} {
                    dict set ensemblemap signal [list\
                        ::rosea::RelCmds::signalMultiAssigner $rpath]
                    dict set ensemblemap create [list\
                        ::rosea::RelCmds::createMultiAssigner $rpath]
                }
            }
            namespace ensemble create -command $rpath -map $ensemblemap
        }

        set gens [relation semijoin $rships $Generalization]
        relation foreach gen $gens {
            set subrefs [pipe {
                relation semijoin $gen $Subclass\
                        -using {Domain Domain Name Relationship}\
                    $ReferringClass $AttributeReference\
                        -using {Domain Domain Class ReferringClass\
                        Relationship Relationship Role ReferringRole} |
                relation project ~ Domain ReferringClass ReferringAttribute\
                    ReferencedClass ReferencedAttribute Relationship |
                relation group ~ ReferringAttrs\
                        ReferringAttribute ReferencedAttribute
            }]
            #puts [relformat $subrefs subrefs]

            set subparts [list]
            relation foreach subref $subrefs {
                relation assign $subref\
                    {ReferringClass subclass}\
                    {ReferencedClass superclass}\
                    {Relationship relationship}\
                    {ReferringAttrs referringAttrs}

                set attrrefs [relation tag $referringAttrs RefOrder]
                set subattrs [relation list $attrrefs ReferringAttribute\
                        -ascending RefOrder]
                set superattrs [relation list $attrrefs ReferencedAttribute\
                        -ascending RefOrder]
                lassign [WeaveLists $subattrs $superattrs]\
                        forwattrs revattrs

                lappend subparts ${domns}::$subclass $subattrs

                relvar eval {
                    relvar insert ${archns}::Link [list\
                        Name        $relationship\
                        SrcClass    $subclass\
                    ]
                    relvar insert ${archns}::AssociationLink [list\
                        Name            $relationship\
                        SrcClass        $subclass\
                        DstClass        $superclass\
                        Attrs           $forwattrs\
                        PrevSrcClass    {}\
                    ]
                    # Here!! need to figure out how to get rid of the uinserts
                    relvar uinsert ${archns}::Link [list\
                        Name        ~$relationship\
                        SrcClass    $superclass\
                    ]
                    relvar uinsert ${archns}::PartitionLink [list\
                        Name        ~$relationship\
                        SrcClass    $superclass\
                    ]
                    relvar insert ${archns}::PartitionDst [list\
                        Name        ~$relationship\
                        SrcClass    $superclass\
                        DstClass    $subclass\
                        Attrs   $revattrs\
                    ]
                    relvar uinsert ${archns}::SuperLink [list\
                        Relationship    $relationship\
                        SuperClass      $superclass\
                    ]
                    relvar insert ${archns}::SubLink [list\
                        Relationship    $relationship\
                        SubClass        $subclass\
                        ReferringAttrs  $referringAttrs\
                    ]
                }
            }

            relvar partition ${domns}::$relationship ${domns}::$superclass\
                    $superattrs {*}$subparts
            namespace ensemble create\
                -command ${domns}::$relationship\
                -map [dict create migrate [list ::rosea::RelCmds::migrate\
                        $relationship]]
        }

        set assigners [relation semijoin $domain $AssignerStateModel\
                -using {Name Domain}]
        relation foreach assigner $assigners {
            set asgnns\
                ${domns}::[relation extract $assigner Relationship]::__Activity
            namespace eval $asgnns {
                <<tclral imports>>
            }
            namespace eval $asgnns [list\
                namespace path [list\
                    ::rosea::InstCmds\
                    $domns\
                ]\
            ]
            set states [pipe {
                relation semijoin $assigner $State\
                    -using {Domain Domain Relationship Model} |
                relation project ~ Name Parameters Action
            }]
            relation foreach state $states {
                relation assign $state\
                    {Name stateName}\
                    {Parameters params}\
                    {Action stateAction}
                set params [linsert $params 0 self]
                proc ${asgnns}::$stateName $params $stateAction
            }
        }

        relation foreach sassigner\
                [relation semijoin $domain $SingleAssigner\
                -using {Name Domain}] {
            relation assign $sassigner {Relationship relationship}
            relvar create ${domns}::__${relationship}__STATEINST {
                Id      int
                __State string
            } Id
            CreateInInitialState $domns $relationship {Id 0}
        }

        relation foreach massigner\
                [relation semijoin $domain $MultipleAssigner\
                -using {Name Domain}] {
            relation assign $massigner {Relationship relationship}
            set assignvar ${domns}::__${relationship}__STATEINST

            set idattrs [pipe {
                relation semijoin $massigner $Identifier\
                    $IdentifyingAttribute\
                    $Attribute -using {Domain Domain Class Class\
                        Attribute Name} |
                relation dict ~ Name Type
            }]
            relvar create $assignvar\
                [concat $idattrs [list __State string]]\
                [dict keys $idattrs]
        }
    }
    #puts [relformat [relvar set ${archns}::Link] Link]
    #puts [relformat [relvar set ${archns}::AssociationLink] AssociationLink]
    #puts [relformat [relvar set ${archns}::PartitionLink] PartitionLink]
    #puts [relformat [relvar set ${archns}::PartitionDst] PartitionDst]
    #puts [relformat [relvar set ${archns}::RefLink] RefLink]
    #puts [relformat [relvar set ${archns}::AssocRef] AssocRef]
    #puts [relformat [relvar set ${archns}::SuperLink] SuperLink]
    #puts [relformat [relvar set ${archns}::SubLink] SubLink]
}
----

(((error code,FULLY_QUALIFIED)))
[source,tcl]
----
<<error code formats>>=
FULLY_QUALIFIED {fully qualified namespace required, got "%s"}
----

[source,tcl]
----
<<helper commands>>=
proc MapCondMultToConstraint {cond mult} {
    if {$cond && $mult} {
        return *
    } elseif {$cond && !$mult} {
        return ?
    } elseif {!$cond && $mult} {
        return +
    } elseif {!($cond || $mult)} {
        return 1
    }
}

proc Interleave {l1 l2} {
    set result [list]
    foreach a $l1 b $l2 {
        lappend result $a $b
    }
    return $result
}

proc WeaveLists {l1 l2} {
    tailcall list [Interleave $l1 $l2] [Interleave $l2 $l1]
}
----

[source,tcl]
----
<<helper commands>>=
proc InsertTrace {defheading defvalues op relvar tuple} {
    tuple create\
        [dict merge $defheading [tuple heading $tuple]]\
        [dict merge $defvalues [tuple get $tuple]]
}
----

[source,tcl]
----
<<config command tests>>=
test generate-1.0 {
    Generate domain relvars
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class X {
                attribute x1 string -id 1
                attribute x2 string -default 20
            }
            class Y {
                attribute y1 string -id 1
            }
        }
    }
    rosea generate
    set rvnames [relvar names ::foo::*]
    expr {"::foo::X" in $rvnames && "::foo::Y" in $rvnames}
} -result {1}
----

[source,tcl]
----
<<test utility procs>>=
proc removeDomain {domns} {
    relvar constraint delete {*}[relvar constraint names ${domns}::*]
    relvar unset {*}[relvar names ${domns}::*]
    namespace delete $domns
    set ::rosea::Dispatch::event_queue [list]
}
----

[source,tcl]
----
<<config command tests>>=
test generate-1.1 {
    Generate domain relvars -- multiple identifiers
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class X {
                attribute x1 string -id 1
                attribute y1 string -id 1
                attribute z1 int -id 2
                attribute x2 string -default 20
            }
        }
    }
    rosea generate
    relvar identifiers ::foo::X
} -result {{x1 y1} z1}
----

[source,tcl]
----
<<config command tests>>=
test generate-2.0 {
    generate constraints for simple associative relationshp
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class x {
                attribute a1 string -id 1
                attribute a2 string -default 20
            }
            class y {
                attribute a1 string -id 1
                reference R1 x -link a1
            }
            association R1 y 1--1 x
        }
    }
    rosea generate
    relvar constraint info ::foo::R1
} -result {association ::foo::R1 ::foo::y a1 1 ::foo::x a1 1}
----

[source,tcl]
----
<<config command tests>>=
test generate-2.1 {
    Simple association -- bad class
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            association R1 y 1--1 x
        }
    }
    rosea generate
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test generate-2.2 {
    Simple association -- need associator
} -setup {
} -cleanup {
    cleanupConfigData
} -body {
    rosea configure {
        domain foo {
            association R1 y 1..n--1..n x
        }
    }
    rosea generate
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test generate-3.0 {
    generate constraints for class based associative relationship
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class a {
                attribute ax1 string -id 1
                attribute ax2 string -id 1
                attribute ay1 string -id 1
                attribute ay2 string -id 1
                reference R1 x -link {ax1 x1} -link {ax2 x2}
                reference R1 y -link {ay1 y1} -link {ay2 y2}
            }
            class x {
                attribute x1 string -id 1
                attribute x2 string -id 1
                attribute x3 string -default 20
            }
            class y {
                attribute y1 string -id 1
                attribute y2 string -id 1
            }
            association R1 x 0..n--1..n y -associator a
        }
    }
    rosea generate
    relvar constraint info ::foo::R1
} -result {correlation ::foo::R1 ::foo::a {ax1 ax2} + ::foo::x {x1 x2} {ay1 ay2} * ::foo::y {y1 y2}}
----

[source,tcl]
----
<<config command tests>>=
test generate-3.1 {
    class based association when simple would do
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class a {
                attribute x1 string -id 1
                attribute y1 string
                reference R2 x -link x1
                reference R2 y -link y1
            }
            class x {
                attribute x1 string -id 1
                attribute x2 int -default 20
            }
            class y {
                attribute y1 string -id 1
                attribute y2 string -default bar
            }
            association R2 x 0..n--1 y -associator a
        }
    }
    rosea generate
    relvar constraint info ::foo::R2
} -result {correlation ::foo::R2 ::foo::a x1 1 ::foo::x x1 y1 * ::foo::y y1}
----

[source,tcl]
----
<<config command tests>>=
test generate-3.2 {
    generate constraints for reflexive class based associative relationshp
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class A {
                attribute xid string -id 1
                attribute next_xid string -id 1
                reference R1 X -link xid -link {next_xid xid}
            }
            class X {
                attribute xid string -id 1
                attribute value string -default 20
            }
            association R1 X 0..n--0..n X -associator A -path {xid next_xid}
        }
    }
    rosea generate
    relvar constraint info ::foo::R1
} -result {correlation ::foo::R1 ::foo::A xid * ::foo::X xid next_xid * ::foo::X xid}
----

[source,tcl]
----
<<config command tests>>=
test generate-4.0 {
    generate constraints for generalization relationship
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class super {
                attribute s1 string -id 1
                attribute s2 string -id 1
                attribute a2 string -default 20
            }
            class sub1 {
                attribute sb1 string -id 1
                attribute sb2 string -id 1
                reference R1 super -link {sb1 s1} -link {sb2 s2}
            }
            class sub2 {
                attribute sb3 string -id 1
                attribute sb4 string -id 1
                reference R1 super -link {sb3 s1} -link {sb4 s2}
            }
            generalization R1 super sub1 sub2
        }
    }
    rosea generate
    relvar constraint info ::foo::R1
} -result {partition ::foo::R1 ::foo::super {s1 s2} ::foo::sub2 {sb3 sb4} ::foo::sub1 {sb1 sb2}}
----

[source,tcl]
----
<<config command tests>>=
test generate-4.1 {
    migrate subclass
} -setup {
    rosea configure {
        domain foo {
            class S {
                attribute s1 string -id 1
                attribute s2 string -id 1
                attribute a2 int -default 20
            }
            class X {
                attribute x1 string -id 1
                attribute x2 string -id 1
                reference R1 S -link {x1 s1} -link {x2 s2}
            }
            class Y {
                attribute y1 string -id 1
                attribute y2 string -id 1
                reference R1 S -link {y1 s1} -link {y2 s2}
            }
            generalization R1 S X Y
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    relvar eval {
        foo::S create s1 a s2 b
        foo::X create x1 a x2 b
    }
    set ref [foo::X findWhere {$x1 eq "a"}]
    foo::R1 migrate $ref Y
} -result {::foo::Y {{y1 string y2 string} {{y1 a y2 b}}}} -match ref
----

[source,tcl]
----
<<config command tests>>=
test generate-4.2 {
    compound generalization
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::grocer
} -body {
    rosea configure {
        domain grocer {
            class Fruit {
                attribute Name string -id 1
                attribute Color string
            }
            class SeededFruit {
                attribute Name string -id 1
                reference R1 Fruit -link Name
            }
            class UnseededFruit {
                attribute Name string -id 1
                reference R1 Fruit -link Name
            }
            generalization R1 Fruit SeededFruit UnseededFruit

            class StoneFruit {
                attribute Name string -id 1
                reference R2 SeededFruit -link Name
            }
            class PitFruit {
                attribute Name string -id 1
                attribute PitSize int -default 10
                reference R2 SeededFruit -link Name
            }
            generalization R2 SeededFruit StoneFruit PitFruit
        }
    }
    rosea generate
    relvar eval {
        set ref [::grocer::Fruit create Name apple Color red]
        ::grocer::SeededFruit create Name apple
        ::grocer::PitFruit create Name apple PitSize 30
    }
    set pit [::rosea::InstCmds::findRelated $ref\
            {~R1 SeededFruit} {~R2 PitFruit}]
    ::rosea::InstCmds::readAttribute $pit PitSize
} -result {30}
----

[source,tcl]
----
<<config command tests>>=
test generate-5.0 {
    generate class based operations
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea configure {
        domain foo {
            class c1 {
                attribute a1 string -id 1
                attribute a2 string

                classop echo {id} {
                    return $id
                }
            }
        }
    }
    rosea generate
    ::foo::c1 echo 27
} -result {27}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.0 {
    generate multiple classes and relationships, navigate
} -setup {
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    rosea configure {
        domain meta {
            class Class {
                attribute Domain string -id 1
                attribute Name string -id 1
            }

            class Attribute {
                attribute Domain string -id 1
                attribute Class string -id 1
                attribute Name string -id 1
                attribute Type string

                reference R3 Class -link Domain -link {Class Name}
            }
            association R3 Attribute 1..n--1 Class

            operation showAttrs {class} {
                set c1 [Class findWhere\
                        {$Domain eq "foo" && $Name eq $class}]
                set attrs [Class::instop $c1 findRelated ~R3]
                return [Attribute::instop $attrs deRef]
            }
        }
    }
    rosea generate
    relvar eval {
        meta::Class create Domain foo Name c1
        meta::Attribute create Domain foo Class c1 Name a1 Type string
        meta::Attribute create Domain foo Class c1 Name a2 Type string
    }
    meta::showAttrs c1
} -result {{Domain string Class string Name string Type string} {{Domain foo Class c1 Name a1 Type string} {Domain foo Class c1 Name a2 Type string}}}\
    -match relation
----

[source,tcl]
----
<<config command tests>>=
test generate-6.1 {
    generate multiple classes and a relationship, link instances together
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 1..n--1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    relvar eval {
        set c1 [meta::C1 create Id foo A1 20]
        meta::C2 create Id bar C1Id {}
        meta::C2 create Id baz C1Id {}
        set c2 [meta::C2 create Id fub C1Id {}]
        meta::R1 link $c1 [meta::C2 findAll]
    }
    #puts [relformat [relvar set ::meta::C2] C2]
    rosea::InstCmds::readAttribute $c2 C1Id
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.2 {
    generate multiple classes and a relationship, unlink instances
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 0..n--0..1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    relvar eval {
        set c1 [meta::C1 create Id foo A1 20]
        meta::C2 create Id bar C1Id foo
        meta::C2 create Id baz C1Id foo
        set c2 [meta::C2 create Id fub C1Id foo]
    }
    meta::R1 unlink [meta::C2 findWhere {[string match b* $Id]}]
    #puts [relformat [relvar set ::meta::C2] C2]
    rosea::InstCmds::readAttribute $c2 C1Id
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.3 {
    generate multiple classes and a relationship, unlink by referred to instance
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 0..n--0..1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    relvar eval {
        set c1 [meta::C1 create Id foo A1 20]
        meta::C2 create Id bar C1Id foo
        meta::C2 create Id baz C1Id foo
        set c2 [meta::C2 create Id fub C1Id foo]
    }
    meta::R1 unlink $c1
    #puts [relformat [relvar set ::meta::C2] C2]
    rosea::InstCmds::readAttribute $c2 C1Id
} -result {}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.4 {
    generate class-based association and link instances
} -setup {
    rosea configure {
        domain foo {
            class A {
                attribute ax1 string -id 1
                attribute ax2 string -id 1
                attribute ay1 string -id 1
                attribute ay2 string -id 1
                reference R1 X -link {ax1 x1} -link {ax2 x2}
                reference R1 Y -link {ay1 y1} -link {ay2 y2}
            }
            class X {
                attribute x1 string -id 1
                attribute x2 string -id 1
                attribute x3 int
            }
            class Y {
                attribute y1 string -id 1
                attribute y2 string -id 1
                attribute y3 int
            }
            association R1 X 1..n--1..n Y -associator A
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    relvar eval {
        ::foo::X create x1 x1-1 x2 x2-1 x3 27
        ::foo::X create x1 x1-2 x2 x2-2 x3 47
        ::foo::Y create y1 y1-1 y2 y2-1 y3 57
        ::foo::Y create y1 y1-2 y2 y2-2 y3 67

        set assoc [::foo::R1 link [::foo::X findAll] [::foo::Y findAll]]
    }
    #puts [relformat [relvar set ::foo::A] A]
    ::rosea::InstCmds::refMultiplicity $assoc
} -result {4}
----

[source,tcl]
----
<<config command tests>>=
test generate-6.5 {
    generate class-based association and unlink instances
} -setup {
    rosea configure {
        domain foo {
            class A {
                attribute ax1 string -id 1
                attribute ax2 string -id 1
                attribute ay1 string -id 1
                attribute ay2 string -id 1
                reference R1 X -link {ax1 x1} -link {ax2 x2}
                reference R1 Y -link {ay1 y1} -link {ay2 y2}
            }
            class X {
                attribute x1 string -id 1
                attribute x2 string -id 1
                attribute x3 int
            }
            class Y {
                attribute y1 string -id 1
                attribute y2 string -id 1
                attribute y3 int
            }
            association R1 X 0..n--0..n Y -associator A
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    relvar eval {
        ::foo::X create x1 x1-1 x2 x2-1 x3 27
        ::foo::X create x1 x1-2 x2 x2-2 x3 47
        ::foo::Y create y1 y1-1 y2 y2-1 y3 57
        ::foo::Y create y1 y1-2 y2 y2-2 y3 67
    }
    set assoc [::foo::R1 link [::foo::X findAll] [::foo::Y findAll]]
    ::foo::R1 unlink [::foo::X findAll]
    relation cardinality [relvar set ::foo::A]
} -result {0}
----

[source,tcl]
----
<<config command tests>>=
test generate-7.0 {
    Classes with state models
} -setup {
    rosea configure {
        domain foo {
            class Dog {
                attribute Name string -id 1
                attribute Breed string

                statemodel {
                    state Born {} {
                        puts "In Born"
                    }
                    state Grown {} {
                        puts "In Grown"
                        delaysignal 200 $self Time
                    }
                    state Old {} {
                        puts "In Old"
                        delaysignal 200 $self Time
                    }
                    state Dead {} {
                        puts "In Dead"
                        set ::done 1
                    }
                    terminal Dead

                    transition Born - Time -> Grown
                    transition Grown - Time -> Old
                    transition Old - Time -> Dead
                }
            }
            class Owner {
                attribute Name string -id 1
            }
            class Ownership {
                attribute DogName string -id 1
                attribute OwnerName string -id 1
                attribute Aquired string

                reference R1 Dog -link {DogName Name}
                reference R1 Owner -link {OwnerName Name}
            }
            association R1 Dog 0..n--0..n Owner -associator Ownership
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    set ref [::foo::Dog create Name fido Breed mutt]

    ::rosea::InstCmds::signal $ref Time
    set timer [after 1000 set ::done TIMEOUT]
    vwait ::done
    after cancel $timer
    set ::done
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test generate-8.0 {
    signal an assigner
} -setup {
    rosea configure {
        domain foo {
            class Customer {
                attribute Name string -id 1
            }
            class Clerk {
                attribute Name string -id 1
                attribute Customer string
                reference R1 Customer -link {Customer Name}
            }
            association R1 Clerk 0..1--0..1 Customer
            assigner R1 {
                state s1 {a b} {
                    puts $a $b
                }
                transition s1 - e1 -> s2

                state s2 {} {
                    puts "in s2"
                        set ::done 1
                }
                transition s2 - e1 -> s1
            }
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    ::foo::R1 signal e1
    set timer [after 1000 set ::done TIMEOUT]
    vwait ::done
    after cancel $timer
    set ::done
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test generate-8.1 {
    signal a multi assigner
} -setup {
    rosea configure {
        domain foo {
            class Customer {
                attribute Name string -id 1
            }
            class Clerk {
                attribute Name string -id 1
                attribute Customer string
                attribute Department string
                reference R1 Customer -link {Customer Name}
                reference R2 Department -link {Department Name}
            }
            class Department {
                attribute Name string -id 1
            }
            association R1 Clerk 0..1--0..1 Customer
            association R2 Clerk 1..n--1 Department
            assigner R1 {
                identifyby Department
                state s1 {a b} {
                    puts $a $b
                }
                transition s1 - e1 -> s2

                state s2 {} {
                    puts "in s2"
                        set ::done 1
                }
                transition s2 - e1 -> s1
            }
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    ::foo::R1 create Name Shoes
    ::foo::R1 signal {Name Shoes} e1
    set timer [after 1000 set ::done TIMEOUT]
    vwait ::done
    after cancel $timer
    set ::done
} -result {1}
----

=== Structuring Architectural Data

image::arch-class-diagram.pdf[title="Class State Model Architecture Date"]

image::link-classes.pdf[title="Class Linkage Architecture Data"]

[source,tcl]
----
<<rosea commands>>=
proc GenerateArchStructures {domns} {
    set archns ${domns}::__Arch
    namespace eval ${archns} {
        ral relvar create State {
            Class string
            State string
        } {Class State}
        ral relvar create Event {
            Class string
            Event string
        } {Class Event}
        ral relvar create Transition {
            Class string
            State string
            Event string
            NewState string
        } {Class State Event}
        ral relvar correlation R1 Transition\
            {Class State} + State {Class State}\
            {Class Event} + Event {Class Event}
        ral relvar create InitialState {
            Class string
            State string
        } Class
        ral relvar association R6\
            InitialState {Class State} ?\
            State {Class State} 1
        ral relvar create Terminal {
            Class string
            State string
        } {Class State}
        ral relvar create PolymorphicEvent {
            Class           string
            Event           string
        } {Class Event}
        ral relvar create Link {
            Name            string
            SrcClass        string
        } {Name SrcClass}
        ral relvar create AssociationLink {
            Name            string
            SrcClass        string
            DstClass        string
            Attrs           list
            PrevSrcClass    string
        } {Name SrcClass}
        ral relvar association R4\
            AssociationLink {Name PrevSrcClass} ?\
            AssociationLink {Name SrcClass} ?
        ral relvar create PartitionLink {
            Name            string
            SrcClass        string
        } {Name SrcClass}
        ral relvar partition R3 Link {Name SrcClass}\
            AssociationLink {Name SrcClass}\
            PartitionLink {Name SrcClass}
        ral relvar create PartitionDst {
            Name            string
            SrcClass        string
            DstClass        string
            Attrs           list
        } {Name SrcClass DstClass}
        ral relvar association R2\
            PartitionDst {Name SrcClass} +\
            PartitionLink {Name SrcClass} 1
        ral relvar create SuperLink {
            Relationship    string
            SuperClass      string
        } Relationship
        ral relvar create SubLink {
            Relationship    string
            SubClass        string
            ReferringAttrs  {Relation {ReferringAttribute string\
                            ReferencedAttribute string}}
        } {Relationship SubClass}
        ral relvar association R5\
            SubLink Relationship +\
            SuperLink Relationship 1
        ral relvar create RefLink {
            Relationship    string
            ReferringClass  string
            ReferencedClass string
            ReferringAttrs  {Relation {ReferringAttribute string\
                                ReferencedAttribute string}}
        } Relationship
        ral relvar create AssocRef {
            Relationship    string
            AssocClass      string
            References      {Relation {Participant string Role string\
                    ReferringAttrs {Relation\
                    {ReferringAttribute string ReferencedAttribute string}}}}
        } Relationship
    }

    return $archns
}
----

== Populating Domains

The third important step in translating an XUML domain is to establish
an initial instance population.
If you consider the evolution of the domain over time,
the initial instance population sets the values of attributes
at time zero.
This is analogous to specifying the initial state of a state machine.
Then at each transaction in the processing,
the domain data moves from one valid state to another as enforced by
the integrity constraints of the underlying relvars.

One of the great benefits of using TclRAL relvars as the basis of the
data architecture is the instance population of the domain can be
established by specifying attribute values alone.
Attributes values and relationship linkage is established by setting
values in a declarative way.
Now it is possible to execute a series of +create+ and +link+ commands
to establish the initial instance population in much the same way as
class instances are dealt with at run-time.
However, this implies writing potentially long sequences of code.
The +populate+ command will allow you to specify attribute values and
the implied relationship linkages in data organized as tables that
correspond exactly to the class diagram.
It is not unusual to with to maintain many populations for a domain.
Often testing will use a different initial population than the delivered
system.
Population scripts can be stored in files and the system build mechanism
can choose the desired initial instance population.

///////
----
<<manual package commands>>=
[call [cmd "::rosea populate"] [arg script]]
----
///////

[source,tcl]
----
<<rosea exports>>=
namespace export populate

<<rosea commands>>=
proc populate {script} {
    namespace upvar Config errcount errcount configlineno configlineno
    set errcount 0
    set configlineno 1
    try {
        relvar eval {
            ConfigEvaluate ::rosea::Populate $script
        }
    } on error {result} {
        log::error $result
        incr errcount
    }
    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----

///////
----
<<manual package commands>>=
[call [cmd "::rosea populateFromFile"] [arg filename]]
----
///////

[source,tcl]
----
<<rosea exports>>=
namespace export populateFromFile

<<rosea commands>>=
proc populateFromFile {filename} {
    set f [::open $filename r]
    try {
        populate [read $f]
    } finally {
        ::chan close $f
    }
}
----

[source,tcl]
----
<<population commands namespace>>=
namespace eval Populate {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace import ::rosea::Config::ConfigEvaluate
    namespace import ::rosea::Helpers::DeclError
    <<populate commands>>
    <<domain population namespace layout>>
}
----

///////
----
<<manual populate commands>>=
[call [cmd domain] [arg name] [arg script]]
----
///////

[source,tcl]
----
<<populate commands>>=
proc domain {name body} {
    set domain [relvar restrictone ::rosea::Config::Domain Name $name]
    if {[relation isempty $domain]} {
        tailcall DeclError UNKNOWN_DOMAIN $domain
    }

    namespace upvar DomainPop DomainName DomainName DomainLoc DomainLoc
    relation assign $domain {Name DomainName} {Location DomainLoc}

    try {
        ConfigEvaluate [namespace current]::DomainPop $body
    } on error {result opts} {
        log::error $result
        upvar #0 ::rosea::Config::errcount errcount
        incr errcount
    }
}
----

[source,tcl]
----
<<domain population namespace layout>>=
namespace eval DomainPop {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path ::rosea::Helpers
    <<domain populate commands>>
}
----

///////
----
<<manual populate commands>>=
[call [cmd class] [arg heading] [arg values]]
----
///////

[source,tcl]
----
<<domain populate commands>>=
proc class {class heading args} {
    # Determine if we have one big list or a bunch of values.
    set popvalues [expr {[llength $args] == 1 ? [lindex $args 0] : $args}]
    set headlen [llength $heading]
    if {[llength $popvalues] % $headlen != 0} {
        tailcall DeclError ARG_MISMATCH $headlen [llength $popvalues]
    }

    # Iterate over the attribute values taking them in chunks that are the same
    # size as the heading.
    set body [list]
    for {set vindex 0} {$vindex < [llength $popvalues]} {incr vindex $headlen} {
        set values [lrange $popvalues $vindex [expr {$vindex + $headlen - 1}]]
        # Create a tuple as a list of attribute name / value pairs.
        set tuple [list]
        foreach attr $heading value $values {
            # Check if we are skipping a value to use a default.  We must also
            # allow some way to specify the value as "-".
            if {$value eq "-"} {
                continue
            } elseif {$value eq "\\-"} {
                set value -
            }
            lappend tuple $attr $value
        }
        # Accumulate the tuples as a list to form the body that will be
        # inserted into the relvar.
        lappend body $tuple
    }

    # Insert the body into the relvar.
    namespace upvar [namespace current]\
        DomainName DomainName\
        DomainLoc DomainLoc
    set domns ${DomainLoc}::${DomainName}
    set relvar ${domns}::$class
    set insts [relvar insert $relvar {*}$body]
    #puts [relformat $insts $relvar]

    # Now we have to deal with any state model that might be present.  We have
    # to set up the initial state properly if such a thing exists for this
    # class.
    set idattrs [lindex [relvar identifiers $relvar] 0]
    relation foreach inst $insts {
        CreateInInitialState $domns $class [pipe {
            relation project $inst {*}$idattrs |
            relation tuple ~ |
            tuple get ~
        }]
    }

    return
}
----

(((error code,ARG_MISMATCH)))
[source,tcl]
----
<<error code formats>>=
ARG_MISMATCH      {number of population values must be a multiple of %d, got %d}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.0 {
    Populate a domain
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 0..n--0..1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    rosea populate {
        domain meta {
            class C1\
                {Id     A1} {
                foo     24
                bar     42
            }
            class C2\
                {Id     C1Id} {
                f1      24
                f2      24
            }
        }
    }
    relation cardinality $::meta::C1
} -result {2}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.1 {
    Populate a domain -- alternate syntax
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 0..n--0..1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    rosea populate {
        domain meta {
            class C1\
                {Id     A1}\
                foo     24\
                bar     42
            class C2\
                {Id     C1Id}\
                f1      24\
                f2      24
        }
    }
    relation cardinality $::meta::C2
} -result {2}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.2 {
    Populate a domain using default value syntax
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int -default 20
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}
            }
            association R1 C2 0..n--0..1 C1
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::meta
} -body {
    rosea populate {
        domain meta {
            class C1\
                {Id     A1} {
                foo     24
                bar     -
            }
            class C2\
                {Id     C1Id} {
                f1      24
                f2      24
            }
        }
    }
    set ref [::meta::C1 findWhere {$A1 == 20}]
    ::rosea::InstCmds::readAttribute $ref Id
} -result {bar}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.3 {
    Populate a domain with initial states
} -setup {
    rosea configure {
        domain meta {
            class C1 {
                attribute Id string -id 1
                attribute A1 int
            }

            class C2 {
                attribute Id string -id 1
                attribute C1Id string
                reference R1 C1 -link {C1Id Id}

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                }
            }
            association R1 C2 0..n--0..1 C1
        }
    }
    rosea generate [namespace current]
} -cleanup {
    cleanupConfigData
    removeDomain [namespace current]::meta
} -body {
    rosea populate {
        domain meta {
            class C1\
                {Id     A1} {
                foo     24
                bar     42
            }
            class C2\
                {Id     C1Id} {
                f1      24
                f2      24
            }
        }
    }
    relation cardinality [relvar set [namespace current]::meta::__C2__STATEINST]
} -result {2}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.4 {
    populate a multi assigner
} -setup {
    rosea configure {
        domain foo {
            class Customer {
                attribute Name string -id 1
            }
            class Clerk {
                attribute Name string -id 1
                attribute Customer string
                attribute Department string
                reference R1 Customer -link {Customer Name}
                reference R2 Department -link {Department Name}
            }
            class Department {
                attribute Name string -id 1
            }
            association R1 Clerk 0..1--0..1 Customer
            association R2 Clerk 1..n--1 Department
            assigner R1 {
                identifyby Department
                state s1 {a b} {
                    puts $a $b
                }
                transition s1 - e1 -> s2

                state s2 {} {
                    puts "in s2"
                        set ::done 1
                }
                transition s2 - e1 -> s1
            }
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
} -body {
    rosea populate {
        domain foo {
            assigner R1 Name Shoes
        }
    }
    ::foo::R1 signal {Name Shoes} e1
    set timer [after 1000 set ::done TIMEOUT]
    vwait ::done
    after cancel $timer
    set ::done
} -result {1}
----

///////
----
<<manual populate commands>>=
[call [cmd assigner] [arg heading] [arg values]]
----
///////

[source,tcl]
----
<<domain populate commands>>=
proc assigner {rname heading args} {
    # Determine if we have one big list or a bunch of values.
    set popvalues [expr {[llength $args] == 1 ? [lindex $args 0] : $args}]
    set headlen [llength $heading]
    if {[llength $popvalues] % $headlen != 0} {
        tailcall DeclError ARG_MISMATCH $headlen [llength $popvalues]
    }

    namespace upvar [namespace current]\
        DomainName DomainName\
        DomainLoc DomainLoc
    set domns ${DomainLoc}::${DomainName}
    set relvar ${domns}::__${rname}__STATEINST
    set idattrs [lindex [relvar identifiers $relvar] 0]
    if {![struct::set equal $heading $idattrs]} {
        tailcall DeclError NO_IDENTIFIER $heading $idattrs
    }

    # Iterate over the attribute values taking them in chunks that are the same
    # size as the heading.
    for {set vindex 0} {$vindex < [llength $popvalues]} {incr vindex $headlen} {
        set values [lrange $popvalues $vindex [expr {$vindex + $headlen - 1}]]
        # Create a tuple as a list of attribute name / value pairs.  We assume
        # the values are in the same order as the heading -- that is the point.
        set tuple [list]
        foreach attr $heading value $values {
            lappend tuple $attr $value
        }
        CreateInInitialState $domns $rname $tuple
    }

    return
}
----

== State Machine Trace

In this section we discuss the capabilities and design of tracing
state machine event dispatch.
Again,
we are confronted with a heavily overloaded term, _trace_.
There are many kinds of traces in the Tcl world and
we do not wish to confuse Tcl variable and command tracing with
+rosea+ package state machine tracing.
Here we are discussing the ability of the package to produce a chronologically
ordered sequence of the results of dispatching state machine events.

It's hard to overemphasize the importance of the event dispatch trace
for a set of state machines.
Since the majority of the processing in state machine based application is in
the form of callbacks for dispatched events,
it is difficult to simply read the code base sequentially and
have a good sense of what will happen during execution.
Of course,
a different sequence of events will order the code execution differently.
That is, after all, what we are trying to achieve with a state model.

The fact that the path of code execution does not easily correspond to the
sequence of the code statements is objectionable enough to some that they avoid
a state model based approach.
Others try to cast state behavior into more sequential appearing
code by using other techniques such as coroutines.
All of these considerations lead to the conclusion that
capturing a chronological trace of the event dispatch of
a state machine based applications is indispensable to understanding and
testing.

In this section we discuss the design and implementation of the
state machine tracing implemented by this package.
First we lay out some basic rules.

* Tracing can be controlled.
It is necessary to be able to start and stop the trace capture
and to clear out any accumulated traces.
* Tracing must capture all the semantics of event dispatch,
including polymorphic and creation events.
* It is only necessary to trace event dispatch.
Signaling, _i.e._ when events are generated,
is not captured.
* Common operations on the collected trace data must be supported
including the ability to save the trace data into some persistent form,
(_e.g._ a file).

To meet these requirements,
trace data is captured by the event dispatch methods and stored
in appropriate data structures.
The following sections discuss the manner in which this is done.
We divide the discussion into the these parts:

* The structure of the trace data.
* Procedures to gather the trace data.
* Procedures to query and format the trace data.

=== Trace Data

The figure below shows a class diagram in UML notation of the
state machine trace data.

image::trace-schema.pdf[title="Trace Data Class Model"]

A trace is identified by an arbitrary identifier.
We will use a sequential integer.
Each trace has a +Timestamp+.
This needs to be of relatively high resolution so we will use the
return from the +clock microseconds+ command.
The +Target+ of a trace is the instance reference to which the event is
directed.
We also store the +Class+ name that corresponds to the +Target+
so we can perform queries on a class rather than instance basis
(_e.g._ it is interesting to determine how all instances of some set of classes
pass events without any reference to particular instances).

The three types of event dispatch types are captured as by the +R1+
generalization.
*Creation* events result in an instance being created followed by
an ordinary *Transition* event.
So any creation event will eventually have two trace entries.
*Polymorphic* events map, at run time, an event directed at a superclass
instance to a corresponding event in the related subclass instance.
So each polymorphic event will have at least one ordinary transition associated
with it as the polymorphic event is finally mapped down to a leaf subclass
and consumed there.
Ordinary *Transition* events are most common and we record the object that is
the source of the event,
parameters associated with the event and
the outcome of the transition.

Following our established patter,
the most direct implementation of this data schema is to use the +TclRAL+
package.

[source,tcl]
----
<<trace commands namespace>>=
namespace eval Trace {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path [list\
        [namespace parent]::Helpers\
        [namespace parent]::InstCmds\
    ]
    <<trace data>>
    <<trace commands>>
}
----

[source,tcl]
----
<<trace data>>=
relvar create Trace {
    Trace_Id    int
    Timestamp   bignum
    Source      string
    Event       string
    Target      string
    Class       string
} Trace_Id

relvar create Creation {
    Trace_Id    int
} Trace_Id

relvar create Polymorphic {
    Trace_Id    int
    SuperClass  string
    Linkage     string
} Trace_Id

relvar create Transition {
    Trace_Id    int
    CurrState   string
    NewState    string
    Params      list
} Trace_Id

relvar partition R1 Trace Trace_Id\
    Creation Trace_Id\
    Polymorphic Trace_Id\
    Transition Trace_Id
----

We need some ordinary variables to keep track of the
state of trace capture, a counter for generating
the +Trace_Id+ attribute values and details of trace logging.

[source,tcl]
----
<<trace data>>=
variable traceState off
variable traceNumber 0
variable traceLogState off
variable traceLogLevel info
----

We log to a service that is the same name as the package.

[source,tcl]
----
<<trace data>>=
variable traceLogCmd [::logger::init rosea]
----

=== Trace Control

The +traceControl+ procedure provides the interface necessary to control the
aspects of state machine tracing.

///////
----
<<manual package commands>>=
[call [cmd "::rosea traceControl"] [arg option] [opt [arg "value ..."]]]
----
///////

[source,tcl]
----
<<rosea exports>>=
namespace export traceControl

<<rosea commands>>=
proc traceControl {op args} {
    switch -exact -- $op {
        on {
            namespace upvar Trace traceState traceState
            set traceState on
        }
        off {
            namespace upvar Trace traceState traceState
            set traceState off
        }
        status {
            namespace upvar Trace traceState traceState
            return $traceState
        }
        clear {
            relvar eval {
                foreach rvar {Trace Creation Polymorphic Transition} {
                    relvar set Trace::$rvar\
                            [relation emptyof [relvar set Trace::$rvar]]
                }
            }
            namespace upvar Trace traceNumber traceNumber
            set traceNumber 0
        }
        logon {
            namespace upvar Trace traceLogState traceLogState
            set traceLogState on
        }
        logoff {
            namespace upvar Trace traceLogState traceLogState
            set traceLogState off
        }
        loglevel {
            namespace upvar Trace traceLogLevel traceLogLevel
            if {[llength $args] != 0} {
                set traceLogLevel [lindex $args 0]
            }
            return $traceLogLevel
        }
        save {
            if {[llength $args] == 0} {
                DeclError NO_SAVEFILE
            }
            storeToSQLite [lindex $args 0] [relvar names ::rosea::Trace::*]
        }
        default {
            DeclError BAD_TRACEOP $op
        }
    }
}
----

(((error code,BAD_TRACEOP)))
(((error code,NO_SAVEFILE)))
[source,tcl]
----
<<error code formats>>=
BAD_TRACEOP     {unknown trace operation, "%s"}
NO_SAVEFILE     {no save file name provided}
----

=== Trace Population

Each of the event dispatch procedrues that is involved with dispatching
events into a state machine invokes a procedure to capture the dispatch
data.
There are three such procedures corresponding to the three types
of event dispatch.
Each as the same basic structure, namely determining if tracing is
enabled,
inserting the trace data to the appropriate relvars
and logging the trace instance.

[source,tcl]
----
<<trace commands>>=
proc TraceCreation {source event target} {
    variable traceState
    if {$traceState} {
        relvar eval {
            set trace [NewTrace $source $event $target]
            relvar insert Creation [list\
                Trace_Id    [relation extract $trace Trace_Id]\
            ]
        }
        LogTrace $trace
    }
}
----

[source,tcl]
----
<<trace commands>>=
proc TracePolymorphic {source event target super link} {
    variable traceState
    if {$traceState} {
        relvar eval {
            set trace [NewTrace $source $event $target]
            relvar insert Polymorphic [list\
                Trace_Id    [relation extract $trace Trace_Id]\
                SuperClass  $super\
                Linkage     $link\
            ]
        }
        LogTrace $trace
    }
}
----

[source,tcl]
----
<<trace commands>>=
proc TraceTransition {source event target curr new params} {
    variable traceState
    if {$traceState} {
        relvar eval {
            set trace [NewTrace $source $event $target]
            relvar insert Transition [list\
                Trace_Id    [relation extract $trace Trace_Id]\
                CurrState   $curr\
                NewState    $new\
                Params      $params\
            ]
        }
        LogTrace $trace
    }
}
----

Code to number the trace and insert it into the +Trace+ relvar is
factored to a separate procedure.

[source,tcl]
----
<<trace commands>>=
proc NewTrace {src event target} {
    variable traceNumber
    return [relvar insert Trace [list\
        Trace_Id    [incr traceNumber]\
        Timestamp   [clock microseconds]\
        Source      $src\
        Event       $event\
        Target      $target\
        Class       [lindex $target 0]\
    ]]
}
----

Each of the above three procedures that inserts a particular type
of trace data into the data store also logs the trace.
Trace logging first checks the state of the logging and then
formats an appropriate string for the log.

[source,tcl]
----
<<trace commands>>=
proc LogTrace {trace} {
    variable traceLogState
    if {$traceLogState} {
        set rec [FormatTraceRec [lindex [TracesToRecords $trace] 0]] ; # <1>

        variable traceLogCmd
        variable traceLogLevel
        ${traceLogCmd}::${traceLogLevel} $rec
    }
}
----
<1> The +TracesToRecords+ procedure returns a list and knowing that the
list contains only one element, we extract that element to format.

[source,tcl]
----
<<trace command tests>>=
test LogTrace-1.0 {
    log trace data
} -setup {
    rosea configure {
        domain foo {
            class c1 {
                attribute Id int -id 1
                attribute Count int -default 0
                attribute Max int -default 2
                statemodel {
                    state s1 {} {
                        updateAttribute $self Count\
                            [expr {[readAttribute $self Count] + 1}]
                        #puts [relformat [deRef $self] self]
                        lassign [readAttribute $self Count Max] count max
                        if {$count >= $max} {
                            ::rosea::test::syncToTest $count
                        }
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                        updateAttribute $self Count\
                            [expr {[readAttribute $self Count] + 1}]
                        signal $self e2
                    }
                    transition s2 - e2 -> s1
                }
            }
        }
    }
    rosea generate
    turnOnTraceLog
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
    turnOffTraceLog
} -body {
    set ref [::foo::c1 create Id 1]
    ::rosea::InstCmds::signal $ref e1
    waitForSync
} -result {2}
----

[source,tcl]
----
<<test utility procs>>=
proc syncToTest {{value {}}} {
    set [namespace current]::testDone $value
}

proc waitForSync {{timeout 1000}} {
    set varname [namespace current]::testDone
    set tid [::after $timeout set $varname TIMEOUT]
    vwait $varname
    after cancel $tid
    set $varname
}
----

[source,tcl]
----
<<trace command tests>>=
test LogTrace-2.0 {
    log trace data for a polymorphic event
} -setup {
    rosea configure {
        domain foo {
            class lt2 {
                attribute Id int -id 1

                polymorphic *e1 *e2
            }
            generalization R1 lt2 lt2-sub1 lt2-sub2

            class lt2-sub1 {
                attribute Id int -id 1
                reference R1 lt2 -link Id

                statemodel {
                    state sub1-s1 {} {
                        ::rosea::test::syncToTest true
                    }
                    transition sub1-s1 - *e1 -> sub1-s2

                    state sub1-s2 {} {
                        delaysignal 50 $self *e2
                    }
                    transition sub1-s2 - *e2 -> sub1-s1
                }
            }

            class lt2-sub2 {
                attribute Id int -id 1
                reference R1 lt2 -link Id

                statemodel {
                    state sub1-s1 {} {
                        ::rosea::test::syncToTest true
                    }
                    transition sub1-s1 - *e1 -> sub1-s2

                    state sub1-s2 {} {
                        delaysignal 50 $self *e2
                    }
                    transition sub1-s2 - *e2 -> sub1-s1
                }
            }
        }
    }

    rosea generate

    rosea populate {
        domain foo {
            class lt2 Id 1
            class lt2-sub1 Id 1
        }
    }

    turnOnTraceLog
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
    turnOffTraceLog
} -body {
    set superref [::foo::lt2 findWhere {$Id == 1}]
    ::rosea::InstCmds::signal $superref *e1
    waitForSync
} -result {true}
----

[source,tcl]
----
<<trace command tests>>=
test LogTrace-3.0 {
    log trace data for a creation event
} -setup {
    rosea configure {
        domain foo {
            class lt3 {
                attribute Id int -id 1
                statemodel {
                    transition @ - e1 -> s1

                    state s1 {value} {
                        ::rosea::test::syncToTest $value
                    }
                }
            }
        }
    }

    rosea generate

    turnOnTraceLog
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
    turnOffTraceLog
} -body {
    ::foo::lt3 createasync e1 10 Id 1
    waitForSync
} -result {10}
----

[source,tcl]
----
<<test utility procs>>=
proc turnOnTraceLog {} {
    variable prevloglevel

    ::rosea traceControl clear
    ::rosea traceControl on
    set logcmd [::logger::servicecmd rosea]
    set prevloglevel [${logcmd}::currentloglevel]
    ${logcmd}::setlevel [::rosea traceControl loglevel]
    ::rosea traceControl logon
}

proc turnOffTraceLog {} {
    variable prevloglevel

    set logcmd [::logger::servicecmd rosea]
    ${logcmd}::setlevel $prevloglevel
    ::rosea traceControl logoff
    ::rosea traceControl off
    ::rosea traceControl clear
}
----

=== Trace Operations

It is difficult to provide all the conceivable operations that one
may wish to perform on the captured state machine trace data.
In this package we will provide some common operations,
but special cases can be handled by constructing appropriate
queries on the +relvar+ data of the package and passing the result
to be formatted.
The required primitive operations are here to support a wider range
of custom trace queries.

We divide the decoding of the trace data into two parts:

* Casting the +relvar+ data into an ordered list of dictionaries.
* Formatting trace dictionary data into human readable form.

This separation makes handling data programmatically via the dictionaries
much easier yet still allows the production of human readable output.
There are many ways that a program can use the state machine trace data.
For example, the trace data can be used to compute the coverage of
states and transitions for testing purposes.
This is much easier to accomplish if the data is _not_ in string form but
rather with known named fields.

In this section we will cover the layout of the trace record dictionaries
and then a set of query functions to produce sets of records.
Afterward, we will discuss procedures to format trace dictionaries into
human readable strings.

==== Trace Dictionary Structure

Although the ++relvar++s defined above contain all the trace data
in a form that is easy to write queries on,
transforming relational data into a dictionary provides a convenient
interface for handling sets of trace data.
Here we discuss the keys that the trace data dictionary have
and the procedures which produce them.

The trace data dictionary has to account for the three different
types of dispatched events.
We will have common keys that apply to all types of events and a +type+
key that can be used to determine the event type specific keys.
The common keys are:

+id+::
    An integer number that identifies the sequence of the trace entry.
+time+::
    The time since the epoch, in microseconds, that the trace was captured.
+source+::
    The instance reference of the instance that signaled the event.
    If the source of the event is outside of an object,
    then this will be the nil reference.
+event+::
    The name of the event.
+target+::
    The instance reference of the target of the event.
+class+::
    The fully qualified relvar name for the class that corresponds to +target+.
+type+::
    The type of the dispatched event: one of +creation+, +polymorphic+,
    or +transition+.

For +creation+ type events, there are no additional keys.
The +target+ value is interpreted as the object command name of the
newly created instance and the +class+ value is the command name of
the instance creator (which is, necessarily, also the class of the +target+).

For +polymorphic+ type events, the following additional keys are available:

+super+::
    The class name of the superclass instance mapping the event.
+link+::
    The name of the partition linkage across which the event is mapped.

For polymorphic type events, the +target+ value is the class name of
the subclass instance onto which the polymorphic event is mapped.

For +transition+ type events, the following additional keys are available:

+current+::
    The name of the state of +target+ when the event was received.
+new+::
    The name of the state of +target+ after the transition happened.
+params+::
    A list of values giving the parametric data passed with the event to
    the state activity.

The procedure, +TracesToRecords+, takes a relation value that is
a subset (proper or improper) of the value contained in the +Trace+ relvar
and converts it into a list of trace records.
Each trace record is a dictionary of the form described above.

As we will see below,
this procedure is used by all the query oriented procedures to
convert the trace data into lists of dictionaries.
One difficulty of this transformation is to account for the
three different types of event traces.
This is done by joining the +Trace+ relation values against each of the
three ++relvar++s that participate in +R1+.
This join is done in such a way that three new relation valued attributes
are created and, given the disjoint union implied by the partition
constraint, only one of the new attributes will contain any tuples.

(((proc,TracesToRecords)))

[source,tcl]
----
<<trace commands>>=
proc TracesToRecords {traces} {
    foreach rvname {Creation Polymorphic Transition} { # <1>
        set traces [::ralutil::rvajoin $traces [relvar set $rvname] $rvname]
    }

    set result [list]
    relation foreach trace $traces -ascending Trace_Id { # <2>
        relation assign $trace
        set labeled [dict create\
            id      $Trace_Id\
            time    $Timestamp\
            source  $Source\
            event   $Event\
            target  $Target\
            class   $Class\
        ] ; # <3>
        if {[relation isnotempty $Transition]} { # <4>
            relation assign $Transition
            dict set labeled type transition
            dict set labeled current $CurrState
            dict set labeled new $NewState
            dict set labeled params $Params
        } elseif {[relation isnotempty $Polymorphic]} {
            relation assign $Polymorphic
            dict set labeled type polymorphic
            dict set labeled super $SuperClass
            dict set labeled link $Linkage
        } elseif {[relation isnotempty $Creation]} {
            dict set labeled type creation
        }

        lappend result $labeled
    }
    return $result
}
----
<1> Perform a *relation valued join* of the traces against the three
different types of trace data.
Each +rvajoin+ produces a new attribute whose name we choose to be the same
as the +relvar+ from which it came and whose value is a relation value
containing those tuples whose value of +Trace_Id+ match.
Because the +R1+ partition represents a disjoint union and +Trace_Id+
is an identifier,
only one of the three new attributes will have any tuples and the non-empty
one will contain exactly one tuple.
<2> We can now iterate across the joined trace data in the order that it was
generated (_i.e._ by +-ascending Trace_Id+)
so that the resulting list of dictionaries is in the same order.
This was the primary reason for performing all the +rvajoin+ operations,
_i.e._ to make it more convenient to preserve the event dispatch order
into the resulting list.
<3> Add all the common keys, except +type+.
<4> Add the keys that are specific to the event type.

==== Decode All Traces

The first of the query functions simple decodes all available trace data.

///////
----
<<manual package commands>>=
[call [cmd "::rosea decodeAllTraces"]]
----
///////

(((proc,decodeAllTraces)))

[source,tcl]
----
<<rosea exports>>=
namespace export decodeAllTraces

<<rosea commands>>=
proc decodeAllTraces {} {
    tailcall Trace::TracesToRecords [relvar set Trace::Trace]
}
----

[float]
===== Decode All Traces Tests

[source,tcl]
----
<<trace command tests>>=
test decodeAllTraces-1.0 {
    display trace data
} -setup {
    rosea configure {
        domain foo {
            class c1 {
                attribute Id int -id 1
                attribute Count int -default 0
                attribute Max int -default 2
                statemodel {
                    state s1 {} {
                        updateAttribute $self Count\
                            [expr {[readAttribute $self Count] + 1}]
                        lassign [readAttribute $self Count Max] count max
                        if {$count >= $max} {
                            ::rosea::test::syncToTest $count
                        }
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                        updateAttribute $self Count\
                            [expr {[readAttribute $self Count] + 1}]
                    }
                    transition s2 - e2 -> s1
                }
            }
        }
    }
    rosea generate
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
    ::rosea traceControl off
    ::rosea traceControl clear
} -body {
    ::rosea traceControl on
    set ref [::foo::c1 create Id 1]
    ::rosea::InstCmds::signal $ref e1
    ::rosea::InstCmds::signal $ref e2
    waitForSync
    set traces [::rosea decodeAllTraces]
    dict get [lindex $traces 0] event
} -result {e1}
----

==== Decode Class Traces

///////
----
<<manual package commands>>=
[call [cmd "::rosea decodeClassTraces"] [arg "class ..."]]
----
///////

(((proc,decodeClassTraces)))

[source,tcl]
----
<<rosea exports>>=
namespace export decodeClassTraces

<<rosea commands>>=
proc decodeClassTraces {args} {
    tailcall Trace::TracesToRecords [pipe {
        relvar set Trace::Trace |
        relation restrictwith ~ {$Class in $args}
    }]
}
----

[float]
===== Decode Class Traces Tests

[source,tcl]
----
<<trace command tests>>=
test decodeClassTraces-1.0 {
    display trace data for specific class
} -setup {
    rosea configure {
        domain foo {
            class dct1 {
                attribute Id string -id 1
                attribute Power int -default 20
                reference R1 dct2 -link Id
                statemodel {
                    state Off {} {
                        signal [findRelated $self R1] Lower
                    }
                    transition Off - TurnOn -> On

                    state On {power} {
                        updateAttribute $self Power $power
                        signal [findRelated $self R1] Raise
                    }
                    transition On - TurnOff -> Off
                }
            }

            association R1 dct1 1--1 dct2

            class dct2 {
                attribute Id string -id 1
                statemodel {
                    state Down {} {
                        ::rosea::test::syncToTest\
                            [readAttribute [findRelated $self ~R1] Power]
                    }
                    transition Down - Raise -> Up

                    state Up {} {
                        delaysignal 50 [findRelated $self ~R1] TurnOff
                    }
                    transition Up - Lower -> Down
                }
            }
        }
    }

    rosea generate

    rosea populate {
        domain foo {
            class dct1 Id first
            class dct2 Id first
        }
    }

    rosea traceControl clear
    rosea traceControl on
} -cleanup {
    cleanupConfigData
    removeDomain ::foo
    rosea traceControl off
    rosea traceControl clear
} -body {
    ::rosea::InstCmds::signal [::foo::dct1 findWhere {$Id eq "first"}] TurnOn 30
    waitForSync
    # puts [::rosea formatTraces [::rosea decodeAllTraces]]
    set traces [::rosea decodeClassTraces ::foo::dct2]
    expr {[llength $traces] == 2 &&\
            [dict get [lindex $traces 1] event] eq "Lower"}
} -result {1}
----

==== Decode Target Traces

///////
----
<<manual package commands>>=
[call [cmd "::rosea decodeTargetTraces"] [arg "target ..."]]
----
///////

(((proc,decodeTargetTraces)))

[source,tcl]
----
<<rosea exports>>=
namespace export decodeTargetTraces

<<rosea commands>>=
proc decodeTargetTraces {args} {
    tailcall TracesToRecords [pipe {
        relvar set Trace |
        relation restrictwith ~ {$Target in $args}
    }]
}
----

==== Format Traces

Human readable output for state machine traces can be obtain via the
+formatTraces+ procedure.
This procedure takes a list of trace records,
as defined above and as returned from the various trace decode procedures,
and returns a string that has a human readable representation of the
trace records.
Each trace record is separated by a line terminator character.
The returned string may be written on any channel the caller wishes.

///////
----
<<manual package commands>>=
[call [cmd "::rosea formatTraces"] [arg tracelist]]
----
///////

(((proc,formatTraces)))

[source,tcl]
----
<<rosea exports>>=
namespace export formatTraces

<<rosea commands>>=
proc formatTraces {tracerecs} {
    if {[llength $tracerecs] == 0} {
        return {}
    }
    set prevtime [dict get [lindex $tracerecs 0] time]
    foreach rec $tracerecs {
        dict with rec {
            append result "[Trace::FormatTimestamp $time]: "
            append result "[Trace::FormatTimeAsSec\
                    [expr {$time - $prevtime}]]: "
            set prevtime $time
            append result [Trace::FormatTraceRec $rec] \n
        }
    }
    return [string trimright $result]
}
----

[float]
===== Format Traces Tests

[source,tcl]
----
<<trace command tests>>=
test formatTraces-1.0 {
    display human readable trace data
} -setup {
    rosea configure {
        domain foo {
            class c1 {
                attribute Id int -id 1
                attribute Count int -default 0
                attribute Max int -default 2
                statemodel {
                    state s1 {} {
                        updateAttribute $self Count\
                            [expr {[readAttribute $self Count] + 1}]
                        lassign [readAttribute $self Count Max] count max
                        if {$count >= $max} {
                            ::rosea::test::syncToTest $count
                        }
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                        updateAttribute $self Count\
                            [expr {[readAttribute $self Count] + 1}]
                    }
                    transition s2 - e2 -> s1
                }
            }
        }
    }
    rosea generate
} -cleanup {
    rosea traceControl off
    rosea traceControl clear
} -body {
    rosea traceControl on
    set one [::foo::c1 create Id 1]
    ::rosea::InstCmds::signal $one e1
    ::rosea::InstCmds::signal $one e2
    waitForSync
    set traces [rosea formatTraces [rosea decodeAllTraces]]
    # puts $traces
    llength [split $traces \n]
} -result {2}
----

==== Format Trace Record

An individual trace record may be formatted with the +FormatTraceRec+
procedure.

(((proc,FormatTraceRec)))

[source,tcl]
----
<<trace commands>>=
proc FormatTraceRec {rec} {
    dict with rec {
        switch -exact -- $type {
            transition {
                append result\
                    "Transition: "\
                    "[FormatInstRef $source] - $event"\
                    [expr {[llength $params] != 0 ?\
                        "\([join $params {, }]\)" : {}}]\
                    " -> [FormatInstRef $target] ==> "\
                    "$current -> $new"
            }
            polymorphic {
                append result\
                    "Polymorphic : "\
                    "[FormatInstRef $source] - $event -> $super ==> "\
                    "$link -> [FormatInstRef $target]"
            }
            creation {
                append result\
                    "Creation: "\
                    "[FormatInstRef $source] - $event -> $class ==>\
                        [FormatInstRef $target]"
            }
            default {
                DeclError BAD_TRACETYPE $type
            }
        }
    }
    return $result
}
----

[source,tcl]
----
<<trace commands>>=
proc FormatInstRef {instref} {
    lassign $instref relvar inst
    if {$relvar eq {}} {
        return {{}}
    } else {
        return "$relvar\{[tuple get [relation tuple $inst]]\}"
    }
}
----

(((error code,BAD_TRACETYPE)))
[source,tcl]
----
<<error code formats>>=
BAD_TRACETYPE   {unknown trace type, "%s"}
----

==== Format Time Stamp

(((proc,FormatTimeStamp)))

[source,tcl]
----
<<trace commands>>=
proc FormatTimestamp {time} {
    set sec [clock format [expr {$time / 1000000}] -format %T] ; # <1>
    set time [expr {$time % 1000000}]
    set msec [expr {$time / 1000}]
    set usec [expr {$time % 1000}]

    return [format %s.%03ld.%03ld $sec $msec $usec]
}
----
<1> We assume time in units of microseconds.

==== Format Time As Seconds

(((proc,FormatTimeAsSec)))

[source,tcl]
----
<<trace commands>>=
proc FormatTimeAsSec {time} {
    set sec [expr {$time / 1000000}]
    set time [expr {$time % 1000000}]
    set msec [expr {$time / 1000}]
    set usec [expr {$time % 1000}]

    return [format %3ld.%03ld.%03ld $sec $msec $usec]
}
----

=== Sequence Diagrams

Another way to view trace information is in the form of a sequence diagram.
The http://blockdiag.com/en/seqdiag/index.html[+seqdiag+]
program can layout and render UML sequence diagrams
from a simple textual specification of the diagram's components.
The syntax of the sequence diagram is similar to that of *dot*.
Using the captured state machine trace information,
we can view the interactions of state models.
We present several procedures in this group.

==== Diagram Traces

(((proc,DiagTraces)))

[source,tcl]
----
<<trace commands>>=
proc DiagTraces {traces args} {
    set result {}
    append result "seqdiag \{\n"
    append result "    activation = none;\n"
    foreach {option value} $args {
        append result "    $option = $value;\n"
    }

    foreach rvname {Creation Polymorphic Transition} {
        set traces [::ralutil::rvajoin $traces [relvar set $rvname] $rvname]
    }

    relation foreach trace $traces -ascending Trace_Id {
        relation assign $trace
        if {[isEmptyRef $Source]} {
            set Source EXTERNAL
        } else {
            set Source [namespace tail [lindex $Source 0]]
        }
        set Target [namespace tail [lindex $Target 0]]
        if {[relation isnotempty $Transition]} {
            relation assign $Transition Params
            set evtlabel $Event[expr {[llength $Params] != 0 ?\
                "\([join $Params {, }]\)" : {}}]
        } elseif {[relation isnotempty $Polymorphic]} {
            relation assign $Transition Linkage
            set evtlabel "$Event <<Polymorphic $Linkage>>"
        } elseif {[relation isnotempty $Creation]} {
            set evtlabel "$Event <<Creation>>"
        }
        append result "    $Source ->> $Target \[label=\"$evtlabel\"\];\n"
    }

    append result "\}\n"

    return $result
}
----

==== Diagram All Traces

///////
----
<<manual package commands>>=
[call [cmd "::rosea diagAllTraces"] [arg filename]\
    [opt [arg "option value ..."]]]
----
///////

(((proc,diagAllTraces)))

[source,tcl]
----
<<rosea exports>>=
namespace export diagAllTraces

<<rosea commands>>=
proc diagAllTraces {filename args} {
    set chan [open $filename w]
    try {
        chan puts $chan [Trace::DiagTraces [relvar set Trace::Trace] {*}$args]
    } finally {
        chan close $chan
    }
    return
}
----

==== Diagram Class Traces

///////
----
<<manual package commands>>=
[call [cmd "::rosea diagClassTraces"] [arg classlist]\
    [opt [arg "option value ..."]]]
----
///////

(((proc,diagClassTraces)))

[source,tcl]
----
<<rosea exports>>=
namespace export diagClassTraces

<<rosea commands>>=
proc diagClassTraces {filename classes args} {
    set chan [open $filename w]
    try {
        set traces [pipe {
            relvar set Config::Trace >
            relation restrictwith ~\
                {$Class in $classes || [namespace tail $Class] in $classes}
        }] {} >~
        chan puts $chan [Trace::DiagTraces $traces {*}$args]
    } finally {
        chan close $chan
    }
    return
}
----

== An Example

=== Example Overview

In this section we start the discussion of the example that is used
to illustrate the usage of +rosea+.
Unfortunately,
there is rather a lot of background material that we will not cover here.
We do not explain how to create an XUML model
nor will we spend much time explaining why the example model was designed
the way it was.
There are many good books that explain XUML in detail and will teach
you the basics of modelingfootnote:[
<<mb-xuml,Mellor and Balcer>>,
<<rs-xuml,Chris Raistrick _et.al_>> and
<<ls-build,Leon Starr>> all are worthy of a close reading.].
We suggest you read at least one of them.
It is also the case that this package represents one particular piece
of a larger workflow and this means that readers who may not be
completely familiar with model-driven translation oriented development
may have many questions that remain.

["blockdiag",title="Simplified Translation Workflow"]
----
blockdiag {
    class process [shape=ellipse]
    class known [shape=ellipse,color="#ff7690"]
    requirements [label="Requirements", class="process"]
    models [label="Models", class="process"]
    code [label="Code", class="known"]

    pop [label="Population", class="known"]
    arch [label="rosea", class="known"]
    program [label="Program", class="known"]

    requirements -> models [label="Analysis",fontsize=8]
    models -> code [label="Translate",fontsize=8]
    code -> program [label="Build",fontsize=8]
    arch -> program
    pop -> program
}
----

In the above figure,
we will cover those portions that are colored.
Specifically,
we will not deal with how one creates models from Requirements.
We will start with the Model and show how that becomes Code via translation.
By combining the code with a population and the +rosea+ package,
we will produce a running example program.

The subject matter of our example is an automatic clothes washer.
This is a very simple washing machine,
especially compared to modern commercially available washers.
The intent is to select a subject that most people would be familiar
with from ordinary experience so that we don't have to devote too much
time explaining the problem.
One word of caution.
This model is an example for pedagogical purposes
and probably has little correspondence with the way _real_ washing
machines operate or are designed to operate.
You will also notice a lack of any attention paid to _what can go wrong_.
For industrial strength programs,
handling probable failure cases is very important but we have dispensed
with those considerations here to focus on how the model is
translated into the implementation code using +rosea+.

=== Class Diagram

The figure below shows a class diagram for the washing machine control
domain in UML graphical notation.

[[class-diagram,class diagram]]

image::wmc-class-diagram.pdf[title="Washing Machine Class Diagram"]

In our world,
a Washing Machine operates according to some Washing Cycle.
The Washing Cycle is a set of parameters that specifies aspects of
the washing that will turn dirty clothes into clean ones.
The Washing Machine itself has a Clothes Tub into which the dirty
laundry is placed.
There are also Water Valves to control the flow of water into and out of
the Clothes Tub and Motors to run a water pump, agitate the
Clothes Tub and rotate the Clothes Tub to spin excess water out of the
clean laundry.
Rounding out the machinery,
there is a Water Level Sensor that will tell us when the Clothes Tub
is filled with water or empty of water.

For a well engineered model,
the class diagram must also have a set of descriptions of what
the attributes and relationship actually mean,
what the value domains of the attributes are and many other
aspects that describe how the problem is represented in the model.
These descriptions are vital to understanding a class diagram.
Here again, in the interests of space,
we will have to suffice ourselves with more casual descriptions
included along with the example as it translated into the implementation
and an admonition that writing the model descriptions is an essential
aspect of a well engineered solution.

The class diagram shows the static aspects of our domain
and is always the first aspect of the model that must be considered
when deriving the implementation.
The classes hold the parameters of the domain and the relationships
state how the components are associated with respect to each other.
The class diagram facet of the model is static in the sense that
at any point in time,
the statements you can infer from the diagram will be true.
Later, we visit the dynamic and algorithmic facets of the domain
but, for now, we will endeavor to represent the classes and relationships
in terms of the +rosea+ package constructs.

=== Washing Machine Class

[source,tcl]
----
<<WM class>>=
class WashingMachine {
    attribute MachineID string -id 1
    attribute CycleType string
    reference R4 WashingCycle -link CycleType

    statemodel {
        initialstate Stopped
        defaulttrans CH

        state Stopped {} {
            <<WM stopped activity>>
        }
        transition Stopped - Start -> FillingToWash

        state FillingToWash {} {
            <<WM filling to wash activity>>
        }
        transition FillingToWash - Full -> Washing

        state Washing {} {
            <<WM washing activity>>
        }
        transition Washing - Done -> DrainingWash

        state DrainingWash {} {
            <<WM draining wash activity>>
        }
        transition DrainingWash - Empty -> FillingToRinse

        state FillingToRinse {} {
            <<WM filling to rinse activity>>
        }
        transition FillingToRinse - Full -> Rinsing

        state Rinsing {} {
            <<WM rinsing activity>>
        }
        transition Rinsing - Done -> DrainingRinse

        state DrainingRinse {} {
            <<WM draining rinse activity>>
        }
        transition DrainingRinse - Empty -> Spinning

        state Spinning {} {
            <<WM spinning activity>>
        }
        transition Spinning - Done -> Stopped
    }
}

association R4 WashingMachine 0..n--1 WashingCycle
----

==== Washing Machine State Activities

We start with the Washing Machine class.

image::wm-states.pdf[title="Washing Machine State Model Diagram"]

'''

// %States images/wm-states.uxf WashingMachine

// %Action WashingMachine Stopped
.Stopped Activity
----
# Stop spinning -- wash complete
select one ct related by self->R1[CT]
signal Stop to ct
----

.Stopped Implementation
[source,tcl]
----
<<WM stopped activity>>=
set ct [findRelated $self ~R1]
signal $ct Stop
----

'''

// %Action WashingMachine "Filling To Wash"
.Filling To Wash Activity
----
# Fill the tub with wash water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.WashWaterTemp) to ct
----

.Filling To Wash Implementation
[source,tcl]
----
<<WM filling to wash activity>>=
set wc [findRelated $self R4]
set ct [findRelated $self ~R1]
signal $ct Fill [readAttribute $wc WashWaterTemp]
----

'''

// %Action WashingMachine Washing
.Washing Activity
----
# Agitate the tub to wash.
select one ct related by self->R1[CT]
signal Agitate to ct
select one wc related by self->R4[WC]
signal Done to self at wc.WashDuration
----

.Washing Implementation
[source,tcl]
----
<<WM washing activity>>=
set ct [findRelated $self ~R1]
signal $ct Agitate
set wc [findRelated $self R4]
delaysignal [expr {[readAttribute $wc WashDuration] * 1000}] $self Done ; # <1>
----
<1> We are implicitly assuming the units of WashDuration are seconds.
In truth, the units are minutes, but we are not patient enough
to wait that long for a run of the example to finish.

'''

// %Action WashingMachine "Draining Wash"
.Draining Wash Activity
----
# Stop washing and drain
# the dirty wash water.
select one ct related by self->R1[CT]
signal Drain to ct
----

.Draining Wash Implementation
[source,tcl]
----
<<WM draining wash activity>>=
set ct [findRelated $self ~R1]
signal $ct Drain
----

'''

// %Action WashingMachine "Filling To Rinse"
.Filling To Rinse Activity
----
# Fill the tub with rinse water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.RinseWaterTemp) to ct
----

.Filling To Rinse Implementation
[source,tcl]
----
<<WM filling to rinse activity>>=
set wc [findRelated $self R4]
set ct [findRelated $self ~R1]
signal $ct Fill [readAttribute $wc RinseWaterTemp]
----

'''

// %Action WashingMachine Rinsing
.Rinsing Activity
----
# Agitate the tub to rinse.
select one ct related by self->R1[CT]
signal Agitate to ct
select one wc related by self->R4[WC]
signal Done to self at wc.RinseDuration
----

.Rinsing Implementation
[source,tcl]
----
<<WM rinsing activity>>=
set ct [findRelated $self ~R1]
signal $ct Agitate
set wc [findRelated $self R4]
delaysignal [expr {[readAttribute $wc RinseDuration] * 1000}] $self Done
----

'''

// %Action WashingMachine "Draining Rinse"
.Draining Rinse Activity
----
# Stop rinsing and drain
# the rinse water.
select one ct related by self->R1[CT]
signal Drain to ct
----

.Draining Rinse Implementation
[source,tcl]
----
<<WM draining rinse activity>>=
set ct [findRelated $self ~R1]
signal $ct Drain
----

'''

// %Action WashingMachine Spinning
.Spinning Activity
----
# Spin out excess water.
select one ct related by self->R1[CT]
signal Spin to ct
select one wc related by self->R4[WC]
signal Done to self at wc.SpinDuration
----

.Spinning Implementation
[source,tcl]
----
<<WM spinning activity>>=
set ct [findRelated $self ~R1]
signal $ct Spin
set wc [findRelated $self R4]
delaysignal [expr {[readAttribute $wc SpinDuration] * 1000}] $self Done
----

=== Washing Cycle Class

[source,tcl]
----
<<WC class>>=
class WashingCycle {
    attribute CycleType string -id 1
    attribute WashWaterTemp string
    attribute RinseWaterTemp string
    attribute WashDuration int
    attribute RinseDuration int
    attribute SpinDuration int
    attribute AgitationSpeed string
    attribute SpinSpeed string
}
----

=== Clothes Tub Class

[source,tcl]
----
<<CT class>>=
class ClothesTub {
    attribute MachineID string -id 1
    reference R1 WashingMachine -link MachineID

    statemodel {
        initialstate Empty
        defaulttrans CH

        state Empty {} {
            <<CT empty activity>>
        }
        transition Empty - Fill -> Filling
        transition Empty - Spin -> Spinning

        state Filling {temp} {
            <<CT filling activity>>
        }
        transition Filling - TubFull -> Full
        transition Filling - TubEmpty -> IG     ; # <1>

        state Full {} {
            <<CT full activity>>
        }
        transition Full - Agitate -> Agitating

        state Agitating {} {
            <<CT agitating activity>>
        }
        transition Agitating - Drain -> Emptying

        state Emptying {} {
            <<CT emptying activity>>
        }
        transition Emptying - TubEmpty -> Empty
        transition Emptying - TubFull -> IG

        state Spinning {} {
            <<CT spinning activity>>
        }
        transition Spinning - Stop -> StoppingSpin

        state StoppingSpin {} {
            <<CT stopping spin activity>>
        }
        transition StoppingSpin - Fill -> Filling
    }
}

association R1 ClothesTub 1--1 WashingMachine
----
<1> We allow for the fact that when the water level sensor is
enabled it may send events that reflect its current state.
So we simply ignore those sensor events in which we are not currently
interested.
See also the *Emptying* state transition for the *TubFull* event.

=== Clothes Tub State Activities

The other state model in our example is for the Clothes Tub class

image::ct-states.pdf[title="Clothes Tub State Model Diagram"]

'''

// %States images/ct-states.uxf ClothesTub

// %Action ClothesTub Empty
.Empty Activity
----
# Stop the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Stop()
# Close the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Close()
# Disable the sensor
select one wls related by self->R5[WLS]
wls.Disable()
# Inform the washing machine
select one wm related by self->R1[WM]
signal Empty to wm
----

.Empty Implementation
[source,tcl]
----
<<CT empty activity>>=
set mtr [findRelatedWhere $self ~R2 {$MotorID eq "Pump"}]
instop $mtr Stop

set wv [findRelatedWhere $self ~R3 {$ValveID eq "Drain"}]
instop $wv Close

set wls [findRelated $self ~R5]
instop $wls Disable

set wm [findRelated $self R1]
signal $wm Empty
----

'''

// %Action ClothesTub Filling
.Filling Activity
----
# Enable the sensor
select one wls related by self->R5[WLS]
wls.Enable()
# Open inlet valve(s)
if (temp = 'Hot')
    select one wv related by self->R3[WV]
        where (ValveID = 'Hot')
    wv.Open()
else if (temp = 'Cold')
    select one wv related by self->R3[WV]
        where (ValveID = 'Cold')
    wv.Open()
else if (temp = 'Warm')
    select many wvs related by self->R3[WV]
        where (ValveID = 'Hot' OR ValveID = 'Cold')
    foreach wv in wvs
        wv.Open()
    endfor
end if
----

.Filling Implementation
[source,tcl]
----
<<CT filling activity>>=
set wls [findRelated $self ~R5]
instop $wls Enable
if {$temp eq "Hot"} {
    set wv [findRelatedWhere $self ~R3 {$ValveID eq "Hot"}]
    instop $wv Open
} elseif {$temp eq "Cold"} {
    set wv [findRelatedWhere $self ~R3 {$ValveID eq "Cold"}]
    instop $wv Open
} elseif {$temp eq "Warm"} {
    set wvs [findRelatedWhere $self ~R3 {$ValveID eq "Hot" ||\
            $ValveID eq "Cold"}]
    forAllRefs wv $wvs {
        instop $wv Open
    }
}
----

'''

// %Action ClothesTub Full
.Full Activity
----
# Disable the sensor
select one wls related by self->R5[WLS]
wls.Disable()
# Close all water valves
select many wvs related by self->R3[WV]
    where (ValveID = 'Hot' OR ValveID = 'Cold')
foreach wv in wvs
    wv.Close()
endfor
# Inform the washing machine
select one wm related by self->R1[WM]
signal Full to wm
----

.Full Implementation
[source,tcl]
----
<<CT full activity>>=
set wls [findRelated $self ~R5]
instop $wls Disable
set wvs [findRelatedWhere $self ~R3 {$ValveID eq "Hot" || $ValveID eq "Cold"}]
forAllRefs wv $wvs {
    instop $wv Close
}
set wm [findRelated $self R1]
signal $wm Full
----

'''

// %Action ClothesTub Agitating
.Agitating Activity
----
# Start the agitator motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Agitator')
mtr.Start()
----

.Agitating Implementation
[source,tcl]
----
<<CT agitating activity>>=
set mtr [findRelatedWhere $self ~R2 {$MotorID eq "Agitator"}]
instop $mtr Start
----

'''

// %Action ClothesTub Emptying
.Emptying Activity
----
# Stop the motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Agitator')
mtr.Stop()
# Open the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Open()
# Start the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Start()
# Enable the sensor
select one wls related by self->R5[WLS]
wls.Enable()
----

.Emptying Implementation
[source,tcl]
----
<<CT emptying activity>>=
set mtr [findRelatedWhere $self ~R2 {$MotorID eq "Agitator"}]
instop $mtr Stop

set wv [findRelatedWhere $self ~R3 {$ValveID eq "Drain"}]
instop $wv Open

set mtr [findRelatedWhere $self ~R2 {$MotorID eq "Pump"}]
instop $mtr Start

set wls [findRelated $self ~R5]
instop $wls Enable
----

'''

// %Action ClothesTub Spinning
.Spinning Activity
----
# Open the drain valve
select one wv related by self->R2[WV]
     where (ValveID = 'Drain')
wv.Open()
# Start the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Start()
# Start the spin motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Spin')
mtr.Start()
----

.Spinning Implementation
[source,tcl]
----
<<CT spinning activity>>=
set wv [findRelatedWhere $self ~R3 {$ValveID eq "Drain"}]
instop $wv Open

set mtr [findRelatedWhere $self ~R2 {$MotorID eq "Pump"}]
instop $mtr Start

set mtr [findRelatedWhere $self ~R2 {$MotorID eq "Spin"}]
instop $mtr Start
----

'''

// %Action ClothesTub "Stopping Spin"
.Stopping Spin Activity
----
# Stop the motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Spin')
mtr.Stop()
# Stop the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Stop()
# Close the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Close()
----

.Stopping Spin Implementation
[source,tcl]
----
<<CT stopping spin activity>>=
set mtr [findRelatedWhere $self ~R2 {$MotorID eq "Spin"}]
instop $mtr Stop

set mtr [findRelatedWhere $self ~R2 {$MotorID eq "Pump"}]
instop $mtr Stop

set wv [findRelatedWhere $self ~R3 {$ValveID eq "Drain"}]
instop $wv Close
----

=== Water Valve Class

[source,tcl]
----
<<WV class>>=
class WaterValve {
    attribute ValveID string -id 1
    attribute MachineID string
    reference R3 ClothesTub -link MachineID

    instop Open {} {
        <<WV open operation>>
    }
    instop Close {} {
        <<WV close operation>>
    }
}

association R3 WaterValve 1..n--1 ClothesTub
----

=== Motor Class

[source,tcl]
----
<<MTR class>>=
class Motor {
    attribute MotorID string -id 1
    attribute MachineID string
    reference R2 ClothesTub -link MachineID

    instop Start {} {
        <<MTR start operation>>
    }
    instop Stop {} {
        <<MTR stop operation>>
    }
}

association R2 Motor 1..n--1 ClothesTub
----

=== Water Level Sensor

[source,tcl]
----
<<WLS class>>=
class WaterLevelSensor {
    attribute MachineID string -id 1
    reference R5 ClothesTub -link MachineID

    instop Enable {} {
        <<WLS enable operation>>
    }
    instop Disable {} {
        <<WLS disable operation>>
    }
}

association R5 WaterLevelSensor 1--1 ClothesTub
----

=== Domain Operations

In this section we show the code for our two domain operations.
We assume that there is some entity in our overall system that
will invoke these operations.
To make our example run,
we will contrive to make that happen
even though we do not intend to supply a user interface, _per se_.

==== Start Washer

To start a washing machine we must supply the identifier of the
washer so we can know which one is to be started.
Although our instance population only included a single WashingMachine
instance,
as we stated before, the models will run with an arbitrary number
of washing machine instances.

The implementation of the operation first searches all the instances
of WashingMachine to find the correct one to start.
It is possible to request an unknown washer to start.
After finding the correct instance,
the *Start* event will kick things off.

(((proc,domain operation,startWasher)))

[source,tcl]
----
<<domain operations>>=
operation startWasher {washer} {
    set wm [WashingMachine findWhere {$MachineID eq $washer}]
    if {[WashingMachine::instop $wm isEmptyRef]} {
        error "unknown washer, \"$washer\""
    }

    WashingMachine::instop $wm signal Start

    return
}
----

==== Select Cycle

On the class diagram,
relationship +R1+ determines which Washing Cycle will be used to
control the operations.
Selecting a wash cycle mean we must reform the +R1+ relationship,
_i.e._ unlink the existing cycle and link in a different one.
The implementation of the +selectCycle+ domain operation does just that.

(((proc,domain operation,selectCycle)))

[source,tcl]
----
<<domain operations>>=
operation selectCycle {washer cycle} {
    set wm [WashingMachine findWhere {$MachineID eq $washer}]
    if {[WashingMachine::instop $wm isEmptyRef]} {
        error "unknown washer, \"$washer\""
    }

    set wc [WashingCycle findWhere {$CycleType eq $cycle}]
    if {[WashingCycle::instop $wc isEmptyRef]} {
        error "unknown cycle, \"$cycle\""
    }

    R4 link $wm $wc

    return
}
----

=== External Operations

For external operations,
we don't code the operation itself,
it is after all _external_.
But we must define its interface and invoke the operation at the
appropriate time in our own processing.

For our example,
there are six external operations that are assumed,
two each for the motor, valve and water level sensor.
Each of these operations passes an identifying value to the operation.
This allows the external operations to determine exactly what is
is to operate upon.
We fill in the external operation invocations below.

[source,tcl]
----
<<MTR start operation>>=
MOTOR::start [readAttribute $self MotorID]

<<MTR stop operation>>=
MOTOR::stop [readAttribute $self MotorID]

<<WV open operation>>=
VALVE::open [readAttribute $self ValveID]

<<WV close operation>>=
VALVE::close [readAttribute $self ValveID]

<<WLS enable operation>>=
SENSOR::enable [readAttribute $self MachineID]

<<WLS disable operation>>=
SENSOR::disable [readAttribute $self MachineID]
----

=== Initial Instance Population

[source,tcl]
----
<<initial instance population>>=
class WashingCycle\
    {CycleType WashWaterTemp RinseWaterTemp WashDuration RinseDuration\
             SpinDuration AgitationSpeed SpinSpeed} {

    Normal Cold Cold 20 10 10 Medium Medium
    Whites Hot Cold 20 10 20 High High
    PermPress Warm Cold 15 10 15 Medium Medium
    Delicate Cold Cold 15 10 10 Low Low
}
----

We intend to have only a single WashingMachine instance but
note that the model will run correctly regardless of how many washing
machines we are trying to control.
We can also link up our washer with its initial washingCycle.

[source,tcl]
----
<<initial instance population>>=
class WashingMachine {MachineID CycleType} {WasherOne Normal}
----

The class model dictates that each washer have exactly one ClothesTub.

[source,tcl]
----
<<initial instance population>>=
class ClothesTub MachineID WasherOne
----

[source,tcl]
----
<<initial instance population>>=
class Motor\
    {MotorID    MachineID} {
    Pump        WasherOne
    Agitator    WasherOne
    Spin        WasherOne
}
----

Each washing machine, also by design,
has three valves to control hot and cold water and draining.

[source,tcl]
----
<<initial instance population>>=
class WaterValve\
    {ValveID    MachineID} {
    Hot         WasherOne
    Cold        WasherOne
    Drain       WasherOne
}
----

Finally, each washing machine has a sensor that can determine
whether the tub is full or empty.

[source,tcl]
----
<<initial instance population>>=
class WaterLevelSensor MachineID WasherOne
----

=== Stubbing the External Operations

For the MOTOR and VALVE operations we will content ourselves to simply
log the fact that they were invoked.
The control that is implied by the operation is ``open loop'' and no
feed back is assumed.
So when we say ``Open a Valve'' we will assume that the value does what
it is told.
This leads us to the following implementation.

[source,tcl]
----
<<external operation stubs>>=
namespace eval ::wmctrl::Motor::MOTOR {
    ::logger::initNamespace [namespace current] info
    proc start {motor} {
        log::info "starting motor, \"$motor\""
    }
    proc stop {motor} {
        log::info "stopping motor, \"$motor\""
    }
}

namespace eval ::wmctrl::WaterValve::VALVE {
    ::logger::initNamespace [namespace current] info
    proc open {valve} {
        log::info "opening valve, \"$valve\""
    }
    proc close {valve} {
        log::info "closing valve, \"$valve\""
    }
}
----

The SENSOR operations present a bit more difficulty to stub.
In this case,
there _is_ feedback from the interaction.
We must signal back the state of water level as being full or empty.
So in some sense we must _simulate_ the action of the sensor.
If you carefully examine the example,
you find that we can assume the tub starts empty and each time the
sensor is enabled we are trying to detect the opposite state of the tub.
So enabling the sensor on an empty tub means we are looking for when
the tub goes full and _vice versa_.
So it sufficient to simulate the sensor to simply toggle the tub state and then
announce the new state at some time when we think the new state will have been
reached.
We will delay the announcement of the new state for some time
to simulate the water filling or draining.
To make the example run in reasonable times,
we assume the tub will fill or empty in 3 seconds.
That's quick!

[source,tcl]
----
<<external operation stubs>>=
namespace eval ::wmctrl::WaterLevelSensor::SENSOR {
    ::logger::initNamespace [namespace current] info
    variable sensorState TubEmpty
    variable sensorEvent

    proc enable {machine} {
        log::info "enable sensor on machine, \"$machine\""

        variable sensorState
        variable sensorEvent

        set newState\
            [expr {$sensorState eq "TubEmpty" ? "TubFull" : "TubEmpty"}] ; # <1>
        set sensorEvent [after 3000 [namespace code\
            [list trigger $machine $newState]]] ; # <2>
    }

    proc disable {machine} {
        log::info "disable sensor on machine, \"$machine\""
        variable sensorEvent
        after cancel $sensorEvent
    }
----
<1> Toggle the tub state.
<2> Use the +after+ _ms_ form of the command to delay announcing the new
state.

Delivering the indication that the Water Level Sensor has detected
a change in the water level really means we want to send the
appropriate ClothesTub instance either the *TubFull* or *TubEmpty*
event.
Conveniently, we have been keeping track of the sensor state using
string named the same as the event we intend to deliver.
So all we have to do is search for the correct Washing Machine that
matches the sensor, navigate +R1+ to the ClothesTub and signal an event.

[source,tcl]
----
<<external operation stubs>>=
    proc trigger {machine value} {
        variable sensorState
        set sensorState $value

        set wm [::wmctrl::WashingMachine findWhere {
            $MachineID eq $machine
        }]
        set ct [::rosea::InstCmds::findRelated $wm ~R1]
        ::rosea::InstCmds::signal $ct $sensorState
    }
}
----

Before we can start the example running,
we have to figure out how we are going to stop it.
Recall that to dispatch state machine events we must enter the
Tcl event loop.
We will use the +vwait+ command to do that.
But we need some way to break out of the event loop
so that we can look at the results of the run.
To do that we will add setting a global variable to the
state activity of the Stopping Spin state in the ClothesTub class.
This state is entered when the cycle is done
and it is our intent to regain control of the execution flow after
each washing cycle.
Note that we are adding this synchronization solely to be able to
run one washing cycle in our example.
An actual application would most likely run forever or exit based
on some interaction with the user.

[source,tcl]
----
<<CT stopping spin activity>>=
set ::done 1
----

=== Running the Example

An finally, yes truly finally,
we are in a position to drive the domain operations to select a cycle and
run the washer through the cycle.
We will turn on tracing so we can see what happened.

[source,tcl]
----
<<running the example>>=
rosea traceControl on

wmctrl selectCycle WasherOne PermPress
puts "**** Start Run"
wmctrl startWasher WasherOne

vwait ::done ; # <1>

puts "**** Finish Run"
rosea traceControl off

puts "**** Trace Begin"
puts [rosea formatTraces [rosea decodeAllTraces]]
puts "**** Trace End"

rosea diagAllTraces images/wmctrl-seqdiag.diag span_height 7 ; # <2>
----
<1> Enter the Tcl event loop.
State machine events will then be dispatched and the washer will operate.
<2> Draw a sequence diagram of the example run.
This will allow us to compare the textual log with a graphic containing
the same information.

=== Example Run Results

After running the example we obtain the following output.

[literal]
.Output From Running the Example
--
include::wmctrl-trace.txt[]
--

The first section is the set of log messages that show the interaction
with the motors, values and sensors.
This amounts to a trace of the external side effects that the domain
produces on the washing machine hardware.
The second portion show the chronological trace of the state machine
event dispatch.
The first column of the trace is the time of day and the second column is
the time difference between the last trace entry (in the form of _s.ms.us_).
The remainder of the trace show the details of the event dispatch.
The first portion of the _Transition_ trace shows the event being
dispatched from a source instance to a target instance.
The state machine transition of the target instance,
from current state to new state,
is shown after the ``==>'' symbol.
Instances are shown with the set of attribute name / value pairs that
form the identifier contained in the instance reference.

The figure below shows the trace information in sequence diagram form.
This diagram was produced using +rosea diagAllTraces+ to generate
a file suitable for the +seqdiag+ program to render a graphic.

image::wmctrl-seqdiag.svg[title="Example Sequence Diagram"]

The track labeled *EXTERNAL* shows events that originate outside of the
domain.
The example begins with a *Start* event being sent to an instance of the
*WashingMachine* class.
The other external events arise from the Water Level Sensor detecting
the status of the Clothes Tub.
The clothes are cleaned by a sequence of events exchanged between the
*WashingMachine* and *ClothesTub* instances to coordinate the steps of the
washing cycle to clean clothes.
Although the sequence diagram does not tell the whole story of the
program execution (_e.g._ the side effects caused the state activities
is often very important),
it does go a long way to showing the chronological unfolding of the
example's execution.

== Code Organization

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted and licensed in the same manner as
Tcl itself.

[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<rosea.tcl>>=
<<copyright info>>

package require Tcl 8.6

package require logger
<<required packages>>

namespace eval ::rosea {
    <<rosea exports>>
    namespace ensemble create

    variable version 1.0a2

    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    <<rosea commands>>
    <<rosea namespace layout>>

    namespace path ::rosea::Helpers
    namespace import ::rosea::Config::ConfigEvaluate
}

package provide rosea $::rosea::version
----

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded rosea 1.0a2 [list source [file join $dir rosea.tcl]]
----

=== Unit Tests

[source,tcl]
----
<<rosea.test>>=
<<copyright info>>

package require Tcl 8.6
package require cmdline
package require logger

<<required packages>>

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

logger::setlevel $options(level)

source ../src/rosea.tcl
chan puts "testing rosea version: [package require rosea]"

package require tcltest
eval tcltest::configure $argv

namespace eval ::rosea::test {
    namespace import ::tcltest::*
    ::logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar

    <<test utility procs>>
    <<helper command tests>>
    <<class command tests>>
    <<relationship command tests>>
    <<instance command tests>>
    <<dispatch command tests>>
    <<config command tests>>
    <<trace command tests>>

    cleanupTests
}
----


////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

=== Example Code

[source,tcl]
----
<<wmctrl.tcl>>=
<<copyright info>>

package require Tcl 8.6
package require logger

source rosea.tcl

rosea configure {
    domain wmctrl {
        <<domain operations>>
        <<WM class>>
        <<WC class>>
        <<CT class>>
        <<WV class>>
        <<MTR class>>
        <<WLS class>>
    }
}

rosea generate

rosea populate {
    domain wmctrl {
        <<initial instance population>>
    }
}

<<external operation stubs>>
<<running the example>>
----

=== Reference Documentation

[source,tcl]
----
<<rosea.man>>=
[manpage_begin rosea n 1.0a2]
[comment {
<<copyright info>>
}]
[moddesc "XUML Data and Execution Architecture"]
[titledesc "Relation Oriented Software Execution Architecture"]
[copyright "2014 by G. Andrew Mangogna"]
[require rosea [opt 1.0]]
[description]
<<manual description>>
[section "Package Commands"]
[list_begin definitions]
[usage "Package Commands"]
<<manual package commands>>
[list_end]
[section "Configuration Commands"]
[list_begin definitions]
[usage "Configuration Commands"]
<<manual configuration commands>>
[list_end]
[subsection "Domain Configuration Commands"]
[list_begin definitions]
[usage "Domain Configuration Commands"]
<<manual domain configuration commands>>
[list_end]
[subsection "Class Configuration Commands"]
[list_begin definitions]
[usage "Class Configuration Commands"]
<<manual class configuration commands>>
[list_end]
[subsection "State Model Configuration Commands"]
[usage "State Model Configuration Commands"]
[list_begin definitions]
<<manual statemodel configuration commands>>
[list_end]
[subsection "Assigner Configuration Commands"]
[list_begin definitions]
[usage "Assigner Configuration Commands"]
<<manual assigner configuration commands>>
[list_end]
[subsection "Population Commands"]
[list_begin definitions]
[usage "Population Commands"]
<<manual populate commands>>
[list_end]
[section "Architecture Commands"]
[subsection "Class Commands"]
[list_begin definitions]
[usage "Class Commands"]
<<manual architecture class commands>>
[list_end]
[subsection "Relationship Commands"]
[list_begin definitions]
[usage "Relationship Commands"]
<<manual architecture relationship commands>>
[list_end]
[subsection "Instance Commands"]
[list_begin definitions]
[usage "Instance Commands"]
<<manual architecture instance commands>>
[list_end]
[manpage_end]
----

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk defintion ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

include::bibliography.txt[]

[index]
.Index
