// vim:set syntax=asciidoc:
= Relation Oriented Software Execution Architecture

[abstract]
This document describes a Tcl package named, +rosea+.

== Introduction [[introduction,Introduction]]

* XUML software architecture
* Literate program

=== Design Strategy [[design-strategy,Design Strategy]]

Design Strategy

* Why use TclRAL?

==== Comparing Approaches [[comparing-approaches,Comparing Approaches]]

Comparing Approaches

* TclRAL and a bunch of procedures
* TclOO based
** each relvar a class
** each tuple an object
** large amount of OO machinery that is not used
** problems with lifetimes of object commands
* namespace ensemble based

=== Namespace Ensemble Approach [[namespace-ensemble-approach,Namespace Ensemble Approach]]
Namespace Ensemble Approach

* No unnecessary OO machinery that is not used.
* Convenient way to encapsulate a domain.

Parts of the puzzle

* procedures in the +rosea+ package to handle common XUML semantics
* configuration language to compute the mechanisms data structures and
layout the domain in the correct way.

Mapping concepts to Tcl implementation constructs.

["blockdiag",title="Basic Mapping of XUML Concepts"]
------
blockdiag {
    class longnode [width=150]
    domain [label="Domain"]
    namespace [label="Namespace"]
    class [label="XUML Class"]
    relvar [label="TclRAL relvar"]
    instance [label="XUML Instance"]
    tuple [label="Tuple in a relvar"]
    relationship [label="XUML Relationship"]
    constraint [label="TclRAL constraint"]
    classop [label="Class Operation"]
    clenscmd [label="Ensemble Subcommand", class=longnode]
    domop [label="Domain Operation"]
    domenscmd [label="Ensemble Subcommand", class=longnode]
    instop [label="Instance Operation"]
    inenscmd [label="Ensemble Subcommand", class=longnode]
    stateact [label="State Activity"]
    proc [label="Tcl proc"]

    domain -> namespace
    class -> relvar
    instance -> tuple
    relationship -> constraint
    domop -> domenscmd
    classop -> clenscmd
    instop -> inenscmd
    stateact -> proc
}
------

=== Relation Values, Relvars and Instance References -- Oh My!

Although the ideas of variables and values are well know,
it is worth clarifying the differences between variables and
values and how TclRAL constructs are involved.
Some of the confusion in this area arise from the conventional
use of symbol names in programing languages to stand for both
the variable and its value.

For example, consider the following ``C'' code.

[source,c,numbered]
----
int counter ;

counter = 27 ;

counter = counter + 3 ;
----

As line 1 shows, +counter+ is clearly a variable of integer type.
It is assigned the _value_ 27 on line 3.
Line 5 assigns the _value_ held by +counter+ plus the _value_ +3+ into the
_variable_ +counter+.
In ``C'' and many other languages, the interpretation of the symbol +counter+
depends upon whether it stands for a value in an expression
or as the target of an assignment.
In ``C'' parlance, the meaning is determined by whether +counter+ is
used as
http://en.wikipedia.org/wiki/Value_(computer_science)[an _lvalue_ or an _rvalue_].
Normally, we do not speak in such ultra-precise terms since context
shows whether we are interested in the _value_ contained by the _variable_
or whether we are talking about the memory allocated to the _variable_.

A _relation value_ is defined as a _heading_ and a _body_
which is a set of tuples that correspond to the heading.
The heading consists of a set of named attributes and their corresponding
data types.
The set of tuples that form the body of the relation value form a set,
_i.e._ there are no duplicated tuples.
In TclRAL, a relation value has a string representation
(like all well behaved Tcl values)
that is a two element list representing the heading and the body.
Relation values in TclRAL are first class Tcl values and consequently
may be assigned to an ordinary Tcl variable and undergo the normal
lifecycle of values.
This latter point is important as we shall see later.

A _relation variable_ (or relvar) is a special type of variable
that holds a _relation value_.
The concept of a relvar is supplied by TclRAL and a relvar is _not_ an
ordinary Tcl variable.
TclRAL maintains a _shadow_ variable system for relvars.
The naming conventions follow those of ordinary Tcl variables in that
they can be qualified using namespace syntax.
The reason that relation variables are distinct from Tcl variables is that they
are also subject to _constraints_ for identity and referential integrity.
This is one of the major distinguishing aspects of relvars.
TclRAL has the subcommand, +relvar+, which operates directly on relvars and
a distinct subcommand, +relation+, that operates on relation values.

However, we still need some way to refer to a particular tuple in a
relvar.
For example,
in XUML events are signaled to instances.
In our mapping of XUML concepts to TclRAL,
an instance corresponds to a particular tuple in a relvar.
We will also find it convenient to refer to sets of tuples when, for example,
set search for those tuples that meet some criteria.
Consequently, we define an _instance reference_ concept.
In the relational view,
the only way that you can refer to tuples in the relation values contained
in relvars is by the values of identifying attributes.
There is no notion of indexing and order within the relation values is
not specified.
Each relvar must have at least one identifier.
An identifier is a set of attributes (often a single attribute but
not always), the values of which must be distinct.
So to refer to an instance we need to know the relvar in questions and
the values of the attributes that constitute an identifier.
So we will represent an instance reference as a two element list as follows:

* A fully qualified relvar name.
* A relation value whose heading contains those attributes of the
relvar that correspond to an identifier.

This representation has several useful characteristics.

* An empty relation value indicates the _nil_ reference.
* The cardinality of the relation value can be greater than one and as
such represents a reference to a set of instances.

So we do not need to distinguish between an instance reference
and an instance reference set as distinct entities
is often done in architectures that target staticly typed languages.

We will need several operations on instance references.

==== ToRef Command

The +ToRef+ command takes a fully qualified relvar name and a relation value
that is a subset of the value held in the relvar and returns an instance
reference to the values.

(((rosea,Helper,ToRef)))

[source,tcl]
----
<<helper commands>>=
proc ToRef {relvar relvalue} {
    tailcall list $relvar [relation project $relvalue\
        {*}[lindex [relvar identifiers $relvar] 0]] ; # <1>
}
----
<1> Let's step through this one command at a time.
* +relvar identifiers+ returns a list of the identifiers of the relvar.
Since each relvar has at least one identifier, we can always index off
the first identifier.
* +relation project+ returns a new relation value that contains only
the attributes requested.
In this case we are asking for those attributes that form one of the
identifiers.
* We compose the two element list that defines an instance reference
and we can use +tailcall+ since this is the last command in the procedure.

[source,tcl]
----
<<helper command tests>>=
test ToRef-1.0 {
    Compute a reference to a relvar tuple
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
} -cleanup {
    relvar unset A
} -body {
    set value [relation create {Attr1 int Attr2 string} {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }]
    ::rosea::Helpers::ToRef [namespace current]::A $value
} -result {::rosea::test::A {{Attr1 int} {{Attr1 20} {Attr1 40}}}} -match ref
----

==== Dereferencing an Instance

We will also need to obtain the tuples referenced by an instance reference.
In other words we will need to derefence the instance.
The +deRef+ command takes an instance reference and returns a relation
value that contains all the tuples from the associated relvar that
match the identifying attribute values contained in the reference.

(((rosea,Helper,DeRef)))
[source,tcl]
----
<<helper commands>>=
proc deRef {instref} {
    tailcall relation semijoin [lindex $instref 1]\
        [relvar set [lindex $instref 0]] ; # <1>
}
----
<1> Dereferencing the instance is just a simple matter of ++semijoin++ing the
relation value in the instance reference to the value contained in the
relvar.
In TclRAL, +semijoin+ returns a relation value whose heading
matches that of its final argument which in our case is that of the
referenced relvar value.

[source,tcl]
----
<<helper command tests>>=
test deRef-1.0 {
    Dereference to get a relation value
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }
} -cleanup {
    relvar unset A
} -body {
    set ref [list [namespace current]::A {{Attr1 int} {{Attr1 40}}}]
    rosea::Helpers::deRef $ref
} -result {{Attr1 int Attr2 string} {{Attr1 40 Attr2 bar}}} -match relation
----

==== Counting References

Since commands that search for instances return instance references
we will need some commands that can determine if we are indeed referring
to anything.

(((rosea,Helper,isNilRef)))
[source,tcl]
----
<<helper commands>>=
proc isNilRef {instref} {
    tailcall relation isempty [lindex $instref 1]
}
----

Note that in relational algebra the empty relation, _i.e._ what we
have call here the _nil reference_ is perfectly valid.
It is well defined that dereferencing a nil reference simply
returns a relation values that contains no tuples.
Despite our use of the _nil_ term,
it should _not_ be mistaken for the same concept in most programming
languages where +nil+ is usually implemented as a special
address and dereferencing the +nil+ pointer is not allowed.

(((rosea,Helper,isNotNilRef)))
[source,tcl]
----
<<helper commands>>=
proc isNotNilRef {instref} {
    tailcall relation isnotempty [lindex $instref 1]
}
----

(((rosea,Helper,refMultiplicity)))
[source,tcl]
----
<<helper commands>>=
proc refMultiplicity {instref} {
    tailcall relation cardinality [lindex $instref 1]
}
----

(((rosea,Helper,isRefSingular)))
[source,tcl]
----
<<helper commands>>=
proc isRefSingular {instref} {
    expr {[refMultiplicity $instref] == 1}
}
----

==== Instance Reference Equality

(((rosea,Helper,isRefEqual)))
[source,tcl]
----
<<helper commands>>=
proc isRefEqual {ref1 ref2} {
    lassign ref1 relvar1 inst1
    lassign ref2 relvar2 inst2
    return [expr {$relvar1 eq $relvar2 &&\
            [relation is $inst1 == $inst2]}]
}
----

==== Iterating on References

We will find it convenient to iterate on the instances referred to
by an instance reference.
Recall, that an instance reference can refer to many tuples
and there are times when we want to visit each instance and run
some code.
As is typical in Tcl and following the pattern of the +foreach+
command,
we construct a control structure procedure to perform the iteration.
The +forAllRefs+ command assigns an instance reference from a set
to a variable and executes a script for each instance.
Each iteration insures that the instance reference assigned to the
variable references only a single tuple.

(((rosea,Helper,forAllRefs)))
[source,tcl]
----
<<helper commands>>=
proc forAllRefs {varname instref body} {
    lassign $instref relvar refs
    upvar 1 $varname inst
    relation foreach ref $refs {
        set inst [list $relvar $ref]
        uplevel 1 $body
    } ; # <1>
    return
}
----
<1> The key command here is +relation foreach+ which performs the
iteration, one tuple at a time.

=== Navigating the Model

In the relation model of data,
one can specify a set of declarative constraints that enforce
a form of integrity constraint on the relvar values.
For TclRAL,
the form of these constraints was specifically design to match
those needed by XUML.
From a relational algebra point of view,
the constraints declare the multiplicity and conditionality of
the association between tuples in relvars.

From an XUML point of view,
model relationships enforce both referential integrity and provide
a way to navigate around the class data.
It is common for state activities to need to obtain read and update
data in the model and to use the relationship declarations
of the model to find related instances.
Ultimately for an architecture based on relational algebra,
navigating the XUML class model via relationships
must be translated into a sequence of +semijoin+ operations.
In this section we discuss the concepts and syntax for accomplishing
that.

Conventionally,
XUML action languages specify the relationship navigation
by giving the relationship name and the destination class name, _e.g._

====
self -> R23[MOTOR]
====

would be a statement to select the instance across +R23+ that are
from the +MOTOR+ class.
This technique has an ambiguity for reflexive relationshipsfootnote:[
A reflexive relationship is one formed between a class and itself]
as it gives no way to determine the direction of the traversal.
This has usually been resolved by using the relationship annotation
from the class model.

However, we specifically avoid using the model annotation to disambiguate
the reflexive relationship case.
Changing model annotation should not invalidate action language statements.
The approach we adopt in +rosea+ is to give each relationship an
explicit direction and to use the destination class only in those
cases where the relationship type allows for multiple paths.
We will specify navigation in forward direction using the relationship
name, _i.e._ +R1+, and in the reverse direction using the relationship
prefixed by a tilde character, _i.e._ +~R1+.

We will consider each type of relationship and show how the use of
a direction and sometimes a destination class allows for the navigation
of the class model.
Note also that this choice of specifying the relationship navigation
has no bearing on the XUML view of relationships in general.
We are not implying that the concept of a direction is a model level concept.
It is a particular technique that will be used as part of the syntax
for specifying the navigation operations for the +rosea+ archiecture.

==== Simple Associations

The figure below shows the case of a simple associative
relationship.
We choose the direction of the relationships to
be the same as the direction of reference.
So we deem the source of the navigation to be the class
that contains the referential attributes and the destination of
the navigation to be the referred to class.
For the case of singular relationships,
the choice of where to place the referential attributes is sometimes
arbitrary,
but wherever the analyst has placed the referential attribute determines
the direction of the relationship.

image::assoc-link.pdf[title="Simple Associative Relationships"]

So, starting with an instance of +X+ we can find the related +Y+ instance
or instances by navigating across +R1+.
The reverse navigation from +Y+ to +X+ is across +~R1+.

==== Generalization

The figure below shows the case of a generalization relationship.
In a generalization,
the subclasses always contain the referential attributes and therefore
always refer to the superclass and the direction of a
generalization is always from the subclasses to the superclass.

image::partition-link.pdf[title="Generalization Relationship"]

So we can say that we navigate from a subclass, say +X+,
to the superclass, +S+, by +R1+.
In the case of navigating from the superclass to a subclass,
we will find it necessary to specify the destination class name
when navigating from superclass to subclass.
So navigation from +S+ to +Y+ is specified as +~R1 Y+.
Because of the nature of a generalization,
navigating from superclass to a specific subclass will result in at most
one instance (and possibly zero) being found and 
navigating from subclass to superclass results in exactly one found instance.

==== Associative Classes

image::correl-link.pdf[title="Associative Class Relationship"]

==== Architecture Link Information

image::link-classes.pdf[title="Link Information Class Diagram"]

=== Domain Organization [[domain-organization,Domain Organization]]

Domain Organization

["blockdiag",title="Namespace Organization for a Domain"]
------
blockdiag {
    class rvsetstyle [shape = roundedbox, stacked] ;
    class rvstyle [shape = roundedbox] ;
    class procstyle [shape = ellipse, stacked, width = 175, height = 50] ;

    domain [label = "::<domain name>", color = "#bbffb0"] ;
    relvars [label = "<class relvars>", class = "rvsetstyle"] ;
    classcmds [label = "<class ensemble\ncommands>", class = "procstyle"] ;
    relcmds [label = "<relationship\nensemble commands>",
        class = "procstyle"] ;
    arch [label = "::__ARCH", color = "#ffe870"] ;

    class1 [label = "::<class 1>", color = "#ffe870"] ;
    class2 [label = "::<class 2>", color = "#ffe870"] ;
    classdots [shape = "dots"] ;
    classN [label = "::<class N>", color = "#ffe870"] ;

    domain -> relvars, classcmds, relcmds,
            class1, class2, classdots, classN, arch ;
    domain -> classdots [style = "none"] ;

    c2dots [shape = "dots"] ;
    class2 -> c2dots ;
    cNdots [shape = "dots"] ;
    classN -> cNdots ;

    archinfo [label = "<arch relvars>", class = "rvsetstyle"] ;

    arch -> archinfo ;

    instance [label = "__<class>__INSTANCE", class = "rvstyle"] ;
    activity [label = "::__ACTIVITY", color = "#ff8b70"] ;
    classop [label = "::<class op procs>", class = "procstyle"] ;
    instop [label = "::<inst op procs>", class = "procstyle"] ;

    class1 -> instance, activity, classop, instop ;

    state [label = "::<state activity>", class = "procstyle"] ;

    activity -> state ;
}
------

==== Class Relvars
Class Relvars

==== Class Ensemble Commands
Class Ensemble Commands

==== Relationship Ensemble Commands
Relationship Ensemble Commands

==== Class Namespaces
Class Namespaces

==== Class Activity Procedures
Class Activities

==== Architecture Relvars

["blockdiag",title="Relvars Containing Architecture Information"]
------
blockdiag {
    class rvsetstyle [shape = roundedbox, stacked] ;
    class rvstyle [shape = roundedbox] ;

    archinfo [label = "<arch relvars>", class = "rvsetstyle"] ;

    trans [label = "__TRANSITION", class = "rvstyle"]
    istate [label = "__INITIALSTATE", class = "rvstyle"]
    deftrans [label = "__DEFAULTTRANS", class = "rvstyle"]
    term [label = "__TERMINAL", class = "rvstyle"]
    link [label = "__LINK", class = "rvstyle"]
    assoclink [label = "__ASSOCIATIONLINK", class = "rvstyle"]
    partlink [label = "__PARTITIONLINK", class = "rvstyle"]

    archinfo -> trans, istate, deftrans, term, link, assoclink, partlink ;
}
------

=== Package Organization [[package-organization,Package Organization]]

Package Organization

["blockdiag",title="Namespace Organization for a rosea Package"]
------
blockdiag {
    class ns1st [color= "#bbffb0"]
    class ns2nd [color= "#ffe870"]

    rosea [label="::rosea",class=ns1st]
    helpcmd [label="::Helpers",class=ns2nd]
    classcmd [label="::ClassCmds",class=ns2nd]
    instcmd [label="::InstCmds",class=ns2nd]
    relcmd [label="::RelCmds",class=ns2nd]
    configcmd [label="::Config",class=ns2nd]
    dispatchcmd [label="::Dispatch",class=ns2nd]
    tracecmd [label="::Trace",class=ns2nd]

    rosea -> helpcmd, classcmd, instcmd, relcmd, configcmd,
            dispatchcmd, tracecmd
}
------

== Package Procedures

In this section we begin showing all the procedures associated
with the +rosea+ run time itself.
These will be divided into sections that correspond to the figure
above that showed how the namespace for the packge would be organized.

We start with some preliminaries.
Since we are using TclRAL extensively,
we need to pull in the package.

[source,tcl]
----
<<required packages>>=
package require ral
package require ralutil
----

We will find it convenient to import some of the commands from
TclRAL since we will be using them repeatedly.

[source,tcl]
----
<<tclral imports>>=
namespace import ::ral::relvar
namespace import ::ral::relation
namespace import ::ral::tuple
namespace import ::ral::relformat
namespace import ::ralutil::pipe
----

The namespace is organized as shown <<package-organization,above>>.

[source,tcl]
----
<<rosea namespace layout>>=
<<helper commands namespace>>
<<class commands namespace>>
<<instance commands namespace>>
<<relationship commands namespace>>
<<dispatch commands namespace>>
<<configuration commands namespace>>
<<trace commands namespace>>
----

=== A Diversion for Testing

[source,tcl]
----
<<test utility procs>>=
proc refMatch {expected actual} {
    lassign $expected erelvar einst
    lassign $actual arelvar ainst
    return [expr {$erelvar eq $arelvar && [ral relation is $einst == $ainst]}]
}
customMatch ref [namespace current]::refMatch

proc relationMatch {expected actual} {
    return [::ral::relation is $expected == $actual]
}
customMatch relation [namespace current]::relationMatch
----

=== Class Commands

In this section we show the class oriented commands of +rosea+.
These commands are the target of the ensemble mappings for each
of the classes in a domain.
Class oriented commands fall into these categories:

* Commands that search for instances.
* Commands that create and destroy instances.
* Commands that update the value of the underlying relvar.

First we create the namespace where the commands will reside.

[source,tcl]
----
<<class commands namespace>>=
namespace eval ClassCmds {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers ; # <1>
    <<class commands>>
}
----
<1> The helper commands are used everywhere so it is convenient to
include them in the command resolution path.

==== Find All Instances

The simplest search for instances is just to return them all.
The +findAll+ command returns an instance reference that refers to
all the tuples of the relvar.

(((rosea,ClassCmds,findAll)))
[source,tcl]
----
<<class commands>>=
proc findAll {relvar} {
    tailcall ToRef $relvar [relvar set $relvar]
}
----

==== Find Instances by Their Identifier

Sometimes the values of the identifying attributes are known.
The +findById+ command returns a reference to at most one
tuple found in the relvar.

(((rosea,ClassCmds,findById)))
[source,tcl]
----
<<class commands>>=
proc findById {relvar args} {
    tailcall ToRef $relvar [relvar restrictone $relvar {*}$args]
}
----

[source,tcl]
----
<<class command tests>>=
test findById-1.0 {
    Find tuple by value of the identifier
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }
} -cleanup {
    relvar unset A
} -body {
    rosea::ClassCmds::findById [namespace current]::A Attr1 20
} -result {::rosea::test::A {{Attr1 int} {{Attr1 20}}}} -match ref
----

==== Find Instances Meeting a Criteria

The general case is to find instances based on the result of
evaluating an expression.
The +findWhere+ command takes an expression and returns an
instance reference for those tuples where the expression evaluates
to true.
During execution, the values of the attributes will be placed in Tcl
variable that have the same name as the attribute.
So the +expr+ argument may refer to those variables.

(((rosea,ClassCmds,findWhere)))
[source,tcl]
----
<<class commands>>=
proc findWhere {relvar expr} {
    tailcall ToRef $relvar [uplevel 1 [list ral relation restrictwith\
        [relvar set $relvar] $expr]]
}
----

[source,tcl]
----
<<class command tests>>=
test findWhere-1.0 {
    Find tuples based on an expression
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    } {
        Attr1 60 Attr2 baz
    }
} -cleanup {
    relvar unset A
} -body {
    rosea::ClassCmds::findWhere [namespace current]::A {
        $Attr1 > 20 && $Attr1 < 60
    }
} -result {::rosea::test::A {{Attr1 int} {{Attr1 40}}}} -match ref
----

==== More Testing Infrastructure

[source,tcl]
----
<<test utility procs>>=
proc setupDomain {name} {
    set domns [namespace current]::$name
    namespace eval $domns {}
    namespace eval ${domns}::__ARCH {}
    relvar create ${domns}::__ARCH::__STATE {
        Class string
        State string
    } {Class State}
    relvar create ${domns}::__ARCH::__INITIALSTATE {
        Class string
        State string
    } Class
    relvar create ${domns}::__ARCH::__LINK {
        Name            string
        Class           string
        Attrs           list
    } {Name Class}
    relvar create ${domns}::__ARCH::__ASSOCIATIONLINK {
        Name            string
        SrcClass        string
        DstClass        string
        PrevSrcClass    string
    } {Name SrcClass}
    relvar create ${domns}::__ARCH::__PARTITIONLINK {
        Name            string
        DstClass        string
        SrcClass        string
    } {Name DstClass}
    relvar partition ${domns}::__ARCH::R3\
        ${domns}::__ARCH::__LINK {Name Class}\
            ${domns}::__ARCH::__ASSOCIATIONLINK {Name SrcClass}\
            ${domns}::__ARCH::__PARTITIONLINK {Name DstClass}\
        
    relvar create ${domns}::__ARCH::__POLYMORPHICEVENT {
        Class           string
        Event           string
    } {Class Event}
}

proc cleanupDomain {name} {
    set domns [namespace current]::$name
    relvar constraint delete {*}[relvar constrain names ${domns}::*]
    relvar unset {*}[relvar names ${domns}::*]
    namespace delete $domns
}

proc addClass {domain class heading id} {
    set domns [namespace current]::$domain
    set idheading [list]
    foreach attr $id {
        lappend idheading $attr [dict get $heading $attr]
    }
    relvar create ${domns}::__${class}__INSTANCE\
        [concat $idheading [list __State string]]\
        $id
    relvar create ${domns}::$class $heading $id
}

proc addState {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__ARCH::__STATE $args
}

proc addInitialState {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__ARCH::__INITIALSTATE $args
}

proc addAssocLink {domain linkattrs assocattrs} {
    dict set linkattrs Class\
        [namespace current]::${domain}::[dict get $linkattrs Class]
    dict set assocattrs SrcClass\
        [namespace current]::${domain}::[dict get $assocattrs SrcClass]
    dict set assocattrs DstClass\
        [namespace current]::${domain}::[dict get $assocattrs DstClass]
    set prev [dict get $assocattrs PrevSrcClass]
    if {$prev ne {}} {
        dict set assocattrs PrevSrcClass [namespace current]::${domain}::$prev
    }

    relvar eval {
        relvar insert [namespace current]::${domain}::__ARCH::__LINK $linkattrs
        relvar insert [namespace current]::${domain}::__ARCH::__ASSOCIATIONLINK\
                $assocattrs
    }
}

proc addParitionLink {domain linkattrs partattrs} {
    dict set linkattrs Class\
        [namespace current]::${domain}::[dict get $linkattrs Class]
    dict set partattrs DstClass\
        [namespace current]::${domain}::[dict get $partattrs DstClass]
    dict set partattrs SrcClass\
        [namespace current]::${domain}::[dict get $partattrs SrcClass]
    relvar eval {
        relvar insert [namespace current]::${domain}::__ARCH::__LINK $linkattrs
        relvar insert [namespace current]::${domain}::__ARCH::__PARTITIONLINK\
                $partattrs
    }
}
----

==== Create an Instance

The +create+ command creates instances.
If the class has a state model, then the instance is placed in the
initial state.
The return value is a instance reference to the newly created instance.

(((rosea,ClassCmds,create)))
[source,tcl]
----
<<class commands>>=
proc create {relvar args} {
    set ref [ToRef $relvar [relvar insert $relvar $args]] ; # <1>
    lassign [SplitRelvarName $relvar] domain class
    set initstate [relvar restrictone ${domain}::__ARCH::__INITIALSTATE\
        Class $relvar] ; # <2>
    if {[relation isnotempty $initstate]} {
        CreateInstanceState $domain $class [relation extract $initstate State]\
                [lindex $ref 1]
    }
    return $ref
}
----
<1> Here we see the correspondence between an XUML class instance and
a tuple in a relvar.
The instance is create by inserting a tuple into the relvar.
<2> If there is a state model associated with the class,
then there will be an initial state defined.
In that case, we must add a tuple to the +\__<class>\__INSTANCE+
relvar so we can track the current state for event transitions.

[source,tcl]
----
<<class command tests>>=
test create-1.0 {
    Create an instance -- no state model
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
} -cleanup {
    cleanupDomain foo
} -body {
    rosea::ClassCmds::create [namespace current]::foo::c1 A1 20 A2 bar
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 20}}}} -match ref
----

==== Create an Instance In a Given State

(((rosea,ClassCmds,createin)))
[source,tcl]
----
<<class commands>>=
proc createin {relvar state args} {
    lassign [SplitRelvarName $relvar] domain class
    set initstate [relvar restrictone ${domain}::__ARCH::__STATE\
        Class $relvar State $state]
    if {[relation isempty $initstate]} {
        tailcall DeclError UNKNOWN_STATE $state $relvar
    }
    set ref [ToRef $relvar [relvar insert $relvar $args]]
    CreateInstanceState $domain $class $state [lindex $ref 1]
    return $ref
}
----

(((error code,UNKNOWN_STATE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_STATE   {unknown state, "%s", for class, "%s"}
----

[source,tcl]
----
<<class command tests>>=
test createin-1.0 {
    Create an instance in a given state
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addState foo Class c1 State Idle
    addInitialState foo Class c1 State Idle
} -cleanup {
    cleanupDomain foo
} -body {
    set ref [::rosea::ClassCmds::createin [namespace current]::foo::c1\
        Idle A1 40 A2 bar]
    set statetest [pipe {
        relvar restrictone ::rosea::test::foo::__c1__INSTANCE A1 40 |
        relation extract ~ __State
    }]
    expr {$statetest eq "Idle" &&\
        [refMatch {::rosea::test::foo::c1 {{A1 int} {{A1 40}}}} $ref]}
} -result {1}
----

We factor some common code to create the instance tuple that tracks
the state of the instance into a procedure.

[source,tcl]
----
<<class commands>>=
proc CreateInstanceState {domain class state value} {
    set tuple [concat\
        [tuple get [relation tuple $value]]\
        [list __State $state]\
    ]
    relvar insert ${domain}::__${class}__INSTANCE $tuple
    return
}
----

==== Asynchronous Instance Creation

(((rosea,ClassCmds,signal)))

[source,tcl]
----
<<class commands>>=
proc createasync {relvar event eventparams args} {
    set event [relvar restrictone\
        [namespace qualifiers $relvar]::__ARCH::__TRANSITIONEVENT\
        Class $relvar Event $event]
    if {[relation isempty $event]} {
        tailcall DeclError UNKNOWN_EVENT $event $relvar
    }
    set instref [createin $relvar @ {*}$args]
    ::rosea::InstCmds signal $instref $event {*}$eventparams
    return $instref
}
----

(((error code,UNKNOWN_STATE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_EVENT   {unknown event, "%s", for class, "%s"}
----

==== Delete an Instance

(((rosea,ClassCmds,delete)))

[source,tcl]
----
<<class commands>>=
proc delete {instref} {
    set deleted 0
    forAllRefs inst $instref {
        lassign $inst relvar ref
        incr deleted [relvar deleteone $relvar\
            [tuple get [relation tuple $ref]]]
    }
    return $deleted
}
----

=== Instance Commands

[source,tcl]
----
<<instance commands namespace>>=
namespace eval InstCmds {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers
    <<instance data>>
    <<instance commands>>
}
----

==== Finding Related Instances

[source,tcl]
----
<<instance data>>=
pipe {
    relvar set $DstClass |
    relation $op $related ~ -using $Attrs
} relatedQuery

pipe {
    relation semijoin $assoc $AssociationLink\
            -using {Name Name SrcClass PrevSrcClass} |
    relation join ~ $Link -using {Name Name SrcClass Class}
} nextlinkQuery

<<instance commands>>=
proc FindRelatedInsts {instref op args} {
    set srcrelvar [lindex $instref 0]
    lassign [SplitRelvarName $srcrelvar] domain

    namespace upvar ${domain}::__ARCH\
            __LINK Link\
            __ASSOCIATIONLINK AssociationLink\
            __PARTITIONLINK PartitionLink
    variable relatedQuery
    variable nextlinkQuery

    set related [deRef $instref]
    foreach linkage $args {
        lassign $linkage lname dst

        set linkclass [expr {$dst eq {} ? $srcrelvar : "${domain}::$dst"}]
        set link [relvar restrictone ${domain}::__ARCH::__LINK\
                Name $lname Class $linkclass]
        if {[ral relation isempty $link]} {
            tailcall DeclError UNKNOWN_LINKAGE $lname $linkclass
        }
        set assoc [relation join $AssociationLink $link\
                -using {Name Name SrcClass Class}]
        if {[relation isnotempty $assoc]} {
            relation assign $assoc SrcClass DstClass Attrs
            if {$SrcClass ne $srcrelvar} {
                tailcall DeclError PATH_ERROR $lname $SrcClass $DstClass\
                    $srcrelvar
            }

            set related [eval $relatedQuery]
            set assoc [eval $nextlinkQuery]
            if {[relation isnotempty $assoc]} {
                relation assign $assoc DstClass Attrs
                set related [eval $relatedQuery]
            }
        } else {
            set partition [relation join $PartitionLink $link\
                -using {Name Name DstClass Class}]
            relation assign $partition SrcClass DstClass Attrs
            if {$SrcClass ne $srcrelvar} {
                tailcall DeclError PATH_ERROR $linkage $srcrelvar
            }

            set related [eval $relatedQuery]
        }
        set srcrelvar $DstClass
    }

    return [list $srcrelvar $related]
}
----

(((error code,UNKNOWN_LINKAGE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_LINKAGE {unknown relationship, "%s", for class, "%s"}
PATH_ERROR      {relationship, "%s", from "%s" to "%s", does not start at "%s"}
----

[source,tcl]
----
<<instance commands>>=
proc findRelated {instref args} {
    tailcall ToRef {*}[FindRelatedInsts $instref semijoin {*}$args]
}

proc findUnRelated {instref args} {
    tailcall ToRef {*}[FindUnRelatedInsts $instref semiminus {*}$args]
}

proc findRelatedWhere {instref rchain expr} {
    lassign [FindRelatedInst $instref semijoin {*}$rchain] relvar insts
    tailcall ToRef $relvar [uplevel 1 ral relation restrictwith $insts $expr]
}

proc findUnRelatedWhere {instref rchain expr} {
    lassign [FindRelatedInst $instref semiminus {*}$rchain] relvar insts
    tailcall ToRef $relvar [uplevel 1 ral relation restrictwith $insts $expr]
}
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.0 {
    Navigate a relationship -- simple association
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addClass foo c2 {B1 int B2 string} B1
    addAssocLink foo {Name R1 Class c1 Attrs {A1 B1}}\
        {Name R1 SrcClass c1 DstClass c2 PrevSrcClass {}}
    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {::rosea::test::foo::c2 {{B1 int} {{B1 5}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.1 {
    Navigate a relationship -- multiple simple association
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addClass foo c2 {B1 int B2 string} B1
    addClass foo c3 {C1 int C2 string} C1

    addAssocLink foo {Name R1 Class c1 Attrs {A1 B1}}\
        {Name R1 SrcClass c1 DstClass c2 PrevSrcClass {}}
    addAssocLink foo {Name R2 Class c2 Attrs {B1 C1}}\
        {Name R2 SrcClass c2 DstClass c3 PrevSrcClass {}}

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
    rosea::ClassCmds::create [namespace current]::foo::c3 C1 5 C2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1 R2
} -result {::rosea::test::foo::c3 {{C1 int} {{C1 5}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.2 {
    Navigate a relationship -- unknown link
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1

    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {unknown relationship, "R1", for class, "::rosea::test::foo::c1"}\
-returnCodes error
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-1.3 {
    Navigate a relationship -- bad path
} -setup {
    setupDomain foo
    addClass foo X {A1 int A2 string} A1
    addClass foo Y {B1 int B2 string} B1
    addClass foo A {A1 int B1 int} {A1 B1}
    addClass foo c1 {A1 int A2 string} A1

    # Forward direction is from X -> Y via A
    addAssocLink foo {Name R1 Class X Attrs {A1 A1}}\
        {Name R1 SrcClass X DstClass A PrevSrcClass {}}
    addAssocLink foo {Name R1 Class A Attrs {B1 B1}}\
        {Name R1 SrcClass A DstClass Y PrevSrcClass X}
    addAssocLink foo {Name ~R1 Class Y Attrs {B1 B1}}\
        {Name ~R1 SrcClass Y DstClass A PrevSrcClass {}}
    addAssocLink foo {Name ~R1 Class A Attrs {A1 A1}}\
        {Name ~R1 SrcClass A DstClass X PrevSrcClass Y}
    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref {R1 A}
} -result {relationship, "R1", from "::rosea::test::foo::A" to\
    "::rosea::test::foo::Y", does not start at "::rosea::test::foo::c1"}\
-returnCodes error
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-2.0 {
    Navigate a relationship -- associative class
} -setup {
    setupDomain foo
    addClass foo X {A1 int A2 string} A1
    addClass foo Y {B1 int B2 string} B1
    addClass foo A {A1 int B1 int} {A1 B1}
    # Forward direction is from X -> Y via A
    addAssocLink foo {Name R1 Class X Attrs {A1 A1}}\
        {Name R1 SrcClass X DstClass A PrevSrcClass {}}
    addAssocLink foo {Name R1 Class A Attrs {B1 B1}}\
        {Name R1 SrcClass A DstClass Y PrevSrcClass X}
    addAssocLink foo {Name ~R1 Class Y Attrs {B1 B1}}\
        {Name ~R1 SrcClass Y DstClass A PrevSrcClass {}}
    addAssocLink foo {Name ~R1 Class A Attrs {A1 A1}}\
        {Name ~R1 SrcClass A DstClass X PrevSrcClass Y}

    set ref [rosea::ClassCmds::create [namespace current]::foo::X A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::Y B1 10 B2 bar
    rosea::ClassCmds::create [namespace current]::foo::A A1 5 B1 10
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref R1
} -result {::rosea::test::foo::Y {{B1 int} {{B1 10}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test findRelated-3.0 {
    Navigate a generalization
} -setup {
    setupDomain foo
    addClass foo S {S1 int S2 string} S1
    addClass foo X {X1 int X2 string} X1
    addClass foo Y {Y1 int Y2 string} Y1

    addAssocLink foo {Name R1 Class X Attrs {X1 S1}}\
        {Name R1 SrcClass X DstClass S PrevSrcClass {}}
    addParitionLink foo {Name ~R1 Class X Attrs {S1 X1}}\
        {Name ~R1 DstClass X SrcClass S}
    addAssocLink foo {Name R1 Class Y Attrs {Y1 S1}}\
        {Name R1 SrcClass Y DstClass S PrevSrcClass {}}
    addParitionLink foo {Name ~R1 Class Y Attrs {S1 Y1}}\
        {Name ~R1 DstClass Y SrcClass S}

    set ref [rosea::ClassCmds::create [namespace current]::foo::S S1 5 S2 baz]
    rosea::ClassCmds::create [namespace current]::foo::X X1 5 X2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::findRelated $ref {~R1 X}
} -result {::rosea::test::foo::X {{X1 int} {{X1 5}}}} -match ref
----

==== Signaling Instances

[source,tcl]
----
<<helper commands>>=
proc SelfInstRef {{level 2}} {
    upvar $level self srcself
    return [expr {[info exists srcself] ? $srcself : {}}]
}
----

[source,tcl]
----
<<instance commands>>=
proc signal {destset event args} {
    set srcref [SelfInstRef]
    if {[::rosea::Dispatch::MapPolymorphicEvent ::rosea::Dispatch::SignalEvent\
            $srcref $destset $event $args]} {
        return
    }
    ::rosea::Dispatch::SignalEvent $srcref $destset $event $args
}
----

[source,tcl]
----
<<instance commands>>=
proc delaysignal {time destset event args} {
    if {!([string is integer -strict $time] && $time >= 0)} {
        error "invalid time, $time"
    }
    set srcref [SelfInstRef]
    if {[::rosea::Dispatch::MapPolymorphicEvent\
            [list ::rosea::Dispatch::SignalDelayedEvent $time]\
            $srcref $destset $event $args]} {
        return
    }
    ::rosea::Dispatch::SignalDelayedEvent $time $srcref $destset $event $args
}
----

=== Dispatch Commands

[source,tcl]
----
<<dispatch commands namespace>>=
namespace eval Dispatch {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers ; # <1>
    <<dispatch data>>
    <<dispatch commands>>
}
----

[source,tcl]
----
<<dispatch commands>>=
proc MapPolymorphicEvent {frwdcmd srcref dstrefs event arglist} {
    lassign $dstrefs dstrelvar dstinsts ; # <1>
    set domain [namespace qualifiers $dstrelvar]
    set polyevent [relvar restrictone ${domain}::__ARCH::__POLYMORPHICEVENT\
        Class $dstrelvar Event $event]
    if {[relation isempty $polyevent]} {
        return false
    }

    variable polymapQuery
    set partitions [eval $polymapQuery] ; # <2>

    relation foreach inst $dstinsts { # <3>
        relation foreach partition $partitions {
            relation assign $partition
            relation foreach dstlink $DstLinks {
                relation assign $dstlink
                set related [relation semijoin $inst [relvar set $DstClass]\
                    -using $Attrs] ; # <4>
                if {[relation isnotempty $related]} {
                    {*}$frwdcmd $srcref [ToRef $DstClass $related] $event\
                            $arglist
                    break
                }
            }
        }
    }
    return true
}
----
<1> First we must determine if the event is polymorphic.
If not, then we just return and the event will be signaled as a
transition event.
<2> See query explanation <<polymapQuery,below>>.
<3> There are three nested iterations.
The outside loop iterates over the superclass instances
since we may be signaling several instances in the same call.
The next iteration is over all the hierarchies that orginate from
the superclass.
Typically, this is only one, but it can be several for a compound
generalization.
Finally, we iterate over all the subclass links.
<4> We must traverse the relationship to find the one subclass that is
actually linked and forward the event on to that one.
Once forwarding has happened, we can stop looking any futher since
we _know_ that there is exactly on subclass linked up to any given
superclass instance because the partition constraint enforces that.

[[polymapQuery,polymorphic event query]]
The essential query for dispatching a polymorphic event is to find the set of
hierarchies orginating at the source relvar.

[source,tcl]
----
<<dispatch data>>=
pipe {
    relvar set ${domain}::__ARCH::__PARTITIONLINK |
    relation restrictwith ~ {$SrcClass eq $dstrelvar} |
    relation join ~ [relvar set ${domain}::__ARCH::__LINK]\
        -using {Name Name DstClass Class} |
    relation group ~ DstLinks DstClass Attrs
} polymapQuery
----

This query is accomplished by finding all the partition link tuples that
originate at the relvar which is the target of the event signaling.
These are joined with the link superclass to pick up the attributes
that are used across the partition.
The result of the join is grouped so we may consider all the superclass to
subclass links for a given hierarchy.
We want to do this because we know that a superclass instance will reference
exactly one of subclass from among all the subclasses in the generalization and
it is to that subclass instance that the event will be forwarded.

The heading of result of this query will be:

[width="30%",options="header"]
|=========================
|Name  |SrcClass|DstLinks
|string|string  |Relation
|=========================

Where the +DstLinks+ is a relation valued attributefootnote:[That is what
the +group+ operation does]
with a heading of:

[width="30%",options="header"]
|==============
|DstClass|Attrs
|string  |list
|==============

[source,tcl]
----
<<test utility procs>>=
proc addPolymorphic {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__ARCH::__POLYMORPHICEVENT\
            $args
}

proc polysignal {srcref dstref event paramlist} {
    puts -nonewline [info level 0]
}
----

[source,tcl]
----
<<dispatch command tests>>=
test MapPolymorphicEvent-1.0 {
    Map a polymorphic event
} -setup {
    setupDomain bar
    addClass bar S {S1 int S2 string} S1
    addClass bar X {X1 int X2 string} X1
    addClass bar Y {Y1 int Y2 string} Y1

    addAssocLink bar {Name R1 Class X Attrs {X1 S1}}\
        {Name R1 SrcClass X DstClass S PrevSrcClass {}}
    addParitionLink bar {Name ~R1 Class X Attrs {S1 X1}}\
        {Name ~R1 DstClass X SrcClass S}
    addAssocLink bar {Name R1 Class Y Attrs {Y1 S1}}\
        {Name R1 SrcClass Y DstClass S PrevSrcClass {}}
    addParitionLink bar {Name ~R1 Class Y Attrs {S1 Y1}}\
        {Name ~R1 DstClass Y SrcClass S}

    addPolymorphic bar Class S Event e1
    set ref [rosea::ClassCmds::create [namespace current]::bar::S S1 5 S2 baz]
    rosea::ClassCmds::create [namespace current]::bar::X X1 5 X2 bar
} -cleanup {
    cleanupDomain bar
} -body {
    rosea::Dispatch::MapPolymorphicEvent [namespace current]::polysignal\
        {} $ref e1 {}
} -result {true} -output {::rosea::test::polysignal {} {::rosea::test::bar::X {{X1 int} {{X1 5}}}} e1 {}}
----

[source,tcl]
----
<<dispatch data>>=
variable event_queue [list]
variable event_counter 0
relvar create __SIGNAL {
    EventId int
    TimerId string
} EventId TimerId

<<dispatch commands>>=
proc SignalEvent {srcref destset event args} {
    variable event_queue
    variable event_counter
    forAllRefs destref $destset {
        set eventInfo [dict create\
            src $srcref\
            event $event\
            dest $destref\
            params $args\
        ]
        if {[isRefEqual $srcref $destref]} {
            for {set nsindex 0} {$nsindex < [llength $event_queue]}\
                    {incr nsindex} {
                set cmpevent [lindex $event_queue $nsindex]
                if {![isRefEqual [dict get $cmpevent src]\
                        [dict get $cmpevent dst]]} {
                    break
                }
            }
            set event_queue [linsert $event_queue $nsindex $eventInfo]
        } else {
            lappend event_queue $eventInfo
        }
        incr event_counter
        relvar insert __SIGNAL [list\
            EventId $event_counter\
            TimerId [::after 0 ::rosea::Dispatch::DispatchEvent $event_counter]\
        ]
    }
}
----

[source,tcl]
----
<<dispatch data>>=
relvar create __DELAYEDSIGNAL {
    SrcInstRef      list
    Event           string
    DstInstRef      list
    TimerId         string
    Expire          bignum
} {SrcInstRef Event DstInstRef}

<<dispatch commands>>=
proc CancelDelayedSignal {srcref event dstref} {
    namespace upvar ::rosea::Dispatch __DELAYEDSIGNAL DelayedSignal
    set sig [relation restrictwith $DelayedSignal {
            [isRefEqual $SrcInstRef $srcref] && $Event eq $event &&\
            [isRefEqual $DstInstRef $dstref]}]
    if {[relation isnotempty $sig]} {
        ::after cancel [relation extract $sig TimerId]
        ::rosea::Dispatch::DeleteDelayedSignal $srcref $event $dstref
    }
}

proc SignalDelayedEvent {time srcref destset event args} {
    if {!([string is integer -strict $time] && $time >= 0)} {
        error "invalid time, $time"
    }
    if {[MapPolymorphicEvent [list delaysignal $time] $destset $event\
            $args]} {
        return
    }
    set srcref [SelfInstRef]
    forAllRefs destref $destset {
        # Cancel any existing delayed signal that might have been in place.
        CancelDelayedSignal $srcref $event $destref
        ::rosea::Dispatch::CreateDelayedSignal $time $srcref $event $destref
    }
    return
}
----

[source,tcl]
----
<<dispatch commands>>=
proc CreateDelayedSignal {time srcref event dstref} {
    relvar insert __DELAYEDSIGNAL [list\
        SrcInstRef  $srcref\
        Event       $event\
        DstInstRef $destref\
        TimerId     [::after $time [list ::rosea::Dispatch::DelayedDispatch\
                    $srcref $event $destref $args]]\
        Expire      [expr {entier([clock milliseconds]) + entier($time)}]\
    ]
}

proc DeleteDelayedSignal {srcref event dstref} {
    relvar delete __DELAYEDSIGNAL dsig {
        [isRefEqual [tuple extract $dsig SrcInstRef] $srcref] &&\
        $Event eq $event &&\
        [isRefEqual [tuple extract $dsig DstInstRef] $dstref]}
}

proc Dispatch {eventid} {
    relvar deleteone __SIGNAL EventId $eventid
    variable event_queue
    if {[llength $event_queue] != 0} {
        # Pull the event from the front of the queue.
        set eventInfo [lindex $event_queue 0]
        set event_queue [lrange $event_queue 1 end]
        tailcall Receive $eventInfo
    }
}

proc DelayedDispatch {srcref event destref params} {
    DeleteDelayedSignal $srcref $event $destref
    tailcall Receive [dict create\
        src $srcref\
        event $event\
        dest $destref\
        params $params\
    ]
}

proc Receive {eventInfo} {
    #puts [info level 0]
    set destref [dict get $eventInfo dest]
    lassign $destref relvar ref
    lassign [SplitRelvarName $relvar] domain class

    set instrelvar ${relvar}::__${class}__INSTANCE
    set state [relation semijoin $ref [relvar set $instrelvar]]
    if {[relation isempty $state]} {
        error "can't find current state, $ref"
    }
    set currstate [relation extract $state __State]

    set trans [relvar restrictone ${domain}::__ARCH::__TRANSITION\
            Class $relvar CurrState $currstate\
            Event [dict get $eventInfo event]]
    if {[ral relation isempty $trans]} {
        set deftrans [relvar restrictone ${domain}::__ARCH::__DEFAULTTRANS\
                Class $relvar]
        set newState [relation extract $deftrans DefaultTrans]
    } else {
        set newState [relation extract $trans NewState]
    }

    if {$newState eq "CH"} {
        error "can't happen: $relvar\
            $currstate - [dict get $eventInfo event] -> CH"
    } elseif {$newState ne "IG"} {
        set idattrs [tuple get [ral relation tuple $ref]]
        relvar updateone $instrelvar is $idattrs {
            tuple update $is __State $newState
        }
        try {
            relvar eval {
                ${relvar}::__ACTIVITY::$newState $destref\
                        {*}[dict get $eventInfo params]
            }
        } on error {result opts} {
            puts "state activity error: $::errorInfo"
        } finally {
            set termrelvar ${domain}::__ARCH::__TERMINAL
            set term [relvar restrictone $termrelvar\
                    Class $relvar State $newState]
            if {[relation isnotempty $term]} {
                relvar deleteone $relvar {*}$idattrs
                relvar deleteone $instrelvar {*}$idattrs
            }
        }
    }
    return
}
----

=== Helper Commands

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    <<tclral imports>>
    <<helper data>>
    <<helper commands>>
}
----

[source,tcl]
----
<<helper commands>>=
proc SplitRelvarName {relvar} {
    tailcall list [namespace qualifiers $relvar] [namespace tail $relvar]
}
----

[source,tcl]
----
<<helper commands>>=
proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list STSACLASS $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

== Configuration Language

DSL Here

== Code Organization

In this section we show the organization of the files that can be
tangled from the literate source.
Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<rosea.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6

<<required packages>>

namespace eval ::rosea {
    variable version 1.0a1

    <<rosea namespace layout>>
}

package provide rosea $::rosea::version
----

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded rosea 1.0a1 [list source [file join $dir rosea.tcl]]
----

=== Unit Tests

[source,tcl]
----
<<rosea.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger

<<required packages>>

source ../src/rosea.tcl
chan puts "testing rosea version: [package require rosea]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

package require tcltest
eval tcltest::configure $argv

namespace eval ::rosea::test {
    ::logger::initNamespace [namespace current] $::options(level)

    namespace import ::tcltest::*
    <<tclral imports>>

    <<test utility procs>>
    <<helper command tests>>
    <<class command tests>>
    <<instance command tests>>
    <<dispatch command tests>>

    cleanupTests
}
----


////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk defintion ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.
