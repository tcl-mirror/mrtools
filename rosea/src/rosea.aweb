// vim:set syntax=asciidoc:
= Relation Oriented Software Execution Architecture

[abstract]
This document describes a Tcl package named, +rosea+.

== Introduction [[introduction,Introduction]]

* XUML software architecture
* Literate program

=== Design Strategy [[design-strategy,Design Strategy]]

Design Strategy

* Why use TclRAL?

==== Comparing Approaches [[comparing-approaches,Comparing Approaches]]

Comparing Approaches

* TclRAL and a bunch of procedures
* TclOO based
** each relvar a class
** each tuple an object
** large amount of OO machinery that is not used
** problems with lifetimes of object commands
* namespace ensemble based

=== Namespace Ensemble Approach [[namespace-ensemble-approach,Namespace Ensemble Approach]]
Namespace Ensemble Approach

* No unnecessary OO machinery that is not used.
* Convenient way to encapsulate a domain.

Parts of the puzzle

* procedures in the +rosea+ package to handle common XUML semantics
* configuration language to compute the mechanisms data structures and
layout the domain in the correct way.

Mapping concepts to Tcl implementation constructs.

["blockdiag",title="Basic Mapping of XUML Concepts"]
------
blockdiag {
    class longnode [width=150]
    domain [label="Domain"]
    namespace [label="Namespace"]
    class [label="XUML Class"]
    relvar [label="TclRAL relvar"]
    instance [label="XUML Instance"]
    tuple [label="Tuple in a relvar"]
    relationship [label="XUML Relationship"]
    constraint [label="TclRAL constraint"]
    classop [label="Class Operation"]
    clenscmd [label="Ensemble Subcommand", class=longnode]
    domop [label="Domain Operation"]
    domenscmd [label="Ensemble Subcommand", class=longnode]
    instop [label="Instance Operation"]
    inenscmd [label="Ensemble Subcommand", class=longnode]
    stateact [label="State Activity"]
    proc [label="Tcl proc"]

    domain -> namespace
    class -> relvar
    instance -> tuple
    relationship -> constraint
    domop -> domenscmd
    classop -> clenscmd
    instop -> inenscmd
    stateact -> proc
}
------

=== Relation Values, Relvars and Instance References -- Oh My!

Although the ideas of variables and values are well know,
it is worth clarifying the differences between variables and
values and how TclRAL constructs are involved.
Some of the confusion in this area arise from the conventional
use of symbol names in programing languages to stand for both
the variable and its value.

For example, consider the following ``C'' code.

[source,c,numbered]
----
int counter ;

counter = 27 ;

counter = counter + 3 ;
----

As line 1 shows, +counter+ is clearly a variable of integer type.
It is assigned the _value_ 27 on line 3.
Line 5 assigns the _value_ held by +counter+ plus the value +3+ into the
variable +counter+.
In ``C'' and many other languages, the interpretation of the symbol +counter+
depends upon whether it stands for a value in an expression
or as the target of an assignment.
In ``C'' parlance, the meaning is determined by whether +counter+ is
used as
http://en.wikipedia.org/wiki/Value_(computer_science)[an _lvalue_ or an _rvalue_].
Normally, we do not speak in such ultra-precise terms since context
shows whether we are interested in the _value_ contained by the _variable_
or whether we are talking about the memory allocated to the _variable_.

A _relation value_ is defined as a _heading_ and a _body_
which is a set of tuples that correspond to the heading.
The heading consists of a set of named attributes and their corresponding
data types.
The set of tuples that form the body of the relation value form a set,
_i.e._ there are no duplicated tuples.
In TclRAL, a relation value has a string representation
(like all well behaved Tcl values)
that is a two element list representing the heading and the body.
Relation values in TclRAL are first class Tcl values and consequently
may be assigned to an ordinary Tcl variable and undergo the normal
lifecycle of values.
This latter point is important as we shall see later.

A _relation variable_ (or relvar) is a special type of variable
that holds a _relation value_.
The concept of a relvar is supplied by TclRAL and a relvar is _not_ an
ordinary Tcl variable.
TclRAL maintains a _shadow_ variable system for relvars.
The naming conventions follow those of ordinary Tcl variables in that
they can be qualified in namespace syntax.
The reason that relation variables are distinct from Tcl variables is that they
are also subject to _constraints_ for identity and referential integrity.
This is one of the major distinguishing aspects of relvars.
TclRAL has the subcommand, +relvar+, which operates on relvars and
a distinct subcommand, +relation+, that operations on relation values.

However, we still need some way to refer to a particular tuple in a
relvar.
For example,
in XUML events are signaled to instances.
In our mapping of XUML concepts to TclRAL,
an instance corresponds to a particular tuple in a relvar.
We will also find it convenient to refer to sets of tuples when, for example,
set search for those tuples that meet some criteria.
Consequently, we define an _instance reference_ concept.
In the relational view,
the only way that you can refer to tuples in the relation values contained
in relvars is by the values of attributes.
There is no notion of indexing and order within the relation values is
not specified.
Each relvar must have at least one identifiers.
An identifier is a set of attributes (often a single attribute but
not always), the values of which must be distinct.
So to refer to an instance we need to know the relvar in questions and
the values of the attributes that constitute an identifier.

So we will represent an instance reference as a two element list as follows:
* A fully qualified relvar name.
* A relation value whose heading contains those attributes of the
relvar that correspond to an identifier.

This representation has several useful characteristics.
* An empty relation value indicates the _nil_ reference.
* The cardinality of the relation value can be greater than one and as
such represents a reference to a set of instances.

So we do not need to distinguish between an instance reference
and an instance reference set as is often done in architectures that
target staticly typed languages.

We will need several operations on instance references.

==== ToRef Command

The +ToRef+ command takes a fully qualified relvar name and a relation value
that is a subset of the value held in the relvar and returns an instance
reference to the values.

(((rosea,Helper,ToRef)))

[source,tcl]
----
<<helper commands>>=
proc ToRef {relvar relvalue} {
    tailcall list $relvar [relation project $relvalue\
        {*}[lindex [relvar identifiers $relvar] 0]] ; # <1>
}
----
<1> Let's step through this one command at a time.
* +relvar identifiers+ returns a list of the identifiers of the relvar.
Since each relvar has at least one identifier, we can always index off
the first identifier.
* +relation project+ returns a new relation value that contains only
the attributes requested.
In this case we are asking for those attributes that form one of the
identifiers.
* We compose the two element list that defines an instance reference
and we can use +tailcall+ since this is the last command in the procedure.

[source,tcl]
----
<<helper command tests>>=
test ToRef-1.0 {
    Compute a reference to a relvar tuple
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
} -cleanup {
    relvar unset A
} -body {
    set value [relation create {Attr1 int Attr2 string} {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }]
    ::rosea::Helpers::ToRef [namespace current]::A $value
} -result {::rosea::test::A {{Attr1 int} {{Attr1 20} {Attr1 40}}}} -match ref
----

==== Dereferencing an Instance

We will also need to obtain the tuples referenced by an instance reference.
In other words we will need to derefence the instance.
The +deRef+ command takes an instance refence and returns a relation
value that contains all the tuples from the associated relvar that
match the identifying attribute values contained in the reference.

(((rosea,Helper,DeRef)))
[source,tcl]
----
<<helper commands>>=
proc deRef {instref} {
    tailcall relation join [lindex $instref 1]\
        [relvar set [lindex $instref 0]] ; # <1>
}
----
<1> Dereferencing the instance is just a simple matter of ++join++ing the
relation value in instance reference to the value contained in the
relvar.
In TclRAL, +join+ in the so called _natural join_ so we end up with
a relation value whose heading matches that of the relvar's value.

[source,tcl]
----
<<helper command tests>>=
test deRef-1.0 {
    Dereference to get a relation value
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }
} -cleanup {
    relvar unset A
} -body {
    set ref [list [namespace current]::A {{Attr1 int} {{Attr1 40}}}]
    rosea::Helpers::deRef $ref
} -result {{Attr1 int Attr2 string} {{Attr1 40 Attr2 bar}}} -match relation
----

==== Counting References

Since commands that search for instances return instance references
we will need some commands that can determine if we are indeed referring
to anything.

(((rosea,Helper,isNilRef)))
[source,tcl]
----
<<helper commands>>=
proc isNilRef {instref} {
    tailcall relation isempty [lindex $instref 1]
}
----

(((rosea,Helper,isNotNilRef)))
[source,tcl]
----
<<helper commands>>=
proc isNotNilRef {instref} {
    tailcall relation isnotempty [lindex $instref 1]
}
----

==== Iterating on References

We will find it convenient to iterate on the instances referred to
by an instance reference.
Recall, that an instance reference can refer to many tuples
and there are times when we want to visit each instance and run
some code.
As is typical in Tcl and following the pattern of the +foreach+
command,
we construct a control structure procedure to perform the iteration.
The +forAllRefs+ command assigns an instance reference from a set
to a variable and executes a script for each instance.
Each iteration insures that the instance reference assigned to the
variable references only a single tuple.

(((rosea,Helper,forAllRefs)))
[source,tcl]
----
<<helper commands>>=
proc forAllRefs {varname instref body} {
    lassign $instref relvar refs
    upvar 1 $varname inst
    relation foreach ref $refs {
        set inst [list $relvar $ref]
        uplevel 1 $body
    } ; # <1>
    return
}
----
<1> The key command here is +relation foreach+ which performs the
iteration, one tuple at a time.

=== Domain Organization [[domain-organization,Domain Organization]]

Domain Organization

["blockdiag",title="Namespace Organization for a Domain"]
------
blockdiag {
    class rvsetstyle [shape = roundedbox, stacked] ;
    class rvstyle [shape = roundedbox] ;
    class procstyle [shape = ellipse, stacked, width = 175, height = 50] ;

    domain [label = "::<domain name>", color = "#bbffb0"] ;
    relvars [label = "<class relvars>", class = "rvsetstyle"] ;
    classcmds [label = "<class ensemble\ncommands>", class = "procstyle"] ;
    relcmds [label = "<relationship\nensemble commands>",
        class = "procstyle"] ;
    arch [label = "::__ARCH", color = "#ffe870"] ;

    class1 [label = "::<class 1>", color = "#ffe870"] ;
    class2 [label = "::<class 2>", color = "#ffe870"] ;
    classdots [shape = "dots"] ;
    classN [label = "::<class N>", color = "#ffe870"] ;

    domain -> relvars, classcmds, relcmds,
            class1, class2, classdots, classN, arch ;
    domain -> classdots [style = "none"] ;

    c2dots [shape = "dots"] ;
    class2 -> c2dots ;
    cNdots [shape = "dots"] ;
    classN -> cNdots ;

    archinfo [label = "<arch relvars>", class = "rvsetstyle"] ;

    arch -> archinfo ;

    instance [label = "__<class>__INSTANCE", class = "rvstyle"] ;
    activity [label = "::__ACTIVITY", color = "#ff8b70"] ;
    classop [label = "::<class op procs>", class = "procstyle"] ;
    instop [label = "::<inst op procs>", class = "procstyle"] ;

    class1 -> instance, activity, classop, instop ;

    state [label = "::<state activity>", class = "procstyle"] ;

    activity -> state ;
}
------

==== Class Relvars
Class Relvars

==== Class Ensemble Commands
Class Ensemble Commands

==== Relationship Ensemble Commands
Relationship Ensemble Commands

==== Class Namespaces
Class Namespaces

==== Class Activity Procedures
Class Activities

==== Architecture Relvars

["blockdiag",title="Relvars Containing Architecture Information"]
------
blockdiag {
    class rvsetstyle [shape = roundedbox, stacked] ;
    class rvstyle [shape = roundedbox] ;

    archinfo [label = "<arch relvars>", class = "rvsetstyle"] ;

    trans [label = "__TRANSITION", class = "rvstyle"]
    istate [label = "__INITIALSTATE", class = "rvstyle"]
    deftrans [label = "__DEFAULTTRANS", class = "rvstyle"]
    term [label = "__TERMINAL", class = "rvstyle"]
    link [label = "__LINK", class = "rvstyle"]

    archinfo -> trans, istate, deftrans, term, link ;
}
------

=== Package Organization [[package-organization,Package Organization]]

Package Organization

["blockdiag",title="Namespace Organization for a rosea Package"]
------
blockdiag {
    class ns1st [color= "#bbffb0"]
    class ns2nd [color= "#ffe870"]

    rosea [label="::rosea",class=ns1st]
    helpcmd [label="::Helpers",class=ns2nd]
    classcmd [label="::ClassCmds",class=ns2nd]
    instcmd [label="::InstCmds",class=ns2nd]
    relcmd [label="::RelCmds",class=ns2nd]
    configcmd [label="::Config",class=ns2nd]
    tracecmd [label="::Trace",class=ns2nd]

    rosea -> helpcmd, classcmd, instcmd, relcmd, configcmd, tracecmd
}
------

== Package Procedures

In this section we begin showing all the procedures associated
with the +rosea+ run time itself.
These will be divided into sections that correspond to the figure
above that showed how the namespace for the packge would be organized.

We start with some preliminaries.
Since we are using TclRAL extensively,
we need to pull in the package.

[source,tcl]
----
<<required packages>>=
package require ral
package require ralutil
----

We will find it convenient to import some of the commands from
TclRAL since we will be using them repeatedly.

[source,tcl]
----
<<tclral imports>>=
namespace import ::ral::relvar
namespace import ::ral::relation
namespace import ::ral::tuple
namespace import ::ral::relformat
namespace import ::ralutil::pipe
----

The namespace is organized as shown <<package-organization,above>>.

[source,tcl]
----
<<rosea namespace layout>>=
<<helper commands namespace>>
<<class commands namespace>>
<<instance commands namespace>>
<<relationship commands namespace>>
<<configuration commands namespace>>
<<trace commands namespace>>
----

=== A Diversion for Testing

[source,tcl]
----
<<test utility procs>>=
proc refMatch {expected actual} {
    lassign $expected erelvar einst
    lassign $actual arelvar ainst
    return [expr {$erelvar eq $arelvar && [ral relation is $einst == $ainst]}]
}
customMatch ref [namespace current]::refMatch

proc relationMatch {expected actual} {
    return [::ral::relation is $expected == $actual]
}
customMatch relation [namespace current]::relationMatch
----

=== Class Commands

In this section we show the class oriented commands of +rosea+.
These commands are the target of the ensemble mappings for each
of the classes in a domain.
Class oriented commands fall into these categories:

* Commands that search for instances.
* Commands that create and destroy instances.
* Commands that update the value of the underlying relvar.

First we create the namespace where the commands will reside.

[source,tcl]
----
<<class commands namespace>>=
namespace eval ClassCmds {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers ; # <1>
    <<class commands>>
}
----
<1> The helper commands are used everywhere so it is convenient to
include them in the command resolution path.

==== Select All Instances

The simplest search for instances is just to return them all.
The +selectAll+ command returns an instance reference that refers to
all the tuples of the relvar.

(((rosea,ClassCmds,selectAll)))
[source,tcl]
----
<<class commands>>=
proc selectAll {relvar} {
    tailcall ToRef $relvar [relvar set $relvar]
}
----

==== Select From Instances by Their Identifier

Sometimes the values of the identifying attributes is know.
The +selectById+ command returns a reference to the zero or one
tuples found in the relvar.

(((rosea,ClassCmds,selectById)))
[source,tcl]
----
<<class commands>>=
proc selectById {relvar args} {
    tailcall ToRef $relvar [relvar restrictone $relvar {*}$args]
}
----

[source,tcl]
----
<<class command tests>>=
test selectById-1.0 {
    Select tuple by value of the identifier
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    }
} -cleanup {
    relvar unset A
} -body {
    rosea::ClassCmds::selectById [namespace current]::A Attr1 20
} -result {::rosea::test::A {{Attr1 int} {{Attr1 20}}}} -match ref
----

==== Select Instances Meeting a Criteria

The general case is to select instances based on the result of
evaluating an expression.
The +selectWhere+ command takes an expression and returns an
instance reference for those tuples where the expression evaluates
to true.
During execution, the values of the attributes will be placed in Tcl
variable that have the same name as the attribute.
So the +expr+ argument may refer to those variables.

(((rosea,ClassCmds,selectWhere)))
[source,tcl]
----
<<class commands>>=
proc selectWhere {relvar expr} {
    tailcall ToRef $relvar [uplevel 1 [list ral relation restrictwith\
        [relvar set $relvar] $expr]]
}
----

[source,tcl]
----
<<class command tests>>=
test selectWhere-1.0 {
    Select tuples based on an expression
} -setup {
    relvar create A {
        Attr1   int
        Attr2   string
    } Attr1
    relvar insert A {
        Attr1 20 Attr2 foo
    } {
        Attr1 40 Attr2 bar
    } {
        Attr1 60 Attr2 baz
    }
} -cleanup {
    relvar unset A
} -body {
    rosea::ClassCmds::selectWhere [namespace current]::A {
        $Attr1 > 20 && $Attr1 < 60
    }
} -result {::rosea::test::A {{Attr1 int} {{Attr1 40}}}} -match ref
----

==== More Testing Infrastructure

[source,tcl]
----
<<test utility procs>>=
proc setupDomain {name} {
    set domns [namespace current]::$name
    namespace eval $domns {}
    namespace eval ${domns}::__ARCH {}
    relvar create ${domns}::__ARCH::__STATE {
        Class string
        State string
    } {Class State}
    relvar create ${domns}::__ARCH::__INITIALSTATE {
        Class string
        State string
    } Class
    relvar create ${domns}::__ARCH::__LINK {
        Link            string
        SourceClass     string
        DestClass       string
        Attrs           list
        PrevLink        string
    } Link
}

proc cleanupDomain {name} {
    set domns [namespace current]::$name
    relvar unset {*}[relvar names ${domns}::*]
    namespace delete $domns
}

proc addClass {domain class heading id} {
    set domns [namespace current]::$domain
    set idheading [list]
    foreach attr $id {
        lappend idheading $attr [dict get $heading $attr]
    }
    relvar create ${domns}::__${class}__INSTANCE\
        [concat $idheading [list __State string]]\
        $id
    relvar create ${domns}::$class $heading $id
}

proc addState {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__ARCH::__STATE $args
}

proc addInitialState {domain args} {
    dict set args Class [namespace current]::${domain}::[dict get $args Class]
    relvar insert [namespace current]::${domain}::__ARCH::__INITIALSTATE $args
}

proc addLink {domain args} {
    dict set args SourceClass\
        [namespace current]::${domain}::[dict get $args SourceClass]
    dict set args DestClass\
        [namespace current]::${domain}::[dict get $args DestClass]
    relvar insert [namespace current]::${domain}::__ARCH::__LINK $args
}
----

==== Create an Instance

The +create+ command creates instances.
If the class has a state model, then the instance is placed in the
initial state.
The return value is a instance reference to the newly created instance.

(((rosea,ClassCmds,create)))
[source,tcl]
----
<<class commands>>=
proc create {relvar args} {
    set ref [ToRef $relvar [relvar insert $relvar $args]] ; # <1>
    lassign [SplitRelvarName $relvar] domain class
    set initstate [relvar restrictone ${domain}::__ARCH::__INITIALSTATE\
        Class $relvar] ; # <2>
    if {[relation isnotempty $initstate]} {
        CreateInstanceState $domain $class [relation extract $initstate State]\
                [lindex $ref 1]
    }
    return $ref
}
----
<1> Here we see the correspondence between an XUML class instance and
a tuple in a relvar.
The instance is create by inserting a tuple into the relvar.
<2> If there is a state model associated with the class,
then there will be an initial state defined.
In that case, we must add a tuple to the +\__<class>\__INSTANCE+
relvar so we can track the current state for event transitions.

[source,tcl]
----
<<class command tests>>=
test create-1.0 {
    Create an instance -- no state model
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
} -cleanup {
    cleanupDomain foo
} -body {
    rosea::ClassCmds::create [namespace current]::foo::c1 A1 20 A2 bar
} -result {::rosea::test::foo::c1 {{A1 int} {{A1 20}}}} -match ref
----

==== Create an Instance In a Given State

(((rosea,ClassCmds,createin)))
[source,tcl]
----
<<class commands>>=
proc createin {relvar state args} {
    lassign [SplitRelvarName $relvar] domain class
    set initstate [relvar restrictone ${domain}::__ARCH::__STATE\
        Class $relvar State $state]
    if {[relation isempty $initstate]} {
        tailcall DeclError UNKNOWN_STATE $state $relvar
    }
    set ref [ToRef $relvar [relvar insert $relvar $args]]
    CreateInstanceState $domain $class $state [lindex $ref 1]
    return $ref
}
----

(((error code,UNKNOWN_STATE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_STATE   {unknown state, "%s", for class, "%s"}
----

[source,tcl]
----
<<class command tests>>=
test createin-1.0 {
    Create an instance in a given state
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addState foo Class c1 State Idle
    addInitialState foo Class c1 State Idle
} -cleanup {
    cleanupDomain foo
} -body {
    set ref [::rosea::ClassCmds::createin [namespace current]::foo::c1\
        Idle A1 40 A2 bar]
    set statetest [pipe {
        relvar restrictone ::rosea::test::foo::__c1__INSTANCE A1 40 |
        relation extract ~ __State
    }]
    expr {$statetest eq "Idle" &&\
        [refMatch {::rosea::test::foo::c1 {{A1 int} {{A1 40}}}} $ref]}
} -result {1}
----

We factor some common code to create the instance tuple that tracks
the state of the instance into a procedure.

[source,tcl]
----
<<class commands>>=
proc CreateInstanceState {domain class state value} {
    set tuple [concat\
        [tuple get [relation tuple $value]]\
        [list __State $state]\
    ]
    relvar insert ${domain}::__${class}__INSTANCE $tuple
    return
}
----

==== Delete an Instance

(((rosea,ClassCmds,delete)))

[source,tcl]
----
<<class commands>>=
proc delete {instref} {
    set deleted 0
    forAllRefs inst $instref {
        lassign $inst relvar ref
        incr deleted [relvar deleteone $relvar\
            [tuple get [relation tuple $ref]]]
    }
    return $deleted
}
----

=== Instance Commands

[source,tcl]
----
<<instance commands namespace>>=
namespace eval InstCmds {
    <<tclral imports>>
    namespace path [namespace parent]::Helpers ; # <1>
    <<instance data>>
    <<instance commands>>
}
----
////
relvar create __LINK {
    Link            string
    SourceClass     string
    DestClass       string
    Attrs           list
    PrevLink        string
} Link
////

[source,tcl]
----
<<instance data>>=
pipe {
    relvar set $DestClass |
    relation $op $related ~ -using $Attrs
} relatedquery

pipe {
    relvar set $linkinfo |
    relation semijoin $rship ~ -using {Link PrevLink}
} assocquery

<<instance commands>>=
proc SelectRelatedInsts {instref op args} {
    set srcrelvar [lindex $instref 0]
    set linkinfo [namespace qualifiers $srcrelvar]::__ARCH::__LINK
    set related [deRef $instref]

    variable relatedquery
    variable assocquery

    foreach lname $args {
        set rship [relvar restrictone $linkinfo Link $lname]
        if {[ral relation isempty $rship]} {
            tailcall DeclError UNKNOWN_LINKAGE $lname
        }

        relation assign $rship SourceClass DestClass Attrs
        if {$SourceClass ne $srcrelvar} {
            tailcall DeclError PATH_ERROR $lname $srcrelvar
        }
        set related [eval $relatedquery]

        set rship [eval $assocquery]
        if {[relation isnotempty $rship]} {
            relation assign $rship SourceClass DestClass Attrs
            set related [eval $relatedquery]
        }
        set srcrelvar $DestClass
    }

    return [list $srcrelvar $related]
}
----

(((error code,UNKNOWN_LINKAGE)))
[source,tcl]
----
<<error code formats>>=
UNKNOWN_LINKAGE {unknown linkage, "%s", for class, "%s"}
PATH_ERROR      {linkage, "%s", does not originate at relvar, "%s"}
----

[source,tcl]
----
<<instance commands>>=
proc selectRelated {instref args} {
    tailcall ToRef {*}[SelectRelatedInsts $instref semijoin {*}$args]
}

proc selectUnRelated {instref args} {
    tailcall ToRef {*}[SelectUnRelatedInsts $instref semiminus {*}$args]
}
----

[source,tcl]
----
<<instance command tests>>=
test selectRelated-1.0 {
    Navigate a relationship -- simple association
} -setup {
    setupDomain foo
    addClass foo c1 {A1 int A2 string} A1
    addClass foo c2 {B1 int B2 string} B1
    addLink foo Link R1 SourceClass c1 DestClass c2\
        Attrs {A1 B1} PrevLink {}
    set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::selectRelated $ref R1
} -result {::rosea::test::foo::c2 {{B1 int} {{B1 5}}}} -match ref
----

[source,tcl]
----
<<instance command tests>>=
test selectRelated-2.0 {
    Navigate a relationship -- associative class
} -setup {
    setupDomain foo
    addClass foo X {A1 int A2 string} A1
    addClass foo Y {B1 int B2 string} B1
    addClass foo A {A1 int B1 int} {A1 B1}
    # Forward direction is from X -> Y via A
    addLink foo Link R1 SourceClass X DestClass A\
        Attrs {A1 A1} PrevLink {}
    addLink foo Link "R1 A" SourceClass A DestClass Y\
        Attrs {B1 B1} PrevLink R1
    addLink foo Link ~R1 SourceClass Y DestClass A\
        Attrs {B1 B1} PrevLink {}
    addLink foo Link "~R1 A" SourceClass A DestClass X\
        Attrs {A1 A1} PrevLink ~R1

    set ref [rosea::ClassCmds::create [namespace current]::foo::X A1 5 A2 baz]
    rosea::ClassCmds::create [namespace current]::foo::Y B1 10 B2 bar
    rosea::ClassCmds::create [namespace current]::foo::A A1 5 B1 10
} -cleanup {
    cleanupDomain foo
} -body {
    ::rosea::InstCmds::selectRelated $ref R1
} -result {::rosea::test::foo::Y {{B1 int} {{B1 10}}}} -match ref
----

=== Helper Commands

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    <<tclral imports>>
    <<helper data>>
    <<helper commands>>
}
----

[source,tcl]
----
<<helper commands>>=
proc SplitRelvarName {relvar} {
    tailcall list [namespace qualifiers $relvar] [namespace tail $relvar]
}
----

[source,tcl]
----
<<helper commands>>=
proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list STSACLASS $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

== Configuration Language

DSL Here

== Code Organization

In this section we show the organization of the files that can be
tangled from the literate source.
Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<rosea.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6

<<required packages>>

namespace eval ::rosea {
    variable version 1.0a1

    <<rosea namespace layout>>
}

package provide rosea $::rosea::version
----

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded rosea 1.0a1 [list source [file join $dir rosea.tcl]]
----

=== Unit Tests

[source,tcl]
----
<<rosea.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger

<<required packages>>

source ../src/rosea.tcl
chan puts "testing rosea version: [package require rosea]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

package require tcltest
eval tcltest::configure $argv

namespace eval ::rosea::test {
    ::logger::initNamespace [namespace current] $::options(level)

    namespace import ::tcltest::*
    <<tclral imports>>

    <<test utility procs>>
    <<helper command tests>>
    <<class command tests>>
    <<instance command tests>>

    cleanupTests
}
----


////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk defintion ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.
