# ACTIVESTATE TEAPOT-PKG BEGIN TM -*- tcl -*-
# -- Tcl Module

# @@ Meta Begin
# Package rosea 1.0a1
# Meta description Rosea is a data and execution architecture for
# Meta description translating XUML models using Tcl as the implementation
# Meta description language.
# Meta platform    tcl
# Meta require     {Tcl 8.6}
# Meta require     logger
# Meta require     ral
# Meta require     ralutil
# Meta require     struct::set
# Meta summary     Rosea -- XUML Software Architecture
# @@ Meta End


# ACTIVESTATE TEAPOT-PKG BEGIN REQUIREMENTS

package require Tcl 8.6
package require logger
package require ral
package require ralutil
package require struct::set

# ACTIVESTATE TEAPOT-PKG END REQUIREMENTS

# ACTIVESTATE TEAPOT-PKG BEGIN DECLARE

package provide rosea 1.0a1

# ACTIVESTATE TEAPOT-PKG END DECLARE
# ACTIVESTATE TEAPOT-PKG END TM
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6

package require logger
package require ral
package require ralutil
package require struct::set

namespace eval ::rosea {
    namespace export configure
    
    namespace export configureFromFile
    
    namespace export generate
    
    namespace export populate
    
    namespace export populateFromFile
    
    namespace export traceControl
    
    namespace export decodeAllTraces
    
    namespace export decodeClassTraces
    
    namespace export decodeTargetTraces
    
    namespace export formatTraces
    
    namespace export diagAllTraces
    
    namespace export diagClassTraces
    
    namespace ensemble create

    variable version 1.0a1

    logger::initNamespace [namespace current]

    namespace import ::ral::relation
    namespace import ::ral::tuple
    namespace import ::ral::relformat
    namespace import ::ralutil::pipe
    namespace import ::ral::relvar
    proc configure {script} {
        namespace upvar Config errcount errcount configlineno configlineno
        set errcount 0
        set configlineno 1
        try {
            relvar eval { # <1>
                ConfigEvaluate ::rosea::Config $script
            }
        } on error {result} {
            log::error $result
            incr errcount
        }
        if {$errcount > 0} {
            tailcall DeclError CONFIG_ERRORS $errcount
        }
        return $errcount
    }
    proc configureFromFile {filename} {
        set f [::open $filename r]
        try {
            configure [read $f]
        } finally {
            ::chan close $f
        }
    }
    proc generate {{prefix {}}} {
        if {$prefix ne {}} {
            if {[string range $prefix 0 1] ne "::"} {
                error "relative namespaces not allowed"
            } elseif {![namespace exists $prefix]} {
                namespace eval $prefix
            }
            set prefix [string trimright $prefix :]
        }
    
        namespace upvar Config\
            Domain Domain\
            DomainElement DomainElement\
            Class Class\
            Attribute Attribute\
            DefaultValue DefaultValue\
            Identifier Identifier\
            IdentifyingAttribute IdentifyingAttribute\
            Relationship Relationship\
            Association Association\
            SimpleAssociation SimpleAssociation\
            SimpleReferringClass SimpleReferringClass\
            SimpleReferencedClass SimpleReferencedClass\
            ClassBasedAssociation ClassBasedAssociation\
            AssociatorClass AssociatorClass\
            SourceClass SourceClass\
            TargetClass TargetClass\
            Generalization Generalization\
            Superclass Superclass\
            Subclass Subclass\
            AttributeReference AttributeReference\
            ReferencedIdAttribute ReferencedIdAttribute\
            ReferringClass ReferringClass\
            ReferencedClass ReferencedClass\
            DomainOperation DomainOperation\
            SuppliedOperation SuppliedOperation\
            UserClassOperation UserClassOperation\
            SystemClassOperation SystemClassOperation\
            UserInstanceOperation UserInstanceOperation\
            SystemInstanceOperation SystemInstanceOperation\
            InstanceStateModel InstanceStateModel\
            StateModel StateModel\
            StatePlace StatePlace\
            State State\
            EffectiveEvent EffectiveEvent\
            DeferredEvent DeferredEvent\
            TransitionPlace TransitionPlace\
            StateTransition StateTransition\
            NonStateTransition NonStateTransition
    
        # Query for the heading
        pipe {
            relation semijoin $class $Attribute -using {Domain Domain Name Class} |
            relation project ~ Name Type |
            relation dict ~ Name Type
        } headingQuery
    
        pipe {
            relation semijoin $class $Identifier -using {Domain Domain Name Class}\
                    $IdentifyingAttribute |
            relation group ~ Attributes Attribute
        } idQuery
    
        # Iterate over all domains.
        relation foreach domain $Domain {
            set domainName [relation extract $domain Name]
            relvar updateone Config::Domain dtup [list Name $domainName] {
                tuple update $dtup Location $prefix
            }
            set domns ${prefix}::$domainName
            # We start by creating a namespace to house the domain.
            namespace eval $domns {
                namespace import ::ral::relation
                namespace import ::ral::tuple
                namespace import ::ral::relformat
                namespace import ::ralutil::pipe
            }
            set archns [GenerateArchStructures $domns]
    
            relvar eval {
                set domops [relation semijoin $domain $DomainOperation\
                        -using {Name Domain}]
                relation foreach domop $domops {
                    relation assign $domop\
                        {Name name} {Parameters parameters} {Body body}
                    proc ${domns}::$name $parameters [list ral relvar eval $body]
                }
    
                namespace eval $domns [list\
                    namespace export {*}[relation list $domops Name]\
                ]
                namespace eval $domns namespace ensemble create
    
                set classes [relation semijoin $domain $DomainElement $Class]
                set statemodels [pipe {
                    relation semijoin $classes $InstanceStateModel\
                            -using {Domain Domain Name Class}\
                        $StateModel -using {Domain Domain Class Model}
                }]
    
                # Much of the architectural data can be built in large queries
                # across the entire domain capturing the data for all the classes
                # in the domain.
                relvar union ${archns}::InitialState [pipe {
                    relation project $statemodels Model InitialState |
                    relation rename ~ Model Class InitialState State
                }]
    
    
                set states [relation semijoin $classes $StatePlace\
                        -using {Domain Domain Name Model}]
                relvar union ${archns}::State [pipe {
                    relation project $states Model Name |
                    relation rename ~ Model Class Name State
                }]
                relvar union ${archns}::Terminal [pipe {
                    relation semijoin $classes $State\
                            -using {Domain Domain Name Model}|
                    relation restrict ~ termtuple\
                            {[tuple extract $termtuple IsFinal]} |
                    relation project ~ Model Name |
                    relation rename ~ Model Class Name State
                }]
                set events [relation semijoin $classes $EffectiveEvent\
                        -using {Domain Domain Name Model}]
                relvar union ${archns}::Event [pipe {
                    relation project $events Model Event |
                    relation rename ~ Model Class
                }]
    
                set alltrans [pipe {
                    relation join $states $events |
                    relation rename ~ Name State
                }]
                set statetrans [relation semijoin $classes $StateTransition\
                            -using {Domain Domain Name Model}]
                set nontrans [pipe {
                    relation semijoin $classes $NonStateTransition\
                            -using {Domain Domain Name Model} |
                    relation rename ~ TransRule NewState
                }]
                set deftrans [pipe {
                    relation minus $alltrans $TransitionPlace |
                    relation join ~ $StateModel |
                    relation eliminate ~ InitialState |
                    relation rename ~ DefaultTrans NewState
                }]
                relvar union ${archns}::Transition [pipe {
                    relation union $statetrans $nontrans $deftrans |
                    relation eliminate ~ Domain |
                    relation rename ~ Model Class
                }]
                #puts [relformat [relvar set ${archns}::State] State]
                #puts [relformat [relvar set ${archns}::Event] Event]
                #puts [relformat [relvar set ${archns}::Transition] Transition]
    
                relvar union ${archns}::PolymorphicEvent [pipe {
                    relation semijoin $classes $DeferredEvent\
                            -using {Domain Domain Name Model} |
                    relation project ~ Model Event |
                    relation rename ~ Model Class
                }]
            }
    
            relation foreach class $classes {
                set className ${domns}::[relation extract $class Name]
                namespace eval $className {
                    namespace import ::ral::relation
                    namespace import ::ral::tuple
                    namespace import ::ral::relformat
                    namespace import ::ralutil::pipe
                }
                namespace eval $className [list namespace path\
                        [list $domns ::rosea::InstCmds]]
                # create class relvars
                set heading [eval $headingQuery]
                set ids [eval $idQuery]
                set idset [list]
                relation foreach id $ids -ascending Number {
                    lappend idset [relation list\
                            [relation extract $id Attributes] Attribute]
                }
                # create the relvar
                relvar create $className $heading {*}$idset
    
                set defaultvalues [pipe {
                    relation semijoin $class $Attribute\
                        -using {Domain Domain Name Class} |
                    relation join ~ $DefaultValue\
                        -using {Domain Domain Class Class Name Attribute}
                }]
                #puts [relformat $defaultvalues defaultvalues]
    
                if {[relation isnotempty $defaultvalues]} {
                    set defheading [relation dict $defaultvalues Name Type]
                    set defvalues [relation dict $defaultvalues Name Value]
                    relvar trace add variable $className insert [list\
                        ::rosea::Helpers::InsertTrace $defheading $defvalues]
                }
    
                # Check if we need an "instance" relvar to hold current state.
                set hasStateModel [pipe {
                    relation semijoin $class $StateModel\
                        -using {Domain Domain Name Model} |
                    relation isnotempty
                }]
                if {$hasStateModel} {
                    set instid [lindex $idset 0]
                    set instheading [list]
                    foreach attr $instid {
                        lappend instheading $attr [dict get $heading $attr]
                    }
                    lappend instheading __State string
                    relvar create\
                        ${domns}::__[relation extract $class Name]__STATEINST\
                        $instheading $instid
    
                    set actns ${className}::__Activity
                    namespace eval $actns {
                        namespace import ::ral::relation
                        namespace import ::ral::tuple
                        namespace import ::ral::relformat
                        namespace import ::ralutil::pipe
                    }
                    namespace eval $actns [list\
                        namespace path [list\
                            ::rosea::InstCmds\
                            $className\
                            $domns\
                        ]\
                    ]
                    #puts "$actns path = [namespace eval $actns namespace path]"
                    set states [pipe {
                        relation semijoin $class $State\
                            -using {Domain Domain Name Model} |
                        relation project ~ Name Parameters Action
                    }]
                    relation foreach state $states {
                        relation assign $state\
                            {Name stateName}\
                            {Parameters params}\
                            {Action stateAction}
                        set params [linsert $params 0 self]
                        proc ${actns}::$stateName $params $stateAction
                    }
                }
    
                set opmap [dict create]
                set classops [relation semijoin $class $UserClassOperation\
                    -using {Domain Domain Name Class}]
                relation foreach classop $classops {
                    relation assign $classop\
                        {Name opname}\
                        {Parameters params}\
                        {Body opbody}
    
                    set params [linsert $params 0 class]
                    proc ${className}::$opname $params $opbody
                    dict set opmap $opname [list ${className}::$opname\
                            $className]
                }
    
                set sysmap [pipe {
                    relation restrictwith $SuppliedOperation\
                            {!$RequiresStateModel} |
                    relation join $SystemClassOperation ~ |
                    relation update ~ sco 1 {
                        tuple update $sco Command\
                            [concat [tuple extract $sco Command]\
                            [list $className]]
                    } |
                    relation dict ~ Name Command
                }]
                if {$hasStateModel} {
                    set sysmap [dict merge $sysmap [pipe {
                        relation restrictwith $SuppliedOperation\
                            {$RequiresStateModel} |
                        relation join $SystemClassOperation ~ |
                        relation update ~ sco 1 {
                            tuple update $sco Command\
                                [concat [tuple extract $sco Command]\
                                [list $className]]
                        } |
                        relation dict ~ Name Command
                    }]]
                }
    
                namespace ensemble create\
                    -command $className\
                    -map [dict merge $opmap $sysmap]
    
                set opmap [dict create]
                set instops [relation semijoin $class $UserInstanceOperation\
                    -using {Domain Domain Name Class}]
                relation foreach instop $instops {
                    relation assign $instop\
                        {Name opname}\
                        {Parameters params}\
                        {Body opbody}
    
                    proc ${className}::$opname [linsert $params 0 self] $opbody
                    dict set opmap $opname ${className}::$opname
                }
                set sysmap [pipe {
                    relation restrictwith $SuppliedOperation\
                            {!$RequiresStateModel} |
                    relation join $SystemInstanceOperation ~ |
                    relation dict ~ Name Command
                }]
                if {$hasStateModel} {
                    set sysmap [dict merge $sysmap [pipe {
                        relation restrictwith $SuppliedOperation\
                            {$RequiresStateModel} |
                        relation join $SystemInstanceOperation ~ |
                        relation dict ~ Name Command
                    }]]
                }
                namespace ensemble create\
                    -command ${className}::instop\
                    -parameters instref\
                    -map [dict merge $opmap $sysmap]
            }
    
            set rships [relation semijoin $domain $DomainElement $Relationship]
            set sassocs [relation semijoin $rships $Association\
                    $SimpleAssociation]
            relation foreach sassoc $sassocs {
                set refing [relation semijoin $sassoc $SimpleReferringClass\
                        -using {Domain Domain Name Relationship}]
                set refed [relation semijoin $sassoc $SimpleReferencedClass\
                        -using {Domain Domain Name Relationship}]
    
                set reference [pipe {
                    relation join $AttributeReference $refing\
                        -using {Domain Domain ReferringClass Class\
                        Relationship Relationship ReferringRole Role} |
                    relation rename ~ Conditionality ReferringCond\
                            Multiplicity ReferringMult |
                    relation join ~ $refed -using {Domain Domain\
                        ReferencedClass Class Relationship\
                        Relationship ReferencedRole Role} |
                    relation project ~ Domain Relationship\
                        ReferringClass ReferringAttribute\
                        ReferencedClass ReferencedAttribute\
                        ReferringCond ReferringMult Conditionality |
                    relation group ~ ReferringAttrs\
                            ReferringAttribute ReferencedAttribute
                }]
                #puts [relformat $reference reference]
    
                relation assign $reference\
                    {Domain domain}\
                    {Relationship relationship}\
                    {ReferringClass referringClass}\
                    {ReferencedClass referencedClass}\
                    {ReferringCond referringCond}\
                    {ReferringMult referringMult}\
                    {Conditionality referencedCond}\
                    {ReferringAttrs referringAttrs}
                set attrrefs [relation tag $referringAttrs RefOrder]
                #puts [relformat $attrrefs attrrefs]
                set srcattrs [relation list $attrrefs ReferringAttribute\
                        -ascending RefOrder]
                set destattrs [relation list $attrrefs ReferencedAttribute\
                        -ascending RefOrder]
                lassign [WeaveLists $srcattrs $destattrs] forwattrs revattrs
    
                relvar association ${domns}::$relationship\
                     ${domns}::$referringClass $srcattrs\
                    [MapCondMultToConstraint $referringCond $referringMult]\
                    ${domns}::$referencedClass $destattrs\
                    [MapCondMultToConstraint $referencedCond false]
    
                relvar eval {
                    relvar insert ${archns}::Link [list\
                        Name        $relationship\
                        SrcClass    $referringClass\
                    ]
                    relvar insert ${archns}::AssociationLink [list\
                        Name            $relationship\
                        SrcClass        $referringClass\
                        DstClass        $referencedClass\
                        Attrs   $forwattrs\
                        PrevSrcClass    {}\
                    ]
                    relvar insert ${archns}::Link [list\
                        Name        ~$relationship\
                        SrcClass    $referencedClass\
                    ]
                    relvar insert ${archns}::AssociationLink [list\
                        Name            ~$relationship\
                        SrcClass        $referencedClass\
                        DstClass        $referringClass\
                        Attrs           $revattrs\
                        PrevSrcClass    {}\
                    ]
                    relvar insert ${archns}::RefLink [list\
                        Relationship    $relationship\
                        ReferringClass  $referringClass\
                        ReferencedClass $referencedClass\
                        ReferringAttrs  $referringAttrs\
                    ]
                }
    
                namespace ensemble create\
                    -command ${domns}::$relationship\
                    -map [dict create\
                        link [list ::rosea::RelCmds::linkSimple $relationship]\
                        unlink [list ::rosea::RelCmds::unlinkSimple\
                                $relationship]\
                    ]
            }
    
            set cassocs [relation semijoin $rships $Association\
                    $ClassBasedAssociation]
            relation foreach cassoc $cassocs {
                set sourceclass [relation semijoin $cassoc $SourceClass\
                    -using {Domain Domain Name Relationship}]
                set targetclass [relation semijoin $cassoc $TargetClass\
                    -using {Domain Domain Name Relationship}]
    
                set assocrefs [pipe {
                    relation semijoin $cassoc $AssociatorClass\
                            -using {Domain Domain Name Relationship}\
                        $ReferringClass $AttributeReference\
                            -using {Domain Domain Class ReferringClass\
                            Relationship Relationship Role ReferringRole} |
                    relation project ~ Domain ReferringClass ReferringAttribute\
                        ReferencedClass ReferencedAttribute ReferencedRole\
                        Relationship |
                    relation join ~ [relation union $sourceclass $targetclass]\
                            -using {Domain Domain Relationship Relationship\
                            ReferencedClass Class ReferencedRole Role} |
                    relation group ~ ReferringAttrs\
                            ReferringAttribute ReferencedAttribute |
                    relation group ~ References ReferencedClass ReferencedRole\
                            Conditionality Multiplicity ReferringAttrs
    
                }]
                #puts [relformat $assocrefs assocrefs]
    
                relation foreach assocref $assocrefs {
                    relation assign $assocref\
                        {Domain domain}\
                        {ReferringClass associator}\
                        {Relationship relationship}\
                        {References references}
                    set assoclinks [relation create\
                        {Participant string Role string\
                        ReferringAttrs {Relation {ReferringAttribute string\
                            ReferencedAttribute string}}}]
                    relation foreach reference $references {
                        relation assign $reference\
                            {ReferencedClass referencedClass}\
                            {ReferencedRole referencedRole}\
                            {Conditionality conditionality}\
                            {Multiplicity multiplicity}\
                            {ReferringAttrs referringAttrs}
    
                        set attrrefs [relation tag $referringAttrs RefOrder]
                        set assocattrs($referencedRole)\
                            [relation list $attrrefs ReferringAttribute\
                                -ascending RefOrder]
                        set refattrs($referencedRole)\
                            [relation list $attrrefs ReferencedAttribute\
                                -ascending RefOrder]
                        set multcond($referencedRole)\
                            [MapCondMultToConstraint $conditionality\
                                $multiplicity]
                        set refclass($referencedRole) $referencedClass
    
                        set assoclinks [relation insert $assoclinks [list\
                            Participant $refclass($referencedRole)\
                            Role $referencedRole\
                            ReferringAttrs $referringAttrs\
                        ]]
                    }
    
                    relvar correlation ${domns}::$relationship\
                        ${domns}::$associator\
                        $assocattrs(source) $multcond(target)\
                            ${domns}::$refclass(source) $refattrs(source)\
                        $assocattrs(target) $multcond(source)\
                            ${domns}::$refclass(target) $refattrs(target)
    
                    lassign [WeaveLists $refattrs(source) $assocattrs(source)]\
                        forwattrs revattrs
                    relvar eval {
                        relvar insert ${archns}::Link [list\
                            Name    $relationship\
                            SrcClass   $refclass(source)\
                        ]
                        relvar insert ${archns}::AssociationLink [list\
                            Name            $relationship\
                            SrcClass        $refclass(source)\
                            DstClass        $associator\
                            Attrs           $forwattrs\
                            PrevSrcClass    {}\
                        ]
                        relvar insert ${archns}::Link [list\
                            Name        ~$relationship\
                            SrcClass    $associator\
                        ]
                        relvar insert ${archns}::AssociationLink [list\
                            Name            ~$relationship\
                            SrcClass        $associator\
                            DstClass        $refclass(source)\
                            Attrs   $revattrs\
                            PrevSrcClass    $refclass(target)\
                        ]
                        relvar insert ${archns}::AssocRef [list\
                            Relationship    $relationship\
                            AssocClass      $associator\
                            References      $assoclinks\
                        ]
    
                        lassign [WeaveLists $refattrs(target) $assocattrs(target)]\
                            forwattrs revattrs
                        relvar insert ${archns}::Link [list\
                            Name        $relationship\
                            SrcClass    $associator\
                        ]
                        relvar insert ${archns}::AssociationLink [list\
                            Name            $relationship\
                            SrcClass        $associator\
                            DstClass        $refclass(target)\
                            Attrs   $revattrs\
                            PrevSrcClass    $refclass(source)\
                        ]
                        relvar insert ${archns}::Link [list\
                            Name        ~$relationship\
                            SrcClass    $refclass(target)\
                        ]
                        relvar insert ${archns}::AssociationLink [list\
                            Name            ~$relationship\
                            SrcClass        $refclass(target)\
                            DstClass        $associator\
                            Attrs   $forwattrs\
                            PrevSrcClass    {}\
                        ]
                    }
                }
    
                namespace ensemble create\
                    -command ${domns}::$relationship\
                    -map [dict create\
                        link [list ::rosea::RelCmds::linkAssoc $relationship]\
                        unlink [list ::rosea::RelCmds::unlinkAssoc\
                                $relationship]\
                    ]
            }
    
            set gens [relation semijoin $rships $Generalization]
            relation foreach gen $gens {
                set subrefs [pipe {
                    relation semijoin $gen $Subclass\
                            -using {Domain Domain Name Relationship}\
                        $ReferringClass $AttributeReference\
                            -using {Domain Domain Class ReferringClass\
                            Relationship Relationship Role ReferringRole} |
                    relation project ~ Domain ReferringClass ReferringAttribute\
                        ReferencedClass ReferencedAttribute Relationship |
                    relation group ~ ReferringAttrs\
                            ReferringAttribute ReferencedAttribute
                }]
                #puts [relformat $subrefs subrefs]
    
                set subparts [list]
                relation foreach subref $subrefs {
                    relation assign $subref\
                        {Domain domain}\
                        {ReferringClass subclass}\
                        {ReferencedClass superclass}\
                        {Relationship relationship}\
                        {ReferringAttrs referringAttrs}
    
                    set attrrefs [relation tag $referringAttrs RefOrder]
                    set subattrs [relation list $attrrefs ReferringAttribute\
                            -ascending RefOrder]
                    set superattrs [relation list $attrrefs ReferencedAttribute\
                            -ascending RefOrder]
                    lassign [WeaveLists $subattrs $superattrs]\
                            forwattrs revattrs
    
                    lappend subparts ${domns}::$subclass $subattrs
    
                    relvar eval {
                        relvar insert ${archns}::Link [list\
                            Name        $relationship\
                            SrcClass    $subclass\
                        ]
                        relvar insert ${archns}::AssociationLink [list\
                            Name            $relationship\
                            SrcClass        $subclass\
                            DstClass        $superclass\
                            Attrs           $forwattrs\
                            PrevSrcClass    {}\
                        ]
                        # Here!! need to figure out how to get rid of the uinserts
                        relvar uinsert ${archns}::Link [list\
                            Name        ~$relationship\
                            SrcClass    $superclass\
                        ]
                        relvar uinsert ${archns}::PartitionLink [list\
                            Name        ~$relationship\
                            SrcClass    $superclass\
                        ]
                        relvar insert ${archns}::PartitionDst [list\
                            Name        ~$relationship\
                            SrcClass    $superclass\
                            DstClass    $subclass\
                            Attrs   $revattrs\
                        ]
                        relvar uinsert ${archns}::SuperLink [list\
                            Relationship    $relationship\
                            SuperClass      $superclass\
                        ]
                        relvar insert ${archns}::SubLink [list\
                            Relationship    $relationship\
                            SubClass        $subclass\
                            ReferringAttrs  $referringAttrs\
                        ]
                    }
                }
    
                relvar partition ${domns}::$relationship ${domns}::$superclass\
                        $superattrs {*}$subparts
                namespace ensemble create\
                    -command ${domns}::$relationship\
                    -map [dict create migrate [list ::rosea::RelCmds::migrate\
                            $relationship]]
            }
        }
        #puts [relformat [relvar set ${archns}::Link] Link]
        #puts [relformat [relvar set ${archns}::AssociationLink] AssociationLink]
        #puts [relformat [relvar set ${archns}::PartitionLink] PartitionLink]
        #puts [relformat [relvar set ${archns}::PartitionDst] PartitionDst]
        #puts [relformat [relvar set ${archns}::RefLink] RefLink]
        #puts [relformat [relvar set ${archns}::AssocRef] AssocRef]
        #puts [relformat [relvar set ${archns}::SuperLink] SuperLink]
        #puts [relformat [relvar set ${archns}::SubLink] SubLink]
    }
    
    proc MapCondMultToConstraint {cond mult} {
        if {$cond && $mult} {
            return *
        } elseif {$cond && !$mult} {
            return ?
        } elseif {!$cond && $mult} {
            return +
        } elseif {!($cond || $mult)} {
            return 1
        }
    }
    
    proc GenerateArchStructures {domns} {
        set archns ${domns}::__Arch
        namespace eval ${archns} {
            ral relvar create State {
                Class string
                State string
            } {Class State}
            ral relvar create Event {
                Class string
                Event string
            } {Class Event}
            ral relvar create Transition {
                Class string
                State string
                Event string
                NewState string
            } {Class State Event}
            ral relvar correlation R1 Transition\
                {Class State} + State {Class State}\
                {Class Event} + Event {Class Event}
            ral relvar create InitialState {
                Class string
                State string
            } Class
            ral relvar association R6\
                InitialState {Class State} ?\
                State {Class State} 1
            ral relvar create Terminal {
                Class string
                State string
            } {Class State}
            ral relvar create PolymorphicEvent {
                Class           string
                Event           string
            } {Class Event}
            ral relvar create Link {
                Name            string
                SrcClass        string
            } {Name SrcClass}
            ral relvar create AssociationLink {
                Name            string
                SrcClass        string
                DstClass        string
                Attrs           list
                PrevSrcClass    string
            } {Name SrcClass}
            ral relvar association R4\
                AssociationLink {Name PrevSrcClass} ?\
                AssociationLink {Name SrcClass} ?
            ral relvar create PartitionLink {
                Name            string
                SrcClass        string
            } {Name SrcClass}
            ral relvar partition R3 Link {Name SrcClass}\
                AssociationLink {Name SrcClass}\
                PartitionLink {Name SrcClass}
            ral relvar create PartitionDst {
                Name            string
                SrcClass        string
                DstClass        string
                Attrs           list
            } {Name SrcClass DstClass}
            ral relvar association R2\
                PartitionDst {Name SrcClass} +\
                PartitionLink {Name SrcClass} 1
            ral relvar create SuperLink {
                Relationship    string
                SuperClass      string
            } Relationship
            ral relvar create SubLink {
                Relationship    string
                SubClass        string
                ReferringAttrs  {Relation {ReferringAttribute string\
                                ReferencedAttribute string}}
            } {Relationship SubClass}
            ral relvar association R5\
                SubLink Relationship +\
                SuperLink Relationship 1
            ral relvar create RefLink {
                Relationship    string
                ReferringClass  string
                ReferencedClass string
                ReferringAttrs  {Relation {ReferringAttribute string\
                                    ReferencedAttribute string}}
            } Relationship
            ral relvar create AssocRef {
                Relationship    string
                AssocClass      string
                References      {Relation {Participant string Role string\
                        ReferringAttrs {Relation\
                        {ReferringAttribute string ReferencedAttribute string}}}}
            } Relationship
        }
    
        return $archns
    }
    proc populate {script} {
        namespace upvar Config errcount errcount configlineno configlineno
        set errcount 0
        set configlineno 1
        try {
            relvar eval {
                ConfigEvaluate ::rosea::Populate $script
            }
        } on error {result} {
            log::error $result
            incr errcount
        }
        if {$errcount > 0} {
            tailcall DeclError CONFIG_ERRORS $errcount
        }
        return $errcount
    }
    proc populateFromFile {filename} {
        set f [::open $filename r]
        try {
            populate [read $f]
        } finally {
            ::chan close $f
        }
    }
    proc traceControl {op args} {
        switch -exact -- $op {
            on {
                namespace upvar Trace traceState traceState
                set traceState on
            }
            off {
                namespace upvar Trace traceState traceState
                set traceState off
            }
            status {
                namespace upvar Trace traceState traceState
                return $traceState
            }
            clear {
                relvar eval {
                    foreach rvar {Trace Creation Polymorphic Transition} {
                        relvar set Trace::$rvar\
                                [relation emptyof [relvar set Trace::$rvar]]
                    }
                }
                namespace upvar Trace traceNumber traceNumber
                set traceNumber 0
            }
            logon {
                namespace upvar Trace traceLogState traceLogState
                set traceLogState on
            }
            logoff {
                namespace upvar Trace traceLogState traceLogState
                set traceLogState off
            }
            loglevel {
                namespace upvar Trace traceLogLevel traceLogLevel
                if {[llength $args] != 0} {
                    set traceLogLevel [lindex $args 0]
                }
                return $traceLogLevel
            }
            save {
                if {[llength $args] == 0} {
                    DeclError NO_SAVEFILE
                }
                storeToSQLite [lindex $args 0] [relvar names ::rosea::Trace::*]
            }
            default {
                DeclError BAD_TRACEOP $op
            }
        }
    }
    proc decodeAllTraces {} {
        tailcall Trace::TracesToRecords [relvar set Trace::Trace]
    }
    proc decodeClassTraces {args} {
        tailcall Trace::TracesToRecords [pipe {
            relvar set Trace::Trace |
            relation restrictwith ~ {$Class in $args}
        }]
    }
    proc decodeTargetTraces {args} {
        tailcall TracesToRecords [pipe {
            relvar set Trace |
            relation restrictwith ~ {$Target in $args}
        }]
    }
    proc formatTraces {tracerecs} {
        if {[llength $tracerecs] == 0} {
            return {}
        }
        set prevtime [dict get [lindex $tracerecs 0] time]
        foreach rec $tracerecs {
            dict with rec {
                append result "[Trace::FormatTimestamp $time]: "
                append result "[Trace::FormatTimeAsSec\
                        [expr {$time - $prevtime}]]: "
                set prevtime $time
                append result [Trace::FormatTraceRec $rec] \n
            }
        }
        return [string trimright $result]
    }
    proc diagAllTraces {filename args} {
        set chan [open $filename w]
        try {
            chan puts $chan [Trace::DiagTraces [relvar set Trace::Trace] {*}$args]
        } finally {
            chan close $chan
        }
        return
    }
    proc diagClassTraces {filename classes args} {
        set chan [open $filename w]
        try {
            set traces [pipe {
                relvar set Config::Trace >
                relation restrictwith ~\
                    {$Class in $classes || [namespace tail $Class] in $classes}
            }] {} >~
            chan puts $chan [Trace::DiagTraces $traces {*}$args]
        } finally {
            chan close $chan
        }
        return
    }
    namespace eval Helpers {
        namespace import ::ral::relation
        namespace import ::ral::tuple
        namespace import ::ral::relformat
        namespace import ::ralutil::pipe
        namespace import ::ral::relvar
        variable errFormats
        set errFormats [dict create {*}{
            UNKNOWN_STATE   {unknown state, "%s", for class, "%s"}
            UNKNOWN_EVENT   {unknown event, "%s", for class, "%s"}
            NO_CROSS_DOMAIN         {cannot link instances across domains, got "%s" and "%s"}
            UNKNOWN_RELATIONSHIP    {unknown relationship, "%s"}
            NON_PARTICIPANTS        {"%s" and "%s" don't participate in %s,\
                                        expected "%s" and "%s"}
            MUST_BE_SINGULAR        {number of refered to instances for "%s" must be one, got %d}
            NOT_IN_ASSOCIATION         {"%s" $relvar1 not a participant in "%s"}
            AMBIGUOUS_UNLINK         {"%s" is reflexive and linking via "%s" is ambiguous}
            NO_SUBCLASS         {relationship "%s" does not have a "%s"}
            NO_ASSIGNER         {relationship, "%s", does not have an assigner}
            UNKNOWN_ASSIGNER         {unknown assigner instance, "%s", for relationship,\
                    "%s"}
            UNKNOWN_LINKAGE {unknown relationship, "%s", for class, "%s"}
            PATH_ERROR      {relationship, "%s", from "%s" to "%s", does not end at "%s"}
            ARG_ERROR      {attribute updates must be name / value pairs, got "%s"}
            ID_UPDATE      {cannot update identifying attributes, "%s"}
            INVALID_TIME    {invalid time value, "%s"}
            SINGLE_OR_EMPTY_REF_REQUIRED {single valued or nil reference required, %d found}
            SINGLE_REF_REQUIRED     {single valued reference required, %d found}
            EVENT_IN_FLIGHT     {event, "%s", sent to "%s", which does not exist}
            CANT_HAPPEN_EVENT   {can't happen transition, %s - %s -> %s ==> %s -> CH}
            CONFIG_ERRORS     {encountered %d configuration script errors}
            EMPTY_NAME      {the empty string is not a value name for a %s}
            RESERVED_NAME {names beginning with two underscore characters are reserved,\
                    "%s"}
                
            ARG_FORMAT      {options and values must come in pairs, got "%s"}
            UNKNOWN_OPTION  {unknown %s command option, "%s"}
            DUP_OP_NAME      {operation call, "%s", already exists}
            BAD_RELATIONSHIP_SPEC  {bad relationship specifier, "%s"}
            NEED_ASSOCIATOR {relationship of type, "%s", requires associative class}
            NEED_REFLEXIVE_PATH {traversal path must be specified for reflexive\
                    association, %s, %s %s %s}
            REFLEXIVE_NOT_ALLOWED   {associations of type, "%s", cannot be reflexive}
            TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
            ARG_MISMATCH      {number of population values must be a multiple of %d, got %d}
            BAD_TRACEOP     {unknown trace operation, "%s"}
            NO_SAVEFILE     {no save file name provided}
            BAD_TRACETYPE   {unknown trace type, "%s"}
        }]
        proc ToRef {relvar relvalue} {
            tailcall list $relvar [relation project $relvalue\
                {*}[lindex [relvar identifiers $relvar] 0]] ; # <1>
        }
        proc CreateInstanceState {domain class state value} {
            set tuple [concat\
                [tuple get [relation tuple $value]]\
                [list __State $state]\
            ] ; # <1>
            relvar insert ${domain}::__${class}__STATEINST $tuple
            return
        }
        proc SelfInstRef {{level 2}} {
            upvar $level self srcself
            return [expr {[info exists srcself] ? $srcself : {{} {{} {}}}}]
        }
        proc SplitRelvarName {relvar} {
            tailcall list [namespace qualifiers $relvar] [namespace tail $relvar]
        }
        namespace export DeclError
        
        proc DeclError {errcode args} {
            variable errFormats
            set errmsg [format [dict get $errFormats $errcode] {*}$args]
            tailcall throw [list ROSEA $errcode {*}$args $errmsg] $errmsg
        }
        proc PropagatePolyEvents {super} {
            namespace upvar ::rosea::Config\
                DeferredEvent DeferredEvent\
                LocalEvent LocalEvent\
                Superclass Superclass\
                Subclass Subclass\
                DeferralPath DeferralPath\
                Generalization Generalization
        
            set subs [pipe {
                relation semijoin $super\
                    $Generalization -using {Domain Domain Relationship Name}\
                    $Subclass -using {Domain Domain Name Relationship}
            }]
            #puts [relformat $subs subs]
        
            relation foreach sub $subs {
                set defrdevents [pipe {
                    relation semijoin $super $DeferralPath\
                        -using {Domain Domain Class Model Relationship Relationship}\
                        $DeferredEvent |
                    relation update ~ deftup {1} {
                        tuple update $deftup Model [relation extract $sub Class]
                    }
                }]
                #puts [relformat $defrdevents defrdevents]
                set locals [relation semijoin $sub $LocalEvent\
                    -using {Domain Domain Class Model}]
        
                set isleaf [pipe {
                    relation semijoin $sub $Superclass\
                            -using {Domain Domain Class Class} |
                    relation isempty ~
                }]
        
        
                if {$isleaf} {
                    relvar minus ::rosea::Config::LocalEvent\
                            [relation intersect $LocalEvent $defrdevents]
        
                    set newmapped [relation minus $defrdevents $locals]
                    relvar union ::rosea::Config::Event $newmapped
                    relvar union ::rosea::Config::EffectiveEvent $newmapped
                    relvar union ::rosea::Config::MappedEvent [relation extend\
                        $defrdevents metuple\
                        ParentModel string {[relation extract $super Class]}]
                } else {
                    relvar union ::rosea::Config::Event $defrdevents
                    relvar union ::rosea::Config::DeferredEvent $defrdevents
                    relvar union ::rosea::Config::InheritedEvent $defrdevents
                    relvar union ::rosea::Config::DeferralPath [relation join\
                        $defrdevents $Superclass -using {Domain Domain Model Class}]
                }
                relvar union ::rosea::Config::NonLocalEvent [relation extend\
                    $defrdevents nletuple\
                    Relationship string {[relation extract $sub Relationship]}\
                    Role string {[relation extract $sub Role]}]
        
                set nextsupers [relation semijoin $sub $Superclass\
                    -using {Domain Domain Class Class}]
                #puts [relformat $nextsupers nextsupers]
                relation foreach nextsuper $nextsupers {
                    PropagatePolyEvents $nextsuper
                }
            }
        }
        proc Interleave {l1 l2} {
            set result [list]
            foreach a $l1 b $l2 {
                lappend result $a $b
            }
            return $result
        }
        
        proc WeaveLists {l1 l2} {
            tailcall list [Interleave $l1 $l2] [Interleave $l2 $l1]
        }
        proc InsertTrace {defheading defvalues op relvar tuple} {
            tuple create\
                [dict merge $defheading [tuple heading $tuple]]\
                [dict merge $defvalues [tuple get $tuple]]
        }
    }
    namespace eval ClassCmds {
        namespace import ::ral::relation
        namespace import ::ral::tuple
        namespace import ::ral::relformat
        namespace import ::ralutil::pipe
        namespace import ::ral::relvar
        namespace path [namespace parent]::Helpers ; # <1>
        proc findAll {relvar} {
            tailcall ToRef $relvar [relvar set $relvar]
        }
        proc findById {relvar args} {
            tailcall ToRef $relvar [relvar restrictone $relvar {*}$args]
        }
        proc findWhere {relvar expr} {
            tailcall ToRef $relvar [uplevel 1 [list ::ral relation restrictwith\
                [relvar set $relvar] $expr]]
        }
        proc create {relvar args} {
            set ref [ToRef $relvar [relvar insert $relvar $args]] ; # <1>
            lassign [SplitRelvarName $relvar] domain class
            set initstate [relvar restrictone ${domain}::__Arch::InitialState\
                Class [namespace tail $relvar]] ; # <2>
            if {[relation isnotempty $initstate]} {
                CreateInstanceState $domain $class [relation extract $initstate State]\
                        [lindex $ref 1]
            }
            return $ref
        }
        proc createin {relvar state args} {
            lassign [SplitRelvarName $relvar] domain class
            set initstate [relvar restrictone ${domain}::__Arch::State\
                Class $class State $state]
            if {[relation isempty $initstate]} { # <1>
                tailcall DeclError UNKNOWN_STATE $state $relvar
            }
            set ref [ToRef $relvar [relvar insert $relvar $args]]
            CreateInstanceState $domain $class $state [lindex $ref 1]
            return $ref
        }
        proc createasync {relvar event eventparams args} {
            lassign [SplitRelvarName $relvar] domain class
            set knownevent [relvar restrictone ${domain}::__Arch::Event\
                Class $class Event $event]
            if {[relation isempty $knownevent]} { # <1>
                tailcall DeclError UNKNOWN_EVENT $event $class
            }
            set instref [createin $relvar @ {*}$args] ; # <2>
            ::rosea::Trace::TraceCreation [SelfInstRef 1] $event $instref
            ::rosea::InstCmds::signal $instref $event {*}$eventparams
            return $instref
        }
        proc update {relvar relvalue} {
            tailcall ToRef $relvar [relvar updateper $relvar $relvalue]
        }
    }
    namespace eval InstCmds {
        namespace import ::ral::relation
        namespace import ::ral::tuple
        namespace import ::ral::relformat
        namespace import ::ralutil::pipe
        namespace path [namespace parent]::Helpers
        pipe {
            relvar set ${domain}::$DstClass |
            relation $op $related ~ -using $Attrs
        } relatedQuery
        proc deRef {instref args} {
            lassign $instref relvar ref
            set inst [relation semijoin $ref [relvar set $relvar]] ; # <1>
            if {[llength $args] != 0} {
                set inst [relation project $inst\
                    {*}[relation attributes $ref] {*}$args]
            }
            return $inst
        }
        proc isEmptyRef {instref} {
            tailcall relation isempty [lindex $instref 1]
        }
        proc isNotEmptyRef {instref} {
            tailcall relation isnotempty [lindex $instref 1]
        }
        proc refMultiplicity {instref} {
            tailcall relation cardinality [lindex $instref 1]
        }
        proc isRefSingular {instref} {
            expr {[refMultiplicity $instref] == 1}
        }
        proc isRefEqual {ref1 ref2} {
            lassign $ref1 relvar1 inst1
            lassign $ref2 relvar2 inst2
            return [expr {$relvar1 eq $relvar2 &&\
                    [relation is $inst1 == $inst2]}]
        }
        proc forAllRefs {varname instref body} {
            lassign $instref relvar refs
            upvar 1 $varname inst
            relation foreach ref $refs {
                set inst [list $relvar $ref]
                uplevel 1 $body
            } ; # <1>
            return
        }
        proc FindRelatedInsts {instref op args} {
            set srcrelvar [lindex $instref 0]
            lassign [SplitRelvarName $srcrelvar] domain class
        
            # This procedure queries the architectural data about relationship linkage,
            # so we bring the relvar variables into scope.
            namespace upvar ${domain}::__Arch\
                    Link Link\
                    AssociationLink AssociationLink\
                    PartitionLink PartitionLink\
                    PartitionDst PartitionDst
            #puts [relformat $Link Link]
            #puts [relformat $AssociationLink AssociationLink]
            #puts [relformat $PartitionLink PartitionLink]
            #puts [relformat $PartitionDst PartitionDst]
            variable relatedQuery ; # <1>
        
            # The strategy here is to iterage over the relationship chain to build
            # semijoin (or semiminus) commands from the architectural data values.
            set related [deRef $instref]
            foreach linkage $args {
                # Recall that the linkage specification may contain a destination class
                # for those types of linkages where there may be multiple paths along
                # the relationship (i.e. to associative classes or subclasses).
                lassign $linkage lname dst
        
                set link [relvar restrictone ${domain}::__Arch::Link\
                        Name $lname SrcClass $class]
                if {[ral relation isempty $link]} {
                    tailcall DeclError UNKNOWN_LINKAGE $lname $class
                }
                # First we determine if we are dealing with an associative link or a
                # partition link.
                set assoc [relation join $link $AssociationLink]
                if {[relation isnotempty $assoc]} {
                    relation assign $assoc DstClass Attrs
                    # Check if additional path information was provided.
                    if {$dst eq {}} {
                        # Find the set of instances related to the current set.
                        set related [eval $relatedQuery]
                        # We must see if this is a class-based association.  If so,
                        # then the first traversal was to the associator and we must
                        # traverse again to the other class.
                        set assoc [relation semijoin $assoc $AssociationLink\
                            -using {Name Name SrcClass PrevSrcClass}]
                        if {[relation isnotempty $assoc]} {
                            relation assign $assoc DstClass Attrs
                            set related [eval $relatedQuery]
                        }
                    } else {
                        # If a destination was specified in the linkage, then we need
                        # to verify that it is actually part of the relationship.
                        if {$dst ne $DstClass} {
                            tailcall DeclError PATH_ERROR $lname $class $DstClass\
                                $dst
                        }
                        set related [eval $relatedQuery]
                    }
                } else {
                    # If the linkage is not associative, then it must be a superclass
                    # to subclass traversal. Recall that subclass to superclass
                    # traversal is just an ordinary associative linkage. In this case
                    # we simply find the partition linkage information.
                    set partdst [relvar restrictone ${domain}::__Arch::PartitionDst\
                        Name $lname SrcClass $class DstClass $dst]
                    if {[relation isempty $partdst]} {
                        tailcall DeclError PATH_ERROR $lname $class $DstClass $dst
                    }
                    relation assign $partdst DstClass Attrs
                    set related [eval $relatedQuery]
                }
                # Continue the iteration by setting the next source to the current
                # destination class.
                set class $DstClass
                set srcrelvar ${domain}::$class
            }
            # N.B. that we are not returning an instance reference but rather the
            # complete relation value of the related instances. This allows us
            # to further filter the result in the "findRelatedWhere" command.
            return [list $srcrelvar $related]
        }
        proc findRelated {instref args} {
            tailcall ToRef {*}[::rosea::InstCmds::FindRelatedInsts $instref semijoin\
                    {*}$args]
        }
        
        proc findUnrelated {instref args} {
            tailcall ToRef {*}[::rosea::InstCmds::FindRelatedInsts $instref semiminus\
                    {*}$args]
        }
        
        proc findRelatedWhere {instref rchain expr} {
            lassign [::rosea::InstCmds::FindRelatedInsts $instref semijoin {*}$rchain]\
                    relvar insts
            tailcall ToRef $relvar [uplevel 1\
                [list ::ral relation restrictwith $insts $expr]]
        }
        
        proc findUnrelatedWhere {instref rchain expr} {
            lassign [::rosea::InstCmds::FindRelatedInsts $instref semiminus {*}$rchain]\
                    relvar insts
            tailcall ToRef $relvar [uplevel 1\
                [list ::ral relation restrictwith $insts $expr]]
        }
        proc updateAttribute {ref args} {
            if {[llength $args] % 2 != 0} {
                tailcall DeclError ARG_ERROR $args
            }
        
            lassign $ref relvar insts
        
            # We do not allow updates to the values of identifying attributes.  Changes
            # to identifiers must be accomplished by creating and deleting instances.
            # So we want to make sure that none of the attributes listed in the
            # arguments are actually identifying attributes.
            set idattrs [::struct::set union {*}[relvar identifiers $relvar]]
            set idupdates [::struct::set intersect $args $idattrs]
            if {![::struct::set empty $idupdates]} {
                tailcall DeclError ID_UPDATE $idupdates
            }
        
            # The update strategy is to use the "relvar updateper" command. This
            # command was tailored for this particular purpose. It takes a relation
            # value uses the identifiers in that value and will update non-identifying
            # attributes. So we can create a relation value by extending the instance
            # reference value with the attributes to be updated.  Conveniently, the
            # instance reference contains the identifying attributes.  To perform the
            # extend operation we will need the type of the attribute which we can get
            # from the heading of the relvar.
            set cmd [list relation extend $insts exttuple]
            set heading [relation heading [relvar set $relvar]]
            foreach {attr value} $args {
                lappend cmd $attr [dict get $heading $attr] \"$value\"
            }
            relvar updateper $relvar [eval $cmd]
            return
        }
        proc readAttribute {ref args} {
            # We insist upon a singular reference for reading attributes.  Multiple
            # references can be handled by dereferences and using TclRAL "relation"
            # commands.
            if {![isRefSingular $ref]} {
                tailcall DeclError SINGLE_REF_REQUIRED [refMultiplicity $dstref]
            }
        
            return [expr {[llength $args] == 0 ? {} :\
                [relation extract [deRef $ref {*}$args] {*}$args]}]
        }
        proc delete {instref} {
            lassign $instref relvar insts
            set tuples [deRef $instref]
            relvar minus $relvar $tuples
        
            lassign [SplitRelvarName $relvar] domain class
            set instrelvar ${domain}::${class}::__${class}__STATEINST
            if {[relvar exists $instrelvar]} {
                relvar minus $instrelvar [relvar semijoin $insts $instrelvar]
            }
        
            return
        }
        proc signal {dstset event args} {
            set srcref [SelfInstRef]
            if {![::rosea::Dispatch::MapPolymorphicEvent ::rosea::Dispatch::SignalEvent\
                    $srcref $dstset $event $args]} {
                ::rosea::Dispatch::SignalEvent $srcref $dstset $event $args
            }
            return
        }
        proc delaysignal {time dstset event args} {
            if {!([string is integer -strict $time] && $time >= 0)} {
                tailcall DeclError INVALID_TIME $time
            }
            set srcref [SelfInstRef]
            if {![::rosea::Dispatch::MapPolymorphicEvent\
                    [list ::rosea::Dispatch::SignalDelayedEvent $time]\
                    $srcref $dstset $event $args]} {
                ::rosea::Dispatch::SignalDelayedEvent $time $srcref $dstset $event $args
            }
            return
        }
        proc canceldelayed {srcref dstset event} {
            set srcmult [refMultiplicity $srcref]
            if {$srcmult > 1} {
                tailcall DeclError SINGLE_OR_EMPTY_REF_REQUIRED $srcmult
            }
            forAllRefs dstref $dstset {
                ::rosea::Dispatch::CancelDelayedSignal $srcref $event $dstref
            }
            return
        }
        proc delayremaining {srcref dstref event} {
            set srcmult [refMultiplicity $srcref]
            if {$srcmult > 1} {
                tailcall DeclError SINGLE_OR_EMPTY_REF_REQUIRED $srcmult
            }
            if {![isRefSingular $dstref]} {
                tailcall DeclError SINGLE_REF_REQUIRED [refMultiplicity $dstref]
            }
            tailcall ::rosea::Dispatch::SignalTimeRemaining $srcref $event $dstref
        }
        proc instop {instref op args} {
            tailcall [lindex $instref 0]::instop $instref $op {*}$args
        }
    }
    namespace eval RelCmds {
        namespace import ::ral::relation
        namespace import ::ral::tuple
        namespace import ::ral::relformat
        namespace import ::ralutil::pipe
        namespace import ::ral::relvar
        namespace path [list\
            [namespace parent]::Helpers\
            [namespace parent]::InstCmds\
        ]
        proc linkSimple {rname instref1 instref2} {
            lassign $instref1 relvar1 inst1
            lassign [SplitRelvarName $relvar1] domain1 class1
        
            lassign $instref2 relvar2 inst2
            lassign [SplitRelvarName $relvar2] domain2 class2
        
            if {$domain1 ne $domain2} {
                tailcall DeclError NO_CROSS_DOMAIN $domain1 $domain2
            }
        
            set archns ${domain1}::__Arch
        
            set reflink [relvar restrictone ${archns}::RefLink Relationship $rname]
            if {[relation isempty $reflink]} {
                tailcall DeclError UNKNOWN_RELATIONSHIP $rname
            }
            relation assign $reflink\
                {ReferringClass referringClass}\
                {ReferencedClass referencedClass}\
                {ReferringAttrs referringAttrs}
        
            # First we determine which of the argument instance references are from the
            # referring class and which from the referenced class.
            if {$class1 eq $referringClass && $class2 eq $referencedClass} {
                set fromrelvar $relvar1
                set frominsts $inst1
                set torelvar $relvar2
                set toinst $inst2
            } elseif {$class2 eq $referringClass && $class1 eq $referencedClass} {
                set fromrelvar $relvar2
                set frominsts $inst2
                set torelvar $relvar1
                set toinst $inst1
            } else {
                tailcall DeclError NON_PARTICIPANTS $relvar1 $relvar2 $rname\
                    $referringClass $referencedClass
            }
        
            # You may link many referring instances to the same referenced instance,
            # but there can only be one referenced instance
            if {[relation cardinality $toinst] != 1} {
                tailcall MUST_BE_SINGULAR $torelvar [relation cardinality $toinst]
            }
        
            # The update we want to perform is to modify the values of the referential
            # attributes to match the values of the referenced attributes. First we
            # deference the referenced instance.  We perform the implied semijoin in
            # place since we have already split apart the instance reference into its
            # components.
            set refedvalue [relation semijoin $toinst [relvar set $torelvar]]
        
            # Our stategy for updating the referential attributes is to create a
            # dictionary whose keys are the referential attribute names the values are
            # those of the referenced attributes.  It is important to maintain the
            # correspondence between the referential and referenced attributes. The
            # architectural data structures do this by have the ReferringAttrs as a
            # relation valued attribute.  So it is a matter of extending that relation
            # to include the values and extracting the dictionary.
            set tovalues [pipe {
                relation extend $referringAttrs rfa RefValue string {
                    [relation extract $refedvalue\
                        [tuple extract $rfa ReferencedAttribute]]
                } |
                relation dict ~ ReferringAttribute RefValue
            }]
        
            # Now we iterate across the referring instances updating the referential
            # attributes to be the values of the dictionary we just computed.
            relation foreach frominst $frominsts {
                relvar updateone $fromrelvar fromtup\
                        [tuple get [relation tuple $frominst]] {
                    tuple update $fromtup {*}$tovalues
                }
            }
        
            return
        }
        proc linkAssoc {rname instref1 instref2 args} {
            lassign $instref1 relvar1 inst1
            lassign [SplitRelvarName $relvar1] domain1 class1
        
            lassign $instref2 relvar2 inst2
            lassign [SplitRelvarName $relvar2] domain2 class2
        
            if {$domain1 ne $domain2} {
                tailcall DeclError NO_CROSS_DOMAIN $domain1 $domain2
            }
        
            set archns ${domain1}::__Arch
        
            set assocref [relvar restrictone ${archns}::AssocRef Relationship $rname]
            if {[relation isempty $assocref]} {
                tailcall DeclError UNKNOWN_RELATIONSHIP $rname
            }
        
            relation assign $assocref\
                {AssocClass assocClass}\
                {References references}
        
            # For class based associations, we need to identify the participants
            # and check that the instance references refer to relvar that
            # indeed participate in the relationship.
            set ref1 [relation restrictwith $references {$Participant eq $class1}]
            if {[relation isempty $ref1]} {
                tailcall DeclError NOT_IN_ASSOCIATION $class1 $rname
            }
            # Reflexive associations have to be considered. If the association is
            # reflexive then the above query will yield two tuples since the
            # Participants are the same name. In this case, we query for the "target"
            # as a means of disambiguating the reflexive relationship.
            if {[relation cardinality $ref1] > 1} {
                set ref2 [relation restrictwith $ref1 {$Role eq "target"}]
                set ref1 [relation minus $ref1 $ref2]
            } else {
                # For the non-reflexive case, we can just find the other participant,
                # checking that it is indeed there.
                set ref2 [relation restrictwith $references {$Participant eq $class2}]
                if {[relation isempty $ref2]} {
                    tailcall DeclError NOT_IN_ASSOCIATION $class2 $rname
                }
            }
        
            # Dereference the referenced values via the instance reference.
            set values1 [pipe {
                relvar set $relvar1 |
                relation semijoin $inst1 ~
            }]
            set values2 [pipe {
                relvar set $relvar2 |
                relation semijoin $inst2 ~
            }]
        
            # We use a similar strategy here as with "linkSimple". We want to create
            # dictionaries with the referring attributes as keys and the referenced
            # values as the dictionary values.
            set rattr1 [relation extract $ref1 ReferringAttrs]
            set rattr2 [relation extract $ref2 ReferringAttrs]
        
            # Since linking a class based relationships amounts to inserting tuples in
            # the associator relvar, we will accumulate the set of tuples and perform a
            # single "relvar insert".
            set assoctuples [list]
            relation foreach v1 $values1 { # <1>
                set refto1 [pipe {
                    relation extend $rattr1 rfa RefValue string {
                        [relation extract $v1 [tuple extract $rfa ReferencedAttribute]]
                    } |
                    relation dict ~ ReferringAttribute RefValue
                }]
                relation foreach v2 $values2 {
                    set refto2 [pipe {
                        relation extend $rattr2 rfa RefValue string {
                            [relation extract $v2\
                                [tuple extract $rfa ReferencedAttribute]]
                        } |
                        relation dict ~ ReferringAttribute RefValue
                    }]
        
                    # It may be the case that the associator class has other
                    # attributes. Those are passed as attribute/value pairs in the
                    # "args". The merge order is important here just in case the caller
                    # tried to set one of the referential attributes in the invocation.
                    lappend assoctuples [dict merge $args $refto1 $refto2]
                }
            }
        
            return [ToRef ${domain1}::$assocClass\
                    [relvar insert ${domain1}::$assocClass {*}$assoctuples]]
        }
        proc unlinkSimple {rname instref} {
            lassign $instref relvar inst
            lassign [SplitRelvarName $relvar] domain class
        
            set archns ${domain}::__Arch
        
            set reflink [relvar restrictone ${archns}::RefLink Relationship $rname]
            if {[relation isempty $reflink]} {
                tailcall DeclError UNKNOWN_RELATIONSHIP $rname
            }
            relation assign $reflink\
                {ReferringClass referringClass}\
                {ReferencedClass referencedClass}\
                {ReferringAttrs referringAttrs}
        
            if {$class eq $referringClass} {
                set fromrelvar $relvar
                set frominsts $inst
            } elseif {$class eq $referencedClass} {
                lassign [::rosea::InstCmds::findRelated $instref ~$rname]\
                    fromrelvar frominsts
            } else {
                tailcall DeclError NOT_IN_ASSOCIATION $relvar $rname
            }
        
            set tovalues [pipe {
                relation extend $referringAttrs rfa RefValue string {{}} |
                relation dict ~ ReferringAttribute RefValue
            }]
        
            relation foreach frominst $frominsts {
                relvar updateone $fromrelvar fromtup\
                        [tuple get [relation tuple $frominst]] {
                    tuple update $fromtup {*}$tovalues
                }
            }
        
            return
        }
        proc unlinkAssoc {rname instref} {
            lassign $instref relvar insts
            lassign [SplitRelvarName $relvar] domain class
        
            set archns ${domain}::__Arch
        
            set assocref [relvar restrictone ${archns}::AssocRef Relationship $rname]
            if {[relation isempty $assocref]} {
                tailcall DeclError UNKNOWN_RELATIONSHIP $rname
            }
            relation assign $assocref\
                {Relationship relationship}\
                {AssocClass associator}\
                {References references}
        
            if {$class eq $associator} {
                set associnsts [deRef $instref]
            } else {
                set part [relation restrictwith $references {$Participant eq $class}]
                set partcard [relation cardinality $part]
                if {$partcard == 0} {
                    tailcall DeclError NOT_IN_ASSOCIATION $class $rname
                } elseif {$partcard > 1} {
                    tailcall DeclError AMBIGUOUS_UNLINK $rname $relvar
                } else {
                    # find associative class instances
                    set navdir [expr {[relation extract $part Role] eq "source" ?\
                        $relationship : ~$relationship}]
                    set associnsts [deRef [::rosea::InstCmds::findRelated $instref\
                        [list $navdir [namespace tail $associator]]]]
                }
            }
            # Just remove the associator tuples that are the relationship links.
            relvar minus ${domain}::$associator $associnsts
            return $associnsts
        }
        proc migrate {rname instref subclass args} {
            if {![isRefSingular $instref]} {
                tailcall DeclError SINGLE_REF_REQUIRED [refMultiplicity $instref]
            }
            lassign $instref relvar inst
            lassign [SplitRelvarName $relvar] domns class
            set archns ${domns}::__Arch
        
            set link [relvar restrictone ${archns}::AssociationLink Name $rname\
                    SrcClass $class]
            if {[relation isempty $link]} {
                tailcall DeclError NO_SUBCLASS $rname $relvar
            }
            #puts [relformat $link link]
        
            # Traverse the relationship to the superclass. We need to get the values of
            # the referenced attributes to use in creating the new subclass instance.
            set superinst [pipe {
                relvar set ${domns}::[relation extract $link DstClass] |
                relation semijoin $inst ~ -using [relation extract $link Attrs]
            }]
        
            set sublink [relvar restrictone ${archns}::SubLink Relationship $rname\
                    SubClass $subclass]
            if {[relation isempty $sublink]} {
                tailcall DeclError NO_SUBCLASS $rname $subclass
            }
            #puts [relformat $sublink sublink]
        
            # Using the same relation extend strategy, we compute a dictionary of the
            # attribute names / values as they must appear in the subclass we are about
            # to create.
            set refedvalues [pipe {
                relation extract $sublink ReferringAttrs |
                relation extend ~ rval Value string {
                    [relation extract $superinst\
                        [tuple extract $rval ReferencedAttribute]]
                } |
                relation dict ~ ReferringAttribute Value
            }]
        
            # We use the class commands to delete the old subclass instance and create
            # the new one. This will make sure that if the subclass has a state model
            # that the initial state is set correctly.
            relvar eval {
                ::rosea::InstCmds::delete $instref
                set ref [::rosea::ClassCmds::create ${domns}::$subclass\
                        {*}[dict merge $args $refedvalues]]
            }
            return $ref
        }
        proc signalAssigner {rname event args} {
            lassign [SplitRelvarName $rname] domain relationship
            set assignrelvar ${domain}::__${relationship}__STATEINST
            if {![relvar exists $assignrelvar} {
                tailcall DeclError NO_ASSIGNER $rname
            }
        
            set dstref [pipe {
                relvar set $assignrelvar |
                relation project ~ {*}[lindex [relvar identifiers $assignrelvar] 0] |
                list $rname ~
            }]
            set srcref [SelfInstRef]
            ::rosea::Dispatch::SignalEvent $srcref $dstset $event $args
        
            return
        }
        proc signalMultiAssigner {rname idvalues event args} {
            lassign [SplitRelvarName $rname] domain relationship
            set assignrelvar ${domain}::__${relationship}__STATEINST
            if {![relvar exists $assignrelvar} {
                tailcall DeclError NO_ASSIGNER $rname
            }
            set assigninsts [relvar set $assignrelvar]
            set assignrefs [relation project $assigninsts\
                    {*}[lindex [relvar identifiers $assignrelvar] 0]]
            # We need to find the tuple in "assignrefs" that matches the attributes and
            # values in "idvalues". We will do this by creating a relation value from
            # the idvalues list and semijoining that to "assignrefs". If we come up
            # non-empty, then we have found our multi-assigner instance.  We will
            # insist that the idvalues contain the necessary identifying attributes.
            # HERE, make sure idvalues contains the attributes as heading.
            set heading [relation heading $assignrefs]
            set dstinst [pipe {
                tuple create $heading $idvalues |
                tuple relation ~
                relation semijoin ~ $assignrefs
            }]
            if {[relation isempty $dstinst]} {
                tailcall DeclError UNKNOWN_ASSIGNER $idvalues $rname
            }
            set dstref [list $rname $dstinst]
        
            set srcref [SelfInstRef]
            ::rosea::Dispatch::SignalEvent $srcref $dstset $event $args
        
            return
        }
    }
    namespace eval Dispatch {
        namespace import ::ral::relation
        namespace import ::ral::tuple
        namespace import ::ral::relformat
        namespace import ::ralutil::pipe
        namespace import ::ral::relvar
        namespace path [list\
            [namespace parent]::Helpers\
            [namespace parent]::InstCmds\
        ]
        pipe {
            relvar set ${archns}::PartitionDst |
            relation restrictwith ~ {$SrcClass eq $dstclass} |
            relation group ~ DstLinks DstClass Attrs
        } polymapQuery
        variable event_queue [list]
        variable inTransaction false
        relvar create DelayedSignal {
            SrcInstRef      list
            Event           string
            DstInstRef      list
            TimerId         string
            Expire          bignum
        } {SrcInstRef Event DstInstRef}
        proc MapPolymorphicEvent {frwdcmd srcref dstrefs event arglist} {
            lassign $dstrefs dstrelvar dstinsts ; # <1>
            lassign [SplitRelvarName $dstrelvar] domain dstclass
            set archns ${domain}::__Arch
            set polyevent [relvar restrictone ${archns}::PolymorphicEvent\
                Class $dstclass Event $event]
            if {[relation isempty $polyevent]} {
                return false
            }
        
            variable polymapQuery
            set partitions [eval $polymapQuery] ; # <2>
        
            relation foreach inst $dstinsts { # <3>
                relation foreach partition $partitions {
                    relation assign $partition
                    relation foreach dstlink $DstLinks {
                        relation assign $dstlink
                        set related [relation semijoin $inst\
                            [relvar set ${domain}::$DstClass] -using $Attrs] ; # <4>
                        if {[relation isnotempty $related]} {
                            set dstreference [ToRef ${domain}::$DstClass $related]
                            ::rosea::Trace::TracePolymorphic $srcref\
                                $event $dstreference ${domain}::SrcClass $Name
                            {*}$frwdcmd $srcref $dstreference $event $arglist
                            break
                        }
                    }
                }
            }
            return true
        }
        proc SignalEvent {srcref dstset event arglist} {
            variable event_queue
            forAllRefs dstref $dstset {
                set eventInfo [dict create\
                    src $srcref\
                    event $event\
                    dst $dstref\
                    params $arglist\
                ]
                if {[isRefEqual $srcref $dstref]} {
                    set eqindex 0
                    foreach cmpevent $event_queue {
                        if {![isRefEqual [dict get $cmpevent src]\
                                [dict get $cmpevent dst]]} {
                            break
                        }
                        incr eqindex
                    }
                    set event_queue [linsert $event_queue $eqindex $eventInfo]
                } else {
                    lappend event_queue $eventInfo
                }
                ::after 0 [namespace code DispatchEvent]
            }
        }
        proc DispatchEvent {} {
            variable event_queue
            variable inTransaction
        
            set eqlen [llength $event_queue]
            if {$eqlen != 0} {
                # Pull the event from the front of the queue.
                set eventInfo [lindex $event_queue 0]
                set event_queue [lrange $event_queue 1 end]
        
                set dstref [dict get $eventInfo dst]
                lassign $dstref relvar ref
                lassign [SplitRelvarName $relvar] domain class
                set archns ${domain}::__Arch
        
                set instrelvar ${domain}::__${class}__STATEINST
                set state [relation semijoin $ref [relvar set $instrelvar]]
                if {[relation isempty $state]} {
                    tailcall DeclError EVENT_IN_FLIGHT [dict get $eventInfo event]\
                        $ref
                }
                set currstate [relation extract $state __State]
                set event [dict get $eventInfo event]
        
                set newState [pipe {
                    relvar restrictone ${archns}::Transition\
                        Class $class State $currstate Event $event |
                    relation extract ~ NewState
                }]
                ::rosea::Trace::TraceTransition [dict get $eventInfo src]\
                    $event $dstref $currstate $newState [dict get $eventInfo params]
        
                if {$newState eq "CH"} {
                    tailcall DeclError CANT_HAPPEN_EVENT [dict get $eventInfo src]\
                        $event $dstref $currstate
                } elseif {$newState ne "IG"} {
                    set idattrs [tuple get [ral relation tuple $ref]]
                    relvar updateone $instrelvar is $idattrs {
                        tuple update $is __State $newState
                    }
                    try {
                        if {$eqlen == 1 && !$inTransaction} {
                            relvar transaction begin
                            set inTransaction true
                        }
                        ${relvar}::__Activity::$newState $dstref\
                                {*}[dict get $eventInfo params]
                    } finally {
                        if {[llength $event_queue] == 0 && $inTransaction} {
                            relvar transaction end
                            set inTransaction false
                        }
                        set term [relvar restrictone ${domain}::__Arch::Terminal\
                                Class $class State $newState]
                        if {[relation isnotempty $term]} {
                            relvar deleteone $relvar {*}$idattrs
                            relvar deleteone $instrelvar {*}$idattrs
                        }
                    }
                }
            }
            return
        }
        proc SignalDelayedEvent {time srcref dstset event arglist} {
            forAllRefs dstref $dstset {
                # Cancel any existing delayed signal that might have been in place.
                CancelDelayedSignal $srcref $event $dstref
                relvar insert DelayedSignal [list\
                    SrcInstRef  $srcref\
                    Event       $event\
                    DstInstRef  $dstref\
                    TimerId     [::after $time\
                                [list ::rosea::Dispatch::DispatchDelayedEvent\
                                    $srcref $event $dstref $arglist]]\
                    Expire      [expr {entier([clock milliseconds]) + entier($time)}]\
                ]
            }
            return
        }
        proc DispatchDelayedEvent {srcref event dstref params} {
            DeleteDelayedSignal $srcref $event $dstref
            variable event_queue
            lappend event_queue [dict create\
                src $srcref\
                event $event\
                dst $dstref\
                params $params\
            ]
            tailcall DispatchEvent
        }
        proc CancelDelayedSignal {srcref event dstref} {
            variable DelayedSignal
            set sig [FindDelayedSignal $srcref $event $dstref]
            if {[relation isnotempty $sig]} {
                ::after cancel [relation extract $sig TimerId]
                DeleteDelayedSignal $srcref $event $dstref
            }
        }
        proc SignalTimeRemaining {srcref event dstref} {
            set sig [FindDelayedSignal $srcref $event $dstref]
            if {[relation isnotempty $sig]} {
                set remaining [expr {[relation extract $sig Expire] -\
                    [clock milliseconds]}]
                if {$remaining < 0} {
                    set remaining 0
                }
            } else {
                set remaining 0
            }
        
            return $remaining
        }
        proc FindDelayedSignal {srcref event dstref} {
            variable DelayedSignal
            return [relation restrictwith $DelayedSignal {
                    [isRefEqual $SrcInstRef $srcref] && $Event eq $event &&\
                    [isRefEqual $DstInstRef $dstref]}]
        }
        proc DeleteDelayedSignal {srcref event dstref} {
            relvar delete DelayedSignal dsig {
                [isRefEqual [tuple extract $dsig SrcInstRef] $srcref] &&\
                [tuple extract $dsig Event] eq $event &&\
                [isRefEqual [tuple extract $dsig DstInstRef] $dstref]
            }
        }
    }
    namespace eval Config {
        logger::initNamespace [namespace current]
    
        namespace import ::ral::relation
        namespace import ::ral::tuple
        namespace import ::ral::relformat
        namespace import ::ralutil::pipe
        namespace import ::ral::relvar
        namespace path [namespace parent]::Helpers
        variable evalLambda {{body} {
            upvar #0 ::rosea::Config::errcount errcount ; # <1>
            upvar #0 ::rosea::Config::configlineno configlineno
            set cmdline $configlineno
            set command {}
            foreach line [split $body \n] { # <2>
                append command $line \n
                incr cmdline ; # <3>
                if {[info complete $command]} {
                    try {
                        eval $command
                    } on error {result} {
                        log::error "line $configlineno: \"$result\""
                        incr errcount
                    }
                    set command {} ; # <4>
                    set configlineno $cmdline
                }
            }
            return $errcount
        }}
        relvar create Domain {
            Name        string
            Location    string
        } Name
        
        relvar create DomainElement {
            Domain  string
            Element string
        } {Domain Element}
        
        relvar association R1\
            DomainElement Domain *\
            Domain Name 1
        
        relvar create Class {
            Domain  string
            Name    string
        } {Domain Name}
        
        relvar create Relationship {
            Domain  string
            Name    string
        } {Domain Name}
        
        relvar create DomainOperation {
            Domain      string
            Name        string
            Parameters  list
            Body        string
        } {Domain Name}
        
        relvar partition R2 DomainElement {Domain Element}\
            Class {Domain Name}\
            Relationship {Domain Name}\
            DomainOperation {Domain Name}
        relvar create Attribute {
            Domain  string
            Class   string
            Name    string
            Type    string
        } {Domain Class Name}
        
        relvar association R3\
            Attribute {Domain Class} +\
            Class {Domain Name} 1
        
        relvar create Identifier {
            Domain  string
            Class   string
            Number  int
        } {Domain Class Number}
        
        relvar association R4\
            Identifier {Domain Class} +\
            Class {Domain Name} 1
        
        relvar create IdentifyingAttribute {
            Domain      string
            Class       string
            Attribute   string
            Number      int
        } {Domain Class Attribute Number}
        
        relvar correlation R5 IdentifyingAttribute\
            {Domain Class Number} + Identifier {Domain Class Number}\
            {Domain Class Attribute} * Attribute {Domain Class Name}
        
        relvar create DefaultValue {
            Domain      string
            Class       string
            Attribute   string
            Value       string
        } {Domain Class Attribute}
        
        relvar association R6\
            DefaultValue {Domain Class Attribute} ?\
            Attribute {Domain Class Name} 1
        
        relvar create AttributeReference {
            Domain              string
            ReferringClass      string
            ReferringAttribute  string
            ReferringRole       string
            ReferencedClass     string
            ReferencedAttribute string
            ReferencedRole      string
            ReferencedIdNumber  int
            Relationship        string
        } {Domain ReferringClass ReferringAttribute ReferringRole\
            ReferencedClass ReferencedAttribute ReferencedRole ReferencedIdNumber\
            Relationship}
        
        relvar association R13\
            AttributeReference {Domain ReferringClass ReferringAttribute} *\
            Attribute {Domain Class Name} 1
        
        relvar create ReferencedIdAttribute {
            Domain          string
            Class           string
            Relationship    string
            Role            string
            Attribute       string
            Number          int
        } {Domain Class Relationship Role Attribute Number}
        relvar create Operation {
            Domain  string
            Class   string
            Name    string
        } {Domain Class Name}
        
        relvar association R8\
            Operation {Domain Class} * Class {Domain Name} 1
        
        relvar create InstanceOperation {
            Domain  string
            Class   string
            Name    string
        } {Domain Class Name}
        
        relvar create ClassOperation {
            Domain  string
            Class   string
            Name    string
        } {Domain Class Name}
        
        relvar partition R7 Operation {Domain Class Name}\
            InstanceOperation {Domain Class Name}\
            ClassOperation {Domain Class Name}
        
        relvar create UserInstanceOperation {
            Domain      string
            Class       string
            Name        string
            Parameters  string
            Body        string
        } {Domain Class Name}
        
        relvar create SystemInstanceOperation {
            Domain      string
            Class       string
            Name        string
        } {Domain Class Name}
        
        relvar partition R9 InstanceOperation {Domain Class Name}\
            UserInstanceOperation {Domain Class Name}\
            SystemInstanceOperation {Domain Class Name}
        
        relvar create UserClassOperation {
            Domain  string
            Class   string
            Name    string
            Parameters  string
            Body        string
        } {Domain Class Name}
        
        relvar create SystemClassOperation {
            Domain  string
            Class   string
            Name    string
        } {Domain Class Name}
        
        relvar partition R10 ClassOperation {Domain Class Name}\
            UserClassOperation {Domain Class Name}\
            SystemClassOperation {Domain Class Name}
        
        relvar create SuppliedOperation {
            Name                string
            Command             string
            RequiresStateModel  boolean
        } Name
        
        relvar create SuppliedClassOperation {
            Name    string
        } Name
        
        relvar create SuppliedInstanceOperation {
            Name    string
        } Name
        
        relvar partition R14 SuppliedOperation Name\
            SuppliedClassOperation Name\
            SuppliedInstanceOperation Name
        
        relvar association R15\
            SystemClassOperation Name *\
            SuppliedClassOperation Name 1
        
        relvar association R16\
            SystemInstanceOperation Name *\
            SuppliedInstanceOperation Name 1
        relvar eval {
            relvar insert SuppliedOperation {
                Name                findAll
                Command             ::rosea::ClassCmds::findAll
                RequiresStateModel  false
            } {
                Name                findById
                Command             ::rosea::ClassCmds::findById
                RequiresStateModel  false
            } {
                Name                findWhere
                Command             ::rosea::ClassCmds::findWhere
                RequiresStateModel  false
            } {
                Name                create
                Command             ::rosea::ClassCmds::create
                RequiresStateModel  false
            } {
                Name                createin
                Command             ::rosea::ClassCmds::createin
                RequiresStateModel  true
            } {
                Name                createasync
                Command             ::rosea::ClassCmds::createasync
                RequiresStateModel  true
            } {
                Name                update
                Command             ::rosea::ClassCmds::update
                RequiresStateModel  false
            }
        
            relvar insert SuppliedClassOperation {
                Name    findAll
            } {
                Name    findById
            } {
                Name    findWhere
            } {
                Name    create
            } {
                Name    createin
            } {
                Name    createasync
            } {
                Name    update
            }
        }
        relvar eval {
            relvar insert SuppliedOperation {
                Name                findRelated
                Command             ::rosea::InstCmds::findRelated
                RequiresStateModel  false
            } {
                Name                findUnrelated
                Command             ::rosea::InstCmds::findById
                RequiresStateModel  false
            } {
                Name                findRelatedWhere
                Command             ::rosea::InstCmds::findRelatedWhere
                RequiresStateModel  false
            } {
                Name                findUnrelatedWhere
                Command             ::rosea::InstCmds::findUnrelatedWhere
                RequiresStateModel  false
            } {
                Name                updateAttribute
                Command             ::rosea::InstCmds::updateAttribute
                RequiresStateModel  false
            } {
                Name                readAttribute
                Command             ::rosea::InstCmds::readAttribute
                RequiresStateModel  false
            } {
                Name                delete
                Command             ::rosea::InstCmds::delete
                RequiresStateModel  false
            } {
                Name                signal
                Command             ::rosea::InstCmds::signal
                RequiresStateModel  true
            } {
                Name                delaysignal
                Command             ::rosea::InstCmds::delaysignal
                RequiresStateModel  true
            } {
                Name                canceldelayed
                Command             ::rosea::InstCmds::canceldelayed
                RequiresStateModel  true
            } {
                Name                delayremaining
                Command             ::rosea::InstCmds::delayremaining
                RequiresStateModel  true
            } {
                Name                deRef
                Command             ::rosea::InstCmds::deRef
                RequiresStateModel  false
            } {
                Name                isEmptyRef
                Command             ::rosea::InstCmds::isEmptyRef
                RequiresStateModel  false
            } {
                Name                isNotEmptyRef
                Command             ::rosea::InstCmds::isNotEmptyRef
                RequiresStateModel  false
            } {
                Name                refMultiplicity
                Command             ::rosea::InstCmds::refMultiplicity
                RequiresStateModel  false
            } {
                Name                isRefSingular
                Command             ::rosea::InstCmds::isRefSingular
                RequiresStateModel  false
            } {
                Name                isRefEqual
                Command             ::rosea::InstCmds::isRefEqual
                RequiresStateModel  false
            } {
                Name                forAllRefs
                Command             ::rosea::InstCmds::forAllRefs
                RequiresStateModel  false
            }
        
            relvar insert SuppliedInstanceOperation {
                Name    findRelated
            } {
                Name    findUnrelated
            } {
                Name    findRelatedWhere
            } {
                Name    findUnrelatedWhere
            } {
                Name    updateAttribute
            } {
                Name    readAttribute
            } {
                Name    delete
            } {
                Name    signal
            } {
                Name    delaysignal
            } {
                Name    canceldelayed
            } {
                Name    delayremaining
            } {
                Name    deRef
            } {
                Name    isEmptyRef
            } {
                Name    isNotEmptyRef
            } {
                Name    refMultiplicity
            } {
                Name    isRefSingular
            } {
                Name    isRefEqual
            } {
                Name    forAllRefs
            }
        }
        relvar create Association {
            Domain      string
            Name        string
        } {Domain Name}
        
        relvar create Generalization {
            Domain      string
            Name        string
        } {Domain Name}
        
        relvar partition R30 Relationship {Domain Name}\
            Association {Domain Name}\
            Generalization {Domain Name}
        
        relvar create SimpleAssociation {
            Domain      string
            Name        string
        } {Domain Name}
        
        relvar create ClassBasedAssociation {
            Domain      string
            Name        string
        } {Domain Name}
        
        relvar partition R31 Association {Domain Name}\
            SimpleAssociation {Domain Name}\
            ClassBasedAssociation {Domain Name}
        
        relvar create SimpleReferringClass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
            Conditionality  boolean
            Multiplicity    boolean
        } {Domain Class Relationship Role}
        
        relvar association R32\
            SimpleReferringClass {Domain Relationship} 1\
            SimpleAssociation {Domain Name} 1
        
        relvar create SimpleReferencedClass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
            Conditionality  boolean
        } {Domain Class Relationship Role}
        
        relvar association R33\
            SimpleReferencedClass {Domain Relationship} 1\
            SimpleAssociation {Domain Name} 1
        
        relvar create SourceClass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
            Conditionality  boolean
            Multiplicity    boolean
        } {Domain Class Relationship Role}
        
        relvar association R34\
            SourceClass {Domain Relationship} 1\
            ClassBasedAssociation {Domain Name} 1
        
        relvar create TargetClass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
            Conditionality  boolean
            Multiplicity    boolean
        } {Domain Class Relationship Role}
        
        relvar association R35\
            TargetClass {Domain Relationship} 1\
            ClassBasedAssociation {Domain Name} 1
        
        relvar create AssociatorClass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
        } {Domain Class Relationship Role}
        
        relvar association R42\
            AssociatorClass {Domain Relationship} 1\
            ClassBasedAssociation {Domain Name} 1
        
        relvar create Superclass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
        } {Domain Class Relationship Role}
        
        relvar association R36\
            Superclass {Domain Relationship} 1\
            Generalization {Domain Name} 1
        
        relvar create Subclass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
        } {Domain Class Relationship Role}
        
        relvar association R37\
            Subclass {Domain Relationship} +\
            Generalization {Domain Name} 1
        
        relvar create ReferringClass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
        } {Domain Class Relationship Role}
        
        relvar partition R38 ReferringClass {Domain Class Relationship Role}\
            SimpleReferringClass {Domain Class Relationship Role}\
            AssociatorClass {Domain Class Relationship Role}\
            Subclass {Domain Class Relationship Role}
        
        relvar create ReferencedClass {
            Domain          string
            Class           string
            Relationship    string
            Role            string
        } {Domain Class Relationship Role}
        
        relvar partition R39 ReferencedClass {Domain Class Relationship Role}\
            SimpleReferencedClass {Domain Class Relationship Role}\
            SourceClass {Domain Class Relationship Role}\
            TargetClass {Domain Class Relationship Role}\
            Superclass {Domain Class Relationship Role}
        
        relvar create ClassRole {
            Domain          string
            Class           string
            Relationship    string
            Role            string
        } {Domain Class Relationship Role}
        
        relvar partition R40 ClassRole {Domain Class Relationship Role}\
            ReferringClass {Domain Class Relationship Role}\
            ReferencedClass {Domain Class Relationship Role}
        
        relvar correlation R41 ClassRole\
            {Domain Relationship} + Relationship {Domain Name}\
            {Domain Class} * Class {Domain Name}
        
        relvar correlation R11 ReferencedIdAttribute\
            {Domain Class Relationship Role} +\
                ReferencedClass {Domain Class Relationship Role}\
            {Domain Class Attribute Number} *\
                IdentifyingAttribute {Domain Class Attribute Number}
        
        relvar correlation R12 AttributeReference\
            {Domain ReferringClass Relationship ReferringRole} +\
                ReferringClass {Domain Class Relationship Role}\
            {Domain ReferencedClass Relationship ReferencedRole ReferencedAttribute\
                    ReferencedIdNumber} +\
                ReferencedIdAttribute {Domain Class Relationship Role Attribute Number}
        relvar create __AssocInfo {
            Spec                string
            NeedsAssociator     boolean
            ReflexiveAllowed    boolean
            ReferringCond       boolean
            ReferringMult       boolean
            ReferencedCond      boolean
            ReferencedMult      boolean
        } Spec
        
        relvar insert __AssocInfo {
            Spec 1--1 NeedsAssociator false ReflexiveAllowed true
                ReferringCond false ReferringMult false
                ReferencedCond false ReferencedMult false
        } {
            Spec 0..1--1 NeedsAssociator false ReflexiveAllowed false
                ReferringCond true ReferringMult false
                ReferencedCond false ReferencedMult false
        } {
            Spec 0..1--0..1 NeedsAssociator false ReflexiveAllowed true
                ReferringCond true ReferringMult false
                ReferencedCond true ReferencedMult false
        } {
            Spec 1..n--1 NeedsAssociator false ReflexiveAllowed true
                ReferringCond false ReferringMult true
                ReferencedCond false ReferencedMult false
        } {
            Spec 0..n--1 NeedsAssociator false ReflexiveAllowed false
                ReferringCond true ReferringMult true
                ReferencedCond false ReferencedMult false
        } {
            Spec 1..n--0..1 NeedsAssociator false ReflexiveAllowed false
                ReferringCond false ReferringMult true
                ReferencedCond true ReferencedMult false
        } {
            Spec 0..n--0..1 NeedsAssociator false ReflexiveAllowed true
                ReferringCond true ReferringMult true
                ReferencedCond true ReferencedMult false
        } {
            Spec 1..n--1..n NeedsAssociator true ReflexiveAllowed true
                ReferringCond false ReferringMult true
                ReferencedCond false ReferencedMult true
        } {
            Spec 0..n--1..n NeedsAssociator true ReflexiveAllowed false
                ReferringCond true ReferringMult true
                ReferencedCond false ReferencedMult true
        } {
            Spec 1..n--0..n NeedsAssociator true ReflexiveAllowed false
                ReferringCond false ReferringMult true
                ReferencedCond true ReferencedMult true
        } {
            Spec 0..n--0..n NeedsAssociator true ReflexiveAllowed true
                ReferringCond true ReferringMult true
                ReferencedCond true ReferencedMult true
        }
        relvar create ClassAssoc {
            Domain              string
            Relationship        string
            AssocClass          string
            SourceClass         string
        } {Domain Relationship AssocClass SourceClass}
        
        relvar create NonReflexiveAssoc {
            Domain              string
            Relationship        string
            AssocClass          string
            SourceClass         string
            TargetClass         string
        } {Domain Relationship AssocClass SourceClass}
        
        relvar create ReflexiveAssoc {
            Domain              string
            Relationship        string
            AssocClass          string
            SourceClass         string
        } {Domain Relationship AssocClass SourceClass}
        
        relvar create ReflexivePath {
            Domain              string
            Relationship        string
            AssocClass          string
            SourceClass         string
            SourceAttr          string
            TargetAttr          string
        } {Domain Relationship AssocClass SourceClass SourceAttr}
        
        relvar partition X1 ClassAssoc {Domain Relationship AssocClass SourceClass}\
            NonReflexiveAssoc {Domain Relationship AssocClass SourceClass}\
            ReflexiveAssoc {Domain Relationship AssocClass SourceClass}
        relvar association X2\
            ReflexivePath {Domain Relationship AssocClass SourceClass} +\
            ReflexiveAssoc {Domain Relationship AssocClass SourceClass} 1
        relvar create StateModel {
            Domain          string
            Model           string
            InitialState    string
            DefaultTrans    string
        } {Domain Model}
        
        relvar create InstanceStateModel {
            Domain          string
            Class           string
        } {Domain Class}
        
        relvar association R51\
            InstanceStateModel {Domain Class} ?\
            Class {Domain Name} 1
        
        relvar create AssignerStateModel {
            Domain          string
            Relationship    string
        } {Domain Relationship}
        
        relvar association R52\
            AssignerStateModel {Domain Relationship} ?\
            Association {Domain Name} 1
        
        relvar partition R50 StateModel {Domain Model}\
            InstanceStateModel {Domain Class}\
            AssignerStateModel {Domain Relationship}
        
        relvar create SingleAssigner {
            Domain          string
            Relationship    string
        } {Domain Relationship}
        
        relvar create MultipleAssigner {
            Domain          string
            Relationship    string
            Class           string
            Number          int
        } {Domain Relationship}
        
        relvar partition R53 AssignerStateModel {Domain Relationship}\
            SingleAssigner {Domain Relationship}\
            MultipleAssigner {Domain Relationship}
        
        relvar association R54\
            MultipleAssigner {Domain Class Number} ?\
            Identifier {Domain Class Number} 1
        
        relvar create State {
            Domain          string
            Model           string
            Name            string
            Parameters      string
            Action          string
            IsFinal         boolean
        } {Domain Model Name}
        
        relvar association R55\
            State {Domain Model} +\
            StateModel {Domain Model} 1
        
        relvar association R58\
            StateModel {Domain Model InitialState} ?\
            State {Domain Model Name} 1
        
        relvar create TransitionRule {
            Name    string
        } Name
        
        relvar insert TransitionRule {Name IG} {Name CH}
        
        relvar association R59\
            StateModel DefaultTrans *\
            TransitionRule Name 1
        
        relvar create CreationState {
            Domain          string
            Model           string
            Name            string
        } {Domain Model Name}
        
        relvar create StatePlace {
            Domain          string
            Model           string
            Name            string
        } {Domain Model Name}
        
        relvar partition R57 StatePlace {Domain Model Name}\
            State {Domain Model Name}\
            CreationState {Domain Model Name}
        relvar create Event {
            Domain  string
            Model   string
            Event   string
        } {Domain Model Event}
        
        relvar create DeferredEvent {
            Domain  string
            Model   string
            Event   string
        } {Domain Model Event}
        
        relvar create EffectiveEvent {
            Domain  string
            Model   string
            Event   string
        } {Domain Model Event}
        
        relvar partition R80 Event {Domain Model Event}\
            DeferredEvent {Domain Model Event}\
            EffectiveEvent {Domain Model Event}
        
        relvar create DeferralPath {
            Domain          string
            Model           string
            Event           string
            Relationship    string
            Role            string
        } {Domain Model Event Relationship Role}
        
        relvar correlation R86 DeferralPath\
            {Domain Model Event} + DeferredEvent {Domain Model Event}\
            {Domain Model Relationship Role} * Superclass\
                {Domain Class Relationship Role}
        
        relvar create PolymorphicEvent {
            Domain  string
            Model   string
            Event   string
        } {Domain Model Event}
        
        relvar create InheritedEvent {
            Domain  string
            Model   string
            Event   string
        } {Domain Model Event}
        
        relvar partition R81 DeferredEvent {Domain Model Event}\
            PolymorphicEvent {Domain Model Event}\
            InheritedEvent {Domain Model Event}
        
        relvar create MappedEvent {
            Domain      string
            Model       string
            Event       string
            ParentModel string
        } {Domain Model Event}
        
        relvar association R84\
            MappedEvent {Domain ParentModel Event} *\
            DeferredEvent {Domain Model Event} 1
        
        relvar create LocalEvent {
            Domain  string
            Model   string
            Event   string
        } {Domain Model Event}
        
        relvar partition R82 EffectiveEvent {Domain Model Event}\
            MappedEvent {Domain Model Event}\
            LocalEvent {Domain Model Event}
        
        relvar create NonLocalEvent {
            Domain          string
            Model           string
            Event           string
            Relationship    string
            Role            string
        } {Domain Model Event}
        
        relvar partition R83 NonLocalEvent {Domain Model Event}\
            MappedEvent {Domain Model Event}\
            InheritedEvent {Domain Model Event}
        
        relvar association R85\
            NonLocalEvent {Domain Model Relationship Role} *\
            Subclass {Domain Class Relationship Role} 1
        relvar create TransitionPlace {
            Domain  string
            Model   string
            State   string
            Event   string
        } {Domain Model State Event}
        
        relvar correlation R70 TransitionPlace\
            {Domain Model State} * StatePlace {Domain Model Name}\
            {Domain Model Event} * EffectiveEvent {Domain Model Event}
        
        relvar create StateTransition {
            Domain      string
            Model       string
            State       string
            Event       string
            NewState    string
        } {Domain Model State Event}
        
        relvar create NonStateTransition {
            Domain      string
            Model       string
            State       string
            Event       string
            TransRule   string
        } {Domain Model State Event}
        
        relvar partition R71 TransitionPlace {Domain Model State Event}\
            StateTransition {Domain Model State Event}\
            NonStateTransition {Domain Model State Event}
        
        relvar association R72\
            StateTransition {Domain Model NewState} *\
            State {Domain Model Name} 1
        
        relvar association R73\
            NonStateTransition TransRule *\
            TransitionRule Name 1
        namespace export ConfigEvaluate
        
        proc ConfigEvaluate {ns body} {
            variable evalLambda
            tailcall ::apply [concat $evalLambda $ns] $body
        }
        proc domain {name body} {
            namespace upvar DomainDef DomainName DomainName ; # <1>
            set DomainName $name
        
            relvar uinsert ::rosea::Config::Domain [list Name $name Location {}] ; # <2>
            try {
                if {$name eq {}} {
                    tailcall DeclError EMPTY_NAME domain
                }
        
                ConfigEvaluate [namespace current]::DomainDef  $body
        
                # At this point we have the definition of the domain and enough
                # information to tie together the referential attributes and
                # the association definitions.
                variable ReferencedClass
                variable ReferringClass
                variable ReferencedIdAttribute
                variable AttributeReference
                variable NonReflexiveAssoc
                variable ReflexivePath
                
                #puts [relformat $ReferencedClass ReferencedClass]
                #puts [relformat $ReferringClass ReferringClass]
                #puts [relformat $AttributeReference AttributeReference]
                #puts [relformat $NonReflexiveAssoc NonReflexiveAssoc]
                #puts [relformat $ReflexivePath ReflexivePath]
                
                relation foreach nra $NonReflexiveAssoc {
                    relation assign $nra
                    relvar update ::rosea::Config::AttributeReference ar {
                        [tuple extract $ar Domain] eq $Domain &&
                        [tuple extract $ar Relationship] eq $Relationship &&
                        [tuple extract $ar ReferringClass] eq $AssocClass
                    } {tuple update $ar ReferringRole associator}
                
                    relvar update ::rosea::Config::AttributeReference ar {
                        [tuple extract $ar Domain] eq $Domain &&
                        [tuple extract $ar Relationship] eq $Relationship &&
                        [tuple extract $ar ReferringClass] eq $AssocClass &&
                        [tuple extract $ar ReferencedClass] eq $SourceClass
                    } {tuple update $ar ReferencedRole source}
                }
                
                relation foreach rp $ReflexivePath {
                    relation assign $rp
                    relvar update ::rosea::Config::AttributeReference ar {
                        [tuple extract $ar Domain] eq $Domain &&
                        [tuple extract $ar Relationship] eq $Relationship &&
                        [tuple extract $ar ReferringClass] eq $AssocClass
                    } {tuple update $ar ReferringRole associator}
                
                    relvar update ::rosea::Config::AttributeReference ar {
                        [tuple extract $ar Domain] eq $Domain &&
                        [tuple extract $ar Relationship] eq $Relationship &&
                        [tuple extract $ar ReferringClass] eq $AssocClass &&
                        [tuple extract $ar ReferringAttribute] eq $SourceAttr
                    } {tuple update $ar ReferencedRole source}
                }
                
                pipe {
                    relvar set ::rosea::Config::AttributeReference |
                    relation project ~ Domain ReferencedClass Relationship ReferencedRole\
                            ReferencedAttribute ReferencedIdNumber |
                    relation rename ~ ReferencedClass Class ReferencedRole Role\
                            ReferencedAttribute Attribute ReferencedIdNumber Number |
                    relvar union ::rosea::Config::ReferencedIdAttribute
                }
                
                #puts [relformat $AttributeReference AttributeReference]
                #puts [relformat $ReferencedIdAttribute ReferencedIdAttribute]
                # Create Deferral Path instances
                
                variable PolymorphicEvent
                variable DeferredEvent
                variable Superclass
                variable Subclass
                variable DeferralPath
                
                set dpaths [pipe {
                    relation restrictwith $PolymorphicEvent {$Domain eq $name} |
                    relation semijoin ~ $DeferredEvent |
                    relation join ~ $Superclass -using {Domain Domain Model Class}
                }]
                relvar insert ::rosea::Config::DeferralPath {*}[relation body $dpaths]
                #puts [relformat $DeferralPath DeferralPath]
                
                set supers [relation semiminus $Subclass $Superclass\
                    -using {Domain Domain Class Class}]
                #puts [relformat $supers supers]
                
                relation foreach super $supers {
                    PropagatePolyEvents $super
                }
                
                if {[relation isnotempty $PolymorphicEvent]} {
                #puts [relformat [relvar set ::rosea::Config::Event] Event]
                #puts [relformat [relvar set ::rosea::Config::DeferredEvent] DeferredEvent]
                #puts [relformat [relvar set ::rosea::Config::EffectiveEvent] EffectiveEvent]
                #puts [relformat [relvar set ::rosea::Config::PolymorphicEvent] PolymorphicEvent]
                #puts [relformat [relvar set ::rosea::Config::InheritedEvent] InheritedEvent]
                #puts [relformat [relvar set ::rosea::Config::MappedEvent] MappedEvent]
                #puts [relformat [relvar set ::rosea::Config::LocalEvent] LocalEvent]
                #puts [relformat [relvar set ::rosea::Config::NonLocalEvent] NonLocalEvent]
                }
            } on error {result opts} {
                log::error $result
                upvar #0 ::rosea::Config::errcount errcount
                incr errcount
            }
        }
        namespace eval DomainDef {
            logger::initNamespace [namespace current]
        
            namespace import ::ral::relation
            namespace import ::ral::tuple
            namespace import ::ral::relformat
            namespace import ::ralutil::pipe
            namespace import ::ral::relvar
            namespace import ::rosea::Config::ConfigEvaluate
            namespace import ::rosea::Helpers::DeclError
            proc class {name body} {
                namespace upvar [namespace current] DomainName DomainName ; # <1>
                namespace upvar ClassDef ClassName ClassName
                set ClassName $name
            
                try {
                    if {$name eq {}} {
                        tailcall DeclError EMPTY_NAME class
                    }
                    relvar insert ::rosea::Config::DomainElement [list\
                        Domain  $DomainName\
                        Element $name\
                    ]
                    relvar insert ::rosea::Config::Class [list\
                        Domain  $DomainName\
                        Name    $name\
                    ]
                    set instops [pipe {
                        relvar set ::rosea::Config::SuppliedInstanceOperation |
                        relation extend ~ ioptuple\
                            Domain string {[set DomainName]}\
                            Class string {[set ClassName]}
                    }]
                    relvar union ::rosea::Config::SystemInstanceOperation $instops
                    relvar union ::rosea::Config::InstanceOperation $instops
                    relvar union ::rosea::Config::Operation $instops
                    set classops [pipe {
                        relvar set ::rosea::Config::SuppliedClassOperation |
                        relation extend ~ coptuple\
                            Domain string {[set DomainName]}\
                            Class string {[set ClassName]}
                    }]
                    relvar union ::rosea::Config::SystemClassOperation $classops
                    relvar union ::rosea::Config::ClassOperation $classops
                    relvar union ::rosea::Config::Operation $classops
            
                    ConfigEvaluate [namespace current]::ClassDef  $body
                } on error {result opts} {
                    log::error $result
                    upvar #0 ::rosea::Config::errcount errcount
                    incr errcount
                }
            }
            proc association {name source spec target args} {
                if {[llength $args] % 2 != 0} {
                    tailcall DeclError ARG_FORMAT $args
                }
            
                namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName
            
                set associator {}
                set path {}
            
                foreach {option value} $args {
                    switch -exact -- $option {
                        -associator {
                            set associator $value
                        }
                        -path {
                            set path $value
                            if {[llength $path] % 2 != 0} {
                                tailcall DeclError ARG_FORMAT $path
                            }
                        }
                        default {
                            tailcall DeclError UNKNOWN_OPTION association $option
                        }
                    }
                }
            
                set ainfo [relvar restrictone ::rosea::Config::__AssocInfo Spec $spec]
                if {[relation isempty $ainfo]} {
                    tailcall DeclError BAD_RELATIONSHIP_SPEC $spec
                }
                set needsassoc [relation extract $ainfo NeedsAssociator]
                if {$needsassoc && $associator eq {}} {
                    tailcall DeclError NEED_ASSOCIATOR $spec
                }
                if {$source eq $target} {
                    if {![relation extract $ainfo ReflexiveAllowed]} {
                        tailcall DeclError REFLEXIVE_NOT_ALLOWED $spec
                    }
                    if {$needsassoc && $path eq {}} {
                        tailcall DeclError NEED_REFLEXIVE_PATH $name $source $spec $target
                    }
                }
            
                namespace upvar ::rosea::Config::DomainDef DomainName DomainName
            
                relvar insert ::rosea::Config::DomainElement [list\
                    Domain  $DomainName\
                    Element $name\
                ]
            
                set reltuple [list\
                    Domain  $DomainName\
                    Name $name\
                ]
                relvar insert ::rosea::Config::Relationship $reltuple
                relvar insert ::rosea::Config::Association $reltuple
            
                if {$associator eq {}} {
                    relvar insert ::rosea::Config::SimpleAssociation $reltuple
                    relvar insert ::rosea::Config::SimpleReferringClass [list\
                        Domain          $DomainName\
                        Class           $source\
                        Relationship    $name\
                        Role            source\
                        Conditionality  [relation extract $ainfo ReferringCond]\
                        Multiplicity    [relation extract $ainfo ReferringMult]\
                    ]
                    relvar insert ::rosea::Config::ReferringClass [list\
                        Domain          $DomainName\
                        Class           $source\
                        Relationship    $name\
                        Role            source\
                    ]
                    relvar insert ::rosea::Config::ClassRole [list\
                        Domain          $DomainName\
                        Class           $source\
                        Relationship    $name\
                        Role            source\
                    ]
                    relvar insert ::rosea::Config::SimpleReferencedClass [list\
                        Domain          $DomainName\
                        Class           $target\
                        Relationship    $name\
                        Role            target\
                        Conditionality  [relation extract $ainfo ReferencedCond]\
                    ]
                    relvar insert ::rosea::Config::ReferencedClass [list\
                        Domain          $DomainName\
                        Class           $target\
                        Relationship    $name\
                        Role            target\
                    ]
                    relvar insert ::rosea::Config::ClassRole [list\
                        Domain          $DomainName\
                        Class           $target\
                        Relationship    $name\
                        Role            target\
                    ]
                } else {
                    relvar insert ::rosea::Config::ClassAssoc [list\
                        Domain              $DomainName\
                        Relationship        $name\
                        AssocClass          $associator\
                        SourceClass         $source\
                    ]
                    if {[llength $path] == 0} {
                        relvar insert ::rosea::Config::NonReflexiveAssoc [list\
                            Domain              $DomainName\
                            Relationship        $name\
                            AssocClass          $associator\
                            SourceClass         $source\
                            TargetClass         $target\
                        ]
                    } else {
                        relvar insert ::rosea::Config::ReflexiveAssoc [list\
                            Domain              $DomainName\
                            Relationship        $name\
                            AssocClass          $associator\
                            SourceClass         $source\
                        ]
                        foreach {sourceattr targetattr} $path {
                            relvar insert ::rosea::Config::ReflexivePath [list\
                                Domain              $DomainName\
                                Relationship        $name\
                                AssocClass          $associator\
                                SourceClass         $source\
                                SourceAttr          $sourceattr\
                                TargetAttr          $targetattr\
                            ]
                        }
                    }
            
                    relvar insert ::rosea::Config::ClassBasedAssociation $reltuple
                    relvar insert ::rosea::Config::SourceClass [list\
                        Domain          $DomainName\
                        Class           $source\
                        Relationship    $name\
                        Role            source\
                        Conditionality  [relation extract $ainfo ReferringCond]\
                        Multiplicity    [relation extract $ainfo ReferringMult]\
                    ]
                    relvar insert ::rosea::Config::ReferencedClass [list\
                        Domain          $DomainName\
                        Class           $source\
                        Relationship    $name\
                        Role            source\
                    ]
                    relvar insert ::rosea::Config::ClassRole [list\
                        Domain          $DomainName\
                        Class           $source\
                        Relationship    $name\
                        Role            source\
                    ]
                    relvar insert ::rosea::Config::TargetClass [list\
                        Domain          $DomainName\
                        Class           $target\
                        Relationship    $name\
                        Role            target\
                        Conditionality  [relation extract $ainfo ReferencedCond]\
                        Multiplicity    [relation extract $ainfo ReferencedMult]\
                    ]
                    relvar insert ::rosea::Config::ReferencedClass [list\
                        Domain          $DomainName\
                        Class           $target\
                        Relationship    $name\
                        Role            target\
                    ]
                    relvar insert ::rosea::Config::ClassRole [list\
                        Domain          $DomainName\
                        Class           $target\
                        Relationship    $name\
                        Role            target\
                    ]
                    relvar insert ::rosea::Config::AssociatorClass [list\
                        Domain          $DomainName\
                        Class           $associator\
                        Relationship    $name\
                        Role            associator\
                    ]
                    relvar insert ::rosea::Config::ReferringClass [list\
                        Domain          $DomainName\
                        Class           $associator\
                        Relationship    $name\
                        Role            associator\
                    ]
                    relvar insert ::rosea::Config::ClassRole [list\
                        Domain          $DomainName\
                        Class           $associator\
                        Relationship    $name\
                        Role            associator\
                    ]
                }
            }
            proc generalization {name super args} {
                if {[llength $args] < 2} {
                    tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
                }
            
                namespace upvar ::rosea::Config::DomainDef DomainName DomainName
            
                relvar insert ::rosea::Config::DomainElement [list\
                    Domain  $DomainName\
                    Element $name\
                ]
            
                set reltuple [list\
                    Domain  $DomainName\
                    Name $name\
                ]
                relvar insert ::rosea::Config::Relationship $reltuple
                relvar insert ::rosea::Config::Generalization $reltuple
            
                set supertuple [list\
                    Domain          $DomainName\
                    Class           $super\
                    Relationship    $name\
                    Role            target\
                ]
                relvar insert ::rosea::Config::Superclass $supertuple
                relvar insert ::rosea::Config::ReferencedClass $supertuple
                relvar insert ::rosea::Config::ClassRole $supertuple
            
                foreach sub $args {
                    set subtuple [list\
                        Domain          $DomainName\
                        Class           $sub\
                        Relationship    $name\
                        Role            source\
                    ]
                    relvar insert ::rosea::Config::Subclass $subtuple
                    relvar insert ::rosea::Config::ReferringClass $subtuple
                    relvar insert ::rosea::Config::ClassRole $subtuple
                }
            }
            proc operation {name params body} {
                namespace upvar ::rosea::Config::DomainDef DomainName DomainName
            
                relvar insert ::rosea::Config::DomainElement [list\
                    Domain      $DomainName\
                    Element     $name\
                ]
                relvar insert ::rosea::Config::DomainOperation [list\
                    Domain      $DomainName\
                    Name        $name\
                    Parameters  $params\
                    Body        $body\
                ]
            }
        
            namespace eval ClassDef {
                logger::initNamespace [namespace current]
            
                namespace import ::ral::relation
                namespace import ::ral::tuple
                namespace import ::ral::relformat
                namespace import ::ralutil::pipe
                namespace import ::ral::relvar
                namespace import ::rosea::Config::ConfigEvaluate
                namespace import ::rosea::Helpers::DeclError
            
                proc attribute {name type args} {
                    if {$name eq {}} {
                        tailcall DeclError EMPTY_NAME attribute
                    }
                    if {[string range $name 0 1] eq "__"} {
                        tailcall DeclError RESERVED_NAME $name
                    }
                    if {[llength $args] % 2 != 0} {
                        tailcall DeclError ARG_FORMAT $args
                    }
                
                    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName
                
                    relvar insert ::rosea::Config::Attribute [list\
                        Domain  $DomainName\
                        Class   $ClassName\
                        Name    $name\
                        Type    $type\
                    ]
                
                    foreach {option value} $args {
                        switch -exact -- $option {
                            -default {
                                relvar insert ::rosea::Config::DefaultValue [list\
                                    Domain      $DomainName\
                                    Class       $ClassName\
                                    Attribute   $name\
                                    Value       $value\
                                ]
                            }
                            -id {
                                relvar uinsert ::rosea::Config::Identifier [list\
                                    Domain      $DomainName\
                                    Class       $ClassName\
                                    Number      $value\
                                ]
                                relvar insert ::rosea::Config::IdentifyingAttribute [list\
                                    Domain      $DomainName\
                                    Class       $ClassName\
                                    Attribute   $name\
                                    Number      $value\
                                ]
                            }
                            default {
                                tailcall DeclError UNKNOWN_OPTION attribute $option
                            }
                        }
                    }
                }
                proc reference {relname rclass args} {
                    if {[llength $args] % 2 != 0} {
                        tailcall DeclError ARG_FORMAT $args
                    }
                
                    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName
                
                    set refnum 1
                
                    foreach {option value} $args {
                        switch -exact -- $option {
                            -refid {
                                set refnum $value
                            }
                            -link {
                                if {[llength $value] < 1 || [llength $value] > 2} {
                                    tailcall DeclError ARG_FORMAT $value
                                }
                                lassign $value referring referenced
                                if {$referenced eq {}} {
                                    set referenced $referring
                                }
                                relvar insert ::rosea::Config::AttributeReference [list\
                                    Domain              $DomainName\
                                    ReferringClass      $ClassName\
                                    ReferringAttribute  $referring\
                                    ReferringRole       source\
                                    ReferencedClass     $rclass\
                                    ReferencedAttribute $referenced\
                                    ReferencedRole      target\
                                    ReferencedIdNumber  $refnum\
                                    Relationship        $relname
                                ]
                            }
                            default {
                                tailcall DeclError UNKNOWN_OPTION reference $option
                            }
                        }
                    }
                }
                proc classop {name params body} {
                    if {$name eq {}} {
                        tailcall DeclError EMPTY_NAME "class operation"
                    }
                
                    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName
                
                    set sysop [relvar restrictone ::rosea::Config::Operation\
                        Domain $DomainName Class $ClassName Name $name]
                    if {[relation isnotempty $sysop]} {
                        tailcall DeclError DUP_OP_NAME $name
                    }
                
                    set optuple [list Domain $DomainName Class $ClassName Name $name]
                    relvar insert ::rosea::Config::Operation $optuple
                    relvar insert ::rosea::Config::ClassOperation $optuple
                
                    lappend optuple Parameters $params Body $body
                    relvar insert ::rosea::Config::UserClassOperation $optuple
                }
                proc instop {name params body} {
                    if {$name eq {}} {
                        tailcall DeclError EMPTY_NAME "instance operation"
                    }
                
                    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName
                
                    set sysop [relvar restrictone ::rosea::Config::Operation\
                        Domain $DomainName Class $ClassName Name $name]
                    if {[relation isnotempty $sysop]} {
                        tailcall DeclError DUP_OP_NAME $name
                    }
                
                    set optuple [list Domain $DomainName Class $ClassName Name $name]
                    relvar insert ::rosea::Config::Operation $optuple
                    relvar insert ::rosea::Config::InstanceOperation $optuple
                
                    lappend optuple Parameters $params Body $body
                    relvar insert ::rosea::Config::UserInstanceOperation $optuple
                }
                proc statemodel {body} {
                    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                    variable ClassName
                
                    namespace upvar StateModelDef\
                        InitialState InitialState\
                        DefaultTrans DefaultTrans\
                        Terminals Terminals
                
                    set InitialState {}
                    set DefaultTrans {}
                    set Terminals [list]
                
                    try {
                        ConfigEvaluate [namespace current]::StateModelDef  $body
                
                        if {$DefaultTrans eq {}} {
                            set DefaultTrans CH
                        }
                        relvar insert ::rosea::Config::StateModel [list\
                            Domain          $DomainName\
                            Model           $ClassName\
                            InitialState    $InitialState\
                            DefaultTrans    $DefaultTrans\
                        ]
                        relvar insert ::rosea::Config::InstanceStateModel [list\
                            Domain          $DomainName\
                            Class           $ClassName\
                        ]
                
                        foreach terminal $Terminals {
                            relvar updateone ::rosea::Config::State stup [list\
                                    Domain $DomainName Model $ClassName Name $terminal] {
                                tuple update $stup IsFinal true
                            }
                        }
                
                    } on error {result opts} {
                        log::error $result
                        upvar #0 ::rosea::Config::errcount errcount
                        incr errcount
                    }
                }
                proc polymorphic {args} {
                    namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                    namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName
                
                    foreach polyevent $args {
                        set eventtuple [list\
                            Domain $DomainName\
                            Model $ClassName\
                            Event $polyevent\
                        ]
                        relvar insert ::rosea::Config::PolymorphicEvent $eventtuple
                        relvar insert ::rosea::Config::DeferredEvent $eventtuple
                        relvar insert ::rosea::Config::Event $eventtuple
                    }
                    return
                }
            
                namespace eval StateModelDef {
                    logger::initNamespace [namespace current]
                
                    namespace import ::ral::relation
                    namespace import ::ral::tuple
                    namespace import ::ral::relformat
                    namespace import ::ralutil::pipe
                    namespace import ::ral::relvar
                    namespace import ::rosea::Config::ConfigEvaluate
                    namespace import ::rosea::Helpers::DeclError
                
                    proc state {name params body} {
                        if {$name eq {}} {
                            tailcall DeclError EMPTY_NAME state
                        }
                    
                        namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                        namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName
                    
                        variable InitialState
                    
                        if {$InitialState eq {}} {
                            set InitialState $name
                        }
                    
                        relvar insert ::rosea::Config::State [list\
                            Domain          $DomainName\
                            Model           $ClassName\
                            Name            $name\
                            Parameters      $params\
                            Action          $body\
                            IsFinal         false\
                        ]
                        relvar insert ::rosea::Config::StatePlace [list\
                            Domain          $DomainName\
                            Model           $ClassName\
                            Name            $name\
                        ]
                        return
                    }
                    proc transition {source - event -> target} {
                        if {$event eq {}} {
                            tailcall DeclError EMPTY_NAME event
                        }
                        namespace upvar ::rosea::Config::DomainDef DomainName DomainName
                        namespace upvar ::rosea::Config::DomainDef::ClassDef ClassName ClassName
                    
                        if {$source eq "@"} {
                            set cstuple [list\
                                Domain          $DomainName\
                                Model           $ClassName\
                                Name            @\
                            ]
                            relvar uinsert ::rosea::Config::CreationState $cstuple
                            relvar uinsert ::rosea::Config::StatePlace $cstuple
                        }
                    
                        set eventtuple [list\
                            Domain  $DomainName\
                            Model   $ClassName\
                            Event   $event\
                        ]
                        relvar uinsert ::rosea::Config::Event $eventtuple
                        relvar uinsert ::rosea::Config::EffectiveEvent $eventtuple
                        relvar uinsert ::rosea::Config::LocalEvent $eventtuple
                    
                        set tranrule [relvar restrictone ::rosea::Config::TransitionRule\
                            Name $target]
                        set transtuple [list\
                            Domain  $DomainName\
                            Model   $ClassName\
                            State   $source\
                            Event   $event\
                        ]
                        relvar insert ::rosea::Config::TransitionPlace $transtuple
                    
                        if {[relation isnotempty $tranrule]} {
                            lappend transtuple TransRule $target
                            set tpsubtype NonStateTransition
                        } else {
                            lappend transtuple NewState $target
                            set tpsubtype StateTransition
                        }
                        relvar insert ::rosea::Config::$tpsubtype $transtuple
                        return
                    }
                    proc initialstate {name} {
                        variable InitialState $name
                        return
                    }
                    proc defaulttrans {name} {
                        variable DefaultTrans $name
                        return
                    }
                    proc terminal {args} {
                        variable Terminals
                        ::struct::set add Terminals $args
                        return
                    }
                }
            }
        }
    }
    namespace eval Populate {
        logger::initNamespace [namespace current]
    
        namespace import ::ral::relation
        namespace import ::ral::tuple
        namespace import ::ral::relformat
        namespace import ::ralutil::pipe
        namespace import ::ral::relvar
        namespace import ::rosea::Config::ConfigEvaluate
        namespace import ::rosea::Helpers::DeclError
        proc domain {name body} {
            set domain [relvar restrictone ::rosea::Config::Domain Name $name]
            if {[relation isempty $domain]} {
                tailcall DeclError UNKNOWN_DOMAIN $domain
            }
        
            namespace upvar DomainPop DomainName DomainName DomainLoc DomainLoc
            relation assign $domain {Name DomainName} {Location DomainLoc}
        
            try {
                ConfigEvaluate [namespace current]::DomainPop $body
            } on error {result opts} {
                log::error $result
                upvar #0 ::rosea::Config::errcount errcount
                incr errcount
            }
        }
        namespace eval DomainPop {
            logger::initNamespace [namespace current]
        
            namespace import ::ral::relation
            namespace import ::ral::tuple
            namespace import ::ral::relformat
            namespace import ::ralutil::pipe
            namespace import ::ral::relvar
            namespace path ::rosea::Helpers
            proc class {class heading args} {
                # Determine if we have one big list or a bunch of values.
                set popvalues [expr {[llength $args] == 1 ? [lindex $args 0] : $args}]
                set headlen [llength $heading]
                if {[llength $popvalues] % $headlen != 0} {
                    tailcall DeclError ARG_MISMATCH $headlen [llength $popvalues]
                }
            
                # Iterate over the attribute values taking them in chunks that are the same
                # size as the heading.
                set body [list]
                for {set vindex 0} {$vindex < [llength $popvalues]} {incr vindex $headlen} {
                    set values [lrange $popvalues $vindex [expr {$vindex + $headlen - 1}]]
                    # Create a tuple as a list of attribute name / value pairs.
                    set tuple [list]
                    foreach attr $heading value $values {
                        # Check if we are skipping a value to use a default.  We must also
                        # allow some way to specify the value as "-".
                        if {$value eq "-"} {
                            continue
                        } elseif {$value eq "\\-"} {
                            set value -
                        }
                        lappend tuple $attr $value
                    }
                    # Accumulate the tuples as a list to form the body that will be
                    # inserted into the relvar.
                    lappend body $tuple
                }
            
                # Insert the body into the relvar.
                namespace upvar [namespace current]\
                    DomainName DomainName\
                    DomainLoc DomainLoc
                set domns ${DomainLoc}::${DomainName}
                set relvar ${domns}::$class
                set insts [relvar insert $relvar {*}$body]
                #puts [relformat $insts $relvar]
            
                # Now we have to deal with any state model that might be present.  We have
                # to set up the initial state properly if such a thing exists for this
                # class.
                set initstate [relvar restrictone ${domns}::__Arch::InitialState\
                    Class $class]
                if {[relation isnotempty $initstate]} {
                    relation assign $initstate {State state}
                    set idattrs [lindex [relvar identifiers $relvar] 0]
                    relation foreach inst $insts {
                        CreateInstanceState $domns $class $state\
                            [relation project $inst {*}$idattrs]
                    }
                }
            
                return
            }
        }
    }
    namespace eval Trace {
        logger::initNamespace [namespace current]
    
        namespace import ::ral::relation
        namespace import ::ral::tuple
        namespace import ::ral::relformat
        namespace import ::ralutil::pipe
        namespace import ::ral::relvar
        namespace path [list\
            [namespace parent]::Helpers\
            [namespace parent]::InstCmds\
        ]
        relvar create Trace {
            Trace_Id    int
            Timestamp   bignum
            Source      string
            Event       string
            Target      string
            Class       string
        } Trace_Id
        
        relvar create Creation {
            Trace_Id    int
        } Trace_Id
        
        relvar create Polymorphic {
            Trace_Id    int
            SuperClass  string
            Linkage     string
        } Trace_Id
        
        relvar create Transition {
            Trace_Id    int
            CurrState   string
            NewState    string
            Params      list
        } Trace_Id
        
        relvar partition R1 Trace Trace_Id\
            Creation Trace_Id\
            Polymorphic Trace_Id\
            Transition Trace_Id
        variable traceState off
        variable traceNumber 0
        variable traceLogState off
        variable traceLogLevel info
        variable traceLogCmd [::logger::init rosea]
        proc TraceCreation {source event target} {
            variable traceState
            if {$traceState} {
                relvar eval {
                    set trace [NewTrace $source $event $target]
                    relvar insert Creation [list\
                        Trace_Id    [relation extract $trace Trace_Id]\
                    ]
                }
                LogTrace $trace
            }
        }
        proc TracePolymorphic {source event target super link} {
            variable traceState
            if {$traceState} {
                relvar eval {
                    set trace [NewTrace $source $event $target]
                    relvar insert Polymorphic [list\
                        Trace_Id    [relation extract $trace Trace_Id]\
                        SuperClass  $super\
                        Linkage     $link\
                    ]
                }
                LogTrace $trace
            }
        }
        proc TraceTransition {source event target curr new params} {
            variable traceState
            if {$traceState} {
                relvar eval {
                    set trace [NewTrace $source $event $target]
                    relvar insert Transition [list\
                        Trace_Id    [relation extract $trace Trace_Id]\
                        CurrState   $curr\
                        NewState    $new\
                        Params      $params\
                    ]
                }
                LogTrace $trace
            }
        }
        proc NewTrace {src event target} {
            variable traceNumber
            return [relvar insert Trace [list\
                Trace_Id    [incr traceNumber]\
                Timestamp   [clock microseconds]\
                Source      $src\
                Event       $event\
                Target      $target\
                Class       [lindex $target 0]\
            ]]
        }
        proc LogTrace {trace} {
            variable traceLogState
            if {$traceLogState} {
                set rec [FormatTraceRec [lindex [TracesToRecords $trace] 0]] ; # <1>
        
                variable traceLogCmd
                variable traceLogLevel
                ${traceLogCmd}::${traceLogLevel} $rec
            }
        }
        proc TracesToRecords {traces} {
            foreach rvname {Creation Polymorphic Transition} { # <1>
                set traces [::ralutil::rvajoin $traces [relvar set $rvname] $rvname]
            }
        
            set result [list]
            relation foreach trace $traces -ascending Trace_Id { # <2>
                relation assign $trace
                set labeled [dict create\
                    id      $Trace_Id\
                    time    $Timestamp\
                    source  $Source\
                    event   $Event\
                    target  $Target\
                    class   $Class\
                ] ; # <3>
                if {[relation isnotempty $Transition]} { # <4>
                    relation assign $Transition
                    dict set labeled type transition
                    dict set labeled current $CurrState
                    dict set labeled new $NewState
                    dict set labeled params $Params
                } elseif {[relation isnotempty $Polymorphic]} {
                    relation assign $Polymorphic
                    dict set labeled type polymorphic
                    dict set labeled super $SuperClass
                    dict set labeled link $Linkage
                } elseif {[relation isnotempty $Creation]} {
                    dict set labeled type creation
                }
        
                lappend result $labeled
            }
            return $result
        }
        proc FormatTraceRec {rec} {
            dict with rec {
                switch -exact -- $type {
                    transition {
                        append result\
                            "Transition: "\
                            "[FormatInstRef $source] - $event"\
                            [expr {[llength $params] != 0 ?\
                                "\([join $params {, }]\)" : {}}]\
                            " -> [FormatInstRef $target] ==> "\
                            "$current -> $new"
                    }
                    polymorphic {
                        append result\
                            "Polymorphic : "\
                            "[FormatInstRef $source] - $event -> $super ==> "\
                            "$link -> [FormatInstRef $target]"
                    }
                    creation {
                        append result\
                            "Creation: "\
                            "[FormatInstRef $source] - $event -> $class ==>\
                                [FormatInstRef $target]"
                    }
                    default {
                        DeclError BAD_TRACETYPE $type
                    }
                }
            }
            return $result
        }
        proc FormatInstRef {instref} {
            lassign $instref relvar inst
            if {$relvar eq {}} {
                return {{}}
            } else {
                return "$relvar\{[tuple get [relation tuple $inst]]\}"
            }
        }
        proc FormatTimestamp {time} {
            set sec [clock format [expr {$time / 1000000}] -format %T] ; # <1>
            set time [expr {$time % 1000000}]
            set msec [expr {$time / 1000}]
            set usec [expr {$time % 1000}]
        
            return [format %s.%03ld.%03ld $sec $msec $usec]
        }
        proc FormatTimeAsSec {time} {
            set sec [expr {$time / 1000000}]
            set time [expr {$time % 1000000}]
            set msec [expr {$time / 1000}]
            set usec [expr {$time % 1000}]
        
            return [format %3ld.%03ld.%03ld $sec $msec $usec]
        }
        proc DiagTraces {traces args} {
            set result {}
            append result "seqdiag \{\n"
            append result "    activation = none;\n"
            foreach {option value} $args {
                append result "    $option = $value;\n"
            }
        
            foreach rvname {Creation Polymorphic Transition} {
                set traces [::ralutil::rvajoin $traces [relvar set $rvname] $rvname]
            }
        
            relation foreach trace $traces -ascending Trace_Id {
                relation assign $trace
                if {[isEmptyRef $Source]} {
                    set Source EXTERNAL
                } else {
                    set Source [namespace tail [lindex $Source 0]]
                }
                set Target [namespace tail [lindex $Target 0]]
                if {[relation isnotempty $Transition]} {
                    relation assign $Transition Params
                    set evtlabel $Event[expr {[llength $Params] != 0 ?\
                        "\([join $Params {, }]\)" : {}}]
                } elseif {[relation isnotempty $Polymorphic]} {
                    relation assign $Transition Linkage
                    set evtlabel "$Event <<Polymorphic $Linkage>>"
                } elseif {[relation isnotempty $Creation]} {
                    set evtlabel "$Event <<Creation>>"
                }
                append result "    $Source ->> $Target \[label=\"$evtlabel\"\];\n"
            }
        
            append result "\}\n"
        
            return $result
        }
    }

    namespace path ::rosea::Helpers
    namespace import ::rosea::Config::ConfigEvaluate
}

package provide rosea $::rosea::version
