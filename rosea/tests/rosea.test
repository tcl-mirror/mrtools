# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014-2015 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger
package require uuid

package require ral
package require ralutil
package require struct::set
package require lambda

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

logger::setlevel $options(level)

source ../src/rosea.tcl
chan puts "testing rosea version: [package require rosea]"

package require tcltest
eval tcltest::configure $argv

namespace eval ::rosea::test {
    namespace import ::tcltest::*
    ::logger::initNamespace [namespace current]

    namespace import\
        ::ral::relation\
        ::ral::tuple\
        ::ral::relformat\
        ::ralutil::pipe
    namespace import ::ral::relvar

    proc refMatch {expected actual} {
        lassign $expected erelvar einst
        lassign $actual arelvar ainst
        return [expr {$erelvar eq $arelvar && [ral relation is $einst == $ainst]}]
    }
    customMatch ref [namespace current]::refMatch
    
    proc relationMatch {expected actual} {
        return [::ral::relation is $expected == $actual]
    }
    customMatch relation [namespace current]::relationMatch
    proc syncToTest {{value {}}} {
        set [namespace current]::testDone $value
    }
    
    proc waitForSync {{timeout 1000}} {
        set varname [namespace current]::testDone
        set tid [::after $timeout set $varname TIMEOUT] ; # <1>
        vwait $varname
        after cancel $tid
        set $varname
    }
    proc waitForBGError {{timeout 1000}} {
        set bg [interp bgerror {}] ; # <1>
        interp bgerror {} [lambda@ [namespace current] {result opts} {
            syncToTest [dict get $opts -errorcode]
        }]
    
        set err [waitForSync $timeout]
        interp bgerror {} $bg
        return $err
    }
    proc setupDomain {name} {
        set domns [namespace current]::$name
        namespace eval ${domns} {
            ral relvar create __Arch_RefLink {
                Relationship    string
                ReferringClass  string
                ReferencedClass string
                ReferringAttrs  {Relation
                        {ReferringAttribute string ReferencedAttribute string}}
            } Relationship
            ral relvar create __Arch_AssocRef {
                Relationship    string
                AssocClass      string
                References      {Relation\
                    {Participant string Role string ReferringAttrs {Relation\
                        {ReferringAttribute string ReferencedAttribute string}}}}
            } Relationship
            ral relvar create __Arch_SuperLink {
                Relationship    string
                SuperClass      string
            } Relationship
            
            ral relvar create __Arch_SubLink {
                Relationship    string
                SubClass        string
                ReferringAttrs  {Relation\
                    {ReferringAttribute string ReferencedAttribute string}}
            } {Relationship SubClass}
            
            ral relvar association __Arch_R5\
                __Arch_SubLink Relationship +\
                __Arch_SuperLink Relationship 1
            ral relvar create __Arch_Link {
                Name            string
                SrcClass        string
            } {Name SrcClass}
            ral relvar create __Arch_AssociationLink {
                Name            string
                SrcClass        string
                DstClass        string
                Attrs           list
                PrevSrcClass    string
            } {Name SrcClass}
            ral relvar association __Arch_R4\
                __Arch_AssociationLink {Name PrevSrcClass} ?\
                __Arch_AssociationLink {Name SrcClass} ?
            ral relvar create __Arch_PartitionLink {
                Name            string
                SrcClass        string
            } {Name SrcClass}
            ral relvar partition __Arch_R3 __Arch_Link {Name SrcClass}\
                __Arch_AssociationLink {Name SrcClass}\
                __Arch_PartitionLink {Name SrcClass}
            ral relvar create __Arch_PartitionDst {
                Name            string
                SrcClass        string
                DstClass        string
                Attrs           list
            } {Name SrcClass DstClass}
            ral relvar association __Arch_R2\
                __Arch_PartitionDst {Name SrcClass} +\
                __Arch_PartitionLink {Name SrcClass} 1
            ral relvar create __Arch_State {
                Class string
                State string
            } {Class State}
            ral relvar create __Arch_Event {
                Class string
                Event string
            } {Class Event}
            ral relvar create __Arch_Transition {
                Class string
                State string
                Event string
                NewState string
            } {Class State Event}
            ral relvar correlation __Arch_R1 __Arch_Transition\
                {Class State} + __Arch_State {Class State}\
                {Class Event} + __Arch_Event {Class Event}
            ral relvar create __Arch_InitialState {
                Class string
                State string
            } Class
            ral relvar association __Arch_R6\
                __Arch_InitialState {Class State} ?\
                __Arch_State {Class State} 1
            ral relvar create __Arch_TerminalState {
                Class string
                State string
            } {Class State}
            ral relvar association __Arch_R7\
                __Arch_TerminalState {Class State} *\
                __Arch_State {Class State} 1
            ral relvar create __Arch_PolymorphicEvent {
                Class           string
                Event           string
            } {Class Event}
        }
    }
    
    proc cleanupDomain {name} {
        set domns [namespace current]::$name
        relvar constraint delete {*}[relvar constrain names ${domns}::*]
        relvar unset {*}[relvar names ${domns}::*]
        namespace delete $domns
    }
    
    proc addClass {domain class heading id} {
        set domns [namespace current]::$domain
        set idheading [list]
        foreach attr $id {
            lappend idheading $attr [dict get $heading $attr]
        }
        relvar create ${domns}::${class}__STATEINST\
            [concat $idheading [list __State string]]\
            $id
        relvar create ${domns}::$class $heading $id
        namespace eval ${domns}::${class}::__Activity {}
    }
    
    proc addState {domain args} {
        relvar insert [namespace current]::${domain}::__Arch_State $args
    }
    
    proc addEvent {domain args} {
        relvar insert [namespace current]::${domain}::__Arch_Event $args
    }
    
    proc addTransition {domain args} {
        relvar insert [namespace current]::${domain}::__Arch_Transition $args
    }
    
    proc addInitialState {domain args} {
        relvar insert [namespace current]::${domain}::__Arch_InitialState $args
    }
    
    proc addAssocLink {domain linkattrs assocattrs} {
        relvar eval {
            relvar insert [namespace current]::${domain}::__Arch_Link $linkattrs
            relvar insert [namespace current]::${domain}::__Arch_AssociationLink\
                    $assocattrs
        }
    }
    
    proc addParitionLink {domain linkattrs} {
        relvar insert [namespace current]::${domain}::__Arch_Link $linkattrs
        relvar insert [namespace current]::${domain}::__Arch_PartitionLink\
                $linkattrs
    }
    
    proc addPartitionDst {domain dstattrs} {
        relvar insert [namespace current]::${domain}::__Arch_PartitionDst\
            $dstattrs
    }
    proc addPolymorphic {domain args} {
        relvar insert [namespace current]::${domain}::__Arch_PolymorphicEvent\
                $args
    }
    
    proc polysignal {srcref dstref event paramlist} {
        puts -nonewline [info level 0]
    }
    proc cleanupConfigData {} {
        set preserved {
            ::rosea::Config::TransitionRule
            ::rosea::Config::SuppliedOperation
            ::rosea::Config::SuppliedInstanceOperation
            ::rosea::Config::SuppliedClassOperation
            ::rosea::Config::Config_AssocSpec
            ::rosea::Config::Config_DataError
        } ; # <1>
        relvar eval {
            foreach rname [relvar names ::rosea::Config::*] {
                if {$rname ni $preserved} {
                    relvar set $rname [relation emptyof [relvar set $rname]]
                }
            }
        }
    }
    proc removeDomain {domns} {
        relvar constraint delete {*}[relvar constraint names ${domns}::*]
        relvar unset {*}[relvar names ${domns}::*]
        namespace delete $domns
        set ::rosea::Dispatch::event_queue [list]
    }
    proc testConditions {args} {
        set result 1
        foreach exp $args {
            set passed [uplevel 1 [list expr $exp]]
            if {!$passed} {
                log::error "\"$exp\" failed"
                set result 0
            }
        }
        return $result
    }
    proc turnOnTraceLog {} {
        variable prevloglevel
    
        ::rosea trace control clear
        ::rosea trace control on
        set logcmd [::logger::servicecmd rosea]
        set prevloglevel [${logcmd}::currentloglevel]
        ${logcmd}::setlevel [::rosea trace control loglevel]
        ::rosea trace control logon
    }
    
    proc turnOffTraceLog {} {
        variable prevloglevel
    
        set logcmd [::logger::servicecmd rosea]
        ${logcmd}::setlevel $prevloglevel
        ::rosea trace control logoff
        ::rosea trace control off
        ::rosea trace control clear
    }
    test ToRef-1.0 {
        Compute a reference to a relvar tuple
    } -setup {
        relvar create A {
            Attr1   int
            Attr2   string
        } Attr1
    } -cleanup {
        relvar unset A
    } -body {
        set value [relation create {Attr1 int Attr2 string} {
            Attr1 20 Attr2 foo
        } {
            Attr1 40 Attr2 bar
        }]
        ::rosea::Helpers::ToRef [namespace current]::A $value
    } -result {::rosea::test::A {{Attr1 int} {{Attr1 20} {Attr1 40}}}} -match ref
    test deRef-1.0 {
        Dereference to get a relation value
    } -setup {
        relvar create A {
            Attr1   int
            Attr2   string
        } Attr1
        relvar insert A {
            Attr1 20 Attr2 foo
        } {
            Attr1 40 Attr2 bar
        }
    } -cleanup {
        relvar unset A
    } -body {
        set ref [list [namespace current]::A {{Attr1 int} {{Attr1 40}}}]
        rosea::InstCmds::deRef $ref
    } -result {{Attr1 int Attr2 string} {{Attr1 40 Attr2 bar}}} -match relation
    test deRef-1.1 {
        Dereference to get a projection of the instance
    } -setup {
        relvar create A {
            Attr1   int
            Attr2   string
            Attr3   string
        } Attr1
        relvar insert A {
            Attr1 20 Attr2 foo Attr3 buzz
        } {
            Attr1 40 Attr2 bar Attr3 zub
        }
    } -cleanup {
        relvar unset A
    } -body {
        set ref [list [namespace current]::A {{Attr1 int} {{Attr1 40}}}]
        rosea::InstCmds::deRef $ref Attr3
    } -result {{Attr1 int Attr3 string} {{Attr1 40 Attr3 zub}}} -match relation
    test refUnion-1.0 {
        Compute the union of two instance references
    } -setup {
        relvar create A {
            A_ID   int
            A_Attr   string
        } A_ID
        set A_value [relation create {A_ID int} {A_ID 20}]
        set aref [::rosea::Helpers::ToRef [namespace current]::A $A_value]
        set B_value [relation create {A_ID int} {A_ID 30}]
        set bref [::rosea::Helpers::ToRef [namespace current]::A $B_value]
    } -cleanup {
        relvar unset A
    } -body {
        ::rosea::InstCmds::refUnion $aref $bref
    } -result {::rosea::test::A {{A_ID int} {{A_ID 20} {A_ID 30}}}} -match ref
    test refIntersect-1.0 {
        Compute the intersection of two instance references
    } -setup {
        relvar create A {
            A_ID   int
            A_Attr   string
        } A_ID
        set A_value [relation create {A_ID int} {A_ID 20} {A_ID 30}]
        set aref [::rosea::Helpers::ToRef [namespace current]::A $A_value]
        set B_value [relation create {A_ID int} {A_ID 30} {A_ID 40}]
        set bref [::rosea::Helpers::ToRef [namespace current]::A $B_value]
    } -cleanup {
        relvar unset A
    } -body {
        ::rosea::InstCmds::refIntersect $aref $bref
    } -result {::rosea::test::A {{A_ID int} {{A_ID 30}}}} -match ref
    test refMinus-1.0 {
        Compute the difference of two instance references
    } -setup {
        relvar create A {
            A_ID   int
            A_Attr   string
        } A_ID
        set A_value [relation create {A_ID int} {A_ID 20} {A_ID 30}]
        set aref [::rosea::Helpers::ToRef [namespace current]::A $A_value]
        set B_value [relation create {A_ID int} {A_ID 30} {A_ID 40}]
        set bref [::rosea::Helpers::ToRef [namespace current]::A $B_value]
    } -cleanup {
        relvar unset A
    } -body {
        ::rosea::InstCmds::refMinus $aref $bref
    } -result {::rosea::test::A {{A_ID int} {{A_ID 20}}}} -match ref
    test findById-1.0 {
        Find tuple by value of the identifier
    } -setup {
        relvar create A {
            Attr1   int
            Attr2   string
        } Attr1
        relvar insert A {
            Attr1 20 Attr2 foo
        } {
            Attr1 40 Attr2 bar
        }
    } -cleanup {
        relvar unset A
    } -body {
        rosea::ClassCmds::findById [namespace current]::A Attr1 20
    } -result {::rosea::test::A {{Attr1 int} {{Attr1 20}}}} -match ref
    test findWhere-1.0 {
        Find tuples based on an expression
    } -setup {
        relvar create A {
            Attr1   int
            Attr2   string
        } Attr1
        relvar insert A {
            Attr1 20 Attr2 foo
        } {
            Attr1 40 Attr2 bar
        } {
            Attr1 60 Attr2 baz
        }
    } -cleanup {
        relvar unset A
    } -body {
        # Make sure the expression is evaluated in the proper context
        # and can access local variables
        set lower 20
        set upper 60
        rosea::ClassCmds::findWhere [namespace current]::A {
            $Attr1 > $lower && $Attr1 < $upper
        }
    } -result {::rosea::test::A {{Attr1 int} {{Attr1 40}}}} -match ref
    test create-1.0 {
        Create an instance -- no state model
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
    } -cleanup {
        cleanupDomain foo
    } -body {
        rosea::ClassCmds::create [namespace current]::foo::c1 A1 20 A2 bar
    } -result {::rosea::test::foo::c1 {{A1 int} {{A1 20}}}} -match ref
    test createin-1.0 {
        Create an instance in a given state
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        relvar eval {
            addState foo Class c1 State Idle
            addEvent foo Class c1 Event e1
            addTransition foo Class c1 State Idle Event e1 NewState Idle
            addInitialState foo Class c1 State Idle
        }
    } -cleanup {
        cleanupDomain foo
    } -body {
        set ref [::rosea::ClassCmds::createin [namespace current]::foo::c1\
            Idle A1 40 A2 bar]
        set statetest [pipe {
            relvar restrictone ::rosea::test::foo::c1__STATEINST A1 40 |
            relation extract ~ __State
        }]
        expr {$statetest eq "Idle" &&\
            [refMatch {::rosea::test::foo::c1 {{A1 int} {{A1 40}}}} $ref]}
    } -result {1}
    test createasync-1.0 {
        Signal a creation event
    } -setup {
        rosea configure {
            domain foo {
                class A {
                    attribute A_Id string -id 1
                    attribute A_Attr string
    
                    statemodel {
                        transition @ - New -> Initialize
    
                        state Initialize {bid battr} {
                            B create B_Id $bid B_Attr $battr\
                                A_Id [readAttribute $self A_Id]
                            ::rosea::test::syncToTest $bid
                        }
                    }
                }
                class B {
                    attribute B_Id string -id 1
                    attribute B_Attr string
                    attribute A_Id string
                    reference R1 A -link A_Id
                }
    
                association R1 B 1--1 A
    
                operation newA {} {
                    A createasync New {5 foo} A_Id 17 A_Attr bar
                }
            }
        }
    
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        ::foo newA
        waitForSync
    } -result {5}
    test createasync-1.1 {
        Signal a creation event to class without pseudo initial state
    } -setup {
        rosea configure {
            domain foo {
                class A {
                    attribute A_Id string -id 1
                    attribute A_Attr string
    
                    statemodel {
                        transition Initialize - New -> Initialize
    
                        state Initialize {bid battr} {
                            B create B_Id $bid B_Attr $battr\
                                A_Id [readAttribute $self A_Id]
                        }
                    }
                }
                class B {
                    attribute B_Id string -id 1
                    attribute B_Attr string
                    attribute A_Id string
                    reference R1 A -link A_Id
                }
    
                association R1 B 1--1 A
    
                operation newA {} {
                    A createasync New {5 foo} A_Id 17 A_Attr bar
                }
            }
        }
    
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        ::foo newA
    } -result {class, "A", has no defined creation events} -returnCodes error
    test createasync-1.2 {
        Signal a creation event, instance creation fails.
    } -setup {
        rosea configure {
            domain foo {
                class A {
                    attribute A_Id string -id 1
                    attribute A_Attr string
    
                    statemodel {
                        transition @ - New -> Initialize
    
                        state Initialize {bid battr} {
                            B create B_Id $bid B_Attr $battr\
                                A_Id [readAttribute $self A_Id]
                            ::rosea::test::syncToTest $bid
                        }
                    }
                }
                class B {
                    attribute B_Id string -id 1
                    attribute B_Attr string
                    attribute A_Id string
                    reference R1 A -link A_Id
                }
    
                association R1 B 1--1 A
    
                operation newA {} {
                    A createasync New {5 foo} A_Id 17
                }
            }
        }
    
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        ::foo newA
        lindex [waitForBGError] 1
    } -result {ASYNC_CREATION_FAILED}
    test update-1.0 {
        Update a set of attribute values
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 string Temp int Volume double} A1
        rosea::ClassCmds::create [namespace current]::foo::c1\
            A1 tank1 Temp 100 Volume 3.3
        rosea::ClassCmds::create [namespace current]::foo::c1\
            A1 tank2 Temp 200 Volume 6.3
        rosea::ClassCmds::create [namespace current]::foo::c1\
            A1 tank3 Temp 300 Volume 10.3
    } -cleanup {
        cleanupDomain foo
    } -body {
        set ref [rosea::ClassCmds::findAll [namespace current]::foo::c1]
        # This adds 10 to the Temp and multiplies the Volume by 2 for
        # all the instances. We do it by extending relation value with
        # new attributes and then eliminating the old attributes and renaming
        # the new attributes to have the old attribute names.
        set newvalues [relation update [rosea::InstCmds::deRef $ref Temp Volume]\
                newtuple {1} {
            tuple update $newtuple\
                Temp [expr {[tuple extract $newtuple Temp] + 10}]\
                Volume [expr {[tuple extract $newtuple Volume] * 2.0}]
        }]
        log::debug [relformat $newvalues newvalues]
        set ref [rosea::ClassCmds::update [namespace current]::foo::c1 $newvalues]
        # Extract one of the instances and make sure the attribute values
        # were properly updated.
        pipe {
            rosea::InstCmds::deRef $ref |
            relation restrictwith ~ {$Temp < 200} |
            relation extract ~ Temp Volume
        }
    } -result {110 6.6}
    test linkAssoc-1.0 {
        Create associative links.
    } -setup {
        rosea configure {
            domain assoc {
                class Dog {
                    attribute Name string -id 1
                    attribute Breed string
                }
                class Owner {
                    attribute Name string -id 1
                    attribute Age int
                }
                class Ownership {
                    attribute DogName string -id 1
                    attribute OwnerName string -id 1
                    reference R1 Owner -link {OwnerName Name}
                    reference R1 Dog -link {DogName Name}
    
                    statemodel {
                        state Owning {} {
                            puts "Own dog [readAttribute $self DogName]"
                        }
                        transition Owning - Sold -> Disposed
    
                        state Disposed {} {
                            puts "No longer own dog [readAttribute $self DogName]"
                        }
                    }
                }
    
                association R1 Owner 0..*--0..* Dog -associator Ownership
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::assoc
    } -body {
        set d1 [assoc::Dog create Name Fluffy Breed Poodle]
        set d2 [assoc::Dog create Name Tiger Breed Mut]
        set dogs [rosea::InstCmds::refUnion $d1 $d2]
        set owners [assoc::Owner create Name Fred Age 32]
        set a [assoc::R1 link $dogs $owners]
        testConditions\
            {[rosea::InstCmds::refMultiplicity $a] == 2}\
            {[relation cardinality [relvar set ::assoc::Ownership__STATEINST]]\
                == 2}
    } -result {1}
    test unlinkAssoc-1.0 {
        Destroy associative links.
    } -setup {
        rosea configure {
            domain assoc {
                class Dog {
                    attribute Name string -id 1
                    attribute Breed string
                }
                class Owner {
                    attribute Name string -id 1
                    attribute Age int
                }
                class Ownership {
                    attribute DogName string -id 1
                    attribute OwnerName string -id 1
                    reference R1 Owner -link {OwnerName Name}
                    reference R1 Dog -link {DogName Name}
    
                    statemodel {
                        state Owning {} {
                            puts "Own dog [readAttribute $self DogName]"
                        }
                        transition Owning - Sold -> Disposed
    
                        state Disposed {} {
                            puts "No longer own dog [readAttribute $self DogName]"
                        }
                    }
                }
    
                association R1 Owner 0..*--0..* Dog -associator Ownership
            }
        }
        rosea generate
    
        set owner [assoc::Owner create Name Fred Age 32]
        assoc::R1 link $owner [assoc::Dog create Name Fluffy Breed Poodle]
        assoc::R1 link $owner [assoc::Dog create Name Tiger Breed Mut]
    } -cleanup {
        cleanupConfigData
        removeDomain ::assoc
    } -body {
        set dogs [assoc::Dog findAll]
        assoc::R1 unlink $dogs
        testConditions\
            {[relation cardinality [relvar set ::assoc::Ownership]] == 0}\
            {[relation cardinality [relvar set ::assoc::Ownership__STATEINST]]\
                == 0}
    } -result {1}
    test findRelated-1.0 {
        Navigate a relationship -- simple association
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        addClass foo c2 {B1 int B2 string} B1
        addAssocLink foo {Name R1 SrcClass c1}\
            {Name R1 SrcClass c1 DstClass c2 Attrs {A1 B1} PrevSrcClass {}}
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
        rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findRelated $ref R1
    } -result {::rosea::test::foo::c2 {{B1 int} {{B1 5}}}} -match ref
    test findRelated-1.1 {
        Navigate a relationship -- multiple simple association
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        addClass foo c2 {B1 int B2 string} B1
        addClass foo c3 {C1 int C2 string} C1
    
        addAssocLink foo {Name R1 SrcClass c1}\
            {Name R1 SrcClass c1 DstClass c2 Attrs {A1 B1} PrevSrcClass {}}
        addAssocLink foo {Name R2 SrcClass c2}\
            {Name R2 SrcClass c2 DstClass c3 Attrs {B1 C1} PrevSrcClass {}}
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
        rosea::ClassCmds::create [namespace current]::foo::c2 B1 5 B2 bar
        rosea::ClassCmds::create [namespace current]::foo::c3 C1 5 C2 bar
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findRelated $ref R1 R2
    } -result {::rosea::test::foo::c3 {{C1 int} {{C1 5}}}} -match ref
    test findRelated-1.2 {
        Navigate a relationship -- unknown link
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findRelated $ref R1
    } -result {unknown relationship, "R1", for class, "c1"}\
    -returnCodes error
    test findRelated-1.3 {
        Navigate a relationship -- bad path
    } -setup {
        setupDomain foo
        addClass foo X {A1 int A2 string} A1
        addClass foo Y {B1 int B2 string} B1
        addClass foo A {A1 int B1 int} {A1 B1}
        addClass foo c1 {A1 int A2 string} A1
    
        # Forward direction is from X -> Y via A
        addAssocLink foo {Name R1 SrcClass X}\
            {Name R1 SrcClass X DstClass A Attrs {A1 A1} PrevSrcClass {}}
        addAssocLink foo {Name R1 SrcClass A}\
            {Name R1 SrcClass A DstClass Y Attrs {B1 B1} PrevSrcClass X}
        addAssocLink foo {Name ~R1 SrcClass Y}\
            {Name ~R1 SrcClass Y DstClass A Attrs {B1 B1} PrevSrcClass {}}
        addAssocLink foo {Name ~R1 SrcClass A}\
            {Name ~R1 SrcClass A DstClass X Attrs {A1 A1} PrevSrcClass Y}
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findRelated $ref {R1 A}
    } -result {unknown relationship, "R1", for class, "c1"}\
        -returnCodes error
    test findRelated-2.0 {
        Navigate a relationship -- associative class
    } -setup {
        setupDomain foo
        addClass foo X {A1 int A2 string} A1
        addClass foo Y {B1 int B2 string} B1
        addClass foo A {A1 int B1 int} {A1 B1}
        # Forward direction is from X -> Y via A
        addAssocLink foo {Name R1 SrcClass X}\
            {Name R1 SrcClass X DstClass A Attrs {A1 A1} PrevSrcClass {}}
        addAssocLink foo {Name R1 SrcClass A}\
            {Name R1 SrcClass A DstClass Y Attrs {B1 B1} PrevSrcClass X}
        addAssocLink foo {Name ~R1 SrcClass Y}\
            {Name ~R1 SrcClass Y DstClass A Attrs {B1 B1} PrevSrcClass {}}
        addAssocLink foo {Name ~R1 SrcClass A}\
            {Name ~R1 SrcClass A DstClass X Attrs {A1 A1} PrevSrcClass Y}
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::X A1 5 A2 baz]
        rosea::ClassCmds::create [namespace current]::foo::Y B1 10 B2 bar
        rosea::ClassCmds::create [namespace current]::foo::A A1 5 B1 10
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findRelated $ref R1
    } -result {::rosea::test::foo::Y {{B1 int} {{B1 10}}}} -match ref
    test findRelated-2.1 {
        Navigate a relationship -- path to associative class
    } -setup {
        setupDomain foo
        addClass foo X {A1 int A2 string} A1
        addClass foo Y {B1 int B2 string} B1
        addClass foo A {A1 int B1 int} {A1 B1}
        # Forward direction is from X -> Y via A
        addAssocLink foo {Name R1 SrcClass X}\
            {Name R1 SrcClass X DstClass A Attrs {A1 A1} PrevSrcClass {}}
        addAssocLink foo {Name R1 SrcClass A}\
            {Name R1 SrcClass A DstClass Y Attrs {B1 B1} PrevSrcClass X}
        addAssocLink foo {Name ~R1 SrcClass Y}\
            {Name ~R1 SrcClass Y DstClass A Attrs {B1 B1} PrevSrcClass {}}
        addAssocLink foo {Name ~R1 SrcClass A}\
            {Name ~R1 SrcClass A DstClass X Attrs {A1 A1} PrevSrcClass Y}
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::X A1 5 A2 baz]
        rosea::ClassCmds::create [namespace current]::foo::Y B1 10 B2 bar
        rosea::ClassCmds::create [namespace current]::foo::A A1 5 B1 10
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findRelated $ref {R1 A}
    } -result {::rosea::test::foo::A {{A1 int B1 int} {{A1 5 B1 10}}}} -match ref
    test findUnrelated-1.0 {
        Navigate a relationship -- associative class -- unrelated instances
    } -setup {
        setupDomain foo
        addClass foo X {A1 int A2 string} A1
        addClass foo Y {B1 int B2 string} B1
        addClass foo A {A1 int B1 int} {A1 B1}
        # Forward direction is from X -> Y via A
        addAssocLink foo {Name R1 SrcClass X}\
            {Name R1 SrcClass X DstClass A Attrs {A1 A1} PrevSrcClass {}}
        addAssocLink foo {Name R1 SrcClass A}\
            {Name R1 SrcClass A DstClass Y Attrs {B1 B1} PrevSrcClass X}
        addAssocLink foo {Name ~R1 SrcClass Y}\
            {Name ~R1 SrcClass Y DstClass A Attrs {B1 B1} PrevSrcClass {}}
        addAssocLink foo {Name ~R1 SrcClass A}\
            {Name ~R1 SrcClass A DstClass X Attrs {A1 A1} PrevSrcClass Y}
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::X A1 5 A2 baz]
        rosea::ClassCmds::create [namespace current]::foo::X A1 7 A2 zzz
        rosea::ClassCmds::create [namespace current]::foo::Y B1 10 B2 bar
        rosea::ClassCmds::create [namespace current]::foo::Y B1 17 B2 xxx
        rosea::ClassCmds::create [namespace current]::foo::A A1 5 B1 10
        rosea::ClassCmds::create [namespace current]::foo::A A1 7 B1 17
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findUnrelated $ref R1
    } -result {::rosea::test::foo::Y {{B1 int} {{B1 17}}}} -match ref
    test findRelated-3.0 {
        Navigate a generalization
    } -setup {
        setupDomain foo
        addClass foo S {S1 int S2 string} S1
        addClass foo X {X1 int X2 string} X1
        addClass foo Y {Y1 int Y2 string} Y1
    
        addAssocLink foo {Name R1 SrcClass X}\
            {Name R1 SrcClass X DstClass S Attrs {X1 S1} PrevSrcClass {}}
        addAssocLink foo {Name R1 SrcClass Y}\
            {Name R1 SrcClass Y DstClass S Attrs {Y1 S1} PrevSrcClass {}}
        relvar eval {
            addParitionLink foo {Name ~R1 SrcClass S}
            addPartitionDst foo {Name ~R1 SrcClass S DstClass X Attrs {S1 X1}}
            addPartitionDst foo {Name ~R1 SrcClass S DstClass Y Attrs {S1 Y1}}
        }
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::S S1 5 S2 baz]
        rosea::ClassCmds::create [namespace current]::foo::X X1 5 X2 bar
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findRelated $ref {~R1 X}
    } -result {::rosea::test::foo::X {{X1 int} {{X1 5}}}} -match ref
    test findRelated-3.1 {
        Navigate a generalization -- bad subclass
    } -setup {
        setupDomain foo
        addClass foo S {S1 int S2 string} S1
        addClass foo X {X1 int X2 string} X1
        addClass foo Y {Y1 int Y2 string} Y1
    
        addAssocLink foo {Name R1 SrcClass X}\
            {Name R1 SrcClass X DstClass S Attrs {X1 S1} PrevSrcClass {}}
        addAssocLink foo {Name R1 SrcClass Y}\
            {Name R1 SrcClass Y DstClass S Attrs {Y1 S1} PrevSrcClass {}}
        relvar eval {
            addParitionLink foo {Name ~R1 SrcClass S}
            addPartitionDst foo {Name ~R1 SrcClass S DstClass X Attrs {S1 X1}}
            addPartitionDst foo {Name ~R1 SrcClass S DstClass Y Attrs {S1 Y1}}
        }
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::S S1 5 S2 baz]
        rosea::ClassCmds::create [namespace current]::foo::X X1 5 X2 bar
    } -cleanup {
        cleanupDomain foo
    } -body {
        ::rosea::InstCmds::findRelated $ref {~R1 Z}
    } -result {navigating from superclass, "S", along generalization "~R1",\
        does not have "Z" as a subclass} -returnCodes error
    test updateAttribute-1.0 {
        Update single attribute value
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::updateAttribute $ref A2 foo
        relation extract [::rosea::InstCmds::deRef $ref] A2
    } -result {foo}
    test updateAttribute-1.1 {
        Update multiple attribute values
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string A3 int} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1\
            A1 5 A2 baz A3 27]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::updateAttribute $ref A3 42 A2 foo
        relation extract [::rosea::InstCmds::deRef $ref] A2 A3
    } -result {foo 42}
    test updateAttribute-1.2 {
        Update identifying attributes
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::updateAttribute $ref A1 27
    } -result {cannot update identifying attributes, "A1"} -returnCodes error
    test updateAttribute-1.3 {
        Update non-existent attributes
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::updateAttribute $ref C3 27
    } -result {unknown attribute, "C3"} -returnCodes error
    test updateAttribute-1.4 {
        Update single attribute value containing Tcl metacharacters
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::updateAttribute $ref A2 {foo[27]}
        relation extract [::rosea::InstCmds::deRef $ref] A2
    } -result {foo[27]}
    test withAttribute-1.0 {
        Update single attribute value
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 string A2 int} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 baz A2 5]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::withAttribute $ref A2 {
            incr A2
        }
        relation extract [::rosea::InstCmds::deRef $ref] A2
    } -result {6}
    test withAttribute-1.1 {
        Update multiple attribute values
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string A3 int} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1\
                A1 5 A2 baz A3 27]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::withAttribute $ref {A3 x} {A2 y} {
            set x [expr {$x + 10}]
            set y foo
        }
        relation extract [::rosea::InstCmds::deRef $ref] A2 A3
    } -result {foo 37}
    test withAttribute-1.2 {
        Unset update variable
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string A3 int} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1\
                A1 5 A2 baz A3 27]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::withAttribute $ref {A3 x} {A2 y} {
            set x [expr {$x + 10}]
            unset y
        }
        relation extract [::rosea::InstCmds::deRef $ref] A2 A3
    } -result {baz 37}
    test readAttribute-1.0 {
        Read single attribute value
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::readAttribute $ref A2
    } -result {baz}
    test readAttribute-1.1 {
        Read multiple attribute values
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::readAttribute $ref A1 A2
    } -result {5 baz}
    test readAttribute-1.2 {
        Attempt to read multiple reference
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz
        rosea::ClassCmds::create [namespace current]::bar::c1 A1 7 A2 foo
        set ref [rosea::ClassCmds::findAll [namespace current]::bar::c1]
    } -cleanup {
        cleanupDomain bar
    } -body {
        rosea::InstCmds::readAttribute $ref A1
    } -result {single valued reference required, 2 found} -returnCodes error
    test assignAttribute-1.0 {
        Assign single attribute value into a given Tcl variable
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::assignAttribute $ref {A2 myvar}
        set myvar
    } -result {baz}
    test assignAttribute-1.1 {
        Assign multiple attribute values
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string} A1
        set ref [rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain bar
    } -body {
        ::rosea::InstCmds::assignAttribute $ref A1 {A2 a2var}
        list $A1 $a2var
    } -result {5 baz}
    test delete-1.1 {
        delete class instances
    } -setup {
        setupDomain bar
        addClass bar c1 {A1 int A2 string A3 int} A1
        rosea::ClassCmds::create [namespace current]::bar::c1 A1 5 A2 baz A3 27
        rosea::ClassCmds::create [namespace current]::bar::c1 A1 6 A2 foo A3 37
        rosea::ClassCmds::create [namespace current]::bar::c1 A1 7 A2 bar A3 47
    } -cleanup {
        cleanupDomain bar
    } -body {
        set before [relation cardinality [relvar set [namespace current]::bar::c1]]
        rosea::InstCmds::delete [rosea::Helpers::ToRef\
            [namespace current]::bar::c1\
            [relvar set [namespace current]::bar::c1]]
        set after [relation cardinality [relvar set [namespace current]::bar::c1]]
        testConditions\
            {$before == 3}\
            {$after == 0}
    } -result {1}
    test SignalEvent-1.0 {
        Signal an event
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        relvar eval {
            addState foo Class c1 State s1
            addState foo Class c1 State s2
            addEvent foo Class c1 Event e1
            addInitialState foo Class c1 State s1
            addTransition foo Class c1 State s1 Event e1 NewState s2
            addTransition foo Class c1 State s2 Event e1 NewState s1
        }
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
        rosea::InstCmds::signal $ref e1
    } -cleanup {
        after cancel [namespace eval ::rosea::Dispatch namespace code DispatchEvent]
        cleanupDomain foo
        set ::rosea::Dispatch::toc_queue [list]
    } -body {
        set event [lindex $::rosea::Dispatch::toc_queue 0]
        dict get $event dst
    } -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
    test DispatchEvent-1.0 {
        Dispatch an event and execute a state action
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        relvar eval {
            addState foo Class c1 State s1
            addState foo Class c1 State s2
            addEvent foo Class c1 Event e1
            addInitialState foo Class c1 State s1
            addTransition foo Class c1 State s1 Event e1 NewState s2
            addTransition foo Class c1 State s2 Event e1 NewState s1
        }
        proc [namespace current]::foo::c1::__Activity::s2 {self} {
            set ::done $self
        }
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
        rosea::InstCmds::signal $ref e1
    } -cleanup {
        cleanupDomain foo
    } -body {
        vwait ::done
        set ::done
    } -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
    test DispatchEvent-1.1 {
        Dispatch an event with the wrong arguments
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        relvar eval {
            addState foo Class c1 State s1
            addState foo Class c1 State s2
            addEvent foo Class c1 Event e1
            addInitialState foo Class c1 State s1
            addTransition foo Class c1 State s1 Event e1 NewState s2
            addTransition foo Class c1 State s2 Event e1 NewState s1
        }
        proc [namespace current]::foo::c1::__Activity::s2 {self} {
        }
    } -cleanup {
        cleanupDomain foo
    } -body {
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
        rosea::InstCmds::signal $ref e1 baz
        lindex [waitForBGError] 1
    } -result {WRONGARGS}
    test DispatchEvent-1.2 {
        Dispatch an event with error in the activity
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        relvar eval {
            addState foo Class c1 State s1
            addState foo Class c1 State s2
            addEvent foo Class c1 Event e1
            addInitialState foo Class c1 State s1
            addTransition foo Class c1 State s1 Event e1 NewState s2
            addTransition foo Class c1 State s2 Event e1 NewState s1
        }
        proc [namespace current]::foo::c1::__Activity::s2 {self} {
            throw BAD {bad activity}
        }
    } -cleanup {
        cleanupDomain foo
    } -body {
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
        rosea::InstCmds::signal $ref e1
        waitForBGError
    } -result {BAD}
    test DispatchDelayedEvent-1.0 {
        Dispatch a delayed event and execute a state action
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        relvar eval {
            addState foo Class c1 State s1
            addState foo Class c1 State s2
            addEvent foo Class c1 Event e1
            addInitialState foo Class c1 State s1
            addTransition foo Class c1 State s1 Event e1 NewState s2
            addTransition foo Class c1 State s2 Event e1 NewState s1
        }
        proc [namespace current]::foo::c1::__Activity::s2 {self} {
            set ::done $self
        }
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
        rosea::InstCmds::delaysignal 100 $ref e1
    } -cleanup {
        cleanupDomain foo
    } -body {
        vwait ::done
        set ::done
    } -result {::rosea::test::foo::c1 {{A1 int} {{A1 5}}}} -match ref
    test CancelDelayedSignal-1.0 {
        Cancel a delayed event
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        relvar eval {
            addState foo Class c1 State s1
            addState foo Class c1 State s2
            addEvent foo Class c1 Event e1
            addInitialState foo Class c1 State s1
            addTransition foo Class c1 State s1 Event e1 NewState s2
            addTransition foo Class c1 State s2 Event e1 NewState s1
        }
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain foo
    } -body {
        rosea::InstCmds::delaysignal 100 $ref e1
        set src [rosea::Helpers::nilInstRef]
        rosea::InstCmds::canceldelayed $src $ref e1
        relation cardinality [rosea::Dispatch::FindDelayedSignal $src e1 $ref]
    } -result {0}
    test SignalTimeRemaining-1.0 {
        Obtain remaining time on a delayed signal
    } -setup {
        setupDomain foo
        addClass foo c1 {A1 int A2 string} A1
        relvar eval {
            addState foo Class c1 State s1
            addState foo Class c1 State s2
            addEvent foo Class c1 Event e1
            addInitialState foo Class c1 State s1
            addTransition foo Class c1 State s1 Event e1 NewState s2
            addTransition foo Class c1 State s2 Event e1 NewState s1
        }
    
        set ref [rosea::ClassCmds::create [namespace current]::foo::c1 A1 5 A2 baz]
    } -cleanup {
        cleanupDomain foo
    } -body {
        rosea::InstCmds::delaysignal 100 $ref e1
        set src [rosea::Helpers::nilInstRef]
        set remain [rosea::InstCmds::delayremaining $src $ref e1]
        rosea::InstCmds::canceldelayed $src $ref e1
        expr {$remain <= 100 && $remain >= 95}
    } -result {1}
    test MapPolymorphicEvent-1.0 {
        Map a polymorphic event
    } -setup {
        setupDomain bar
        addClass bar S {S1 int S2 string} S1
        addClass bar X {X1 int X2 string} X1
        addClass bar Y {Y1 int Y2 string} Y1
    
        addAssocLink bar {Name R1 SrcClass X}\
            {Name R1 SrcClass X DstClass S Attrs {X1 S1} PrevSrcClass {}}
        addAssocLink bar {Name R1 SrcClass Y}\
            {Name R1 SrcClass Y DstClass S Attrs {Y1 S1} PrevSrcClass {}}
        relvar eval {
            addParitionLink bar {Name ~R1 SrcClass S}
            addPartitionDst bar {Name ~R1 SrcClass S DstClass X Attrs {S1 X1}}
            addPartitionDst bar {Name ~R1 SrcClass S DstClass Y Attrs {S1 Y1}}
        }
    
        addPolymorphic bar Class S Event e1
        set ref [rosea::ClassCmds::create [namespace current]::bar::S S1 5 S2 baz]
        rosea::ClassCmds::create [namespace current]::bar::X X1 5 X2 bar
    } -cleanup {
        cleanupDomain bar
    } -body {
        rosea::Dispatch::MapPolymorphicEvent [namespace current]::polysignal\
            {} $ref e1 {}
    } -result {true} -output {::rosea::test::polysignal {} {::rosea::test::bar::X {{X1 int} {{X1 5}}}} e1 {}}
    test configure-1.0 {
        Define domain
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                # A domain may be empty of components.
            }
        }
        relation extract [relvar set ::rosea::Config::Domain] Name
    } -result {foo}
    test configure-1.1 {
        Define domain -- bad name
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain {} {
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error
    test configure-2.0 {
        Define domain and classes
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -id 1
                    attribute a2 string -default 20
                }
                class c2 {
                    attribute a1 string -id 1
                    attribute a2 string -default 40
                }
            }
        }
        relation cardinality [relvar set ::rosea::Config::Class]
    } -result {2}
    test configure-2.1 {
        Define domain -- bad attribute option
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -foo 1 -id 1
                }
            }
        }
    } -result {encountered 2 configuration script errors} -returnCodes error
    test configure-2.2 {
        Define class reference
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        catch {
            rosea configure {
                domain foo {
                    class c1 {
                        attribute a1 string -id 1
                        attribute a2 string -default 20
                    }
                    class c2 {
                        attribute a1 string -id 1
                        attribute a2 string -default 40
                        reference R1 c1 -link a1
                    }
                    set ::rosea::test::arefs [relation cardinality\
                        $::rosea::Config::AttributeReference]
                }
            }
        }
        set arefs
    } -result {1}
    test configure-3.0 {
        Define simple association
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class x {
                    attribute a1 string -id 1
                    attribute a2 string -default 20
                }
                class y {
                    attribute a1 string -id 1
                    reference R1 x -link a1
                }
                association R1 y 1--1 x
            }
        }
        relation cardinality [relvar set ::rosea::Config::SimpleAssociation]
    } -result {1}
    test configure-3.1 {
        Define reflexive simple association
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class x {
                    attribute a1 string -id 1
                    attribute prev string -id 2
                    attribute a2 string -default 20
                    reference R1 x -link {prev a1}
                }
                association R1 x 1--1 x
            }
        }
        relation cardinality [relvar set ::rosea::Config::SimpleAssociation]
    } -result {1}
    test configure-3.2 {
        Define class based association
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class a {
                    attribute x1 string -id 1
                    attribute y1 string -id 1
                    reference R1 x -link x1
                    reference R1 y -link y1
                }
                class x {
                    attribute x1 string -id 1
                    attribute x2 string -default 20
                }
                class y {
                    attribute y1 string -id 1
                }
                association R1 x 1..*--1..* y -associator a
            }
        }
        relation cardinality [relvar set ::rosea::Config::ClassBasedAssociation]
    } -result {1}
    test configure-3.3 {
        Define reflexive class based association
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class a {
                    attribute x1 string -id 1
                    attribute next string -id 1
                    reference R1 x -link x1 -link {next x1}
                }
                class x {
                    attribute x1 string -id 1
                    attribute x2 string -default 20
                }
                association R1 x 1..*--1..* x -associator a -path {x1 next}
            }
        }
        relation cardinality [relvar set ::rosea::Config::ClassBasedAssociation]
    } -result {1}
    test configure-3.4 {
        Simple association -- bad class
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                association R1 y 1--1 x
            }
        }
    } -result {encountered 2 configuration script errors} -returnCodes error
    test configure-3.5 {
        Simple association -- need associator
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                association R1 y 1..*--1..* x
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error
    test configure-4.0 {
        Define generalization
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class super {
                    attribute a1 string -id 1
                    attribute a2 string -default 20
                }
                class sub1 {
                    attribute a1 string -id 1
                    reference R1 super -link a1
                }
                class sub2 {
                    attribute a1 string -id 1
                    reference R1 super -link a1
                }
                generalization R1 super sub1 sub2
            }
        }
        relation cardinality [relvar set ::rosea::Config::Class]
    } -result {3}
    test configure-5.0 {
        Define statemodel
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -id 1
                    statemodel {
                        state s1 {a b} {
                            puts $a $b
                        }
                        transition s1 - e1 -> s2
    
                        state s2 {} {
                            puts "in s2"
                        }
                        transition s2 - e1 -> s1
                    }
                }
            }
        }
        relation cardinality [relvar set ::rosea::Config::StateModel]
    } -result {1}
    test configure-6.0 {
        Define polymorphic events
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class S {
                    attribute id string -id 1
                    polymorphic e1 e2
                }
                class X {
                    attribute id string -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                class Y {
                    attribute id string -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R1 S X Y
            }
        }
        testConditions\
            {[relation cardinality $::rosea::Config::NonLocalEvent] == 4}\
            {[relation cardinality $::rosea::Config::MappedEvent] == 4}\
            {[relation cardinality $::rosea::Config::LocalEvent] == 0}
    } -result {1}
    test configure-6.1 {
        Define polymorphic events -- inherit across one level
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class S {
                    attribute id string -id 1
                    polymorphic e1 e2
                }
                class X {
                    attribute id string -id 1
                    reference R1 S -link id
                }
                class Y {
                    attribute id string -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R1 S X Y
    
                class A {
                    attribute id string -id 1
                    reference R2 X -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                class B {
                    attribute id string -id 1
                    reference R2 X -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R2 X A B
            }
        }
        testConditions\
            {[relation cardinality $::rosea::Config::NonLocalEvent] == 8}\
            {[relation cardinality $::rosea::Config::InheritedEvent] == 2}\
            {[relation cardinality $::rosea::Config::MappedEvent] == 6}\
            {[relation cardinality $::rosea::Config::LocalEvent] == 0}
    } -result {1}
    test configure-6.2 {
        Define polymorphic events -- new event in leaf subclass
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class S {
                    attribute id string -id 1
    
                    polymorphic e1 e2
                }
                class X {
                    attribute id string -id 1
                    reference R1 S -link id
    
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        state s2 {} {
                            puts "in s2"
                        }
                        transition s1 - e1 -> s2
                        transition s2 - e2 -> s1
                        transition s2 - e3 -> s2 ; # New local event!
                    }
                }
                class Y {
                    attribute id string -id 1
                    reference R1 S -link id
    
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        state s2 {} {
                            puts "in s2"
                        }
                        transition s1 - e1 -> s2
                        transition s2 - e2 -> s1
                    }
                }
                generalization R1 S X Y
            }
        }
        testConditions\
            {[relation cardinality $::rosea::Config::NonLocalEvent] == 4}\
            {[relation cardinality $::rosea::Config::InheritedEvent] == 0}\
            {[relation cardinality $::rosea::Config::MappedEvent] == 4}\
            {[relation cardinality $::rosea::Config::LocalEvent] == 1}
    } -result {1}
    test configure-6.3 {
        Define polymorphic events -- inject polymorphic event mid-level
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class S {
                    attribute id string -id 1
                    polymorphic e1 e2
                }
                class X {
                    attribute id string -id 1
                    reference R1 S -link id
                    polymorphic e3
                }
                class Y {
                    attribute id string -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R1 S X Y
    
                class A {
                    attribute id string -id 1
                    reference R2 X -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                class B {
                    attribute id string -id 1
                    reference R2 X -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R2 X A B
            }
        }
        testConditions\
            {[relation cardinality $::rosea::Config::NonLocalEvent] == 10}\
            {[relation cardinality $::rosea::Config::InheritedEvent] == 2}\
            {[relation cardinality $::rosea::Config::MappedEvent] == 8}\
            {[relation cardinality $::rosea::Config::LocalEvent] == 0}
    } -result {1}
    test configure-6.4 {
        Define polymorphic events -- multiple hierarchies
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class S {
                    attribute id string -id 1
                    polymorphic e1 e2
                }
                class X {
                    attribute id string -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                class Y {
                    attribute id string -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R1 S X Y
    
                class A {
                    attribute id string -id 1
                    reference R2 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                class B {
                    attribute id string -id 1
                    reference R2 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R2 S A B
            }
        }
        testConditions\
            {[relation cardinality $::rosea::Config::NonLocalEvent] == 8}\
            {[relation cardinality $::rosea::Config::InheritedEvent] == 0}\
            {[relation cardinality $::rosea::Config::MappedEvent] == 8}\
            {[relation cardinality $::rosea::Config::LocalEvent] == 0}
    } -result {1}
    test configure-6.5 {
        Define polymorphic events -- common subclass
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class S {
                    attribute id string -id 1
                    polymorphic e1 e2
                }
                class X {
                    attribute id string -id 1
                    attribute zid string -id 2
                    reference R1 S -link id
                    reference R2 Z -link zid
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                        transition s1 - e3 -> s1
                    }
                }
                class Y {
                    attribute id string -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                    }
                }
                generalization R1 S X Y
    
                class Z {
                    attribute zid string -id 1
                    polymorphic e3
                }
                class A {
                    attribute zid string -id 1
                    reference R2 Z -link zid
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                    }
                }
                generalization R2 Z A X
            }
        }
        testConditions\
            {[relation cardinality $::rosea::Config::NonLocalEvent] == 6}\
            {[relation cardinality $::rosea::Config::InheritedEvent] == 0}\
            {[relation cardinality $::rosea::Config::MappedEvent] == 6}\
            {[relation cardinality $::rosea::Config::LocalEvent] == 0}
    } -result {1}
    test configure-6.6 {
        Define polymorphic events -- consume mid level event
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class S {
                    attribute id int -id 1
                    polymorphic e1
                    polymorphic e2
                }
                class X {
                    attribute id int -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                    }
                }
                class Y {
                    attribute id int -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R1 S X Y
    
                class A {
                    attribute id int -id 1
                    reference R2 X -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e2 -> s1
                    }
                }
                class B {
                    attribute id int -id 1
                    reference R2 X -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e2 -> s1
                    }
                }
                generalization R2 X A B
            }
        }
        puts [relformat $::rosea::Config::EffectiveEvent EffectiveEvent]
        puts [relformat $::rosea::Config::DeferredEvent DeferredEvent]
        puts [relformat $::rosea::Config::NonLocalEvent NonLocalEvent]
        puts [relformat $::rosea::Config::InheritedEvent InheritedEvent]
        puts [relformat $::rosea::Config::MappedEvent MappedEvent]
        puts [relformat $::rosea::Config::LocalEvent LocalEvent]
        testConditions\
            {[relation cardinality $::rosea::Config::NonLocalEvent] == 6}\
            {[relation cardinality $::rosea::Config::InheritedEvent] == 1}\
            {[relation cardinality $::rosea::Config::MappedEvent] == 5}\
            {[relation cardinality $::rosea::Config::LocalEvent] == 0}
    } -result {1}
    test configure-6.7 {
        Define polymorphic events -- consume mid level event, use in subclass
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class S {
                    attribute id int -id 1
                    polymorphic e1
                    polymorphic e2
                }
                class X {
                    attribute id int -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                    }
                }
                class Y {
                    attribute id int -id 1
                    reference R1 S -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                        transition s1 - e2 -> s1
                    }
                }
                generalization R1 S X Y
    
                class A {
                    attribute id int -id 1
                    reference R2 X -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e2 -> s1
                        transition s1 - e1 -> s1
                    }
                }
                class B {
                    attribute id int -id 1
                    reference R2 X -link id
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e2 -> s1
                        transition s1 - e1 -> s1
                    }
                }
                generalization R2 X A B
            }
        }
    } -result {encountered 2 configuration script errors} -returnCodes error
    test configure-7.0 {
        Define assigner
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class Customer {
                    attribute Name string -id 1
                }
                class Clerk {
                    attribute Name string -id 1
                    attribute Customer string
                    reference R1 Customer -link {Customer Name}
                }
                association R1 Clerk 0..1--0..1 Customer
                assigner R1 {
                    state s1 {a b} {
                        puts $a $b
                    }
                    transition s1 - e1 -> s2
    
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s2 - e1 -> s1
                }
            }
        }
        relation cardinality [relvar set ::rosea::Config::SingleAssigner]
    } -result {1}
    test configure-7.1 {
        Define mulit assigner
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class Customer {
                    attribute Name string -id 1
                }
                class Clerk {
                    attribute Name string -id 1
                    attribute Customer string
                    attribute Department string
                    reference R1 Customer -link {Customer Name}
                    reference R2 Department -link {Department Name}
                }
                class Department {
                    attribute Name string -id 1
                }
                association R1 Clerk 0..1--0..1 Customer
                association R2 Clerk 1..*--1 Department
                assigner R1 {
                    identifyby Department
                    state s1 {a b} {
                        puts $a $b
                    }
                    transition s1 - e1 -> s2
    
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s2 - e1 -> s1
                }
            }
        }
        relation cardinality [relvar set ::rosea::Config::MultipleAssigner]
    } -result {1}
    test configure-8.0 {
        configure error -- no attributes defined for class
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                }
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error\
    -output {*in domain, "foo", class, "c1", has no attributes*} -match glob
    test configure-8.1 {
        configure error -- no identifier defined for class
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string
                }
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error\
    -output {*in domain, "foo", class, "c1", has no identifiers*} -match glob
    test configure-8.2 {
        configure error -- no reference
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -id 1
                }
                class c2 {
                    attribute a2 string -id 1
                }
                association R1 c1 1--1 c2
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error\
    -output {*in domain, "foo", for relationship, "R1", no class has defined a reference to class, "c2"*}\
    -match glob
    test configure-8.3 {
        configure error -- bad reference
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -id 1
                    reference R1 c3 -link a1
                }
                class c2 {
                    attribute a2 string -id 1
                }
                association R1 c1 1--1 c2
            }
        }
    } -result {encountered 3 configuration script errors} -returnCodes error\
    -output {*in domain, "foo", relationship, "R1", references attribute, "a1", in class, "c3", which is not an identifying attribute, does not exist or "R1" does not exist*}\
    -match glob
    test configure-8.4 {
        configure error -- bad referential attribute linkage
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -id 1
                    reference R1 c2 -link {a1 a3}
                }
                class c2 {
                    attribute a2 string -id 1
                }
                association R1 c1 1--1 c2
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error\
    -output {*in domain, "foo", relationship, "R1", references attribute, "a3", in class, "c2", which is not an identifying attribute, does not exist or "R1" does not exist*}\
    -match glob
    test configure-8.5 {
        configure error -- transition refers to non-existent state
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -id 1
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s2
                    }
                }
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error\
    -output {*in domain, "foo", the state model for, "c1", contains the transition, "s1 - e1 -> s2", but state "s2" does not exist*}\
    -match glob
    test configure-8.6 {
        configure error -- duplicated polymorphic events
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class super {
                    attribute a1 string -id 1
                    polymorphic e1
                }
                class sub1 {
                    attribute a1 string -id 1
                    reference R1 super -link a1
    
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                    }
                }
                class sub2 {
                    attribute a1 string -id 1
                    reference R1 super -link a1
                    polymorphic e1
                }
                class ssub1 {
                    attribute a1 string -id 1
                    reference R2 sub2 -link a1
                }
                class ssub2 {
                    attribute a1 string -id 1
                    reference R2 sub2 -link a1
                }
                generalization R1 super sub1 sub2
                generalization R2 sub2 ssub1 ssub2
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error\
    -output {*in domain, "foo", in the state model for, "sub2", event, "e1", is both an inherited polymorphic event and a locally defined one*}\
    -match glob
    test configure-8.7 {
        configure error -- no leaf state models
    } -setup {
    } -cleanup {
        cleanupConfigData
    } -body {
        rosea configure {
            domain foo {
                class super {
                    attribute a1 string -id 1
                    polymorphic e1
                }
                class sub1 {
                    attribute a1 string -id 1
                    reference R1 super -link a1
    
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                    }
                }
                class sub2 {
                    attribute a1 string -id 1
                    reference R1 super -link a1
                }
                class ssub1 {
                    attribute a1 string -id 1
                    reference R2 sub2 -link a1
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                    }
                }
                class ssub2 {
                    attribute a1 string -id 1
                    reference R2 sub2 -link a1
                }
                generalization R1 super sub1 sub2
                generalization R2 sub2 ssub1 ssub2
            }
        }
    } -result {encountered 1 configuration script errors} -returnCodes error\
    -output {*in domain, "foo", event, "e1" has been inherited, but no state model exists for, "ssub2"*}\
    -match glob
    test generate-5.0 {
        Classes with state models
    } -setup {
        rosea configure {
            domain foo {
                class Dog {
                    attribute Name string -id 1
                    attribute Breed string
    
                    statemodel {
                        state Born {} {
                            puts "In Born"
                        }
                        state Grown {} {
                            puts "In Grown"
                            delaysignal 200 $self Time
                        }
                        state Old {} {
                            puts "In Old"
                            delaysignal 200 $self Time
                        }
                        state Dead {} {
                            puts "In Dead"
                            set ::done 1
                        }
                        terminal Dead
    
                        transition Born - Time -> Grown
                        transition Grown - Time -> Old
                        transition Old - Time -> Dead
                    }
                }
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        testConditions\
            {[relation cardinality [relvar set ::foo::__Arch_Transition]] == 4}\
            {[relation cardinality [relvar set ::foo::__Arch_State]] == 4}\
            {[relation cardinality [relvar set ::foo::__Arch_Event]] == 1}\
    } -result {1}
    test generate-1.0 {
        Generate domain relvars
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute x2 string -default 20
                }
                class Y {
                    attribute y1 string -id 1
                }
            }
        }
        rosea generate
        set rvnames [relvar names ::foo::*]
        expr {"::foo::X" in $rvnames && "::foo::Y" in $rvnames}
    } -result {1}
    test generate-1.1 {
        Generate domain relvars -- multiple identifiers
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute y1 string -id 1
                    attribute z1 int -id 2
                    attribute x2 string
                }
            }
        }
        rosea generate
        relvar identifiers ::foo::X
    } -result {{x1 y1} z1}
    test generate-1.2 {
        Generate domain relvars, default values
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute y1 string -id 1
                    attribute x2 string -default foo
                    attribute x3 int -default 20
                }
            }
        }
        rosea generate
        set ref [::foo::X create x1 red y1 truck]
        rosea tunnel $ref readAttribute x2 x3
    } -result {foo 20}
    test generate-1.3 {
        Generate domain relvars, override default values
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute y1 string -id 1
                    attribute x2 string -default foo
                    attribute x3 int -default 20
                }
            }
        }
        rosea generate
        set ref [::foo::X create x1 red y1 truck x2 bar x3 40]
        rosea tunnel $ref readAttribute x2 x3
    } -result {bar 40}
    test generate-1.4.1 {
        Generate domain relvars, system supplied value
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute y1 int -id 1 -system 100
                    attribute x2 string -default foo
                    attribute x3 int -default 20
                }
            }
        }
        rosea generate
        set ref [::foo::X create x1 red]
        rosea tunnel $ref readAttribute y1
    } -result {100}
    test generate-1.4.2 {
        Generate domain relvars, system supplied value, override default
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute y1 int -id 1 -system 100
                    attribute x2 string -default foo
                    attribute x3 int -default 20
                }
            }
        }
        rosea generate
        ::foo::X create x1 red
        # We are supplying the value of "y1".
        ::foo::X create x1 red y1 200
        # Since we supplied y1 last time, we expect the next y1 value to be 101
        set ref [::foo::X create x1 red]
        rosea tunnel $ref readAttribute y1
    } -result {101}
    test generate-1.5 {
        Generate domain relvars, generated default value
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute y1 string -id 1
                    attribute x2 string -generate {uuid::uuid generate}
                }
            }
        }
        rosea generate
        set ref [::foo::X create x1 red y1 truck]
        rosea tunnel $ref readAttribute x2
    } -result {[[:xdigit:]-]{36}} -match regexp
    test generate-1.6 {
        Generate domain relvars, check values on create
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute x2 int -check {$x2 > 1 && $x2 < 10}
                }
            }
        }
        rosea generate
        set ref [::foo::X create x1 red x2 5]
        rosea tunnel $ref readAttribute x2
    } -result {5}
    test generate-1.7 {
        Generate domain relvars, check values on update
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute x2 int -check {$x2 > 1 && $x2 < 10}
                }
            }
        }
        rosea generate
        set ref [::foo::X create x1 red x2 5]
        rosea tunnel $ref updateAttribute x2 7
        rosea tunnel $ref readAttribute x2
    } -result {7}
    test generate-1.8 {
        Generate domain relvars, value check fails
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute x2 int -check {$x2 > 1 && $x2 < 10}
                }
            }
        }
        rosea generate
        set ref [::foo::X create x1 red x2 5]
        rosea tunnel $ref updateAttribute x2 17
    } -result {check for attribute, "x2", failed: instance value was, "x1 red x2 17": "$x2 > 1 && $x2 < 10" evaluated to "0"}\
        -returnCodes error
    test generate-1.9 {
        Generate domain relvars, default value and a check expression
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute x2 int -default 5 -check {$x2 > 1 && $x2 < 10}
                }
            }
        }
        rosea generate
        set ref [::foo::X create x1 red]
        rosea tunnel $ref readAttribute x2
    } -result {5}
    test generate-1.10 {
        generate class based operations
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -id 1
                    attribute a2 string
    
                    classop echo {id} {
                        return $id
                    }
                }
            }
        }
        rosea generate
        ::foo::c1 echo 27
    } -result {27}
    test generate-1.11 {
        generate instance based operations
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class c1 {
                    attribute a1 string -id 1
                    attribute a2 string
    
                    instop echo {id} {
                        return $id
                    }
                }
            }
        }
        rosea generate
        set ref [::foo::c1 create a1 bar a2 baz]
        rosea tunnel $ref echo 27
    } -result {27}
    test generate-2.0 {
        generate constraints for simple associative relationship
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class x {
                    attribute a1 string -id 1
                    attribute a2 string -default 20
                }
                class y {
                    attribute a1 string -id 1
                    reference R1 x -link a1
                }
                association R1 y 1--1 x
            }
        }
        rosea generate
        relvar constraint info ::foo::R1
    } -result {association ::foo::R1 ::foo::y a1 1 ::foo::x a1 1}
    test generate-2.1 {
        association run time data
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class X {
                    attribute x1 string -id 1
                    attribute x2 string -default 20
                }
                class Y {
                    attribute y1 string -id 1
                    reference R1 X -link {y1 x1}
                }
                association R1 Y 1--1 X
            }
        }
        rosea generate
    
        set forwattrs [pipe {
            relvar restrictone ::foo::__Arch_AssociationLink Name R1 SrcClass Y |
            relation extract ~ Attrs
        }]
    
        set revattrs [pipe {
            relvar restrictone ::foo::__Arch_AssociationLink Name ~R1 SrcClass X |
            relation extract % Attrs
        } {} |%]
    
        testConditions\
            {[relation cardinality $::foo::__Arch_Link] == 2}\
            {[relation cardinality $::foo::__Arch_RefLink] == 1}\
            {[llength [info commands ::foo::R1]] == 1}\
            {$forwattrs eq {y1 x1}}\
            {$revattrs eq {x1 y1}}
    
    } -result {1}
    test generate-2.2 {
        generate constraints for simple reflexive associative relationship
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class x {
                    attribute a1 string -id 1
                    attribute prev string -id 2
                    attribute a2 string -default 20
                    reference R1 x -link {prev a1}
                }
                association R1 x 1--1 x
            }
        }
        rosea generate
        relvar constraint info ::foo::R1
    } -result {association ::foo::R1 ::foo::x prev 1 ::foo::x a1 1}
    test generate-2.3 {
        traversal for simple reflexive associative relationship
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class x {
                    attribute a1 string -id 1
                    attribute prev string -id 2
                    attribute a2 string -default 20
                    reference R1 x -link {prev a1}
                }
                association R1 x ?--? x
            }
        }
        rosea generate
        relvar eval {
            set f [::foo::x create a1 fred prev {} a2 10]
            set j [::foo::x create a1 john prev fred a2 20]
        }
        set r [rosea tunnel $f findRelated ~R1]
        rosea tunnel $r readAttribute a2
    } -result {20}
    test generate-2.4 {
        navigate associative relationship
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::meta
    } -body {
        rosea configure {
            domain meta {
                class Class {
                    attribute Domain string -id 1
                    attribute Name string -id 1
                }
    
                class Attribute {
                    attribute Domain string -id 1
                    attribute Class string -id 1
                    attribute Name string -id 1
                    attribute Type string
    
                    reference R3 Class -link Domain -link {Class Name}
                }
                association R3 Attribute 1..*--1 Class
    
                operation showAttrs {class} {
                    set c1 [Class findWhere\
                            {$Domain eq "foo" && $Name eq $class}]
                    set attrs [instop $c1 findRelated ~R3]
                    return [instop $attrs deRef]
                }
            }
        }
        rosea generate
        relvar eval {
            meta::Class create Domain foo Name c1
            meta::Attribute create Domain foo Class c1 Name a1 Type string
            meta::Attribute create Domain foo Class c1 Name a2 Type string
        }
        meta::showAttrs c1
    } -result {{Domain string Class string Name string Type string} {{Domain foo Class c1 Name a1 Type string} {Domain foo Class c1 Name a2 Type string}}}\
        -match relation
    test generate-2.5 {
        link instances across association
    } -setup {
        rosea configure {
            domain meta {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 1..*--1 C1
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::meta
    } -body {
        relvar eval {
            set c1 [meta::C1 create Id foo A1 20]
            meta::C2 create Id bar C1Id {}
            meta::C2 create Id baz C1Id {}
            set c2 [meta::C2 create Id fub C1Id {}]
            meta::R1 link $c1 [meta::C2 findAll]
        }
        rosea tunnel $c2 readAttribute C1Id
    } -result {foo}
    test generate-2.6 {
        unlink instances across association
    } -setup {
        rosea configure {
            domain meta {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::meta
    } -body {
        relvar eval {
            set c1 [meta::C1 create Id foo A1 20]
            meta::C2 create Id bar C1Id foo
            meta::C2 create Id baz C1Id foo
            set c2 [meta::C2 create Id fub C1Id foo]
        }
        set before [rosea::InstCmds::refMultiplicity\
            [rosea::InstCmds::findRelated $c1 ~R1]]
        meta::R1 unlink [meta::C2 findWhere {[string match b* $Id]}]
        set after [rosea::InstCmds::refMultiplicity\
            [rosea::InstCmds::findRelated $c1 ~R1]]
        testConditions\
            {$before == 3}\
            {$after == 1}
    } -result {1}
    test generate-2.7 {
        unlink using referred to instance
    } -setup {
        rosea configure {
            domain meta {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::meta
    } -body {
        relvar eval {
            set c1 [meta::C1 create Id foo A1 20]
            meta::C2 create Id bar C1Id foo
            meta::C2 create Id baz C1Id foo
            meta::C2 create Id fub C1Id foo
        }
        set before [rosea::InstCmds::refMultiplicity\
            [rosea::InstCmds::findRelated $c1 ~R1]]
        meta::R1 unlink $c1
        set after [rosea::InstCmds::refMultiplicity\
            [rosea::InstCmds::findRelated $c1 ~R1]]
        testConditions\
            {$before == 3}\
            {$after == 0}
    } -result {1}
    test generate-2.8 {
        unlink and violate referential integrity
    } -setup {
        rosea configure {
            domain meta {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 1..*--0..1 C1
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::meta
    } -body {
        catch {relvar eval {
            set c1 [meta::C1 create Id foo A1 20]
            meta::C2 create Id bar C1Id foo
            meta::C2 create Id baz C1Id foo
            meta::C2 create Id fub C1Id foo
            meta::R1 unlink $c1}
        } result
        set result
    } -result {for association*::meta::R1*} -match glob
    test generate-3.0 {
        generate constraints for class based associative relationship
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class a {
                    attribute ax1 string -id 1
                    attribute ax2 string -id 1
                    attribute ay1 string -id 1
                    attribute ay2 string -id 1
                    reference R1 x -link {ax1 x1} -link {ax2 x2}
                    reference R1 y -link {ay1 y1} -link {ay2 y2}
                }
                class x {
                    attribute x1 string -id 1
                    attribute x2 string -id 1
                    attribute x3 string -default 20
                }
                class y {
                    attribute y1 string -id 1
                    attribute y2 string -id 1
                }
                association R1 x 0..*--1..* y -associator a
            }
        }
        rosea generate
        relvar constraint info ::foo::R1
    } -result {correlation ::foo::R1 ::foo::a {ax1 ax2} + ::foo::x {x1 x2} {ay1 ay2} * ::foo::y {y1 y2}}
    test generate-3.1 {
        class based association when simple would do
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class a {
                    attribute x1 string -id 1
                    attribute y1 string
                    reference R2 x -link x1
                    reference R2 y -link y1
                }
                class x {
                    attribute x1 string -id 1
                    attribute x2 int -default 20
                }
                class y {
                    attribute y1 string -id 1
                    attribute y2 string -default bar
                }
                association R2 x 0..*--1 y -associator a
            }
        }
        rosea generate
        relvar constraint info ::foo::R2
    } -result {correlation ::foo::R2 ::foo::a x1 1 ::foo::x x1 y1 * ::foo::y y1}
    test generate-3.2 {
        generate constraints for reflexive class based associative relationship
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class A {
                    attribute xid string -id 1
                    attribute next_xid string -id 1
                    reference R1 X -link xid -link {next_xid xid}
                }
                class X {
                    attribute xid string -id 1
                    attribute value string -default 20
                }
                association R1 X 0..*--0..* X -associator A -path {xid next_xid}
            }
        }
        rosea generate
        relvar constraint info ::foo::R1
    } -result {correlation ::foo::R1 ::foo::A xid * ::foo::X xid next_xid * ::foo::X xid}
    test generate-3.3 {
        traversal for reflexive class based associative relationship
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class Element {
                    attribute ElemId string -id 1
                    attribute ElemNumber int
                }
                class Group {
                    attribute PrevElem string -id 1
                    attribute NextElem string -id 1
                    reference R1 Element\
                        -link {PrevElem ElemId} -link {NextElem ElemId}
                }
                association R1 Element *--* Element\
                    -associator Group\
                    -path {PrevElem NextElem}
            }
        }
        rosea generate
        relvar eval {
            ::foo::Element create ElemId fred ElemNumber 10
            ::foo::Element create ElemId john ElemNumber 20
            set s [::foo::Element create ElemId sally ElemNumber 30]
            ::foo::Group create PrevElem fred NextElem john
            ::foo::Group create PrevElem fred NextElem sally
        }
        set r [rosea tunnel $s findRelated ~R1]
        rosea tunnel $r readAttribute ElemNumber
    } -result {10}
    test generate-3.4 {
        link class bases association instances
    } -setup {
        rosea configure {
            domain foo {
                class A {
                    attribute ax1 string -id 1
                    attribute ax2 string -id 1
                    attribute ay1 string -id 1
                    attribute ay2 string -id 1
                    reference R1 X -link {ax1 x1} -link {ax2 x2}
                    reference R1 Y -link {ay1 y1} -link {ay2 y2}
                }
                class X {
                    attribute x1 string -id 1
                    attribute x2 string -id 1
                    attribute x3 int
                }
                class Y {
                    attribute y1 string -id 1
                    attribute y2 string -id 1
                    attribute y3 int
                }
                association R1 X 1..*--1..* Y -associator A
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        relvar eval {
            ::foo::X create x1 x1-1 x2 x2-1 x3 27
            ::foo::X create x1 x1-2 x2 x2-2 x3 47
            ::foo::Y create y1 y1-1 y2 y2-1 y3 57
            ::foo::Y create y1 y1-2 y2 y2-2 y3 67
    
            set assoc [::foo::R1 link [::foo::X findAll] [::foo::Y findAll]]
        }
        rosea tunnel $assoc refMultiplicity
    } -result {4}
    test generate-3.5 {
        unlink class based association instances.
    } -setup {
        rosea configure {
            domain foo {
                class A {
                    attribute ax1 string -id 1
                    attribute ax2 string -id 1
                    attribute ay1 string -id 1
                    attribute ay2 string -id 1
                    reference R1 X -link {ax1 x1} -link {ax2 x2}
                    reference R1 Y -link {ay1 y1} -link {ay2 y2}
                }
                class X {
                    attribute x1 string -id 1
                    attribute x2 string -id 1
                    attribute x3 int
                }
                class Y {
                    attribute y1 string -id 1
                    attribute y2 string -id 1
                    attribute y3 int
                }
                association R1 X 0..*--0..* Y -associator A
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        relvar eval {
            ::foo::X create x1 x1-1 x2 x2-1 x3 27
            ::foo::X create x1 x1-2 x2 x2-2 x3 47
            ::foo::Y create y1 y1-1 y2 y2-1 y3 57
            ::foo::Y create y1 y1-2 y2 y2-2 y3 67
        }
        set assoc [::foo::R1 link [::foo::X findAll] [::foo::Y findAll]]
        ::foo::R1 unlink [::foo::X findAll]
        relation cardinality [relvar set ::foo::A]
    } -result {0}
    test generate-4.0 {
        generate constraints for generalization relationship
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea configure {
            domain foo {
                class super {
                    attribute s1 string -id 1
                    attribute s2 string -id 1
                    attribute a2 string -default 20
                }
                class sub1 {
                    attribute sb1 string -id 1
                    attribute sb2 string -id 1
                    reference R1 super -link {sb1 s1} -link {sb2 s2}
                }
                class sub2 {
                    attribute sb3 string -id 1
                    attribute sb4 string -id 1
                    reference R1 super -link {sb3 s1} -link {sb4 s2}
                }
                generalization R1 super sub1 sub2
            }
        }
        rosea generate
        relvar constraint info ::foo::R1
    } -result {partition ::foo::R1 ::foo::super {s1 s2} ::foo::sub2 {sb3 sb4} ::foo::sub1 {sb1 sb2}}
    test generate-4.1.1 {
        migrate subclass
    } -setup {
        rosea configure {
            domain foo {
                class S {
                    attribute s1 string -id 1
                    attribute s2 string -id 1
                    attribute a2 int -default 20
                }
                class X {
                    attribute x1 string -id 1
                    attribute x2 string -id 1
                    reference R1 S -link {x1 s1} -link {x2 s2}
                }
                class Y {
                    attribute y1 string -id 1
                    attribute y2 string -id 1
                    reference R1 S -link {y1 s1} -link {y2 s2}
                }
                generalization R1 S X Y
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        relvar eval {
            foo::S create s1 a s2 b
            foo::X create x1 a x2 b
        }
        set ref [foo::X findWhere {$x1 eq "a"}]
        relvar eval {
            set result [foo::R1 migrate $ref Y]
        }
        set result
    } -result {::foo::Y {{y1 string y2 string} {{y1 a y2 b}}}} -match ref
    test generate-4.1.2 {
        migrate subclass under event control
    } -setup {
        rosea configure {
            domain foo {
                class S {
                    attribute id string -id 1
                }
                class X {
                    attribute id string -id 1
                    attribute x1 int -default 20
                    attribute b_id string
    
                    reference R1 S -link id
                    reference R4 B -link {b_id id}
                }
                class Y {
                    attribute id string -id 1
                    attribute y1 int -default 30
                    attribute c_id string
    
                    reference R1 S -link id
                    reference R3 C -link {c_id id}
    
                    statemodel {
                        state idle {} {
                            signal [findRelated $self R3] stop
                            R1 migrate $self X b_id [readAttribute $self c_id]
                            after 200 [list ::rosea::test::syncToTest $self]
                        }
                        transition idle - run -> running
    
                        state running {} {
                            signal [findRelated $self R3] run
                        }
                        transition running - stop -> idle
                    }
                }
                generalization R1 S X Y
    
                class A {
                    attribute id string -id 1
                }
                class B {
                    attribute id string -id 1
                    attribute b1 int -default 40
    
                    reference R2 A -link id
                }
                class C {
                    attribute id string -id 1
                    attribute c1 int -default 50
    
                    reference R2 A -link id
    
                    statemodel {
                        state idle {} {
                            R2 migrate $self B
                        }
                        transition idle - run -> running
    
                        state running {} {
                        }
                        transition running - stop -> idle
                    }
                }
                generalization R2 A B C
    
                association R3 Y 1--1 C
                association R4 X 1--1 B
            }
        }
        rosea generate
        rosea populate {
            domain foo {
                class S id s1
                class Y {id c_id} s1 a1
    
                class A id a1
                class C id a1
            }
        }
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea trace control clear
        rosea trace control on
        set yref [foo::Y findWhere {$id eq "s1"}]
        rosea tunnel $yref signal run
        after 400 [list rosea tunnel $yref signal stop]
        waitForSync
        rosea trace control off
        puts [rosea trace format [rosea trace decode all]]
    
        set xref [foo::X findWhere {$id eq "s1"}]
        set bref [foo::B findWhere {$id eq "a1"}]
        testConditions\
            {[rosea tunnel $xref readAttribute x1] == 20}\
            {[rosea tunnel $bref readAttribute b1] == 40}
    } -result {1}
    test generate-4.2 {
        repeated specialization
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::grocer
    } -body {
        rosea configure {
            domain grocer {
                class Fruit {
                    attribute Name string -id 1
                    attribute Color string
                }
                class SeededFruit {
                    attribute Name string -id 1
                    reference R1 Fruit -link Name
                }
                class UnseededFruit {
                    attribute Name string -id 1
                    reference R1 Fruit -link Name
                }
                generalization R1 Fruit SeededFruit UnseededFruit
    
                class StoneFruit {
                    attribute Name string -id 1
                    reference R2 SeededFruit -link Name
                }
                class PitFruit {
                    attribute Name string -id 1
                    attribute PitSize int -default 10
                    reference R2 SeededFruit -link Name
                }
                generalization R2 SeededFruit StoneFruit PitFruit
            }
        }
        rosea generate
        relvar eval {
            set ref [::grocer::Fruit create Name apple Color red]
            ::grocer::SeededFruit create Name apple
            ::grocer::PitFruit create Name apple PitSize 30
        }
        set pit [::rosea::InstCmds::findRelated $ref\
                {~R1 SeededFruit} {~R2 PitFruit}]
        ::rosea::InstCmds::readAttribute $pit PitSize
    } -result {30}
    test generate-4.3 {
        compound generalization
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::grocer
    } -body {
        rosea configure {
            domain grocer {
                class Fruit {
                    attribute Name string -id 1
                    attribute Color string
                }
                class SeededFruit {
                    attribute Name string -id 1
                    reference R1 Fruit -link Name
                }
                class UnseededFruit {
                    attribute Name string -id 1
                    reference R1 Fruit -link Name
                }
                generalization R1 Fruit SeededFruit UnseededFruit
    
                class RedFruit {
                    attribute Name string -id 1
                    reference R2 Fruit -link Name
                }
                class YellowFruit {
                    attribute Name string -id 1
                    reference R2 Fruit -link Name
                }
                generalization R2 Fruit RedFruit YellowFruit
            }
        }
        rosea generate
        relvar eval {
            set aref [::grocer::Fruit create Name apple Color red]
            ::grocer::SeededFruit create Name apple
            ::grocer::RedFruit create Name apple
    
            set bref [::grocer::Fruit create Name banana Color yellow]
            ::grocer::UnseededFruit create Name banana
            ::grocer::YellowFruit create Name banana
        }
        set apple [rosea tunnel $aref findRelated {~R1 SeededFruit}]
        set banana [rosea tunnel $bref findRelated {~R2 YellowFruit}]
        testConditions\
            {[rosea tunnel $apple readAttribute Name] eq "apple"}\
            {[rosea tunnel $banana readAttribute Name] eq "banana"}
    } -result {1}
    test generate-4.4 {
        signal a polymorphic event to a compound generalization
    } -setup {
    } -cleanup {
        cleanupConfigData
        removeDomain ::grocer
    } -body {
        rosea configure {
            domain grocer {
                class Fruit {
                    attribute Name string -id 1
                    attribute Color string
    
                    polymorphic grow
                }
                class SeededFruit {
                    attribute Name string -id 1
                    reference R1 Fruit -link Name
    
                    statemodel {
                        state seed {} {
                            puts "In Seed"
                        }
                        transition seed - grow -> sprouted
    
                        state sprouted {} {
                            puts "In SeededFruit"
                            lappend ::rosea::test::states SeededFruit
                        }
                    }
                }
                class UnseededFruit {
                    attribute Name string -id 1
                    reference R1 Fruit -link Name
    
                    statemodel {
                        state seed {} {
                            puts "In Seed"
                        }
                        transition seed - grow -> sprouted
    
                        state sprouted {} {
                            puts "In UnseededFruit"
                            lappend ::rosea::test::states UnseededFruit
                        }
                    }
                }
                generalization R1 Fruit SeededFruit UnseededFruit
    
                class RedFruit {
                    attribute Name string -id 1
                    reference R2 Fruit -link Name
    
                    statemodel {
                        state seed {} {
                            puts "In Seed"
                        }
                        transition seed - grow -> sprouted
    
                        state sprouted {} {
                            puts "In RedFruit"
                            lappend ::rosea::test::states RedFruit
                        }
                    }
                }
                class YellowFruit {
                    attribute Name string -id 1
                    reference R2 Fruit -link Name
    
                    statemodel {
                        state seed {} {
                            puts "In Seed"
                        }
                        transition seed - grow -> sprouted
    
                        state sprouted {} {
                            puts "In YellowFruit"
                            lappend ::rosea::test::states YellowFruit
                        }
                    }
                }
                generalization R2 Fruit RedFruit YellowFruit
            }
        }
        rosea generate
        relvar eval {
            set aref [::grocer::Fruit create Name apple Color red]
            ::grocer::SeededFruit create Name apple
            ::grocer::RedFruit create Name apple
        }
    
        set ::rosea::test::states [list]
        rosea tunnel $aref signal grow
        vwait ::rosea::test::states
    
        testConditions\
            {"SeededFruit" in $::rosea::test::states}\
            {"RedFruit" in $::rosea::test::states}
    } -result {1}
    test generate-6.0 {
        signal an assigner
    } -setup {
        rosea configure {
            domain foo {
                class Customer {
                    attribute Name string -id 1
                }
                class Clerk {
                    attribute Name string -id 1
                    attribute Customer string
                    reference R1 Customer -link {Customer Name}
                }
                association R1 Clerk 0..1--0..1 Customer
                assigner R1 {
                    state s1 {a b} {
                        puts $a $b
                    }
                    transition s1 - e1 -> s2
    
                    state s2 {} {
                        puts "in s2"
                            set ::done 1
                    }
                    transition s2 - e1 -> s1
                }
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        ::foo::R1 signal e1
        set timer [after 1000 set ::done TIMEOUT]
        vwait ::done
        after cancel $timer
        set ::done
    } -result {1}
    test generate-6.1 {
        signal a multi assigner
    } -setup {
        rosea configure {
            domain foo {
                class Customer {
                    attribute Name string -id 1
                }
                class Clerk {
                    attribute Name string -id 1
                    attribute Customer string
                    attribute Department string
                    reference R1 Customer -link {Customer Name}
                    reference R2 Department -link {Department Name}
                }
                class Department {
                    attribute Name string -id 1
                }
                association R1 Clerk 0..1--0..1 Customer
                association R2 Clerk 1..*--1 Department
                assigner R1 {
                    identifyby Department
                    state s1 {a b} {
                        puts $a $b
                    }
                    transition s1 - e1 -> s2
    
                    state s2 {} {
                        puts "in s2"
                            set ::done 1
                    }
                    transition s2 - e1 -> s1
                }
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        ::foo::R1 create Name Shoes
        ::foo::R1 signal {Name Shoes} e1
        set timer [after 1000 set ::done TIMEOUT]
        vwait ::done
        after cancel $timer
        set ::done
    } -result {1}
    test populate-1.0 {
        Populate a domain
    } -setup {
        rosea configure {
            domain meta {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::meta
    } -body {
        rosea populate {
            domain meta {
                class C1\
                    {Id     A1} {
                    foo     24
                    bar     42
                }
                class C2\
                    {Id     C1Id} {
                    f1      24
                    f2      24
                }
            }
        }
        relation cardinality $::meta::C1
    } -result {2}
    test populate-1.1 {
        Populate a domain -- alternate syntax
    } -setup {
        rosea configure {
            domain meta {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::meta
    } -body {
        rosea populate {
            domain meta {
                class C1\
                    {Id     A1}\
                    foo     24\
                    bar     42
                class C2\
                    {Id     C1Id}\
                    f1      24\
                    f2      24
            }
        }
        relation cardinality $::meta::C2
    } -result {2}
    test populate-1.2 {
        Populate a domain using default value syntax
    } -setup {
        rosea configure {
            domain meta {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int -default 20
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::meta
    } -body {
        rosea populate {
            domain meta {
                class C1\
                    {Id     A1} {
                    foo     24
                    bar     -
                }
                class C2\
                    {Id     C1Id} {
                    f1      24
                    f2      24
                }
            }
        }
        set ref [::meta::C1 findWhere {$A1 == 20}]
        ::rosea::InstCmds::readAttribute $ref Id
    } -result {bar}
    test populate-1.3 {
        Populate a domain with initial states
    } -setup {
        rosea configure {
            domain meta {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
    
                    statemodel {
                        state s1 {} {
                            puts "in s1"
                        }
                        transition s1 - e1 -> s1
                    }
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea generate * [namespace current]
    } -cleanup {
        cleanupConfigData
        removeDomain [namespace current]::meta
    } -body {
        rosea populate {
            domain meta {
                class C1\
                    {Id     A1} {
                    foo     24
                    bar     42
                }
                class C2\
                    {Id     C1Id} {
                    f1      24
                    f2      24
                }
            }
        }
        relation cardinality [relvar set [namespace current]::meta::C2__STATEINST]
    } -result {2}
    test populate-2.0 {
        populate a multi assigner
    } -setup {
        rosea configure {
            domain foo {
                class Customer {
                    attribute Name string -id 1
                }
                class Clerk {
                    attribute Name string -id 1
                    attribute Customer string
                    attribute Department string
                    reference R1 Customer -link {Customer Name}
                    reference R2 Department -link {Department Name}
                }
                class Department {
                    attribute Name string -id 1
                }
                association R1 Clerk 0..1--0..1 Customer
                association R2 Clerk 1..*--1 Department
                assigner R1 {
                    identifyby Department
                    state s1 {a b} {
                        puts $a $b
                    }
                    transition s1 - e1 -> s2
    
                    state s2 {} {
                        puts "in s2"
                            set ::done 1
                    }
                    transition s2 - e1 -> s1
                }
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
    } -body {
        rosea populate {
            domain foo {
                assigner R1 Name Shoes
                assigner R1 Name Clothes
            }
        }
        ::foo::R1 signal {Name Shoes} e1
        set timer [after 1000 set ::done TIMEOUT]
        vwait ::done
        after cancel $timer
        set ::done
    } -result {1}
    test save-1.0 {
        Serialize a domain
    } -setup {
        rosea configure {
            domain serial {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea generate
        rosea populate {
            domain serial {
                class C1\
                    {Id     A1} {
                    foo     24
                    bar     42
                }
                class C2\
                    {Id     C1Id} {
                    f1      bar
                    f2      foo
                }
            }
        }
    } -cleanup {
        cleanupConfigData
        removeDomain ::serial
        removeDomain ::sertest
        file delete serial.ral
    } -body {
        set asynccmd [lambda@ [namespace current] {domain file} {
            syncToTest
        }]
        rosea save -async $asynccmd ::serial serial.ral
        waitForSync
    
        ral deserializeFromFile serial.ral ::sertest
        ral relation cardinality [ral relvar set ::sertest::C1]
    } -result {2}
    test save-2.0 {
        Serialize a domain using SQLite
    } -setup {
        rosea configure {
            domain serial {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea generate
        rosea populate {
            domain serial {
                class C1\
                    {Id     A1} {
                    foo     24
                    bar     42
                }
                class C2\
                    {Id     C1Id} {
                    f1      foo
                    f2      {}
                }
            }
        }
    } -cleanup {
        cleanupConfigData
        removeDomain ::serial
        removeDomain ::sertest
        file delete serial.sqlite
    } -body {
        set asynccmd [lambda@ [namespace current] {domain file} {
            syncToTest
        }]
        rosea save -sqlite -async $asynccmd ::serial serial.sqlite
        waitForSync
    
        ral loadFromSQLite serial.sqlite ::sertest
        ral relation cardinality [ral relvar set ::sertest::C1]
    } -result {2}
    test restore-1.0 {
        Restore a domain
    } -setup {
        set testdomain {
            domain serial {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                    attribute A2 int -system 100
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea configure $testdomain
        rosea generate
        rosea populate {
            domain serial {
                class C1\
                    {Id     A1} {
                    foo     24
                    bar     42
                }
                class C2\
                    {Id     C1Id} {
                    f1      bar
                    f2      foo
                }
            }
        }
    
        set asynccmd [lambda@ [namespace current] {domain file} {
            syncToTest
        }]
        rosea save -async $asynccmd serial serial.ral
        waitForSync
    
        cleanupConfigData
        removeDomain ::serial
    } -cleanup {
        cleanupConfigData
        removeDomain ::serial
        file delete serial.ral
    } -body {
        rosea configure $testdomain
        rosea generate
        rosea restore serial serial.ral
        ::serial::C1 create Id baz A1 55
        set c1ref [::serial::C1 findAll]
        relation list [rosea tunnel $c1ref deRef A2] A2
    } -result {100 101 102}
    test restore-2.0 {
        Restore a domain from SQLite
    } -setup {
        set testdomain {
            domain serial {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
            }
        }
        rosea configure $testdomain
        rosea generate
        rosea populate {
            domain serial {
                class C1\
                    {Id     A1} {
                    foo     24
                    bar     42
                }
                class C2\
                    {Id     C1Id} {
                    f1      bar
                    f2      foo
                }
            }
        }
    
        set asynccmd [lambda@ [namespace current] {domain file} {
            syncToTest
        }]
        rosea save -sqlite -async $asynccmd serial serial.sqlite
        waitForSync
    
        cleanupConfigData
        removeDomain ::serial
    } -cleanup {
        cleanupConfigData
        removeDomain ::serial
        file delete serial.sqlite
    } -body {
        rosea configure $testdomain
        rosea generate
        rosea restore -sqlite serial serial.sqlite
        set c2ref [::serial::C2 findAll]
        relation list [rosea tunnel $c2ref deRef Id]
    } -result {f1 f2}
    test info-1.0 {
        find domain classes
    } -setup {
        set testdomain {
            domain infotest {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                    attribute A2 int -system 100
                }
    
                class C2 {
                    attribute Id string -id 1
                    attribute C1Id string
                    reference R1 C1 -link {C1Id Id}
                }
                association R1 C2 0..*--0..1 C1
    
                operation op1 {a b} {
                    puts "info test operation 1: $a $b"
                }
    
                operation op2 {a b} {
                    puts "info test operation 2: $a $b"
                }
            }
        }
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        rosea info domain classes infotest
    } -result {C1 C2}
    test info-1.1 {
        find domain relationships
    } -setup {
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        rosea info domain relationships infotest
    } -result {R1}
    test info-1.2 {
        find domain operations
    } -setup {
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        set ops [rosea info domain operations infotest]
        list [lindex $ops 0] [lindex $ops 3]
    } -result {op1 op2}
    test info-1.3 {
        bad domain info request
    } -setup {
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        rosea info domain foo infotest
    } -result {unknown info request, "foo"} -returnCodes error
    test info-2.0 {
        find class attributes
    } -setup {
        set testdomain {
            domain infotest {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                    attribute A2 int -system 100
    
                    classop op1 {a b} {
                        puts "info test operation 1: $a $b"
                    }
    
                    instop op2 {a b} {
                        puts "info test operation 2: $a $b"
                    }
                }
            }
        }
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        rosea info class attributes infotest C1
    } -result {Id string A1 int A2 int}
    test info-2.1 {
        find class operations
    } -setup {
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        lindex [rosea info class classops infotest C1] 0
    } -result {op1}
    test info-2.2 {
        find instance operations
    } -setup {
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        lindex [rosea info class instops infotest C1] 0
    } -result {op2}
    test info-3.0 {
        find state model states
    } -setup {
        set testdomain {
            domain infotest {
                class C1 {
                    attribute Id string -id 1
                    attribute A1 int
                    attribute A2 int -system 100
    
                    classop op1 {a b} {
                        puts "info test operation 1: $a $b"
                    }
    
                    instop op2 {a b} {
                        puts "info test operation 2: $a $b"
                    }
    
                    statemodel {
                        state s1 {a} {
                            puts $a
                        }
                        transition s1 - e1 -> s2
    
                        state s2 {b c} {
                            puts "$b $c"
                        }
                        transition s2 - e1 -> s1
                        transition s2 - e2 -> s3
    
                        state s3 {} {
                            puts "in s3"
                        }
                        transition s3 - e2 -> s1
                    }
                }
            }
        }
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        set sinfo [rosea info statemodel states infotest C1]
        lsort [list [lindex $sinfo 0] [lindex $sinfo 3] [lindex $sinfo 6]]
    } -result {s1 s2 s3}
    test info-3.1 {
        find state model events
    } -setup {
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        lsort [rosea info statemodel events infotest C1]
    } -result {e1 e2}
    test info-3.2 {
        find state model transitions
    } -setup {
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        set trans [rosea info statemodel transitions infotest C1]
        dict get $trans s1 e1
    } -result {s2}
    test info-3.3 {
        find state activity procedure name
    } -setup {
        rosea configure $testdomain
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::infotest
    } -body {
        rosea info statemodel activityproc infotest C1 s1
    } -result {::infotest::C1::__Activity::s1}
    test LogTrace-1.0 {
        log trace data
    } -setup {
        rosea configure {
            domain foo {
                class c1 {
                    attribute Id int -id 1
                    attribute Count int -default 0
                    attribute Max int -default 2
                    statemodel {
                        state s1 {} {
                            updateAttribute $self Count\
                                [expr {[readAttribute $self Count] + 1}]
                            #puts [relformat [deRef $self] self]
                            lassign [readAttribute $self Count Max] count max
                            if {$count >= $max} {
                                ::rosea::test::syncToTest $count
                            }
                        }
                        transition s1 - e1 -> s2
    
                        state s2 {} {
                            updateAttribute $self Count\
                                [expr {[readAttribute $self Count] + 1}]
                            signal $self e2
                        }
                        transition s2 - e2 -> s1
                    }
                }
            }
        }
        rosea generate
        turnOnTraceLog
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
        turnOffTraceLog
    } -body {
        set ref [::foo::c1 create Id 1]
        ::rosea::InstCmds::signal $ref e1
        waitForSync
    } -result {2}
    test LogTrace-2.0 {
        log trace data for a polymorphic event
    } -setup {
        rosea configure {
            domain foo {
                class lt2 {
                    attribute Id int -id 1
    
                    polymorphic *e1 *e2
                }
                generalization R1 lt2 lt2-sub1 lt2-sub2
    
                class lt2-sub1 {
                    attribute Id int -id 1
                    reference R1 lt2 -link Id
    
                    statemodel {
                        state sub1-s1 {} {
                            ::rosea::test::syncToTest true
                        }
                        transition sub1-s1 - *e1 -> sub1-s2
    
                        state sub1-s2 {} {
                            delaysignal 50 $self *e2
                        }
                        transition sub1-s2 - *e2 -> sub1-s1
                    }
                }
    
                class lt2-sub2 {
                    attribute Id int -id 1
                    reference R1 lt2 -link Id
    
                    statemodel {
                        state sub1-s1 {} {
                            ::rosea::test::syncToTest true
                        }
                        transition sub1-s1 - *e1 -> sub1-s2
    
                        state sub1-s2 {} {
                            delaysignal 50 $self *e2
                        }
                        transition sub1-s2 - *e2 -> sub1-s1
                    }
                }
            }
        }
    
        rosea generate
    
        rosea populate {
            domain foo {
                class lt2 Id 1
                class lt2-sub1 Id 1
            }
        }
    
        turnOnTraceLog
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
        turnOffTraceLog
    } -body {
        set superref [::foo::lt2 findWhere {$Id == 1}]
        ::rosea::InstCmds::signal $superref *e1
        waitForSync
    } -result {true}
    test LogTrace-3.0 {
        log trace data for a creation event
    } -setup {
        rosea configure {
            domain foo {
                class lt3 {
                    attribute Id int -id 1
                    statemodel {
                        transition @ - e1 -> s1
    
                        state s1 {value} {
                            ::rosea::test::syncToTest $value
                        }
                    }
                }
            }
        }
    
        rosea generate
    
        turnOnTraceLog
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
        turnOffTraceLog
    } -body {
        ::foo::lt3 createasync e1 10 Id 1
        waitForSync
    } -result {10}
    test DecodeAllTraces-1.0 {
        display trace data
    } -setup {
        rosea configure {
            domain foo {
                class c1 {
                    attribute Id int -id 1
                    attribute Count int -default 0
                    attribute Max int -default 2
                    statemodel {
                        state s1 {} {
                            updateAttribute $self Count\
                                [expr {[readAttribute $self Count] + 1}]
                            lassign [readAttribute $self Count Max] count max
                            if {$count >= $max} {
                                ::rosea::test::syncToTest $count
                            }
                        }
                        transition s1 - e1 -> s2
    
                        state s2 {} {
                            updateAttribute $self Count\
                                [expr {[readAttribute $self Count] + 1}]
                        }
                        transition s2 - e2 -> s1
                    }
                }
            }
        }
        rosea generate
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
        ::rosea trace control off
        ::rosea trace control clear
    } -body {
        ::rosea trace control on
        set ref [::foo::c1 create Id 1]
        ::rosea::InstCmds::signal $ref e1
        ::rosea::InstCmds::signal $ref e2
        waitForSync
        set traces [::rosea::Trace::DecodeAllTraces]
        dict get [lindex $traces 0] event
    } -result {e1}
    test DecodeClassTraces-1.0 {
        display trace data for specific class
    } -setup {
        rosea configure {
            domain foo {
                class dct1 {
                    attribute Id string -id 1
                    attribute Power int -default 20
                    reference R1 dct2 -link Id
                    statemodel {
                        state Off {} {
                            signal [findRelated $self R1] Lower
                        }
                        transition Off - TurnOn -> On
    
                        state On {power} {
                            updateAttribute $self Power $power
                            signal [findRelated $self R1] Raise
                        }
                        transition On - TurnOff -> Off
                    }
                }
    
                association R1 dct1 1--1 dct2
    
                class dct2 {
                    attribute Id string -id 1
                    statemodel {
                        state Down {} {
                            ::rosea::test::syncToTest\
                                [readAttribute [findRelated $self ~R1] Power]
                        }
                        transition Down - Raise -> Up
    
                        state Up {} {
                            delaysignal 50 [findRelated $self ~R1] TurnOff
                        }
                        transition Up - Lower -> Down
                    }
                }
            }
        }
    
        rosea generate
    
        rosea populate {
            domain foo {
                class dct1 Id first
                class dct2 Id first
            }
        }
    
        rosea trace control clear
        rosea trace control on
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
        rosea trace control off
        rosea trace control clear
    } -body {
        ::rosea::InstCmds::signal [::foo::dct1 findWhere {$Id eq "first"}] TurnOn 30
        waitForSync
        # puts [::rosea trace format [::rosea trace decode all]]
        set traces [::rosea::Trace::DecodeClassTraces ::foo::dct2]
        expr {[llength $traces] == 2 &&\
                [dict get [lindex $traces 1] event] eq "Lower"}
    } -result {1}
    test DecodeTargetTraces-1.0 {
        display trace data for specific instances
    } -setup {
        rosea configure {
            domain foo {
                class c1 {
                    attribute Id string -id 1
                    statemodel {
                        state S1 {} {
                        }
                        transition S1 - E1 -> S1
                        transition S1 - E2 -> S2
    
                        state S2 {} {
                            ::rosea::test::syncToTest S2
                        }
                    }
                }
            }
        }
    
        rosea generate
    
        rosea populate {
            domain foo {
                class c1 Id first
                class c1 Id second
                class c1 Id third
            }
        }
    
        rosea trace control clear
        rosea trace control on
    } -cleanup {
        cleanupConfigData
        removeDomain ::foo
        rosea trace control off
        rosea trace control clear
    } -body {
        set i1 [foo::c1 findById Id first]
        set i2 [foo::c1 findById Id second]
        set i3 [foo::c1 findById Id third]
        rosea tunnel $i1 signal E1
        rosea tunnel $i2 signal E1
        rosea tunnel $i3 signal E1
        rosea tunnel $i1 signal E1
        rosea tunnel $i1 signal E1
    
        rosea tunnel $i1 signal E2
        rosea tunnel $i2 signal E2
        rosea tunnel $i3 signal E2
    
        waitForSync
        set traces [::rosea::Trace::DecodeTargetTraces $i1 $i2]
        #puts [rosea::formatTraces $traces]
        llength $traces
    } -result {6}
    test formatTraces-1.0 {
        display human readable trace data
    } -setup {
        rosea configure {
            domain foo {
                class c1 {
                    attribute Id int -id 1
                    attribute Count int -default 0
                    attribute Max int -default 2
                    statemodel {
                        state s1 {} {
                            updateAttribute $self Count\
                                [expr {[readAttribute $self Count] + 1}]
                            lassign [readAttribute $self Count Max] count max
                            if {$count >= $max} {
                                ::rosea::test::syncToTest $count
                            }
                        }
                        transition s1 - e1 -> s2
    
                        state s2 {} {
                            updateAttribute $self Count\
                                [expr {[readAttribute $self Count] + 1}]
                        }
                        transition s2 - e2 -> s1
                    }
                }
            }
        }
        rosea generate
    } -cleanup {
        rosea trace control off
        rosea trace control clear
    } -body {
        rosea trace control on
        set one [::foo::c1 create Id 1]
        ::rosea::InstCmds::signal $one e1
        ::rosea::InstCmds::signal $one e2
        waitForSync
        set traces [rosea trace format [rosea trace decode all]]
        # puts $traces
        llength [split $traces \n]
    } -result {2}

    cleanupTests
}
