// vim:syntax=asciidoc:
= stsatcl - An Software Architecture for Tcl

== Introduction

By analogy to STSA,
which is a software architecture for micro-controller
based implementations that are coded in ``C'',
the *stsatcl* package is a software architecture for Tcl based
application.

This package follows the common convention of defining a small
domain specific language (DSL) that is used in the constructing
of objects to configure the object.
In this case we are constructing classes that have STSA
qualities, namely:

* Definition of attributes.
* Definition of relationships.
* Definition of state models.

The concepts here are similar to those used by +pycca+.
Specifically we are defining implementation aspects and the
package is expected to be used as the target for translating
XUML models into Tcl.

There are, of course, many differences in the way a ``C'' base
architecture and a Tcl based on will handle the implementation
aspects.
For example,
STSA uses pointers to traverse relationships.
There are no such things in Tcl.
However,
command names of TclOO objects can be used to serve the same purpose.
In STSA, ``C'' data types must be given for attributes.
In the Tcl world, everything is a string and Tcl variables can hold
data of any type.
Therefore type annotation is not necessary.
State models in Tcl have already been done in many ways.
Here we will follow the pattern of the *oomoore* package and
indeed pull large amounts of its code over.

["ditaa",options="no-shadows",title="STSA Tcl Block Diagram"]
-----------------------------------------------------------------------------
+---------------+                                             
|  STSA Class   |                                             
|  o meta-class |
+-------+-------+                                             
        |                                                       
        | create               +-----------------+
        V                +-----| Reference Class |              
+-------+-------+  mixin |     +-----------------+
|  XUML Class   |<-------+
+-------+-------+        |     +-------------------+
        |                +-----| State Model Class |
        | create/new           +-------------------+
        V
+-------+-------+                                             
|  XMUL Object  |
+-------+-------+                                             
-----------------------------------------------------------------------------

== STSA Class

(((class,STSA Class)))

The *stsatcl* package contains the +STSAClass+ class.
+STSAClass+ is actually a meta-class, _i.e._ it is a class
for defining other classes.

[source,tcl]
----
<<stsatcl commands>>=
::oo::class create ::stsatcl::STSAClass {
    superclass ::oo::class
    unexport new                ; # <1>
    <<stsaclass configuration>>
}
----
<1> We insist that new STSA classes are named.

The idea is for the constructor of the +STSAClass+ to take a script
that consists of configuration commands.
Those commands will validate and store away the information.
Using the configuation information,
a new class is created with the requested properties.
Objects created from the class then have all the characteristics specified
in the configuration script.

The constructor of +STSAClass+ takes a configuration script
that contains commands from our mini-DSL.
The result is a class, from which objects may be created,
that have the characteristics as defined by the configuration.

(((method,STSAClass,constructor)))

[source,tcl]
----
<<stsaclass configuration>>=
constructor {config} {
    <<stsaclass constructor>>
}
----

=== Configuration DSL

The configuration language is really just a series of commands
that are implemented as methods of the class.
The +oo::util+ package provides the +link+ command to make
the DSL definitions easier.

[source,tcl]
----
<<stsaclass constructor>>=
link\
    {attribute Attribute}\
    {reference Reference}\
    {partition Partition}\
    {polymorphic Polymorphic}\
    {statemodel Statemodel}
----

=== DSL Implementation Methods

We will first consider the commands that form our mini-DSL
that is used to configure an +STSAClass+.
First we consider the data, namely attributes and relationships.
Next we will deal with the more complicated issue of state models.

==== Attribute Method

(((method,STSAClass,Attribute)))

[source,tcl]
----
<<stsaclass constructor>>=
my variable attrInfo
set attrInfo [list]

<<stsaclass configuration>>=
method Attribute {args} {
    my variable attrInfo

    foreach attr $args {
        if {$attr ni $attrInfo} {
            lappend attrInfo $attr
        }
    }
}
----

==== Configurating references

The defintions are for the decomposed *paths* of relationships,
so we expect definitions to appear in both of the participating
classes.
Since we are defining the decomposed paths,
we need only specify whether the relationship is +singular+ or +multiple+.

The command that implements the mini-language is straight forward.
Singular relationship linkage is held in a simple variable that contains
a object command.
We define a command to link, unlink and obtain the command implied by
the relationship.

(((method,STSAClass,Reference)))

[source,tcl]
----
<<stsaclass configuration>>=
method Reference {rname type dstclass} {
    my variable refinfo
    if {[info exists refinfo($rname)]} {
        error "linkage, \"$rname\", already exists"
    }
    if {![string match {::*} $dstclass]} {
        set dstclass [uplevel 3 namespace current]::$dstclass
    }

    if {![regexp -- {\A-(>{1,2})(c?)\Z} $type match mult cond]} {
        error "unknown reference type spec, \"$type\""
    }
    set mult [string equal $mult ">>"]
    set cond [string equal $cond "c"]

    set refinfo($rname) [dict create\
        type reference\
        dest $dstclass\
        mult $mult\
        cond $cond\
    ]
    my variable $rname
    set $rname {}
}
----

[source,tcl]
----
<<stsaclass configuration>>=
method Partition {rname args} {
    my variable refinfo
    if {[info exists refinfo($rname)]} {
        error "linkage, \"$rname\", already exists
    }
    if {[llength $args] < 2} {
        error "partition, \"$rname\", must have at least two subclasses"
    }

    set subs [list]
    foreach sub $args {
        if {![string match {::*} $sub]} {
            set sub [uplevel 3 namespace current]::$sub
        }
        lappend subs $sub
    }
    set refinfo($rname) [dict create\
        type partition\
        subclasses $subs\
    ]
}
----


[source,tcl]
----
<<required packages>>=
package require oo::util
----

[source,tcl]
----
<<stsaclass configuration>>=
constructor {body} {
    my variable refinfo
    array set refinfo {}

    link\
        {reference Reference}\
        {partition Partition}

    my eval [uplevel 1 [list ::subst $body]]
}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-1.0 {
    define simple reference
} -setup {
} -cleanup {
    test1 destroy
} -body {
    stsatcl STSAClass create test1 {
        reference R1 -> foo
    }
    return [set [info object namespace test1]::refinfo(R1)]
} -result {type reference dest ::stsatcl::test::foo mult 0 cond 0}

test constructor-2.0 {
    define reference with bad syntax
} -setup {
} -cleanup {
} -body {
    stsatcl STSAClass create test2 {
        reference R1 ->>x foo
    }
} -result {unknown reference type spec, "->>x"} -returnCodes error

test constructor-3.0 {
    reference method
} -setup {
} -cleanup {
    test3 destroy
} -body {
    stsatcl STSAClass create test3 {
        reference R1 ->c foo
    }
    return [test3 -> R1]
} -result {}

test constructor-4.0 {
    define partition
} -setup {
    oo::class create super {
        superclass ::stsatcl::STSAClass

        constructor {} {
            next {
                partition R1 sub1 sub2
            }
        }
    }

    oo::class create sub1 {
        superclass ::stsatcl::STSAClass

        constructor {} {
            next {
                reference R1 -> super
            }
        }
    }

    oo::class create sub2 {
        superclass ::stsatcl::STSAClass

        constructor {} {
            next {
                reference R1 -> super
                reference R2 -> ::stsatcl::STSAClass
            }
        }
    }
} -cleanup {
    sup1 destroy
} -body {
    super create sup1
    return [set [info object namespace sup1]::refinfo(R1)]
} -result {type partition subclasses {::stsatcl::test::sub1 ::stsatcl::test::sub2}}
----

[source,tcl]
----
<<stsaclass configuration>>=
method CheckRelName {rname} {
    my variable refinfo
    if {![info exists refinfo($rname)]} {
        error "unknown linkage, \"$rname\""
    }
}

method CheckReferenceObj {rname obj} {
    my variable refinfo

    set objclass [info object class $obj]
    switch -exact -- [dict get $refinfo($rname) type] {
        reference {
            set destclass [dict get $refinfo($rname) dest]
            if {!($objclass eq $destclass ||\
                    $destclass in [info class superclasses $objclass])} {
                error "instance, \"$obj\", is not an instance of class,\
                        \"[dict get $refinfo($rname) dest]\""
            }
        }
        partition {
            set subclasses [dict get $refinfo($rname) subclasses]
            foreach subclass $subclasses {
                if {$objclass eq $subclass ||\
                    $subclass in [info class superclasses $objclass]} {
                    return
                }
            }
            error "instance, \"$obj\", is not an instance of any class,\
                    \"[join $subclasses {, }]\""
        }
        default {
            error "unknown linkage type, \"[dict get $refinfo($rname) type]\""
        }
    }
}

method ResolveObj {obj} {
    if {![string match {::*} $obj]} {
        set obj [uplevel 2 namespace current]::$obj
    }
    return $obj
}
----

(((method,STSAClass,link)))

[source,tcl]
----
<<stsaclass configuration>>=
method link {rname obj} {
    set obj [my ResolveObj $obj]
    my variable refinfo
    my CheckRelName $rname
    my CheckReferenceObj $rname $obj

    my variable $rname
    switch -exact -- [dict get $refinfo($rname) type] {
        reference {
            if {[dict get $refinfo($rname) mult]} {
                if {$obj ni [set $rname]} {
                    lappend $rname $obj
                }
            } else {
                set $rname $obj
            }
        }
        partition {
            set $rname $obj
        }
        default {
            error "unknown linkage type, \"[dict get $refinfo($rname) type]\""
        }
    }
    return $obj
}
----

[source,tcl]
----
<<exported tests>>=
test link-1.0 {
    link across singular reference
} -setup {
    stsatcl STSAClass create lt1 {
        reference R1 -> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create lt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    lt1 destroy
    lt2 destroy
} -body {
    lt1 link R1 lt2
} -result {::stsatcl::test::lt2}

test link-2.0 {
    link across multiple reference
} -setup {
    stsatcl STSAClass create lt1 {
        reference R1 ->> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create lt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create lt3 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    lt1 destroy
    lt2 destroy
    lt3 destroy
} -body {
    lt1 link R1 lt2
    lt1 link R1 lt3
    llength [set [info object namespace lt1]::R1]
} -result {2}

test link-3.0 {
    link across partition
} -setup {
    super create sup1
    sub1 create s1
} -cleanup {
    sup1 destroy
    s1 destroy
} -body {
    sup1 link R1 s1
} -result {::stsatcl::test::s1}
----

(((method,STSAClass,unlink)))

[source,tcl]
----
<<stsaclass configuration>>=
method unlink {rname obj} {
    set obj [my ResolveObj $obj]
    my variable refinfo
    my CheckRelName $rname
    my CheckReferenceObj $rname $obj

    my variable $rname
    switch -exact -- [dict get $refinfo($rname) type] {
        reference {
            if {[dict get $refinfo($rname) mult]} {
                set at [lsearch [set $rname] $obj]
                if {$at != -1} {
                    set $rname [lreplace [set $rname] $at $at]
                }
            } else {
                if {$obj eq [set $rname]} {
                    set $rname {}
                } else {
                    error "\"$obj\" is not linked to \"$rname\",\
                            \"[set $rname]\" is"
                }
            }
        }
        partition {
            if {$obj eq [set $rname]} {
                set $rname {}
            } else {
                error "\"$obj\" is not linked to \"$rname\",\
                        \"[set $rname]\" is"
            }
        }
        default {
            error "unknown linkage type, \"[dict get $refinfo($rname) type]\""
        }
    }

    return
}
----

[source,tcl]
----
<<exported tests>>=
test unlink-1.0 {
    unlink across singular reference
} -setup {
    stsatcl STSAClass create lt1 {
        reference R1 ->c ::stsatcl::STSAClass
    }
    stsatcl STSAClass create lt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    lt1 destroy
    lt2 destroy
} -body {
    lt1 link R1 lt2
    lt1 unlink R1 lt2
    lt1 -> R1
} -result {}

test unlink-2.0 {
    unlink across multiple reference
} -setup {
    stsatcl STSAClass create lt1 {
        reference R1 ->> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create lt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create lt3 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    lt1 destroy
    lt2 destroy
    lt3 destroy
} -body {
    lt1 link R1 lt2
    lt1 link R1 lt3
    lt1 unlink R1 lt2
    lt1 -> R1
} -result {::stsatcl::test::lt3}

test unlink-3.0 {
    unlink across partition
} -setup {
    super create sup1
    sub1 create s1
} -cleanup {
    sup1 destroy
    s1 destroy
} -body {
    sup1 link R1 s1
    sup1 unlink R1 s1
} -result {}
----

[source,tcl]
----
<<required packages>>=
package require struct::set
----

(((method,STSAClass,->)))

[source,tcl]
----
<<stsaclass configuration>>=
method -> {rname args} {
    my variable refinfo
    my CheckRelName $rname

    my variable $rname
    set relobjs [set $rname]

    switch -exact -- [dict get $refinfo($rname) type] {
        reference {
            if {![dict get $refinfo($rname) cond] && [llength $relobjs] == 0} {
                error "reference, \"$rname\", is unconditional, yet no\
                        instances were found"
            }
        }
        partition {
            if {$relobjs eq {}} {
                error "superclass partition, \"$rname\", is unconditional,\
                        yet no instances were found"
            }
            if {[llength $args] < 1} {
                error "partition navigation from supertype to subtype\
                        requires the destination subtype class"
            }

            set subclass [lindex $args 0]
            set args [lrange $args 1 end]

            set subclass [my ResolveObj $subclass]
            if {[llength [info class instances $subclass $relobjs]] == 0} {
                set relobjs [list]
            }
        }
        default {
            error "unknown linkage type, \"[dict get $refinfo($rname) type]\""
        }
    }

    if {[llength $args] != 0} {
        set related [list]
        foreach robj $relobjs {
            ::struct::set add related [$robj -> {*}$args]
        }
    } else {
        set related $relobjs
    }

    return [expr {[llength $related] < 2 ? [lindex $related 0] : $related}]
}
export ->
----

[source,tcl]
----
<<exported tests>>=
test reference-1.0 {
    traverse a singular relationship
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 link R1 rt2
    rt1 -> R1
} -result {::stsatcl::test::rt2}

test reference-1.1 {
    traverse many singular relationships
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 link R1 rt2
    rt2 link R1 rt1
    rt1 -> R1 R1
} -result {::stsatcl::test::rt1}

test reference-1.2 {
    traverse many singular relationships -- violate conditionality
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 link R1 rt2
    rt1 -> R1 R1
} -result {reference, "R1", is unconditional, yet no instances were found}\
  -returnCodes error

test reference-2.0 {
    traverse a multiple relationship
} -setup {
    stsatcl STSAClass create rt1 {
        reference R2 ->> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create rt3 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
    rt3 destroy
} -body {
    rt1 link R2 rt2
    rt1 link R2 rt3
    rt1 -> R2
} -result {::stsatcl::test::rt2 ::stsatcl::test::rt3}

test reference-2.1 {
    traverse a multiple relationship, then a singular
} -setup {
    stsatcl STSAClass create rt1 {
        reference R2 ->> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> ::stsatcl::STSAClass
    }
    stsatcl STSAClass create rt3 {
        reference R1 -> ::stsatcl::STSAClass
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
    rt3 destroy
} -body {
    rt1 link R2 rt2
    rt2 link R1 rt1

    rt1 link R2 rt3
    rt3 link R1 rt1
    rt1 -> R2 R1
} -result {::stsatcl::test::rt1}

test reference-3.0 {
    traverse across partition
} -setup {
    super create sup1
    sub1 create s1
} -cleanup {
    sup1 destroy
    s1 destroy
} -body {
    sup1 link R1 s1
    sup1 -> R1 sub1
} -result {::stsatcl::test::s1}

test reference-3.1 {
    traverse across partition and single reference
} -setup {
    super create sup1
    sub2 create s2
    stsatcl::STSAClass create b1 {}
} -cleanup {
    sup1 destroy
    s2 destroy
    b1 destroy
} -body {
    sup1 link R1 s2
    s2 link R1 sup1
    s2 link R2 b1
    sup1 -> R1 sub2 R2
} -result {::stsatcl::test::b1}

test reference-3.2 {
    traverse across partition and single reference -- empty
} -setup {
    super create sup1
    sub1 create s1
} -cleanup {
    sup1 destroy
    s1 destroy
} -body {
    sup1 link R1 s1
    s1 link R1 sup1
    sup1 -> R1 sub2 R2
} -result {}
----

Note that the lamda function is evaluated in the namespace of the object.

[source,tcl]
----
<<stsatcl utilities>>=
proc ::stsatcl::Filter {instances params body args} {
    if {[llength $args] != [llength $params] - 1} {
        error "you must supply one less argument than there are parameters,\
            got [llength $args] arguments,\
            expected [expr {[llength $params] - 1}]"
    }
    set selected [list]
    foreach instance $instances {
        # Set up a lamda function to be run in the namespace of the
        # object.
        set lambda [list $params $body [info object namespace $instance]]
        if {[::apply $lambda {*}$args $instance]} {
            ::struct::set include selected $instance
        }
    }
    return [expr {[llength $selected] < 2 ?\
            [lindex $selected 0] : $selected}]
}

proc ::stsatcl::Map {instances params body args} {
    if {[llength $args] != [llength $params] - 1} {
        error "you must supply one less argument than there are parameters,\
            got [llength $args] arguments,\
            expected [expr {[llength $params] - 1}]"
    }
    set result [list]
    foreach instance $instances {
        # Same logic as for Filter
        set lambda [list $params $body [info object namespace $instance]]
        lappend result [::apply $lambda {*}$args $instance]
    }
    return $result
}

proc ::stsatcl::Apply {instances params body args} {
    if {[llength $args] != [llength $params] - 1} {
        error "you must supply one less argument than there are parameters,\
            got [llength $args] arguments,\
            expected [expr {[llength $params] - 1}]"
    }
    foreach instance $instances {
        # Same logic as for Filter
        set lambda [list $params $body [info object namespace $instance]]
        ::apply $lambda {*}$args $instance
    }
    return
}
----

It is useful to be able to do *blind* selection of instances
from a class,
so we defined some methods attached to the class itself.

[source,tcl]
----
<<stsaclass configuration>>=
classmethod filterInstances {params body args} {
    tailcall ::stsatcl::Filter [info class instances [self]]\
            $params $body {*}$args
}
----

[source,tcl]
----
<<exported tests>>=
test filterInstances-1.0 {
    blind select instances
} -setup {
    ::oo::class create fiClass {
        superclass ::stsatcl::STSAClass

        constructor {v} {
            next {}
            my variable id
            set id $v
        }

        method getId {} {
            my variable id
            return $id
        }

        method info {} {
            my variable id
            puts "[self]: $id"
        }
    }
    fiClass create fi1 1
    fiClass create fi2 2
    fiClass create fi3 3
} -cleanup {
    fi1 destroy
    fi2 destroy
    fi3 destroy
} -body {
    fiClass filterInstances {value obj} {string equal [$obj getId] $value} 2
} -result {::stsatcl::test::fi2}

test filterInstances-1.1 {
    blind select instances using internal variables
} -setup {
    fiClass create fi1 1
    fiClass create fi2 2
    fiClass create fi3 3
} -cleanup {
    fi1 destroy
    fi2 destroy
    fi3 destroy
} -body {
    fiClass filterInstances {value obj} {
        my variable id
        expr {$id eq $value}
    } 2
} -result {::stsatcl::test::fi2}
----

[source,tcl]
----
<<stsaclass configuration>>=
classmethod mapInstances {params body args} {
    tailcall ::stsatcl::Map [info class instances [self]]\
        $params $body {*}$args
}
----

[source,tcl]
----
<<exported tests>>=
test mapInstances-1.0 {
    apply function to all instances
} -setup {
    fiClass create fi1 4
    fiClass create fi2 5
    fiClass create fi3 6
} -cleanup {
    fi1 destroy
    fi2 destroy
    fi3 destroy
} -body {
    fiClass mapInstances {obj} {$obj getId}
} -result {4 5 6}
----

[source,tcl]
----
<<stsaclass configuration>>=
classmethod forallInstances {params body args} {
    tailcall ::stsatcl::Apply [info class instances [self]]\
            $params $body {*}$args
}
----

[source,tcl]
----
<<exported tests>>=
test forallInstances-1.0 {
    apply function to all instances
} -setup {
    fiClass create fi1 4
    fiClass create fi2 5
    fiClass create fi3 6
} -cleanup {
    fi1 destroy
    fi2 destroy
    fi3 destroy
} -body {
    fiClass forallInstances {obj} {$obj info}
} -result {} -output "::stsatcl::test::fi1: 4\n::stsatcl::test::fi2: 5\n::stsatcl::test::fi3: 6\n"
----

There are some common operations needed for relationship navigation
and selection.
Again, the distinction between one and many means that in the former
case we return immediately when a match is found.

[source,tcl]
----
<<stsaclass configuration>>=
method filterRelatedInstances {traversal params body args} {
    tailcall ::stsatcl::Filter [my -> {*}$traversal] $params $body {*}$args
}
----

[source,tcl]
----
<<exported tests>>=
test filterRelated-1.0 {
    find a set of related instances
} -setup {
    ::oo::class create frClass {
        superclass ::stsatcl::STSAClass

        constructor {} {
            next {
                reference R1 ->> fiClass
            }
        }
    }
    fiClass create fi1 1
    fiClass create fi2 2
    fiClass create fi3 3
    frClass create fr1
    fr1 link R1 fi1
    fr1 link R1 fi2
} -cleanup {
    fi1 destroy
    fi2 destroy
    fi3 destroy
    fr1 destroy
} -body {
    fr1 filterRelatedInstances R1 {value obj} {
        expr {[$obj getId] <= $value}
    } 2
} -result {::stsatcl::test::fi1 ::stsatcl::test::fi2}
----

[source,tcl]
----
<<stsaclass configuration>>=
method mapRelatedInstances {traversal params body args} {
    tailcall ::stsatcl::Map [my -> {*}$traversal] $params $body {*}$args
}
----

[source,tcl]
----
<<exported tests>>=
test mapRelated-1.0 {
    apply a function to related instances
} -setup {
    fiClass create fi1 4
    fiClass create fi2 5
    fiClass create fi3 6
    frClass create fr1
    fr1 link R1 fi2
    fr1 link R1 fi3
} -cleanup {
    fi1 destroy
    fi2 destroy
    fi3 destroy
    fr1 destroy
} -body {
    fr1 mapRelatedInstances R1 {obj} {
        $obj getId
    }
} -result {5 6}
----

[source,tcl]
----
<<stsaclass configuration>>=
method forallRelatedInstances {traversal params body args} {
    tailcall ::stsatcl::Apply [my -> {*}$traversal] $params $body {*}$args
}
----

[source,tcl]
----
<<exported tests>>=
test forallRelatedInstances-1.0 {
    invoke a method on related instances
} -setup {
    fiClass create fi1 4
    fiClass create fi2 5
    fiClass create fi3 6
    frClass create fr1
    fr1 link R1 fi2
    fr1 link R1 fi3
} -cleanup {
    fi1 destroy
    fi2 destroy
    fi3 destroy
    fr1 destroy
} -body {
    fr1 forallRelatedInstances R1 {obj} {
        $obj info
    }
} -result {} -output "::stsatcl::test::fi2: 5\n::stsatcl::test::fi3: 6\n"
----

[source,tcl]
----
<<stsaclass configuration>>=
method readAttribute {attribute} {
    my variable $attribute
    return [set $attribute]
}
----

[source,tcl]
----
<<exported tests>>=
test readAttribute-1.0 {
    read attribute value
} -setup {
    fiClass create fi1 27
} -cleanup {
    fi1 destroy
} -body {
    fi1 readAttribute id
} -result {27}
----

[source,tcl]
----
<<stsaclass configuration>>=
method updateAttribute {attribute value} {
    my variable $attribute
    return [set $attribute $value]
}
----

[source,tcl]
----
<<exported tests>>=
test updateAttribute-1.0 {
    update attribute value
} -setup {
    fiClass create fi1 27
} -cleanup {
    fi1 destroy
} -body {
    fi1 updateAttribute id 33
    fi1 readAttribute id
} -result {33}
----

== Code Organization

=== Source Code

[source,tcl]
----
<<stsatcl.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# Copyright 2014, InCube Labs, LLC.
# All rights reserved.  This file contains unpublished work that is
# confidential and proprietary to InCube Labs.  This document may not, in
# whole or in part, be duplicated, disclosed or used for any purposes,
# whatsoever, without written permission from InCube Labs.
#

package require Tcl 8.6
package require logger

<<required packages>>

namespace eval ::stsatcl {
    namespace export STSAClass
    namespace ensemble create

    variable version 1.0
}

<<stsatcl utilities>>
<<stsatcl commands>>

package provide stsatcl $::stsatcl::version
----

=== Unit Tests

[source,tcl]
----
<<stsatcl.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# Copyright 2014, InCube Labs, LLC.
# All rights reserved.  This file contains unpublished work that is
# confidential and proprietary to InCube Labs.  This document may not, in
# whole or in part, be duplicated, disclosed or used for any purposes,
# whatsoever, without written permission from InCube Labs.
#

package require Tcl 8.6
package require cmdline
package require logger

source ../stsatcl.tcl
chan puts "testing stsatcl version: [package require stsatcl]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
    {port.arg {} {Target comm port}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

package require tcltest
eval tcltest::configure $argv

namespace eval ::stsatcl::test {
    ::logger::initNamespace [namespace current] $::options(level)

    namespace import ::tcltest::*

    <<test utility procs>>
    <<constructor tests>>
    <<unexported tests>>
    <<exported tests>>

    cleanupTests
}
----


////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded stsatcl 1.0 [list source [file join $dir stsatcl.tcl]]
----
