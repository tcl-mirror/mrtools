// vim:syntax=asciidoc:
= stsatcl - An Software Architecture for Tcl

== Introduction

By analogy to
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[STSA],
which is a software architecture for micro-controller
based implementations that are coded in ``C'',
the *stsatcl* package is a software architecture for Tcl based
applications.

The concepts here are similar to those used by +STSA+.
Specifically we are defining an implementation based scheme
that is to be used as the target for translating
XUML models into Tcl.

There are, of course, many differences in the way a ``C'' based
architecture and a Tcl based one will handle the implementation
aspects.
For example,
STSA uses pointers to traverse relationships.
There are no such things in Tcl.
However,
command names of TclOO objects can be used to serve the same purpose.
In STSA, ``C'' data types must be given for attributes.
In the Tcl world, everything is a string and Tcl variables can hold
data of any type.
Therefore type annotation is not necessary.
State models in Tcl have already been done in many ways.
Here, we will follow the pattern of the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools-cm3/[+oomoore+],
package and
indeed pull large amounts of its code over.

=== Design Concepts

The STSA Tcl package is based on TclOO.
The translation of XUML model classes to TclOO class is,
to a first approximation, one-to-one.
To support the XUML execution model,
we will create a meta-class called, +STSAClass+.
Instances of +STSAClass+ will correspond to the XUML classes
of the translation.
The constructor of +STSAClass+ will allow for the appropriate
configuration of the resulting XUML implemenation class.
Instances can then be created to populate the translation.
This is shown in the diagram below.

["ditaa",options="no-shadows",title="STSA Tcl Block Diagram"]
-----------------------------------------------------------------------------
+---------------+
|  STSA Class   |
|  o meta-class |
+-------+-------+
        |
        | create
        V
+-------+-------+
|  XUML Class   |
+-------+-------+
        |
        | create/new
        V
+-------+-------+
|  XMUL Object  |
+-------+-------+
-----------------------------------------------------------------------------

This package follows the common convention of defining a small
domain specific language (DSL) that is used in the construction
of objects to specify the required configuration.
In this case we are constructing classes that have STSA
qualities, namely:

* Definition of attributes.
* Definition of relationships.
* Definition of state models.
* Definition of processing.

=== Document Conventions

The source for this document conforms to
http://http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included here and
the build process extracts the source that is then given to the
Tcl interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the preferred choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates understanding the
program details and then _tangle_ the resulting source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk defintion ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
have become adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

We will actually include root chunks for the following items:

* Tcl source for the package.
* Test cases that run under +tcltest+.
* The +pkgIndex.tcl+ package index file.

Since we also include test cases in this document,
the usual order will be to show a *method* and follow it by
the tests that exercise the method.
From a development and maintenance point of view,
is is beneficial to keep the code and tests lexically near each other.
However, you may wish to skip over the testing to keep the narrative
flow more consistent.

In addition to the explanation and code for the +stsatcl+ package,
we will also include an example and endeavor to show how an XUML model
is translated into a Tcl implementation using this package.
The example will, of necessity, be small and somewhat contrived to
insure that all the features of the package are used.
The use of small, contrived examples is always unfortunate but
this document is large enough with just the package and its test cases
that any _real-world_ example would over burden the entire undertaking.
Realistic models and their translation easily become books in themselves.

== STSA Class

(((class,STSA Class)))

The *stsatcl* package contains the +STSAClass+ class.
+STSAClass+ is actually a meta-class, _i.e._ it is a class
for defining other classes.

[source,tcl]
----
<<stsatcl commands>>=
::oo::class create ::stsatcl::STSAClass {
    superclass ::oo::class      ; # <1>
    unexport new                ; # <2>
    <<stsaclass configuration>>
}
----
<1> Deriving from +::oo::class+ make us a meta-class.
<2> We insist that all STSA classes be named commands.

=== Constructor

The constructor of the +STSAClass+ takes a script
that consists of configuration commands.
Those commands will validate and store away the information.
Using the configuation information,
a new class is created with the properties described in the construction
configuration script.
Objects created from the class then have all the characteristics specified
in the configuration script.

(((method,STSAClass,constructor)))

[source,tcl]
----
<<stsaclass configuration>>=
constructor {config} {
    <<stsaclass constructor>>
}
----

=== Configuration DSL

The configuration language is really just a series of commands
that are implemented as methods of the class.
Technically,
the design is to use the +my eval+ command to evaluate the
configuration script in the context of the class being created.
The commands in the configuration script need to resolve correctly
in that context.
We would like _not_ to be forced to prefix the DSL commands with
the +my+ command as that clutters the expressiveness of the DSL.
The +oo::util+ package in +tcllib+ provides the +link+ command to make
the DSL command definitions easier.

[source,tcl]
----
<<required packages>>=
package require oo::util
# The mixin of "oo::class.Delegate", interacts badly with meta-classes that
# have constructor arguments. So we eliminate the oo::class mixins here. This
# will mean that you can't define class methods.
::oo::define oo::class self mixin
----

[source,tcl]
----
<<stsaclass constructor>>=
link\
    {attribute Attribute}\
    {reference Reference}\
    {partition Partition}\
    {classop ClassOp}\
    {instop InstOp}\
    {polymorphic Polymorphic}\
    {statemodel Statemodel}
----

So the +link+ command arranges, for example, that invoking +attribute+
in the namespace of the class being created actually
invokes the +Attribute+ method of the +STSAClass+ class.
The trickery to accomplish can be found in the source to the +oo::util+
package.
Here we follow the convention that the methods implementing
the DSL commands are unexported and the corresponding linked names
begin with lower case.

So there will be seven commands in the configuration DSL.
The +statemodel+ command will itself take another configuration
script to describe state and transition
and that will be described in a section of its own.
Each of the top level commands is described in a section below
and the method that implements the command is given.

The methods associated with the DSL follow the same general pattern.
They store the data given in the command arguments, possibly with some
validation, into data variable associated with the created class.
That data is then available to the class methods to implement
the semantics of XUML attribute access, relationship navigation
and state machine dispatch.
So it is very much a data-driven approach with the DSL commands
supplying the values of the data that determine the specific semantics
that are needed.

==== Attribute Method

The +attribute+ command is used to define the attributes of a XUML class.
It is invoked as:

(((DSL,command,attribute)))

.................
attribute attr-value-pair1 attr-value-pair2 ...
.................

+attr-value-pair ...+::
    Each +attr-value-pair+ argument is treated as a one or two element list.
    the first element gives the name of the attribute.
    If the second element of the pair is present,
    then it gives the default value for the attribute.
    If the second element is missing then the default value is the empty string.

The command may be invoked an arbitary number of times in the
configuration script.
When objects of the resulting class are created,
the attributes will be present and have their default values after
construction.
We will also see that the resulting constructor also allows us to
override the defaults at creation time.

Attribute names form a set and so duplicates are not allowed.
We also do not allow the empty string as an attribute name on
the rational that the empty string cannot convey any semantics.
Attempts to define the empty string as an attribute name or
to define a duplicate attribute name cause an error to be thrown.

Attribute names will be stored away in an array.
The index to the array will be the attribute name itself and
the value of the array element will be the default value of the attribute.

[source,tcl]
----
<<stsaclass constructor>>=
my variable attrInfo
array set attrInfo {}
----

The implementation of the +Attribute+ method consists of an
interation over the arguments, validating the attribute names
and assigning the default values into the +attrInfo+ array.

(((method,STSAClass,Attribute)))

[source,tcl]
----
<<stsaclass configuration>>=
method Attribute {args} {
    my variable attrInfo

    foreach attr $args {
        lassign $attr name default
        if {$name eq {}} {
            set msg "invalid attribute name, \"$name\""
            throw [list STSACLASS BADATTRIBUTENAME $name $msg] $msg   ; # <1>
        }
        if {![info exists attrInfo($name)]} {
            set attrInfo($name) $default
        } else {
            set msg "duplicate attribute name, \"$name\""
            throw [list STSACLASS DUPATTRIBUTENAME $name $msg] $msg
        }
    }
}
----
<1> We will consistently use the +throw+ command to produce errors
in an effort to insure that reasonable error codes are produced.

[float]
===== Attribute Method Tests

We can test the +Attribute+ method in isolation,
but this requires a bit of namespace trickery to invoke the
unexported method.
However, in Tcl nothing is really hidden.

[source,tcl]
----
<<constructor tests>>=
test Attribute-1.0 {
    configure multiple attributes
} -setup {
    ::stsatcl STSAClass create at1 {}
} -cleanup {
    at1 destroy
} -body {
    [info object namespace at1]::my Attribute\
        Count {Maximum 20}
    array size [info object namespace at1]::attrInfo
} -result {2}
----

[source,tcl]
----
<<constructor tests>>=
test Attribute-2.0 {
    attempt to name an attribute the empty string
} -setup {
    ::stsatcl STSAClass create at2 {}
} -cleanup {
    at2 destroy
} -body {
    [info object namespace at2]::my Attribute {}
} -result {invalid attribute name, ""} -returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test Attribute-3.0 {
    attempt to have duplicate attributes
} -setup {
    ::stsatcl STSAClass create at3 {}
} -cleanup {
    at3 destroy
} -body {
    [info object namespace at3]::my Attribute Count Count
} -result {duplicate attribute name, "Count"} -returnCodes error
----

==== Reference Method

In XUML,
a relationship between two classes is conceptually bi-directional.
The relationship defines a function (or partial function) between
the two instance sets of the classes and the idea is firmly grounded
in referential integrity ideas from the
http://en.wikipedia.org/wiki/Relational_model[Relational Model of Data].

In the implementation world,
a relationship is decomposed into _links_.
A link is uni-directional
and is included in a class if any of the class processing requires
_navigating_ the link to obtain instances of the related class.

XUML relationships also carry the notion of multiplicity and
conditionality.
So a relationship may navigate to multiple instances in one direction
and may also allow that no instances are related.
We need a way to specify whether a link reference is _singular_ or _multiple_
and whether it is _conditional_.

The +reference+ command is invoked in the XUML class configuration
script to define a linkage where one class refers to another.
The invocation synopsis is:

(((DSL,command,reference)))

................
reference rname spec dstclass
................

+rname+::
    is the name of the reference. Conventionally, references are named
    with a capital ``R'' followed by a number (_e.g._ +R42+), but any
    string may be used.
+spec+::
    is a string that designates the multiplicity and conditionality of the
    reference. It consists of a hyphen (-) followed by one or more greater
    than signs (>) followed by an optional letter ``c''.
    A _spec_ argument of ``\->'' indicates the multiplicity of the reference
    is singular. A ``\->>'' indicates a multiplicity of _many_.
    Either type of multiplicity may have a ``c'' suffix (_e.g._ ``\->>c'')
    to indicate that the reference may refer to zero instances.
+dstclass+::
    is the name of a class command to which instances refer.
    The class need not exist at the time the +reference+ command is executed.
    Unqualified class commands are resolved into the namespace of the
    caller.

In this architecture,
linkage is achieved by storing the command name of the object.
We will make sure to store the fully qualified command name
even if we take unqualified names as arguments.
So one aspect of linkage is to perform the object command name
qualification.

[source,tcl]
----
<<stsaclass configuration>>=
method Qualify {cmdname {level 4}} {
    return [expr {[string range $cmdname 0 1] ne "::" ?\
        "[string trimright [uplevel $level namespace current] :]::$cmdname" :\
        $cmdname}]
}
----

Just as for attributes,
we hold the reference information in an array.
The array index is the name of the linkage
and the array element is a dictionary.
We will see the structure of the dictionary below.

[source,tcl]
----
<<stsaclass constructor>>=
my variable refInfo
array set refInfo {}
----

The implementation of the +Reference+ method uses a regular expression
to parse the _spec_ argument syntax.
A dictionary is then created to hold the component parts of the spec.

(((method,STSAClass,Reference)))

[source,tcl]
----
<<stsaclass configuration>>=
method Reference {rname spec dstclass} {
    my variable refInfo
    if {[info exists refInfo($rname)]} {
        set errmsg  "linkage, \"$rname\", already exists"
        throw [list STSACLASS DUPREFERENCE $rname $errmsg] $errmsg
    }
    set dstclass [my Qualify $dstclass]

    if {![regexp -nocase -- {\A-(>{1,2})(c?)\Z} $spec match mult cond]} {
        set errmsg "bad reference spec, \"$spec\""
        throw [list STSACLASS BADREFSPEC $spec $errmsg] $errmsg
    }
    set mult [string equal $mult ">>"]
    set cond [string equal $cond "c"]

    set refInfo($rname) [dict create\
        type reference\
        dest $dstclass\
        mult $mult\
        cond $cond\
    ]
}
----

[float]
===== Reference Method Tests

Using the same techniques as for the +Attribute+ method,
we can test the +Reference+ method in isolation.
However, we must be careful to give fully qualified class names.
Otherwise since the +Qualify+ method is not being invoked at the correct level,
it will throw an error.

[source,tcl]
----
<<constructor tests>>=
test Reference-1.0 {
    configure a simple reference
} -setup {
    ::stsatcl STSAClass create ref1 {}
} -cleanup {
    ref1 destroy
} -body {
    [info object namespace ref1]::my Reference R1 -> [namespace current]::foo
    set [info object namespace ref1]::refInfo(R1)
} -result {type reference dest ::stsatcl::test::foo mult 0 cond 0}
----

[source,tcl]
----
<<constructor tests>>=
test Reference-2.0 {
    define reference with bad syntax
} -setup {
    ::stsatcl STSAClass create ref2 {}
} -cleanup {
    ref2 destroy
} -body {
    [info object namespace ref2]::my Reference R1 ->>x [namespace current]::foo
} -result {bad reference spec, "->>x"} -returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test Reference-3.0 {
    duplicated reference
} -setup {
    ::stsatcl STSAClass create ref3 {}
} -cleanup {
    ref3 destroy
} -body {
    [info object namespace ref3]::my Reference R1 -> [namespace current]::foo
    [info object namespace ref3]::my Reference R1 -> [namespace current]::foo
} -result {linkage, "R1", already exists} -returnCodes error
----

==== Partition Method

There is one other type of linkage that must be supported.
In XUML the generalization relationship of ordinary UML is interpreted
in terms of a set partitionfootnote:[_Cf._ conventional UML that usually
interprets the general relationship as some type of _inheritance_.].
A set partion of the super class instances implies that each
instance of the super class is linked to exactly one instance of
a sub class from among all the sub classes that participate in the
generalization.
You can think of the generalization as some sort of equivalence relation.

(((DSL,command,partition)))

................
partition rname sub1 sub2 ...
................

+rname+::
    is the name of the partition. Conventionally, partitions and references are
    named with a capital ``R'' followed by a number (_e.g._ +R42+), but any
    string may be used.
    A partition and a reference may not have the same name.
+sub1 sub2 ...+::
    are the names of sub classes of the partition.
    The sub classes do not have to exist when the partition is declared.
    At least two sub classes must be given.

We will store the partition information in the same +refInfo+ array.
Together the references and partitions for the set of linkages for the
class.
For the case of a partition,
the dictionary value will have a different value for the +type+ key
and the value of the +subclasses+ key holds the set of sub classes.

(((method,STSAClass,Partition)))

[source,tcl]
----
<<stsaclass configuration>>=
method Partition {rname args} {
    my variable refInfo
    if {[info exists refInfo($rname)]} {
        set errmsg  "linkage, \"$rname\", already exists"
        throw [list STSACLASS DUPREFERENCE $rname $errmsg] $errmsg
    }
    if {[llength $args] < 2} { # <1>
        set errmsg "partition, \"$rname\", must have at least two subclasses"
        throw [list STSACLASS PARTITION $errmsg] $errmsg
    }

    set subs [list]
    foreach sub $args {
        set sub [my Qualify $sub]
        ::struct::set include subs $sub
    }
    set refInfo($rname) [dict create\
        type partition\
        subclasses $subs\
    ]
}
----
<1> We insists that a partition has at least two sub classes.
Although, one can conceive of an improper subset as a partition,
it does not carry any reasonable semantics and so is interpreted as
a mistake.

[float]
===== Partition Method Tests

+Partition+ method testing follows the same pattern as for
the +Attribute+ and +Reference+ methods.

[source,tcl]
----
<<constructor tests>>=
test Partition-1.0 {
    define partition
} -setup {
    ::stsatcl STSAClass create pt1 {}
} -cleanup {
    pt1 destroy
} -body {
    [info object namespace pt1]::my Partition R1\
            [namespace current]::sub1 [namespace current]::sub2
    set [info object namespace pt1]::refInfo(R1)
} -result {type partition subclasses {::stsatcl::test::sub1 ::stsatcl::test::sub2}}
----

[source,tcl]
----
<<constructor tests>>=
test Partition-2.0 {
    partition with one sub class
} -setup {
    ::stsatcl STSAClass create pt2 {}
} -cleanup {
    pt2 destroy
} -body {
    [info object namespace pt2]::my Partition R1\
            [namespace current]::sub1
} -result {partition, "R1", must have at least two subclasses}\
-returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test Partition-3.0 {
    define duplicate partitions
} -setup {
    ::stsatcl STSAClass create pt3 {}
} -cleanup {
    pt3 destroy
} -body {
    [info object namespace pt3]::my Partition R1\
            [namespace current]::sub1 [namespace current]::sub2
    [info object namespace pt3]::my Partition R1\
            [namespace current]::sub3 [namespace current]::sub4
} -result {linkage, "R1", already exists} -returnCodes error
----

==== Statemodel Method

Not all XUML classes have state behavior.
The analysis model will only define state models for classes
that have non-trivial and interesting dynamic behavior.
We would like to keep the commands that are required to define
a state model grouped together.
Although not strictly necessary,
grouping the state model commands together into a script will
help make the semantic distinction between dynamic behavior
implied by the state model and the static characteristics specified
by the attributes.

(((DSL,command,statemodel)))

................
statemodel script
................

+script+::
    A script invoking commands used to specify a Moore style state model.

We will still want to execute +STSAClass+ methods to handle the
state model specification,
but we want to make sure the state model configuration script does
not execute any other configuration commands.
To do this, we will put the state model configuration commands
in a namespace that is a child of the class namespace and evaluate
the state model configuration script in that namespace.

The bit of trickery required for this is similar to that used
in the +link+ command.
Indeed the code below is a simple variation on the +tcllib+ source
for the +link+ procedure.
Here we define a +linkTo+ helper procedure that specifies a child
namespace were we wish to evaluate the linked commands.

[source,tcl]
----
<<stsatcl commands>>=
proc ::oo::Helpers::linkTo {childns args} {
    namespace eval $childns {}              ; # <1>
    set childns [string trim $childns :]    ; # <2>
    set ns [uplevel 1 {namespace current}]
    foreach link $args {
	if {[llength $link] == 2} {
	    lassign $link src dst
	} else {
	    lassign $link src
	    set dst $src
	}
	interp alias {} ${ns}::${childns}::$src {} ${ns}::my $dst ; # <3>
    }
    return
}
----
<1> Make sure to create the namespace.
<2> Clean up any extraneous colon characters. We definitely don't want
any leading colons as that would imply a fully-qualified namespace name.
<3> Link the command in the child namespace back to a class method.

With the ability to link commands to a child namespace,
we can now define the state model configuration commands.

[source,tcl]
----
<<stsaclass constructor>>=
linkTo smdsl\
    {state State}\
    {transition Transition}\
    {defaultTrans DefaultTrans}\
    {initialState InitialState}
----

With all these preliminaries out of the way,
the +Statemodel+ method simply consists of evaluating a +script+
in the proper child namespace that resolves the commands
required to specify the state behavior.
We will discuss those commands in detail <<smdsl,below>>.

(((method,STSAClass,Statemodel)))

[source,tcl]
----
<<stsaclass configuration>>=
method Statemodel {script} {
    namespace eval [namespace current]::smdsl $script
}
----

==== Polymorphic Method

The semantics of dynamic actions in XUML supports one form or
polymorphism and that is in events that are directed at a super class.
Super class events that are declared as polymorphic are propagated
to the sub class instance to which the target super class is currently
related.
This idea is only valid for those classes that are the super class
in a generalization relationship.
From a methodology point of view,
there is much to say about polymorphic events.
However from an implemementation architecure point of view,
they amount to little more than factoring some common code in to
the event dispatch.

The +polymorphic+ command is used to declare those events that
are intended to be treated as polymorphic with respect to their sub classes.

(((DSL,command,polymorphic)))

................
polymorphic event1 event2 ...
................

+event1 event2 ...+::
    the names of events that are to be treated polymorphically.

It is sufficient simply to store the event names as a set.

[source,tcl]
----
<<stsaclass constructor>>=
my variable polyEvents
set polyEvents [list]
----

(((method,STSAClass,Polymorphic)))

[source,tcl]
----
<<stsaclass configuration>>=
method Polymorphic {args} {
    my variable polyEvents
    ::struct::set add polyEvents $args
}
----

[float]
===== Polymorphic Method Tests

[source,tcl]
----
<<constructor tests>>=
test Polymorphic-1.0 {
    define polymorphic events
} -setup {
    ::stsatcl STSAClass create pm1 {}
} -cleanup {
    pm1 destroy
} -body {
    [info object namespace pm1]::my Polymorphic e1 e2
    llength [set [info object namespace pm1]::polyEvents]
} -result {2}
----

==== InstOp Method

[source,tcl]
----
<<stsaclass configuration>>=
method InstOp {name arglist body} {
    tailcall ::oo::define [self] method $name $arglist $body
}
----

==== ClassOp Method

[source,tcl]
----
<<stsaclass configuration>>=
method ClassOp {name arglist body} {
    tailcall ::oo::objdefine [self] method $name $arglist $body
}
----

=== State Model Configuration DSL [[smdsl,State Model DSL]]

Now that we have covered all the first level class configuration
commands,
we can turn our attention to the commands used to configure a state model.
Recall that the +statemodel+ command takes a script and that script
should invoke the commands discussed here to specify the state model
for a class.

We follow the syntax and conventions of the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/doc/tip/oomoore/wiki/intro.wiki[+oomoore+]
package.
Indeed, must of the code for configurating and dispatching events to
state models was take from that package and adapted here.

==== State Method

The +State+ method is used to specify that states of the state model.

(((DSL,command,state)))

................
state name arglist body
................

+name+::
    the name of the state. The names, ``IG'', ``CH'' and ``@'' are reserved.

+arglist+::
    a list of parameters in the style of the +proc+ command.
    Events that cause a transition into the state must supply actual
    argument values that correspond to the parameters.

+body+::
    a script that is executed when the state is entered.

[source,tcl]
----
<<stsaclass constructor>>=
my variable states
set states [list]
----

[source,tcl]
----
<<stsaclass configuration>>=
method State {name argList body} {
    # The "states" variable holds the set of defined states. Order is
    # important here because we may need to use the first defined state
    # as the default initial state.
    my variable states
    if {$name in {IG CH}} {
        set errmsg "states may not be named by the reserved name, \"$name\""
        throw [list STSACLASS RESERVED_STATE $name $errmsg] $errmsg
    } elseif {$name in $states} {
        set errmsg "duplicate state, \"$name\""
        throw [list STSACLASS DUPLICATE_STATE $name $errmsg] $errmsg
    } else {
        lappend states $name
        ::oo::define [self] method ${name}__STATE__ $argList $body
    }
}
----

[source,tcl]
----
<<stsaclass constructor>>=
my variable events
set events [list]
my variable transitions
array set transitions {}
----

[source,tcl]
----
<<stsaclass configuration>>=
# Define a state model transition
# The "-" and "->" parameters are syntactic sugar.
method Transition {current - event -> new} {
    my variable events
    ::struct::set include events $event

    my variable transitions
    if {[info exists transitions($current,$event)]} {
        set errmsg "duplicate transition, \"$current - $event\""
        throw [list STSACLASS DUPLICATE_TRANS $current $event $errmsg] $errmsg
    } else {
        set transitions($current,$event) $new
    }
}
----

[source,tcl]
----
<<stsaclass constructor>>=
my variable defaulttrans
set defaulttrans CH
----

[source,tcl]
----
<<stsaclass configuration>>=
method DefaultTrans {trans} {
    if {$trans eq "IG" || $trans eq "CH"} {
        my variable defaulttrans
        set defaulttrans $trans
    } else {
        set errmsg "unknown transition name, \"$trans\": must be one of\
                \"IG\" or \"CH\""
        throw [list STSACLASS BAD_DEFAULT_TRANS $trans $errmsg] $errmsg
    }
}
----

[source,tcl]
----
<<stsaclass configuration>>=
method InitialState {state} {
    my variable initialstate
    set initialstate $state
}
----

=== Completing Construction

[source,tcl]
----
<<stsaclass constructor>>=
my eval $config
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] variable {*}[array names attrInfo]
----

[source,tcl]
----
<<stsaclass constructor>>=
if {[llength $states] != 0} {
    # Check that the model was defined correctly and consistently.
    #
    # Check for isolated states, i.e. those with no inbound or outbound
    # transition. Here we find all the states with no outbound transitions
    # and all those with no inbound transition. The intersection is then
    # the set of isolated states. We start by accumulating as list of
    # states that have outbound or inbound transitions.
    set outstates [list]
    set instates [list]
    foreach {trans dst} [array get transitions] {
        lassign [split $trans ,] src event
        # While we are iterating across the transitions, check that they
        # are consistent with the set of defined states.
        if {$src ni $states} {
            set errmsg "unknown source state in transition,\
                \"$src - $event -> $dst\""
            throw [list STSACLASS UNKNOWN_STATE $src $errmsg] $errmsg
        }
        ::struct::set include outstates $src
        # Skip the non-transitioning pseudo-states of IG and CH
        if {!($dst eq "IG" || $dst eq "CH")} {
            if {$dst ni $states} {
                set errmsg "unknown destination state in transition,\
                    \"$src - $event -> $dst\""
                throw [list STSACLASS UNKNOWN_STATE $dst $errmsg] $errmsg
            } else {
                ::struct::set include instates $dst
            }
        }
    }
    # The set of states with no inbound transitions is then the difference
    # between the set of all states and those that do have inbound
    # transitions. Similarly for outbound transitions.
    set noincoming [::struct::set difference $states $instates]
    set nooutgoing [::struct::set difference $states $outstates]
    # The intersection then determines those states with neither inbound
    # nor outbound transitions, hence isolated.
    set isostates [::struct::set intersect $noincoming $nooutgoing]
    if {![::struct::set empty $isostates]} {
        set errmsg "state model has isolated state(s):\
                \"[join $isostates {, }]\""
        log::error $errmsg
        throw [list STSACLASS ISOLATED $isostates] $errmsg
    }
    # Fill out the transition matrix completely using the default
    # transition for those transitions not defined explicitly.  This will
    # save some tests during event dispatch.
    foreach s $states {
        foreach e $events {
            if {![info exists transitions($s,$e)]} {
                set transitions($s,$e) $defaulttrans
            }
        }
    }
    # If it has been defined, check the initial state. Otherwise,
    # we set it to the first state that was lexically defined.
    my variable initialstate
    if {[info exists initialstate]} {
        if {$initialstate ni $states} {
            set errmsg "unknown initial state, \"$initialstate\""
            throw [list STSACLASS UNKNOWN_STATE $initialstate $errmsg] $errmsg
        }
    } else {
        set initialstate [lindex $states 0]
    }
}
----

=== Class Methods

[source,tcl]
----
<<stsaclass constructor>>=
define [self] constructor {args} {
    classvariable attrInfo
    foreach attrName [array names attrInfo] {
        set $attrName $attrInfo($attrName)
    }

    classvariable refInfo
    foreach refName [array names refInfo] {
        my variable $refName
        set $refName {}
    }

    my updateAttributes {*}$args

    classvariable states
    if {[llength $states] != 0} {
        my variable __currentstate__
        # Set the initial state to the default
        classvariable initialstate
        set __currentstate__ $initialstate

        # Set up the uevent package event bindings. We use two
        # different event bindings depending upon whether the event
        # being dispatched is delayed or not.
        my variable __evttoken__
        set __evttoken__ [::uevent bind [self] event [mymethod Dispatch]]
        my variable __delaytoken__
        set __delaytoken__ [::uevent bind [self] delayed\
                [mymethod DelayedDispatch]]
        # We keep a queue of events as a simple list.
        my variable __event_queue__
        set __event_queue__ [list]
    }
}
----

[source,tcl]
----
<<required packages>>=
package require uevent
----

[source,tcl]
----
<<constructor tests>>=
test constructor-5.0 {
    create an instance
} -setup {
    stsatcl STSAClass create test5 {
        attribute Count {Maximum 20}
    }
} -cleanup {
    test5 destroy
} -body {
    test5 create inst5
    set [info object namespace inst5]::Maximum
} -result {20}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-6.0 {
    define a state model
} -setup {
    stsatcl STSAClass create test6 {
        attribute Count {Maximum 20}
        statemodel {
            state s1 {} {
                puts "[self] in s1"
            }
            transition s1 - e1 -> s1
        }
    }
} -cleanup {
    test6 destroy
} -body {
    test6 create inst6
    set [info object namespace test6]::states
} -result {s1}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-6.1 {
    define a state model with transition
} -setup {
    stsatcl STSAClass create test6 {
        attribute Count {Maximum 20}
        statemodel {
            state s1 {} {
                puts "[self] in s1"
            }
            transition s1 - e1 -> s1
        }
    }
} -cleanup {
    test6 destroy
} -body {
    test6 create inst6
    set [info object namespace test6]::transitions(s1,e1)
} -result {s1}
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] destructor {
    my variable __currentstate__
    if {[info exists __currentstate__]} {
        # Unbind the events used for asynchronous signal delivery.
        my variable __evttoken__
        ::uevent unbind $__evttoken__
        my variable __delaytoken__
        ::uevent unbind $__delaytoken__
        # Cancel any outstanding delayed signals.
        my variable __delayedSignals__
        foreach {sigid sigdetails} [array get __delayedSignals__] {
            after cancel [lindex $sigdetails 0]
        }
    }
}
----

== Creating in a State

[source,tcl]
----
<<stsaclass constructor>>=
objdefine [self] method createin {name initstate args} {
    my variable states
    if {$initstate in $states} {
        if {[string range $name 0 1] ne "::"} {
            set ns [string trimright [uplevel 1 namespace current] :]
            set name ${ns}::${name}
        }
        set inst [my create $name {*}$args]
        set [info object namespace $inst]::__currentstate__ $initstate
    } else {
        set errmsg "unknown state, \"$initstate\", should be one of,\
                \"[join $states {, }]\""
        throw [list STSACLASS UNKNOWN_STATE $initstate $errmsg] $errmsg
    }

    return $inst
}
----

[source,tcl]
----
<<stsaclass constructor>>=
objdefine [self] method newin {initstate args} {
    my variable states
    if {$initstate in $states} {
        set inst [my new {*}$args]
        set [info object namespace $inst]::__currentstate__ $initstate
    } else {
        set errmsg "unknown state, \"$initstate\", should be one of,\
                \"[join $states {, }]\""
        throw [list STSACLASS UNKNOWN_STATE $initstate $errmsg] $errmsg
    }

    return $inst
}
----

== Access to Attributes

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method readAttributes {args} {
    set nargs [llength $args]
    if {$nargs == 0} {
        classvariable attrInfo
        set attrNames [array names attrInfo]
    } elseif {$nargs > 1} {
        set attrNames $args
    } else {
        return [set [lindex $args 0]]
    }

    set result [dict create]
    foreach attr $attrNames {
        dict set result $attr [set $attr]
    }
    return $result
}
----

[source,tcl]
----
<<exported tests>>=
test readAttributes-1.0 {
    read single attribute value
} -setup {
    stsatcl STSAClass create test-ra1 {
        attribute Count {Maximum 27}
    }
} -cleanup {
    test-ra1 destroy
} -body {
    test-ra1 create inst1-ra1
    inst1-ra1 readAttributes Maximum
} -result {27}
----

[source,tcl]
----
<<exported tests>>=
test readAttributes-2.0 {
    read multiple attribute value
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27} {Timeout 1000}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst1-ra2
    inst1-ra2 readAttributes Maximum Timeout
} -result {Maximum 27 Timeout 1000}
----

[source,tcl]
----
<<exported tests>>=
test readAttributes-3.0 {
    read multiple attribute value
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27} {Timeout 1000}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst1-ra2
    inst1-ra2 readAttributes
} -result {Count {} Maximum 27 Timeout 1000}
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method updateAttributes {args} {
    dict for {attribute value} $args {
        set $attribute $value
    }
    return
}
----

[source,tcl]
----
<<exported tests>>=
test updateAttributes-1.0 {
    update attribute value
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst-ra2
    inst-ra2 updateAttributes Count 33
    inst-ra2 readAttributes Count
} -result {33}
----

[source,tcl]
----
<<exported tests>>=
test updateAttributes-2.0 {
    update multiple attribute values
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst-ra2
    inst-ra2 updateAttributes Count 33 Maximum 50
    inst-ra2 readAttributes Count Maximum
} -result {Count 33 Maximum 50}
----

== Relationship Navigation

[source,tcl]
----
<<required packages>>=
package require struct::set
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method link {rname obj} {
    set obj [my ResolveObj $obj]
    classvariable refInfo
    my CheckRelName $rname
    my CheckReferenceObj $rname $obj

    my variable $rname
    switch -exact -- [dict get $refInfo($rname) type] {
        reference {
            if {[dict get $refInfo($rname) mult]} {
                ::struct::set include $rname $obj
            } else {
                set $rname $obj
            }
        }
        partition {
            set $rname $obj
        }
        default {
            error "unknown linkage type, \"[dict get $refInfo($rname) type]\""
        }
    }
    return $obj
}
----

[source,tcl]
----
<<exported tests>>=
test link-1.0 {
    link across singular reference
} -setup {
    stsatcl STSAClass create test-lt1 {
        reference R1 -> test-lt2
    }
    stsatcl STSAClass create test-lt2 {
        reference R1 -> test-lt1
    }
} -cleanup {
    test-lt1 destroy
    test-lt2 destroy
} -body {
    test-lt1 create lt1
    test-lt2 create lt2
    lt1 link R1 lt2
} -result {::stsatcl::test::lt2}
----

[source,tcl]
----
<<exported tests>>=
test link-2.0 {
    link across multiple reference
} -setup {
    stsatcl STSAClass create test-lt1 {
        reference R2 ->> test-lt2
    }
    stsatcl STSAClass create test-lt2 {
        reference R2 -> test-lt1
    }
} -cleanup {
    test-lt1 destroy
    test-lt2 destroy
} -body {
    test-lt1 create inst1
    test-lt2 create inst2
    test-lt2 create inst3
    inst1 link R2 inst2
    inst1 link R2 inst3
    llength [set [info object namespace inst1]::R2]
} -result {2}
----

[source,tcl]
----
<<exported tests>>=
test link-2.1 {
    link across multiple reference, duplicate references
} -setup {
    stsatcl STSAClass create test-lt1 {
        reference R2 ->> test-lt2
    }
    stsatcl STSAClass create test-lt2 {
        reference R2 -> test-lt1
    }
} -cleanup {
    test-lt1 destroy
    test-lt2 destroy
} -body {
    test-lt1 create inst1
    test-lt2 create inst2
    inst1 link R2 inst2
    inst1 link R2 inst2
    llength [set [info object namespace inst1]::R2]
} -result {1}
----

[source,tcl]
----
<<exported tests>>=
test link-3.0 {
    link across partition
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R3 -> super
    }

    ::stsatcl STSAClass create sub2 {
        reference R3 -> super
    }
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    super create sup1
    sub1 create inst1
    sup1 link R3 inst1
    llength [set [info object namespace sup1]::R3]
} -result {1}
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method unlink {rname obj} {
    set obj [my ResolveObj $obj]
    classvariable refInfo
    my CheckRelName $rname
    my CheckReferenceObj $rname $obj

    my variable $rname
    switch -exact -- [dict get $refInfo($rname) type] {
        reference {
            if {[dict get $refInfo($rname) mult]} {
                if {[::struct::set contains [set $rname] $obj]} {
                    ::struct::set exclude $rname $obj
                } else {
                    error "object, \"$obj\", is not linked to \"$rname\""
                }
            } else {
                if {$obj eq [set $rname]} {
                    set $rname {}
                } else {
                    error "\"$obj\" is not linked to \"$rname\",\
                            \"[set $rname]\" is"
                }
            }
        }
        partition {
            if {$obj eq [set $rname]} {
                set $rname {}
            } else {
                error "\"$obj\" is not linked to \"$rname\",\
                        \"[set $rname]\" is"
            }
        }
        default {
            error "unknown linkage type, \"[dict get $refInfo($rname) type]\""
        }
    }

    return
}
----

[source,tcl]
----
<<exported tests>>=
test unlink-1.0 {
    unlink across singular reference
} -setup {
    stsatcl STSAClass create test-ul1 {
        reference R1 ->c test-ul2
    }
    stsatcl STSAClass create test-ul2 {
        reference R1 -> test-ul1
    }
} -cleanup {
    test-ul1 destroy
    test-ul2 destroy
} -body {
    test-ul1 create inst-ul1
    test-ul2 create inst-ul2
    inst-ul1 link R1 inst-ul2
    inst-ul1 unlink R1 inst-ul2
    set [info object namespace inst-ul2]::R1
} -result {}
----

[source,tcl]
----
<<exported tests>>=
test unlink-2.0 {
    unlink across multiple reference
} -setup {
    stsatcl STSAClass create test-ul3 {
        reference R1 ->> test-ul4
    }
    stsatcl STSAClass create test-ul4 {
        reference R1 -> test-ul3
    }
} -cleanup {
    test-ul3 destroy
    test-ul4 destroy
} -body {
    test-ul3 create inst1
    test-ul4 create inst2
    test-ul4 create inst3

    inst1 link R1 inst2
    inst1 link R1 inst3
    inst1 unlink R1 inst2
    llength [info object namespace inst1]::R1
} -result {1}

test unlink-3.0 {
    unlink across partition
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R3 -> super
    }

    ::stsatcl STSAClass create sub2 {
        reference R3 -> super
    }
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    super create inst-super
    sub1 create inst-sub1
    inst-super link R3 inst-sub1
    inst-super unlink R3 inst-sub1
    set [info object namespace inst-super]::R3
} -result {}
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method -> {rname args} {
    classvariable refInfo
    my CheckRelName $rname

    my variable $rname
    set relobjs [set $rname]

    switch -exact -- [dict get $refInfo($rname) type] {
        reference {
            if {![dict get $refInfo($rname) cond] && [llength $relobjs] == 0} {
                error "reference, \"$rname\", is unconditional, yet no\
                        instances were found"
            }
        }
        partition {
            if {$relobjs eq {}} {
                error "superclass partition, \"$rname\", is unconditional,\
                        yet no instances were found"
            }
            if {[llength $args] < 1} {
                error "partition navigation from supertype to subtype\
                        requires the destination subtype class"
            }

            set subclass [lindex $args 0]
            set args [lrange $args 1 end]

            set subclass [my ResolveObj $subclass]
            if {[llength [info class instances $subclass $relobjs]] == 0} {
                set relobjs [list]
            }
        }
        default {
            error "unknown linkage type, \"[dict get $refInfo($rname) type]\""
        }
    }

    if {[llength $args] != 0} {
        set related [list]
        foreach robj $relobjs {
            ::struct::set add related [$robj -> {*}$args]
        }
    } else {
        set related $relobjs
    }

    return [expr {[llength $related] < 2 ? [lindex $related 0] : $related}]
}
define [self] export ->
----

[source,tcl]
----
<<exported tests>>=
test reference-1.0 {
    traverse a singular relationship
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    inst1 link R1 inst2
    inst1 -> R1
} -result {::stsatcl::test::inst2}
----

[source,tcl]
----
<<exported tests>>=
test reference-1.1 {
    traverse many singular relationships
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    inst1 link R1 inst2
    inst2 link R1 inst1

    inst1 -> R1 R1
} -result {::stsatcl::test::inst1}
----

[source,tcl]
----
<<exported tests>>=
test reference-1.2 {
    traverse many singular relationships -- violate conditionality
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    inst1 link R1 inst2
    inst1 -> R1 R1
} -result {reference, "R1", is unconditional, yet no instances were found}\
  -returnCodes error
----

[source,tcl]
----
<<exported tests>>=
test reference-2.0 {
    traverse a multiple relationship
} -setup {
    stsatcl STSAClass create rt1 {
        reference R2 ->> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R2 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    rt2 create inst3
    inst1 link R2 inst2
    inst1 link R2 inst3
    inst1 -> R2
} -result {::stsatcl::test::inst2 ::stsatcl::test::inst3}
----

[source,tcl]
----
<<exported tests>>=
test reference-2.1 {
    traverse a multiple relationship, then a singular
} -setup {
    stsatcl STSAClass create rt1 {
        reference R2 ->> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R2 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    rt2 create inst3
    inst1 link R2 inst2
    inst1 link R2 inst3
    inst2 link R2 inst1
    inst3 link R2 inst1

    inst1 -> R2 R2
} -result {::stsatcl::test::inst1}
----

[source,tcl]
----
<<exported tests>>=
test reference-3.0 {
    traverse across partition
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R3 -> super
    }

    ::stsatcl STSAClass create sub2 {
        reference R3 -> super
    }
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    super create sup1
    sub1 create inst1

    sup1 link R3 inst1
    sup1 -> R3 sub1
} -result {::stsatcl::test::inst1}
----

[source,tcl]
----
<<exported tests>>=
test reference-3.1 {
    traverse across partition and single reference
} -setup {
    ::stsatcl STSAClass create super {
        partition R10 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R10 -> super
        reference R11 -> c3
    }

    ::stsatcl STSAClass create sub2 {
        reference R10 -> super
    }
    ::stsatcl STSAClass create c3 {
        reference R11 -> sub1
    }
    super create sup1
    sub1 create s1
    c3 create inst3
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
    c3 destroy
} -body {
    sup1 link R10 s1
    s1 link R10 sup1
    s1 link R11 inst3
    inst3 link R11 s1
    sup1 -> R10 sub1 R11
} -result {::stsatcl::test::inst3}
----

[source,tcl]
----
<<exported tests>>=
test reference-3.2 {
    traverse across partition and single reference
} -setup {
    ::stsatcl STSAClass create super {
        partition R10 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R10 -> super
        reference R11 -> c3
    }

    ::stsatcl STSAClass create sub2 {
        reference R10 -> super
    }
    ::stsatcl STSAClass create c3 {
        reference R11 -> sub1
    }
    super create sup1
    sub1 create s1
    c3 create inst3
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
    c3 destroy
} -body {
    sup1 link R10 s1
    s1 link R10 sup1
    s1 link R11 inst3
    inst3 link R11 s1
    sup1 -> R10 sub2 R11
} -result {}
----

=== Filter Method

[source,tcl]
----
<<required packages>>=
package require struct::list
----

[source,tcl]
----
<<stsaclass constructor>>=
objdefine [self] method findWhere {varname expr} {
    tailcall ::struct::list filterfor $varname [info class instances [self]]\
            $expr
}
----

[source,tcl]
----
<<exported tests>>=
test findWhere-1.0 {
    find instances base on criteria
} -setup {
    ::stsatcl STSAClass create fw1 {
        attribute Count {Maximum 27} {Timeout 1000}
    }
} -cleanup {
    fw1 destroy
} -body {
    fw1 create inst1
    fw1 create inst2 Maximum 30 Timeout 1000
    fw1 create inst3 Timeout 2000
    fw1 findWhere inst {
        [$inst readAttributes Timeout] == 1000
    }
} -result {::stsatcl::test::inst1 ::stsatcl::test::inst2}
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method findRelatedWhere {rlist varname expr} {
    tailcall ::struct::list filterfor $varname [my -> {*}$rlist] $expr
}
----

[source,tcl]
----
<<exported tests>>=
test findRelatedWhere-1.0 {
    find related instances base on criteria
} -setup {
    ::stsatcl STSAClass create frw1 {
        attribute Count {Maximum 27} {Timeout 1000}
        reference R1 ->> frw2
    }
    ::stsatcl STSAClass create frw2 {
        attribute Reason Temp Pressure Current
    }

    frw1 create i1

    frw2 create c1 Temp 20
    frw2 create c2 Temp 30
    frw2 create c3 Temp 40
    frw2 create c4 Temp 50

    i1 link R1 c1
    i1 link R1 c2
    i1 link R1 c3
    i1 link R1 c4
} -cleanup {
    frw1 destroy
    frw2 destroy
} -body {
    set targetTemp 30
    i1 findRelatedWhere R1 inst {
        [$inst readAttributes Temp] > $targetTemp
    }
} -result {::stsatcl::test::c3 ::stsatcl::test::c4}
----

=== Map Method

[source,tcl]
----
<<stsaclass constructor>>=
objdefine [self] method mapInstances {varname script} {
    uplevel 1 [list ::lmap $varname [info class instances [self]] $script]
}
----

[source,tcl]
----
<<exported tests>>=
test mapInstances-1.0 {
    iterate on instances to produce an attribute list
} -setup {
    ::stsatcl STSAClass create fw1 {
        attribute Count Maximum Timeout
    }
} -cleanup {
    fw1 destroy
} -body {
    fw1 create inst1 Maximum 20
    fw1 create inst2 Maximum 30
    fw1 create inst3 Maximum 40

    set divisor 10
    fw1 mapInstances inst {
        expr {[$inst readAttributes Maximum] / $divisor}
    }
} -result {2 3 4}
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method mapRelatedInstances {rlist varname script} {
    uplevel 1 [list ::lmap $varname [my -> {*}$rlist] $script]
}
----

[source,tcl]
----
<<exported tests>>=
test mapRelatedInstances-1.0 {
    iterate on related instances to produce a list
} -setup {
    ::stsatcl STSAClass create frw1 {
        attribute Count {Maximum 27} {Timeout 1000}
        reference R1 ->> frw2
    }
    ::stsatcl STSAClass create frw2 {
        attribute Reason Temp Pressure Current
    }

    frw1 create i1

    frw2 create c1 Temp 20
    frw2 create c2 Temp 30
    frw2 create c3 Temp 40
    frw2 create c4 Temp 50

    i1 link R1 c1
    i1 link R1 c2
    i1 link R1 c3
    i1 link R1 c4
} -cleanup {
    frw1 destroy
    frw2 destroy
} -body {
    set divisor 10
    i1 mapRelatedInstances R1 inst {
        expr {[$inst readAttributes Temp] / $divisor}
    }
} -result {2 3 4 5}
----

=== Utility Methods

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method CheckRelName {rname} {
    classvariable refInfo
    if {![info exists refInfo($rname)]} {
        error "unknown linkage, \"$rname\""
    }
}
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method CheckReferenceObj {rname obj} {
    classvariable refInfo

    set objclass [info object class $obj]
    switch -exact -- [dict get $refInfo($rname) type] {
        reference {
            set destclass [dict get $refInfo($rname) dest]
            if {!($objclass eq $destclass ||\
                    $destclass in [info class superclasses $objclass])} {
                error "instance, \"$obj\", is not an instance of class,\
                        \"[dict get $refInfo($rname) dest]\""
            }
        }
        partition {
            set subclasses [dict get $refInfo($rname) subclasses]
            foreach subclass $subclasses {
                if {$objclass eq $subclass ||\
                    $subclass in [info class superclasses $objclass]} {
                    return
                }
            }
            error "instance, \"$obj\", is not an instance of any class,\
                    \"[join $subclasses {, }]\""
        }
        default {
            error "unknown linkage type, \"[dict get $refInfo($rname) type]\""
        }
    }
}
----

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method ResolveObj {obj} {
    if {[string range $obj 0 1] ne "::"} {
        set obj\
            [string trimright [uplevel 2 namespace current] :]::$obj
    }
    return $obj
}
----

== Code Organization

=== Source Code

[source,tcl]
----
<<stsatcl.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# Copyright 2014, InCube Labs, LLC.
# All rights reserved.  This file contains unpublished work that is
# confidential and proprietary to InCube Labs.  This document may not, in
# whole or in part, be duplicated, disclosed or used for any purposes,
# whatsoever, without written permission from InCube Labs.
#

package require Tcl 8.6
package require logger

<<required packages>>

namespace eval ::stsatcl {
    namespace export STSAClass
    namespace ensemble create

    variable version 1.0
}

<<stsatcl commands>>

package provide stsatcl $::stsatcl::version
----

=== Unit Tests

[source,tcl]
----
<<stsatcl.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# Copyright 2014, InCube Labs, LLC.
# All rights reserved.  This file contains unpublished work that is
# confidential and proprietary to InCube Labs.  This document may not, in
# whole or in part, be duplicated, disclosed or used for any purposes,
# whatsoever, without written permission from InCube Labs.
#

package require Tcl 8.6
package require cmdline
package require logger

source ../src/stsatcl.tcl
chan puts "testing stsatcl version: [package require stsatcl]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
    {port.arg {} {Target comm port}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

package require tcltest
eval tcltest::configure $argv

namespace eval ::stsatcl::test {
    ::logger::initNamespace [namespace current] $::options(level)

    namespace import ::tcltest::*

    <<test utility procs>>
    <<constructor tests>>
    <<unexported tests>>
    <<exported tests>>

    cleanupTests
}
----


////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded stsatcl 1.0 [list source [file join $dir stsatcl.tcl]]
----
