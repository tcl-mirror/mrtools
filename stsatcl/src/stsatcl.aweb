// vim:syntax=asciidoc:
= stsatcl - An Software Architecture for Tcl

== Introduction

By analogy to
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[STSA],
which is a software architecture for micro-controller
based implementations that are coded in ``C'',
the *stsatcl* package is a software architecture for Tcl based
applications.

The concepts here are similar to those used by +STSA+.
Specifically we are defining an implementation based scheme
that is to be used as the target for translating
XUML models into Tcl.

There are, of course, many differences in the way a ``C'' based
architecture and a Tcl based one will handle the implementation
aspects.
For example,
STSA uses pointers to traverse relationships.
There are no such things in Tcl.
However,
command names of TclOO objects can be used to serve the same purpose.
In STSA, ``C'' data types must be given for attributes.
In the Tcl world, everything is a string and Tcl variables can hold
data of any type.
Therefore type annotation is not necessary.
State models in Tcl have already been done in many ways.
Here, we will follow the pattern of the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools-cm3/[+oomoore+],
package and
indeed pull large amounts of its code over.

=== Design Concepts

The STSA Tcl package is based on TclOO.
The translation of XUML model classes to TclOO class is,
to a first approximation, one-to-one.
To support the XUML execution model,
we will create a meta-class called, +STSAClass+.
Instances of +STSAClass+ will correspond to the XUML classes
of the translation.
The constructor of +STSAClass+ will allow for the appropriate
configuration of the resulting XUML implemenation class.
Instances can then be created to populate the translation.
This is shown in the diagram below.

["ditaa",options="no-shadows",title="STSA Tcl Block Diagram"]
-----------------------------------------------------------------------------
+---------------+
|  STSA Class   |
|  o meta-class |
+-------+-------+
        |
        | create
        V
+-------+-------+
|  XUML Class   |
+-------+-------+
        |
        | create/new
        V
+-------+-------+
|  XMUL Object  |
+-------+-------+
-----------------------------------------------------------------------------

This package follows the common convention of defining a small
domain specific language (DSL) that is used in the construction
of objects to specify the required configuration.
In this case we are constructing classes that have STSA
qualities, namely:

* Definition of attributes.
* Definition of relationships.
* Definition of state models.
* Definition of processing.

=== Document Conventions

The source for this document conforms to
http://http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included here and
the build process extracts the source that is then given to the
Tcl interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the preferred choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates understanding the
program details and then _tangle_ the resulting source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk defintion ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
have become adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

We will actually include root chunks for the following items:

* Tcl source for the package.
* Test cases that run under +tcltest+.
* The +pkgIndex.tcl+ package index file.

Since we also include test cases in this document,
the usual order will be to show a *method* and follow it by
the tests that exercise the method.
From a development and maintenance point of view,
is is beneficial to keep the code and tests lexically near each other.
However, you may wish to skip over the testing to keep the narrative
flow more consistent.

In addition to the explanation and code for the +stsatcl+ package,
we will also include an example and endeavor to show how an XUML model
is translated into a Tcl implementation using this package.
The example will, of necessity, be small and somewhat contrived to
insure that all the features of the package are used.
The use of small, contrived examples is always unfortunate but
this document is large enough with just the package and its test cases
that any _real-world_ example would over burden the entire undertaking.
Realistic models and their translation easily become books in themselves.

=== Error Reporting

Most software pushes any discussion of errors to the end as if it were
unimportant or an afterthought (which in many cases it is).
Here we bring error reporting up front to emphasize its importance.

We will consistently use the +throw+ command to produce errors
in an effort to insure that reasonable error codes are produced.
Good error codes are key to programatic recovery from errors.
The format of the error code will be a list of the following elements:

. The package name in upper case, _i.e._ +STSATCL+.
. An error code string.
. Parameters that are dependent upon the error specifics.
. A human readable error message.

Although the size of the error code list varies,
the first two elements and the last element have consistent definitions.

We factor into common code the manipulations required to +throw+
errors.

[source,tcl]
----
<<stsatcl commands>>=
proc ::stsatcl::DeclError {errcode args} {
    variable errFormats
    set errmsg [format $errFormats($errcode) {*}$args]
    tailcall throw [list STSACLASS $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the namespace of the +stsatcl+ package.

[source,tcl]
----
<<package data>>=
variable errFormats
array set errFormats {
    <<error code format>>
}
----

== STSA Class

(((class,STSA Class)))

The *stsatcl* package contains the +STSAClass+ class.
+STSAClass+ is actually a meta-class, _i.e._ it is a class
for defining other classes.

[source,tcl]
----
<<stsatcl commands>>=
::oo::class create ::stsatcl::STSAClass {
    superclass ::oo::class      ; # <1>
    unexport new                ; # <2>
    <<stsaclass configuration>>
}
----
<1> Deriving from +::oo::class+ makes us a meta-class.
<2> We insist that all STSA classes be named commands.

=== Constructor

The constructor of the +STSAClass+ takes a script
that consists of configuration commands.
Those commands will validate and store away the information.
Using the configuation information,
a new class is created with the properties described in the construction
configuration script.
Objects created from the class then have all the characteristics specified
in the configuration script.

(((method,STSAClass,constructor)))

[source,tcl]
----
<<stsaclass configuration>>=
constructor {{config {}}} {
    objdefine [self] export new ; # <1>
    <<stsaclass constructor>>
}
----
<1> We now want the +new+ method to be available to create object
instances of the resulting XUML class.

=== Configuration DSL

The configuration language is really just a series of commands
that are implemented as methods of the class.
Technically,
the design is to use the +my eval+ command to evaluate the
configuration script in the context of the class being created.
The commands in the configuration script need to resolve correctly
in that context.
We would like _not_ to be forced to prefix the DSL commands with
the +my+ command as that clutters the expressiveness of the DSL.
The +oo::util+ package in +tcllib+ provides the +link+ command to make
the DSL command definitions easier.

[source,tcl]
----
<<required packages>>=
package require oo::util
# The mixin of "oo::class.Delegate", interacts badly with meta-classes that
# have constructor arguments. So we eliminate the oo::class mixins here. This
# will mean that you can't define class methods.
::oo::define oo::class self mixin
----

We will also find the notions of a mathematica _set_ useful.
Again we can look to +tcllib+ for the required package.

[source,tcl]
----
<<required packages>>=
package require struct::set
----

[source,tcl]
----
<<stsaclass constructor>>=
link\
    {attribute Attribute}\
    {reference Reference}\
    {partition Partition}\
    {classop ClassOp}\
    {instop InstOp}\
    {polymorphic Polymorphic}\
    {statemodel Statemodel}
----

So the +link+ command arranges, for example, that invoking +attribute+
in the namespace of the class being created actually
invokes the +Attribute+ method of the +STSAClass+ class.
The trickery to accomplish can be found in the source to the +oo::util+
package.
Here we follow the convention that the methods implementing
the DSL commands are unexported and the corresponding linked names
begin with lower case.

So there will be seven commands in the configuration DSL.
The +statemodel+ command will itself take another configuration
script to describe state and transition
and that will be described in a section of its own.
Each of the top level commands is described in a section below
and the method that implements the command is given.

The methods associated with the DSL follow the same general pattern.
They store the data given in the command arguments, possibly with some
validation, into data variable associated with the created class.
That data is then available to the class methods to implement
the semantics of XUML attribute access, relationship navigation
and state machine dispatch.
So it is very much a data-driven approach with the DSL commands
supplying the values of the data that determine the specific semantics
that are needed.

==== Attribute Method

The +attribute+ command is used to define the attributes of a XUML class.
It is invoked as:

(((DSL,command,attribute)))

.................
attribute attr-value-pair1 attr-value-pair2 ...
.................

+attr-value-pair ...+::
    Each +attr-value-pair+ argument is treated as a one or two element list.
    the first element gives the name of the attribute.
    If the second element of the pair is present,
    then it gives the default value for the attribute.
    If the second element is missing then the default value is the empty string.

The command may be invoked an arbitary number of times in the
configuration script.
When objects of the resulting class are created,
the attributes will be present and have their default values after
construction.
We will also see that the resulting constructor also allows us to
override the defaults at creation time.

Attribute names form a set and so duplicates are not allowed.
We also do not allow the empty string as an attribute name on
the rational that the empty string cannot convey any semantics.
Attempts to define the empty string as an attribute name or
to define a duplicate attribute name cause an error to be thrown.

Attribute names will be stored away in a dictionary.
The keys to the dictionary will be the attribute names themselves and the value
of the corresponding dictionary key element will be the default value of the
attribute.

[source,tcl]
----
<<stsaclass constructor>>=
my variable attrInfo
set attrInfo [dict create]
----

The implementation of the +Attribute+ method consists of an
interation over the arguments, validating the attribute names
and assigning the default values into the +attrInfo+ dictionary.

(((method,STSAClass,Attribute)))

[source,tcl]
----
<<stsaclass configuration>>=
method Attribute {args} {
    my variable attrInfo

    foreach attr $args {
        lassign $attr name default
        if {$name eq {}} {
            tailcall ::stsatcl::DeclError BADATTRIBUTENAME $name
        }
        if {[dict exists $attrInfo $name]} {
            tailcall ::stsatcl::DeclError DUPATTRIBUTENAME $name
        } else {
            dict set attrInfo $name $default
        }
    }
}
----
(((error code,BADATTRIBUTENAME)))
(((error code, DUPATTRIBUTENAME)))
[source,tcl]
----
<<error code format>>=
BADATTRIBUTENAME        {invalid attribute name, "%s"}
DUPATTRIBUTENAME        {duplicate attribute name, "%s"}
----

[float]
===== Attribute Method Tests

We can test the +Attribute+ method in isolation,
but this requires a bit of namespace trickery to invoke the
unexported method.
However, in Tcl nothing is really hidden.

[source,tcl]
----
<<meta constructor tests>>=
test Attribute-1.0 {
    configure multiple attributes
} -setup {
    ::stsatcl STSAClass create at1
} -cleanup {
    at1 destroy
} -body {
    [info object namespace at1]::my Attribute\
        Count {Maximum 20}
    dict size [set [info object namespace at1]::attrInfo]
} -result {2}
----

[source,tcl]
----
<<meta constructor tests>>=
test Attribute-2.0 {
    attempt to name an attribute the empty string
} -setup {
    ::stsatcl STSAClass create at2
} -cleanup {
    at2 destroy
} -body {
    [info object namespace at2]::my Attribute {}
} -result {invalid attribute name, ""} -returnCodes error
----

[source,tcl]
----
<<meta constructor tests>>=
test Attribute-3.0 {
    attempt to have duplicate attributes
} -setup {
    ::stsatcl STSAClass create at3
} -cleanup {
    at3 destroy
} -body {
    [info object namespace at3]::my Attribute Count Count
} -result {duplicate attribute name, "Count"} -returnCodes error
----

==== Reference Method

In XUML,
a relationship between two classes is conceptually bi-directional.
[[bidir-relationship, bi-directional relationship]]
The relationship defines a function (or partial function) between
the two instance sets of the classes and the idea is firmly grounded
in referential integrity ideas from the
http://en.wikipedia.org/wiki/Relational_model[Relational Model of Data].

In the implementation world,
a relationship is decomposed into _links_.
A link is uni-directional
and is included in a class if any of the class processing requires
_navigating_ the link to obtain instances of the related class.

XUML relationships also carry the notion of multiplicity and
conditionality.
So a relationship may navigate to multiple instances in one direction
and may also allow that no instances are related.
We need a way to specify whether a link reference is _singular_ or _multiple_
and whether it is _conditional_.

The +reference+ command is invoked in the XUML class configuration
script to define a linkage where one class refers to another.
The invocation synopsis is:

(((DSL,command,reference)))

................
reference rname spec dstclass
................

+rname+::
    is the name of the reference. Conventionally, references are named
    with a capital ``R'' followed by a number (_e.g._ +R42+), but any
    string may be used.
+spec+::
    is a string that designates the multiplicity and conditionality of the
    reference. It consists of a hyphen (-) followed by one or two greater
    than signs (>) followed by an optional letter ``c''.
    A _spec_ argument of ``\->'' indicates the multiplicity of the reference
    is singular.
    A _spec_ of ``\->>'' indicates a multiplicity of _many_.
    Either type of multiplicity may have a ``c'' suffix (_e.g._ ``\->>c'')
    to indicate that the reference may refer to zero instances.
+dstclass+::
    is the name of a class command to which instances refer.
    The class need not exist at the time the +reference+ command is executed.
    Unqualified class commands are resolved into the namespace of the
    creator of the class.

In this architecture,
linkage is achieved by storing the command name of the object.
We will make sure to store the fully qualified command name
even if we take unqualified names as arguments.
So one aspect of linkage is to perform the object command name
qualification.

[source,tcl]
----
<<stsaclass configuration>>=
method Qualify {cmdname {level 4}} {
    return [expr {[string range $cmdname 0 1] ne "::" ?\
        "[string trimright [uplevel $level namespace current] :]::$cmdname" :\
        $cmdname}]
}
----

Just as for attributes,
we hold the linkage information in a dictionary.
The dictionary key is the name of the linkage
and the corresponding value is also a dictionary
(yielding a nested dictionary).
We will see the structure of the nested portion of the dictionary below.

[source,tcl]
----
<<stsaclass constructor>>=
my variable linkInfo
set linkInfo [dict create]
----

The implementation of the +Reference+ method uses a regular expression
to parse the _spec_ argument syntax.
A dictionary is then created to hold the component parts of the spec.

(((method,STSAClass,Reference)))

[source,tcl]
----
<<stsaclass configuration>>=
method Reference {rname spec dstclass} {
    my variable linkInfo
    if {[dict exists $linkInfo $rname]} {
        tailcall ::stsatcl::DeclError DUPREFERENCE $rname
    }
    set dstclass [my Qualify $dstclass]

    if {![regexp -nocase -- {\A-(>{1,2})(c?)\Z} $spec match mult cond]} {
        tailcall ::stsatcl::DeclError BADREFSPEC $spec
    }
    set mult [string equal $mult ">>"]
    set cond [string equal $cond "c"]

    dict set linkInfo $rname [dict create\
        type reference\
        dest $dstclass\
        mult $mult\
        cond $cond\
    ]
}
----
(((error code,DUPREFERENCE)))
(((error code,BADREFSPEC)))
[source,tcl]
----
<<error code format>>=
DUPREFERENCE        {linkage, "%s", already exists}
BADREFSPEC          {bad reference spec, "%s"}
----

[float]
===== Reference Method Tests

Using the same techniques as for the +Attribute+ method,
we can test the +Reference+ method in isolation.
However, we must be careful to give fully qualified class names.
Otherwise since the +Qualify+ method is not being invoked at the correct level,
it will throw an error.

[source,tcl]
----
<<meta constructor tests>>=
test Reference-1.0 {
    configure a simple reference
} -setup {
    ::stsatcl STSAClass create ref1
} -cleanup {
    ref1 destroy
} -body {
    [info object namespace ref1]::my Reference R1 -> [namespace current]::foo
    dict get [set [info object namespace ref1]::linkInfo] R1
} -result {type reference dest ::stsatcl::test::foo mult 0 cond 0}
----

[source,tcl]
----
<<meta constructor tests>>=
test Reference-2.0 {
    define reference with bad syntax
} -setup {
    ::stsatcl STSAClass create ref2
} -cleanup {
    ref2 destroy
} -body {
    [info object namespace ref2]::my Reference R1 ->>x [namespace current]::foo
} -result {bad reference spec, "->>x"} -returnCodes error
----

[source,tcl]
----
<<meta constructor tests>>=
test Reference-3.0 {
    duplicated reference
} -setup {
    ::stsatcl STSAClass create ref3
} -cleanup {
    ref3 destroy
} -body {
    [info object namespace ref3]::my Reference R1 -> [namespace current]::foo
    [info object namespace ref3]::my Reference R1 -> [namespace current]::foo
} -result {linkage, "R1", already exists} -returnCodes error
----

==== Partition Method

There is one other type of linkage that must be supported.
In XUML the generalization relationship of ordinary UML is interpreted
in terms of a set partitionfootnote:[_Cf._ conventional UML that usually
interprets the general relationship as some type of _inheritance_.].
A set partion of the super class instances implies that each
instance of the super class is linked to exactly one instance of
a sub class from among all the sub classes that participate in the
generalization.
You can think of the generalization as some sort of equivalence relation.

(((DSL,command,partition)))

................
partition rname sub1 sub2 ...
................

+rname+::
    is the name of the partition. Conventionally, partitions and references are
    named with a capital ``R'' followed by a number (_e.g._ +R42+), but any
    string may be used.
    A partition and a reference may not have the same name.
+sub1 sub2 ...+::
    are the names of sub classes of the partition.
    The sub classes do not have to exist when the partition is declared.
    At least two sub classes must be given.

We will store the partition information in the same +linkInfo+ dictionary.
Together the references and partitions form the set of linkages for the
class.
For the case of a partition,
the dictionary value will have a different value for the +type+ key
and the value of the +subclasses+ key holds the set of sub classes.

We will also find it convenient to have the set of paritions defined for
a class accessible outside of the +linkInfo+ array.

[source,tcl]
----
<<stsaclass constructor>>=
my variable partitions
set partitions [list]
----

(((method,STSAClass,Partition)))

[source,tcl]
----
<<stsaclass configuration>>=
method Partition {rname args} {
    my variable linkInfo
    if {[dict exists $linkInfo $rname]} {
        tailcall ::stsatcl::DeclError DUPREFERENCE $rname
    }
    if {[llength $args] < 2} { # <1>
        tailcall ::stsatcl::DeclError PARTITION $rname
    }

    set subs [list]
    foreach sub $args {
        set sub [my Qualify $sub]
        ::struct::set include subs $sub
    }
    dict set linkInfo $rname [dict create\
        type partition\
        subclasses $subs\
    ]
    my variable partitions
    lappend partitions $rname
}
----
(((error code,PARTITION)))
[source,tcl]
----
<<error code format>>=
PARTITION       {partition, "%s", must have at least two subclasses}
----
<1> We insists that a partition have at least two sub classes.
Although, one can conceive of an improper subset as a partition,
it does not carry any reasonable semantics and so is interpreted as
a mistake.

[float]
===== Partition Method Tests

+Partition+ method testing follows the same pattern as for
the +Attribute+ and +Reference+ methods.

[source,tcl]
----
<<meta constructor tests>>=
test Partition-1.0 {
    define partition
} -setup {
    ::stsatcl STSAClass create pt1
} -cleanup {
    pt1 destroy
} -body {
    [info object namespace pt1]::my Partition R1\
            [namespace current]::sub1 [namespace current]::sub2
    dict get [set [info object namespace pt1]::linkInfo] R1
} -result {type partition subclasses {::stsatcl::test::sub1 ::stsatcl::test::sub2}}
----

[source,tcl]
----
<<meta constructor tests>>=
test Partition-2.0 {
    partition with one sub class
} -setup {
    ::stsatcl STSAClass create pt2
} -cleanup {
    pt2 destroy
} -body {
    [info object namespace pt2]::my Partition R1\
            [namespace current]::sub1
} -result {partition, "R1", must have at least two subclasses}\
-returnCodes error
----

[source,tcl]
----
<<meta constructor tests>>=
test Partition-3.0 {
    define duplicate partitions
} -setup {
    ::stsatcl STSAClass create pt3
} -cleanup {
    pt3 destroy
} -body {
    [info object namespace pt3]::my Partition R1\
            [namespace current]::sub1 [namespace current]::sub2
    [info object namespace pt3]::my Partition R1\
            [namespace current]::sub3 [namespace current]::sub4
} -result {linkage, "R1", already exists} -returnCodes error
----

==== Statemodel Method

Not all XUML classes have state behavior.
The analysis model will only define state models for classes
that have non-trivial and interesting dynamic behavior.
We would like to keep the commands that are required to define
a state model grouped together.
Although not strictly necessary,
grouping the state model commands together into a script will
help make the semantic distinction between dynamic behavior
implied by the state model and the static characteristics specified
by the attributes.

(((DSL,command,statemodel)))

................
statemodel script
................

+script+::
    A script invoking commands used to specify a Moore style state model.

We will want to execute +STSAClass+ methods to handle the
state model specification just as we did for attributes and references.
However,
we want to insure that the state model configuration script does
not execute any other configuration commands (_e.g._ we don't want
+attribute+ commands imbedded in the state model configuration script).
To do this, we will put the state model configuration commands
in a namespace that is a child of the class namespace and evaluate
the state model configuration script in that namespace.

The bit of trickery required for this is similar to that used
in the +link+ command.
Indeed the code below is a simple variation on the +tcllib+ source
for the +oo::util link+ procedure.
Here we define a +linkTo+ helper procedure that specifies a child
namespace were we wish to evaluate the linked commands.

[source,tcl]
----
<<stsatcl commands>>=
proc ::oo::Helpers::linkTo {childns args} {   # <1>
    set childns [string trim $childns :]    ; # <2>
    namespace eval $childns {}              ; # <3>
    set ns [uplevel 1 {namespace current}]
    foreach link $args {
	if {[llength $link] == 2} {
	    lassign $link src dst
	} else {
	    lassign $link src
	    set dst $src
	}
	interp alias {} ${ns}::${childns}::$src {} ${ns}::my $dst ; # <4>
    }
    return
}
----
<1> _N.B._ we put this procedure into a namespace that is accessible to
all TclOO objects.
<2> Clean up any extraneous colon characters. We definitely don't want
any leading colons as that would imply a fully-qualified namespace name.
<3> Make sure to create the namespace.
<4> Link the command in the child namespace back to a class method.

With the ability to link commands to a child namespace,
we can now define the state model configuration commands.

[source,tcl]
----
<<stsaclass constructor>>=
linkTo smdsl\
    {state State}\
    {transition Transition}\
    {defaultTrans DefaultTrans}\
    {initialState InitialState}\
    {terminal Terminal}
----

With all these preliminaries out of the way,
the +Statemodel+ method simply consists of evaluating a +script+
in the proper child namespace that resolves the commands
required to specify the state behavior.
We will discuss those commands in detail <<smdsl,below>>.

(((method,STSAClass,Statemodel)))

[source,tcl]
----
<<stsaclass configuration>>=
method Statemodel {script} {
    namespace eval [namespace current]::smdsl $script
}
----

[float]
===== Statemodel Method Tests

Here we will only test that the statemodel script is evaluated in
the proper child namespace.
After presenting the code for the individual state model definition
commands we will have more extensive tests.

[source,tcl]
----
<<meta constructor tests>>=
test Statemodel-1.0 {
    insure the statemodel script executes in the correct namespace
} -setup {
    ::stsatcl STSAClass create sm1
} -cleanup {
    sm1 destroy
} -body {
    [info object namespace sm1]::my Statemodel {
        puts -nonewline [namespace tail [namespace current]]
        attribute Foo Bar
    }
} -result {invalid command name "attribute"} -output {smdsl} -returnCodes error
----

==== Polymorphic Method

The semantics of dynamic actions in XUML supports only one type of polymorphism
and it takes the form of events that are directed at a super class.
Super class events that are declared as polymorphic are propagated,
at runtime,
to the sub class instance to which the target super class is currently
related.
This idea is only valid for those classes that are the super class
in a generalization relationship.
From a methodology point of view,
there is much to say about polymorphic events.
However from an implemementation architecure point of view,
they amount to little more than factoring some common code in to
the event dispatch.

The +polymorphic+ command is used to declare those events that
are intended to be treated as polymorphic with respect to their sub classes.

(((DSL,command,polymorphic)))

................
polymorphic event1 event2 ...
................

+event1 event2 ...+::
    the names of events that are to be treated polymorphically.

It is sufficient simply to store the event names as a set.

[source,tcl]
----
<<stsaclass constructor>>=
my variable polyEvents
set polyEvents [list]
----

(((method,STSAClass,Polymorphic)))

[source,tcl]
----
<<stsaclass configuration>>=
method Polymorphic {args} {
    my variable polyEvents
    ::struct::set add polyEvents $args
}
----

[float]
===== Polymorphic Method Tests

[source,tcl]
----
<<meta constructor tests>>=
test Polymorphic-1.0 {
    define polymorphic events
} -setup {
    ::stsatcl STSAClass create pm1
} -cleanup {
    pm1 destroy
} -body {
    [info object namespace pm1]::my Polymorphic e1 e2
    llength [set [info object namespace pm1]::polyEvents]
} -result {2}
----

==== InstOp Method

Instance based operations in XUML allow code common to all instances
to be factored into one place.

(((DSL,command,instop)))

................
instop name arglist body
................

+name+::
    The name of the instance operation.
+arglist+::
    A list of formal parameters to the instance operation in the
    style of the +proc+ command.
+body+::
    A Tcl script that executes when the instance operation is invoked.

The direct implementation of an instance operation as a +method+ is used.
TclOO provides all the machinery here and we just need to
pass the parameter along.

(((method,STSAClass,InstOp)))

[source,tcl]
----
<<stsaclass configuration>>=
method InstOp {name arglist body} {
    tailcall ::oo::define [self] method $name $arglist $body ; # <1>
}
----
<1> Note here that +::oo::define+ is used to declare the instance operation.
Because we are constructing a class,
we want the instance operation to be realized as part of the
configuration of the class being constructed.
Configuring the method into the class will insure that the method is available
to created instances.
This is just one of the mind-binding aspects of meta-classes.

[float]
===== InstOp Method Tests

[source,tcl]
----
<<meta constructor tests>>=
test InstOp-1.0 {
    define instance operation
} -setup {
    ::stsatcl STSAClass create io1
} -cleanup {
    io1 destroy
} -body {
    [info object namespace io1]::my InstOp print {a} {puts -nonewline $a}
    io1 create inst-io1
    inst-io1 print alpha
    expr {"print" in [info object methods inst-io1 -all]}
} -result {1} -output {alpha}
----

==== ClassOp Method

By analogy to instance based operations,
XUML allows for class based operations.
This is code that common to the class and independent of the instances.
These types of operations are not common,
but serve a role providing, for example, improved access to instance
queries.

(((DSL,command,classop)))

................
classop name arglist body
................

+name+::
    The name of the class based operation.
+arglist+::
    A list of formal parameters to the instance operation in the
    style of the +proc+ command.
+body+::
    A Tcl script that executes when the operation is invoked.

The direct implementation of a class based operation as a +method+ is used.
Again, TclOO provides all the machinery here.

(((method,STSAClass,ClassOp)))

[source,tcl]
----
<<stsaclass configuration>>=
method ClassOp {name arglist body} {
    tailcall ::oo::objdefine [self] method $name $arglist $body ; # <1>
}
----
<1> Compare this with the implementation of the +InstOp+ method.
In this case we want the class based operation to be available to
the class that is under construction.
As classes are objects themselves under TclOO,
we then need to define the method on the class object itself
using +::oo::objedefine+

[float]
===== ClassOp Method Tests

[source,tcl]
----
<<meta constructor tests>>=
test ClassOp-1.0 {
    define class based operation
} -setup {
    ::stsatcl STSAClass create co1
} -cleanup {
    co1 destroy
} -body {
    [info object namespace co1]::my ClassOp print {a} {puts -nonewline $a}
    co1 print beta
    expr {"print" in [info object methods co1]}
} -result {1} -output {beta}
----

=== State Model Configuration DSL [[smdsl,State Model DSL]]

Now that we have covered all the first level class configuration
commands,
we can turn our attention to the commands used to configure a state model.
Recall that the +statemodel+ command takes a script and that script
should invoke the commands discussed here to specify the state model
for a class.

The type of state model defined by these commands is a
http://en.wikipedia.org/wiki/Moore_machine[Moore] type.
This means that the processing associated with the
state is executed when the state is entered.
XUML has a long history of using this formulation of
state models and specifically eschews hierarchical state models.
We follow the syntax and conventions of the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/doc/tip/oomoore/wiki/intro.wiki[+oomoore+]
package.
Indeed, most of the code for configurating and dispatching events to
state models was take from that package and adapted here.

The commands to specify a state model are:

* state -> define a state and the action executed when it is entered.
* transition -> define the transition between states that an event causes.
* defaultTrans -> specify the default transition.
* initialState -> specify the state where a machine starts.
* terminal -> specify states where an object is deleted.

The state model script may contain invocation of these commands in any
order.
The invocation summaries for each command is given in the sections below.

==== State Method

The +State+ method is used to specify the states of the state model.
States may have arguments and will execute the provided Tcl script
when the state is entered.

(((DSL,command,state)))

................
state name arglist body
................

+name+::
    the name of the state. The names, ``IG'', ``CH'' and ``@'' are reserved.
    The reserved state names are discussed as part of the +transition+
    command.

+arglist+::
    a list of parameters in the style of the +proc+ command.
    Events that cause a transition into the state must supply actual
    argument values that correspond to the parameters.

+body+::
    a script that is executed when the state is entered.

We use a variable to hold the set of defined states.
Order is important here because we will choose
to use the first defined state as the default initial state
if one is not explicitly declared.

[source,tcl]
----
<<stsaclass constructor>>=
my variable states
set states [list]
----

(((method,STSAClass,State)))

[source,tcl]
----
<<stsaclass configuration>>=
method State {name argList body} {
    my variable states
    if {$name in {IG CH @}} {
        tailcall ::stsatcl::DeclError RESERVED_STATE $name
    } elseif {$name in $states} {
        tailcall ::stsatcl::DeclError DUPLICATE_STATE $name
    } else {
        lappend states $name  ; # <1>
        ::oo::define [self] method ${name}__STATE__ $argList $body ; # <2>
        ::oo::define [self] unexport ${name}__STATE__              ; # <3>
    }
}
----
(((error code,RESERVED_STATE)))
(((error code,DUPLICATE_STATE)))
[source,tcl]
----
<<error code format>>=
RESERVED_STATE      {states may not be named by the reserved name, "%s"}
DUPLICATE_STATE     {duplicate state, "%s"}
----
<1> We don't use the +::struct::set+ operations so as to guarantee the
order of the state name list.
<2> State actions just become methods of the class being created.
Again, we just use the existing TclOO facilities.
However, we do want to insure that the method names for state actions
do not interfer with any other method definitions that might arise
from instance operations.
<3> State action methods should *not* be invoked from outside of the
object.
They also should *not* be invoked directly as methods.
It is not possible to hide things completely,
but an unexported, contrived name is intended to make sure you have to
work a little harder to circumvent the design intent.

[float]
===== State Method Tests

[source,tcl]
----
<<meta constructor tests>>=
test State-1.0 {
    define state
} -setup {
    ::stsatcl STSAClass create st1
} -cleanup {
    st1 destroy
} -body {
    [info object namespace st1]::my Statemodel {
        state s1 {} {
            puts "in state s1"
        }
    }
    set isdef [expr {"s1" in [set [info object namespace st1]::states]}]
    set hasmeth [expr {"s1__STATE__" in [info class methods st1 -private]}]
    expr {$isdef && $hasmeth}
} -result {1}
----

[source,tcl]
----
<<meta constructor tests>>=
test State-2.0 {
    define state with reserved name
} -setup {
    ::stsatcl STSAClass create st2
} -cleanup {
    st2 destroy
} -body {
    [info object namespace st2]::my Statemodel {
        state IG {} {}
    }
} -result {states may not be named by the reserved name, "IG"}\
-returnCodes error
----

[source,tcl]
----
<<meta constructor tests>>=
test State-3.0 {
    define state with reserved name
} -setup {
    ::stsatcl STSAClass create st3
} -cleanup {
    st3 destroy
} -body {
    [info object namespace st3]::my Statemodel {
        state Idle {} {}
        state Idle {a b} {puts "$a $b"}
    }
} -result {duplicate state, "Idle"} -returnCodes error
----

==== Transition Method

The +Transition+ method is used to specify how the state model
transitions when it receives events.
It is useful to consider the possible transitions that a state
model may make to be a matrix where the rows of the matrix are
labeled by state names and columns are labeled by event names.
The matrix entry at the intersection of each row and column is the
name of the new state to which the state machine will enter.
It is not necessary to specify the entire _states_ by _events_ matrix.
A default entry may be specified for the missing entries.

There are a few more rules about state model transitions. The ``IG''
state denotes that an event is to be ignored.
The ``CH'' state asserts that the event can never happen in a state
and if it does then it is an error.
Neither of these state cause a transition, despite their being
used as the target of a transition.
The ``@'' state denotes the initial pseudo-state into which a new
asynchronously created state machine is placed.
There is never an action associated with the ``@'' state
(hence it is called a pseudo-state).

(((DSL,command,transition)))

................
transition current - event -> target
................

+current+::
    The state name from which the transition arises.
    The special states, *IG* and *CH* are not allowed for this argument.
+event+::
    The event name that causes the transition.
+target+::
    The state to which the transition is made.
    The special state *@* is not allowed as a target.

The ``-'' and ``\->'' arguments are literally required but
only serve as syntactic sugar.
The command asserts that when the state model is in the _current_ state
and receives the _event_ event it is to transition to the _target_ state.
_N.B._ that _current_ and _target_ may be the same state.
In that case,
the _event_ causes the
the state to be reentered and its action is executed again.

This configuration command will fill in two pieces of data.
There is no special configuration command to declare events.
They are simply picked up from the transition command.
The transitions themselves are stored in an array
indexed by the values of both the _current_ and _event_ arguments.

[source,tcl]
----
<<stsaclass constructor>>=
my variable events
set events [list]
my variable transitions
array set transitions {}
----

(((method,STSAClass,Transition)))

[source,tcl]
----
<<stsaclass configuration>>=
method Transition {current - event -> target} {
    if {$current in {IG CH}} {
        tailcall ::stsatcl::DeclError TRANS_SRC $current
    } elseif {$current eq "@"} { # <1>
        my variable states
        ::struct::set include states $current
    }

    if {$target eq "@"} {
        tailcall ::stsatcl::DeclError TRANS_DST
    }
    my variable events
    ::struct::set include events $event ; # <2>

    my variable transitions
    if {[info exists transitions($current,$event)]} {
        tailcall ::stsatcl::DeclError DUPLICATE_TRANS $current $event
    } else {
        set transitions($current,$event) $target ; # <3>
    }
}
----
(((error code,TRANS_SRC)))
(((error code,TRANS_DST)))
(((error code,DUPLICATE_TRANS)))
[source,tcl]
----
<<error code format>>=
TRANS_SRC           {a transition cannot originate from the "%s" pseudo-state}
TRANS_DST           {the initial pseudo-state, "@", cannot be the\
                     target of a transition}
DUPLICATE_TRANS     {duplicate transition, "%s - %s"}
----
<1> The only valid place were the ``@'' state may be specified is as the
_current_ state in a +transition+ command.
If it shows up we need to record that fact.
<2> Event names are collected from all the transition statements but they
form a set.
<3> The transition array is indexed in the conventional pseudo-two dimensional
way.

[float]
===== Transition Method Tests

[source,tcl]
----
<<meta constructor tests>>=
test Transition-1.0 {
    define transition
} -setup {
    ::stsatcl STSAClass create tr1 {}
} -cleanup {
    tr1 destroy
} -body {
    [info object namespace tr1]::my Statemodel {
        transition s1 - e1 -> s1
    }
    set hasevent [expr {"e1" in [set [info object namespace tr1]::events]}]
    set hastrans\
        [expr {[set [info object namespace tr1]::transitions(s1,e1)] eq "s1"}]
    expr {$hasevent && $hastrans}
} -result {1}
----

[source,tcl]
----
<<meta constructor tests>>=
test Transition-2.0 {
    define transition -- bad source state
} -setup {
    ::stsatcl STSAClass create tr2 {}
} -cleanup {
    tr2 destroy
} -body {
    [info object namespace tr2]::my Statemodel {
        transition IG - e1 -> s1
    }
} -result {a transition cannot originate from the "IG" pseudo-state}\
-returnCodes error
----

[source,tcl]
----
<<meta constructor tests>>=
test Transition-3.0 {
    define transition -- bad source state
} -setup {
    ::stsatcl STSAClass create tr3 {}
} -cleanup {
    tr3 destroy
} -body {
    [info object namespace tr3]::my Statemodel {
        transition s1 - e1 -> @
    }
} -result {the initial pseudo-state, "@", cannot be the target of a transition}\
-returnCodes error
----

[source,tcl]
----
<<meta constructor tests>>=
test Transition-4.0 {
    define transition -- duplicate transition
} -setup {
    ::stsatcl STSAClass create tr4 {}
} -cleanup {
    tr4 destroy
} -body {
    [info object namespace tr4]::my Statemodel {
        transition s1 - e1 -> s1
        transition s1 - e1 -> s2
    }
} -result {duplicate transition, "s1 - e1"} -returnCodes error
----

==== DefaultTrans Method

It is not necessary to specify all the entries of the conceptual
transition matrix for a state model.
Any unspecified entries will default to ``CH''.
However, sometimes it is more convenient to specify ``IG'' as the
default transition.
The +DefaultTrans+ method allows you to set the default transition
to either ``CH'' or ``IG''.

(((DSL,command,defaultTrans)))

................
defaultTrans trans
................

+trans+::
    Either ``IG'' or ``CH'' may be specified as the default transition.

A simple variable is used to hold the default transition.
That variable is initialized to ``CH''.

[source,tcl]
----
<<stsaclass constructor>>=
my variable defaulttrans
set defaulttrans CH
----

(((method,STSAClass,DefaultTrans)))

[source,tcl]
----
<<stsaclass configuration>>=
method DefaultTrans {trans} {
    if {$trans in {IG CH}} {
        my variable defaulttrans
        set defaulttrans $trans
    } else {
        tailcall ::stsatcl::DeclError BAD_DEFAULT_TRANS $trans
    }
}
----
(((error code,BAD_DEFAULT_TRANS)))
[source,tcl]
----
<<error code format>>=
BAD_DEFAULT_TRANS       {bad default transition name, "%s": must be one of\
                         "IG" or "CH"}
----

==== InitialState Method

(((DSL,command,initialState)))

................
initialState state
................

+state+::
    The state name into which newly create instances are placed.

[source,tcl]
----
<<stsaclass constructor>>=
my variable initialstate
set initialstate {}
----

(((method,STSAClass,InitialState)))

[source,tcl]
----
<<stsaclass configuration>>=
method InitialState {state} {
    if {$state in {IG CH @ {}}} {
        tailcall ::stsatcl::DeclError BAD_INIT_STATE $state
    }
    my variable initialstate
    set initialstate $state
}
----
(((error code,BAD_INIT_STATE)))
[source,tcl]
----
<<error code format>>=
BAD_INIT_STATE      {initial state, "%s", cannot be "IG", "CH", "@" or empty}
----

==== Terminal Method

(((DSL,command,terminal)))

................
terminal state1 state2 ...
................

+state+::
    The name of a state that is to be deemed a terminal state.
    When an instance transitions into a terminal state,
    it is destroyed at the completion of the state action.

[source,tcl]
----
<<stsaclass constructor>>=
my variable terminals
set terminals [list]
----

(((method,STSAClass,Terminal)))

[source,tcl]
----
<<stsaclass configuration>>=
method Terminal {args} {
    foreach state $args {
        if {$state in {IG CH @ {}}} {
            tailcall ::stsatcl::DeclError BAD_TERM_STATE $state
        }
    }
    my variable terminals
    ::struct::set add terminals $args
}
----
(((error code,BAD_TERM_STATE)))
[source,tcl]
----
<<error code format>>=
BAD_TERM_STATE  {terminal state, "%s", cannot be "IG", "CH", "@" or empty}
----

=== Completing Construction

At this point we have now covered all the commands that are used
to construct a configuration script used to create a new XUML class.
These commands all follow the same pattern, namely
they validate their inputs as possible and store away argument values
into appropriate data structures.

Now we consider what needs to be done to complete constructing
the new class.

First, we evaluate the configuration script in the namespace of the
newly created class.

[source,tcl]
----
<<stsaclass constructor>>=
my eval $config
----

This will cause the various configuration command methods to be invoked.
The next step is to continue with some semantic validation.
It is still possible to incorrectly specify parts of the configuration
and that cannot be determined on a command by command basis.
Like any language it is quite possible to make syntactically correct
statements that are still meaningless.

We divide the remaining evaluation into parts that parallel the
configuration, _i.e._ attributes, linkage, state models and polymorphic events.

[source,tcl]
----
<<stsaclass constructor>>=
<<attribute semantics>>
<<linkage semantics>>
<<state model semantics>>
<<polymorphic semantics>>
define [self] {
    <<utility methods>>
}
----


Each of these categories is discussed below.

==== Attribute Semantics

If the XUML class declares any attributes,
we want to make them instance variables.

[source,tcl]
----
<<attribute semantics>>=
if {[dict size $attrInfo] != 0} {
    define [self] {
        <<attribute access methods>>
    }
}
----

We will discuss the class method that will be provided to access
attributes below.
Here we note that if no attributes are declared,
then the methods will not be part of the interface for objects created
from the class.

==== Linkage Semantics

For +reference+ and +partition+ definitions,
we want to include the methods used to create and _traverse_ the linkage
into the created class.
These methods are described below.

[source,tcl]
----
<<linkage semantics>>=
if {[dict size $linkInfo] != 0} {
    define [self] {
        <<linkage access methods>>
    }
}
----

==== State Model Semantics

For state models,
there is a bit more work to do to insure that a consistent model
has been defined.

[source,tcl]
----
<<state model semantics>>=
if {[llength $states] != 0 || [llength $polyEvents] != 0} {
    <<validate transitions>>
    <<compute transition matrix>>
    <<validate initial state>>
    <<validate terminal states>>
    <<creation events>>
    objdefine [self] {
        <<in state creation methods>>
    }
    define [self] {
        <<state model methods>>
    }
}
----

We first insure that no isolated states were defined.
Isolated state are those that have no incoming or outgoing transitions.
Such state are not reachable and indicated a specification error.

The strategy to compute isolated state is to find all the states that
have out-bound transitions and all the states that have in-bound
transitions.
This can be determined by look at the values of +transitions+.

[source,tcl]
----
<<validate transitions>>=
set outstates [list]
set instates [list]
foreach {trans dst} [array get transitions] {
    lassign [split $trans ,] src event
    if {$src ni $states} { # <1>
        tailcall ::stsatcl::DeclError UNKNOWN_SRC_STATE $src $event $dst
    }
    ::struct::set include outstates $src
    if {$dst ni {IG CH}} { # <2>
        if {$dst ni $states} {
            tailcall ::stsatcl::DeclError UNKNOWN_DST_STATE $src $event $dst
        } else {
            ::struct::set include instates $dst
        }
    }
}
----
(((error code,UNKNOWN_SRC_STATE)))
(((error code,UNKNOWN_DST_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_SRC_STATE       {unknown source state in transition, "%s - %s -> %s"}
UNKNOWN_DST_STATE       {unknown target state in transition, "%s - %s -> %s"}
----
<1> While we are iterating across the transitions,
check that they are consistent with the set of defined states.
We have to defer this until here so there will not be any
order dependency in the configuration language.
<2> Skip the non-transitioning pseudo-states of IG and CH.

Next, we compute the set of states with no in-bound transitions
and the set with no out-bound transitions.
The set of states with no in-bound transitions is just the difference
between the set of all states and those that do have in-bound
transitions.
Similarly the set of states with no out-bound transitions is computed.

[source,tcl]
----
<<validate transitions>>=
set noincoming [::struct::set difference $states $instates]
set nooutgoing [::struct::set difference $states $outstates]
----

Finally,
isolated states are those which have not in-bound or out-bound
transitions.
This is just the intersection of the two sets we just computed.

[source,tcl]
----
<<validate transitions>>=
set isostates [::struct::set intersect $noincoming $nooutgoing]
if {![::struct::set empty $isostates]} {
    tailcall ::stsatcl::DeclError ISOLATED $isostates
}
----
(((error code,ISOLATED)))
[source,tcl]
----
<<error code format>>=
ISOLATED        {state model has isolated state(s): "%s"}
----

During state machine event dispatch,
we will find it much more convenient to find a new target state
if the entire transition matrix is completely populated.
So we use this opportunity to fill in any missing transitions
with the default transition.

[source,tcl]
----
<<compute transition matrix>>=
foreach s $states {
    foreach e $events {
        if {![info exists transitions($s,$e)]} {
            set transitions($s,$e) $defaulttrans
        }
    }
}
----

We also have to validate that the initial state is reasonable.
This is another situation where we must defer the check until after
the configuration script is executed to avoid imposing some
arbitrary order onto the configuration commands in a script.
We can also now say that if the initial state has not been explicitly
defined,
then we will take the first defined state as the initial one.

[source,tcl]
----
<<validate initial state>>=
if {$initialstate eq {}} {
    set initialstate [lindex $states 0]
} elseif {$initialstate ni $states} {
    tailcall ::stsatcl::DeclError UNKNOWN_INIT_STATE $initialstate
}
----
(((error code,UNKNOWN_INIT_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_INIT_STATE      {unknown initial state, "%s"}
----

We must insure that the set of terminal states
is a subset of the set of all states.
This will make sure that no undefined states are included in the
terminal state set.

[source,tcl]
----
<<validate terminal states>>=
if {![::struct::set subsetof $terminals $states]} {
    set unknown [::struct::set difference $terminals $states]
    tailcall ::stsatcl::DeclError UNKNOWN_TERM_STATE $unknown
}
----
(((error code,UNKNOWN_TERM_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_TERM_STATE      {unknown terminal states, "%s"}
----

Finally, we deal with *creation* events.
Creation events allow class instances to be created asynchronously.
In this architecture,
a creation event implies creating a new instance,
placing that instance in the ``@'' pseudo-initial state
and signalling an event to the instance.
Creation events are consequently directed at the class.
Here we test to see if the ``@'' pseudo-initial state is present
and if so, we then need to have a method to handle the asynchronous creation.

[source,tcl]
----
<<creation events>>
if {"@" in $states} {
    objdefine method signal {event args} {
        set inst [[self] newin @]
        $inst signal $event {*}$args
    }
}
----

==== Polymorphic Event Semantics

Defining polymorphic events only makes sense if there is at least
one partition defined for the class.

[source,tcl]
----
<<polymorphic semantics>>=
set commonEvents [::struct::set intersect $polyEvents $events]
if {![::struct::set empty $commonEvents]} {
    tailcall ::stsatcl::DeclError COMMON_EVENTS $commonEvents
}
if {[llength $polyEvents] != 0 && [llength $partitions] == 0} {
    tailcall ::stsatcl::DeclError BAD_POLY_EVENTS $polyEvents
}
----
(((error code,COMMON_EVENTS)))
(((error code,BAD_POLY_EVENTS)))
[source,tcl]
----
<<error code format>>=
COMMON_EVENTSA      {polymorphic events and ordinary events have the same name,\
                     "%s"}
BAD_POLY_EVENTS     {polymorphic events, "%s", are defined,\
                     but there are no defined partition linkages}
----

== XUML Class Methods

We have now completed the mini-DSL that is used configure
an XUML class.
To recap,
the +STSAClass+ is a meta-class that, as part of its construction,
accepts a configuration script.
That configuration script invokes commands that together form a small domain
specific language (DSL) to describe the data and dynamics that the
newly create class is to have.
We refer, collectively, to those newly created classes as _XUML classes_.

In the following section we describe the methods that the XUML classes have.
These are methods that are common to all XUML classes.
Recall that the +instop+ and +classop+ DSL commands can be used to
object methods and class methods, respectively, to a particular XUML class.
The common methods deal, not unsurprisingly, with the access to
the data and dynamics that are specified by configuration DSL.

First we deal with creating objects and the variations on construction
that are supported.
Afterwards we follow the set of topics that we have already established.
There are methods to deal with attributes, linkage and state model
dynamics and sections will be devoted to each of these topics.
Then we explain methods that are used to obtain sets of object
instances, either selecting them by some criteria or selected
related instances for some criteria.
Lastly, we look a methods for computing on sets of instances.

=== Creating Objects

In this section we deal with constructing an object from an XUML class.
We need to be clear of that distinction given how much of our
effort so far has been devoted to constructing the XUML class itself
from the +STSAClass+ meta-class.

==== Constructor

The constructor for an XUML class is invoked when the +create+ or +new+
method is used to generate an object, as in:

=====================
+STSAClass create+ _xumlclass_ +{ ...+ _configuration script_ +...}+

_xumlclass_ +create+ _objname_ _attr1 value1 attr2 value2 ..._

_xumlclass_ +new+ _attr1 value1 attr2 value2 ..._
=====================

+attr value ...+::
    a set of attribute name / attribute value pairs.
    If supplied, then the values will override any default value
    set for the attribute.

The constructor deals, roughly speaking, with the same
areas that the configuration DSL deals with, namely,
attributes, linkages and state model.

(((method,XUMLClass,constructor)))

[source,tcl]
----
<<stsaclass constructor>>=
define [self] constructor {args} {
    <<attribute initialization>>
    <<linkage initialization>>
    <<state model initialization>>
}
----

Recall that in the +STSAClass+ constructor,
any attributes were declared to be a class +variable+.
This means that the underlying TclOO mechanism
will make the variable available to all methods of the
class, including the constructor.
Here, we need to set up values for the attributes.
The value an attribute has will either be its default value
(which will be the empty string if no default was supplied)
or the value given in the arguments to +create+ or +new+.

The easy way to accomplish this is to merge the dictionary supplied
by +args+ onto the +attrInfo+ dictionary.
The +dict merge+ command does the overriding as we want.

[source,tcl]
----
<<attribute initialization>>=
classvariable attrInfo  ; # <1>

if {[dict size $attrInfo] != 0} { # <2>
    dict for {attrName defValue} [dict merge $attrInfo $args] {
        if {[dict exists $attrInfo $attrName]} { # <3>
            my variable $attrName
            set $attrName $defValue
        } else {
            tailcall ::stsatcl::DeclError UNKNOWN_ATTRIBUTE $attrName
        }
    }
}
----
(((error code,UNKNOWN_ATTRIBUTE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_ATTRIBUTE        {unknown attribute, "%s"}
----
<1> From the point of view of the an object of an XUML class,
the attribute information gleened from the DSL commands
is stored in a variable in the class.
The +oo::util+ package provides the +classvariable+ command
to conveniently create a reference to the proper variable in the class.
We will use this construct many more times and it insures that
all the objects of the XUML class work off of the same configuration
information.
<2> If no attributes were defined when the class was configured,
then no +variables+ will have been defined and we ignore
any supplied arguments.
<3> We need to check if the attribute name is valid since the caller
may have included an unknown attribute in argument list and after
the dictionary merge it would show up here.

[float]
===== Constructor Attribute Tests

[source,tcl]
----
<<constructor tests>>=
test constructor-1.0 {
    create an instance with attributes
} -setup {
    stsatcl STSAClass create test5 {
        attribute Count {Maximum 20}
    }
} -cleanup {
    test5 destroy
} -body {
    test5 create inst5
    set [info object namespace inst5]::Maximum
} -result {20}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-1.1 {
    create an instance with attributes -- override values
} -setup {
    stsatcl STSAClass create test5 {
        attribute Count {Maximum 20}
    }
} -cleanup {
    test5 destroy
} -body {
    test5 create inst5 Maximum 30
    set [info object namespace inst5]::Maximum
} -result {30}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-1.2 {
    error overriding attributes
} -setup {
    stsatcl STSAClass create test5 {
        attribute Count {Maximum 20}
    }
} -cleanup {
    test5 destroy
} -body {
    test5 create inst5 Foo 30
} -result {unknown attribute, "Foo"} -returnCodes error
----

The object command names that make up the linkage information are
stored in variables by the same name as the linkage.
So we must initialize these variables.

[source,tcl]
----
<<linkage initialization>>=
classvariable linkInfo

foreach linkName [dict keys $linkInfo] {
    my variable $linkName
    set $linkName {}
}
----

[float]
===== Constructor Linkage Tests

[source,tcl]
----
<<constructor tests>>=
test constructor-2.0 {
    create an instance with a reference
} -setup {
    stsatcl STSAClass create ct2 {
        reference R42 -> foo
    }
} -cleanup {
    ct2 destroy
} -body {
    ct2 create inst2
    info exists [info object namespace inst2]::R42
} -result {1}
----

One of the more significant aspects of an XUML class is its
ability to dispatch events into a state machine.
There is substantial machinery required to do this
and we devote much text below to the details of how the
state machine execution is implemented on top of Tcl.
We will defer that discussion until later,
but during object construction we must do some initialization
of the state machine execution mechanism.

What we will discuss here is the notion of the current state
of an object.
All objects of an XUML class have the same state model behavior.
However, each object can be in a state that is different from that
of any other object.
This means we need a variable to hold the current state
that is part of the object

[source,tcl]
----
<<state model initialization>>=
classvariable states
if {[llength $states] != 0} {
    my variable __currentstate__
    # Set the initial state to the default
    classvariable initialstate
    set __currentstate__ $initialstate

    <<binding state machine events>>
}
----

When an object is created from an XUML class using +create+ or +new+
it's current state is set to be the initial state defined
by the +initialState+ commandfootnote:[or the first state defined
if the +initialState+ command is not invoked].
_N.B._ that any action associated with the initial state is *not*
executed.
We will also see <<construct-in-state,below>>
that the +createin+ and +newin+ methods can be used to
create an object in some state other than its default initial state.
We will also see that it is possible to create objects asychronously
and, in that case, we will be able to cause some processing to happen
immediately after creation.

[float]
===== Constructor State Tests

[source,tcl]
----
<<constructor tests>>=
test constructor-3.0 {
    define a state model -- defined initial state
} -setup {
    stsatcl STSAClass create test6 {
        statemodel {
            state s1 {} {
                puts "[self] in s1"
            }
            transition s1 - e1 -> s2

            state s2 {a} {
                puts $a
            }
            transition s2 - e2 -> s1

            initialState s2
        }
    }
} -cleanup {
    test6 destroy
} -body {
    test6 create inst6
    set [info object namespace inst6]::__currentstate__
} -result {s2}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-3.1 {
    define a state model -- default initial state
} -setup {
    stsatcl STSAClass create test6 {
        statemodel {
            state s1 {} {
                puts "[self] in s1"
            }
            transition s1 - e1 -> s2

            state s2 {a} {
                puts $a
            }
            transition s2 - e2 -> s1
        }
    }
} -cleanup {
    test6 destroy
} -body {
    test6 create inst6
    set [info object namespace inst6]::__currentstate__
} -result {s1}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-3.2 {
    define state model -- check transition
} -setup {
    stsatcl STSAClass create test6 {
        attribute Count {Maximum 20}
        statemodel {
            state s1 {} {
                puts "[self] in s1"
            }
            transition s1 - e1 -> s1
        }
    }
} -cleanup {
    test6 destroy
} -body {
    test6 create inst6
    set [info object namespace test6]::transitions(s1,e1)
} -result {s1}
----

==== Constructing in a State [[construct-in-state,Constructing in a State]]

XUML execution semantics support the idea of creating an object
in a specified state.
The XUML classes here support that notion by
augmenting +create+ and +new+ with the +createin+ and +newin+ methods.
It is worth repeating that creating an object either its default
initial state or a specified state does *not* execute any action
associated with the state.
The initial state only determines how the object reacts to events
in the future.

=====================
+STSAClass create+ _xumlclass_ +{ ...+ _configuration script_ +...}+

_xumlclass_ +createin+ _objname_ _initialstate attr1 value1 attr2 value2 ..._

_xumlclass_ +newin+ _initialstate attr1 value1 attr2 value2 ..._
=====================

+initialstate+::
    the name of the state into which the newly created object is place.

The implementation strategy for these methods is to use the
+create+ and +new+ methods and then, after construction, set the
current state to the given _initialstate_.

(((method,XUMLClass,createin)))

[source,tcl]
----
<<in state creation methods>>=
method createin {name initialstate args} {
    my variable states
    if {$initialstate in $states} { # <1>
        if {[string range $name 0 1] ne "::"} {
            set ns [string trimright [uplevel 1 namespace current] :]
            set name ${ns}::${name}
        }
        set inst [my create $name {*}$args]
        set [info object namespace $inst]::__currentstate__ $initialstate
    } else {
        tailcall ::stsatcl::DeclError UNKNOWN_STATE $initialstate $states
    }

    return $inst
}
----
(((error code,UNKNOWN_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_STATE   {unknown state, "%s\", should be one of, "%s"}
----
<1> We must deal with the complication that _name_ may not be fully
qualified.
If we hand an unqualified name to +create+ it will resolve it to the
namespace in which we are running rather than the namespace of the
caller.
We have to undertake the desired namespace resolution here so that
+create+ will see a fully-qualified name.

(((method,XUMLClass,newin)))

[source,tcl]
----
<<in state creation methods>>=
method newin {initialstate args} {
    my variable states
    if {$initialstate in $states} {
        set inst [my new {*}$args]  ; # <1>
        set [info object namespace $inst]::__currentstate__ $initialstate
    } else {
        tailcall ::stsatcl::DeclError UNKNOWN_STATE $initialstate $states
    }

    return $inst
}
----
<1> Unlike +createin+, here we can depend upon +new+ creating an object
name automatically.

[float]
===== In State Constructor Tests

[source,tcl]
----
<<constructor tests>>=
test constructor-4.0 {
    create an instance in a given state
} -setup {
    stsatcl STSAClass create test4 {
        statemodel {
            state sA {} {
                puts "[self] in sA"
            }
            transition sA - e1 -> sB

            state sB {a} {
                puts $a
            }
            transition sB - e2 -> sA

            initialState sB
        }
    }
} -cleanup {
    test4 destroy
} -body {
    test4 createin inst4 sA
    set [info object namespace inst4]::__currentstate__
} -result {sA}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-4.1 {
    create an instance in a given state using newin
} -setup {
    stsatcl STSAClass create test4 {
        statemodel {
            state sA {} {
                puts "[self] in sA"
            }
            transition sA - e1 -> sB

            state sB {a} {
                puts $a
            }
            transition sB - e2 -> sA

            state sC {b} {
                puts $b
            }
            transition sC - e1 -> sB

            initialState sB
        }
    }
} -cleanup {
    test4 destroy
} -body {
    set inst [test4 newin sC]
    set [info object namespace $inst]::__currentstate__
} -result {sC}
----

==== Destructor

Destroying an XUML class object involves release resource
associated with the event dispatch mechanisms.
As with the constructor,
we will defer that discussion until later.

The destructor logic involves testing if this class has a state model
and if so, then releasing any event dispatch resources.
It suffices to test for the existance of the current state to determine
if the object has an associated state mode.

(((method,XUMLClass,destructor)))

[source,tcl]
----
<<state model methods>>=
destructor {
    my variable __currentstate__
    if {[info exists __currentstate__]} {
        <<unbinding state machine events>>
    }
}
----

=== Access to Attributes

XUML execution semantics provide for reading and updating the
attributes of an object.
Some readers will observe that there is no notion of private or hidden
attributes.
Privacy is not a concept that enters into XUML and so is not dealt with
here.

==== Reading Attribute Values

The +readAttributes+ method provides access to the values
of an object's attributes.

=================
_xumlobj_ +readAttributes+ _?attrname1 attrname2 ...?_
=================

+attrname+::
    The name of the attribute to be read.
    If no attribute names are given, then the return value of the method is a
    dictionary of all the attributes of _xumlobj_ where the dictionary keys are
    the names of the attribute.
    If one _attrname_ argument is given, then the method return value is the
    simple scalar for the given attribute.
    If multiple _attrname_ arguments are given then the method return value is
    a dictionary whose keys are the attribute names given by the _attrname_
    arguments.

(((method,XUMLClass,readAttributes)))

[source,tcl]
----
<<attribute access methods>>=
method readAttributes {args} {
    set nargs [llength $args]
    if {$nargs == 0} {
        classvariable attrInfo
        set attrNames [dict keys $attrInfo]
    } elseif {$nargs > 1} {
        set attrNames $args
    } else {
        set attrName [lindex $args 0] ; # <1>
        my variable $attrName
        return [set $attrName]
    }

    set result [dict create]
    my variable {*}$attrNames
    foreach attr $attrNames {
        dict set result $attr [set $attr]
    }
    return $result
}
----
<1> For a single attribute, just return the value.
It's just easier to deal with the most common case in that way.

[float]
===== Read Attributes Tests

[source,tcl]
----
<<exported tests>>=
test readAttributes-1.0 {
    read single attribute value
} -setup {
    stsatcl STSAClass create test-ra1 {
        attribute Count {Maximum 27}
    }
} -cleanup {
    test-ra1 destroy
} -body {
    test-ra1 create inst1-ra1
    inst1-ra1 readAttributes Maximum
} -result {27}
----

[source,tcl]
----
<<exported tests>>=
test readAttributes-2.0 {
    read multiple attribute values
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27} {Timeout 1000}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst1-ra2
    inst1-ra2 readAttributes Maximum Timeout
} -result {Maximum 27 Timeout 1000}
----

[source,tcl]
----
<<exported tests>>=
test readAttributes-3.0 {
    read all attribute values
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27} {Timeout 1000}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst1-ra2
    inst1-ra2 readAttributes
} -result {Count {} Maximum 27 Timeout 1000}
----

==== Updating Attribute Values

The +updateAttributes+ method sets one or more attributes to
the values given as arguments.

=================
_xumlobj_ +updateAttributes+ _?attrname1 value1 attrname2 value 2...?_
=================

+attrname+::
    The name of the attribute to be read.
+value+::
    The corresponding value to assign to the attribute.

(((method,XUMLClass,updateAttributes)))

[source,tcl]
----
<<attribute access methods>>=
method updateAttributes {args} {
    classvariable attrInfo

    dict for {attribute value} $args {
        if {[dict exists $attrInfo $attribute]} {
            my variable $attribute
            set $attribute $value
        } else {
            tailcall ::stsatcl::DeclError UNKNOWN_ATTRIBUTE $attribute
        }
    }
    return
}
----

[float]
===== Update Attributes Tests

[source,tcl]
----
<<exported tests>>=
test updateAttributes-1.0 {
    update attribute value
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst-ra2
    inst-ra2 updateAttributes Count 33
    inst-ra2 readAttributes Count
} -result {33}
----

[source,tcl]
----
<<exported tests>>=
test updateAttributes-2.0 {
    update multiple attribute values
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst-ra2
    inst-ra2 updateAttributes Count 33 Maximum 50
    inst-ra2 readAttributes Count Maximum
} -result {Count 33 Maximum 50}
----

[source,tcl]
----
<<exported tests>>=
test updateAttributes-3.0 {
    unknown attribute
} -setup {
    stsatcl STSAClass create test-ra2 {
        attribute Count {Maximum 27}
    }
} -cleanup {
    test-ra2 destroy
} -body {
    test-ra2 create inst-ra2
    inst-ra2 updateAttributes Foo 42
} -result {unknown attribute, "Foo"} -returnCodes error
----

=== Linkage Methods

As we discussed <<bidir-relationship,above>>,
the model notion of a relationship is implemented by one or more
links.
There are three fundamental operations on relationships:

. Creating a relationship.
. Destroying a relationship.
. Navigating a relationship.

In this section we discuss the methods provide to XUML classes
to operate on relationship linkage.
When configuring an XUML class,
the +reference+ and +partition+ commands are used to
define object linkages that are the implementation realization
of a relationship in the XUML model.
Each class participating in the relationship that also uses
the relationship in some action need to have a link defined for it.
This implies that creating or destroying the model notion of a
relationship may require _linking_ or _unlinking_ in both objects
that participate in the relationship.

==== Link Method

The +link+ method is used to establish a relationship linkage
between two XUML objects.

=================
_xumlobj_ +link+ _rname_  _target_
=================

+rname+::
    the name of the relationship link.
    This will be one of the link names given as an argument to either the
    +reference+ or +partition+ command.
+target+::
    the object command name of the target object of the link.
    The _target_ must be an instance of the class
    (or subclasses in the case of a +partition+ link)
    defined for the link.
returns::
    the fully qualified _target_ command name.

(((method,XUMLClass,link)))

[source,tcl]
----
<<linkage access methods>>=
method link {rname target} {
    set target [my ResolveObj $target] ; # <1>
    my CheckRelName $rname
    my CheckReferenceObj $rname $target

    classvariable linkInfo
    my variable $rname
    switch -exact -- [dict get $linkInfo $rname type] {
        reference {
            set multiple [dict get $linkInfo $rname mult]
        }
        partition {
            set multiple 0
        }
        default {
            tailcall ::stsatcl::DeclError\
                    UNKNOWNLINKTYPE [dict get $linkInfo $rname type]
        }
    }
    if {$multiple} {
        ::struct::set include $rname $target ; # <2>
    } else {
        if {[set $rname] eq {}} {
            set $rname $target
        } else { # <3>
            tailcall ::stsatcl::DeclError OVERLINK [self] [set $rname]\
                   $rname $target
        }
    }
    return $target
}
----
(((error code,UNKNOWNLINKTYPE)))
(((error code,OVERLINK)))
[source,tcl]
----
<<error code format>>=
UNKNOWNLINKTYPE {unknown linkage type, "%s"}
OVERLINK        {attempt to over-link: %s is currently linked to %s across %s,\
                 requested link to %s}
----
<1> We use a number of utility methods described <<util-methods, below>>
to handle object command name resolution and checking that the
linkage exists and the target object is of the correct class.
<2> For links with multiple cardinality,
it is important that the list of target object commands be a set.
<3> For singular links, we insist that the link variable be empty,
_i.e._ that it has been properly unlinked before we overwrite the new
linkage value.

[float]
===== Link Tests

[source,tcl]
----
<<exported tests>>=
test link-1.0 {
    link across singular reference
} -setup {
    stsatcl STSAClass create test-lt1 {
        reference R1 -> test-lt2
    }
    stsatcl STSAClass create test-lt2 {
        reference R1 -> test-lt1
    }
} -cleanup {
    test-lt1 destroy
    test-lt2 destroy
} -body {
    test-lt1 create lt1
    test-lt2 create lt2
    lt1 link R1 lt2
} -result {::stsatcl::test::lt2}
----

[source,tcl]
----
<<exported tests>>=
test link-1.1 {
    overlink error
} -setup {
    stsatcl STSAClass create test-lt1 {
        reference R1 -> test-lt2
    }
    stsatcl STSAClass create test-lt2 {
        reference R1 -> test-lt1
    }
} -cleanup {
    test-lt1 destroy
    test-lt2 destroy
} -body {
    test-lt1 create lt1
    test-lt2 create lt2
    lt1 link R1 lt2
    lt1 link R1 lt2
} -result {attempt to over-link: ::stsatcl::test::lt1 is currently linked to ::stsatcl::test::lt2 across R1, requested link to ::stsatcl::test::lt2}\
-returnCodes error
----

[source,tcl]
----
<<exported tests>>=
test link-2.0 {
    link across multiple reference
} -setup {
    stsatcl STSAClass create test-lt1 {
        reference R2 ->> test-lt2
    }
    stsatcl STSAClass create test-lt2 {
        reference R2 -> test-lt1
    }
} -cleanup {
    test-lt1 destroy
    test-lt2 destroy
} -body {
    test-lt1 create inst1
    test-lt2 create inst2
    test-lt2 create inst3
    inst1 link R2 inst2
    inst1 link R2 inst3
    llength [set [info object namespace inst1]::R2]
} -result {2}
----

[source,tcl]
----
<<exported tests>>=
test link-2.1 {
    link across multiple reference, duplicate references
} -setup {
    stsatcl STSAClass create test-lt1 {
        reference R2 ->> test-lt2
    }
    stsatcl STSAClass create test-lt2 {
        reference R2 -> test-lt1
    }
} -cleanup {
    test-lt1 destroy
    test-lt2 destroy
} -body {
    test-lt1 create inst1
    test-lt2 create inst2
    inst1 link R2 inst2
    inst1 link R2 inst2
    llength [set [info object namespace inst1]::R2]
} -result {1}
----

[source,tcl]
----
<<exported tests>>=
test link-3.0 {
    link across partition
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R3 -> super
    }

    ::stsatcl STSAClass create sub2 {
        reference R3 -> super
    }
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    super create sup1
    sub1 create inst1
    sup1 link R3 inst1
    llength [set [info object namespace sup1]::R3]
} -result {1}
----

==== Unlink Method

A link between objects is destroyed by invoking the +unlink+ method.

=================
_xumlobj_ +unlink+ _rname_  _target_
=================

+rname+::
    the name of the relationship link.
    This will be one of the link names given as an argument to either the
    +reference+ or +partition+ command.
+target+::
    the object command name of the target object of the link.
    The _target_ must be an instance that is currently linked across
    _rname_.

(((method,XUMLClass,unlink)))

[source,tcl]
----
<<linkage access methods>>=
method unlink {rname target} {
    set target [my ResolveObj $target]
    my CheckRelName $rname
    my CheckReferenceObj $rname $target

    classvariable linkInfo
    my variable $rname
    switch -exact -- [dict get $linkInfo $rname type] {
        reference {
            set multiple [dict get $linkInfo $rname mult]
            set match [::struct::set contains [set $rname] $target]
        }
        partition {
            set multiple 0
            set match [expr {$target eq [set $rname]}]
        }
        default {
            tailcall ::stsatcl::DeclError\
                    UNKNOWNLINKTYPE [dict get $linkInfo $rname type]
        }
    }
    if {$match} {
        if {$multiple} {
            ::struct::set exclude $rname $target
        } else {
            set $rname {}
        }
    } else {
        tailcall ::stsatcl::DeclError NOTLINKED $target $rname
    }

    return
}
----
(((error code,NOTLINKED)))
[source,tcl]
----
<<error code format>>=
NOTLINKED       {object, "%s", is not linked to "%s"}
----

[float]
===== Unlink Tests

[source,tcl]
----
<<exported tests>>=
test unlink-1.0 {
    unlink across singular reference
} -setup {
    stsatcl STSAClass create test-ul1 {
        reference R1 ->c test-ul2
    }
    stsatcl STSAClass create test-ul2 {
        reference R1 -> test-ul1
    }
} -cleanup {
    test-ul1 destroy
    test-ul2 destroy
} -body {
    test-ul1 create inst-ul1
    test-ul2 create inst-ul2
    inst-ul1 link R1 inst-ul2
    inst-ul1 unlink R1 inst-ul2
    set [info object namespace inst-ul2]::R1
} -result {}
----

[source,tcl]
----
<<exported tests>>=
test unlink-2.0 {
    unlink across multiple reference
} -setup {
    stsatcl STSAClass create test-ul3 {
        reference R1 ->> test-ul4
    }
    stsatcl STSAClass create test-ul4 {
        reference R1 -> test-ul3
    }
} -cleanup {
    test-ul3 destroy
    test-ul4 destroy
} -body {
    test-ul3 create inst1
    test-ul4 create inst2
    test-ul4 create inst3

    inst1 link R1 inst2
    inst1 link R1 inst3
    inst1 unlink R1 inst2
    llength [info object namespace inst1]::R1
} -result {1}

test unlink-3.0 {
    unlink across partition
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R3 -> super
    }

    ::stsatcl STSAClass create sub2 {
        reference R3 -> super
    }
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    super create inst-super
    sub1 create inst-sub1
    inst-super link R3 inst-sub1
    inst-super unlink R3 inst-sub1
    set [info object namespace inst-super]::R3
} -result {}
----

==== Link Navigation Method

The +\->+ method is used to navigate one or more links.

=================
_xumlobj_ +\->+ _rname1_  _?rname2 ...?_
=================

There are two particular points in navigating links.
First,
references and partition have different characteristics in the
navigation.
A partition, when navigated from superclass to
subclass\footnote:[Navigating from subclass to superclass us just
an unconditional singular link with no special characteristics]
must specify which subclass of the partition is to be
navigated and consequently whether the currently linked instance
is of the specified subtype.
Second, we want to be able to have a chain of links specified and
so navigation can be seen as a recursive operation.

(((method,XUMLClass,->)))

[source,tcl]
----
<<linkage access methods>>=
method -> {rname args} {
    classvariable linkInfo
    my CheckRelName $rname

    my variable $rname
    set relobjs [set $rname]

    switch -exact -- [dict get $linkInfo $rname type] {
        reference {
            if {![dict get $linkInfo $rname cond] && [llength $relobjs] == 0} {
                tailcall ::stsatcl::DeclError UNCOND $rname
            }
        }
        partition {
            if {$relobjs eq {}} {
                tailcall ::stsatcl::DeclError UNCOND $rname
            }
            if {[llength $args] < 1} { # <1>
                tailcall ::stsatcl::DeclError NOSUBCLASS $rname
            }

            set subclass [lindex $args 0]
            set args [lrange $args 1 end]

            set subclass [my ResolveObj $subclass]
            if {$subclass ni [dict get $linkInfo $rname subclasses]} {
                tailcall ::stsatcl::DeclError NOTSUBCLASS $subclass $rname
            }
            if {[llength [info class instances $subclass $relobjs]] == 0} {
                set relobjs [list]
            }
        }
        default {
            tailcall ::stsatcl::DeclError\
                    UNKNOWNLINKTYPE [dict get $linkInfo $rname type]
        }
    }

    if {[llength $args] != 0} {
        set related [list]
        foreach robj $relobjs {
            ::struct::set add related [$robj -> {*}$args] ; # <2>
        }
    } else {
        set related $relobjs
    }

    return [expr {[llength $related] < 2 ? [lindex $related 0] : $related}] ; #<3>
}
export ->
----
(((error code,UNCOND)))
(((error code,NOSUBCLASS)))
(((error code,NOTSUBCLASS)))
[source,tcl]
----
<<error code format>>=
UNCOND      {reference, "%s", is unconditional, yet no instances were found}
NOSUBCLASS  {navigation of "%s" from supertype to subtype\
             requires the destination subtype class}
NOTSUBCLASS {subclass, "%s", is not a subclass of partition "%s"}
----
<1> When navigating from a superclass to a subclass we must state
which subclass of the partition we are interested in and so an extra
argument is required.
<2> The instances related by a link form a set.
<3> We return a single scalar value when possible.
argument must be supplied.

[float]
===== Traversal Tests

[source,tcl]
----
<<exported tests>>=
test traverse-1.0 {
    traverse a singular relationship
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    inst1 link R1 inst2
    inst1 -> R1
} -result {::stsatcl::test::inst2}
----

[source,tcl]
----
<<exported tests>>=
test traverse-1.1 {
    traverse multiple singular relationships
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    inst1 link R1 inst2
    inst2 link R1 inst1

    inst1 -> R1 R1
} -result {::stsatcl::test::inst1}
----

[source,tcl]
----
<<exported tests>>=
test traverse-1.2 {
    traverse many singular relationships -- violate conditionality
} -setup {
    stsatcl STSAClass create rt1 {
        reference R1 -> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R1 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    inst1 link R1 inst2
    inst1 -> R1 R1
} -result {reference, "R1", is unconditional, yet no instances were found}\
  -returnCodes error
----

[source,tcl]
----
<<exported tests>>=
test traverse-2.0 {
    traverse a multiple relationship
} -setup {
    stsatcl STSAClass create rt1 {
        reference R2 ->> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R2 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    rt2 create inst3
    inst1 link R2 inst2
    inst1 link R2 inst3
    inst1 -> R2
} -result {::stsatcl::test::inst2 ::stsatcl::test::inst3}
----

[source,tcl]
----
<<exported tests>>=
test reference-2.1 {
    traverse a multiple relationship, then a singular
} -setup {
    stsatcl STSAClass create rt1 {
        reference R2 ->> rt2
    }
    stsatcl STSAClass create rt2 {
        reference R2 -> rt1
    }
} -cleanup {
    rt1 destroy
    rt2 destroy
} -body {
    rt1 create inst1
    rt2 create inst2
    rt2 create inst3
    inst1 link R2 inst2
    inst1 link R2 inst3
    inst2 link R2 inst1
    inst3 link R2 inst1

    inst1 -> R2 R2
} -result {::stsatcl::test::inst1}
----

[source,tcl]
----
<<exported tests>>=
test traverse-3.0 {
    traverse across partition
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R3 -> super
    }

    ::stsatcl STSAClass create sub2 {
        reference R3 -> super
    }
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    super create sup1
    sub1 create inst1

    sup1 link R3 inst1
    sup1 -> R3 sub1
} -result {::stsatcl::test::inst1}
----

[source,tcl]
----
<<exported tests>>=
test reference-3.1 {
    traverse across partition and single reference
} -setup {
    ::stsatcl STSAClass create super {
        partition R10 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R10 -> super
        reference R11 -> c3
    }

    ::stsatcl STSAClass create sub2 {
        reference R10 -> super
    }
    ::stsatcl STSAClass create c3 {
        reference R11 -> sub1
    }
    super create sup1
    sub1 create s1
    c3 create inst3
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
    c3 destroy
} -body {
    sup1 link R10 s1
    s1 link R10 sup1
    s1 link R11 inst3
    inst3 link R11 s1
    sup1 -> R10 sub1 R11
} -result {::stsatcl::test::inst3}
----

[source,tcl]
----
<<exported tests>>=
test reference-3.2 {
    traverse across partition and single reference -- come up empty
} -setup {
    ::stsatcl STSAClass create super {
        partition R10 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R10 -> super
        reference R11 -> c3
    }

    ::stsatcl STSAClass create sub2 {
        reference R10 -> super
    }
    ::stsatcl STSAClass create c3 {
        reference R11 -> sub1
    }
    super create sup1
    sub1 create s1
    c3 create inst3
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
    c3 destroy
} -body {
    sup1 link R10 s1
    s1 link R10 sup1
    s1 link R11 inst3
    inst3 link R11 s1
    sup1 -> R10 sub2 R11
} -result {}
----

[source,tcl]
----
<<exported tests>>=
test traverse-3.3 {
    traverse across partition -- wrong subclass
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        reference R3 -> super
    }

    ::stsatcl STSAClass create sub2 {
        reference R3 -> super
    }
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    super create sup1
    sub1 create inst1

    sup1 link R3 inst1
    sup1 -> R3 sub3
} -result {subclass, "::stsatcl::test::sub3",\
        is not a subclass of partition "R3"} -returnCodes error
----

==== Migrate Method

The +migrate+ method provides the common operation of
migrating one of the subclass instances in a partition
to a different subclass.
Conceptually, this is accomplished by:

. Unlink in the subclass instance.
. Destroy the unlinked instance.
. Create a new instance of the required subclass.
. Link the new subclass instance to the superclass instance.

=================
_xumlobj_ +migrate+ _rname  subclass ?attr1 value1 attr2 value2 ...?_
=================

+rname+::
    the name of a partition link.
    Subclass migration is only defined for partition links.
+subclass+::
    the name of the subclass to which the migration will occur.
    The _subclass_ must be one defined for the _rname_ partition.
+attr value ...+::
    attribute name / attribute value pairs that given as arguments
    to the new constructed subclass instance.

(((method,XUMLClass,migrate)))

[source,tcl]
----
<<linkage access methods>>=
method migrate {rname subclass args} {
    set subclass [my ResolveObj $subclass]
    my CheckRelName $rname

    classvariable linkInfo
    if {[dict get $linkInfo $rname type] ne "partition"} {
        tailcall ::stsatcl::DeclError NOTPARTITION $rname
    }
    if {$subclass ni [dict get $linkInfo $rname subclasses]} {
        tailcall ::stsatcl::DeclError NOTSUBCLASS $subclass $rname
    }

    my variable $rname
    set subinst [set $rname]
    if {$subinst eq {}} {
        tailcall ::stsatcl::DeclError UNCOND $rname
    }
    $subinst destroy

    set $rname [$subclass new {*}$args]
}
----
(((error code,NOTPARTITION)))
[source,tcl]
----
<<error code format>>=
NOTPARTITION    {linkage "%s" is not a partition}
----

[float]
===== Migrate Tests

[source,tcl]
----
<<exported tests>>=
test migrate-1.0 {
    migrate subclasses
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        attribute {A1 20}
    }

    ::stsatcl STSAClass create sub2 {
        attribute {A1 30}
    }
    super create sup1
    sub1 create inst1
    sup1 link R3 inst1
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    set subinst [sup1 migrate R3 sub2 A1 50]
    $subinst readAttributes A1
} -result {50}
----

[source,tcl]
----
<<exported tests>>=
test migrate-2.0 {
    migrate subclasses -- not a partition
} -setup {
    ::stsatcl STSAClass create fake {
        reference R32 -> baz
    }
    ::stsatcl STSAClass create baz

    fake create i1
} -cleanup {
    fake destroy
    baz destroy
} -body {
    i1 migrate R32 sub2
} -result {linkage "R32" is not a partition} -returnCodes error
----

[source,tcl]
----
<<exported tests>>=
test migrate-3.0 {
    migrate subclasses -- unknown subclass
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
    }

    ::stsatcl STSAClass create sub1 {
        attribute {A1 20}
    }

    ::stsatcl STSAClass create sub2 {
        attribute {A1 30}
    }
    super create sup1
    sub1 create inst1
    sup1 link R3 inst1
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    sup1 migrate R3 sub3
} -result {subclass, "::stsatcl::test::sub3",\
        is not a subclass of partition "R3"} -returnCodes error
----

[source,tcl]
----
<<exported tests>>=
test migrate-4.0 {
    migrate subclasses -- missing link
} -setup {
    ::stsatcl STSAClass create super {
        partition R5 sub1 sub2
    }
    super create sup1
} -cleanup {
    super destroy
} -body {
    sup1 migrate R5 sub2
} -result {reference, "R5", is unconditional, yet no instances were found}\
    -returnCodes error
----

=== Instance Selection [[inst-select, Instance Selection]]

In this section we describe the methods provided to
search for class instances.
There are two types of searches that are quite general and
are provided by the package.

. Selecting from all instances of a class.
. Selecting from related instances of a class.

To find an instance set from among all the instances of a class
is a method on the XUML class itself.
Finding related instances is a method on XMUL objects.

[NOTE]
The searches here are simple linear searches and are
entirely suitable for a small number of instances.
More sophisticated searches can be implemented by creating and
maintaining indices or other techniques.
However,
those techniques are beyond that provided by this package.
Constructing more sophisticated instance selection can be
done by adding class-based operations and carefully building
the required auxiliary data structures.
It remains for a future enhancement to add the ability to
use a more sophisticated search index scheme.

The methods in this section use a +tcllib+ package to do the actual
work of evaluating the selection critierion and building
the resulting list of instances.

[source,tcl]
----
<<required packages>>=
package require struct::list
----

==== Find Where Method

=================
_xumlclass_ +findWhere+ _varname  expr_
=================

The +findWhere+ method is defined on each XUML class.
The method iterates over each instance of the _xumlclass_
and assigns the object command to the variable given by _varname_
and evaluates the expression given by _expr_.
The result of evaluating _expr_ is interpreted as a boolean
and if true, the instance command name is included in the returned
list of instance commands.

(((method,XUMLClass,findWhere)))

[source,tcl]
----
<<stsaclass constructor>>=
objdefine [self] method findWhere {varname expr} {
    tailcall ::struct::list filterfor $varname [info class instances [self]]\
            $expr ; # <1>
}
----
<1> Note the use of the +tailcall+ command here.
The +filterfor+ procedure will evaluate the express in the stack level
of the caller.
Using +tailcall+ insures that another stack level is _not_ introduced
so that the expression is evaluated in the stack level of the caller
of the +findWhere+ method, which is exactly what we want.

[float]
===== Find Where Tests

[source,tcl]
----
<<exported tests>>=
test findWhere-1.0 {
    find instances based on criteria
} -setup {
    ::stsatcl STSAClass create fw1 {
        attribute Count {Maximum 27} {Timeout 1000}
    }
} -cleanup {
    fw1 destroy
} -body {
    fw1 create inst1
    fw1 create inst2 Maximum 30 Timeout 1000
    fw1 create inst3 Timeout 2000
    set min 1000
    fw1 findWhere inst {
        [$inst readAttributes Timeout] == $min
    }
} -result {::stsatcl::test::inst1 ::stsatcl::test::inst2}
----

==== Find Related Where Method

=================
_xumlclass_ +findRelatedWhere+ _links varname  expr_
=================

(((method,XUMLClass,findRelatedWhere)))

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method findRelatedWhere {rlist varname expr} {
    tailcall ::struct::list filterfor $varname [my -> {*}$rlist] $expr
}
----

[float]
===== Find Related Where Tests

[source,tcl]
----
<<exported tests>>=
test findRelatedWhere-1.0 {
    find related instances base on criteria
} -setup {
    ::stsatcl STSAClass create frw1 {
        attribute Count {Maximum 27} {Timeout 1000}
        reference R1 ->> frw2
    }
    ::stsatcl STSAClass create frw2 {
        attribute Reason Temp Pressure Current
    }

    frw1 create i1

    frw2 create c1 Temp 20
    frw2 create c2 Temp 30
    frw2 create c3 Temp 40
    frw2 create c4 Temp 50

    i1 link R1 c1
    i1 link R1 c2
    i1 link R1 c3
    i1 link R1 c4
} -cleanup {
    frw1 destroy
    frw2 destroy
} -body {
    set targetTemp 30
    i1 findRelatedWhere R1 inst {
        [$inst readAttributes Temp] > $targetTemp
    }
} -result {::stsatcl::test::c3 ::stsatcl::test::c4}
----

=== Instance Computation Methods

In this section we show methods that,
like the instance selection methods <<inst-select, above>>,
iterate over instances.
For these methods we provide a means to compute
on each of the instances and thereby build up higher order
summaries of data.
The fundamental capablities are provided by the +lmap+ command.

==== Map Instances Method

(((method,XUMLClass,findRelatedWhere)))

[source,tcl]
----
<<stsaclass constructor>>=
objdefine [self] method mapInstances {varname script} {
    uplevel 1 [list ::lmap $varname [info class instances [self]] $script]
}
----

[float]
===== Map Instances Tests

[source,tcl]
----
<<exported tests>>=
test mapInstances-1.0 {
    iterate on instances to produce an attribute list
} -setup {
    ::stsatcl STSAClass create fw1 {
        attribute Count Maximum Timeout
    }
} -cleanup {
    fw1 destroy
} -body {
    fw1 create inst1 Maximum 20
    fw1 create inst2 Maximum 30
    fw1 create inst3 Maximum 40

    set divisor 10
    fw1 mapInstances inst {
        expr {[$inst readAttributes Maximum] / $divisor}
    }
} -result {2 3 4}
----

==== Map Related Instances Method

(((method,XUMLClass,mapRelatedInstances)))

[source,tcl]
----
<<stsaclass constructor>>=
define [self] method mapRelatedInstances {rlist varname script} {
    uplevel 1 [list ::lmap $varname [my -> {*}$rlist] $script]
}
----

[float]
===== Map Related Instances Tests

[source,tcl]
----
<<exported tests>>=
test mapRelatedInstances-1.0 {
    iterate on related instances to produce a list
} -setup {
    ::stsatcl STSAClass create frw1 {
        attribute Count {Maximum 27} {Timeout 1000}
        reference R1 ->> frw2
    }
    ::stsatcl STSAClass create frw2 {
        attribute Reason Temp Pressure Current
    }

    frw1 create i1

    frw2 create c1 Temp 20
    frw2 create c2 Temp 30
    frw2 create c3 Temp 40
    frw2 create c4 Temp 50

    i1 link R1 c1
    i1 link R1 c2
    i1 link R1 c3
    i1 link R1 c4
} -cleanup {
    frw1 destroy
    frw2 destroy
} -body {
    set divisor 10
    i1 mapRelatedInstances R1 inst {
        expr {[$inst readAttributes Temp] / $divisor}
    }
} -result {2 3 4 5}
----

=== State Machine Execution

At long last we will now discuss how state machine execution operates.

We will start my clarifying some terms.
The term *event* is heavily overloaded in the Tcl world.
It can be used to describe Tk window events or used in conjunction with
event oriented programming concepts.
Here we will overload the term one more time and discuss state machine
events.
We will use the term *state machine event* when we need to be explicit.

The state model execution rules also need to be made explicit.

* There are three types of state machine events, ordinary transitioning
events (or just simply events), polymorphic events and creation events.
* Events signalled by an instance to itself are dispatched before
events that are signalled from a different instance.
* Events and polymorphic events may be _delayed_, _i.e._ you may request
that the system signal events at some time in the future.
* There may be only one outstanding delayed event of a given event name
between any sending / receiving pair of instances.
* Polymorphic event can only be signalled to instances that have
defined a +partition+ link.
* Creation events are signalled to the class and result in an instance
of that class being created in its pseudo-initial state
and an event signalled to the newly created instance.

One of the important properties of state actions is that they
_execute to completion_.
During the execution of the action of a state,
signalling a state machine event does _not_ cause any side effects
on the state of the executing instance.
This happens also to be a single threaded architecture,
so there is no concurrency implied by the state machine events.

From a design point of view,
we must decide how to implement the above rules.
The execute-to-completion rule can be accomplished using a queue for the
events.
In this design,
each XUML class instance has its own event queues,
one for immediately dispatched events and one for delayed events.
Signalling events to an instance will result in inserting an
event on the event queue associated with the target instance.

Another important consideration is how to drive the dispatch of events
on the instance queues.
Fortunately,
the +after+ command provides us with all we need.

At instance construction time,
we must set up some variables to use to track the event dispatch.

[source,tcl]
----
<<binding state machine events>>=
# We keep a queue of events as a simple list.
my variable __event_queue__
set __event_queue__ [list]
# Delayed events require some additional bookkeeping.
my variable __delayedSignals__
array set __delayedSignals__ {}
----

At object destruction time,
we must clear up any allocated resources.

[source,tcl]
----
<<unbinding state machine events>>=
my variable __delayedSignals__ ; # <1>
foreach {sigid sigdetails} [array get __delayedSignals__] {
    after cancel [dict get $sigdetails timerid]
}
----
<1> Delayed signals are ultimately mapped to timer events via the +::after+
command so we must cancel anything that is currently outstanding.

==== Signal Method

The primary operation to state machines is to generate events to them
and that is accomplished by the +signal+ method.

=================
_xumlobj +signal+ _event_ _?param1 param2 ...?_
=================

+event+::
    The name of the event to be signalled.
+param1 param2 ...+::
    Optional parameters given to the state action.

The +signal+ method generates _event_ to _xumlobj_ passing along
any parameter arguments.
The state action that is invoked by the transition caused by _event_
receives the values of the _paramN_ arguments.
State actions are defined with any formal arguments that they expect.
It is a rule of the Moore formalism that all events that cause a
transition into a given state must carry parametric data values
that match those expected by the state action signature.
In this architecture,
a run time error is generated if the arguments don't match.

The implementation of the +signal+ method has two major considerations.
First,
we must determine if the signalled event is polymorphic or not.
Polymorphic events are just forwarded on to the related subclass instance.
Eventually, the polymorphic event arrives at a subclass instance where
it is consumed as an ordinary event.
Second for ordinary events,
we must place the event into the event queue.
It is here we enforce the rule that events that an instance signals to
itself are dispatched before any events generated by other instances.

(((method,XUMLClass,signal)))

[source,tcl]
----
<<state model methods>>=
method signal {event args} {
    classvariable polyEvents
    if {$event in $polyEvents} { # <1>
        my ForwardPolyEvent signal $event $args
    } else {
        my ValidateEvent $event
        set src [my EventSource]
        set eventInfo [dict create\
            src $src\
            event $event\
            params $args\
        ]
        my variable __event_queue__
        # Self directed events are queued to the front.  However, we handle the
        # case where an object may signal multiple self-directed events. In
        # that, admittedly unusual case, we want to preserve the order of the
        # signalled events.
        if {$src eq [self]} {
            for {set nsindex 0} {$nsindex < [llength $__event_queue__]}\
                    {incr nsindex} { # <2>
                set cmpevent [lindex $__event_queue__ $nsindex]
                if {[dict get $cmpevent src] ne [self]} {
                    break ; # <3>
                }
            }
            set __event_queue__ [linsert $__event_queue__ $nsindex $eventInfo]
        } else {
            lappend __event_queue__ $eventInfo ; # <4>
        }
        ::after 0 [mymethod Dispatch]
    }
}
----
<1> Polymorphic events are propagated down all the partition linkages
that are specified for the class.
<2> We iterate through the event queue using an index because we want to
use +linsert+ to place the event in the correct location.
<3> Stop the iteration at the first event that is non-self directed.
The +linsert+ command inserts the item into a list _before_ its argument
index, which is just what we want.
<4> Non-self directed events are simply appended to the event queue.

[float]
===== Signal Method Tests

We start the testing of +signal+ by generating events and
examining the event queue to make sure it is in the expected state.

[source,tcl]
----
<<exported tests>>=
test signal-1.0 {
    signal an event from outside of a state machine context
} -setup {
    ::stsatcl STSAClass create sg1 {
        statemodel {
            state s1 {a} {
                puts -nonewline $a
            }
            transition s1 - e1 -> s1
        }
    }
} -cleanup {
    sg1 destroy
} -body {
    sg1 create inst1
    inst1 signal e1 20
    namespace upvar [info object namespace inst1] __event_queue__ evtqueue
    dict get [lindex $evtqueue 0] src
} -result {}
----

[source,tcl]
----
<<exported tests>>=
test signal-2.0 {
    signal an event from inside of a state machine context
} -setup {
    ::stsatcl STSAClass create sg1 {
        statemodel {
            state s1 {a} {
                puts -nonewline $a
            }
            transition s1 - e1 -> s1
        }
    }
    ::stsatcl STSAClass create sg2 {
        reference R1 -> sg1
        instop sig_sg1 {event args} {
            [my -> R1] signal $event {*}$args
        }
    }
} -cleanup {
    sg1 destroy
    sg2 destroy
} -body {
    sg1 create inst1
    sg2 create inst2
    inst2 link R1 inst1
    inst2 sig_sg1 e1 20

    namespace upvar [info object namespace inst1] __event_queue__ evtqueue
    dict get [lindex $evtqueue 0] src
} -result {::stsatcl::test::inst2}
----

[source,tcl]
----
<<exported tests>>=
test signal-3.0 {
    signal multiple self directed events
} -setup {
    ::stsatcl STSAClass create sg1 {
        attribute {Count 0}
        statemodel {
            state s1 {} {
                my variable Count
                incr Count
                my signal e1
                my signal e2
            }
            transition s1 - e1 -> s1

            state s2 {} {
                my variable Count
                incr Count
            }
            transition s2 - e2 -> s1
        }
    }
    ::stsatcl STSAClass create sg2 {
        reference R1 -> sg1
        instop sig_sg1 {event} {
            [info object namespace [my -> R1]]::my Receive e1
            [my -> R1] signal e1
        }
    }
} -cleanup {
    sg1 destroy
    sg2 destroy
} -body {
    sg1 create inst1
    sg2 create inst2
    inst2 link R1 inst1
    inst2 sig_sg1 e1

    namespace upvar [info object namespace inst1] __event_queue__ evtqueue
    set checklen [expr {[llength $evtqueue] == 3}]
    set check1 [expr {[dict get [lindex $evtqueue 0] event] eq "e1"}]
    set check2 [expr {[dict get [lindex $evtqueue 1] event] eq "e2"}]
    set check3 [expr {[dict get [lindex $evtqueue 2] src] eq\
            "::stsatcl::test::inst2"}]
    expr {$checklen && $check1 && $check2 && $check3}
} -result {1}
----

[source,tcl]
----
<<exported tests>>=
test signal-4.0 {
    signal a polymorphic event
} -setup {
    ::stsatcl STSAClass create super {
        partition R3 sub1 sub2
        polymorphic *e1
    }

    ::stsatcl STSAClass create sub1 {
        reference R3 -> super
        attribute {Count 0}
        statemodel {
            state sb1 {} {
                my variable Count
                incr Count
            }
            transition sb1 - *e1 -> sb1
        }
    }

    ::stsatcl STSAClass create sub2 {
        reference R3 -> super
        attribute {Count 0}
        statemodel {
            state sb1 {} {
                my variable Count
                incr Count
            }
            transition sb1 - *e1 -> sb1
        }
    }
} -cleanup {
    super destroy
    sub1 destroy
    sub2 destroy
} -body {
    super create sup1
    sub1 create inst1
    sup1 link R3 inst1
    inst1 link R3 sup1

    sup1 signal *e1
    namespace upvar [info object namespace inst1] __event_queue__ evtqueue
    dict get [lindex $evtqueue 0] src
} -result {::stsatcl::test::sup1}
----

==== Delayed Signal Method

The +delayedSignal+ method requests an event to be signalled at some
time in the future.

=================
_xumlobj +delayedSignal+ _time event_ _?param1 param2 ...?_
=================

+time+::
    The minimum number of milliseconds in the future when the event
    will be signalled. This value may non-negative.
+event+::
    The name of the event to be signalled.
+param1 param2 ...+::
    Optional parameters given to the state action.

There are several design considerations here.
Clearly, we have to have access to some timing resource.
The +after+ command provides basic time driven events.
However, there are two other operations on delayed signals that must be
considered.
It is possible to cancel a delayed signal.
This is conveniently mapped to the +after cancel+ command.
It is also necessary to be able to determine the amount of time
remaining before a delayed signal is to be generated.
For this function,
we have to provide some additional machinery.

We must also enforce the rule that there can only be one
outstanding delayed signal for a given event name between any
sending / receiving pair of instances.
The first complication arises in determining what to do if
a duplicate request is made.
In this architecture we interpret an attempt to have a duplicated
delayed event as a request to cancel the first signal and reinstate the
signal at the newly requested time.
This turns out to be the most common intent in practice and it
prevents have to deal with a potential error situation.

(((method,XUMLClass,delayedSignal)))

[source,tcl]
----
<<state model methods>>=
method delayedSignal {time event args} {
    if {$time < 0} {
        tailcall ::stsatcl::DeclError INVALIDTIME $time
    }
    classvariable polyEvents
    if {$event in $polyEvents} { # <1>
        my ForwardPolyEvent delayedSignal $event $args
    } else {
        # Cancel any existing delayed signal that might have been in place.
        my CancelDelayedSignal $src $event
        set eventInfo [dict create\
            src [my EventSource]\
            event $event\
            params $args\
        ]
        set timerid [::after $time [mymethod DelayedDispatch $eventInfo]
        my variable __delayedSignals__
        set __delayedSignals__($src,$event) [dict create\
            timerid $timerid\
            expire [expr {[clock milliseconds] + $time}]\
        ]
    }
    return
}
----
<1> Like the +signal+ method,
polymorphic events are forwarded down the generalization hierarchy.

(((error code,INVALIDTIME)))
[source,tcl]
----
<<error code format>>=
INVALIDTIME    {invalid signal delay time, "%ld"}
----

==== Cancel Method

Cancel a delayed signal

(((method,XUMLClass,cancel)))

[source,tcl]
----
<<state model methods>>=
method cancel {event} {
    return [my CancelDelayedSignal [my EventSource] $event]
}
----

==== Remaining Method

Obtain the time remaining before a delayed signal is sent.
Time remaining for a delayed signal.

(((method,XUMLClass,remainging)))

[source,tcl]
----
<<state model methods>>=
method remaining {event} {
    set src [my EventSource]
    my variable __delayedSignals__
    if {[info exists __delayedSignals__($src,$event)]} {
        set expiretime [dict get $__delayedSignals__($src,$event) expire]
        set currtime [clock milliseconds]
        set remaintime [expr {max($expiretime - $currtime, 0)}]
    } else {
        set remaintime 0
    }
    return $remaintime
}
----

==== Force Method

Force a machine to a given state, executing its action.

(((method,XUMLClass,force)))

[source,tcl]
----
<<state model methods>>=
method force {state args} {
    classvariable states
    if {$state ni $states} {
        tailcall ::stsatcl::DeclError UNKNOWN_STATE $state $states
    }
    my variable __currentstate__
    set __currentstate__ $state
    my ${__currentstate__}__STATE_ {*}$args
    return
}
----

==== Current State Method

Obtain the current state.

(((method,XUMLClass,currentstate)))

[source,tcl]
----
<<state model methods>>=
method currentstate {} {
    my variable __currentstate__
    return $__currentstate__
}
----

==== Receive Method

Receive an event synchronously.
This causes immediate dispatch of the state action as a synchronous procedure
invocation.

(((method,XUMLClass,receive)))

[source,tcl]
----
<<state model methods>>=
method Receive {event args} {
    my variable __currentstate__
    classvariable transitions
    set newState $transitions($__currentstate__,$event) ; # <1>

    if {$newState eq "CH"} { # <2>
        tailcall ::stsatcl::DeclError CH_TRANSITION $__currentstate__ $event
    } elseif {$newState ne "IG"} {
        set __currentstate__ $newState
        try {
            my ${__currentstate__}__STATE__ {*}$args ; # <3>
        } on error {result opts} {
            ::stsa::DeclError ACTION_ERROR $result
        } finally {
            classvariable terminals ; # <4>
            if {$__currentstate__ in $terminals} {
                my destroy
            }
        }
    }
    return
}
----
<1> In the Moore formalism,
the new state is a function of the current state and the event.
<2> Check for pseudo-transitions.
<3> Despite the ``line noise'' appearance of this statement, we are simply
invoking the method that is the state action,
constructing its name according to some established conventions.
<4> If this is a terminal state, then we destroy ourselves.
This is the asynchronous deletion that corresponds to asychronous creation.

(((error code,CH_TRANSITION)))
(((error code,ACTION_ERROR)))
[source,tcl]
----
<<error code format>>=
CH_TRANSITION   {can't happen transition: %s - %s -> CH}
ACTION_ERROR    {state action error, "%s"}
----

[float]
===== Receive Method Tests

[source,tcl]
----
<<exported tests>>=
test Receive-1.0 {
    synchronously receive a state machine event
} -setup {
    ::stsatcl STSAClass create rc1 {
        statemodel {
            state s1 {a} {
                puts -nonewline $a
            }
            transition s1 - e1 -> s1
        }
    }
} -cleanup {
    rc1 destroy
} -body {
    rc1 create inst1
    [info object namespace inst1]::my Receive e1 20
} -result {} -output {20}
----

[source,tcl]
----
<<exported tests>>=
test Receive-2.0 {
    cause can't happen transition
} -setup {
    ::stsatcl STSAClass create rc1 {
        statemodel {
            state s1 {a} {
                puts -nonewline $a
            }
            transition s1 - e1 -> s1
            transition s1 - e2 -> CH
        }
    }
} -cleanup {
    rc1 destroy
} -body {
    rc1 create inst1
    [info object namespace inst1]::my Receive e2
} -result {can't happen transition: s1 - e2 -> CH} -returnCodes error
----

==== Dispatch Method

Dispatch of non-delayed events comes here.
The event queue is emptied by generating an event after each one is dispatched
until the queue goes empty.
So when we enter here,
if the queue is already not empty, then there must be a pending event.

(((method,XUMLClass,delayedSignal)))

[source,tcl]
----
<<state model methods>>=
method Dispatch {obj event empty} {
    my variable __event_queue__
    # The event queue should contain something here, but we test
    # anyway.
    if {[llength $__event_queue__] != 0} {
        # Pull the event from the front of the queue
        set eventInfo [lindex $__event_queue__ 0]
        set __event_queue__ [lrange $__event_queue__ 1 end]
        tailcall my Receive [dict get $eventInfo event]\
                [dict get $eventInfo params]
    }
}

# Dispatch of delayed events comes here. For delayed events, we
# queue them normally, except if the event queue is already empty.
# Since here we executing out of the event loop anyway, there is no
# reason to generate another event just to get the already delayed
# event dispatched. Hence, we deliver the event immediately if
# there are no other events pending. If other events are pending,
# the there is a pending ::uevent already in the works.
method DelayedDispatch {eventInfo} {
    # Now that the delayed event is delivered, we have to do the
    # bookkeeping on the set of outstanding delayed events.
    my variable __delayedSignals__
    dict with eventInfo {
        if {[info exists __delayedSignals__($src,$event)]} {
            unset __delayedSignals__($src,$event)
            my Receive $event $params
        }
    }
}

method CancelDelayedSignal {src event} {
    my ValidateEvent $event
    # Check if we have the delayed signal. It might not exist
    # or have already been dispatched. We return an indication
    # of whether the signal was indeed canceled.
    my variable __delayedSignals__
    if {[info exists __delayedSignals__($src,$event)]} {
        after cancel [dict get $__delayedSignals__($src,$event) timerid]
        unset __delayedSignals__($src,$event)
        set result true
    } else {
        # If the signal has already been delivered, it might be in
        # the event queue. Iterate across the event queue and
        # remove the event if we find it.
        my variable __event_queue__
        for {set queue_index 0} {$queue_index < [llength $__event_queue__]}\
                {incr queue_index} {
            set event_item [lindex $__event_queue $queue_index]
            dict with event_item {
                if {$eventSrc eq $src && $eventName eq $event} {
                    set __event_queue__ [lreplace $__event_queue__\
                            $queue_index $queue_index]
                    return true
                }
            }
        }
        set result false
    }
    return $result
}
----

=== Utility Methods [[util-methods,utility methods]]

[source,tcl]
----
<<utility methods>>=
method CheckRelName {rname} {
    classvariable linkInfo
    if {![dict exists $linkInfo $rname]} {
        error "unknown linkage, \"$rname\""
    }
}
----

[source,tcl]
----
<<utility methods>>=
method CheckReferenceObj {rname obj} {
    classvariable linkInfo

    set objclass [info object class $obj]
    switch -exact -- [dict get $linkInfo $rname type] {
        reference {
            set destclass [dict get $linkInfo $rname dest]
            if {!($objclass eq $destclass ||\
                    $destclass in [info class superclasses $objclass])} {
                error "instance, \"$obj\", is not an instance of class,\
                        \"[dict get $linkInfo $rname dest]\""
            }
        }
        partition {
            set subclasses [dict get $linkInfo $rname subclasses]
            foreach subclass $subclasses {
                if {$objclass eq $subclass ||\
                    $subclass in [info class superclasses $objclass]} {
                    return
                }
            }
            error "instance, \"$obj\", is not an instance of any class,\
                    \"[join $subclasses {, }]\""
        }
        default {
            error "unknown linkage type, \"[dict get $linkInfo $rname type]\""
        }
    }
}
----

[source,tcl]
----
<<utility methods>>=
method ResolveObj {obj} {
    if {[string range $obj 0 1] ne "::"} {
        set obj\
            [string trimright [uplevel 2 namespace current] :]::$obj
    }
    return $obj
}
----

[source,tcl]
----
<<utility methods>>=
# Make sure we are dealing with a known event.
method ValidateEvent {event} {
    classvariable events
    if {$event ni $events} {
        tailcall ::stsatcl::DeclError UNKNOWN_EVENT $event
    }
}
----
(((error code,UNKNOWN_EVENT)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_EVENT {unknown event, "%s"}
----

[source,tcl]
----
<<utility methods>>=
method EventSource {} {
    # Determine the caller of the method. We use this to determine
    # whether the event is self-directed. "self caller" throws
    # an error if the caller is not a method.
    try {
        set src [lindex [uplevel 1 {self caller}] 1]
    } on error {} {
        set src {}
    }
    return $src
}
----

[source,tcl]
----
<<utility methods>>=
method ForwardPolyEvent {fwrd event arglist} {
    classvariable partitions
    foreach partition $partitions {
        my variable $partition
        [set $partition] $fwrd $event {*}$arglist
    }
}
----

== Code Organization

=== Source Code

[source,tcl]
----
<<stsatcl.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6

<<required packages>>

namespace eval ::stsatcl {
    namespace export STSAClass
    namespace ensemble create

    variable version 1.0

    <<package data>>
}

<<stsatcl commands>>

package provide stsatcl $::stsatcl::version
----

=== Unit Tests

[source,tcl]
----
<<stsatcl.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger

source ../src/stsatcl.tcl
chan puts "testing stsatcl version: [package require stsatcl]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
    {port.arg {} {Target comm port}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

package require tcltest
eval tcltest::configure $argv

namespace eval ::stsatcl::test {
    ::logger::initNamespace [namespace current] $::options(level)

    namespace import ::tcltest::*

    <<test utility procs>>
    <<meta constructor tests>>
    <<constructor tests>>
    <<unexported tests>>
    <<exported tests>>

    cleanupTests
}
----


////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded stsatcl 1.0 [list source [file join $dir stsatcl.tcl]]
----
