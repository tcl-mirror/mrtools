# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require logger

source stsatcl.tcl

namespace eval ::wmctrl {

    variable version 1.0a2

    ::logger::initNamespace [namespace current] info

    namespace import ::stsatcl::STSAClass

    STSAClass create WashingMachine {
        attribute MachineID
        reference R1 -> ClothesTub
        reference R4 -> WashingCycle
        statemodel {
            initialState Stopped
            defaultTrans CH
    
            state Stopped {} {
                set ct [my -> R1]
                $ct signal Stop
            }
            transition Stopped - Start -> FillingToWash
    
            state FillingToWash {} {
                set wc [my -> R4]
                set ct [my -> R1]
                $ct signal Fill [$wc readAttributes WashWaterTemp]
            }
            transition FillingToWash - Full -> Washing
    
            state Washing {} {
                set ct [my -> R1]
                $ct signal Agitate
                set wc [my -> R4]
                my delayedSignal [expr {[$wc readAttributes WashDuration] * 1000}] Done ; # <1>
            }
            transition Washing - Done -> DrainingWash
    
            state DrainingWash {} {
                set ct [my -> R1]
                $ct signal Drain
            }
            transition DrainingWash - Empty -> FillingToRinse
    
            state FillingToRinse {} {
                set wc [my -> R4]
                set ct [my -> R1]
                $ct signal Fill [$wc readAttributes RinseWaterTemp]
            }
            transition FillingToRinse - Full -> Rinsing
    
            state Rinsing {} {
                set ct [my -> R1]
                $ct signal Agitate
                set wc [my -> R4]
                my delayedSignal [expr {[$wc readAttributes RinseDuration] * 1000}] Done
            }
            transition Rinsing - Done -> DrainingRinse
    
            state DrainingRinse {} {
                set ct [my -> R1]
                $ct signal Drain
            }
            transition DrainingRinse - Empty -> Spinning
    
            state Spinning {} {
                set ct [my -> R1]
                $ct signal Spin
                set wc [my -> R4]
                my delayedSignal [expr {[$wc readAttributes SpinDuration] * 1000}] Done
            }
            transition Spinning - Done -> Stopped
        }
    }
    STSAClass create WashingCycle {
        attribute CycleType
        attribute WashWaterTemp RinseWaterTemp
        attribute WashDuration RinseDuration SpinDuration
        attribute AgitationSpeed SpinSpeed
    }
    STSAClass create ClothesTub {
        reference R1 -> WashingMachine
        reference R2 ->> Motor
        reference R3 ->> WaterValve
        reference R5 -> WaterLevelSensor
        statemodel {
            initialState Empty
            defaultTrans CH
        
            state Empty {} {
                set mtr [my selectOneRelatedWhere R2 selected {
                    [$selected readAttributes MotorID] eq "Pump"
                }]
                $mtr Stop
                set wv [my selectOneRelatedWhere R3 selected {
                    [$selected readAttributes ValveID] eq "Drain"
                }]
                $wv Close
                set wls [my -> R5]
                $wls Disable
                set wm [my -> R1]
                $wm signal Empty
            }
            transition Empty - Fill -> Filling
            transition Empty - Spin -> Spinning
        
            state Filling {temp} {
                set wls [my -> R5]
                $wls Enable
                if {$temp eq "Hot"} {
                    set wv [my selectOneRelatedWhere R3 selected {
                        [$selected readAttributes ValveID] eq "Hot"
                    }]
                    $wv Open
                } elseif {$temp eq "Cold"} {
                    set wv [my selectOneRelatedWhere R3 selected {
                        [$selected readAttributes ValveID] eq "Cold"
                    }]
                    $wv Open
                } elseif {$temp eq "Warm"} {
                    set wvs [my selectRelatedWhere R3 selected {
                        [$selected readAttributes ValveID] eq "Hot" ||\
                        [$selected readAttributes ValveID] eq "Cold"
                    }]
                    foreach wv $wvs {
                        $wv Open
                    }
                }
            }
            transition Filling - TubFull -> Full
            transition Filling - TubEmpty -> IG     ; # <1>
        
            state Full {} {
                set wls [my -> R5]
                $wls Disable
                set wvs [my selectRelatedWhere R3 selected {
                    [$selected readAttributes ValveID] eq "Hot" ||\
                    [$selected readAttributes ValveID] eq "Cold"
                }]
                foreach wv $wvs {
                    $wv Close
                }
                set wm [my -> R1]
                $wm signal Full
            }
            transition Full - Agitate -> Agitating
        
            state Agitating {} {
                set mtr [my selectOneRelatedWhere R2 selected {
                    [$selected readAttributes MotorID] eq "Agitator"
                }]
                $mtr Start
            }
            transition Agitating - Drain -> Emptying
        
            state Emptying {} {
                set mtr [my selectOneRelatedWhere R2 selected {
                    [$selected readAttributes MotorID] eq "Agitator"
                }]
                $mtr Stop
                set wv [my selectOneRelatedWhere R3 selected {
                    [$selected readAttributes ValveID] eq "Drain"
                }]
                $wv Open
                set mtr [my selectOneRelatedWhere R2 selected {
                    [$selected readAttributes MotorID] eq "Pump"
                }]
                $mtr Start
                set wls [my -> R5]
                $wls Enable
            }
            transition Emptying - TubEmpty -> Empty
            transition Emptying - TubFull -> IG
        
            state Spinning {} {
                set wv [my selectOneRelatedWhere R3 selected {
                    [$selected readAttributes ValveID] eq "Drain"
                }]
                $wv Open
                set mtr [my selectOneRelatedWhere R2 selected {
                    [$selected readAttributes MotorID] eq "Pump"
                }]
                $mtr Start
                set mtr [my selectOneRelatedWhere R2 selected {
                    [$selected readAttributes MotorID] eq "Spin"
                }]
                $mtr Start
            }
            transition Spinning - Stop -> StoppingSpin
        
            state StoppingSpin {} {
                set mtr [my selectOneRelatedWhere R2 selected {
                    [$selected readAttributes MotorID] eq "Spin"
                }]
                $mtr Stop
                set mtr [my selectOneRelatedWhere R2 selected {
                    [$selected readAttributes MotorID] eq "Pump"
                }]
                $mtr Stop
                set wv [my selectOneRelatedWhere R3 selected {
                    [$selected readAttributes ValveID] eq "Drain"
                }]
                $wv Close
                set ::done 1
            }
            transition StoppingSpin - Fill -> Filling
        }
    }
    STSAClass create WaterValve {
        attribute ValveID
        instop Open {} {
            my variable ValveID
            ::wmctrl::VALVE::open $ValveID
            
        }
        instop Close {} {
            my variable ValveID
            ::wmctrl::VALVE::close $ValveID
            
        }
    }
    STSAClass create Motor {
        attribute MotorID
        instop Start {} {
            my variable MotorID
            ::wmctrl::MOTOR::start $MotorID
            
        }
        instop Stop {} {
            my variable MotorID
            ::wmctrl::MOTOR::stop $MotorID
            
        }
    }
    STSAClass create WaterLevelSensor {
        reference R5 -> ClothesTub
        instop Enable {} {
            set machine [my -> R5 R1] ; # <1>
            ::wmctrl::SENSOR::enable [$machine readAttributes MachineID]
            
        }
        instop Disable {} {
            set machine [my -> R5 R1]
            ::wmctrl::SENSOR::disable [$machine readAttributes MachineID]
        }
    }
    WashingCycle create normal\
        CycleType Normal\
        WashWaterTemp Cold\
        RinseWaterTemp Cold\
        WashDuration 20\
        RinseDuration 10\
        SpinDuration 10\
        AgitationSpeed Medium\
        SpinSpeed Medium
    WashingCycle create whites\
        CycleType Whites\
        WashWaterTemp Hot\
        RinseWaterTemp Cold\
        WashDuration 20\
        RinseDuration 10\
        SpinDuration 20\
        AgitationSpeed High\
        SpinSpeed High
    WashingCycle create permpress\
        CycleType PermPress\
        WashWaterTemp Warm\
        RinseWaterTemp Cold\
        WashDuration 15\
        RinseDuration 10\
        SpinDuration 15\
        AgitationSpeed Medium\
        SpinSpeed Medium
    WashingCycle create delicate\
        CycleType Delicate\
        WashWaterTemp Cold\
        RinseWaterTemp Cold\
        WashDuration 15\
        RinseDuration 10\
        SpinDuration 10\
        AgitationSpeed Low\
        SpinSpeed Low
    WashingMachine create washer MachineID WasherOne
    washer link R4 normal
    ClothesTub create tub
    washer link R1 tub      ; # <1>
    tub link R1 washer
    Motor create pump MotorID Pump
    Motor create agitator MotorID Agitator
    Motor create spin MotorID Spin
    
    tub link R2 pump
    tub link R2 agitator
    tub link R2 spin
    WaterValve create hot ValveID Hot
    WaterValve create cold ValveID Cold
    WaterValve create drain ValveID Drain
    
    tub link R3 hot
    tub link R3 cold
    tub link R3 drain
    WaterLevelSensor create sensor
    
    tub link R5 sensor
    sensor link R5 tub
}
proc ::wmctrl::startWasher {washer} {
    set wm [WashingMachine selectOneWhere selected {
        [$selected readAttributes MachineID] eq $washer
    }]
    if {$wm eq {}} {
        error "unknown washer, \"$washer\""
    }
    $wm signal Start

    return
}
proc ::wmctrl::selectCycle {washer cycle} {
    set wm [WashingMachine selectOneWhere selected {
        [$selected readAttributes MachineID] eq $washer
    }]
    if {$wm eq {}} {
        error "unknown washer, \"$washer\""
    }

    set wc [WashingCycle selectOneWhere selected {
        [$selected readAttributes CycleType] eq $cycle
    }]
    if {$wc eq {}} {
        error "unknown cycle, \"$cycle\""
    }
    $wm unlink R4 [$wm -> R4] ; # <1>
    $wm link R4 $wc

    return
}
namespace eval ::wmctrl::MOTOR {
    ::logger::initNamespace [namespace current] info
    proc start {motor} {
        log::info "starting motor, \"$motor\""
    }
    proc stop {motor} {
        log::info "stopping motor, \"$motor\""
    }
}

namespace eval ::wmctrl::VALVE {
    ::logger::initNamespace [namespace current] info
    proc open {valve} {
        log::info "opening valve, \"$valve\""
    }
    proc close {valve} {
        log::info "closing valve, \"$valve\""
    }
}
namespace eval ::wmctrl::SENSOR {
    ::logger::initNamespace [namespace current] info
    variable sensorState TubEmpty
    variable sensorEvent

    proc enable {machine} {
        log::info "enable sensor on machine, \"$machine\""

        variable sensorState
        variable sensorEvent

        set newState\
            [expr {$sensorState eq "TubEmpty" ? "TubFull" : "TubEmpty"}] ; # <1>
        set sensorEvent [after 3000 [namespace code\
            [list trigger $machine $newState]]] ; # <2>
    }

    proc disable {machine} {
        log::info "disable sensor on machine, \"$machine\""
        variable sensorEvent
        after cancel $sensorEvent
    }
    proc trigger {machine value} {
        variable sensorState
        set sensorState $value

        set wm [::wmctrl::WashingMachine selectOneWhere selected {
            [$selected readAttributes MachineID] eq $machine
        }]
        set ct [$wm -> R1]
        $ct signal $sensorState
    }
}
::stsatcl traceControl on

::wmctrl::selectCycle WasherOne PermPress
puts "**** Start Run"
::wmctrl::startWasher WasherOne

vwait ::done ; # <1>

puts "**** Finish Run"
::stsatcl traceControl off

puts "**** Trace Begin"
puts [::stsatcl::formatTraces [::stsatcl::decodeAllTraces]]
puts "**** Trace End"

::wmctrl::WashingMachine draw\
    {-Gcenter=1 -Gratio=auto -Gsize=7.5,10 -Tsvg -oimages/WashingMachine.svg} ; # <2>

::stsatcl diagAllTraces images/wmctrl-seqdiag.diag span_height 7 ; # <3>
