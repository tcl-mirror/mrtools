# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger

source ../src/stsatcl.tcl
chan puts "testing stsatcl version: [package require stsatcl]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

package require tcltest
eval tcltest::configure $argv

namespace eval ::stsatcl::test {
    ::logger::initNamespace [namespace current] $::options(level)

    namespace import ::tcltest::*

    proc syncToTest {{value {}}} {
        set [namespace current]::testDone $value
    }
    
    proc waitForSync {{timeout 1000}} {
        set varname [namespace current]::testDone
        set tid [::after $timeout set $varname TIMEOUT]
        vwait $varname
        after cancel $tid
        set $varname
    }
    proc turnOnTraceLog {} {
        variable prevloglevel
    
        ::stsatcl traceControl clear
        ::stsatcl traceControl on
        set logcmd [::logger::servicecmd stsatcl]
        set prevloglevel [${logcmd}::currentloglevel]
        ${logcmd}::setlevel [::stsatcl traceControl loglevel]
        ::stsatcl traceControl logon
    }
    
    proc turnOffTraceLog {} {
        variable prevloglevel
    
        set logcmd [::logger::servicecmd stsatcl]
        ${logcmd}::setlevel $prevloglevel
        ::stsatcl traceControl logoff
        ::stsatcl traceControl off
        ::stsatcl traceControl clear
    }
    test Attribute-1.0 {
        configure multiple attributes
    } -setup {
        ::stsatcl STSAClass create at1
    } -cleanup {
        at1 destroy
    } -body {
        [info object namespace at1]::my Attribute\
            Count {Maximum 20}
        dict size [set [info object namespace at1]::attrInfo]
    } -result {2}
    test Attribute-2.0 {
        attempt to name an attribute the empty string
    } -setup {
        ::stsatcl STSAClass create at2
    } -cleanup {
        at2 destroy
    } -body {
        [info object namespace at2]::my Attribute {}
    } -result {invalid attribute name, ""} -returnCodes error
    test Attribute-3.0 {
        attempt to have duplicate attributes
    } -setup {
        ::stsatcl STSAClass create at3
    } -cleanup {
        at3 destroy
    } -body {
        [info object namespace at3]::my Attribute Count Count
    } -result {duplicate attribute name, "Count"} -returnCodes error
    test Reference-1.0 {
        configure a simple reference
    } -setup {
        ::stsatcl STSAClass create ref1
    } -cleanup {
        ref1 destroy
    } -body {
        [info object namespace ref1]::my Reference R1 -> [namespace current]::foo
        dict get [set [info object namespace ref1]::linkInfo] R1
    } -result {type reference dest ::stsatcl::test::foo mult 0 cond 0}
    test Reference-2.0 {
        define reference with bad syntax
    } -setup {
        ::stsatcl STSAClass create ref2
    } -cleanup {
        ref2 destroy
    } -body {
        [info object namespace ref2]::my Reference R1 ->>x [namespace current]::foo
    } -result {bad reference spec, "->>x"} -returnCodes error
    test Reference-3.0 {
        duplicated reference
    } -setup {
        ::stsatcl STSAClass create ref3
    } -cleanup {
        ref3 destroy
    } -body {
        [info object namespace ref3]::my Reference R1 -> [namespace current]::foo
        [info object namespace ref3]::my Reference R1 -> [namespace current]::foo
    } -result {linkage, "R1", already exists} -returnCodes error
    test Partition-1.0 {
        define partition
    } -setup {
        ::stsatcl STSAClass create pt1
    } -cleanup {
        pt1 destroy
    } -body {
        [info object namespace pt1]::my Partition R1\
                [namespace current]::sub1 [namespace current]::sub2
        dict get [set [info object namespace pt1]::linkInfo] R1
    } -result {type partition subclasses {::stsatcl::test::sub1 ::stsatcl::test::sub2}}
    test Partition-2.0 {
        partition with one subclass
    } -setup {
        ::stsatcl STSAClass create pt2
    } -cleanup {
        pt2 destroy
    } -body {
        [info object namespace pt2]::my Partition R1\
                [namespace current]::sub1
    } -result {partition, "R1", must have at least two subclasses}\
    -returnCodes error
    test Partition-3.0 {
        define duplicate partitions
    } -setup {
        ::stsatcl STSAClass create pt3
    } -cleanup {
        pt3 destroy
    } -body {
        [info object namespace pt3]::my Partition R1\
                [namespace current]::sub1 [namespace current]::sub2
        [info object namespace pt3]::my Partition R1\
                [namespace current]::sub3 [namespace current]::sub4
    } -result {linkage, "R1", already exists} -returnCodes error
    test Statemodel-1.0 {
        insure the statemodel script executes in the correct namespace
    } -setup {
        ::stsatcl STSAClass create sm1
    } -cleanup {
        sm1 destroy
    } -body {
        [info object namespace sm1]::my Statemodel {
            puts -nonewline [namespace tail [namespace current]]
            attribute Foo Bar
        }
    } -result {invalid command name "attribute"} -output {smdsl} -returnCodes error
    test Polymorphic-1.0 {
        define polymorphic events
    } -setup {
        ::stsatcl STSAClass create pm1
    } -cleanup {
        pm1 destroy
    } -body {
        [info object namespace pm1]::my Polymorphic e1 e2
        llength [set [info object namespace pm1]::polyEvents]
    } -result {2}
    test InstOp-1.0 {
        define instance operation
    } -setup {
        ::stsatcl STSAClass create io1
    } -cleanup {
        io1 destroy
    } -body {
        [info object namespace io1]::my InstOp print {a} {puts -nonewline $a}
        io1 create inst-io1
        inst-io1 print alpha
        expr {"print" in [info object methods inst-io1 -all]}
    } -result {1} -output {alpha}
    test ClassOp-1.0 {
        define class based operation
    } -setup {
        ::stsatcl STSAClass create co1
    } -cleanup {
        co1 destroy
    } -body {
        [info object namespace co1]::my ClassOp print {a} {puts -nonewline $a}
        co1 print beta
        expr {"print" in [info object methods co1]}
    } -result {1} -output {beta}
    test State-1.0 {
        define state
    } -setup {
        ::stsatcl STSAClass create st1
    } -cleanup {
        st1 destroy
    } -body {
        [info object namespace st1]::my Statemodel {
            state s1 {} {
                puts "in state s1"
            }
        }
        set isdef [expr {"s1" in [set [info object namespace st1]::states]}]
        set hasmeth [expr {"s1__STATE__" in [info class methods st1 -private]}]
        expr {$isdef && $hasmeth}
    } -result {1}
    test State-2.0 {
        define state with reserved name
    } -setup {
        ::stsatcl STSAClass create st2
    } -cleanup {
        st2 destroy
    } -body {
        [info object namespace st2]::my Statemodel {
            state IG {} {}
        }
    } -result {states may not be named by the reserved name, "IG"}\
    -returnCodes error
    test State-3.0 {
        define state with reserved name
    } -setup {
        ::stsatcl STSAClass create st3
    } -cleanup {
        st3 destroy
    } -body {
        [info object namespace st3]::my Statemodel {
            state Idle {} {}
            state Idle {a b} {puts "$a $b"}
        }
    } -result {duplicate state, "Idle"} -returnCodes error
    test Transition-1.0 {
        define transition
    } -setup {
        ::stsatcl STSAClass create tr1 {}
    } -cleanup {
        tr1 destroy
    } -body {
        [info object namespace tr1]::my Statemodel {
            transition s1 - e1 -> s1
        }
    
        namespace upvar [info object namespace tr1] transitions t
        namespace upvar [info object namespace tr1] events e
    
        set hasevent [expr {"e1" in $e}]
        set hastrans [expr {[dict get $t s1 e1] eq "s1"}]
        expr {$hasevent && $hastrans}
    } -result {1}
    test Transition-2.0 {
        define transition -- bad source state
    } -setup {
        ::stsatcl STSAClass create tr2 {}
    } -cleanup {
        tr2 destroy
    } -body {
        [info object namespace tr2]::my Statemodel {
            transition IG - e1 -> s1
        }
    } -result {a transition cannot originate from the "IG" pseudo-state}\
    -returnCodes error
    test Transition-3.0 {
        define transition -- bad source state
    } -setup {
        ::stsatcl STSAClass create tr3 {}
    } -cleanup {
        tr3 destroy
    } -body {
        [info object namespace tr3]::my Statemodel {
            transition s1 - e1 -> @
        }
    } -result {the initial pseudo-state, "@", cannot be the target of a transition}\
    -returnCodes error
    test Transition-4.0 {
        define transition -- duplicate transition
    } -setup {
        ::stsatcl STSAClass create tr4 {}
    } -cleanup {
        tr4 destroy
    } -body {
        [info object namespace tr4]::my Statemodel {
            transition s1 - e1 -> s1
            transition s1 - e1 -> s2
        }
    } -result {duplicate transition, "s1 - e1"} -returnCodes error
    test constructor-1.0 {
        create an instance with attributes
    } -setup {
        stsatcl STSAClass create test5 {
            attribute Count {Maximum 20}
        }
    } -cleanup {
        test5 destroy
    } -body {
        test5 create inst5
        set [info object namespace inst5]::Maximum
    } -result {20}
    test constructor-1.1 {
        create an instance with attributes -- override values
    } -setup {
        stsatcl STSAClass create test5 {
            attribute Count {Maximum 20}
        }
    } -cleanup {
        test5 destroy
    } -body {
        test5 create inst5 Maximum 30
        set [info object namespace inst5]::Maximum
    } -result {30}
    test constructor-1.2 {
        error overriding attributes
    } -setup {
        stsatcl STSAClass create test5 {
            attribute Count {Maximum 20}
        }
    } -cleanup {
        test5 destroy
    } -body {
        test5 create inst5 Foo 30
    } -result {unknown attribute, "Foo"} -returnCodes error
    test constructor-2.0 {
        create an instance with a reference
    } -setup {
        stsatcl STSAClass create ct2 {
            reference R42 -> foo
        }
    } -cleanup {
        ct2 destroy
    } -body {
        ct2 create inst2
        info exists [info object namespace inst2]::R42
    } -result {1}
    test constructor-3.0 {
        define a state model -- defined initial state
    } -setup {
        stsatcl STSAClass create test6 {
            statemodel {
                state s1 {} {
                    puts "[self] in s1"
                }
                transition s1 - e1 -> s2
    
                state s2 {a} {
                    puts $a
                }
                transition s2 - e2 -> s1
    
                initialState s2
            }
        }
    } -cleanup {
        test6 destroy
    } -body {
        test6 create inst6
        set [info object namespace inst6]::__currentstate__
    } -result {s2}
    test constructor-3.1 {
        define a state model -- default initial state
    } -setup {
        stsatcl STSAClass create test6 {
            statemodel {
                state s1 {} {
                    puts "[self] in s1"
                }
                transition s1 - e1 -> s2
    
                state s2 {a} {
                    puts $a
                }
                transition s2 - e2 -> s1
            }
        }
    } -cleanup {
        test6 destroy
    } -body {
        test6 create inst6
        set [info object namespace inst6]::__currentstate__
    } -result {s1}
    test constructor-3.2 {
        define state model -- check transition
    } -setup {
        stsatcl STSAClass create test6 {
            attribute Count {Maximum 20}
            statemodel {
                state s1 {} {
                    puts "[self] in s1"
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        test6 destroy
    } -body {
        test6 create inst6
        namespace upvar [info object namespace test6] transitions transitions
        dict get $transitions s1 e1
    } -result {s1}
    test constructor-4.0 {
        create an instance in a given state
    } -setup {
        stsatcl STSAClass create test4 {
            statemodel {
                state sA {} {
                    puts "[self] in sA"
                }
                transition sA - e1 -> sB
    
                state sB {a} {
                    puts $a
                }
                transition sB - e2 -> sA
    
                initialState sB
            }
        }
    } -cleanup {
        test4 destroy
    } -body {
        test4 createin inst4 sA
        set [info object namespace inst4]::__currentstate__
    } -result {sA}
    test constructor-4.1 {
        create an instance in a given state using newin
    } -setup {
        stsatcl STSAClass create test4 {
            statemodel {
                state sA {} {
                    puts "[self] in sA"
                }
                transition sA - e1 -> sB
    
                state sB {a} {
                    puts $a
                }
                transition sB - e2 -> sA
    
                state sC {b} {
                    puts $b
                }
                transition sC - e1 -> sB
    
                initialState sB
            }
        }
    } -cleanup {
        test4 destroy
    } -body {
        set inst [test4 newin sC]
        set [info object namespace $inst]::__currentstate__
    } -result {sC}
    test creation-event-1.0 {
        send a creation event
    } -setup {
        stsatcl STSAClass create cre1 {
            attribute Count {Maximum 27}
            statemodel {
                transition @ - e1 -> s1
    
                state s1 {} {
                    my variable Maximum
                    incr Maximum 10
                    ::stsatcl::test::syncToTest $Maximum
                }
            }
        }
    } -cleanup {
        cre1 destroy
    } -body {
        set inst [cre1 signal e1]
        ::stsatcl::test::waitForSync
        $inst readAttributes Maximum
    } -result {37}
    test readAttributes-1.0 {
        read single attribute value
    } -setup {
        stsatcl STSAClass create test-ra1 {
            attribute Count {Maximum 27}
        }
    } -cleanup {
        test-ra1 destroy
    } -body {
        test-ra1 create inst1-ra1
        inst1-ra1 readAttributes Maximum
    } -result {27}
    test readAttributes-2.0 {
        read multiple attribute values
    } -setup {
        stsatcl STSAClass create test-ra2 {
            attribute Count {Maximum 27} {Timeout 1000}
        }
    } -cleanup {
        test-ra2 destroy
    } -body {
        test-ra2 create inst1-ra2
        inst1-ra2 readAttributes Maximum Timeout
    } -result {Maximum 27 Timeout 1000}
    test readAttributes-3.0 {
        read all attribute values
    } -setup {
        stsatcl STSAClass create test-ra2 {
            attribute Count {Maximum 27} {Timeout 1000}
        }
    } -cleanup {
        test-ra2 destroy
    } -body {
        test-ra2 create inst1-ra2
        inst1-ra2 readAttributes
    } -result {Count {} Maximum 27 Timeout 1000}
    test readAttributes-4.0 {
        read unknown attribute values
    } -setup {
        stsatcl STSAClass create test-ra2 {
            attribute Count {Maximum 27} {Timeout 1000}
        }
    } -cleanup {
        test-ra2 destroy
    } -body {
        test-ra2 create inst1-ra2
        inst1-ra2 readAttributes foo
    } -result {unknown attribute, "foo"} -returnCodes error
    test readAttributes-4.1 {
        read unknown attribute values from among many
    } -setup {
        stsatcl STSAClass create test-ra2 {
            attribute Count {Maximum 27} {Timeout 1000}
        }
    } -cleanup {
        test-ra2 destroy
    } -body {
        test-ra2 create inst1-ra2
        inst1-ra2 readAttributes Maximum foo Timeout
    } -result {unknown attribute, "foo"} -returnCodes error
    test updateAttributes-1.0 {
        update attribute value
    } -setup {
        stsatcl STSAClass create test-ra2 {
            attribute Count {Maximum 27}
        }
    } -cleanup {
        test-ra2 destroy
    } -body {
        test-ra2 create inst-ra2
        inst-ra2 updateAttributes Count 33
        inst-ra2 readAttributes Count
    } -result {33}
    test updateAttributes-2.0 {
        update multiple attribute values
    } -setup {
        stsatcl STSAClass create test-ra2 {
            attribute Count {Maximum 27}
        }
    } -cleanup {
        test-ra2 destroy
    } -body {
        test-ra2 create inst-ra2
        inst-ra2 updateAttributes Count 33 Maximum 50
        inst-ra2 readAttributes Count Maximum
    } -result {Count 33 Maximum 50}
    test updateAttributes-3.0 {
        unknown attribute
    } -setup {
        stsatcl STSAClass create test-ra2 {
            attribute Count {Maximum 27}
        }
    } -cleanup {
        test-ra2 destroy
    } -body {
        test-ra2 create inst-ra2
        inst-ra2 updateAttributes Foo 42
    } -result {unknown attribute, "Foo"} -returnCodes error
    test link-1.0 {
        link across singular reference
    } -setup {
        stsatcl STSAClass create test-lt1 {
            reference R1 -> test-lt2
        }
        stsatcl STSAClass create test-lt2 {
            reference R1 -> test-lt1
        }
    } -cleanup {
        test-lt1 destroy
        test-lt2 destroy
    } -body {
        test-lt1 create lt1
        test-lt2 create lt2
        lt1 link R1 lt2
    } -result {::stsatcl::test::lt2}
    test link-1.1 {
        overlink error
    } -setup {
        stsatcl STSAClass create test-lt1 {
            reference R1 -> test-lt2
        }
        stsatcl STSAClass create test-lt2 {
            reference R1 -> test-lt1
        }
    } -cleanup {
        test-lt1 destroy
        test-lt2 destroy
    } -body {
        test-lt1 create lt1
        test-lt2 create lt2
        lt1 link R1 lt2
        lt1 link R1 lt2
    } -result {attempt to over-link: ::stsatcl::test::lt1 is currently linked to ::stsatcl::test::lt2 across R1, requested link to ::stsatcl::test::lt2}\
    -returnCodes error
    test link-2.0 {
        link across multiple reference
    } -setup {
        stsatcl STSAClass create test-lt1 {
            reference R2 ->> test-lt2
        }
        stsatcl STSAClass create test-lt2 {
            reference R2 -> test-lt1
        }
    } -cleanup {
        test-lt1 destroy
        test-lt2 destroy
    } -body {
        test-lt1 create inst1
        test-lt2 create inst2
        test-lt2 create inst3
        inst1 link R2 inst2
        inst1 link R2 inst3
        llength [set [info object namespace inst1]::R2]
    } -result {2}
    test link-2.1 {
        link across multiple reference, duplicate references
    } -setup {
        stsatcl STSAClass create test-lt1 {
            reference R2 ->> test-lt2
        }
        stsatcl STSAClass create test-lt2 {
            reference R2 -> test-lt1
        }
    } -cleanup {
        test-lt1 destroy
        test-lt2 destroy
    } -body {
        test-lt1 create inst1
        test-lt2 create inst2
        inst1 link R2 inst2
        inst1 link R2 inst2
        llength [set [info object namespace inst1]::R2]
    } -result {1}
    test link-3.0 {
        link across partition
    } -setup {
        ::stsatcl STSAClass create super {
            partition R3 sub1 sub2
        }
    
        ::stsatcl STSAClass create sub1 {
            reference R3 -> super
        }
    
        ::stsatcl STSAClass create sub2 {
            reference R3 -> super
        }
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
    } -body {
        super create sup1
        sub1 create inst1
        sup1 link R3 inst1
        llength [set [info object namespace sup1]::R3]
    } -result {1}
    test unlink-1.0 {
        unlink across singular reference
    } -setup {
        stsatcl STSAClass create test-ul1 {
            reference R1 ->c test-ul2
        }
        stsatcl STSAClass create test-ul2 {
            reference R1 -> test-ul1
        }
    } -cleanup {
        test-ul1 destroy
        test-ul2 destroy
    } -body {
        test-ul1 create inst-ul1
        test-ul2 create inst-ul2
        inst-ul1 link R1 inst-ul2
        inst-ul1 unlink R1 inst-ul2
        set [info object namespace inst-ul2]::R1
    } -result {}
    test unlink-2.0 {
        unlink across multiple reference
    } -setup {
        stsatcl STSAClass create test-ul3 {
            reference R1 ->> test-ul4
        }
        stsatcl STSAClass create test-ul4 {
            reference R1 -> test-ul3
        }
    } -cleanup {
        test-ul3 destroy
        test-ul4 destroy
    } -body {
        test-ul3 create inst1
        test-ul4 create inst2
        test-ul4 create inst3
    
        inst1 link R1 inst2
        inst1 link R1 inst3
        inst1 unlink R1 inst2
        llength [info object namespace inst1]::R1
    } -result {1}
    
    test unlink-3.0 {
        unlink across partition
    } -setup {
        ::stsatcl STSAClass create super {
            partition R3 sub1 sub2
        }
    
        ::stsatcl STSAClass create sub1 {
            reference R3 -> super
        }
    
        ::stsatcl STSAClass create sub2 {
            reference R3 -> super
        }
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
    } -body {
        super create inst-super
        sub1 create inst-sub1
        inst-super link R3 inst-sub1
        inst-super unlink R3 inst-sub1
        set [info object namespace inst-super]::R3
    } -result {}
    test traverse-1.0 {
        traverse a singular relationship
    } -setup {
        stsatcl STSAClass create rt1 {
            reference R1 -> rt2
        }
        stsatcl STSAClass create rt2 {
            reference R1 -> rt1
        }
    } -cleanup {
        rt1 destroy
        rt2 destroy
    } -body {
        rt1 create inst1
        rt2 create inst2
        inst1 link R1 inst2
        inst1 -> R1
    } -result {::stsatcl::test::inst2}
    test traverse-1.1 {
        traverse multiple singular relationships
    } -setup {
        stsatcl STSAClass create rt1 {
            reference R1 -> rt2
        }
        stsatcl STSAClass create rt2 {
            reference R1 -> rt1
        }
    } -cleanup {
        rt1 destroy
        rt2 destroy
    } -body {
        rt1 create inst1
        rt2 create inst2
        inst1 link R1 inst2
        inst2 link R1 inst1
    
        inst1 -> R1 R1
    } -result {::stsatcl::test::inst1}
    test traverse-1.2 {
        traverse many singular relationships -- violate conditionality
    } -setup {
        stsatcl STSAClass create rt1 {
            reference R1 -> rt2
        }
        stsatcl STSAClass create rt2 {
            reference R1 -> rt1
        }
    } -cleanup {
        rt1 destroy
        rt2 destroy
    } -body {
        rt1 create inst1
        rt2 create inst2
        inst1 link R1 inst2
        inst1 -> R1 R1
    } -result {reference, "R1", is unconditional, yet no instances were found}\
      -returnCodes error
    test traverse-2.0 {
        traverse a multiple relationship
    } -setup {
        stsatcl STSAClass create rt1 {
            reference R2 ->> rt2
        }
        stsatcl STSAClass create rt2 {
            reference R2 -> rt1
        }
    } -cleanup {
        rt1 destroy
        rt2 destroy
    } -body {
        rt1 create inst1
        rt2 create inst2
        rt2 create inst3
        inst1 link R2 inst2
        inst1 link R2 inst3
        inst1 -> R2
    } -result {::stsatcl::test::inst2 ::stsatcl::test::inst3}
    test reference-2.1 {
        traverse a multiple relationship, then a singular
    } -setup {
        stsatcl STSAClass create rt1 {
            reference R2 ->> rt2
        }
        stsatcl STSAClass create rt2 {
            reference R2 -> rt1
        }
    } -cleanup {
        rt1 destroy
        rt2 destroy
    } -body {
        rt1 create inst1
        rt2 create inst2
        rt2 create inst3
        inst1 link R2 inst2
        inst1 link R2 inst3
        inst2 link R2 inst1
        inst3 link R2 inst1
    
        inst1 -> R2 R2
    } -result {::stsatcl::test::inst1}
    test traverse-3.0 {
        traverse across partition
    } -setup {
        ::stsatcl STSAClass create super {
            partition R3 sub1 sub2
        }
    
        ::stsatcl STSAClass create sub1 {
            reference R3 -> super
        }
    
        ::stsatcl STSAClass create sub2 {
            reference R3 -> super
        }
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
    } -body {
        super create sup1
        sub1 create inst1
    
        sup1 link R3 inst1
        sup1 -> R3 sub1
    } -result {::stsatcl::test::inst1}
    test reference-3.1 {
        traverse across partition and single reference
    } -setup {
        ::stsatcl STSAClass create super {
            partition R10 sub1 sub2
        }
    
        ::stsatcl STSAClass create sub1 {
            reference R10 -> super
            reference R11 -> c3
        }
    
        ::stsatcl STSAClass create sub2 {
            reference R10 -> super
        }
        ::stsatcl STSAClass create c3 {
            reference R11 -> sub1
        }
        super create sup1
        sub1 create s1
        c3 create inst3
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
        c3 destroy
    } -body {
        sup1 link R10 s1
        s1 link R10 sup1
        s1 link R11 inst3
        inst3 link R11 s1
        sup1 -> R10 sub1 R11
    } -result {::stsatcl::test::inst3}
    test reference-3.2 {
        traverse across partition and single reference -- come up empty
    } -setup {
        ::stsatcl STSAClass create super {
            partition R10 sub1 sub2
        }
    
        ::stsatcl STSAClass create sub1 {
            reference R10 -> super
            reference R11 -> c3
        }
    
        ::stsatcl STSAClass create sub2 {
            reference R10 -> super
        }
        ::stsatcl STSAClass create c3 {
            reference R11 -> sub1
        }
        super create sup1
        sub1 create s1
        c3 create inst3
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
        c3 destroy
    } -body {
        sup1 link R10 s1
        s1 link R10 sup1
        s1 link R11 inst3
        inst3 link R11 s1
        sup1 -> R10 sub2 R11
    } -result {}
    test traverse-3.3 {
        traverse across partition -- wrong subclass
    } -setup {
        ::stsatcl STSAClass create super {
            partition R3 sub1 sub2
        }
    
        ::stsatcl STSAClass create sub1 {
            reference R3 -> super
        }
    
        ::stsatcl STSAClass create sub2 {
            reference R3 -> super
        }
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
    } -body {
        super create sup1
        sub1 create inst1
    
        sup1 link R3 inst1
        sup1 -> R3 sub3
    } -result {subclass, "::stsatcl::test::sub3",\
            is not a subclass of partition "R3"} -returnCodes error
    test migrate-1.0 {
        migrate subclasses
    } -setup {
        ::stsatcl STSAClass create super {
            partition R3 sub1 sub2
        }
    
        ::stsatcl STSAClass create sub1 {
            attribute {A1 20}
        }
    
        ::stsatcl STSAClass create sub2 {
            attribute {A1 30}
        }
        super create sup1
        sub1 create inst1
        sup1 link R3 inst1
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
    } -body {
        sup1 migrate R3 sub2 A1 50
        # Traverse the partition from superclass to subclass
        # to obtain the attribute value. Demonstrates the link was made.
        [sup1 -> R3 sub2] readAttributes A1
    } -result {50}
    test migrate-2.0 {
        migrate subclasses -- not a partition
    } -setup {
        ::stsatcl STSAClass create fake {
            reference R32 -> baz
        }
        ::stsatcl STSAClass create baz
    
        fake create i1
    } -cleanup {
        fake destroy
        baz destroy
    } -body {
        i1 migrate R32 sub2
    } -result {linkage "R32" is not a partition} -returnCodes error
    test migrate-3.0 {
        migrate subclasses -- unknown subclass
    } -setup {
        ::stsatcl STSAClass create super {
            partition R3 sub1 sub2
        }
    
        ::stsatcl STSAClass create sub1 {
            attribute {A1 20}
        }
    
        ::stsatcl STSAClass create sub2 {
            attribute {A1 30}
        }
        super create sup1
        sub1 create inst1
        sup1 link R3 inst1
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
    } -body {
        sup1 migrate R3 sub3
    } -result {subclass, "::stsatcl::test::sub3",\
            is not a subclass of partition "R3"} -returnCodes error
    test migrate-4.0 {
        migrate subclasses -- missing link
    } -setup {
        ::stsatcl STSAClass create super {
            partition R5 sub1 sub2
        }
        super create sup1
    } -cleanup {
        super destroy
    } -body {
        sup1 migrate R5 sub2
    } -result {reference, "R5", is unconditional, yet no instances were found}\
        -returnCodes error
    test selectWhere-1.0 {
        find instances based on criteria
    } -setup {
        ::stsatcl STSAClass create sw1 {
            attribute Count {Maximum 27} {Timeout 1000}
        }
    } -cleanup {
        sw1 destroy
    } -body {
        sw1 create inst1
        sw1 create inst2 Maximum 30 Timeout 1000
        sw1 create inst3 Timeout 2000
        set min 1000
        sw1 selectWhere inst {
            [$inst readAttributes Timeout] == $min
        }
    } -result {::stsatcl::test::inst1 ::stsatcl::test::inst2}
    test selectOneWhere-1.0 {
        find a single instance based on criteria
    } -setup {
        ::stsatcl STSAClass create sw1 {
            attribute Count {Maximum 27} {Timeout 1000}
        }
    } -cleanup {
        sw1 destroy
    } -body {
        sw1 create inst1
        sw1 create inst2 Maximum 30 Timeout 1000
        sw1 create inst3 Timeout 2000
        set min 1000
        sw1 selectOneWhere inst {
            [$inst readAttributes Timeout] == $min
        }
    } -result {::stsatcl::test::inst1}
    test selectRelatedWhere-1.0 {
        select related instances based on criteria
    } -setup {
        ::stsatcl STSAClass create frw1 {
            attribute Count {Maximum 27} {Timeout 1000}
            reference R1 ->> frw2
        }
        ::stsatcl STSAClass create frw2 {
            attribute Reason Temp Pressure Current
        }
    
        frw1 create i1
    
        frw2 create c1 Temp 20
        frw2 create c2 Temp 30
        frw2 create c3 Temp 40
        frw2 create c4 Temp 50
    
        i1 link R1 c1
        i1 link R1 c2
        i1 link R1 c3
        i1 link R1 c4
    } -cleanup {
        frw1 destroy
        frw2 destroy
    } -body {
        set targetTemp 30
        i1 selectRelatedWhere R1 selected {
            [$selected readAttributes Temp] > $targetTemp
        }
    } -result {::stsatcl::test::c3 ::stsatcl::test::c4}
    test selectRelatedWhere-2.0 {
        select instances related by multiple links
    } -setup {
        ::stsatcl STSAClass create frw1 {
            attribute Count {Maximum 27} {Timeout 1000}
            reference R1 ->> frw2
        }
        ::stsatcl STSAClass create frw2 {
            reference R2 ->> frw3
        }
        ::stsatcl STSAClass create frw3 {
            attribute Reason Temp Pressure Current
        }
    
        frw1 create i1
    
        frw2 create m1
        frw2 create m2
        i1 link R1 m1
        i1 link R1 m2
    
        # These two will be on the chain, but not match the criterion
        frw3 create c1 Temp 20
        frw3 create c2 Temp 30
        m1 link R2 c1
        m1 link R2 c2
    
        # These two will match the criterion
        frw3 create c3 Temp 40
        frw3 create c4 Temp 50
        m2 link R2 c3
        m2 link R2 c4
    } -cleanup {
        frw1 destroy
        frw2 destroy
        frw3 destroy
    } -body {
        set targetTemp 30
        i1 selectRelatedWhere {R1 R2} selected {
            [$selected readAttributes Temp] > $targetTemp
        }
    } -result {::stsatcl::test::c3 ::stsatcl::test::c4}
    test mapInstances-1.0 {
        iterate on instances to produce an attribute list
    } -setup {
        ::stsatcl STSAClass create fw1 {
            attribute Count Maximum Timeout
        }
    } -cleanup {
        fw1 destroy
    } -body {
        fw1 create inst1 Maximum 20
        fw1 create inst2 Maximum 30
        fw1 create inst3 Maximum 40
    
        set divisor 10
        fw1 mapInstances inst {
            expr {[$inst readAttributes Maximum] / $divisor}
        }
    } -result {2 3 4}
    test mapRelatedInstances-1.0 {
        iterate on related instances to produce a list
    } -setup {
        ::stsatcl STSAClass create frw1 {
            attribute Count {Maximum 27} {Timeout 1000}
            reference R1 ->> frw2
        }
        ::stsatcl STSAClass create frw2 {
            attribute Reason Temp Pressure Current
        }
    
        frw1 create i1
    
        frw2 create c1 Temp 20
        frw2 create c2 Temp 30
        frw2 create c3 Temp 40
        frw2 create c4 Temp 50
    
        i1 link R1 c1
        i1 link R1 c2
        i1 link R1 c3
        i1 link R1 c4
    } -cleanup {
        frw1 destroy
        frw2 destroy
    } -body {
        set divisor 10
        i1 mapRelatedInstances R1 inst {
            expr {[$inst readAttributes Temp] / $divisor}
        }
    } -result {2 3 4 5}
    test signal-1.0 {
        signal an event from outside of a state machine context
    } -setup {
        ::stsatcl STSAClass create sg1 {
            statemodel {
                state s1 {a} {
                    puts -nonewline $a
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        sg1 destroy
    } -body {
        sg1 create inst1
        inst1 signal e1 20
        namespace upvar [info object namespace inst1] __event_queue__ evtqueue
        dict get [lindex $evtqueue 0] src
    } -result {}
    test signal-2.0 {
        signal an event from inside of a state machine context
    } -setup {
        ::stsatcl STSAClass create sg1 {
            statemodel {
                state s1 {a} {
                    puts -nonewline $a
                }
                transition s1 - e1 -> s1
            }
        }
        ::stsatcl STSAClass create sg2 {
            reference R1 -> sg1
            instop sig_sg1 {event args} {
                [my -> R1] signal $event {*}$args
            }
        }
    } -cleanup {
        sg1 destroy
        sg2 destroy
    } -body {
        sg1 create inst1
        sg2 create inst2
        inst2 link R1 inst1
        inst2 sig_sg1 e1 20
    
        namespace upvar [info object namespace inst1] __event_queue__ evtqueue
        dict get [lindex $evtqueue 0] src
    } -result {::stsatcl::test::inst2}
    test signal-3.0 {
        signal multiple self directed events
    } -setup {
        ::stsatcl STSAClass create sg1 {
            attribute {Count 0}
            statemodel {
                state s1 {} {
                    my variable Count
                    incr Count
                    my signal e1
                    my signal e2
                }
                transition s1 - e1 -> s1
    
                state s2 {} {
                    my variable Count
                    incr Count
                }
                transition s2 - e2 -> s1
            }
        }
        ::stsatcl STSAClass create sg2 {
            reference R1 -> sg1
            instop sig_sg1 {event} {
                [info object namespace [my -> R1]]::my Receive\
                    [dict create src {} event e1 params {}]
                [my -> R1] signal e1
            }
        }
    } -cleanup {
        sg1 destroy
        sg2 destroy
    } -body {
        sg1 create inst1
        sg2 create inst2
        inst2 link R1 inst1
        inst2 sig_sg1 e1
    
        namespace upvar [info object namespace inst1] __event_queue__ evtqueue
        set checklen [expr {[llength $evtqueue] == 3}]
        set check1 [expr {[dict get [lindex $evtqueue 0] event] eq "e1"}]
        set check2 [expr {[dict get [lindex $evtqueue 1] event] eq "e2"}]
        set check3 [expr {[dict get [lindex $evtqueue 2] src] eq\
                "::stsatcl::test::inst2"}]
        expr {$checklen && $check1 && $check2 && $check3}
    } -result {1}
    test signal-4.0 {
        signal a polymorphic event
    } -setup {
        ::stsatcl STSAClass create super {
            partition R3 sub1 sub2
            polymorphic *e1
        }
    
        ::stsatcl STSAClass create sub1 {
            reference R3 -> super
            attribute {Count 0}
            statemodel {
                state sb1 {} {
                    my variable Count
                    incr Count
                }
                transition sb1 - *e1 -> sb1
            }
        }
    
        ::stsatcl STSAClass create sub2 {
            reference R3 -> super
            attribute {Count 0}
            statemodel {
                state sb1 {} {
                    my variable Count
                    incr Count
                }
                transition sb1 - *e1 -> sb1
            }
        }
    } -cleanup {
        super destroy
        sub1 destroy
        sub2 destroy
    } -body {
        super create sup1
        sub1 create inst1
        sup1 link R3 inst1
        inst1 link R3 sup1
    
        sup1 signal *e1
        namespace upvar [info object namespace inst1] __event_queue__ evtqueue
        dict get [lindex $evtqueue 0] src
    } -result {::stsatcl::test::sup1}
    test delayedSignal-1.0 {
        signal a delayed event from outside of a state machine context
    } -setup {
        ::stsatcl STSAClass create ds1 {
            statemodel {
                state s1 {a} {
                    puts -nonewline $a
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        ds1 destroy
    } -body {
        ds1 create inst1
        set begin [clock milliseconds]
        inst1 delayedSignal 100 e1 20
        namespace upvar [info object namespace inst1] __delayedSignals__ dsigs
        set expire [dict get $dsigs(,e1) expire]
    
        expr {$expire - $begin - 100 <= 2}
    } -result {1}
    test cancel-1.0 {
        cancel a delayed event
    } -setup {
        ::stsatcl STSAClass create ds1 {
            statemodel {
                state s1 {a} {
                    puts -nonewline $a
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        ds1 destroy
    } -body {
        ds1 create inst1
        set begin [clock milliseconds]
        inst1 delayedSignal 100 e1 20
        inst1 cancel e1
    
        namespace upvar [info object namespace inst1] __delayedSignals__ dsigs
        parray dsigs
        info exists dsigs(,e1)
    } -result {0}
    test remaining-1.0 {
        obtain the remaining time for a delayed event
    } -setup {
        ::stsatcl STSAClass create ds1 {
            statemodel {
                state s1 {a} {
                    puts -nonewline $a
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        ds1 destroy
    } -body {
        ds1 create inst1
        inst1 delayedSignal 100 e1 20
        set remain [inst1 remaining e1]
        expr {$remain - 100 <= 2}
    } -result {1}
    test remaining-2.0 {
        remaining time for non-existent event
    } -setup {
        ::stsatcl STSAClass create ds1 {
            statemodel {
                state s1 {a} {
                    puts -nonewline $a
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        ds1 destroy
    } -body {
        ds1 create inst1
        inst1 remaining e1
    } -result {0}
    test Receive-1.0 {
        synchronously receive a state machine event
    } -setup {
        ::stsatcl STSAClass create rc1 {
            statemodel {
                state s1 {a} {
                    puts -nonewline $a
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        rc1 destroy
    } -body {
        rc1 create inst1
        [info object namespace inst1]::my Receive\
                [dict create src {} event e1 params 20]
    } -result {} -output {20}
    test Receive-2.0 {
        cause can't happen transition
    } -setup {
        ::stsatcl STSAClass create rc1 {
            statemodel {
                state s1 {a} {
                    puts -nonewline $a
                }
                transition s1 - e1 -> s1
                transition s1 - e2 -> CH
            }
        }
    } -cleanup {
        rc1 destroy
    } -body {
        rc1 create inst1
        [info object namespace inst1]::my Receive\
                [dict create src {} event e2 params {}]
    } -result {can't happen transition: s1 - e2 -> CH} -returnCodes error
    test Receive-3.0 {
        enter a terminal state
    } -setup {
        ::stsatcl STSAClass create rc3 {
            statemodel {
                terminal s2
    
                state s1 {} {
                }
                transition s1 - e1 -> s2
    
                state s2 {} {
                }
            }
        }
    } -cleanup {
        rc3 destroy
    } -body {
        rc3 create inst1
        [info object namespace inst1]::my Receive\
                [dict create src {} event e1 params {}]
        llength [info commands ::stsatcl::test::inst1]
    } -result {0}
    test Receive-4.0 {
        ignore an event
    } -setup {
        ::stsatcl STSAClass create rc4 {
            statemodel {
                state s1 {} {
                }
                transition s1 - e1 -> s1
                transition s1 - e2 -> IG
            }
        }
    } -cleanup {
        rc4 destroy
    } -body {
        rc4 create inst1
        [info object namespace inst1]::my Receive\
                [dict create src {} event e2 params {}]
        inst1 currentstate
    } -result {s1}
    test Dispatch-1.0 {
        dispatch an event to a state machine.
    } -setup {
        ::stsatcl STSAClass create rc1 {
            statemodel {
                state s1 {a} {
                    ::stsatcl::test::syncToTest $a
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        rc1 destroy
    } -body {
        rc1 create inst1
        inst1 signal e1 20
        waitForSync
    } -result {20}
    test Dispatch-2.0 {
        dispatch multiple events to a state machine.
    } -setup {
        ::stsatcl STSAClass create rc1 {
            attribute {Count 0}
            attribute {Max 2}
            statemodel {
                state s1 {} {
                    my variable Count Max
                    incr Count
                    if {$Count >= $Max} {
                        ::stsatcl::test::syncToTest $Count
                    }
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        rc1 destroy
    } -body {
        rc1 create inst1
        inst1 signal e1
        inst1 signal e1
        waitForSync
    } -result {2}
    test DelayedDispatch-1.0 {
        dispatch a delayed event to a state machine.
    } -setup {
        ::stsatcl STSAClass create rc1 {
            statemodel {
                state s1 {} {
                    ::stsatcl::test::syncToTest [clock milliseconds]
                }
                transition s1 - e1 -> s1
            }
        }
    } -cleanup {
        rc1 destroy
    } -body {
        rc1 create inst1
        set delay 100
    
        set start [clock milliseconds]
        inst1 delayedSignal $delay e1
        set end [waitForSync]
    
        expr {$end - $start - $delay <= 2}
    } -result {1}
    test DelayedDispatch-2.0 {
        dispatch multiple delayed events to a state machine.
    } -setup {
        ::stsatcl STSAClass create rc1 {
            attribute {Count 0}
            attribute {Max 2}
            statemodel {
                state s1 {} {
                    my variable Count Max
                    incr Count
                    if {$Count >= $Max} {
                        ::stsatcl::test::syncToTest $Count
                    }
                }
                transition s1 - e1 -> s2
    
                state s2 {} {
                    my variable Count
                    incr Count
                }
                transition s2 - e2 -> s1
            }
        }
    } -cleanup {
        rc1 destroy
    } -body {
        rc1 create inst1
        set delay 100
    
        set start [clock milliseconds]
        inst1 delayedSignal $delay e1
        inst1 delayedSignal $delay e2
        set end [waitForSync]
    
        expr {$end - $start - 2 * $delay <= 2}
    } -result {1}
    test LogTrace-1.0 {
        log trace data
    } -setup {
        ::stsatcl STSAClass create tr1 {
            attribute {Count 0} {Max 2}
            statemodel {
                state s1 {} {
                    my variable Count Max
                    incr Count
                    if {$Count >= $Max} {
                        ::stsatcl::test::syncToTest $Count
                    }
                }
                transition s1 - e1 -> s2
    
                state s2 {} {
                    my variable Count
                    incr Count
                    my signal e2
                }
                transition s2 - e2 -> s1
            }
        }
    
        turnOnTraceLog
    } -cleanup {
        turnOffTraceLog
    
        tr1 destroy
    } -body {
        tr1 create inst1
        inst1 signal e1
        waitForSync
    } -result {2}
    test LogTrace-2.0 {
        log trace data for a polymorphic event
    } -setup {
        ::stsatcl STSAClass create lt2 {
            partition R1 lt2-sub1 foo
            polymorphic *e1 *e2
        }
    
        ::stsatcl STSAClass create lt2-sub1 {
            reference R1 -> lt2
            statemodel {
                state sub1-s1 {} {
                    ::stsatcl::test::syncToTest true
                }
                transition sub1-s1 - *e1 -> sub1-s2
    
                state sub1-s2 {} {
                    [my -> R1] delayedSignal 50 *e2
                }
                transition sub1-s2 - *e2 -> sub1-s1
            }
        }
    
        lt2 create super
        lt2-sub1 create sub1
        super link R1 sub1
        sub1 link R1 super
    
        turnOnTraceLog
    } -cleanup {
        turnOffTraceLog
    
        lt2 destroy
        lt2-sub1 destroy
    } -body {
        super signal *e1
        waitForSync
    } -result {true}
    test LogTrace-3.0 {
        log trace data for a creation event
    } -setup {
        ::stsatcl STSAClass create lt3 {
            statemodel {
                transition @ - e1 -> s1
    
                state s1 {value} {
                    ::stsatcl::test::syncToTest $value
                }
            }
        }
    
        turnOnTraceLog
    } -cleanup {
        turnOffTraceLog
    
        lt3 destroy
    } -body {
        set inst [lt3 signal e1 10]
        waitForSync
    } -result {10}
    test decodeAllTraces-1.0 {
        display trace data
    } -setup {
        ::stsatcl STSAClass create tr1 {
            attribute {Count 0} {Max 2}
            statemodel {
                state s1 {} {
                    my variable Count Max
                    incr Count
                    if {$Count >= $Max} {
                        ::stsatcl::test::syncToTest $Count
                    }
                }
                transition s1 - e1 -> s2
    
                state s2 {} {
                    my variable Count
                    incr Count
                }
                transition s2 - e2 -> s1
            }
        }
    } -cleanup {
        ::stsatcl traceControl off
        ::stsatcl traceControl clear
        tr1 destroy
    } -body {
        ::stsatcl traceControl on
        tr1 create inst1
        inst1 signal e1
        inst1 signal e2
        waitForSync
        set traces [::stsatcl decodeAllTraces]
        dict get [lindex $traces 0] event
    } -result {e1}
    test decodeClassTraces-1.0 {
        display trace data for specific class
    } -setup {
        ::stsatcl STSAClass create dct1 {
            reference R1 -> dct2
            attribute {Power 20}
            statemodel {
                state Off {} {
                    [my -> R1] signal Lower
                }
                transition Off - TurnOn -> On
    
                state On {power} {
                    my variable Power
                    set Power $power
                    [my -> R1] signal Raise
                }
                transition On - TurnOff -> Off
            }
        }
    
        ::stsatcl STSAClass create dct2 {
            reference R1 -> dct1
            statemodel {
                state Down {} {
                    ::stsatcl::test::syncToTest [[my -> R1] readAttributes Power]
                }
                transition Down - Raise -> Up
    
                state Up {} {
                    [my -> R1] delayedSignal 50 TurnOff
                }
                transition Up - Lower -> Down
            }
        }
    
        ::stsatcl traceControl clear
        ::stsatcl traceControl on
    } -cleanup {
        ::stsatcl traceControl off
        ::stsatcl traceControl clear
        dct1 destroy
        dct2 destroy
    } -body {
        dct1 create inst1
        dct2 create inst2
        inst1 link R1 inst2
        inst2 link R1 inst1
        inst1 signal TurnOn 30
        waitForSync
        # puts [::stsatcl formatTraces [::stsatcl decodeAllTraces]]
        set traces [::stsatcl decodeClassTraces [namespace current]::dct2]
        expr {[llength $traces] == 2 &&\
                [dict get [lindex $traces 1] event] eq "Lower"}
    } -result {1}
    test formatTraces-1.0 {
        display human readable trace data
    } -setup {
        ::stsatcl STSAClass create tr1 {
            attribute {Count 0} {Max 2}
            statemodel {
                state s1 {} {
                    my variable Count Max
                    incr Count
                    if {$Count >= $Max} {
                        ::stsatcl::test::syncToTest $Count
                    }
                }
                transition s1 - e1 -> s2
    
                state s2 {} {
                    my variable Count
                    incr Count
                }
                transition s2 - e2 -> s1
            }
        }
    } -cleanup {
        ::stsatcl traceControl off
        ::stsatcl traceControl clear
        tr1 destroy
    } -body {
        ::stsatcl traceControl on
        tr1 create inst1
        inst1 signal e1
        inst1 signal e2
        waitForSync
        set traces [::stsatcl formatTraces [::stsatcl::decodeAllTraces]]
        llength [split $traces \n]
    } -result {2}
    test info-1.0 {
        introspection on a class
    } -setup {
        ::stsatcl STSAClass create in1 {
            attribute {Count 0} {Max 2}
            reference R23 -> foo
            statemodel {
                state s1 {} {
                    puts "in s1"
                }
                transition s1 - e1 -> s2
    
                state s2 {} {
                    puts "in s2"
                }
                transition s2 - e2 -> s1
            }
        }
    } -cleanup {
        in1 destroy
    } -body {
        set pass 1
    
        set attrs [in1 info attributes]
        set pass [expr {$pass && "Count" in $attrs && "Max" in $attrs}]
        set links [in1 info links]
        set pass [expr {$pass && "R23" in $links}]
        set states [in1 info states]
        set pass [expr {$pass && "s1" in $states && "s2" in $states}]
        set events [in1 info events]
        set pass [expr {$pass && "e1" in $events && "e2" in $events}]
        set trans [in1 info transitions]
        set pass [expr {$pass && [llength $trans] == 4}]
        set istate [in1 info initialstate]
        set pass [expr {$pass && $istate eq "s1"}]
        set deftrans [in1 info defaulttrans]
        set pass [expr {$pass && $deftrans eq "CH"}]
        set terms [in1 info terminals]
        set pass [expr {$pass && [llength $terms] == 0}]
        set poly [in1 info polyevents]
        set pass [expr {$pass && [llength $poly] == 0}]
    
        set pass
    } -result {1}
    test dot-1.0 {
        draw state model with dot
    } -setup {
        ::stsatcl STSAClass create dot1 {
            statemodel {
                state s1 {} {
                    puts "in s1"
                }
                transition s1 - e2 -> s2
    
                state s2 {} {
                    puts "in s2"
                }
    
                transition @ - e1 -> s1
            }
        }
    
        # We use "dotfile" to make an expected result file
        # which is closely examined manually to serve as
        # the comparison file.
        # dot1 dotfile dot_1_results
    } -cleanup {
        dot1 destroy
    } -body {
        set diagram [dot1 dot]
        string equal $diagram [viewFile dot_1_results]
    } -result {1}
    test draw-1.0 {
        draw and render state model with dot
    } -setup {
        ::stsatcl STSAClass create dot1 {
            statemodel {
                state s1 {} {
                    puts "in s1"
                }
                transition s1 - e2 -> s2
    
                state s2 {} {
                    puts "in s2"
                }
    
                transition @ - e1 -> s1
            }
        }
    } -cleanup {
        dot1 destroy
    } -body {
        dot1 draw
    } -result {}

    cleanupTests
}
