#
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY EXTRACTED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2019 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require dbus
package require ral
package require ralutil
package require tdom
package require oo::util
package require logger
package require logger::utils
package require logger::appender
package require tcltest
package require cmdline
package require struct::set

# Add custom arguments here.
set optlist {
    {level.arg warn {Logging level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]
tcltest::configure {*}$argv

logger::setlevel $options(level)

source ../code/dbusclient.tcl

namespace eval ::dbusclient::test {
    set logger [::logger::init dbusclient]
    set appenderType [expr {[dict exist [fconfigure stdout] -mode] ?\
            "colorConsole" : "console"}]
    ::logger::utils::applyAppender -appender $appenderType -serviceCmd $logger\
            -appenderArgs {-conversionPattern {\[%c\] \[%p\] '%m'}}
    ::logger::import -all -force -namespace log dbusclient

    log::info "testing dbusclient version: [package require dbusclient]"

    namespace import ::tcltest::*
    namespace import ::dbusclient::*

    customMatch set {::struct::set equal}
    proc killServer {} {
        set conn [Connection create sessionBus session]
        Service create tserver com.modelrealization.test $conn
        tserver call /com/modelrealization/test com.modelrealization.test\
                Quit
    
        $conn destroy
    }
    proc isInSet {expected actual} {
        return [::struct::set contains $actual $expected]
    }
    customMatch contains [namespace code isInSet]

    exec ./test-server.tcl &

    test Dbus-create-1.0 {
        Create a DBus object
    } -setup {
    } -cleanup {
        sysBus destroy
    } -body {
        Connection create sysBus system
        llength [info commands sysBus]
    } -result {1}
    test Service-create-1.0 {
        Create an instance representing the bus itself
    } -setup {
        set conn [Connection create sysBus system]
    } -cleanup {
        sysBus destroy
    } -body {
        Service create DBus org.freedesktop.DBus $conn
        llength [info commands DBus]
    } -result {1}
    test Service-introspection-1.0 {
        which connection
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus connectedTo
    } -result $conn
    test Service-introspection-2.0 {
        object paths
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus pathList
    } -result {/ /org/freedesktop/DBus} -match set
    test Service-introspection-3.0 {
        selecting paths based on property value
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus findPathsByPropertyValue org.freedesktop.DBus Interfaces\
                {"org.freedesktop.DBus.Monitoring" in $Value}
    } -result {/org/freedesktop/DBus}
    test Service-introspection-4.0 {
        querying the interfaces supported by a path
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus pathInterfaces /org/freedesktop/DBus
    } -result {org.freedesktop.DBus org.freedesktop.DBus.Properties\
        org.freedesktop.DBus.Introspectable org.freedesktop.DBus.Monitoring\
        org.freedesktop.DBus.Debug.Stats org.freedesktop.DBus.Peer}\
        -match set
    test Service-introspection-5.0 {
        querying the methods supported by an interface
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus interfaceMethods org.freedesktop.DBus.Properties
    } -result {Get GetAll Set} -match set
    test Service-introspection-6.0 {
        querying the signature of a method
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus methodSignature org.freedesktop.DBus.Properties Get
    } -result {ss}
    test Service-introspection-7.0 {
        querying the properties for an interface
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus interfaceProperties org.freedesktop.DBus
    } -result {Features Interfaces} -match set
    test Service-introspection-8.0 {
        querying the signals for an interface
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus interfaceSignals org.freedesktop.DBus.Properties
    } -result {PropertiesChanged}
    test Service-call-1.0 {
        Invoke a method
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus call /org/freedesktop/DBus\
                org.freedesktop.DBus ListNames
    } -result {org.freedesktop.DBus} -match contains
    test Service-call-2.0 {
        Invoke a method -- bad path
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus call /foo org.freedesktop.DBus ListNames
    } -result {unknown path, "/foo"} -returnCodes error
    test Service-call-2.1.0 {
        Invoke a method -- bad interface
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus call /org/freedesktop/DBus org.foo ListNames
    } -result {unknown interface, "org.foo"} -returnCodes error
    test Service-call-2.1.1 {
        Invoke a method -- unimplemented on a path
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus call / org.freedesktop.DBus.Properties GetAll
    } -result {path, "/", does not implement interface,\
            "org.freedesktop.DBus.Properties"} -returnCodes error
    test Service-call-2.2 {
        Invoke a method -- bad method
    } -setup {
        set conn [Connection create sysBus system]
        Service create DBus org.freedesktop.DBus $conn
    } -cleanup {
        sysBus destroy
    } -body {
        DBus call /org/freedesktop/DBus org.freedesktop.DBus Foo
    } -result {interface, "org.freedesktop.DBus",\
                does not have a method named, "Foo"} -returnCodes error
    test property-1.0 {
        Get a property from the test server
    } -setup {
        set conn [Connection create sessionBus session]
        Service create tserver com.modelrealization.test $conn
    } -cleanup {
        sessionBus destroy
    } -body {
        tserver property\
                /com/modelrealization/test com.modelrealization.test Counter
    } -result {0}
    test property-2.0 {
        Set an property value
    } -setup {
        set conn [Connection create sessionBus session]
        Service create tserver com.modelrealization.test $conn
    } -cleanup {
        tserver waitForProperty com.modelrealization.test Counter\
            /com/modelrealization/test\
            {tserver property /com/modelrealization/test\
                com.modelrealization.test Counter 100}
        sessionBus destroy
    } -body {
        set chng [tserver waitForProperty com.modelrealization.test Counter\
            /com/modelrealization/test\
            {tserver property /com/modelrealization/test\
                com.modelrealization.test Counter 100}]
        dict get $chng value
    } -result {100}
    test signal-1.0 {
        Wait for a signal
    } -setup {
        set conn [Connection create sessionBus session]
        Service create tserver com.modelrealization.test $conn
    } -cleanup {
        sessionBus destroy
    } -body {
        set chng [tserver waitForSignal com.modelrealization.test Attention\
            /com/modelrealization/test\
            {tserver call /com/modelrealization/test\
                com.modelrealization.test Trigger}]
        dict get $chng args
    } -result {100 {Model Realization}}
    test signal-2.0 {
        Wait for a signal -- timeout
    } -setup {
        set conn [Connection create sessionBus session]
        Service create tserver com.modelrealization.test $conn
    } -cleanup {
        sessionBus destroy
    } -body {
        tserver waitForSignal com.modelrealization.test Attention\
            /com/modelrealization/test {} 500
    } -result {timed out waiting for signal change:*}\
        -match glob -returnCodes error

    killServer

    cleanupTests
}
