// vim:syntax=asciidoc:
= rvstsa - Relation Variable Based Single Threaded Software Architecture

== Introduction

Similar to +stsatcl+.

Only built upon relation variables and relational algebra.

== Error Reporting

Often any discussion of errors is pushed to the end as if it were
unimportant or an afterthought (which, sadly, in many cases it is).
Here we bring error reporting up front to emphasize its importance.

We will consistently use the +throw+ command to produce errors
in an effort to insure that reasonable error codes are produced.
Good error codes are key to programatic recovery from errors.
The format of the error code will be a list of the following elements:

. The package name in upper case, _i.e._ +RVSTSA+.
. An error code string.
. Parameters that are dependent upon the error specifics.
. A human readable error message.

Although the size of the error code list varies,
the first two elements and the last element have consistent definitions.

We factor into common code the manipulations required to +throw+
errors.

[source,tcl]
----
<<package commands>>=
proc ::rvstsa::DeclError {errcode args} {
    variable errFormats
    set errmsg [format $errFormats($errcode) {*}$args]
    tailcall throw [list STSACLASS $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the namespace of the +rvstsa+ package.

[source,tcl]
----
<<package data>>=
variable errFormats
array set errFormats {
    <<error code format>>
}
----

It is also important to realize that programs built upon this
package will perform most of their operations in event callbacks.
This means that any error encountered,
for example during a state activity,
will happen a background error.
It will be important to install a background error
handlerfootnote:[See +bgerror+ and +interp bgerror+ commands].
Attention to the error codes thrown by this package can make coding a
background error handler much easier.

== RVSTSA Class

(((class,RVSTSA Class)))

[source,tcl]
----
<<package commands>>=
::oo::class create ::rvstsa::RVSTSAClass {
    unexport new
    <<rvstsa class configuration>>
}

<<package exports>>=
namespace export RVSTSAClass
----

=== Create

Want to have all the underlying relvars in the same namespace
and resolve all the objects into the same namespace

(((method,RVSTSAClass,create)))

[source,tcl]
----
<<rvstsa class configuration>>=
self method create {name args} {
    set name [::rvstsa::ResolveName $name]
    if {[namespace exists $name]} {
        ::rvstsa::DeclError DUP_NAME $name
    }

    set path [namespace eval $name namespace path]
    lappend path [namespace parent $name]
    namespace eval $name [list namespace path $path]

    return [my createWithNamespace $name $name {*}$args]
}
----

(((error code,DUP_NAME)))
[source,tcl]
----
<<error code format>>=
DUP_NAME {namespace "%s" already exists}
----

[float]
===== Create Method Tests

[source,tcl]
----
<<constructor tests>>=
test obj-create-1.0 {
    create objects in fixed namespaces
} -setup {
    ::rvstsa RVSTSAClass create testns::at1 {
        attribute a1 string
        identifier a1
    }
} -cleanup {
    testns::at1 destroy
} -body {
    namespace exists [namespace current]::testns::at1
} -result {1}
----

=== Defining RVSTSA Classes

[source,tcl]
----
<<required packages>>=
package require ral
package require ralutil

<<rvstsa class constructor>>=
namespace import ::ral::*
namespace import ::ralutil::*
----

[source,tcl]
----
<<required packages>>=
package require oo::util
# The mixin of "oo::class.Delegate", interacts badly with meta-classes that
# have constructor arguments. So we eliminate the oo::class mixins here. This
# will mean that you can't define class methods.
#::oo::define oo::class self mixin
----

[source,tcl]
----
<<rvstsa class constructor>>=
link\
    {attribute Attribute}\
    {identifier Identifier}\
    {statemodel Statemodel}\
    {classop ClassOp}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable attrInfo
set attrInfo [relation create {Name string DataType string DefValue string}]
----

The implementation of the +Attribute+ method consists of an
interation over the arguments, validating the attribute names
and assigning the default values into the +attrInfo+ dictionary.

(((method,RVSTSAClass,Attribute)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Attribute {name datatype {defvalue {}}} {
    my variable attrInfo

    if {$name eq {}} {
        tailcall ::rvstsa::DeclError BAD_ATTRIBUTE $name
    }
    my CheckDupAttribute $name
    set attrInfo [relation insert $attrInfo [list\
        Name        $name\
        DataType    $datatype\
        DefValue    $defvalue\
    ]]
}
----

(((error code,BAD_ATTRIBUTE)))
[source,tcl]
----
<<error code format>>=
BAD_ATTRIBUTE           {invalid attribute name, "%s"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable idCounter
set idCounter 0
my variable idInfo
set idInfo [relation create {IdNum int IdAttrs list}]
----

(((method,RVSTSAClass,Identifier)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Identifier {args} {
    foreach attr $args {
        my CheckAttrExists $attr
    }

    my variable idCounter
    my variable idInfo
    set idInfo [relation insert $idInfo [list\
        IdNum   [incr idCounter]\
        IdAttrs $args\
    ]]
}
----

=== Defining RVSTSA Class State Models

[source,tcl]
----
<<helper commands>>=
proc ::oo::Helpers::linkTo {childns args} {   # <1>
    set childns [string trim $childns :]    ; # <2>
    namespace eval $childns {}              ; # <3>
    set ns [uplevel 1 {namespace current}]
    foreach link $args {
	if {[llength $link] == 2} {
	    lassign $link src dst
	} else {
	    lassign $link src
	    set dst $src
	}
	interp alias {} ${ns}::${childns}::$src {} ${ns}::my $dst ; # <4>
    }
    return
}
----
<1> _N.B._ we put this procedure into a namespace that is accessible to
all TclOO objects.
<2> Clean up any extraneous colon characters. We definitely don't want
any leading colons as that would imply a fully-qualified namespace name.
<3> Make sure to create the namespace.
<4> Use an +alias+ to link the command in the child namespace back to a class
method.

With the ability to link commands to a child namespace,
we can now define the state model configuration commands.

[source,tcl]
----
<<rvstsa class constructor>>=
linkTo smdsl\
    {state State}\
    {transition Transition}\
    {defaultTrans DefaultTrans}\
    {initialState InitialState}\
    {terminal Terminal}
----

(((method,RVSTSAClass,Statemodel)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Statemodel {script} {
    namespace eval [namespace current]::smdsl $script
    my Attribute __state__ string
}
----

(((method,RVSTSAClass,ClassOp)))

[source,tcl]
----
<<rvstsa class configuration>>=
method ClassOp {name arglist body} {
    ::oo::objdefine [self] method $name $arglist $body
    ::oo::objdefine [self] export $name
}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable states
set states [relation create {StateName string}]
----

(((method,STSAClass,State)))

[source,tcl]
----
<<rvstsa class configuration>>=
method State {name argList body} {
    my variable states
    if {$name in {IG CH @}} {
        tailcall ::rvstsa::DeclError RESERVED_STATE $name
    }
    try {
        set states [relation insert $states [list StateName $name]]
    } trap {RAL relation insert DUPLICATE_TUPLE} {} {
        tailcall ::rvstsa::DeclError DUPLICATE_STATE $name
    }
    ::oo::objdefine [self] method ${name}__STATE__ $argList $body
    ::oo::objdefine [self] unexport ${name}__STATE__
}
----

(((error code,RESERVED_STATE)))
(((error code,DUPLICATE_STATE)))
[source,tcl]
----
<<error code format>>=
RESERVED_STATE      {states may not be named by the reserved name, "%s"}
DUPLICATE_STATE     {duplicate state, "%s"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable transitions
set transitions [relation create {FromState string Event string ToState string}]
----

(((method,STSAClass,Transition)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Transition {fromstate - event -> tostate} {
    if {$fromstate in {IG CH}} {
        tailcall ::rvstsa::DeclError TRANS_SRC $fromstate
    } elseif {$fromstate eq "@"} {
        my variable states
        set states [relation uinsert $states [list StateName $fromstate]]
    }

    if {$tostate eq "@"} {
        tailcall ::rvstsa::DeclError TRANS_DST
    }

    my variable transitions
    try {
        set transitions [relation insert $transitions [list\
            FromState   $fromstate\
            Event       $event\
            ToState     $tostate\
        ]]
    } trap {RAL relation insert DUPLICATE_TUPLE} {} {
        tailcall ::rvstsa::DeclError DUPLICATE_TRANS $fromstate $event $tostate
    }
}
----

(((error code,TRANS_SRC)))
(((error code,TRANS_DST)))
(((error code,DUPLICATE_TRANS)))
[source,tcl]
----
<<error code format>>=
TRANS_SRC           {a transition cannot originate from the "%s" pseudo-state}
TRANS_DST           {the initial pseudo-state, "@", cannot be the\
                     target of a transition}
DUPLICATE_TRANS     {duplicate transition, "%s - %s -> %s"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable defaulttrans
set defaulttrans CH
----

(((method,RVSTSAClass,DefaultTrans)))

[source,tcl]
----
<<rvstsa class configuration>>=
method DefaultTrans {trans} {
    if {$trans in {IG CH}} {
        my variable defaulttrans
        set defaulttrans $trans
    } else {
        tailcall ::rvstsa::DeclError BAD_DEFAULT_TRANS $trans
    }
}
----
(((error code,BAD_DEFAULT_TRANS)))
[source,tcl]
----
<<error code format>>=
BAD_DEFAULT_TRANS       {bad default transition name, "%s": must be one of\
                         "IG" or "CH"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable initialstate
set initialstate {}
----

(((method,RVSTSAClass,InitialState)))

[source,tcl]
----
<<rvstsa class configuration>>=
method InitialState {state} {
    if {$state in {IG CH @ {}}} {
        tailcall ::rvstsa::DeclError BAD_INIT_STATE $state
    }
    my variable initialstate
    set initialstate $state
}
----

(((error code,BAD_INIT_STATE)))
[source,tcl]
----
<<error code format>>=
BAD_INIT_STATE      {initial state, "%s", cannot be "IG", "CH", "@" or empty}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable terminals
set terminals [relation create {StateName string}]
----

(((method,STSAClass,Terminal)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Terminal {args} {
    my variable terminals
    foreach state $args {
        if {$state in {IG CH @ {}}} {
            tailcall ::rvstsa::DeclError BAD_TERM_STATE $state
        }
        set terminals [relation uinsert $terminals [list StateName $state]]
    }
}
----
(((error code,BAD_TERM_STATE)))
[source,tcl]
----
<<error code format>>=
BAD_TERM_STATE  {terminal state, "%s", cannot be "IG", "CH", "@" or empty}
----

(((error code,NO_IDENTIFIERS)))
[source,tcl]
----
<<error code format>>=
NO_IDENTIFIERS  {no identifiers defined for class, "%s"}
----

=== Constructor

(((method,RVSTSAClass,constructor)))

[source,tcl]
----
<<rvstsa class configuration>>=
constructor {config} {
    <<rvstsa class constructor>>
}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my eval $config
----

Build the relvar implied by the attributes

[source,tcl]
----
<<rvstsa class constructor>>=
if {[relation isnotempty $attrInfo]} {
    if {[relation isempty $idInfo]} {
        tailcall ::rvstsa::DeclError NO_IDENTIFIERS [self]
    }
    if {[relation isnotempty $states] != 0} {
        <<validate transitions>>
        <<validate initial state>>
        <<validate terminal states>>
        <<compute transition matrix>>
        set attrInfo [relation insert $attrInfo [list\
            Name        __State__\
            DataType    string\
            DefValue    $initialstate\
        ]]

        <<event dispatch data setup>>
        ::oo::objdefine [self] {
            <<state related methods>>
        }
    }
    set header [relation dict\
            [relation project $attrInfo Name DataType] Name DataType]
    set ids [relation list [relation project $idInfo IdAttrs]]
    relvar create [self] $header {*}$ids
    relvar trace add variable [self] insert [mymethod SetDefaultAttrs]
} else {
    tailcall ::rvstsa::DeclError NO_ATTRIBUTES [self]
}
----

(((error code,BAD_INIT_STATE)))
[source,tcl]
----
<<error code format>>=
NO_ATTRIBUTES      {class, "%s", defined with no attributes}
----

[source,tcl]
----
<<rvstsa class configuration>>=
method SetDefaultAttrs {insert rvname tuple} {
    my variable attrInfo
    set missingAttrs [pipe {
        tuple attributes $tuple |
        relation fromlist ~ Name string |
        relation semiminus ~ $attrInfo
    }]

    if {[relation isnotempty $missingAttrs]} {
        set missNames [relation list $missingAttrs Name -ascending Name]
        set missTypes [relation list $missingAttrs DataType -ascending Name]
        set missValues [relation list $missingAttrs DefValue -ascending Name]

        set missing [list]
        foreach name $missNames type $missTypes value $missValues {
            lappend missing $name $type $value
        }
        set tuple [tuple extend $tuple {*}$missing]
    }
    return $tuple
}
----

[source,tcl]
----
<<validate transitions>>=
set missingFrom [relation semiminus $states $transitions\
        -using {StateName FromState}]
relation foreach badFrom $missingFrom {
    relation assign $badFrom
    ::rvstsa::DeclError UNKNOWN_SRC_STATE $FromState $Event $ToState
}

set nodefs [relation restrictwith $transitions {
    $ToState ne "IG" && $ToState ne "CH"}]

set missingTo [relation semiminus $states $nodefs -using {StateName ToState}]
relation foreach badTo $missingTo {
    relation assign $badTo
    ::rvstsa::DeclError UNKNOWN_DST_STATE $FromState $Event $ToState
}
----

(((error code,UNKNOWN_SRC_STATE)))
(((error code,UNKNOWN_DST_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_SRC_STATE       {unknown source state in transition, "%s - %s -> %s"}
UNKNOWN_DST_STATE       {unknown target state in transition, "%s - %s -> %s"}
----

[source,tcl]
----
<<validate transitions>>=
# Compute isolated states

set noout [relation semiminus $transitions $states -using {FromState StateName}]
set noin [relation semiminus $nodefs $states -using {ToState StateName}]
set isolated [relation intersect $noout $noin]

if {[relation isnotempty $isolated]} {
    tailcall ::rvstsa::DeclError ISOLATED [relation list $isolated]
}
----

(((error code,ISOLATED)))
[source,tcl]
----
<<error code format>>=
ISOLATED        {state model has isolated state(s): "%s"}
----

[source,tcl]
----
<<validate initial state>>=
if {$initialstate eq {}} {
    set initialstate [lindex $states 0]
} elseif {$initialstate ni $states} {
    tailcall ::rvstsa::DeclError UNKNOWN_INIT_STATE $initialstate
}
----
(((error code,UNKNOWN_INIT_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_INIT_STATE      {unknown initial state, "%s"}
----

[source,tcl]
----
<<validate terminal states>>=
set missingTerms [pipe {
    relation semiminus $states $terminals |
    relation list ~
}]

if {[llength $missingTerms] != 0} {
    tailcall ::rvstsa::DeclError UNKNOWN_TERM_STATE $missingTerms
}
----

(((error code,UNKNOWN_TERM_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_TERM_STATE      {unknown terminal states, "%s"}
----

[source,tcl]
----
<<compute transition matrix>>=
# Hold the transition matrix in a relvar.

set heading [list __State__ string __IsTermState__ boolean]
set eventNames [relation list [relation project $transitions Event]]
foreach eventName $eventNames {
    lappend heading $eventName string
}

set transRelvar [self]_Transitions
relvar create $transRelvar $heading __State__

set tuples [list]
foreach stateName [relation list $states] {
    set entry [list\
        __State__       $stateName\
        __IsTermState__ [relation isnotempty\
            [relation restrictwith $terminals {$StateName eq $state}]]\
    ]

    foreach eventName $eventNames {
        set trans [relation restrictwith $transitions {
            $FromState eq $stateName && $Event eq $eventName
        }]
        set toState [expr {[relation isnotempty $trans] ?\
            [relation extract $trans ToState] : $defaulttrans}]
        lappend entry $eventName $toState
    }
    lappend tuples $entry
}
relvar insert $transRelvar {*}$tuples

#puts [relformat [relvar set $transRelvar] $transRelvar]
----

[float]
===== Constructor Tests

[source,tcl]
----
<<constructor tests>>=
test constructor-1.0 {
    create object with attributes
} -setup {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        attribute Amount int
        identifier UserName
    }
} -cleanup {
    UserAccount destroy
} -body {
    relvar names [namespace current]::*
} -result {::rvstsa::test::UserAccount}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-2.0 {
    create object with state model -- duplicate state
} -setup {
} -cleanup {
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            state s1 {} {
                puts "in s1"
            }
        }
    }
} -result {duplicate state, "s1"} -returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test constructor-3.1 {
    create object with state model -- bad src state
} -setup {
} -cleanup {
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            transition s3 - e1 -> s1
        }
    }
} -result {unknown source state in transition, "s3 - e1 -> s1"}\
  -returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test constructor-3.2 {
    create object with state model -- bad destination state
} -setup {
} -cleanup {
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            transition s1 - e1 -> s3
        }
    }
} -result {unknown target state in transition, "s1 - e1 -> s3"}\
  -returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test constructor-3.3 {
    create object with state model -- isolated state
} -setup {
} -cleanup {
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            transition s1 - e1 -> s1

            state s2 {} {
                puts "in s2"
            }
        }
    }
} -result {state model has isolated state(s): "s2"}\
  -returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test constructor-3.4 {
    create object with state model -- bad terminal state
} -setup {
} -cleanup {
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            transition s1 - e1 -> s1

            terminal s3
        }
    }
} -result {unknown terminal states, "s3"}\
  -returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test constructor-4.1 {
    create object with state model -- simple transitions
} -setup {
} -cleanup {
    UserAccount destroy
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            transition s1 - e1 -> s1
        }
    }
    relation cardinality\
        [relvar set [namespace current]::UserAccount_Transitions]
} -result {1}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-4.2 {
    create object with state model -- complex transitions
} -setup {
} -cleanup {
    UserAccount destroy
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            transition s1 - e1 -> s1
            transition s1 - e2 -> s2

            state s2 {} {
                puts "in s1"
            }
            transition s2 - e2 -> s1
            transition s2 - e3 -> s3

            state s3 {} {
                puts "in s1"
            }
            transition s3 - e3 -> s3
            transition s3 - e1 -> s1
        }
    }
    relation cardinality\
        [relvar set [namespace current]::UserAccount_Transitions]
} -result {3}
----

=== Destructor

(((method,RVSTSAClass,destructor)))

[source,tcl]
----
<<rvstsa class configuration>>=
destructor {
    if {[llength [relvar names [self]]] != 0} {
        relvar unset [self]
    }
    if {[llength [relvar names [self]_Transitions]] != 0} {
        <<event dispatch data cleanup>>
        relvar unset [self]_Transitions
    }
    namespace delete [self]
}
----

=== Creating Instances

(((method,RVSTSAClass,create)))

[source,tcl]
----
<<rvstsa class configuration>>=
method create {args} {
    tailcall relvar insert [self] $args
}
----

(((method,RVSTSAClass,createin)))

[source,tcl]
----
<<state related methods>>=
method createin {state args} {
    set transrelvar [self]_Transitions
    if {[relation isempty [relvar restrictone $transrelvar __State__ $state]]} {
        tailcall ::rvstsa::DeclError UNKNOWN_INIT_STATE $state
    }
    tailcall relation eliminate\
        [relvar insert [self] [list __State__ $state {*}$args]] __State__
}
----

=== Dereferences Instances

(((method,RVSTSAClass,deref)))

[source,tcl]
----
<<state related methods>>=
# returns an instance from a reference
method deref {instref} {
    tailcall relation semijoin [my refOf $instref] [relvar set [self]]
}

# returns an reference to an instance
method refOf {inst} {
    if {$inst ne {}} {
        tailcall relation project $inst {*}[lindex [relvar identifiers [self]] 0]
    }
}
----

[float]
===== Create Tests

[source,tcl]
----
<<exported methods tests>>=
test create-1.0 {
    create object with attributes
} -setup {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        attribute Amount int 100
        identifier UserName
    }
} -cleanup {
    UserAccount destroy
} -body {
    set inserted [UserAccount create UserName "John Hughes"]
    relation extract $inserted Amount
} -result {100}
----

[source,tcl]
----
<<exported methods tests>>=
test create-2.0 {
    create object in a given state
} -setup {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        attribute Amount int 100
        identifier UserName
        statemodel {
            state closed {} {
                puts "in closed"
            }
            transition closed - open -> opened

            state opened {} {
                puts "in opened"
            }
            transition opened - close -> closed
            transition opened - timeout -> dormant

            state dormant {} {
                puts "in dormant"
            }
            transition dormant - close -> closed
        }
    }
} -cleanup {
    UserAccount destroy
} -body {
    set inserted [UserAccount createin dormant UserName "Fred Jones"]
    UserAccount currentstate $inserted
} -result {dormant}
----

== State Model Operations

[source,tcl]
----
<<event dispatch data setup>>=
my variable __event_queue__
set __event_queue__ [list]


my variable __eventIdCounter
set __eventIdCounter 0
relvar create __signals {EventId int TimerId string} EventId TimerId
relvar create __delayedSignals {FromState string Event string TimerId string}\
    {FromState Event} TimerId
----

[source,tcl]
----
<<event dispatch data cleanup>>=
foreach timerid [relation list [relvar set __signals] TimerId] {
    after cancel $timerid
}
foreach timerid [relation list [relvar set __delayedSignals] TimerId] {
    after cancel $timerid
}
----

(((method,RVSTSAClass,currentstate)))

[source,tcl]
----
<<state related methods>>=
method currentstate {instref} {
    tailcall relation extract [my deref $instref] __State__
}
----

(((method,RVSTSAClass,signal)))

[source,tcl]
----
<<state related methods>>=
method signal {srcinst event dstinsts args} {
    my ValidateEvent $event
    set srcclass [my EventSource]
    set srcref [my refOf $srcinst]

    my variable __event_queue

    relation foreach dstinst $dstinsts {
        set dstref [my refOf $dstinst]
        <<create new event>>
    }

    return
}
----

[source,tcl]
----
<<create new event>>=
set eventInfo [dict create\
    srcclass $srcclass\
    srcref  $srcref\
    dstref  $dstref\
    event   $event\
    params  $args\
]
# Self directed events are queued to the front.  However, we handle the
# case where a state activity may signal multiple self-directed events.
# In that, admittedly unusual case, we want to preserve the order of
# the signalled events.
if {$srcclass eq [self]} {
    for {set nsindex 0} {$nsindex < [llength $__event_queue__]}\
            {incr nsindex} {
        set cmpevent [lindex $__event_queue__ $nsindex]
        if {[dict get $cmpevent src] ne [self]} {
            break
        }
    }
    set __event_queue [linsert $__event_queue $nsindex $eventInfo]
} else {
    lappend __event_queue $eventInfo
}
my variable __eventIdCounter
relvar insert __signals [list\
    EventId     [incr __eventIdCounter]\
    TimerId     [::after 0 [mymethod Dispatch $__eventIdCounter]]\
]
----

[source,tcl]
----
<<exported methods tests>>=
test signal-1.0 {
    signal an event to an
} -setup {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        attribute Amount int 100
        identifier UserName
        statemodel {
            state closed {} {
                puts "in closed"
            }
            transition closed - open -> opened

            state opened {} {
                puts "in opened"
            }
            transition opened - close -> closed
            transition opened - timeout -> dormant

            state dormant {} {
                puts "in dormant"
            }
            transition dormant - close -> closed
        }
    }
    ::rvstsa RVSTSAClass create Banker {
        attribute Name string
        identifier Name
        classop newAccount {user} {
            puts "ns = [namespace current]"
            puts "path = [namespace path]"
            set newuser [::rvstsa::test::UserAccount create UserName $user]
            ::rvstsa::test::UserAccount signal {} open $newuser
        }
    }
} -cleanup {
    UserAccount destroy
    Banker destroy
} -body {
    Banker create Name Chuck
    Banker newAccount "Fred Jones"
    namespace upvar [info object namespace UserAccount] __event_queue event_queue
    puts "event_queue = \"$event_queue\""
    llength $event_queue
} -result {1}
----

(((method,RVSTSAClass,Dispatch)))

[source,tcl]
----
<<state related methods>>=
method Dispatch {eventid} {
    set sig [relvar restrictone __signals EventId $eventid]
    if {[relation isnotempty $sig]} {
        relvar deleteone __signals EventId $eventid

        my variable __event_queue
        if {[llength $__event_queue] != 0} {
            # Pull the event from the front of the queue.
            set eventInfo [lindex $__event_queue__ 0]
            set __event_queue__ [lrange $__event_queue__ 1 end]
            tailcall my Receive $eventInfo
        }
    }
}
----

(((method,XUMLClass,Receive)))
    instref $instref\
    src $src\
    event $event\
    params $params\

[source,tcl]
----
<<state related methods>>=
method Receive {eventInfo} {
    dict with eventInfo {

        set inst [my deref $instref]
        set currstate [relation extract $inst __State__]
        ### HERE

    set newState $transitions($__currentstate__,$event)

    ::stsatcl::TraceTransition [dict get $eventInfo src] $event [self]\
        $__currentstate__ $newState $params

    if {$newState eq "CH"} {
        tailcall ::stsatcl::DeclError CH_TRANSITION $__currentstate__ $event
    } elseif {$newState ne "IG"} {
        set __currentstate__ $newState
        try {
            my ${__currentstate__}__STATE__ {*}$params ;
        } finally {
            classvariable terminals ; # <5>
            if {$__currentstate__ in $terminals} {
                my destroy
            }
        }
    }
    return
    }
}
----

== Common Utility Commands

=== Resolve Name

(((proc,ResolveName)))

[source,tcl]
----
<<package commands>>=
proc ResolveName {name {level 2}} {
    if {[string range $name 0 1] ne "::"} {
        set name\
            [string trimright [uplevel $level namespace current] :]::$name
    }
    return $name
}
----

=== Check Duplicate Attribute

(((proc,CheckDupAttribute)))

[source,tcl]
----
<<rvstsa class configuration>>=
method CheckDupAttribute {name} {
    my variable attrInfo
    if {[relation isnotempty\
            [relation restrictwith $attrInfo {$Name eq $name}]]} {
        tailcall ::rvstsa::DeclError DUP_ATTRIBUTE $name
    }
}
----

(((error code, DUP_ATTRIBUTE)))
[source,tcl]
----
<<error code format>>=
DUP_ATTRIBUTE           {duplicate attribute name, "%s"}
----

=== Check Attribute Exists

(((proc,CheckAttrExists)))

[source,tcl]
----
<<rvstsa class configuration>>=
method CheckAttrExists {name} {
    my variable attrInfo
    if {[relation isempty\
            [relation restrictwith $attrInfo {$Name eq $name}]]} {
        tailcall ::rvstsa::DeclError UNKNOWN_ATTRIBUTE $name
    }
}
----
(((error code,UNKNOWN_ATTRIBUTE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_ATTRIBUTE        {unknown attribute name, "%s"}
----

=== Validate Event

(((method,XUMLClass,ValidateEvent)))

[source,tcl]
----
<<rvstsa class configuration>>=
# Make sure we are dealing with a known event.
method ValidateEvent {event} {
    my variable transitions
    if {$event ni [relation list $transitions Event]} {
        tailcall ::rvstsa::DeclError UNKNOWN_EVENT $event
    }
}
----

[source,tcl]
----
<<error code format>>=
UNKNOWN_EVENT   {unknown event, "%s"}
----

=== Event Source

(((method,RVSTSAClass,EventSource)))

[source,tcl]
----
<<rvstsa class configuration>>=
method EventSource {} {
    try {
        set src [lindex [uplevel 1 {self caller}] 1] ; # <1>
        puts "EventSource: [uplevel 1 {self caller}]"
    } on error {} {
        set src {}
    }
    return $src
}
----
<1> +self caller+ throws an error if the caller is not a method.

== Code Organization

=== Source Code

[source,tcl]
----
<<rvstsa.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6

<<required packages>>

namespace eval ::rvstsa {
    <<package exports>>
    namespace ensemble create

    variable version 1.0a1

    <<package data>>
    <<package initialization>>
    <<package commands>>
}
<<helper commands>>

package provide rvstsa $::rvstsa::version
----

=== Unit Tests

[source,tcl]
----
<<rvstsa.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger

source ../src/rvstsa.tcl
chan puts "testing rvstsa version: [package require rvstsa]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

package require tcltest
eval tcltest::configure $argv

namespace eval ::rvstsa::test {
    ::logger::initNamespace [namespace current] $::options(level)

    namespace import ::tcltest::*
    namespace import ::ral::*
    namespace import ::ralutil::*

    <<test utility procs>>
    <<constructor tests>>
    <<exported methods tests>>
    <<unexported methods tests>>

    cleanupTests
}
----


////
[source,tcl]
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded rvstsa 1.0 [list source [file join $dir rvstsa.tcl]]
----
