// vim:syntax=asciidoc:
= rvstsa - Relation Variable Based Single Threaded Software Architecture

== Introduction

Similar to +stsatcl+.

Only built upon relation variables and relational algebra.

== Error Reporting

Often any discussion of errors is pushed to the end as if it were
unimportant or an afterthought (which, sadly, in many cases it is).
Here we bring error reporting up front to emphasize its importance.

We will consistently use the +throw+ command to produce errors
in an effort to insure that reasonable error codes are produced.
Good error codes are key to programatic recovery from errors.
The format of the error code will be a list of the following elements:

. The package name in upper case, _i.e._ +RVSTSA+.
. An error code string.
. Parameters that are dependent upon the error specifics.
. A human readable error message.

Although the size of the error code list varies,
the first two elements and the last element have consistent definitions.

We factor into common code the manipulations required to +throw+
errors.

[source,tcl]
----
<<package commands>>=
proc ::rvstsa::DeclError {errcode args} {
    variable errFormats
    set errmsg [format $errFormats($errcode) {*}$args]
    tailcall throw [list STSACLASS $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the namespace of the +rvstsa+ package.

[source,tcl]
----
<<package data>>=
variable errFormats
array set errFormats {
    <<error code format>>
}
----

It is also important to realize that programs built upon this
package will perform most of their operations in event callbacks.
This means that any error encountered,
for example during a state activity,
will happen a background error.
It will be important to install a background error
handlerfootnote:[See +bgerror+ and +interp bgerror+ commands].
Attention to the error codes thrown by this package can make coding a
background error handler much easier.

== RVSTSA Class

(((class,RVSTSA Class)))

[source,tcl]
----
<<package commands>>=
::oo::class create ::rvstsa::RVSTSAClass {
    unexport new
    <<rvstsa class configuration>>
}

<<package exports>>=
namespace export RVSTSAClass
----

=== Create

Want to have all the underlying relvars in the same namespace
and resolve all the objects into the same namespace

(((method,RVSTSAClass,create)))

[source,tcl]
----
<<rvstsa class configuration>>=
self method create {name args} {
    set name [::rvstsa::ResolveName $name]
    if {[namespace exists $name]} {
        ::rvstsa::DeclError DUP_NAME $name
    }
    namespace eval $name {}
    return [my createWithNamespace $name $name {*}$args]
}
----

(((error code,DUP_NAME)))
[source,tcl]
----
<<error code format>>=
DUP_NAME {namespace "%s" already exists}
----

[float]
===== Create Method Tests

[source,tcl]
----
<<constructor tests>>=
test create-1.0 {
    create objects in fixed namespaces
} -setup {
    ::rvstsa RVSTSAClass create testns::at1 {
        attribute a1 string
        identifier a1
    }
} -cleanup {
    testns::at1 destroy
} -body {
    namespace exists [namespace current]::testns::at1
} -result {1}
----

=== Constructor

(((method,RVSTSAClass,constructor)))

[source,tcl]
----
<<rvstsa class configuration>>=
constructor {config} {
    <<rvstsa class constructor>>
}
----

[source,tcl]
----
<<required packages>>=
package require ral
package require ralutil

<<rvstsa class constructor>>=
namespace import ::ral::*
namespace import ::ralutil::*
----

[source,tcl]
----
<<required packages>>=
package require struct::set
package require struct::list
----

[source,tcl]
----
<<required packages>>=
package require oo::util
# The mixin of "oo::class.Delegate", interacts badly with meta-classes that
# have constructor arguments. So we eliminate the oo::class mixins here. This
# will mean that you can't define class methods.
#::oo::define oo::class self mixin
----

[source,tcl]
----
<<rvstsa class constructor>>=
link\
    {attribute Attribute}\
    {identifier Identifier}\
    {statemodel Statemodel}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable attrInfo
set attrInfo [relation create {Name string DataType string DefValue string}]
----

The implementation of the +Attribute+ method consists of an
interation over the arguments, validating the attribute names
and assigning the default values into the +attrInfo+ dictionary.

(((method,RVSTSAClass,Attribute)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Attribute {name datatype {defvalue {}}} {
    my variable attrInfo

    if {$name eq {}} {
        tailcall ::rvstsa::DeclError BAD_ATTRIBUTE $name
    }
    my CheckDupAttribute $name
    set attrInfo [relation insert $attrInfo [list\
        Name        $name\
        DataType    $datatype\
        DefValue    $defvalue\
    ]]
}
----

(((error code,BAD_ATTRIBUTE)))
[source,tcl]
----
<<error code format>>=
BAD_ATTRIBUTE           {invalid attribute name, "%s"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable idCounter
set idCounter 0
my variable idInfo
set idInfo [relation create {IdNum int IdAttrs list}]
----

(((method,RVSTSAClass,Identifier)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Identifier {args} {
    foreach attr $args {
        my CheckAttrExists $attr
    }

    my variable idCounter
    my variable idInfo
    set idInfo [relation insert $idInfo [list\
        IdNum   [incr idCounter]\
        IdAttrs $args\
    ]]
}
----

[source,tcl]
----
<<helper commands>>=
proc ::oo::Helpers::linkTo {childns args} {   # <1>
    set childns [string trim $childns :]    ; # <2>
    namespace eval $childns {}              ; # <3>
    set ns [uplevel 1 {namespace current}]
    foreach link $args {
	if {[llength $link] == 2} {
	    lassign $link src dst
	} else {
	    lassign $link src
	    set dst $src
	}
	interp alias {} ${ns}::${childns}::$src {} ${ns}::my $dst ; # <4>
    }
    return
}
----
<1> _N.B._ we put this procedure into a namespace that is accessible to
all TclOO objects.
<2> Clean up any extraneous colon characters. We definitely don't want
any leading colons as that would imply a fully-qualified namespace name.
<3> Make sure to create the namespace.
<4> Use an +alias+ to link the command in the child namespace back to a class
method.

With the ability to link commands to a child namespace,
we can now define the state model configuration commands.

[source,tcl]
----
<<rvstsa class constructor>>=
linkTo smdsl\
    {state State}\
    {transition Transition}\
    {defaultTrans DefaultTrans}\
    {initialState InitialState}\
    {terminal Terminal}
----

(((method,RVSTSAClass,Statemodel)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Statemodel {script} {
    namespace eval [namespace current]::smdsl $script
    my Attribute __state__ string
}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable states
set states [relation create {StateName string}]
----

(((method,STSAClass,State)))

[source,tcl]
----
<<rvstsa class configuration>>=
method State {name argList body} {
    my variable states
    if {$name in {IG CH @}} {
        tailcall ::rvstsa::DeclError RESERVED_STATE $name
    }
    try {
        set states [relation insert $states [list StateName $name]]
    } trap {RAL relation insert DUPLICATE_TUPLE} {} {
        tailcall ::rvstsa::DeclError DUPLICATE_STATE $name
    }
    ::oo::objdefine [self] method ${name}__STATE__ $argList $body
    ::oo::objdefine [self] unexport ${name}__STATE__
}
----

(((error code,RESERVED_STATE)))
(((error code,DUPLICATE_STATE)))
[source,tcl]
----
<<error code format>>=
RESERVED_STATE      {states may not be named by the reserved name, "%s"}
DUPLICATE_STATE     {duplicate state, "%s"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable events
set events [relation create {EventName string}]
my variable transitions
set transitions [relation create {FromState string Event string ToState string}]
----

(((method,STSAClass,Transition)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Transition {fromstate - event -> tostate} {
    if {$fromstate in {IG CH}} {
        tailcall ::rvstsa::DeclError TRANS_SRC $fromstate
    } elseif {$fromstate eq "@"} {
        my variable states
        set states [relation uinsert $states [list StateName $fromstate]]
    }

    if {$tostate eq "@"} {
        tailcall ::rvstsa::DeclError TRANS_DST
    }
    my variable events
    set events [relation uinsert $events [list EventName $event]]

    my variable transitions
    try {
        set transitions [relation insert $transitions [list\
            FromState   $fromstate\
            Event       $event\
            ToState     $tostate\
        ]]
    } trap {RAL relation insert DUPLICATE_TUPLE} {} {
        tailcall ::rvstsa::DeclError DUPLICATE_TRANS $fromstate $event $tostate
    }
}
----

(((error code,TRANS_SRC)))
(((error code,TRANS_DST)))
(((error code,DUPLICATE_TRANS)))
[source,tcl]
----
<<error code format>>=
TRANS_SRC           {a transition cannot originate from the "%s" pseudo-state}
TRANS_DST           {the initial pseudo-state, "@", cannot be the\
                     target of a transition}
DUPLICATE_TRANS     {duplicate transition, "%s - %s -> %s"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable defaulttrans CH
----

(((method,RVSTSAClass,DefaultTrans)))

[source,tcl]
----
<<rvstsa class configuration>>=
method DefaultTrans {trans} {
    if {$trans in {IG CH}} {
        my variable defaulttrans
        set defaulttrans $trans
    } else {
        tailcall ::rvstsa::DeclError BAD_DEFAULT_TRANS $trans
    }
}
----
(((error code,BAD_DEFAULT_TRANS)))
[source,tcl]
----
<<error code format>>=
BAD_DEFAULT_TRANS       {bad default transition name, "%s": must be one of\
                         "IG" or "CH"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable initialstate
set initialstate {}
----

(((method,RVSTSAClass,InitialState)))

[source,tcl]
----
<<rvstsa class configuration>>=
method InitialState {state} {
    if {$state in {IG CH @ {}}} {
        tailcall ::rvstsa::DeclError BAD_INIT_STATE $state
    }
    my variable initialstate
    set initialstate $state
}
----

(((error code,BAD_INIT_STATE)))
[source,tcl]
----
<<error code format>>=
BAD_INIT_STATE      {initial state, "%s", cannot be "IG", "CH", "@" or empty}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my variable terminals
set terminals [relation create {StateName string}]
----

(((method,STSAClass,Terminal)))

[source,tcl]
----
<<rvstsa class configuration>>=
method Terminal {args} {
    my variable terminals
    foreach state $args {
        if {$state in {IG CH @ {}}} {
            tailcall ::rvstsa::DeclError BAD_TERM_STATE $state
        }
        set terminals [relation uinsert $terminals [list StateName $state]]
    }
}
----
(((error code,BAD_TERM_STATE)))
[source,tcl]
----
<<error code format>>=
BAD_TERM_STATE  {terminal state, "%s", cannot be "IG", "CH", "@" or empty}
----

(((error code,NO_IDENTIFIERS)))
[source,tcl]
----
<<error code format>>=
NO_IDENTIFIERS  {no identifiers defined for class, "%s"}
----

[source,tcl]
----
<<rvstsa class constructor>>=
my eval $config
----

Build the relvar implied by the attributes

[source,tcl]
----
<<rvstsa class constructor>>=
if {[relation isnotempty $attrInfo]} {
    if {[relation isempty $idInfo]} {
        tailcall ::rvstsa::DeclError NO_IDENTIFIERS [self]
    }
    if {[llength $states] != 0} {
        <<validate transitions>>
        <<validate initial state>>
        <<validate terminal states>>
        set attrInfo [relation insert $attrInfo [list\
            Name        __state__\
            DataType    string\
            DefValue    $initialstate\
        ]]
    }
    set header [relation dict\
            [relation project $attrInfo Name DataType] Name DataType]
    set ids [relation list [relation project $idInfo IdAttrs]]
    relvar create [self] $header {*}$ids
} else {
    tailcall ::rvstsa::DeclError NO_ATTRIBUTES [self]
}
----

(((error code,BAD_INIT_STATE)))
[source,tcl]
----
<<error code format>>=
NO_ATTRIBUTES      {class, "%s", defined with no attributes}
----

[source,tcl]
----
<<validate transitions>>=
set missingFrom [relation semiminus $states $transitions\
        -using {StateName FromState}]
relation foreach badFrom $missingFrom {
    relation assign $badFrom
    tailcall ::rvstsa::DeclError UNKNOWN_SRC_STATE $FromState $Event $ToState
}

set missingTo [pipe {
    relation restrictwith $transitions {$ToState ne "IG" && $ToState ne "CH"} |
    relation semiminus $states ~ -using {StateName ToState}
}]
relation foreach badTo $missingTo {
    relation assign $badTo
    tailcall ::rvstsa::DeclError UNKNOWN_DST_STATE $FromState $Event $ToState
}
----

(((error code,UNKNOWN_SRC_STATE)))
(((error code,UNKNOWN_DST_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_SRC_STATE       {unknown source state in transition, "%s - %s -> %s"}
UNKNOWN_DST_STATE       {unknown target state in transition, "%s - %s -> %s"}
----

[source,tcl]
----
<<validate initial state>>=
if {$initialstate eq {}} {
    set initialstate [lindex $states 0]
} elseif {$initialstate ni $states} {
    tailcall ::rvstsa::DeclError UNKNOWN_INIT_STATE $initialstate
}
----
(((error code,UNKNOWN_INIT_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_INIT_STATE      {unknown initial state, "%s"}
----

[source,tcl]
----
<<validate terminal states>>=
if {![::struct::set subsetof $terminals $states]} {
    set unknown [::struct::set difference $terminals $states]
    tailcall ::rvstsa::DeclError UNKNOWN_TERM_STATE $unknown
}
----
(((error code,UNKNOWN_TERM_STATE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_TERM_STATE      {unknown terminal states, "%s"}
----

[float]
===== Constructor Tests

[source,tcl]
----
<<constructor tests>>=
test constructor-1.0 {
    create object with attributes
} -setup {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        attribute Amount int
        identifier UserName
    }
} -cleanup {
    UserAccount destroy
} -body {
    relvar names [namespace current]::*
} -result {::rvstsa::test::UserAccount}
----

[source,tcl]
----
<<constructor tests>>=
test constructor-2.0 {
    create object with state model -- duplicate state
} -setup {
} -cleanup {
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            state s1 {} {
                puts "in s1"
            }
        }
    }
} -result {duplicate state, "s1"} -returnCodes error
----

[source,tcl]
----
<<constructor tests>>=
test constructor-2.0 {
    create object with state model -- bad src state
} -setup {
} -cleanup {
} -body {
    ::rvstsa RVSTSAClass create UserAccount {
        attribute UserName string
        identifier UserName
        statemodel {
            state s1 {} {
                puts "in s1"
            }
            transition s3 - e1 -> s1
        }
    }
} -result {unknown source state in transition, "s3 - e1 -> s1"}\
  -returnCodes error
----

=== Destructor

(((method,RVSTSAClass,destructor)))

[source,tcl]
----
<<rvstsa class configuration>>=
destructor {
    if {[relvar names [self]] ne {}} {
        relvar unset [self]
    }
    namespace delete [self]
}
----

== Common Utility Commands

=== Resolve Name

(((proc,ResolveName)))

[source,tcl]
----
<<package commands>>=
proc ResolveName {name {level 2}} {
    if {[string range $name 0 1] ne "::"} {
        set name\
            [string trimright [uplevel $level namespace current] :]::$name
    }
    return $name
}
----

=== Check Duplicate Attribute

(((proc,CheckDupAttribute)))

[source,tcl]
----
<<rvstsa class configuration>>=
method CheckDupAttribute {name} {
    my variable attrInfo
    if {[relation isnotempty\
            [relation restrictwith $attrInfo {$Name eq $name}]]} {
        tailcall ::rvstsa::DeclError DUP_ATTRIBUTE $name
    }
}
----

(((error code, DUP_ATTRIBUTE)))
[source,tcl]
----
<<error code format>>=
DUP_ATTRIBUTE           {duplicate attribute name, "%s"}
----

=== Check Attribute Exists

(((proc,CheckAttrExists)))

[source,tcl]
----
<<rvstsa class configuration>>=
method CheckAttrExists {name} {
    my variable attrInfo
    if {[relation isempty\
            [relation restrictwith $attrInfo {$Name eq $name}]]} {
        tailcall ::rvstsa::DeclError UNKNOWN_ATTRIBUTE $name
    }
}
----
(((error code,UNKNOWN_ATTRIBUTE)))
[source,tcl]
----
<<error code format>>=
UNKNOWN_ATTRIBUTE        {unknown attribute name, "%s"}
----

== Code Organization

=== Source Code

[source,tcl]
----
<<rvstsa.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6

<<required packages>>

namespace eval ::rvstsa {
    <<package exports>>
    namespace ensemble create

    variable version 1.0a1

    <<package data>>
    <<package initialization>>
    <<package commands>>
}
<<helper commands>>

package provide rvstsa $::rvstsa::version
----

=== Unit Tests

[source,tcl]
----
<<rvstsa.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2014 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require cmdline
package require logger

source ../src/rvstsa.tcl
chan puts "testing rvstsa version: [package require rvstsa]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

package require tcltest
eval tcltest::configure $argv

namespace eval ::rvstsa::test {
    ::logger::initNamespace [namespace current] $::options(level)

    namespace import ::tcltest::*
    namespace import ::ral::*
    namespace import ::ralutil::*

    <<test utility procs>>
    <<constructor tests>>
    <<exported methods tests>>
    <<unexported methods tests>>

    cleanupTests
}
----


////
[source,tcl]
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded rvstsa 1.0 [list source [file join $dir rvstsa.tcl]]
----
