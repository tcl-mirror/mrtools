// vim:set syntax=asciidoc:
= Simple Bookstore Model Translation

== Introduction [[introduction,Introduction]]

This document presents a translation of the case study model from the
book,
'Executable UML: A Foundation for Model-Driven Architecture'
by Stephen J. Mellor and Marc J. Balcer.
The translation is targeted at the ``C'' implementation language using
the http://repos.modelrealization.com/cgi-bin/fossil/mrtools[`micca`]
package.
The model can be found in Appendix B in the book on page 313.

This document is also a
http://www.literateprogramming.com[literate program].
It contains all the code of the translation and the execution scenarios
that exercise the program.
The literate program source and all the output is available at the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools[Model Realization]
web site.

Translation using `micca` has a manual component.
The model diagrams are transcribed into a domain specific language (DSL)
that is provided by `micca`.
The classes, relationships and state models are defined in a declarative
manner.
The state activities must be translated from action language into ``C''
using embedded macros provided by `micca` to implement the model level actions.
For example,
action language statements to select related instances are translated
into invocations of the `%<instance ref foreachRelated self ...>%` macro.
Generally, action language statements translate one-for-one into lines
of embedded macro code and the correspondence is direct if you understand the
conventions of ``C'' programming and the embedded macro language.
Once transcribed into the `micca` DSL,
a code generation phase is invoked.
This code generation produces two files, a ``C'' header file and a ``C''
code file.
Once generation is completed,
the application can be compiled and linked and
we can exercise the resulting program by signaling events or
invoking any operations that are provided.

In the next sections,
we explain some preliminary details that must precede the translation.
Some of these details have to do with the on-line bookstore model itself
and some deal with the specifics of translating using `micca`.
After the preliminaries,
we present the translation organized into subsystems and presented
in the order found in the book.
Next we show a sample population of the model and that is followed by
procedures that stub out the explicit external entity functions found
in the model.
Finally, we present a set of scenarios to exercise the model.
`Micca` has many capabilties to deal with execution traces
and we show a textual log of the event dispatch.

=== How to Read This Document [[howtoreadthisdocument,How to Read This Document]]

This document presents the translation of the online bookstore case study
in the same order as the model is shown in the appendix of the book.
This is intended to facilitate easier reference between the text and the
translation and demonstrate how the model directly drives the implementation as
it is transcribed into `micca` configuration commands.
However, if you are more interested in the result and what happens when the
translation is run, then you should skip to the
<<executionscenarios>> section.
There you can see the result of running a set of scenarios on the
translated model.


== Model Details [[modeldetails,Model Details]]

My experience is that until they are translated and made into running programs,
all models contain small errors and inconsistencies.
This is not an reflection on the authors of the model or of the quality
of their work.
Because translatable models must be so detailed,
it is inevitable that inconsistencies and errors arise.
After all,
no one, no matter how carefully coded, expects a program to compile
the first time without errors.
On the rare occasions it happens,
it is a cause for celebration!
The same situation applies here.
We will endeavor to point out the errors and state clearly how we deal
with inconsistences.
Since the publishing of the book,
a set of errata have been published on the book's website.
We have taken those errata into account in this translation.

We must also remember that this domain is but one in what would be a larger
system to handle online ordering.
See Figure 17.1 on page 276 of the book to get an indication of
what that larger system might look like.
Consequently,
we will not deal with any parts of the translation that involve joining
multiple domains.
This is a bit disappointing as this part of assembling a system can be
quite complex and is required for all but the tiniest of systems.
The `micca` package and its underlying Tcl language constructs are well
suited to many of the problems one faces during the construction of
bridge operations.
It would be an interesting undertaking to construct another domain
for the Online Bookstore application and show how bridging in the
`micca` implementation could be accomplished, but we do not undertake
that in this translation.

It should also be noted that no domain level operations are defined
for the online bookstore domain and so no external programming
interface to the domain is provided.

The result of this translation is the code for the domain
itself and a set of scenarios that exercise the domain.
You can think of this translation as providing the code for domain
and a preliminary set of unit tests in the form of execution scenarios.
When I undertake system development using translation,
this is usually the first step in the process of building the system.
It is quite useful to be able to run a domain in isolation and construct
a set of unit tests to exercise it.
But it only a first step.
When building a system of multiple domains,
itegration of the domains is also required.
I usually build a set of running programs integrating one additional domain
until the system is fully built.
The order of integration follows the usual mantra of:
[quote]
Analyze from the top down and build from the bottom up.

A better way of stating this is to analyze the most application dependent
portions first, but build the system infrastructure first.
This is because it is usually easier to build code to drive a partial
system than it is to build stubs intelligent enough to simulate
missing system components.

These intermediary applications are useful for regression testing and
for dealing with the inevitable changes that happen to domain models.
Often the tests developed for the single domain unit tests are useful
in integrating domains.
It is important to remember that building is not _one big step_ but rather
one of building many integration and test applications, the final one of
which contains everything and is the one delivered.
This is a rather long explanation of the fact that what you will find
in this document is only the first part of what it would take to build
a real online bookstore system.

== Translation Conventions [[translationconventions,Translation Conventions]]

During the evolution of Executable UML,
the authors of
_Executable UML_
decided that referential attributes and identifying constraints were optional.
In my opinion, this decision was a regression of the method.
It certainly can reduce the clutter of the class diagram graphic and
reduce the need for invented identifiers,
but it makes it much easier to skip over the details of how
relationships are actually formalized.
Also, combining referential attributes makes constraints on the data model
and does so in a declarativefootnote:[as opposed to a procedural way]
way.

Regardless of your view of referential attributes,
a translation using `micca` discards them anyway.
`Micca` adopts the usual translation convention when static languages
are targeted, namely to use the address of the class instance as
an architectural identifier and as the basis for navigating relationships.
So,
attributes that only serve the role of identifiers or referential
attributes are discarded from the model.

`Micca` does not support the notion of derived attributes.
We have a couple of options to deal with them:

. Delete the derived attributes and add code into the translation to
compute them whenever they are read.
. Keep the derived attribute and add the redundant code required to
keep them up to date when any of the dependent attributes change.

We have chosen the later approach in this translation since it makes
access to the class diagram data from outside the domain much easier.
We should also note that the model as presented in the appendix
does not state what the composition of the derived attributes are.
But we can make reasonable guesses from the context and will point
them out as we encounter them.

Creating instances is also slightly different in `micca`.
Action language allows one to create a class instance without supplying
all the attributes a value at the time the creation operation is invoked.
`Micca` insists that all attributes have some value at the time
an instance is created.
This will involve some shuffling around of actions that perform
instance creation.
In particular,
this model creates a number of class instances asynchronously.
Often the model will pass along as event parameters the values of
attributes which are then set in the state activity first executed
when the creation event is delivered.
It is a simple matter to remove those values as event parameters and
supply them as attribute values at the signaling of the creation event.
Since `micca` supports the notion of a default value,
we will also use that feature to reduce some of the tedium of
supplying attribute values at instance creation time.

The matter of allowing instances to be created without setting all the
attributes to a value is a bit more troubling in general.
Since most translation schemes are targeted at statically compiled languages
with the implicit assumption that class instances are held in memory,
the idea of creating a class instance usually maps to allocating
a piece of memory of the appropriate size.
In this regime,
assigning attributes piecemeal is easily done.
However, for software architectures targeted at databases which
have strong relational underpinnings,
piecemeal setting of attribute values is not allowedfootnote:[Well
databases can handle it with some awkward NULL value nonsense, but
`micca` has no notion of a NULL and none of the three values logic
required to deal with NULL values.].
The danger of piecemeal attribute assignment during creation is that
the possibility exists that an attribute might not be given an intial value
during certain execution paths through a state activity.
For in-memory data structures, this means an attribute might have an arbitrary
value or the value represented by all bits of the memory being zero.
Best practice is to have the model set the values of all attributes at instance
creation time.

To make the correspondence to the text of the book explicit,
we will order the presentation in the same order as the book.
The domain is presented as three subsystems.
Within each subsystem,
the class definitions appear in the same order as the book.
Relationship definitions are dealt with differently.
In the book text,
each _side_ of the relationship is presented with the class that is a
participant in the relationship
and the relationship is stated from point of view of the participating class.
For `micca`, we must define the relationships exactly once.
So we give relationship definitions near the class that contains
the referential attributes that formalize the relationship.
The exceptions to this are associations with an associative class and
generalization relationships.
For associative classes,
we define the corresponding association with them
and we define the generalization along with the superclass.
This ordering is used to clarify the translation's correspondence with the
book text.
`Micca` allows an arbitrary order for these definitions.

Readers will probably find it essential to refer to the text of the book
as you read the translation.
It's impractical to print all the text and graphics of the model in this
document if only because it would be a violation of copyright law.
However, we will include small portions of the model here when it serves
to clarify the translation.
Consequently,
you will find much of the translation presented with little additional
text.
We will comment when clarity is required or when we are doing something
`micca` specific, but little else is really required.
Reading the translation and the text of the book side-by-side is
sufficient to show how the translation was accomplished.

== Data Types [[datatypes,Data Types]]

`Micca` requires attributes to be given an data type.
That data type is, of course, an implementation data type and must
be a data type defined in ``C''.

Comments on the mapping of domain data types to implementation data types
are given below.

arbitrary_id::
    Arbitrary id's are rarely needed in a `micca` translation since
    the object address serves that role.
Money::
    We'll hold money as an `int` in units of cents.
date::
    Here we are using formatted string as dates. Another choice would be
    to use the number of seconds since the epoch.
    The formatted string are easier to read.
    The seconds representation is easier to compute on.
    The model does not appear to perform any date computations.
MailingAddress::
    Real world addresses are painful. We punt here and just hold strings.
    Another option would be to have a tuple valued attributes that
    could separate out the various component parts of the address,
    _e.g._ number, street, city, state, etc.
    Since state activities don't deal with the address as anything
    other than a unit, we'll stick with simple strings.
WebsiteURL::
InternetEmailAddress::
TelephoneNumber::
    All these types could benefit from check expressions to validate
    their string format and content.
    We have not done that here and just use simple strings.

== Product Specification Subsystem [[productspecificationsubsytem,Product Specification Subsystem]]

The Product Specification Subsytem consists of the following classes.

[source,tcl]
----
<<Product Specification Subsystem>>=
<<Product Class Definition>>
<<Publisher Class Definition>>
<<Author Class Definition>>
<<Authorship Class Definition>>
<<Book Product Class Definition>>
<<Recording Product Class Definition>>
<<Software Product Class Definition>>
<<Special Order Product Class Definition>>
<<Stocked Product Class Definition>>
<<Product Category Class Definition>>
<<Recording Class Definition>>
<<Artist Class Definition>>
<<Performance Credit Class Definition>>
<<Recording Format Class Definition>>
<<Platform Class Definition>>
<<Computer Software Class Definition>>
----

=== Product Class [[productclass,Product]]

(((Product Specification,Classes,Product)))
[source,tcl]
----
<<Product Class Definition>>=
class Product {
    attribute productID char -dimension 32
    attribute productName char -dimension 32
    attribute copyright char -dimension 16
    attribute unitPrice unsigned
    attribute description char -dimension 256
    attribute website char -dimension 256
    attribute currentlyAvailable bool
}
----

(((Product Specification,Relationships,R12)))
(((Product Specification,Relationships,R11)))
(((Product Specification,Relationships,R15)))
(((Product Specification,Relationships,R1)))
[source,tcl]
----
<<Product Class Definition>>=
generalization R12 Product SpecialOrderProduct StockedProduct
generalization R11 Product BookProduct RecordingProduct SoftwareProduct
association R15 Product 0..*--1 ProductCategory
association R1 Product 0..*--1 Publisher
----

=== Publisher Class [[publisherclass,Publisher]]

(((Product Specification,Classes,Publisher)))
[source,tcl]
----
<<Publisher Class Definition>>=
class Publisher {
    attribute groupCode char -dimension 32
    attribute publisherCode char -dimension 32
    attribute name char -dimension 64
    attribute address char -dimension 128
    attribute website char -dimension 256
}
----
<1> Per the model, there are two identifying attributes.

=== Author Class [[authorclass,Author]]

(((Product Specification,Classes,Author)))
[source,tcl]
----
<<Author Class Definition>>=
class Author {
    attribute name char -dimension 64
    attribute website char -dimension 256
    attribute email char -dimension 64
}
----

=== Authorship Class [[authorshipclass,Authorship]]

Authorship is an association class.
From the relational view,
association classes have referential attributes to refer to both the
participating classes.
Because `R2` is a many-to-many association,
those referential attributes also constitute an identifier.
It is also true that the instances of the association class correspond
one-to-one to the instances of the association itself and that the
number of instances is less than or equal to the product of the number of
instances of the participating classes.

(((Product Specification,Classes,Authorship)))
[source,tcl]
----
<<Authorship Class Definition>>=
class Authorship {
    attribute preCredit char -dimension 64
    attribute postCredit char -dimension 64
}
----

(((Product Specification,Relationships,R3)))
(((Product Specification,Relationships,R2)))
[source,tcl]
----
<<Authorship Class Definition>>=
association R2 -associator Authorship BookProduct 1..*--0..* Author
association R3 Authorship 0..1--0..1 Authorship
----

To be absolutely pedantic the `R3`,
relationship does not, in and of itself, guarantee a linear ordering.
It requires that the initial instance population or the action code set things
up correctly to achieve desired ordering.
In practice, this is easily done and the number of classes required to
guarantee an ordering by virtue of referential integrity constraints is
usually not worth it.
Another alternative is to realize this relationship using an attribute
that is ordered, such as a sequential integer.
Then, the ordered set of authors of a book could be found by selecting on the
`productID` and sorting by the ordering attribute.
Depending upon the way Authorship is being used might favor one approach
over another.
Here we just stick with the straight forward referential attributes
and contrive to populate the model to achieve the order we want.

=== Book Product Class [[bookproductclass,BookProduct]]

(((Product Specification,Classes,BookProduct)))
[source,tcl]
----
<<Book Product Class Definition>>=
class BookProduct {
    attribute bookNumber char -dimension 32
    attribute titleCode char -dimension 32
    attribute title char -dimension 128
    attribute subtitle char -dimension 128
}
----
<1> All subclasses of a generalization have a referential attribute
back to the superclass of the generalization.
Since there is a one-to-one correspondence between a subclass and
its superclass, the referential attribute is also an identifying attribute.
The fact that an attribute can serve many roles happens often
and is another facet of the ability of referential attributes and
identity constraints to constraint the instance attribute values properly.

=== Recording Product Class [[recordingproductclass,Recording Product]]

In addition to being a subclass in a generalization,
the `Recording Product` class is also an associative class.
We follow the same pattern here as we established in the `Authorship`
class translation.

(((Product Specification,Classes,Recording Product)))
[source,tcl]
----
<<Recording Product Class Definition>>=
class RecordingProduct {
    attribute runningTime unsigned
}
----
<1> Here we introduce the referential attribute for the generalization.
<2> Here are the referential attributes for the role of `RecordingProduct`
as an associator class.

(((Product Specification,Relationships,R16)))
[source,tcl]
----
<<Recording Product Class Definition>>=
association R16 -associator RecordingProduct Recording 1..*--1..* RecordingFormat
----

=== Software Product Class [[softwareproductclass,Software Product]]

(((Product Specification,Classes,Software Product)))
[source,tcl]
----
<<Software Product Class Definition>>=
class SoftwareProduct {
    attribute productVersion char -dimension 32
}
----

(((Product Specification,Relationships,R19)))
(((Product Specification,Relationships,R20)))
[source,tcl]
----
<<Software Product Class Definition>>=
association R19 SoftwareProduct 1..*--1 Platform
association R20 SoftwareProduct 1..*--1 ComputerSoftware
----

=== Special Order Product Class [[specialorderproductclass,Special Order Product]]

(((Product Specification,Classes,Special Order Product)))
[source,tcl]
----
<<Special Order Product Class Definition>>=
class SpecialOrderProduct {
    attribute specialOrderInstructions char -dimension 256
    attribute daysToDeliver unsigned
}
----

=== Stocked Product Class [[stockedproductclass,Stocked Product]]

(((Product Specification,Classes,Stocked Product)))
[source,tcl]
----
<<Stocked Product Class Definition>>=
class StockedProduct {
    attribute quantityOnHand unsigned
    attribute reorderThreshold unsigned
    attribute reorderIncrement unsigned
    attribute reorderInstructions char -dimension 256
}
----

=== Product Category Class [[productcategoryclass,Product Category]]

(((Product Specification,Classes,Product Category)))
[source,tcl]
----
<<Product Category Class Definition>>=
class ProductCategory {
    attribute categoryName char -dimension 32
}
----

(((Product Specification,Relationships,R14)))
[source,tcl]
----
<<Product Category Class Definition>>=
association R14 ProductCategory 0..*--0..1 ProductCategory
----

=== Recording Class [[recordingclass,Recording]]

(((Product Specification,Classes,Recording)))
[source,tcl]
----
<<Recording Class Definition>>=
class Recording {
    attribute title char -dimension 128
}
----

=== Artist Class [[artistclass,Artist]]

(((Product Specification,Classes,Artist)))
[source,tcl]
----
<<Artist Class Definition>>=
class Artist {
    attribute artistName char -dimension 128
}
----

=== Performance Credit Class [[performancecreditclass,Performance Credit]]

(((Product Specification,Classes,Performance Credit)))
[source,tcl]
----
<<Performance Credit Class Definition>>=
class PerformanceCredit {
    attribute role char -dimension 32
}
----

(((Product Specification,Relationships,R17)))
(((Product Specification,Relationships,R18)))
[source,tcl]
----
<<Performance Credit Class Definition>>=
association R17 -associator PerformanceCredit Recording 1..*--1..* Artist
association R18 PerformanceCredit 0..1--0..1 PerformanceCredit
----

=== Recording Format Class [[recordingformatclass,Recording Format]]

(((Product Specification,Classes,Recording Format)))
[source,tcl]
----
<<Recording Format Class Definition>>=
class RecordingFormat {
    attribute formatName char -dimension 32
}
----

=== Platform Class [[platformclass,Platform]]

(((Product Specification,Classes,Platform)))
[source,tcl]
----
<<Platform Class Definition>>=
class Platform {
    attribute platformName char -dimension 32
}
----

=== Computer Software Class [[computersoftwareclass,Computer Software]]

(((Product Specification,Classes,Computer Software)))
[source,tcl]
----
<<Computer Software Class Definition>>=
class ComputerSoftware {
    attribute title char -dimension 128
}
----

== Ordering Subsystem [[orderingsubsytem,Ordering Subsystem]]

The Ordering Subsystem consist of the following classes.

[source,tcl]
----
<<Ordering Subsystem>>=
<<Customer Class Definition>>
<<Order Class Definition>>
<<Product Selection Class Definition>>
<<Shopping Cart Class Definition>>
<<Credit Card Charge Class Definition>>
----

=== Customer Class [[customerclass,Customer]]

(((Ordering,Classes,Customer)))
[source,tcl]
----
<<Customer Class Definition>>=
class Customer {
    attribute email char -dimension 64
    attribute name char -dimension 64
    attribute shippingAddress char -dimension 64
    attribute phone char -dimension 32
    attribute purchasesMade unsigned -default 0 ; # <1>
}
----
<1> When Customer instances are created, they have certainly not made
any purchases so we can specify a default value to ease the burden
of specifying attributes at creation time.

=== Order Class [[orderclass,Order]]

The `Order` class is the first we encounter that has a state model
associated with it.

(((Ordering,Classes,Order)))
[source,tcl]
----
<<Order Class Definition>>=
class Order {
    attribute orderID unsigned
    attribute dateOrderPlaced char -dimension 64
    attribute totalValue unsigned
    attribute recipient char -dimension 128
    attribute deliveryAddress char -dimension 128
    attribute contactPhone char -dimension 32

    statemodel {
        <<Order State Model>>
    }
}
----

(((Ordering,Relationships,R10)))
(((Ordering,Relationships,R5)))
[source,tcl]
----
<<Order Class Definition>>=
association R10 Order 0..1--1 ShoppingCart
association R5 Order 1..*--0..1 Customer ; # <1>
----
<1> There is an interesting policy decision represented here.
A Customer is not a Customer unless he/she has placed at least one order.
Interesting -- not wrong or bad -- just interesting.

==== Order Class State Model

(((Ordering,State Models,Order)))
[source,tcl]
----
<<Order State Model>>=
transition @ - checkOut -> EstablishingCustomerandVerifyingPayment ; # <1>
----
<1> Here we encounter our first creation event.
In `micca` the `@` symbol is used to represent the pseudo-initial state
out of which a creation event transitions.

[source,tcl]
----
<<Order State Model>>=
state EstablishingCustomerandVerifyingPayment {
        cart accountNumber billingAddress cardExpirationDate
        cardholderName customerEmail} {
    R10 link $self $cart

    set customer [Customer findById email $customerEmail]
    assignAttribute $self recipient deliveryAddress contactPhone
    if {[isEmptyRef $customer]} {
        set customer [Customer create\
            email $customerEmail\
            name $recipient\
            shippingAddress $deliveryAddress\
            phone $contactPhone
        ]
    } else {
        updateAttribute $customer\
            name $recipient\
            shippingAddress $deliveryAddress\
            phone $contactPhone
    }

    R5 link $self $customer

    updateAttribute $self dateOrderPlaced [clock format [clock seconds]]

    signal $self submitCharge $accountNumber $billingAddress\
        $cardExpirationDate $cardholderName
}

transition EstablishingCustomerandVerifyingPayment - submitCharge ->\
    SubmittingCharge
----

The translation of the state activity to Tcl is quite direct.
Action language `relate` statements correspond to the `link` subcommand
for the relationship involved, in this case `R10`.
We also see the differences that result from creating having to supply
the values of all the attributes of the created instance.
Using `micca`, we must make a clear distinction between creating the instance
and updating the attributes of an existing instance.

[source,tcl]
----
<<Order State Model>>=
state SubmittingCharge {accountNumber billingAddress cardExpirationDate
        cardholderName} {
    CreditCardCharge createasync makeCharge [list $self]\
        accountNumber $accountNumber\
        cardholderName $cardholderName\
        billingAddress $billingAddress\
        cardExpirationDate $cardExpirationDate\
        chargeAmount [readAttribute $self totalValue] ; # <1>
}

transition SubmittingCharge - paymentApproved -> BeingPackedandShipped
transition SubmittingCharge - paymentDeclined -> PaymentNotApproved
----
<1> Generating an event to the class _creator_, _i.e._ generating a
creation event, is accomplished as the `createasync` subcommand on the
target class.
Again, all the values of the attributes must be supplied since
the instance must be created before the creation event is dispatched.
The `[list $self]` argument is the parameter of the creation event itself,
_i.e._ the instance reference of an order is a parameter to the `makeCharge`
event.

Note that we have factored the `makeCharge` event parameters.
In the model graphic on page 342,
you can see that there are many parameters passed with the event.
All of these parameters, except the `Order` instance reference,
are simply used to set the values of the `CreditCardCharge` instance
and so we have factored them out to the creation event generation
as discussed above.
This is an interesting example of how the idoms of action language have
to be translated into a different set of idoms in Tcl.

[source,tcl]
----
<<Order State Model>>=
state PaymentNotApproved {} {
    set customer [findRelated $self R5]
    # generate chargeDeclined(customerEmail: customer.email)
    #       to EE_OnlineCustomer
    EE_OnLineCustomer::chargeDeclined [readAttribute $customer email] ; # <1>
}

transition PaymentNotApproved - subCharge -> SubmittingCharge
----
<1> The action language text from the model is shown on the line immediately
above.
`Micca` does not have any direct support for generating events to external
entities.
Instead,
we create explict bridge operations, in this case 
`EE_OnLineCustomer::chargeDeclined`, passing the required parameters.
That bridge operation can then map the semantics of a _declined charge_
onto the appropriate operation of the domain that represents the
Online Customer external entity.
In a `micca` translation,
all the interactions with external entities are represented by
procedures.
Those procedures then handle whether the interaction is synchronous or
event based.
We will see examples of this in the <<externalentities>> section below.

[source,tcl]
----
<<Order State Model>>=
state BeingPackedandShipped {} {
    set customer [findRelated $self R5]
    EE_OnLineCustomer::chargeApproved [readAttribute $customer email]

    assignAttribute $self recipient deliveryAddress contactPhone
    Shipment createasync requestShipment [list $self]\
        recipient $recipient\
        deliveryAddress $deliveryAddress\
        contactPhone $contactPhone
}
transition BeingPackedandShipped - orderDelivered -> DeliveredtoCustomer

state DeliveredtoCustomer {} {
    set customer [findRelated $self R5] ; # <1>
    EE_OnLineCustomer::orderReportedDelivered [readAttribute $customer email]
}
----
<1> So the question arises as to whether we should test the `customer`
instance reference for being empty.
After all, R5 is conditional on the `Customer` side.
In this case the answer is no, since all paths to this state come
through the *Establishing Customer and Verifying Payment* state where
a link to `R5` is made and so we have every expectation
that we will find a single instance related by `R5`.
We know that we will find at most one since `R5` has a multiplicity of one
and any attempt to link an order to multiple `Customers` will fail
referential integrity checks.
So, might we want make the test anyway just to be sure?
Again, the answer is no.
If somehow the `customer` instance reference does not refer to
exactly one instance then the `readAttribute` command will throw an
error (as documented in the manual for that command).
The lesson here is that superfluous multiplicity tests are not necessary
and only serve to clutter the code.
The referential integrity checks performed by `micca` go a long way to
insure correct operation.

=== Product Selection Class [[productselectionclass,Product Selection]]

The `ProductSelection` class is an associative class and has a state model.
The state model is interesting because it has both a creation event
and a terminal state.
The state, `RemovingSelection`, is terminal and the instance is deleted
after executing the state activity for that state.

(((Ordering,Classes,Product Selection)))
[source,tcl]
----
<<Product Selection Class Definition>>=
class ProductSelection {
    attribute quantity unsigned -default 0
    attribute unitPriceOfSelection unsigned -default 0
    attribute selectionValue unsigned -default 0

    statemodel {
        <<Product Selection State Model>>
    }
}
----
<1> Note the referential attributes needed for the class association
and those attributes form an identifier.

(((Ordering,Relationships,R4)))
[source,tcl]
----
<<Product Selection Class Definition>>=
association R4 -associator ProductSelection ShoppingCart 0..*--1..* Product
----

==== Product Selection Class State Model

(((Ordering,State Models,Product Selection)))
[source,tcl]
----
<<Product Selection State Model>>=
initialstate NewSelection ; # <1>
----
<1> As it turns out, we also do synchronous creation of this class
so we want to be explicit about the initial state.

[source,tcl]
----
<<Product Selection State Model>>=
transition @ - addSelection -> NewSelection

state NewSelection {cartID unsigned productID unsigned quantity unsigned} {
    set product [Product findById productID $productID]
    updateAttribute $self\
        productID $productID\
        cartID $cartID\
        unitPriceOfSelection [readAttribute $product unitPrice] ; # <1>

    signal $self changeQuantity $quantity
}
transition NewSelection - changeQuantity -> ChangingQuantity
----
<1> So this is a bit tricky here.
If an instance of `ProductSelection` is created asynchronously,
then this state actvity is executed.
We need to link up the references to the participating instances of
`Product` and `ShoppingCart`.
We do that by updating the `productId` and `cartID` referential attributes.
However, synchronous creation happens as a side effect of linking
instances of `Product` and `ShoppingCart` across R4.
In that case, the referential attributes are set by the `link` operation,
the instance is placed in the `NewSelection` state and the
above state activity is *not* executed.
This also implies that the synchonous creation must supply values for
the `quantity`, `unitPriceOfSelection` and `selectionValue` attributes.
In this case the attributes have been given default values so we don't
really have to supply them unless they are to be different from the default.
Okay, I said it was a bit tricky.

Here we run into a quandary in the model.
The two states below signal the `cartUpdated` event to a `ShoppingCart`.
Unfortunately, the Shopping Cart state model (see page 340) does not
define a `cartUpdated` event.
So what to do?
Rather than signaling an event to the `ShoppingCart`,
we will invoke an instance based operation on it.
This means we do not have to modify the state diagram and it will give
us an opportunity to update the `totalValue` derived attribute.
See the <<shoppingcartclass>> for the definition of the operation.

[source,tcl]
----
<<Product Selection State Model>>=
state ChangingQuantity {quantityOfSelection unsigned} {
    withAttribute $self quantity unitPriceOfSelection selectionValue {
        set quantity $quantityOfSelection
        set selectionValue [expr {$quantity * $unitPriceOfSelection}]
    }
    if {$quantity == 0} {
        signal $self removeSelection
    } else {
        set cart [findRelated $self ~R4]
        instop $cart cartUpdated
    }
}
transition ChangingQuantity - removeSelection -> RemovingSelection

state RemovingSelection {} {
    set cart [findRelated $self ~R4]
    R4 unlink $self
    set remainingProduct [findRelated $cart R4]
    if {[isEmptyRef $remainingProduct]} {
        signal $cart cancel
    } else {
        instop $cart cartUpdated
    }
}
terminal RemovingSelection
----

=== ShoppingCart Class [[shoppingcartclass,ShoppingCart]]

(((Ordering,Classes,ShoppingCart)))
[source,tcl]
----
<<Shopping Cart Class Definition>>=
class ShoppingCart {
    attribute totalValue unsigned -default 0

    statemodel {
        <<Shopping Cart State Model>>
    }

    instop void cartUpdated {} {
        updateAttribute $self totalValue [tcl::mathop::+ {*}[pipe {
                findRelated $self {R4 ProductSelection} |
                deRef ~ selectionValue |
                relation list ~ selectionValue
            }]]
    } ; # <1>
}
----
<1> The intent here is much simpler than the code looks.
We want to update the `totalValue` attribute to be the sum of
the values of the `selectionValue` attribute for all the
instances of `ProductSelection` related to this cart.
How we get there is a bit terse.
The `tcl::mathop::+` command will compute the sum all of its arguments.
So we need each `selectionValue` attribute value to be an argument
to the `+` command.
We gather all the `selectionValue` attribute values by:
. finding all the related `ProductSelection` instances.
. dereference the `selectionValue` attribute from those instances.
This yields a relation value where each tuple has a `selectionValue` attribute.
. creating a Tcl list from the set of `selectionValue` attributes.
+
The `pipe` command is a control structure command that sequences the
three commands taking the result of one command and substituting it as an
argument to the next command where the `~` placeholder is located.
The result of the `pipe` command is the Tcl list generated by the
final `relation list` command and the `{*}` operator
takes that list and makes it into individual arguments to the
`tcl::mathop::+` command.
This sequence could have been written in other ways, of course.
The usage here shows some of the expressive power of the underlying relational
algebra but comes with the cognitive burden of understanding exactly
how those commands work.

(((Ordering,State Models,Shopping Cart)))
[source,tcl]
----
<<Shopping Cart State Model>>=
transition @ - startCart -> NewOrder

state NewOrder {productID quantity} {
    signal $self addSelection $productID $quantity
}
transition NewOrder - addSelection -> AddingSelectiontoOrder

state AddingSelectiontoOrder {productID quantity} {
    set product [Product findById productID $productID]
    set unitprice [readAttribute $product unitPrice]
    set selectionvalue [expr {$unitprice * $quantity}]
    set newSelection [R4 link $self $product\
        quantity $quantity\
        unitPriceOfSelection $unitprice\
        selectionValue $selectionvalue\
    ] ; # <1>
    withAttribute $self totalValue {
        incr totalValue $selectionvalue
    }
}
transition AddingSelectiontoOrder - addSelection -> AddingSelectiontoOrder
transition AddingSelectiontoOrder - cancel -> CancelingEntireOrder
transition AddingSelectiontoOrder - checkOut ->\
        EstablishingCustomerandVerifyingPayment
----
<1> Linking `R4` results in the synchronous creation of an instance
of `ProductSelection`.
As discussed above,
we must supply the values of all the non-referential attributes of the
associative class.
The setting of the value of the referential attributes is handled
by the `R4 link` command.

[source,tcl]
----
<<Shopping Cart State Model>>=
state CancelingEntireOrder {} {
    set selections [findRelated $self {R4 ProductSelection}]
    R4 unlink $selections
}
terminal CancelingEntireOrder ; # <1>
----
<1> The `CancelingEntireOrder` is a terminal state and the instance
will be automatically deleted when the state activity finishes.

[source,tcl]
----
<<Shopping Cart State Model>>=
state EstablishingCustomerandVerifyingPayment {
        accountNumber billingAddress cardExpirationDate
        cardholderName customerEmail customerName customerPhone
        shippingAddress} {
    Order createasync checkOut [list $self $accountNumber\
        $billingAddress $cardExpirationDate $cardholderName\
        $customerEmail]\
        totalValue [readAttribute $self totalValue]\
        recipient $customerName\
        deliveryAddress $shippingAddress\
        contactPhone $customerPhone
}
----

=== Credit Card Charge Class [[creditcardchargeclass,Credit Card Charge]]

(((Ordering,Classes,Credit Card Charge)))
[source,tcl]
----
<<Credit Card Charge Class Definition>>=
class CreditCardCharge {
    attribute chargeID unsigned
    attribute accountNumber char -dimension 32
    attribute cardholderName char -dimension 128
    attribute billingAddress char -dimension 128
    attribute cardExpirationDate char -dimension 32
    attribute dateChargeMade char -dimension 32
    attribute chargeAmount unsigned
    attribute approvalCode AP_Code -default AP_pending

    statemodel {
        <<Credit Card Charge State Model>>
    }
}
----

(((Ordering,Relationships,R7)))
(((Ordering,Relationships,R8)))
[source,tcl]
----
<<Credit Card Charge Class Definition>>=
association R7 CreditCardCharge 0..*--1 Order
association R8 CreditCardCharge 0..1--0..1 Order ; #<1>
----
<1> This looks like an error in the model.
The `R7` relationship is tracking attempts to pay for an order
by a credit card charge.
The `R8` relationship is tracking when an attempt actually results
in a purchase.
It has to be conditional on the Order side because an order must
be able to exist before it is paid for.
The relationship is rather weak and we will see other problems
in the state activities for the `CreditCardCharge` class.

==== Credit Card Charge Class State Model

(((Ordering,State Model,Credit Card Charge)))
[source,tcl]
----
<<Credit Card Charge State Model>>=
transition @ - makeCharge -> RequestingChargeApproval

state RequestingChargeApproval {order unsigned} {
    R7 link $self $order ; # <1>
    updateAttribute $self dateChargeMade [clock format [clock seconds]]

    withAttribute $self accountNumber billingAddress cardholderName\
            cardExpirationDate chargeAmount {
        EE_CreditCardCompany::requestChargeApproval\
            $accountNumber\
            $billingAddress\
            $cardholderName\
            $cardExpirationDate\
            [readAttribute $self chargeID]\
            $chargeAmount
    }

    delaysignal 60000 $self chargeProcessingNotCompleted
}
transition RequestingChargeApproval - chargeProcessed -> ProcessingCompleted
transition RequestingChargeApproval - chargeProcessingNotCompleted ->\
    DeclineForTimeout
----
<1> The action language in this state and all the other states for
this class keep refering to relationship, `R8`.
Clearly, `R7` is the one that is intended.

[source,tcl]
----
<<Credit Card Charge State Model>>=
state ProcessingCompleted {resultCode int} {
    set order [findRelated $self R7] ; # <1>
    canceldelayed $self $order chargeProcessingNotCompleted ; # <2>

    updateAttribute $self approvalCode $resultCode
    if {$resultCode eq "approved"} {
        R8 link $self $order ; # <3>
        signal $order paymentApproved
    } else {
        signal $order paymentDeclined
    }
}
----
<1> Here again we need to use `R7`.
<2> To be tidy, we cancel the delayed event that times out the processing
of the credit card charge.
Otherwise it is necessary to ignore that event in this state.
<3> Upon approval of the charge we can then link `R8` to establish
the charge that actually paid for the order.

[source,tcl]
----
<<Credit Card Charge State Model>>=
state DeclineForTimeout {} {
    updateAttribute $self approvalCode connectionFailed
    set order [findRelated $self R7] ; # <1>
    signal $order paymentDeclined
}
----
<1> And the final substitution of `R7` for what was orginally `R8` in the
model.

== Shipping Subsystem [[shippingsubsytem,Shipping Subsystem]]

The Shipping subsystem consists of the following classes.

[source,tcl]
----
<<Shipping Subsystem>>=
<<Shipment Class Definition>>
<<Shipping Company Class Definition>>
<<Warehouse Clerk Class Definition>>
<<Warehouse Class Definition>>
<<Shipping Clerk Class Definition>>
<<Stock Clerk Class Definition>>
<<Off Duty Clerk Class Definition>>
<<Shipment Item Class Definition>>
----

=== Shipment Class [[shipmentclass,Shipment]]

(((Shipping,Classes,Shipment)))
[source,tcl]
----
<<Shipment Class Definition>>=
class Shipment {
    attribute shipmentID unsigned
    attribute trackingNumber char -dimension 32

    attribute recipient char -dimension 128
    attribute deliveryAddress char -dimension 128
    attribute contactPhone char -dimension 32
    attribute timePrepared char -dimension 32
    attribute timePickedUp char -dimension 32
    attribute timeDelivered char -dimension 32
    attribute waitingToBePacked bool -default true

    statemodel {
        <<Shipment State Model>>
    }

    <<Shipment Operations>>
}
----
<1> The model shows the `shippingCompany` and `trackingNumber` attributes
form a secondary identifier.
This is problematic because `shippingCompany` is a referential
attribute that realizes `R21`.
Below we discuss the problems of the `R21` and in the end make it
conditional on the `ShippingCompany` side.
Because of that change, we don't really want to make the `shippingCompany`
attribute part of an identifier as it will change depending upon
when the `R21` relationship is established.
A better approach would be to factor `R21` as a class based association
where `shippingCompany` and `trackingNumber` could be proper identifying
attributes.
However, we are loath to add classes to the model during translation and
so take the easier approach of removing the attributes as an identifer.


(((Shipping,Relationships,R21)))
(((Shipping,Relationships,R24)))
(((Shipping,Relationships,R22)))
(((Shipping,Relationships,R6)))
[source,tcl]
----
<<Shipment Class Definition>>=
association R21 Shipment 0..*--0..1 ShippingCompany ; #<1>
association R24 Shipment 0..*--1 Warehouse
association R22 Shipment 0..*--0..1 WarehouseClerk
association R6 Shipment 0..1--1 Order
----
<1> The model has this relationship as unconditional on the Shipping
Company side.
This is problematic when a Shipment is created.
At that point in time we have no shipping company or tracking number.
We could probably choose a company and get a number before the
Shipment is created, but that work seems to be handled by the
Shipment state model.
That state model implies that we could pack the shipment or
receive a tracking number in either order.
Consequently, the easiest thing to do is to weaken the relationship
to make it conditional on the ShippingCompany side to await the
final company and tracking number assignment.

==== Shipment Class State Model

There are a number of minor issues that have to be resolved in the
state activities for the `Shipment` class.
Pay particular attention to the callouts when comparing the
translated Tcl code to the action language source.

(((Shipping,State Model,Shipment)))
[source,tcl]
----
<<Shipment State Model>>=
transition @ - requestShipment -> PreparingShipment

state PreparingShipment {order unsigned} {
    R6 link $self $order

    set warehouse [Warehouse chooseWarehouse [readAttribute $order orderID]] ; # <1>
    R24 link $self $warehouse

    set items [findRelated $order R10 {R4 ProductSelection}] ; #<2>
    R9 link $items $self

    signal $warehouse shipmentReadyToPack ; #<3>
}
transition PreparingShipment - packed -> PackedandAwaitingTrackingNumber
transition PreparingShipment - trackingNumberAssigned ->\
    NumberAssignedandWaitingtobePacked
----
<1> This state model is rather vague about how `R24` is established.
The relationship is unconditional on the `Warehouse` side so we must
establish it in this activity.
We have punted here and invoke a class based operation of the
`Warehouse` passing the `orderID`.
Presumably that procedure has some policy in it to select a warehouse
based on the contents of the `Order` given by the `orderID`.
We will see in the <<warehouseclass>> how the choice of a `Warehouse` is
resolved (hint, for our purposes very, very simply).
<2> The model doesn't seem to establish R9 with the Shipment.
We do so here assuming no items are shipped initially.
Presumably the Shipping Clerk will have to update the quantity
shipped as the items are packed.
<3> This event should be going to the Warehouse.
The model graphic ships it off to an external entity,
yet the event name appears on the Warehouse state diagram and it is
the Warehouse class that assigns Shipping Clerks for packing.

Note that the state activity for the `Packed and Awaiting Tracking Number`
and the `Packed` states are the same.
We have factored that into an instance based operation,
`updatePackingInfo`.
The same is true of the `Number Assigned and Waiting to be Packed` and
`Number Assigned` states which is factored into the
`updateTrackingInfo` instance operation.
These states allow shipment packing by the shipping clerk and tracking number
assignment by the shipping company to happen in either order.
Not sure why this was important, but it's there.

[source,tcl]
----
<<Shipment State Model>>=
state PackedandAwaitingTrackingNumber {clerkID unsigned} {
    instop $self updatePackingInfo $clerkID
}
transition PackedandAwaitingTrackingNumber - trackingNumberAssigned ->\
    NumberAssigned

state NumberAssignedandWaitingtobePacked {shippingCompany {char const *}\
        trackingNumber unsigned} {
    instop $self updateTrackingInfo $shippingCompany $trackingNumber
}
transition NumberAssignedandWaitingtobePacked - packed -> Packed

state NumberAssigned {shippingCompany {char const *} trackingNumber unsigned} {
    instop $self updateTrackingInfo $shippingCompany $trackingNumber
}
transition NumberAssigned - pickedUp -> InTransittoCustomer

state Packed {clerkID unsigned} {
    instop $self updatePackingInfo $clerkID
}
transition Packed - pickedUp -> InTransittoCustomer
----

Here are the factored instance based operations.
The translation from action language to Tcl follows our usual pattern.
The only thing we have done here is to place duplicated code into one place.

[source,tcl]
----
<<Shipment Operations>>=
instop void updateTrackingInfo {shippingCompany {char const *}\
        trackingNumber unsigned} {
    updateAttribute $self trackingNumber $trackingNumber
    set company [ShippingCompany findById companyName $shippingCompany]
    R21 link $self $company
}

instop void updatePackingInfo {clerkID unsigned} {
    updateAttribute $self timePrepared [clock format [clock seconds]]

    set clerk [WarehouseClerk findById clerkID $clerkID]
    R22 link $self $clerk

    EE_ShippingCompany::shipmentReadyForPickup\
        [readAttribute $self shipmentID]
}
----

Once we are packed and tracked,
the last two states track the delivery of the shipment.

[source,tcl]
----
<<Shipment State Model>>=
state InTransittoCustomer {} {
    updateAttribute $self timePickedUp [clock format [clock seconds]]
}
transition InTransittoCustomer - deliveryConfirmed -> Delivered

state Delivered {timeDelivered {char const *}} {
    updateAttribute $self timeDelivered $timeDelivered
    set order [findRelated $self R6]
    signal $order orderDelivered
}
----

=== Shipping Company Class [[shippingcompanyclass,Shipping Company]]

(((Shipping,Classes,Shipping Company)))
[source,tcl]
----
<<Shipping Company Class Definition>>=
class ShippingCompany {
    attribute companyName char -dimension 32
    attribute trackingWebsite char -dimension 256
    attribute customerServicePhone char -dimension 32
    attribute localDispatchPhone char -dimension 32
    attribute localOffice char -dimension 128
    attribute localContact char -dimension 64
}
----

=== Warehouse Class [[warehouseclass,Warehouse]]

(((Shipping,Classes,Warehouse)))
[source,tcl]
----
<<Warehouse Class Definition>>=
class Warehouse {
    attribute warehouseName char -dimension 32
    attribute warehouseLocation char -dimension 128

    statemodel {
        <<Warehouse State Model>>
    }

    <<Warehouse Operations>>
}
----

As discussed above,
we created a class based operation to choose which `Warehouse`
would be used to ship an order.
Presumably, there is a policy about such choices.
Such policies can be quite complicated, involving inventory,
distances and other costs.
Here, we do the simplest thing we can and simply choose an arbitrary
`Warehouse`.

[source,tcl]
----
<<Warehouse Operations>>=
classop void chooseWarehouse {orderID unsigned} {
    return [limitRef [Warehouse findAll]]
}
----

==== Warehouse Class State Model

The state model for the `Warehouse` is actually an assigner that
assigns `ShippingClerks` to pack and ship `Shipments`.

(((Shipping,State Model,Warehouse)))
[source,tcl]
----
<<Warehouse State Model>>=
initialstate WaitingforaShipment ; # <1>
defaulttrans IG ; # <2>
----
<1> Just to be explicit, we state the initial state of the state model.
<2> For assigners, we want requests for shipment and free clerk notifications
to be able to arrive at any time.
So we will ignore any that arrive when we are dealing with other matters.
Notice that each state searches for shipments and clerks in the state
that is needed.
This is a common assigner idom.

[source,tcl]
----
<<Warehouse State Model>>=
state WaitingforaShipment {} {
    set readyShipment [findRelatedWhere $self ~R24 {$waitingToBePacked}]
    if {[isNotEmptyRef $readyShipment]} {
        signal $self shipmentReadyToPack
    }
}
transition WaitingforaShipment - shipmentReadyToPack -> WaitingforaFreeClerk

state WaitingforaFreeClerk {} {
    set freeClerk [findRelatedWhere $self {~R25 {~R27 ShippingClerk}}\
        {$awaitingAssignment eq "true"}]
    puts $freeClerk
    if {[isNotEmptyRef $freeClerk]} {
        signal $self clerkFree
    }
}
transition WaitingforaFreeClerk - clerkFree -> AssigningClerktoShipment

state AssigningClerktoShipment {} {
    set readyShipment [findRelatedWhere $self ~R24 {$waitingToBePacked}]
    set readyShipment [limitRef $readyShipment]

    set freeClerk [findRelatedWhere $self {~R25 {~R27 ShippingClerk}}\
        {$awaitingAssignment}]
    set freeClerk [limitRef $freeClerk]

    R23 link $readyShipment $freeClerk
    updateAttribute $readyShipment waitingToBePacked false
    updateAttribute $freeClerk awaitingAssignment false

    signal $freeClerk clerkAssigned
    signal $self clerkAssignedToShipment
}
transition AssigningClerktoShipment - clerkAssignedToShipment ->\
        WaitingforaShipment
----

=== Warehouse Clerk Class [[warehouseclerkclass,Warehouse Clerk]]

(((Shipping,Classes,Warehouse Clerk)))
[source,tcl]
----
<<Warehouse Clerk Class Definition>>=
class WarehouseClerk {
    attribute clerkName char -dimension 64
    attribute goOffDutyAtEndOfJob bool -default false ; # <1>
}
----
<1> This attribute is not in the model graphic, but it is mentioned
in an errata and in the state model for `ShippingClerk`.

(((Shipping,Relationships,RR)))
[source,tcl]
----
<<Warehouse Clerk Class Definition>>=
generalization R27 WarehouseClerk OffDutyClerk StockClerk ShippingClerk
association R25 WarehouseClerk 1..*--1 Warehouse
----

=== Shipping Clerk Class [[shippingclerkclass,Shipping Clerk]]

(((Shipping,Classes,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk Class Definition>>=
class ShippingClerk {
    attribute awaitingAssignment bool -default true

    statemodel {
        <<Shipping Clerk State Model>>
    }
}
----

(((Shipping,Relationships,R23)))
[source,tcl]
----
<<Shipping Clerk Class Definition>>=
association R23 ShippingClerk 0..1--0..1 Shipment
----

==== Shipping Clerk Class State Model

The state model for `ShippingClerk` also has a number of minor
issues that need to be resolved.
The state activities refer to `R7` and `R8`.
These are not correct and should be `R23` and `R25`.
Also we are not given any state activity for a number of states.
We presume these are states driven by the activity of a real
shipping clerk as he/she selects, packs and labels the shipment.

For our purposes it is sufficient to simply drive the state transition
along with some self generated events.
We will put some time delay in the events to try to simulate the time
take to accomplish the tasks in the physical world.
It is easy enough to capture this strategy in a procedure.

[source,tcl]
----
<<Translation Helpers>>=
proc ::bookstore::ShippingClerk::randomdelaysignal {instref event {max 10}} {
    delaysignal [expr {int(rand() * $max) * 100}] $instref $event
}
----

This procedure will generate a delayed event at a pseudo-random time
between 0 and `max` tenths of a second.
We use it below to drive the `ShippingClerk` state model through the
states that were not completely specified in the model graphic.


(((Shipping,State Model,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk State Model>>=
transition @ - startShipping -> WaitingforaJob

state WaitingforaJob {} {
    updateAttribute $self awaitingAssignment true
    set warehouse [findRelated R27 R25]
    signal $warehouse clerkFree
}
transition WaitingforaJob - clerkAssigned -> SelectingBooks
transition WaitingforaJob - offDuty -> OffDuty

state SelectingBooks {} {
    EE_ShippingClerk::shipmentReadyToPack\
        [readAttribute $self shipmentID]

    randomdelaysignal $self booksSelected
}
transition SelectingBooks - booksSelected -> PackingBox

state PackingBox {} {
    randomdelaysignal $self boxPacked
}
transition PackingBox - boxPacked -> SealingBox
----

The `SealingBox` state gives us the opportunity to update
the quantity of items that was actually shipped.
This seems to be missing from the model, but presumably this is
updated by the shipping clerk as the box is packed since at that time
he/she would know if the requested quantity of an item was in stock and
able to be shipped.
Below we take the optimistic attitude that we have infinite stock and
always ship the requested quantity of each item.

[source,tcl]
----
<<Shipping Clerk State Model>>=
state SealingBox {} {
    set allSelections [deRef [ProductSelection findAll] quantity] ; # <1>

    ShipmentItem update [pipe {
        findRelated $self R23 {R9 ShipmentItem} |
        deRef ~ |
        relation join ~ $allSelections |
        relation project ~ shipmentID productID cartID quantity |
        relation rename ~ quantity quantityShipped
    }] ; # <2>

    randomdelaysignal $self boxSealed
}
transition SealingBox - boxSealed -> AttachingShippingLabel
----
<1> We will need a relation value that contains the `quantity` attributes
for the `ProductSelection` instances.
It is used below.
<2> There are several way in which we could accomplish updating
`quantityShipped` attribute of the `ShippmentItems` instances.
One way would be to traverse `R23` and `R9` to obtain a set of `ShipmentItem`
instance references and then iterate across them, continuing along `R9`
to obtain the corresponding `ProductSelection` instance.
Then we could read the `quantity` attribute and use its value to update
the `quantityShipped` value.
Alternatively, we can avoid all the iterative stuff and do this in a
much more relational fashion.
Relational algebra eliminates virtually all the explicit iteration in
state activities since relation values are sets and the algebra operates on
the entire value at one time.
In this case we want to use the `update` command to change non-identifying
attributes to new values.
This command is supplied by `micca` specifically for these kinds of
situations.
To use `ShipmentItem update` we need a relation value that has
a heading consisting of the identifier of `ShipmentItem` and with any
additional attributes we wish to modify, in this case `quantityShipped`.
The five commands in the `pipe` compute the needed relation value.
. `findRelated` traverse `R23` and `R9` ending at `ShipmentItem`, the
associative class.
. `deRef` dereferences the instance reference into a relation value so
that we can now operate on it with the next three commands.
. `relation join` performs a join on the `ProductSelection` projection
that contains the `quantity` attributes
and yields a new relation value that contains tuples
where the `productID` and `cartID`
attribute values match those in the `ShipmentItem` value.
This will give a relation value with a `quantity` attribute which properly
corresponds to the instances of `ShippmentItem`.
. We can now begin to shape the heading of the joined value to match what
we need.
We need the `shipmentID`, `productID` and `cartID` attributes to identify
an instance of `ShipmentItem` and the `quantity` attribute is what we want
to magically turn into the `quantityShipped` attribute.
. The magic is provided by using `relation rename` to rename the
`quantity` attribute to be `quantityShipped`.
The heading of the resulting relation value is now just what we need to
update into the `ShipmentItem` instances.

The relational approach to performing the update of the `quantityShipped`
attributes will certainly seem strained and confusing if you are not
familiar with the algebraic operators.
If you have had some experience programming in SQL,
it might not seem that different, although the approach to computing
results in SQL and TclRAL are quite different.
In the end,
the update is a single statement that clearly shows we are
updating the `ShipmentItem` instances with something, even if that something
takes several steps to compute.
Sadly,
most action languages take an imperative and iterative approach to these
types of computations.
It is relatively easy to deduce how to obtain any required iteration when
the computation is formulated relationally.
The opposite is not true.
For comparison we state the iterative approach below.

[source,tcl]
----
set items [findRelated $self R23 {R9 ShipmentItem}]
forAllRefs item $items {
    set selection [findRelated $item R9]
    updateAttribute $item quantityShipped [readAttribute $selection quantity]
} ; # <1>
----
<1> `Micca` does provide a means to iterate across a set of instance references.
It is not that iteration is bad or unnecessary.
It is simply that it is often overused when _set at a time_ operations
are readily available.

Although shorter to write,
it performs a lot more computation as the relationships must be navigated
repeatedly to perform what is equivalent to a single relational join.

[source,tcl]
----
<<Shipping Clerk State Model>>=
state AttachingShippingLabel {} {
    randomdelaysignal $self shippingLabelAttached
}
transition AttachingShippingLabel - shippingLabelAttached ->\
    DeliveringBoxtoLoadingDock

state DeliveringBoxtoLoadingDock {} {
    randomdelaysignal $self boxAtLoadingDoc
}
transition DeliveringBoxtoLoadingDock - boxAtLoadingDoc -> CompletingJob

state CompletingJob {} {
    set currentShipment [findRelated $self R23]
    signal $currentShipment packed [readAttribute $self clerkID]
    R23 unlink $currentShipment
    set wc [findRelated $self R27]
    if {[readAttribute $wc goOffDutyAtEndOfJob]} {
        signal $self offDuty
    } else {
        updateAttribute $self awaitingAssignment true
        set myWarehouse [findRelated $wc R25]
        signal $myWarehouse clerkFree
    }
}
transition CompletingJob - clerkAssigned -> SelectingBooks
transition CompletingJob - offDuty -> OffDuty

state OffDuty {} {
    R27 migrate $self OffDutyClerk
} ; # <1>
----
<1> Note that we do *not* define the `OffDuty` state as `terminal`
despite the model graphic containing a terminal transition.
This is because the `ShippingClerk` instance will not exist after
the migration to an `OffDutyClerk` and so we don't want the run
time architecture to attempt to delete what no longer exists anyway.

=== Stock Clerk Class [[stockclerkclass,Stock Clerk]]

(((Shipping,Classes,Stock Clerk)))
[source,tcl]
----
<<Stock Clerk Class Definition>>=
class StockClerk {
    attribute idle boolean -default true
}
----

=== Off Duty Clerk Class [[offdutyclerkclass,Off Duty Clerk]]

(((Shipping,Classes,Off Duty Clerk)))
[source,tcl]
----
<<Off Duty Clerk Class Definition>>=
class OffDutyClerk {
}
----

=== Shipment Item Class [[shipmentitemclass,Shipment Item]]

(((Shipping,Classes,Shipment Item)))
[source,tcl]
----
<<Shipment Item Class Definition>>=
class ShipmentItem {
    attribute quantityShipped unsigned -default 0
}
----

(((Shipping,Relationships,R9)))
[source,tcl]
----
<<Shipment Item Class Definition>>=
association R9 -associator ShipmentItem Shipment 0..*--1..* ProductSelection
----

== Product Specification Subsystem Population [[productspecificationsubsystempopulation,Product Specification Subsystem Population]]

At this point we have completed the translation of the model.
When the above code is assembled together and submitted to `micca` it
results in a set of procedures and data structures that represent
the actions of the domain.
`Micca` provides a run time component to map model level actions,
_e.g._ navigating relationships to find related instances,
onto Tcl language constructs to implement the intent of the model.

However, we are not done yet.
First we must populate the domain with instances.
Although many of the classes create their instances at run time,
most of the Product Specification subsystem must be populated
with instances in order to have anything to buy at our online store.
In the next sections,
we will supply values for those classes that are not created at run time.

Note that populating a domain before running it is, in general, a necessary
task and one that is frequently overlooked.
Depending on the quanity of data,
population can be a large undertaking.
It is easy to forget about the population step as we are involved
in working out the domain and obtaining its translation.
Also remember in real development,
you may need several domain populations to support testing and integration.
This is particularly true if the domain contains a lot of data.
Workflow and timing may dictate that a separate group of people are
doing the population for the delivered system and the development team
will need to supply their own population for testing and integrating.
Also, testing and integration concerns will probably drive the
values selected for some attributes as this may drive the code path
in some of the state activities.
Finally,
testing that randomizes, in a controlled and repeatable way, the values
of attributes can often find bugs that human composed values miss.
The idea is that randomized attribute values will drive the domain's execution
into broader areas of its state space more effectively than narrowly composed
values made up by humans.

The population given below is quite minimal and is intended only to
demonstrate the translation.
Every class is populated with something and, as you will see,
many of the attribute values are nonsense.

[source,tcl]
----
<<Product Specification Population>>=
<<Product Population>>
<<Publisher Population>>
<<Author Population>>
<<Authorship Population>>
<<Book Product Population>>
<<Recording Product Population>>
<<Software Product Population>>
<<Special Order Product Population>>
<<Stocked Product Population>>
<<Product Category Population>>
<<Recording Population>>
<<Artist Population>>
<<Performance Credit Population>>
<<Recording Format Population>>
<<Platform Population>>
<<Computer Software Population>>
----

`Micca` provides support to populate a domain.
One of the advantages of the relational approach is that
a domain can be populated by pure data values alone.
It is not necessary to execute any action language equivalent
code to create instances.
This even includes relating instances across relationships.
Since we supply referential attributes,
simply setting referential attributes to the values that correspond
to the identifying attributes of the related instance is sufficient.
So below, although we are obviously execution commands in Tcl,
we are simply supplying values to attributes.
If we fail to supply correct ones,
then the population command will fail with error messages that
indicate the problem.

The basic command to populate a class provides two approaches
to specify values.
One is better suited to specifying constant values
and the other better suited when attribute values are held in
ordinary variables.
We will see both used.

=== Product Population [[productpopulation,Product Population]]

(((Product Specification,Population,Product)))
[source,tcl]
----
<<Product Population>>=
set eumlid 780201 ; # <1>
set recid 7789930
set wordid 938763
----
<1> We start with some basic ordinary Tcl variables that will be used
to hold counters and attribute values that are used in several places.

[source,tcl]
----
<<Product Population>>=
class Product {
    productID
    productName
    copyright
    unitPrice
    description
    website 
    currentlyAvailable
    categoryID
    groupCode
    publisherCode
}\
    $eumlid\
    {Executable UML: A Foundation for Model-Driven Architecture}\
    2002\
    2995\
    {Book on software development using models.}\
    www.executableumlbook.com\
    true\
    [set bookid [incr categorytag]]\
    0\
    201\
\
    $recid\
    {Carnival Music for Children}\
    1955\
    1000\
    {Music as heard at old time carnivals}\
    {}\
    true\
    [set musicid [incr categorytag]]\
    1\
    523\
\
    $wordid\
    {Word 2020 for MacOSX}\
    2020\
    5995\
    {Infamous word processing program}\
    www.microsoft.com\
    true\
    [set swid [incr categorytag]]\
    2\
    666 ; # <1>
----
<1> This is an example of populating using the form of the commands
that is most convenient when variables are involved.
The first argument is a list of the attributes which sets the order
in which they appear in the subsequent arguments.
There is a bit of Tcl syntax here that might be unfamiliar.

=== Publisher Population [[publisherpopulation,Publisher Population]]

(((Product Specification,Population,Publisher)))
[source,tcl]
----
<<Publisher Population>>=
class Publisher {
    groupCode
    publisherCode
    name
    address
    website
} {
    0
    201
    Addison-Wesley
    {New York, NY}
    www.aw.com

    1
    523
    {Old-Time Music}
    {St. Louis, MO}
    www.otm.com

    2
    666
    {Microsoft, Inc.}
    {Seattle, WA}
    www.microsoft.com
} ; # <1>
----
<1> Here we see the form of population that is most convenient for constant
values.
Fewer backslashes are required and whitespace is less significant.
Again, Tcl syntax rules apply.

=== Author Population [[authorpopulation,Author Population]]

(((Product Specification,Population,Author)))
[source,tcl]
----
<<Author Population>>=
class Author {
    name
    website
    email
} {
    {Stephen J. Mellor}
    stephenmellor.com
    stephen@stephenmellor.com

    {Marc J. Balcer}
    marcbalcer.com
    marc@marcbalcer.com
}
----

=== Authorship Population [[authorshippopulation,Authorship Population]]

(((Product Specification,Population,Authorship)))
[source,tcl]
----
<<Authorship Population>>=
class Authorship {
    name
    productID
    previousName
    previousProductID
}\
    {Stephen J. Mellor}\
    $eumlid\
    {}\
    {}\
\
    {Marc J. Balcer}\
    $eumlid\
    {Stephen J. Mellor}\
    $eumlid
----

=== Book Product Population [[bookproductpopulation,Book Product Population]]

(((Product Specification,Population,Book Product)))
[source,tcl]
----
<<Book Product Population>>=
class BookProduct {
    productID
    bookNumber
    titleCode
    title
    subtitle
}\
    $eumlid\
    {ISBN 0-201-74804-5}\
    74804-5\
    {Executable UML}\
    {A Foundation for Model-Driven Architecture}
----

=== Recording Product Population [[recordingproductpopulation,Recording Product Population]]

(((Product Specification,Population,Recording Product)))
[source,tcl]
----
<<Recording Product Population>>=
class RecordingProduct {
    productID
    runningTime
    recordingID
    formatID
}\
    $recid\
    3:23\
    [set cmusid [incr recordingtag]]\
    [set cdid [incr formattag]]
----

=== Software Product Population [[softwareproductpopulation,Software Product Population]]

(((Product Specification,Population,Software Product)))
[source,tcl]
----
<<Software Product Population>>=
class SoftwareProduct {
    productID
    productVersion
    softwareID
    platformID
}\
    $wordid\
    20.17.3\
    [set softid [incr softwaretag]]\
    [set platformid [incr platformtag]]
----

=== Special Order Product Population [[specialorderproductpopulation,Special Order Product Population]]

(((Product Specification,Population,Special Order Product)))
[source,tcl]
----
<<Special Order Product Population>>=
class SpecialOrderProduct {
    productID
    specialOrderInstructions
    daysToDeliver
}\
    $recid\
    {Their part number: 30557}\
    10
----

=== Stocked Product Population [[stockedproductpopulation,Stocked Product Population]]

(((Product Specification,Population,Stocked Product)))
[source,tcl]
----
<<Stocked Product Population>>=
class StockedProduct {
    productID
    quantityOnHand
    reorderThreshold
    reorderIncrement
    reorderInstructions
}\
    $eumlid\
    100\
    200\
    100\
    {Ship as quickly as possible}\
\
    $wordid\
    55\
    25\
    55\
    {Get a discount}
----

=== Product Category Population [[productcategorypopulation,Product Category Population]]

(((Product Specification,Population,Product Category)))
[source,tcl]
----
<<Product Category Population>>=
class ProductCategory {
    categoryID
    categoryName
    parentCategoryID
}\
    $bookid\
    book\
    {}\
\
    $musicid\
    music\
    {}\
\
    $swid\
    software\
    {}
----

=== Recording Population [[recordingpopulation,Recording Population]]

(((Product Specification,Population,Recording)))
[source,tcl]
----
<<Recording Population>>=
class Recording {
    recordingID
    title
}\
    $cmusid\
    {Carnival Music for Children}
----

=== Artist Population [[artistpopulation,Artist Population]]

(((Product Specification,Population,Artist)))
[source,tcl]
----
<<Artist Population>>=
class Artist {
    artistID
    artistName
}\
    [set artist1id [incr artisttag]]\
    {Mary Jane}\
\
    [set artist2id [incr artisttag]]\
    {Fred Smith}
----

=== Performance Credit Population [[performancecreditpopulation,Performance Credit Population]]

(((Product Specification,Population,Performance Credit)))
[source,tcl]
----
<<Performance Credit Population>>=
class PerformanceCredit {
    recordingID
    artistID
    prevRecordingID
    prevArtistID
}\
    $cmusid\
    $artist1id\
    {}\
    {}\
\
    $cmusid\
    $artist2id\
    $cmusid\
    $artist1id
----

=== Recording Format Population [[recordingformatpopulation,Recording Format Population]]

(((Product Specification,Population,Recording Format)))
[source,tcl]
----
<<Recording Format Population>>=
class RecordingFormat {
    formatID
    formatName
}\
    $cdid\
    CD
----

=== Platform Population [[xxpopulation,Platform Population]]

(((Product Specification,Population,Platform)))
[source,tcl]
----
<<Platform Population>>=
class Platform {
    platformID
    platformName
}\
    $platformid\
    MacOSX
----

=== Computer Software Population [[computersoftwarepopulation,Computer Software Population]]

(((Product Specification,Population,Computer Software)))
[source,tcl]
----
<<Computer Software Population>>=
class ComputerSoftware {
    softwareID
    title
}\
    $softid\
    {Word 2020 for MacOSX}
----

== Ordering Subsystem Population [[orderingsubsystempopulation,Ordering Subystem Population]]

There are no initial instances in the Ordering subsystem.
All instances are created at run time.
Most instances are created asynchronously by events.
The requirement that *Customers* must have placed an order means that
those instances are created when an *Order* is created.

== Shipping Subsystem Population [[shippingsubsystempopulation,Shipping Subystem Population]]

[source,tcl]
----
<<Shipping Population>>=
<<Shipping Company Population>>
<<Warehouse Population>>
<<Warehouse Clerk Population>>
<<Shipping Clerk Population>>
<<Stock Clerk Population>>
<<Off Duty Clerk Population>>
----

=== Shipping Company Population [[shippingcompanypopulation,Shipping Company Population]]

(((Shipping,Population,Shipping Company)))
[source,tcl]
----
<<Shipping Company Population>>=
class ShippingCompany {
    companyName
    trackingWebsite
    customerServicePhone
    localDispatchPhone
    localOffice
    localContact
} {
    FedEx
    www.fedex.com
    222-555-1212
    223-555-1212
    {200 Elm St., Anywhere, CA 94000}
    {George Shipper}

    UPS
    www.ups.com
    224-555-1212
    225-555-1212
    {220 Elm St., Anywhere, CA 94000}
    {John Parcel}
}
----

=== Warehouse Population [[warehousepopulation,Warehouse Population]]

(((Shipping,Population,Warehouse)))
[source,tcl]
----
<<Warehouse Population>>=
class Warehouse {
    warehouseName
    warehouseLocation
} {
    {Acme Bookstore Warehouse}
    {100 Broad St., Somewhere, CA 94000}

    {My Fulfillment}
    {100 Fremont St., Somewhere, CA 94000}
}
----

=== Warehouse Clerk Population [[warehouseclerkpopulation,Warehouse Clerk Population]]

(((Shipping,Population,Warehouse Clerk)))
[source,tcl]
----
<<Warehouse Clerk Population>>=
class WarehouseClerk {
    clerkID
    clerkName
    warehouseName
}\
    [set clerk1id [incr clerktag]]\
    {Fred Smith}\
    {Acme Bookstore Warehouse}\
\
    [set clerk2id [incr clerktag]]\
    {John Industrious}\
    {Acme Bookstore Warehouse}\
\
    [set clerk3id [incr clerktag]]\
    {George Slacker}\
    {My Fulfillment}
----

=== Shipping Clerk Population [[shippingclerkpopulation,Shipping Clerk Population]]

(((Shipping,Population,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk Population>>=
class ShippingClerk {
    clerkID
}\
    $clerk1id
----

=== Stock Clerk Population [[stockclerkpopulation,Stock Clerk Population]]

(((Shipping,Population,Stock Clerk)))
[source,tcl]
----
<<Stock Clerk Population>>=
class StockClerk {
    clerkID
}\
    $clerk2id
----

=== Off Duty Clerk Population [[offdutyclerkpopulation,Off Duty Clerk Population]]

(((Shipping,Population,Off Duty Clerk)))
[source,tcl]
----
<<Off Duty Clerk Population>>=
class OffDutyClerk {
    clerkID
}\
    $clerk3id
----

== External Entities [[externalentities,External Entities]]

At this point we have translated and populated the domain.
However, we are not quite yet ready to run it.
The last step is to deal with the explicit external entities that
crop up in the translation.

We must write stub procedures for the
external entities that are mentioned in the model.
When stubbing external entities,
two situations arise:

. The external entity action is synchronous and can return its result
immediately.
. The external entity action is asynchronous and we must arrange for some
further action, usually signaling an event, to occur in order to
simulate the external entity properly.

How much of a simulation of the external entities is required to drive
the domain execution is a matter that usually requires some introspection
in the the model.
Many are quite simple as we have in this domain.
Others may be quite complex and difficult to simulate.
This is one of the reasons why it is often better to integrate domains
_from the bottom up_ to avoid needing to create complicated external
entity stubs.
As it turns out, integrating from the bottom up also has the added advantage
of always having something that runs.
This usually makes project managers happy.

Our strategy for external entities is to define a set of namespaces in
the domain namespace to hold the required procedures.
All of these namespaces will start with `EE_` and that should avoid any
naming conflicts.

All the procedures start by printing out their invocation sequence,
_i.e._ the Tcl idom `info level 0` provides that information.
For most of the external entity procedures that is all we strive to do.

[source,tcl]
----
<<External Entity Stubs>>=
namespace eval ::bookstore::EE_CreditCardCompany {
    proc requestChargeApproval {accountNumber billingAddress cardholderName
                cardExpirationDate chargeID chargeAmount} {
        puts [info level 0]

        set chargeRef [::bookstore::CreditCardCharge findById chargeID $chargeID]
        after 100 [list micca tunnel $chargeRef signal chargeProcessed approved] ; # <1>
    }
}
----
<1> Here we must simulate some behavior.
We take the simplest approach and approve all charges 100 ms after they
are requested.
This approach *will not* drive the execution of `CreditCardCharge` instances
to all their possible states.

[source,tcl]
----
<<External Entity Stubs>>=
namespace eval ::bookstore::EE_OnLineCustomer {
    proc chargeDeclined {email} {
        puts [info level 0]
    }
    proc chargeApproved {email} {
        puts [info level 0]
    }
    proc orderReportedDelivered {email} {
        puts [info level 0]
    }
}
----

The interaction with the Shipping Company external entity also requires
more simulation to drive the domain to where we want it to go.
In this case we want to signal an event to assign a tracking number.
Later we need to report that we have picked up the package.
Finally, we need to report the package delivery.

[source,tcl]
----
<<External Entity Stubs>>=
namespace eval ::bookstore::EE_ShippingCompany {
    proc shipmentReadyForPickup {shipmentID} {
        puts [info level 0]

        set shipmentRef [::bookstore::Shipment findById shipmentID $shipmentID]
        micca tunnel $shipmentRef signal trackingNumberAssigned\
            FedEx 130047332

        after 200 [list micca tunnel $shipmentRef signal pickedUp]
        after 400 [list ::bookstore::EE_ShippingCompany::reportDelivery\
                $shipmentID]
    }

    # We use a separate procedure, rather than directly tunneling the event, so
    # we can get a better value for the deliveryConfirmed event parameter.
    proc reportDelivery {shipmentID} {
        puts [info level 0]

        set shipmentRef [::bookstore::Shipment findById shipmentID $shipmentID]
        micca tunnel $shipmentRef signal deliveryConfirmed\
                [clock format [clock seconds]]
    }
}
----

[source,tcl]
----
<<External Entity Stubs>>=
namespace eval ::bookstore::EE_ShippingClerk {
    proc shipmentReadyToPack {shipmentID} {
        puts [info level 0]
    }
}
----

== Execution Scenarios [[executionscenarios,Execution Scenarios]]

Finally, we are ready to run the translated domain.
We will construct a single test file that contains a set of
execution scenarios.
We have chosen to do it this way so that we can use the state of the
domain created by one scenario as the starting point for the next one.
This will prevent us from having the start afresh and drive the domain
to some state just to get into position to start a run.
Real world testing would probably take another approach.

For each execution scenario,
we will record the state machine event dispatch traces.
Those traces will then be presented as text and as a UML sequence diagram.
It is important to remember that the sequence diagrams are programmatically
generated and show the flow of events that happened during actual execution.

Tcl has direct support in its core for event driven programming.
It has the concept of an event loop
and to have state machine events dispatched we must _enter the event loop_.
Normally,
a domain would enter the event loop immediately after initialization and
would probably run forever or until it explicitly exited based on some
condition.
What we want to do is enter the event loop and run until some state
activity is completed.
Then we wish to take event dispatch traces and manage other aspects of the
flow of our execution scenario.
This is definitely a contrived situation because we want to stop things
and look at what has just happened.
We will create some convenience procedures to make the effort a bit less
tedious.

Our stategy for being able to synchronize to the execution of state
activities depends upon two factors.

. `Micca` converts state activity code into ordinary Tcl procedures.
. Tcl provides the means to trace the execution of a procedure.

Using this along with a timer to insure that we don't wait forever
if something goes wrong,
we can generate a procedure that will allow us to block until
either a given state activity is executed or we time out.

[source,tcl]
----
<<Common Execution Utilities>>=
proc ::syncToStateActivity {class state {timeout 3000}} {
    set activityproc\
        [micca info statemodel activityproc bookstore $class $state] ; # <1>

    trace add execution $activityproc leave syncToStop ; # <2>

    set totimer [after $timeout set ::done TIMEOUT]
    vwait ::done ; # <3>
    after cancel $totimer
    trace remove execution $activityproc leave syncToStop

    if {$::done eq "TIMEOUT"} {
        error "Sync to $class / $state timed out"
    }
    return $::done
}
----
<1> Here we obtain the name of the Tcl procedure that contains the
state activity.
<2> This command tells Tcl to invoke the `syncToStop` command when
execution leaves the activity procedure.
<3> Enter the event loop waiting for the `::done` variable to be written.
That will happen either when `syncToStop` is executed or when the
timeout script is executed.

Tcl arranges the execution trace callback to have a number of interesting
arguments about the context of the trace.
We don't use any of them and directly write to the global `::done` variable.

[source,tcl]
----
<<Common Execution Utilities>>=
proc ::syncToStop {cmd code result op} {
    set ::done 1
}
----

Finally,
we can show the code for running the execution scenarios.

[source,tcl]
----
<<testscenario.tcl>>=
<<copyright info>>

package require micca 1.5

<<Common Execution Utilities>>

micca configureFromFile simplebookstore.tcl ; # <1>
micca generate ; # <2>
micca populateFromFile sbs_population.tcl

<<External Entity Stubs>>
<<Translation Helpers>>

micca trace control on

<<scenario1>>
<<scenario2>>
<<scenario3>>
<<scenario4>>

micca trace control off
----
<1> These three commands build the domain from our description,
generate the run time data and install the population.
After they run, the domain is ready to receive events.
<2> Because our domain was named `bookstore` and we did not specify
a namespace where it was to be located,
the domain will be placed in the `::bookstore` namespace.

=== Scenario 1 [[scenario1,Scenario 1]]

Our first scenario is very simple.
We want to create a shopping cart and then decide to change our mind
and zero out our selection.
In order create a shopping cart we must supply a product ID and a quantity.
To obtain the product ID,
we will look up a book by name and then extract the productID from the
instance.
In this case,
we look up the name of the Executable UML book, which our
bookstore conveniently stocks.

[source,tcl]
----
<<scenario1>>=
set exumlref [bookstore::Product findWhere\
        {[string match {Executable*} $productName]}]
set id [micca tunnel $exumlref readAttribute productID] ; # <1>
----
<1> The `micca tunnel` command allows us to bridge into the domain
to perform implicit operations on the internals.
Yes, this breaks encapsulation, but in a very controlled manner
and is essential for bridging domains together.
Testing is just another form of bridging and one that usually
exercises the implicit abilities of the software architecture.

We have to manufacture an ID for the cart.
Any old number will do.
We'll just keep one around in the `carttag` variable.

[source,tcl]
----
<<scenario1>>=
set cartID [incr carttag]
bookstore::ShoppingCart createasync\
    startCart [list $id 1]\
    cartID $cartID totalValue 0 ; # <1>
----
<1> Signal a creation event, passing the productID and quantity as
event parameters and supplying the other `ShoppingCart` attributes.

Since the instance creation is asynchronous,
we must wait until that event is dispatched.
Consulting the state diagram,
we can see that we need to wait until the `AddingSelectiontoOrder`
state is executed.

[source,tcl]
----
<<scenario1>>=
syncToStateActivity ShoppingCart AddingSelectiontoOrder
----

Now we will effectively cancel the order by changing the
quantity associated with the product selection to 0.

[source,tcl]
----
<<scenario1>>=
set selection [bookstore::ProductSelection findById\
        cartID $cartID productID $id]
micca::tunnel $selection signal changeQuantity 0
----

After signaling the event, we must await for it to execute.

[source,tcl]
----
<<scenario1>>=
syncToStateActivity ShoppingCart CancelingEntireOrder
----

Finally,
we want to record the event dispatch traces.

[source,tcl]
----
<<scenario1>>=
logTraces scenario1
----

The procedure to record the event dispatch traces obtains both
the text representation as well as the graphical representation.

[source,tcl]
----
<<Common Execution Utilities>>=
proc ::logTraces {filenamebase} {
    set logchan [::open $filenamebase.log w]
    try {
        puts $logchan [micca trace format [micca trace decode all]]
    } finally {
        ::chan close $logchan
    }
    micca trace diagram all $filenamebase.diag ; # <1>
    micca trace control clear ; # <2>
}
----
<1> This command outputs a file suitable for use with the `seqdiag` program
that does the actual sequence diagram graphical drawing.
<2> Clear out the traces in preparation for the next scenario.

Below are the event dispatch traces in text log form.
The traces are timestamped and the time difference from the previous
trace is given.
For creation events,
the details of the instance reference of the new created instance are given.
For ordinary transitions,
the source of the event, the event and its arguments and the target of
the event are given.
After the `==>` mark, the transition from current state to new state is shown.
You can follow along with the model graphic to see the transitions that
happened.

[literal]
.State Machine Trace Log For Scenario 1
--
// include::scenario1.log[]
--

Below is the same trace information in a graphical form of a UML
sequence diagram.
Time flow is from top to bottom.
The events that originate from the `EXTERNAL` class are those that come
from outside of the domain.
Otherwise,
the net flow of events as they were dispatched during execution is shown.

=== Scenario 2  [[scenario2,Scenario 2]]

For the second scenario,
we will start a new cart and add some products to it.
We will also change the quantity of one of the products.
Finally, we will check out and purchase the order.

We start by generating a new cart ID.

[source,tcl]
----
<<scenario2>>=
set cartID [incr carttag]
----

We create the new shopping cart, waiting for the creation
event to be dispatched.

[source,tcl]
----
<<scenario2>>=
bookstore::ShoppingCart createasync\
    startCart [list $id 1]\
    cartID $cartID totalValue 0

syncToStateActivity ShoppingCart AddingSelectiontoOrder
----

We change our minds and decide we really need three copies of the
Executable UML book.

[source,tcl]
----
<<scenario2>>=
set selection [bookstore::ProductSelection findById\
        cartID $cartID productID $id]
micca::tunnel $selection signal changeQuantity 3

syncToStateActivity ProductSelection ChangingQuantity
----

We also decide to buy some music.
We must look up the product ID and then add the selection to the cart.

[source,tcl]
----
<<scenario2>>=
set musicRef [bookstore::Product findWhere\
        {[string match {Carnival*} $productName]}]
set id [micca tunnel $musicRef readAttribute productID]

set cartRef [bookstore::ShoppingCart findById cartID $cartID]
micca::tunnel $cartRef signal addSelection $id 2 ; # <1>
syncToStateActivity ShoppingCart AddingSelectiontoOrder
----
<1> We decide we need two copies of the music.

Finally, we checkout.
Since we stubbed out all credit cards to be approved,
we will know the order will progress to the `Being Packed and Shipped`
state.

[source,tcl]
----
<<scenario2>>=
micca::tunnel $cartRef signal checkOut\
        {5555 6666 7777 8888}\
        {100 E Main St., Anywhere, CO 88888}\
        {10/17}\
        {Fred Smith}\
        fsmith@gmail.com\
        {Fred Smith}\
        {222-555-1212}\
        {100 E Main St., Anywhere, CO 88888}

syncToStateActivity Order BeingPackedandShipped

logTraces scenario2
----

Again we show the text of the event dispatch traces as well as the
sequence diagram.

[literal]
.State Machine Traces For Scenario 2
--
// include::scenario2.log[]
--

=== Scenario 3 [[scenario3,Scenario 3]]

For our third scenario, we will let the events unwind in the
Shipping subsystem and see how the shipment is packed and made
ready for shipment.

[source,tcl]
----
<<scenario3>>=
syncToStateActivity ShippingClerk CompletingJob 10000

logTraces scenario3
----

[literal]
.State Machine Traces For Scenario 3
--
// include::scenario3.log[]
--

=== Scenario 4 [[scenario4,Scenario 4]]

For scenario 4,
we continue to let the events unwind until we see that the
shipment was delivered.

[source,tcl]
----
<<scenario4>>=
syncToStateActivity Shipment Delivered 10000

logTraces scenario4
----

[literal]
.State Machine Traces For Scenario 4
--
// include::scenario4.log[]
--

== Code Organization [[codeorganization,Code Organization]]

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 - 2016 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<simplebookstore.micca>>=
<<copyright info>>

domain bookstore {
    <<Product Specification Subsystem>>
    <<Ordering Subsystem>>
    <<Shipping Subsystem>>
}
----

=== Initial Instance Population

[source,tcl]
----
<<sbs_population.micca>>=
<<copyright info>>

population bookstore {
    <<Product Specification Population>>
    <<Shipping Population>>
}
----

/////

=== XX Class [[xxclass,XX]]

(((Ordering,Classes,XX)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,Relationships,RR)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,State Model,XX)))
[source,tcl]
----
<<XX State Model>>=
----
/////

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
