// vim:set syntax=asciidoc:
= Simple Bookstore Model Translation

== Introduction [[introduction,Introduction]]

This document presents a translation of the case study model from the
book,
'Executable UML: A Foundation for Model-Driven Architecture'
by Stephen J. Mellor and Marc J. Balcer.
The translation is targeted at the ``C'' implementation language using
the http://repos.modelrealization.com/cgi-bin/fossil/mrtools[`micca`]
package.
The model can be found in Appendix B in the book on page 313.

This document is also a
http://www.literateprogramming.com[literate program].
It contains all the code of the translation and the execution scenarios
that exercise the program.
The literate program source and all the output is available at the
http://repos.modelrealization.com/cgi-bin/fossil/mrtools[Model Realization]
web site.

Translation using `micca` has a manual component.
The model diagrams are transcribed into a domain specific language (DSL)
that is provided by `micca`.
The classes, relationships and state models are defined in a declarative
manner.
The state activities must be translated from action language into ``C''
using embedded macros provided by `micca` to implement the model level actions.
For example,
action language statements to select related instances are translated
into invocations of the `%<instance ref foreachRelated self ...>%` macro.
Generally, action language statements translate one-for-one into lines
of embedded macro code and the correspondence is direct if you understand the
conventions of ``C'' programming and the embedded macro language.
Once transcribed into the `micca` DSL,
a code generation phase is invoked.
This code generation produces two files, a ``C'' header file and a ``C''
code file.
Once generation is completed,
the application can be compiled and linked and
we can exercise the resulting program by signaling events or
invoking any operations that are provided.

In the next sections,
we explain some preliminary details that must precede the translation.
Some of these details have to do with the on-line bookstore model itself
and some deal with the specifics of translating using `micca`.
After the preliminaries,
we present the translation organized into subsystems and presented
in the order found in the book.
Next we show a sample population of the model and that is followed by
procedures that stub out the explicit external entity functions found
in the model.
Finally, we present a set of scenarios to exercise the model.
`Micca` has many capabilties to deal with execution traces
and we show a textual log of the event dispatch.

=== How to Read This Document [[howtoreadthisdocument,How to Read This Document]]

This document presents the translation of the online bookstore case study
in the same order as the model is shown in the appendix of the book.
This is intended to facilitate easier reference between the text and the
translation and demonstrate how the model directly drives the implementation as
it is transcribed into `micca` configuration commands.
However, if you are more interested in the result and what happens when the
translation is run, then you should skip to the
<<executionscenarios>> section.
There you can see the result of running a set of scenarios on the
translated model.


== Model Details [[modeldetails,Model Details]]

My experience is that until they are translated and made into running programs,
all models contain small errors and inconsistencies.
This is not an reflection on the authors of the model or of the quality
of their work.
Because translatable models must be so detailed,
it is inevitable that inconsistencies and errors arise.
After all,
no one, no matter how carefully coded, expects a program to compile
the first time without errors.
On the rare occasions it happens,
it is a cause for celebration!
The same situation applies here.
We will endeavor to point out the errors and state clearly how we deal
with inconsistences.
Since the publishing of the book,
a set of errata have been published on the book's website.
We have taken those errata into account in this translation.

We must also remember that this domain is but one in what would be a larger
system to handle online ordering.
See Figure 17.1 on page 276 of the book to get an indication of
what that larger system might look like.
Consequently,
we will not deal with any parts of the translation that involve joining
multiple domains.
This is a bit disappointing as this part of assembling a system can be
quite complex and is required for all but the tiniest of systems.
The `micca` package and its underlying Tcl language constructs are well
suited to many of the problems one faces during the construction of
bridge operations.
It would be an interesting undertaking to construct another domain
for the Online Bookstore application and show how bridging in the
`micca` implementation could be accomplished, but we do not undertake
that in this translation.

It should also be noted that no domain level operations are defined
for the online bookstore domain and so no external programming
interface to the domain is provided.

The result of this translation is the code for the domain
itself and a set of scenarios that exercise the domain.
You can think of this translation as providing the code for domain
and a preliminary set of unit tests in the form of execution scenarios.
When I undertake system development using translation,
this is usually the first step in the process of building the system.
It is quite useful to be able to run a domain in isolation and construct
a set of unit tests to exercise it.
But it only a first step.
When building a system of multiple domains,
itegration of the domains is also required.
I usually build a set of running programs integrating one additional domain
until the system is fully built.
The order of integration follows the usual mantra of:
[quote]
Analyze from the top down and build from the bottom up.

A better way of stating this is to analyze the most application dependent
portions first, but build the system infrastructure first.
This is because it is usually easier to build code to drive a partial
system than it is to build stubs intelligent enough to simulate
missing system components.

These intermediary applications are useful for regression testing and
for dealing with the inevitable changes that happen to domain models.
Often the tests developed for the single domain unit tests are useful
in integrating domains.
It is important to remember that building is not _one big step_ but rather
one of building many integration and test applications, the final one of
which contains everything and is the one delivered.
This is a rather long explanation of the fact that what you will find
in this document is only the first part of what it would take to build
a real online bookstore system.

== Translation Conventions [[translationconventions,Translation Conventions]]

During the evolution of Executable UML,
the authors of
_Executable UML_
decided that referential attributes and identifying constraints were optional.
In my opinion, this decision was a regression of the method.
It certainly can reduce the clutter of the class diagram graphic and
reduce the need for invented identifiers,
but it makes it much easier to skip over the details of how
relationships are actually formalized.
Also, combining referential attributes makes constraints on the data model
and does so in a declarativefootnote:[as opposed to a procedural way]
way.

Regardless of your view of referential attributes,
a translation using `micca` discards them anyway.
`Micca` adopts the usual translation convention when static languages
are targeted, namely to use the address of the class instance as
an architectural identifier and as the basis for navigating relationships.
So,
attributes that only serve the role of identifiers or referential
attributes are discarded from the model.

`Micca` does not support the notion of derived attributes.
We have a couple of options to deal with them:

. Delete the derived attributes and add code into the translation to
compute them whenever they are read.
. Keep the derived attribute and add the redundant code required to
keep them up to date when any of the dependent attributes change.

We have chosen the later approach in this translation since it makes
access to the class diagram data from outside the domain much easier.
We should also note that the model as presented in the appendix
does not state what the composition of the derived attributes are.
But we can make reasonable guesses from the context and will point
them out as we encounter them.

Creating instances is also slightly different in `micca`.
Action language allows one to create a class instance without supplying
all the attributes a value at the time the creation operation is invoked.
`Micca` insists that all attributes have some value at the time
an instance is created.
This will involve some shuffling around of actions that perform
instance creation.
In particular,
this model creates a number of class instances asynchronously.
Often the model will pass along as event parameters the values of
attributes which are then set in the state activity first executed
when the creation event is delivered.
It is a simple matter to remove those values as event parameters and
supply them as attribute values at the signaling of the creation event.
Since `micca` supports the notion of a default value,
we will also use that feature to reduce some of the tedium of
supplying attribute values at instance creation time.

The matter of allowing instances to be created without setting all the
attributes to a value is a bit more troubling in general.
Since most translation schemes are targeted at statically compiled languages
with the implicit assumption that class instances are held in memory,
the idea of creating a class instance usually maps to allocating
a piece of memory of the appropriate size.
In this regime,
assigning attributes piecemeal is easily done.
However, for software architectures targeted at databases which
have strong relational underpinnings,
piecemeal setting of attribute values is not allowedfootnote:[Well
databases can handle it with some awkward NULL value nonsense, but
`micca` has no notion of a NULL and none of the three values logic
required to deal with NULL values.].
The danger of piecemeal attribute assignment during creation is that
the possibility exists that an attribute might not be given an intial value
during certain execution paths through a state activity.
For in-memory data structures, this means an attribute might have an arbitrary
value or the value represented by all bits of the memory being zero.
Best practice is to have the model set the values of all attributes at instance
creation time.

To make the correspondence to the text of the book explicit,
we will order the presentation in the same order as the book.
The domain is presented as three subsystems.
Within each subsystem,
the class definitions appear in the same order as the book.
Relationship definitions are dealt with differently.
In the book text,
each _side_ of the relationship is presented with the class that is a
participant in the relationship
and the relationship is stated from point of view of the participating class.
For `micca`, we must define the relationships exactly once.
So we give relationship definitions near the class that contains
the referential attributes that formalize the relationship.
The exceptions to this are associations with an associative class and
generalization relationships.
For associative classes,
we define the corresponding association with them
and we define the generalization along with the superclass.
This ordering is used to clarify the translation's correspondence with the
book text.
`Micca` allows an arbitrary order for these definitions.

Readers will probably find it essential to refer to the text of the book
as you read the translation.
It's impractical to print all the text and graphics of the model in this
document if only because it would be a violation of copyright law.
However, we will include small portions of the model here when it serves
to clarify the translation.
Consequently,
you will find much of the translation presented with little additional
text.
We will comment when clarity is required or when we are doing something
`micca` specific, but little else is really required.
Reading the translation and the text of the book side-by-side is
sufficient to show how the translation was accomplished.

== Data Types [[datatypes,Data Types]]

`Micca` requires attributes to be given an data type.
That data type is, of course, an implementation data type and must
be a data type defined in ``C''.

Comments on the mapping of domain data types to implementation data types
are given below.

arbitrary_id::
    Arbitrary id's are rarely needed in a `micca` translation since
    the object address serves that role.
Money::
    We'll hold money as an `int` in units of cents.
date::
    Here we are using formatted string as dates. Another choice would be
    to use the number of seconds since the epoch.
    The formatted string are easier to read.
    The seconds representation is easier to compute on.
    The model does not appear to perform any date computations.
MailingAddress::
    Real world addresses are painful. We punt here and just hold strings.
    Another option would be to have a tuple valued attributes that
    could separate out the various component parts of the address,
    _e.g._ number, street, city, state, etc.
    Since state activities don't deal with the address as anything
    other than a unit, we'll stick with simple strings.
WebsiteURL::
InternetEmailAddress::
TelephoneNumber::
    All these types could benefit from check expressions to validate
    their string format and content.
    We have not done that here and just use simple strings.

== Product Specification Subsystem [[productspecificationsubsytem,Product Specification Subsystem]]

The Product Specification Subsytem consists of the following classes.

[source,tcl]
----
<<Product Specification Subsystem>>=
<<Product Class Definition>>
<<Publisher Class Definition>>
<<Author Class Definition>>
<<Authorship Class Definition>>
<<Book Product Class Definition>>
<<Recording Product Class Definition>>
<<Software Product Class Definition>>
<<Special Order Product Class Definition>>
<<Stocked Product Class Definition>>
<<Product Category Class Definition>>
<<Recording Class Definition>>
<<Artist Class Definition>>
<<Performance Credit Class Definition>>
<<Recording Format Class Definition>>
<<Platform Class Definition>>
<<Computer Software Class Definition>>
----

=== Product Class [[productclass,Product]]

(((Product Specification,Classes,Product)))
[source,tcl]
----
<<Product Class Definition>>=
class Product {
    attribute productID char -dimension 32
    attribute productName char -dimension 64
    attribute copyright char -dimension 16
    attribute unitPrice unsigned
    attribute description char -dimension 256
    attribute website char -dimension 256
    attribute currentlyAvailable bool

    classop {struct Product *} findByProductID {productID {char const *}} {
        %<Product foreachInstance product>%
            if (strcmp(productID, %<instance product attribute productID>%) == 0) {
                return product ;
            }
        %<end>%

        return NULL ;
    }
}
----

(((Product Specification,Relationships,R12)))
(((Product Specification,Relationships,R11)))
(((Product Specification,Relationships,R15)))
(((Product Specification,Relationships,R1)))
[source,tcl]
----
<<Product Class Definition>>=
generalization R12 Product SpecialOrderProduct StockedProduct
generalization R11 Product BookProduct RecordingProduct SoftwareProduct
association R15 Product 0..*--1 ProductCategory
association R1 Product 0..*--1 Publisher
----

=== Publisher Class [[publisherclass,Publisher]]

(((Product Specification,Classes,Publisher)))
[source,tcl]
----
<<Publisher Class Definition>>=
class Publisher {
    attribute groupCode char -dimension 32
    attribute publisherCode char -dimension 32
    attribute name char -dimension 64
    attribute address char -dimension 128
    attribute website char -dimension 256
}
----

=== Author Class [[authorclass,Author]]

(((Product Specification,Classes,Author)))
[source,tcl]
----
<<Author Class Definition>>=
class Author {
    attribute name char -dimension 64
    attribute website char -dimension 256
    attribute email char -dimension 64
}
----

=== Authorship Class [[authorshipclass,Authorship]]

Authorship is an association class.
From the relational view,
association classes have referential attributes to refer to both the
participating classes.
Because `R2` is a many-to-many association,
those referential attributes also constitute an identifier.
It is also true that the instances of the association class correspond
one-to-one to the instances of the association itself and that the
number of instances is less than or equal to the product of the number of
instances of the participating classes.

(((Product Specification,Classes,Authorship)))
[source,tcl]
----
<<Authorship Class Definition>>=
class Authorship {
    attribute preCredit char -dimension 64 -default {""}
    attribute postCredit char -dimension 64 -default {""}
}
----

(((Product Specification,Relationships,R3)))
(((Product Specification,Relationships,R2)))
[source,tcl]
----
<<Authorship Class Definition>>=
association R2 -associator Authorship BookProduct 1..*--0..* Author
association R3 Authorship 0..1--0..1 Authorship
----

To be absolutely pedantic the `R3`,
relationship does not, in and of itself, guarantee a linear ordering.
It requires that the initial instance population or the action code set things
up correctly to achieve desired ordering.
In practice, this is easily done and the number of classes required to
guarantee an ordering by virtue of referential integrity constraints is
usually not worth it.
Another alternative is to realize this relationship using an attribute
that is ordered, such as a sequential integer.
Then, the ordered set of authors of a book could be found by selecting on the
`productID` and sorting by the ordering attribute.
Depending upon the way Authorship is being used might favor one approach
over another.
Here we just stick with the straight forward referential attributes
and contrive to populate the model to achieve the order we want.

=== Book Product Class [[bookproductclass,BookProduct]]

(((Product Specification,Classes,BookProduct)))
[source,tcl]
----
<<Book Product Class Definition>>=
class BookProduct {
    attribute bookNumber char -dimension 32
    attribute titleCode char -dimension 32
    attribute title char -dimension 128
    attribute subtitle char -dimension 128
}
----

=== Recording Product Class [[recordingproductclass,Recording Product]]

In addition to being a subclass in a generalization,
the `Recording Product` class is also an associative class.
We follow the same pattern here as we established in the `Authorship`
class translation.

(((Product Specification,Classes,Recording Product)))
[source,tcl]
----
<<Recording Product Class Definition>>=
class RecordingProduct {
    attribute runningTime unsigned
}
----

(((Product Specification,Relationships,R16)))
[source,tcl]
----
<<Recording Product Class Definition>>=
association R16 -associator RecordingProduct Recording 1..*--1..* RecordingFormat
----

=== Software Product Class [[softwareproductclass,Software Product]]

(((Product Specification,Classes,Software Product)))
[source,tcl]
----
<<Software Product Class Definition>>=
class SoftwareProduct {
    attribute productVersion char -dimension 32
}
----

(((Product Specification,Relationships,R19)))
(((Product Specification,Relationships,R20)))
[source,tcl]
----
<<Software Product Class Definition>>=
association R19 SoftwareProduct 1..*--1 Platform
association R20 ComputerSoftware 1..*--1 SoftwareProduct
----

=== Special Order Product Class [[specialorderproductclass,Special Order Product]]

(((Product Specification,Classes,Special Order Product)))
[source,tcl]
----
<<Special Order Product Class Definition>>=
class SpecialOrderProduct {
    attribute specialOrderInstructions char -dimension 256
    attribute daysToDeliver unsigned
}
----

=== Stocked Product Class [[stockedproductclass,Stocked Product]]

(((Product Specification,Classes,Stocked Product)))
[source,tcl]
----
<<Stocked Product Class Definition>>=
class StockedProduct {
    attribute quantityOnHand unsigned
    attribute reorderThreshold unsigned
    attribute reorderIncrement unsigned
    attribute reorderInstructions char -dimension 256
}
----

=== Product Category Class [[productcategoryclass,Product Category]]

(((Product Specification,Classes,Product Category)))
[source,tcl]
----
<<Product Category Class Definition>>=
class ProductCategory {
    attribute categoryName char -dimension 32
}
----

(((Product Specification,Relationships,R14)))
[source,tcl]
----
<<Product Category Class Definition>>=
association R14 ProductCategory 0..*--0..1 ProductCategory
----

=== Recording Class [[recordingclass,Recording]]

(((Product Specification,Classes,Recording)))
[source,tcl]
----
<<Recording Class Definition>>=
class Recording {
    attribute title char -dimension 128
}
----

=== Artist Class [[artistclass,Artist]]

(((Product Specification,Classes,Artist)))
[source,tcl]
----
<<Artist Class Definition>>=
class Artist {
    attribute artistName char -dimension 128
}
----

=== Performance Credit Class [[performancecreditclass,Performance Credit]]

(((Product Specification,Classes,Performance Credit)))
[source,tcl]
----
<<Performance Credit Class Definition>>=
class PerformanceCredit {
    attribute role char -dimension 32 -default {""}
}
----

(((Product Specification,Relationships,R17)))
(((Product Specification,Relationships,R18)))
[source,tcl]
----
<<Performance Credit Class Definition>>=
association R17 -associator PerformanceCredit Recording 1..*--1..* Artist
association R18 PerformanceCredit 0..1--0..1 PerformanceCredit
----

=== Recording Format Class [[recordingformatclass,Recording Format]]

(((Product Specification,Classes,Recording Format)))
[source,tcl]
----
<<Recording Format Class Definition>>=
class RecordingFormat {
    attribute formatName char -dimension 32
}
----

=== Platform Class [[platformclass,Platform]]

(((Product Specification,Classes,Platform)))
[source,tcl]
----
<<Platform Class Definition>>=
class Platform {
    attribute platformName char -dimension 32
}
----

=== Computer Software Class [[computersoftwareclass,Computer Software]]

(((Product Specification,Classes,Computer Software)))
[source,tcl]
----
<<Computer Software Class Definition>>=
class ComputerSoftware {
    attribute title char -dimension 128
}
----

== Ordering Subsystem [[orderingsubsytem,Ordering Subsystem]]

The Ordering Subsystem consist of the following classes.

[source,tcl]
----
<<Ordering Subsystem>>=
<<Customer Class Definition>>
<<Order Class Definition>>
<<Product Selection Class Definition>>
<<Shopping Cart Class Definition>>
<<Credit Card Charge Class Definition>>
----

=== Customer Class [[customerclass,Customer]]

(((Ordering,Classes,Customer)))
[source,tcl]
----
<<Customer Class Definition>>=
class Customer {
    attribute email char -dimension 64
    attribute name char -dimension 64
    attribute shippingAddress char -dimension 64
    attribute phone char -dimension 32
    attribute purchasesMade unsigned -default 0 ; # <1>

    classop {struct Customer *} findByEmail {email {char const *}} {
        %<Customer foreachInstance customer>%
            if (strcmp(%<instance customer attribute email>%, email) == 0) {
                return customer ;
            }
        %<end>%

        return NULL ;
    }
}
----
<1> When Customer instances are created, they have certainly not made
any purchases so we can specify a default value to ease the burden
of specifying attributes at creation time.

=== Order Class [[orderclass,Order]]

The `Order` class is the first we encounter that has a state model
associated with it.

(((Ordering,Classes,Order)))
[source,tcl]
----
<<Order Class Definition>>=
class Order {
    attribute orderID unsigned
    attribute dateOrderPlaced char -dimension 64 -default {""}
    attribute totalValue unsigned
    attribute recipient char -dimension 128
    attribute deliveryAddress char -dimension 128
    attribute contactPhone char -dimension 32

    statemodel {
        <<Order State Model>>
    }

    classop unsigned genOrderID {} {
        static unsigned orderID = 100 ;

        return orderID ++ ;
    }
}
----

(((Ordering,Relationships,R10)))
(((Ordering,Relationships,R5)))
[source,tcl]
----
<<Order Class Definition>>=
association R10 Order 0..1--1 ShoppingCart
association R5 Order 1..*--0..1 Customer ; # <1>
----
<1> There is an interesting policy decision represented here.
A Customer is not a Customer unless he/she has placed at least one order.
Interesting -- not wrong or bad -- just interesting.

==== Order Class State Model

(((Ordering,State Models,Order)))
[source,tcl]
----
<<Order State Model>>=
transition @ - checkOut -> EstablishingCustomerandVerifyingPayment ; # <1>
----
<1> Here we encounter our first creation event.
In `micca` the `@` symbol is used to represent the pseudo-initial state
out of which a creation event transitions.

[source,tcl]
----
<<Order State Model>>=
state EstablishingCustomerandVerifyingPayment {
        cart {struct ShoppingCart *}
        accountNumber {char const *}
        billingAddress {char const *}
        cardExpirationDate {char const *}
        cardholderName {char const *}
        customerEmail {char const *}} {
    %<R10 relate self cart>%

    %<Customer instref customer>%
    customer = %<Customer operation findByEmail email customerEmail>% ;
    if (customer == NULL) {
        %<Customer create customer\
            email customerEmail\
            name self->recipient\
            shippingAddress self->deliveryAddress\
            phone self->contactPhone>%
    } else {
        strcpy(%<instance customer attribute name>%, self->recipient) ;
        strcpy(%<instance customer attribute shippingAddress>%,
                self->deliveryAddress) ;
        strcpy(%<instance customer attribute phone>%, self->contactPhone) ;
    }

    %<R5 relate self customer>%
    time_t now ;
    time(&now) ;
    strcpy(%<my attribute dateOrderPlaced>%, ctime(&now)) ;

    %<my signal submitCharge\
        accountNumber accountNumber\
        billingAddress billingAddress\
        cardExpirationDate cardExpirationDate\
        cardholderName cardholderName>%
}

transition EstablishingCustomerandVerifyingPayment - submitCharge ->\
    SubmittingCharge
----

The translation of the state activity to Tcl is quite direct.
Action language `relate` statements correspond to the `link` subcommand
for the relationship involved, in this case `R10`.
We also see the differences that result from creating having to supply
the values of all the attributes of the created instance.
Using `micca`, we must make a clear distinction between creating the instance
and updating the attributes of an existing instance.

[source,tcl]
----
<<Order State Model>>=
state SubmittingCharge {
        accountNumber {char const *}
        billingAddress {char const *}
        cardExpirationDate {char const *}
        cardholderName {char const *}} {
    unsigned chargeID = %<CreditCardCharge operation genChargeID>% ;
    unsigned totalValue = %<my attribute totalValue>% ;
    %<CreditCardCharge createasync makeCharge {order self}\
        chargeID chargeID\
        accountNumber accountNumber\
        billingAddress billingAddress\
        cardholderName cardholderName\
        cardExpirationDate cardExpirationDate\
        chargeAmount totalValue>% // <1>
}

transition SubmittingCharge - paymentApproved -> BeingPackedandShipped
transition SubmittingCharge - paymentDeclined -> PaymentNotApproved
----
<1> Generating an event to the class _creator_, _i.e._ generating a
creation event, is accomplished as the `createasync` subcommand on the
target class.
Again, all the values of the attributes must be supplied since
the instance must be created before the creation event is dispatched.
The model is a bit inconsistent here in the event parameters.
The receiving creation state treats `order` as an instance reference,
but the action language send `orderID` as the parameter.
We use the instance reference here to agree with the receiving
state activity.

Note that we have factored the `makeCharge` event parameters.
In the model graphic on page 342,
you can see that there are many parameters passed with the event.
All of these parameters, except the `Order` instance reference,
are simply used to set the values of the `CreditCardCharge` instance
and so we have factored them out to the creation event generation
as discussed above.
This is an interesting example of how the idoms of action language have
to be translated into a different set of idoms in Tcl.

[source,tcl]
----
<<Order State Model>>=
state PaymentNotApproved {} {
    %<instance customer findOneRelated self R5>%
    MRT_InstId customerID = %<instance customer instid>% ;
    %<external OnlineCustomer_chargeDeclined customerID customerID\
            email customer->email>% ; // <1>
}

transition PaymentNotApproved - subCharge -> SubmittingCharge
----
<1> `Micca` does not have any direct support for generating events to external
entities.
Instead,
we create explict bridge operations, in this case 
`OnlineCustomer_chargeDeclined`, passing the required parameters.
That bridge operation can then map the semantics of a _declined charge_
onto the appropriate operation of the domain that represents the
Online Customer external entity.
In a `micca` translation,
all the interactions with external entities are represented by
procedures.
Those procedures then handle whether the interaction is synchronous or
event based.
We will see examples of this in the <<externalentities>> section below.

[source,tcl]
----
<<Order State Model>>=
state BeingPackedandShipped {} {
    %<instance customer findOneRelated self R5>%
    MRT_InstId customerID = %<instance customer instid>% ;
    char const *email = %<instance customer attribute email>% ;
    %<external OnlineCustomer_chargeApproved customerID customerID\
            email email>% ;

    unsigned shipmentID = %<Shipment operation genShipmentID>% ;
    %<Shipment createasync requestShipment {order self}\
        shipmentID shipmentID\
        recipient self->recipient\
        deliveryAddress self->deliveryAddress\
        contactPhone self->contactPhone>%
}
transition BeingPackedandShipped - orderDelivered -> DeliveredtoCustomer

state DeliveredtoCustomer {} {
    %<instance customer findOneRelated self R5>%
    MRT_InstId customerID = %<instance customer instid>% ;
    %<external OnlineCustomer_orderReportedDelivered customerID customerID\
            email customer->email>% ; // <1>
}
----
<1> So the question arises as to whether we should test the `customer`
instance reference for being empty.
After all, R5 is conditional on the `Customer` side.
In this case the answer is no, since all paths to this state come
through the *Establishing Customer and Verifying Payment* state where
a link to `R5` is made and so we have every expectation
that we will find a single instance related by `R5`.
We know that we will find at most one since `R5` has a multiplicity of one
and any attempt to link an order to multiple `Customers` will fail
referential integrity checks.
So, might we want make the test anyway just to be sure?
Again, the answer is no.
If somehow the `customer` instance reference does not refer to
exactly one instance then the `readAttribute` command will throw an
error (as documented in the manual for that command).
The lesson here is that superfluous multiplicity tests are not necessary
and only serve to clutter the code.
The referential integrity checks performed by `micca` go a long way to
insure correct operation.

=== Product Selection Class [[productselectionclass,Product Selection]]

The `ProductSelection` class is an associative class and has a state model.
The state model is interesting because it has both a creation event
and a terminal state.
The state, `RemovingSelection`, is terminal and the instance is deleted
after executing the state activity for that state.

(((Ordering,Classes,Product Selection)))
[source,tcl]
----
<<Product Selection Class Definition>>=
class ProductSelection {
    attribute quantity unsigned -default 0
    attribute unitPriceOfSelection unsigned -default 0
    attribute selectionValue unsigned -default 0

    statemodel {
        <<Product Selection State Model>>
    }
}
----

(((Ordering,Relationships,R4)))
[source,tcl]
----
<<Product Selection Class Definition>>=
association R4 -associator ProductSelection ShoppingCart 0..*--1..* Product
----

==== Product Selection Class State Model

(((Ordering,State Models,Product Selection)))
[source,tcl]
----
<<Product Selection State Model>>=
initialstate NewSelection ; # <1>
----
<1> As it turns out, we also do synchronous creation of this class
so we want to be explicit about the initial state.

[source,tcl]
----
<<Product Selection State Model>>=
transition @ - addSelection -> NewSelection

state NewSelection {
        cartID unsigned
        productID {char const *}
        quantity unsigned} {
    %<my attribute quantity>% = quantity ;

    %<ShoppingCart instref cart>%
    cart = %<ShoppingCart operation findByCartID cartID cartID>% ;
    %<Product instref product>%
    product = %<Product operation findByProductID productID productID>% ;
    %<R4 relate cart product self>%

    %<my attribute unitPriceOfSelection>% =
            %<instance product attribute unitPrice>% ;

    %<my signal changeQuantity quantity quantity>%
}
transition NewSelection - changeQuantity -> ChangingQuantity
----

Here we run into a quandary in the model.
The two states below signal the `cartUpdated` event to a `ShoppingCart`.
Unfortunately, the Shopping Cart state model (see page 340) does not
define a `cartUpdated` event.
So what to do?
Rather than signaling an event to the `ShoppingCart`,
we will invoke an instance based operation on it.
This means we do not have to modify the state diagram and it will give
us an opportunity to update the `totalValue` derived attribute.
See the <<shoppingcartclass>> for the definition of the operation.

[source,tcl]
----
<<Product Selection State Model>>=
state ChangingQuantity {quantity unsigned} {
    %<my attribute quantity>% = quantity ;
    if (%<my attribute quantity>% == 0) {
        %<my signal removeSelection>%
    } else {
        %<instance cart findOneRelated self ~R4>%
        %<instance cart operation cartUpdated>% ;
    }
}
transition ChangingQuantity - removeSelection -> RemovingSelection

state RemovingSelection {} {
    %<instance product findOneRelated self R4>%
    %<instance cart findOneRelated self ~R4>%
    %<R4 unrelate cart product self>%

    %<instset prodset selectRelated cart R4>%
    if (%<instset prodset empty>%) {
        %<instance cart signal cancel>%
    } else {
        %<instance cart operation cartUpdated>% ;
    }
}
terminal RemovingSelection
----

=== ShoppingCart Class [[shoppingcartclass,ShoppingCart]]

(((Ordering,Classes,ShoppingCart)))
[source,tcl]
----
<<Shopping Cart Class Definition>>=
class ShoppingCart {
    attribute cartID unsigned -default 0
    attribute totalValue unsigned -default 0

    statemodel {
        <<Shopping Cart State Model>>
    }

    instop void cartUpdated {} {
        %<my attribute totalValue>% = 0 ;
        %<instance psel foreachRelated self {R4 ProductSelection}>%
            %<my attribute totalValue>% +=
                    %<instance psel attribute selectionValue>% ;
        %<end>%
    } ; # <1>

    classop unsigned genCartID {} {
        static unsigned cartID = 1 ;

        return cartID++ ;
    }

    classop {struct ShoppingCart *} findByCartID {cartID unsigned} {
        %<ShoppingCart foreachInstance cart>%
            if (cartID == %<instance cart attribute cartID>%) {
                return cart ;
            }
        %<end>%

        return NULL ;
    }
}
----
<1> The intent here is much simpler than the code looks.
We want to update the `totalValue` attribute to be the sum of
the values of the `selectionValue` attribute for all the
instances of `ProductSelection` related to this cart.
How we get there is a bit terse.
The `tcl::mathop::+` command will compute the sum all of its arguments.
So we need each `selectionValue` attribute value to be an argument
to the `+` command.
We gather all the `selectionValue` attribute values by:
. finding all the related `ProductSelection` instances.
. dereference the `selectionValue` attribute from those instances.
This yields a relation value where each tuple has a `selectionValue` attribute.
. creating a Tcl list from the set of `selectionValue` attributes.
+
The `pipe` command is a control structure command that sequences the
three commands taking the result of one command and substituting it as an
argument to the next command where the `~` placeholder is located.
The result of the `pipe` command is the Tcl list generated by the
final `relation list` command and the `{*}` operator
takes that list and makes it into individual arguments to the
`tcl::mathop::+` command.
This sequence could have been written in other ways, of course.
The usage here shows some of the expressive power of the underlying relational
algebra but comes with the cognitive burden of understanding exactly
how those commands work.

(((Ordering,State Models,Shopping Cart)))
[source,tcl]
----
<<Shopping Cart State Model>>=
transition @ - startCart -> NewOrder

state NewOrder {productID {char const *} quantity unsigned} {
    %<my attribute cartID>% = %<ShoppingCart operation genCartID>% ;
    %<my signal addSelection productID productID quantity quantity>%
}
transition NewOrder - addSelection -> AddingSelectiontoOrder

state AddingSelectiontoOrder {productID {char const *} quantity unsigned} {
    %<Product instref product>%
    product = %<Product operation findByProductID productID productID>% ;
    unsigned selectionValue = product->unitPrice * quantity ;
    %<ProductSelection create newSelection\
            quantity quantity\
            unitPriceOfSelection product->unitPrice\
            selectionValue selectionValue>%
    %<R4 relate self product newSelection>%
// <1>
}
transition AddingSelectiontoOrder - addSelection -> AddingSelectiontoOrder
transition AddingSelectiontoOrder - cancel -> CancelingEntireOrder
transition AddingSelectiontoOrder - checkOut ->\
        EstablishingCustomerandVerifyingPayment
----
<1> Linking `R4` results in the synchronous creation of an instance
of `ProductSelection`.
As discussed above,
we must supply the values of all the non-referential attributes of the
associative class.
The setting of the value of the referential attributes is handled
by the `R4 link` command.

[source,tcl]
----
<<Shopping Cart State Model>>=
state CancelingEntireOrder {} {
    %<instance selection foreachRelated self {R4 ProductSelection}>%
        %<instance product findOneRelated selection R4>%
        %<R4 unrelate self product selection>%
        %<instance selection delete>% // <1>
    %<end>%
}
terminal CancelingEntireOrder ; # <2>
----
<1> The model seem to be missing the deletion of the associative class.
<2> The `CancelingEntireOrder` is a terminal state and the instance
will be automatically deleted when the state activity finishes.

[source,tcl]
----
<<Shopping Cart State Model>>=
state EstablishingCustomerandVerifyingPayment {
        accountNumber {char const *}
        billingAddress {char const *}
        cardExpirationDate {char const *}
        cardholderName {char const *}
        customerEmail {char const *}
        customerName {char const *}
        customerPhone {char const *}
        shippingAddress {char const *}} {
    unsigned orderID = %<Order operation genOrderID>% ;
    %<Order createasync checkOut {
                cart self
                accountNumber accountNumber
                billingAddress billingAddress
                cardExpirationDate cardExpirationDate
                cardholderName cardholderName
                customerEmail customerEmail}\
            orderID orderID\
            totalValue self->totalValue\
            recipient customerName\
            deliveryAddress shippingAddress\
            contactPhone customerPhone>%
}
----

=== Credit Card Charge Class [[creditcardchargeclass,Credit Card Charge]]

[source,tcl]
----
<<type aliases>>=
typealias AP_Code {enum {AP_approved, AP_overlimit, AP_noAccount,\
        AP_connectionFailed, AP_accountDataMismatch, AP_expired, AP_pending}}
----

(((Ordering,Classes,Credit Card Charge)))
[source,tcl]
----
<<Credit Card Charge Class Definition>>=
class CreditCardCharge {
    attribute chargeID unsigned
    attribute accountNumber char -dimension 32
    attribute cardholderName char -dimension 128
    attribute billingAddress char -dimension 128
    attribute cardExpirationDate char -dimension 32
    attribute dateChargeMade char -dimension 32 -default {""}
    attribute chargeAmount unsigned
    attribute approvalCode AP_Code -default AP_pending

    statemodel {
        <<Credit Card Charge State Model>>
    }

    classop unsigned genChargeID {} {
        static unsigned idnum = 100 ;
        return idnum++ ;
    }
}
----

(((Ordering,Relationships,R7)))
(((Ordering,Relationships,R8)))
[source,tcl]
----
<<Credit Card Charge Class Definition>>=
association R7 CreditCardCharge 0..*--1 Order
association R8 CreditCardCharge 0..1--0..1 Order ; #<1>
----
<1> This looks like an error in the model.
The `R7` relationship is tracking attempts to pay for an order
by a credit card charge.
The `R8` relationship is tracking when an attempt actually results
in a purchase.
It has to be conditional on the Order side because an order must
be able to exist before it is paid for.
The relationship is rather weak and we will see other problems
in the state activities for the `CreditCardCharge` class.

==== Credit Card Charge Class State Model

(((Ordering,State Model,Credit Card Charge)))
[source,tcl]
----
<<Credit Card Charge State Model>>=
transition @ - makeCharge -> RequestingChargeApproval

state RequestingChargeApproval {order {struct Order *}} {
    %<R7 relate self order>% // <1>
    MRT_InstId cccID = %<my instid>% ;
    %<external CreditCardCompany_requestChargeApproval\
        cccID cccID\
        accountNumber self->accountNumber\
        billingAddress self->billingAddress\
        cardholderName self->cardholderName\
        cardExpirationDate self->cardExpirationDate\
        transactionID self->chargeID\
        chargeAmount self->chargeAmount>% ;

    %<my delaysignal 60000 chargeProcessingNotCompleted>%
}
transition RequestingChargeApproval - chargeProcessed -> ProcessingCompleted
transition RequestingChargeApproval - chargeProcessingNotCompleted ->\
    DeclineForTimeout
----
<1> The action language in this state and all the other states for
this class keep refering to relationship, `R8`.
Clearly, `R7` is the one that is intended.

[source,tcl]
----
<<Credit Card Charge State Model>>=
state ProcessingCompleted {resultCode AP_Code} {
    %<my attribute approvalCode>% = resultCode ;
    %<instance order findOneRelated self R7>% // <1>
    %<my canceldelayed chargeProcessingNotCompleted>% // <2>
    if (resultCode == AP_approved) {
        %<R8 relate self order>% // <3>
        %<instance order signal paymentApproved>%
    } else {
        %<instance order signal paymentDeclined>%
    }
}
----
<1> Here again we need to use `R7`.
<2> To be tidy, we cancel the delayed event that times out the processing
of the credit card charge.
Otherwise it is necessary to ignore that event in this state.
<3> Upon approval of the charge we can then link `R8` to establish
the charge that actually paid for the order.

[source,tcl]
----
<<Credit Card Charge State Model>>=
state DeclineForTimeout {} {
    %<my attribute approvalCode>% = AP_connectionFailed ;
    %<instance order findOneRelated self R7>% // <1>
    %<instance order signal paymentDeclined>%
}
----
<1> And the final substitution of `R7` for what was orginally `R8` in the
model.

== Shipping Subsystem [[shippingsubsytem,Shipping Subsystem]]

The Shipping subsystem consists of the following classes.

[source,tcl]
----
<<Shipping Subsystem>>=
<<Shipment Class Definition>>
<<Shipping Company Class Definition>>
<<Warehouse Clerk Class Definition>>
<<Warehouse Class Definition>>
<<Shipping Clerk Class Definition>>
<<Stock Clerk Class Definition>>
<<Off Duty Clerk Class Definition>>
<<Shipment Item Class Definition>>
----

=== Shipment Class [[shipmentclass,Shipment]]

(((Shipping,Classes,Shipment)))
[source,tcl]
----
<<Shipment Class Definition>>=
class Shipment {
    attribute shipmentID unsigned
    attribute trackingNumber char -dimension 32 -default {""}

    attribute recipient char -dimension 128
    attribute deliveryAddress char -dimension 128
    attribute contactPhone char -dimension 32
    attribute timePrepared char -dimension 32 -default {""}
    attribute timePickedUp char -dimension 32 -default {""}
    attribute timeDelivered char -dimension 32 -default {""}
    attribute waitingToBePacked bool -default true

    statemodel {
        <<Shipment State Model>>
    }

    <<Shipment Operations>>
}
----

The model shows the `shippingCompany` and `trackingNumber` attributes
form a secondary identifier.
This is problematic because `shippingCompany` is a referential
attribute that realizes `R21`.
Below we discuss the problems of the `R21` and in the end make it
conditional on the `ShippingCompany` side.
Because of that change, we don't really want to make the `shippingCompany`
attribute part of an identifier as it will change depending upon
when the `R21` relationship is established.
A better approach would be to factor `R21` as a class based association
where `shippingCompany` and `trackingNumber` could be proper identifying
attributes.
However, we are loath to add classes to the model during translation and
so take the easier approach of removing the attributes as an identifer.


(((Shipping,Relationships,R21)))
(((Shipping,Relationships,R24)))
(((Shipping,Relationships,R22)))
(((Shipping,Relationships,R6)))
[source,tcl]
----
<<Shipment Class Definition>>=
association R21 Shipment 0..*--0..1 ShippingCompany ; #<1>
association R24 Shipment 0..*--1 Warehouse
association R22 Shipment 0..*--0..1 WarehouseClerk
association R6 Shipment 0..1--1 Order
----
<1> The model has this relationship as unconditional on the Shipping
Company side.
This is problematic when a Shipment is created.
At that point in time we have no shipping company or tracking number.
We could probably choose a company and get a number before the
Shipment is created, but that work seems to be handled by the
Shipment state model.
That state model implies that we could pack the shipment or
receive a tracking number in either order.
Consequently, the easiest thing to do is to weaken the relationship
to make it conditional on the ShippingCompany side to await the
final company and tracking number assignment.

==== Shipment Class State Model

There are a number of minor issues that have to be resolved in the
state activities for the `Shipment` class.
Pay particular attention to the callouts when comparing the
translated Tcl code to the action language source.

(((Shipping,State Model,Shipment)))
[source,tcl]
----
<<Shipment State Model>>=
transition @ - requestShipment -> PreparingShipment

state PreparingShipment {order {struct Order *}} {
    %<R6 relate self order>%

    unsigned orderID = %<instance order attribute orderID>% ;
    %<Warehouse instref warehouse>% // <1>
    warehouse = %<Warehouse operation chooseWarehouse orderID orderID>% ;
    %<R24 relate self warehouse>%

    %<instance selection foreachRelated order R10 {R4 ProductSelection}>%
        %<ShipmentItem create item>%
        %<R9 relate self selection item>%
    %<end>% // <2>
    %<instance warehouse signal shipmentReadyToPack>% // <3>
}
transition PreparingShipment - packed -> PackedandAwaitingTrackingNumber
transition PreparingShipment - trackingNumberAssigned ->\
    NumberAssignedandWaitingtobePacked
----
<1> This state model is rather vague about how `R24` is established.
The relationship is unconditional on the `Warehouse` side so we must
establish it in this activity.
We have punted here and invoke a class based operation of the
`Warehouse` passing the `orderID`.
Presumably that procedure has some policy in it to select a warehouse
based on the contents of the `Order` given by the `orderID`.
We will see in the <<warehouseclass>> how the choice of a `Warehouse` is
resolved (hint, for our purposes very, very simply).
<2> The model doesn't seem to establish R9 with the Shipment.
We do so here assuming no items are shipped initially.
Presumably the Shipping Clerk will have to update the quantity
shipped as the items are packed.
<3> This event should be going to the Warehouse.
The model graphic ships it off to an external entity,
yet the event name appears on the Warehouse state diagram and it is
the Warehouse class that assigns Shipping Clerks for packing.

Note that the state activity for the `Packed and Awaiting Tracking Number`
and the `Packed` states are the same.
We have factored that into an instance based operation,
`updatePackingInfo`.
The same is true of the `Number Assigned and Waiting to be Packed` and
`Number Assigned` states which is factored into the
`updateTrackingInfo` instance operation.
These states allow shipment packing by the shipping clerk and tracking number
assignment by the shipping company to happen in either order.
Not sure why this was important, but it's there.

[source,tcl]
----
<<Shipment State Model>>=
state PackedandAwaitingTrackingNumber {clerkID unsigned} {
    %<my operation updatePackingInfo clerkID clerkID>% ;
}
transition PackedandAwaitingTrackingNumber - trackingNumberAssigned ->\
    NumberAssigned

state NumberAssignedandWaitingtobePacked {
        shippingCompany {char const *}
        trackingNumber {char const *}} {
    %<my operation updateTrackingInfo\
            shippingCompany shippingCompany\
            trackingNumber trackingNumber>% ;
}
transition NumberAssignedandWaitingtobePacked - packed -> Packed

state NumberAssigned {
        shippingCompany {char const *}
        trackingNumber {char const *}} {
    %<my operation updateTrackingInfo\
            shippingCompany shippingCompany\
            trackingNumber trackingNumber>% ;
}
transition NumberAssigned - pickedUp -> InTransittoCustomer

state Packed {clerkID unsigned} {
    %<my operation updatePackingInfo clerkID clerkID>% ;
}
transition Packed - pickedUp -> InTransittoCustomer
----

Here are the factored instance based operations.
The translation from action language to Tcl follows our usual pattern.
The only thing we have done here is to place duplicated code into one place.

[source,tcl]
----
<<Shipment Operations>>=
instop void updateTrackingInfo {
        shippingCompany {char const *}\
        trackingNumber {char const *}} {
    strcpy(%<my attribute trackingNumber>%,trackingNumber) ;
    %<ShippingCompany instref company>%
    company = %<ShippingCompany operation findByCompanyName\
            companyName shippingCompany>% ;
    %<R21 relate self company>%
}

instop void updatePackingInfo {clerkID unsigned} {
    time_t now ;
    time(&now) ;
    strcpy(%<my attribute timePrepared>%, ctime(&now)) ;
    %<WarehouseClerk instref clerk>%
    clerk = %<WarehouseClerk operation findByClerkID clerkID clerkID>% ;
    %<R22 relate self clerk>%
    
    MRT_InstId shipmentID = %<my instid>% ;
    %<external ShippingCompany_shipmentReadyForPickup shipmentID shipmentID>% ;
}

classop unsigned genShipmentID {} {
    static unsigned shipmentID = 200 ;

    return shipmentID++ ;
}
----

Once we are packed and tracked,
the last two states track the delivery of the shipment.

[source,tcl]
----
<<Shipment State Model>>=
state InTransittoCustomer {} {
    time_t now ;
    time(&now) ;
    strcpy(%<my attribute timePickedUp>%, ctime(&now)) ;
}
transition InTransittoCustomer - deliveryConfirmed -> Delivered

state Delivered {timeDelivered {char const *}} {
    time_t now ;
    time(&now) ;
    strcpy(%<my attribute timeDelivered>%, ctime(&now)) ;
    %<instance order findOneRelated self R6>%
    %<instance order signal orderDelivered>%
}
----

=== Shipping Company Class [[shippingcompanyclass,Shipping Company]]

(((Shipping,Classes,Shipping Company)))
[source,tcl]
----
<<Shipping Company Class Definition>>=
class ShippingCompany {
    attribute companyName char -dimension 32
    attribute trackingWebsite char -dimension 256
    attribute customerServicePhone char -dimension 32
    attribute localDispatchPhone char -dimension 32
    attribute localOffice char -dimension 128
    attribute localContact char -dimension 64

    classop {struct ShippingCompany *} findByCompanyName {
            companyName {char const *}} {
        %<ShippingCompany foreachInstance company>%
            if (strcmp(%<instance company attribute companyName>%,
                    companyName) == 0) {
                return company ;
            }
        %<end>%

        return NULL ;
    }
}
----

=== Warehouse Class [[warehouseclass,Warehouse]]

(((Shipping,Classes,Warehouse)))
[source,tcl]
----
<<Warehouse Class Definition>>=
class Warehouse {
    attribute warehouseName char -dimension 32
    attribute warehouseLocation char -dimension 128

    statemodel {
        <<Warehouse State Model>>
    }

    <<Warehouse Operations>>
}
----

As discussed above,
we created a class based operation to choose which `Warehouse`
would be used to ship an order.
Presumably, there is a policy about such choices.
Such policies can be quite complicated, involving inventory,
distances and other costs.
Here, we do the simplest thing we can and simply choose an arbitrary
`Warehouse`.

[source,tcl]
----
<<Warehouse Operations>>=
classop {struct Warehouse *} chooseWarehouse {orderID unsigned} {
    %<Warehouse idtoref 0 warehouse>%
    return warehouse ;
}

instop {struct Shipment *} findReadyShipment {} {
    %<instance readyShipment foreachRelated self ~R24>%
        if (%<instance readyShipment attribute waitingToBePacked>%) {
            return readyShipment ;
        }
    %<end>%

    return NULL ;
}

instop {struct ShippingClerk *} findFreeShippingClerk {} {
    %<instance freeClerk foreachRelated self ~R25 {~R27 ShippingClerk}>%
        if (%<instance freeClerk attribute awaitingAssignment>%) {
            return freeClerk ;
        }
    %<end>%

    return NULL ;
}
----

==== Warehouse Class State Model

The state model for the `Warehouse` is actually an assigner that
assigns `ShippingClerks` to pack and ship `Shipments`.

(((Shipping,State Model,Warehouse)))
[source,tcl]
----
<<Warehouse State Model>>=
initialstate WaitingforaShipment ; # <1>
defaulttrans IG ; # <2>
----
<1> Just to be explicit, we state the initial state of the state model.
<2> For assigners, we want requests for shipment and free clerk notifications
to be able to arrive at any time.
So we will ignore any that arrive when we are dealing with other matters.
Notice that each state searches for shipments and clerks in the state
that is needed.
This is a common assigner idom.

[source,tcl]
----
<<Warehouse State Model>>=
state WaitingforaShipment {} {
    %<Shipment instref readyShipment>%
    readyShipment = %<my operation findReadyShipment>% ;
    if (readyShipment != NULL) {
        %<my signal shipmentReadyToPack>%
    }
}
transition WaitingforaShipment - shipmentReadyToPack -> WaitingforaFreeClerk

state WaitingforaFreeClerk {} {
    %<ShippingClerk instref freeClerk>%
    freeClerk = %<my operation findFreeShippingClerk>% ;
    if (freeClerk != NULL) {
        %<my signal clerkFree>%
    }
}
transition WaitingforaFreeClerk - clerkFree -> AssigningClerktoShipment

state AssigningClerktoShipment {} {
    %<Shipment instref readyShipment>%
    readyShipment = %<my operation findReadyShipment>% ;

    %<ShippingClerk instref freeClerk>%
    freeClerk = %<my operation findFreeShippingClerk>% ;

    %<R23 relate freeClerk readyShipment>%
    %<instance readyShipment attribute waitingToBePacked>% = false ;
    %<instance freeClerk attribute awaitingAssignment>% = false ;

    %<instance freeClerk signal clerkAssigned>%
    %<my signal clerkAssignedToShipment>%
}
transition AssigningClerktoShipment - clerkAssignedToShipment ->\
        WaitingforaShipment
----

=== Warehouse Clerk Class [[warehouseclerkclass,Warehouse Clerk]]

(((Shipping,Classes,Warehouse Clerk)))
[source,tcl]
----
<<Warehouse Clerk Class Definition>>=
class WarehouseClerk {
    attribute clerkID unsigned
    attribute clerkName char -dimension 64
    attribute goOffDutyAtEndOfJob bool -default false ; # <1>

    classop {struct WarehouseClerk *} findByClerkID {clerkID unsigned} {
        %<WarehouseClerk foreachInstance clerk>%
            if (%<instance clerk attribute clerkID>% == clerkID) {
                return clerk ;
            }
        %<end>%

        return NULL ;
    }
}
----
<1> This attribute is not in the model graphic, but it is mentioned
in an errata and in the state model for `ShippingClerk`.

(((Shipping,Relationships,RR)))
[source,tcl]
----
<<Warehouse Clerk Class Definition>>=
generalization R27 WarehouseClerk OffDutyClerk StockClerk ShippingClerk
association R25 WarehouseClerk 1..*--1 Warehouse
----

=== Shipping Clerk Class [[shippingclerkclass,Shipping Clerk]]

(((Shipping,Classes,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk Class Definition>>=
class ShippingClerk {
    attribute awaitingAssignment bool -default true

    statemodel {
        <<Shipping Clerk State Model>>
    }

    classop MRT_DelayTime randomdelay {} {
        // random number 1 - 10 in tenths of a second
        return (MRT_DelayTime)((rand() % 10 + 1) * 100) ;
    }
}
----

(((Shipping,Relationships,R23)))
[source,tcl]
----
<<Shipping Clerk Class Definition>>=
association R23 ShippingClerk 0..1--0..1 Shipment
----

==== Shipping Clerk Class State Model

The state model for `ShippingClerk` also has a number of minor
issues that need to be resolved.
The state activities refer to `R7` and `R8`.
These are not correct and should be `R23` and `R25`.
Also we are not given any state activity for a number of states.
We presume these are states driven by the activity of a real
shipping clerk as he/she selects, packs and labels the shipment.

For our purposes it is sufficient to simply drive the state transition
along with some self generated events.
We will put some time delay in the events to try to simulate the time
take to accomplish the tasks in the physical world.
It is easy enough to capture this strategy in a procedure.

This procedure will generate a delayed event at a pseudo-random time
between 0 and `max` tenths of a second.
We use it below to drive the `ShippingClerk` state model through the
states that were not completely specified in the model graphic.


(((Shipping,State Model,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk State Model>>=
transition @ - startShipping -> WaitingforaJob

state WaitingforaJob {} {
    %<my attribute awaitingAssignment>% = true ;
    %<instance warehouse findOneRelated self R27 R25>%
    %<instance warehouse signal clerkFree>%
}
transition WaitingforaJob - clerkAssigned -> SelectingBooks
transition WaitingforaJob - offDuty -> OffDuty

state SelectingBooks {} {
    %<instance shipment findOneRelated self R23>%
    MRT_InstId clerkID = %<my instid>% ;
    %<external ShippingClerk_shipmentReadyToPack clerkID clerkID\
            shipmentID shipment->shipmentID>% ;

    MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
    %<my delaysignal time booksSelected>%
}
transition SelectingBooks - booksSelected -> PackingBox

state PackingBox {} {
    MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
    %<my delaysignal time boxPacked>%
}
transition PackingBox - boxPacked -> SealingBox
----

The `SealingBox` state gives us the opportunity to update
the quantity of items that was actually shipped.
This seems to be missing from the model, but presumably this is
updated by the shipping clerk as the box is packed since at that time
he/she would know if the requested quantity of an item was in stock and
able to be shipped.
Below we take the optimistic attitude that we have infinite stock and
always ship the requested quantity of each item.

[source,tcl]
----
<<Shipping Clerk State Model>>=
state SealingBox {} {
    // <1>
    %<instset items selectRelated self R23 {R9 ShipmentItem}>%
    %<instset items foreachSelected item>%
        %<instance selection findOneRelated item R9>%
        %<instance item attribute quantityShipped>% =
                %<instance selection attribute quantity>% ;
    %<end>%
    MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
    %<my delaysignal time boxSealed>%
}
transition SealingBox - boxSealed -> AttachingShippingLabel
----
<1> We accomplish updating
`quantityShipped` attribute of the `ShippmentItems` instances
by traversing `R23` and `R9` to obtain a set of `ShipmentItem`
instance references and then iterate across them, continuing along `R9`
to obtain the corresponding `ProductSelection` instance.
We then read the `quantity` attribute and use its value to update
the `quantityShipped` value.

[source,tcl]
----
<<Shipping Clerk State Model>>=
state AttachingShippingLabel {} {
    MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
    %<my delaysignal time shippingLabelAttached>%
}
transition AttachingShippingLabel - shippingLabelAttached ->\
    DeliveringBoxtoLoadingDock

state DeliveringBoxtoLoadingDock {} {
    MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
    %<my delaysignal time boxAtLoadingDoc>%
}
transition DeliveringBoxtoLoadingDock - boxAtLoadingDoc -> CompletingJob

state CompletingJob {} {
    %<instance currentShipment findOneRelated self R23>%
    %<instance clerk findOneRelated self R27>%
    unsigned clerkID = %<instance clerk attribute clerkID>% ;
    %<instance currentShipment signal packed clerkID clerkID>%
    %<R23 unrelate self currentShipment>%
    if (%<instance clerk attribute goOffDutyAtEndOfJob>%) {
        %<my signal offDuty>%
    } else {
        %<my attribute awaitingAssignment>% = true ;
        %<instance myWarehouse findOneRelated self R27 R25>%
        %<instance myWarehouse signal clerkFree>%
    }
}
transition CompletingJob - clerkAssigned -> SelectingBooks
transition CompletingJob - offDuty -> OffDuty

state OffDuty {} {
    %<instance clerk findOneRelated self R27>%
    %<R27 reclassify clerk OffDutyClerk offduty>%
} ; # <1>
----
<1> Note that we do *not* define the `OffDuty` state as `terminal`
despite the model graphic containing a terminal transition.
This is because the `ShippingClerk` instance will not exist after
the migration to an `OffDutyClerk` and so we don't want the run
time architecture to attempt to delete what no longer exists anyway.

=== Stock Clerk Class [[stockclerkclass,Stock Clerk]]

(((Shipping,Classes,Stock Clerk)))
[source,tcl]
----
<<Stock Clerk Class Definition>>=
class StockClerk {
    attribute idle bool -default true
}
----

=== Off Duty Clerk Class [[offdutyclerkclass,Off Duty Clerk]]

(((Shipping,Classes,Off Duty Clerk)))
[source,tcl]
----
<<Off Duty Clerk Class Definition>>=
class OffDutyClerk {
}
----

=== Shipment Item Class [[shipmentitemclass,Shipment Item]]

(((Shipping,Classes,Shipment Item)))
[source,tcl]
----
<<Shipment Item Class Definition>>=
class ShipmentItem {
    attribute quantityShipped unsigned -default 0
}
----

(((Shipping,Relationships,R9)))
[source,tcl]
----
<<Shipment Item Class Definition>>=
association R9 -associator ShipmentItem Shipment 0..*--1..* ProductSelection
----

== Product Specification Subsystem Population [[productspecificationsubsystempopulation,Product Specification Subsystem Population]]

At this point we have completed the translation of the model.
When the above code is assembled together and submitted to `micca` it
results in a set of procedures and data structures that represent
the actions of the domain.
`Micca` provides a run time component to map model level actions,
_e.g._ navigating relationships to find related instances,
onto Tcl language constructs to implement the intent of the model.

However, we are not done yet.
First we must populate the domain with instances.
Although many of the classes create their instances at run time,
most of the Product Specification subsystem must be populated
with instances in order to have anything to buy at our online store.
In the next sections,
we will supply values for those classes that are not created at run time.

Note that populating a domain before running it is, in general, a necessary
task and one that is frequently overlooked.
Depending on the quantity of data,
population can be a large undertaking.
It is easy to forget about the population step as we are involved
in working out the domain and obtaining its translation.
Also remember in real development,
you may need several domain populations to support testing and integration.
This is particularly true if the domain contains a lot of data.
Workflow and timing may dictate that a separate group of people are
doing the population for the delivered system and the development team
will need to supply their own population for testing and integrating.
Also, testing and integration concerns will probably drive the
values selected for some attributes as this may drive the code path
in some of the state activities.
Finally,
testing that randomizes, in a controlled and repeatable way, the values
of attributes can often find bugs that human composed values miss.
The idea is that randomized attribute values will drive the domain's execution
into broader areas of its state space more effectively than narrowly composed
values made up by humans.

The population given below is quite minimal and is intended only to
demonstrate the translation.
Every class is populated with something and, as you will see,
many of the attribute values are nonsense.

[source,tcl]
----
<<Product Specification Population>>=
<<Product Population>>
<<Publisher Population>>
<<Author Population>>
<<Authorship Population>>
<<Book Product Population>>
<<Recording Product Population>>
<<Software Product Population>>
<<Special Order Product Population>>
<<Stocked Product Population>>
<<Product Category Population>>
<<Recording Population>>
<<Artist Population>>
<<Performance Credit Population>>
<<Recording Format Population>>
<<Platform Population>>
<<Computer Software Population>>
----

`Micca` provides support to populate a domain.
One of the advantages of the relational approach is that
a domain can be populated by pure data values alone.
It is not necessary to execute any action language equivalent
code to create instances.
This even includes relating instances across relationships.
Since we supply referential attributes,
simply setting referential attributes to the values that correspond
to the identifying attributes of the related instance is sufficient.
So below, although we are obviously execution commands in Tcl,
we are simply supplying values to attributes.
If we fail to supply correct ones,
then the population command will fail with error messages that
indicate the problem.

The basic command to populate a class provides two approaches
to specify values.
One is better suited to specifying constant values
and the other better suited when attribute values are held in
ordinary variables.
We will see both used.

=== Product Population [[productpopulation,Product Population]]

[source,tcl]
----
<<Product Population>>=
class Product {
    table {
        productID
        productName
        copyright
        unitPrice
        description
        website 
        currentlyAvailable
        R1
        R15
    } mbxuml {
        {"14387"}
        {"Executable UML: A Foundation for Model-Driven Architecture"}
        {"2002"}
        2995
        {"Book on software development using models."}
        {"www.executableumlbook.com"}
        true
        aw
        book
    } cmc {
        {"14388"}
        {"Carnival Music for Children"}
        {"1955"}
        1000
        {"Music as heard at old time carnivals."}
        {""}
        true
        otm
        music
    } macwd {
        {"14389"}
        {"Word 2020 for MacOSX"}
        {"2020"}
        5995
        {"Infamous word processing program"}
        {"www.microsoft.com"}
        true
        ms
        software
    } ; # <1>
}
----
<1> This is an example of populating using the table command.
It saves some typing to specify repeatedly the attribute names.
Note that ``C'' string literals in quotes must also be enclosed in
braces. Turns out that double quotes are Tcl metacharacters and
we need the braces to insure they are passed through as part of
the attribute value.

=== Publisher Population [[publisherpopulation,Publisher Population]]

(((Product Specification,Population,Publisher)))
[source,tcl]
----
<<Publisher Population>>=
class Publisher {
    table {
        groupCode
        publisherCode
        name
        address
        website
    } aw {
        {"0"}
        {"201"}
        {"Addison-Wesley"}
        {"New York, NY"}
        {"www.aw.com"}
    } otm {
        {"1"}
        {"523"}
        {"Old-Time Music"}
        {"St. Louis, MO"}
        {"www.otm.com"}
    } ms {
        {"2"}
        {"666"}
        {"Microsoft, Inc."}
        {"Seattle, WA"}
        {"www.microsoft.com"}
    }
}
----

=== Author Population [[authorpopulation,Author Population]]

(((Product Specification,Population,Author)))
[source,tcl]
----
<<Author Population>>=
class Author {
    table {
        name
        website
        email
    } sjm {
        {"Stephen J. Mellor"}
        {"stephenmellor.com"}
        {"stephen@stephenmellor.com"}
    } mjb {
        {"Marc J. Balcer"}
        {"marcbalcer.com"}
        {"marc@marcbalcer.com"}
    }
}
----

=== Authorship Population [[authorshippopulation,Authorship Population]]

(((Product Specification,Population,Authorship)))
[source,tcl]
----
<<Authorship Population>>=
class Authorship {
    instance sjm R2 {Author sjm BookProduct mbxuml}
    instance mjb R2 {Author mjb BookProduct mbxuml} R3 sjm
}
----

=== Book Product Population [[bookproductpopulation,Book Product Population]]

(((Product Specification,Population,Book Product)))
[source,tcl]
----
<<Book Product Population>>=
class BookProduct {
    table {
        bookNumber
        titleCode
        title
        subtitle
        R11
    } mbxuml {
        {"ISBN 0-201-74804-5"}
        {"74804-5"}
        {"Executable UML"}
        {"A Foundation for Model-Driven Architecture"}
        mbxuml
    }
}
----

=== Recording Product Population [[recordingproductpopulation,Recording Product Population]]

(((Product Specification,Population,Recording Product)))
[source,tcl]
----
<<Recording Product Population>>=
class RecordingProduct {
    table {
        runningTime
        R11
        R16
    } cmc {
        203
        cmc
        {Recording cmc RecordingFormat cd}
    }
}
----

=== Software Product Population [[softwareproductpopulation,Software Product Population]]

(((Product Specification,Population,Software Product)))
[source,tcl]
----
<<Software Product Population>>=
class SoftwareProduct {
    instance macwd\
        productVersion {"20.17.3"}\
        R11 macwd\
        R19 macosx
}
----

=== Special Order Product Population [[specialorderproductpopulation,Special Order Product Population]]

(((Product Specification,Population,Special Order Product)))
[source,tcl]
----
<<Special Order Product Population>>=
class SpecialOrderProduct {
    instance cmc\
        specialOrderInstructions {"Their part number: 30557"}\
        daysToDeliver 10\
        R12 cmc
}
----

=== Stocked Product Population [[stockedproductpopulation,Stocked Product Population]]

(((Product Specification,Population,Stocked Product)))
[source,tcl]
----
<<Stocked Product Population>>=
class StockedProduct {
    table {
        quantityOnHand
        reorderThreshold
        reorderIncrement
        reorderInstructions
        R12
    } mbxuml {
        100
        200
        100
        {"Ship as quickly as possible"}
        mbxuml
    } macwd {
        55
        25
        55
        {"Get a discount"}
        macwd
    }
}
----

=== Product Category Population [[productcategorypopulation,Product Category Population]]

(((Product Specification,Population,Product Category)))
[source,tcl]
----
<<Product Category Population>>=
class ProductCategory {
    instance book categoryName {"book"}
    instance music categoryName {"music"}
    instance software categoryName {"software"}
}
----

=== Recording Population [[recordingpopulation,Recording Population]]

(((Product Specification,Population,Recording)))
[source,tcl]
----
<<Recording Population>>=
class Recording {
    instance cmc title {"Carnival Music for Children"}
}
----

=== Artist Population [[artistpopulation,Artist Population]]

(((Product Specification,Population,Artist)))
[source,tcl]
----
<<Artist Population>>=
class Artist {
    instance mj artistName {"Mary Jane"}
    instance fs artistName {"Fred Smith"}
}
----

=== Performance Credit Population [[performancecreditpopulation,Performance Credit Population]]

(((Product Specification,Population,Performance Credit)))
[source,tcl]
----
<<Performance Credit Population>>=
class PerformanceCredit {
    instance mj R17 {Recording cmc Artist mj} R18 fs
    instance fs R17 {Recording cmc Artist fs}
}
----

=== Recording Format Population [[recordingformatpopulation,Recording Format Population]]

(((Product Specification,Population,Recording Format)))
[source,tcl]
----
<<Recording Format Population>>=
class RecordingFormat {
    instance cd formatName {"CD"}
}
----

=== Platform Population [[xxpopulation,Platform Population]]

(((Product Specification,Population,Platform)))
[source,tcl]
----
<<Platform Population>>=
class Platform {
    instance macosx platformName {"MacOSX"}
}
----

=== Computer Software Population [[computersoftwarepopulation,Computer Software Population]]

(((Product Specification,Population,Computer Software)))
[source,tcl]
----
<<Computer Software Population>>=
class ComputerSoftware {
    instance macwd title {"Word 2020 for MacOSX"} R20 macwd
}
----

== Ordering Subsystem Population [[orderingsubsystempopulation,Ordering Subystem Population]]

There are no initial instances in the Ordering subsystem.
All instances are created at run time.
Most instances are created asynchronously by events.
The requirement that *Customers* must have placed an order means that
those instances are created when an *Order* is created.
So here we only need to allocate the amount of space we require
for the ordering subsystem classes.

[source,tcl]
----
<<Ordering Population>>=
class Customer {
    allocate 20
}
class Order {
    allocate 20
}
class ProductSelection {
    allocate 40
}
class ShoppingCart {
    allocate 20
}
class CreditCardCharge {
    allocate 40
}
----

== Shipping Subsystem Population [[shippingsubsystempopulation,Shipping Subystem Population]]

[source,tcl]
----
<<Shipping Population>>=
<<Shipment Population>>
<<Shipping Company Population>>
<<Warehouse Population>>
<<Warehouse Clerk Population>>
<<Shipping Clerk Population>>
<<Stock Clerk Population>>
<<Off Duty Clerk Population>>
<<Shipment Item Population>>
----

=== Shipment Population [[shipmentpopulation,Shipment Population]]

(((Shipment,Population,Shipment)))
[source,tcl]
----
<<Shipment Population>>=
class Shipment {
    allocate 20
}
----

=== Shipping Company Population [[shippingcompanypopulation,Shipping Company Population]]

(((Shipping,Population,Shipping Company)))
[source,tcl]
----
<<Shipping Company Population>>=
class ShippingCompany {
    table {
        companyName
        trackingWebsite
        customerServicePhone
        localDispatchPhone
        localOffice
        localContact
    } fedex {
        {"FedEx"}
        {"www.fedex.com"}
        {"222-555-1212"}
        {"223-555-1212"}
        {"200 Elm St., Anywhere, CA 94000"}
        {"George Shipper"}
    } ups {
        {"UPS"}
        {"www.ups.com"}
        {"224-555-1212"}
        {"225-555-1212"}
        {"220 Elm St., Anywhere, CA 94000"}
        {"John Parcel"}
    }
}
----

=== Warehouse Population [[warehousepopulation,Warehouse Population]]

(((Shipping,Population,Warehouse)))
[source,tcl]
----
<<Warehouse Population>>=
class Warehouse {
    table {
        warehouseName
        warehouseLocation
    } acme {
        {"Acme Bookstore Warehouse"}
        {"100 Broad St., Somewhere, CA 94000"}

    } mf {
        {"My Fulfillment"}
        {"100 Fremont St., Somewhere, CA 94000"}
    }
}
----

=== Warehouse Clerk Population [[warehouseclerkpopulation,Warehouse Clerk Population]]

(((Shipping,Population,Warehouse Clerk)))
[source,tcl]
----
<<Warehouse Clerk Population>>=
class WarehouseClerk {
    table {
        clerkID
        clerkName
        R25
    } fs {
        41
        {"Fred Smith"}
        acme
    } ji {
        42
        {"John Industrious"}
        acme
    } gs {
        43
        {"George Slacker"}
        mf
    }
}
----

=== Shipping Clerk Population [[shippingclerkpopulation,Shipping Clerk Population]]

(((Shipping,Population,Shipping Clerk)))
[source,tcl]
----
<<Shipping Clerk Population>>=
class ShippingClerk {
    instance fs R27 fs
}
----

=== Stock Clerk Population [[stockclerkpopulation,Stock Clerk Population]]

(((Shipping,Population,Stock Clerk)))
[source,tcl]
----
<<Stock Clerk Population>>=
class StockClerk {
    instance ji R27 ji
}
----

=== Off Duty Clerk Population [[offdutyclerkpopulation,Off Duty Clerk Population]]

(((Shipping,Population,Off Duty Clerk)))
[source,tcl]
----
<<Off Duty Clerk Population>>=
class OffDutyClerk {
    instance gs R27 gs
}
----

=== Shipment Item Population [[shipmentitempopulation,Shipment Item Population]]

(((Shipment,Population,Shipment Item)))
[source,tcl]
----
<<Shipment Item Population>>=
class ShipmentItem {
    allocate 50
}
----

== External Entities [[externalentities,External Entities]]

At this point we have translated and populated the domain.
However, we are not quite yet ready to run it.
The last step is to deal with the explicit external entities that
crop up in the translation.

We must write stub procedures for the
external entities that are mentioned in the model.
When stubbing external entities,
two situations arise:

. The external entity action is synchronous and can return its result
immediately.
. The external entity action is asynchronous and we must arrange for some
further action, usually signaling an event, to occur in order to
simulate the external entity properly.

How much of a simulation of the external entities is required to drive
the domain execution is a matter that usually requires some introspection
in the the model.
Many are quite simple as we have in this domain.
Others may be quite complex and difficult to simulate.
This is one of the reasons why it is often better to integrate domains
_from the bottom up_ to avoid needing to create complicated external
entity stubs.
As it turns out, integrating from the bottom up also has the added advantage
of always having something that runs.
This usually makes project managers happy.

Our strategy for external entities is to define a set of namespaces in
the domain namespace to hold the required procedures.
All of these namespaces will start with `EE_` and that should avoid any
naming conflicts.

All the procedures start by printing out their invocation sequence,
_i.e._ the Tcl idom `info level 0` provides that information.
For most of the external entity procedures that is all we strive to do.

[source,tcl]
----
<<external operations>>=
externalop void CreditCardCompany_requestChargeApproval {
        cccID MRT_InstId
        accountNumber {char const *}
        billingAddress {char const *}
        cardholderName {char const *}
        cardExpirationDate {char const *}
        transactionID unsigned
        chargeAmount unsigned} {
    printf("%s:\n", __func__) ;
    printf("    cccID = %u\n", cccID) ;
    printf("    accountNumber = %s\n", accountNumber) ;
    printf("    billingAddress = %s\n", billingAddress) ;
    printf("    cardholderName = %s\n", cardholderName) ;
    printf("    cardExpirationDate = %s\n", cardExpirationDate) ;
    printf("    transactionID = %u\n", transactionID) ;
    printf("    chargeAmount = %u\n", chargeAmount) ;

    union {
        MRT_EventParams params ;
        struct bookstore_CreditCardCharge_chargeProcessed__EPARAMS cccparams ;
    } eparams = {
        .cccparams = {
            .resultCode = AP_approved
        }
    } ;
    int result = mrt_PortalSignalDelayedEvent(&bookstore__PORTAL,
        BOOKSTORE_CREDITCARDCHARGE_CLASSID,
        cccID,
        BOOKSTORE_CREDITCARDCHARGE_CHARGEPROCESSED_EVENT,
        eparams.params,
        100) ; // <1>
    assert(result == 0) ;
}
----
<1> Here we must simulate some behavior.
We take the simplest approach and approve all charges 100 ms after they
are requested.
This approach *will not* drive the execution of `CreditCardCharge` instances
to all their possible states.

[source,tcl]
----
<<external operations>>=
externalop void OnlineCustomer_chargeDeclined {
        customerID MRT_InstId
        email {char const *}} {
    printf("%s:\n", __func__) ;
    printf("    customerID = %u\n", customerID) ;
    printf("    email = %s\n", email) ;
}
externalop void OnlineCustomer_chargeApproved {
        customerID MRT_InstId
        email {char const *}} {
    printf("%s:\n", __func__) ;
    printf("    customerID = %u\n", customerID) ;
    printf("    email = %s\n", email) ;
}
externalop void OnlineCustomer_orderReportedDelivered {
        customerID MRT_InstId
        email {char const *}} {
    printf("%s:\n", __func__) ;
    printf("    customerID = %u\n", customerID) ;
    printf("    email = %s\n", email) ;
}
----

The interaction with the Shipping Company external entity also requires
more simulation to drive the domain to where we want it to go.
In this case we want to signal an event to assign a tracking number.
Later we need to report that we have picked up the package.
Finally, we need to report the package delivery.

[source,tcl]
----
<<external operations>>=
externalop void ShippingCompany_shipmentReadyForPickup {shipmentID MRT_InstId} {
    printf("%s:\n", __func__) ;
    printf("    shipmentID = %u\n", shipmentID) ;

    union {
        MRT_EventParams params ;
        struct bookstore_Shipment_trackingNumberAssigned__EPARAMS tnaparams ;
    } tnaevent = {
        .tnaparams = {
            .shippingCompany = "FedEx",
            .trackingNumber = "130047332",
        }
    } ;

    int result = mrt_PortalSignalEvent(&bookstore__PORTAL,
        BOOKSTORE_SHIPMENT_CLASSID,
        shipmentID,
        BOOKSTORE_SHIPMENT_TRACKINGNUMBERASSIGNED_EVENT,
        tnaevent.params) ;
    assert(result == 0) ;

    result = mrt_PortalSignalDelayedEvent(&bookstore__PORTAL,
        BOOKSTORE_SHIPMENT_CLASSID,
        shipmentID,
        BOOKSTORE_SHIPMENT_PICKEDUP_EVENT,
        NULL,
        200) ;
    assert(result == 0) ;

    time_t now ;
    time(&now) ;
    now += 1 ;
    union {
        MRT_EventParams params ;
        struct bookstore_Shipment_deliveryConfirmed__EPARAMS dcparams ;
    } dcevent = {
        .dcparams = {
            .timeDelivered = ctime(&now),
        }
    } ;

    result = mrt_PortalSignalDelayedEvent(&bookstore__PORTAL,
        BOOKSTORE_SHIPMENT_CLASSID,
        shipmentID,
        BOOKSTORE_SHIPMENT_DELIVERYCONFIRMED_EVENT,
        dcevent.params,
        400) ;
    assert(result == 0) ;
}
----

[source,tcl]
----
<<external operations>>=
externalop void ShippingClerk_shipmentReadyToPack {
        clerkID MRT_InstId
        shipmentID unsigned} {
    printf("%s:\n", __func__) ;
    printf("    clerkID = %u\n", clerkID) ;
    printf("    shipmentID = %u\n", shipmentID) ;
}
----

== Execution Scenarios [[executionscenarios,Execution Scenarios]]

Finally, we are ready to run the translated domain.
We will construct a single test file that contains a set of
execution scenarios.
We have chosen to do it this way so that we can use the state of the
domain created by one scenario as the starting point for the next one.
This will prevent us from having the start afresh and drive the domain
to some state just to get into position to start a run.
Real world testing would probably take another approach.

Finally,
we can show the code for running the execution scenarios.

[source,tcl]
----
<<test scenarios>>=
<<scenario1>>
<<scenario2>>
----

=== Scenario 1 [[scenario1,Scenario 1]]

Our first scenario is very simple.
We want to create a shopping cart and then decide to change our mind
and zero out our selection.
In order create a shopping cart we must supply a product ID and a quantity.
To obtain the product ID,
we extract the productID from an initial instance.
In this case,
we use the Executable UML book, which our bookstore conveniently stocks.

[source,tcl]
----
<<scenario1>>=
char const *xuml_productID ;
int result = mrt_PortalGetAttrRef(&bookstore__PORTAL,
    BOOKSTORE_PRODUCT_CLASSID,
    BOOKSTORE_PRODUCT_MBXUML_INSTID,
    BOOKSTORE_PRODUCT_PRODUCTID_ATTRID,
    (void **)&xuml_productID,
    NULL) ;
assert(result == 0) ;
printf("product ID = %s\n", xuml_productID) ;
----

We have to manufacture an ID for the cart.
Any old number will do.
We'll just keep one around in the `carttag` variable.

[source,tcl]
----
<<scenario1>>=
union {
    MRT_EventParams params ;
    struct bookstore_ShoppingCart_startCart__EPARAMS startcart ;
} cartparams = {
    .startcart = {
        .productID = xuml_productID,
        .quantity = 1,
    }
} ;

int cartInstID = mrt_PortalCreateAsync(&bookstore__PORTAL,
    BOOKSTORE_SHOPPINGCART_CLASSID,
    BOOKSTORE_SHOPPINGCART_STARTCART_EVENT,
    cartparams.params) ;
assert(cartInstID >= 0) ;
----

Since the instance creation is asynchronous,
we must wait until that event is dispatched.
Consulting the state diagram,
we can see that we need to wait until the `AddingSelectiontoOrder`
state is executed.

[source,tcl]
----
<<scenario1>>=
dispatchEvents() ;
----

Now we will effectively cancel the order by changing the
quantity associated with the product selection to 0.
To do this, we will need a domain operation to find the
product selection that needs to be signaled.

[source,tcl]
----
<<domain operations>>=
domainop void changeSelectionQuantity {
        cartID MRT_InstId
        productID MRT_InstId
        quantity unsigned} {
    %<ShoppingCart idtoref cartID cart>%
    %<Product idtoref productID product>%
    %<ProductSelection instref selection>%
    selection = NULL ;
    %<instance selection foreachRelated cart {R4 ProductSelection}>%
        %<instance selectedProduct findOneRelated selection R4>%
        if (selectedProduct == product) {
            break ;
        }
    %<end>%
    if (selection != NULL) {
        %<instance selection signal changeQuantity quantity quantity>%
    }
}
----

After invoking the domain operation,
we must dispatch the events.

[source,tcl]
----
<<scenario1>>=
bookstore_changeSelectionQuantity(
    cartInstID, BOOKSTORE_PRODUCT_MBXUML_INSTID, 0) ;
dispatchEvents() ;
----

=== Scenario 2  [[scenario2,Scenario 2]]

For the second scenario,
we will start a new cart and add some products to it.
We will also change the quantity of one of the products.
Finally, we will check out and purchase the order.

We create the new shopping cart, waiting for the creation
event to be dispatched.

[source,tcl]
----
<<scenario2>>=
cartInstID = mrt_PortalCreateAsync(&bookstore__PORTAL,
    BOOKSTORE_SHOPPINGCART_CLASSID,
    BOOKSTORE_SHOPPINGCART_STARTCART_EVENT,
    cartparams.params) ;
assert(cartInstID >= 0) ;

dispatchEvents() ;
----

We change our minds and decide we really need three copies of the
Executable UML book.

[source,tcl]
----
<<scenario2>>=
bookstore_changeSelectionQuantity(
    cartInstID, BOOKSTORE_PRODUCT_MBXUML_INSTID, 3) ;
dispatchEvents() ;
----

We also decide to buy some music.
We must look up the product ID and then add the selection to the cart.

[source,tcl]
----
<<scenario2>>=
char const *cmc_productID ;
result = mrt_PortalGetAttrRef(&bookstore__PORTAL,
    BOOKSTORE_PRODUCT_CLASSID,
    BOOKSTORE_PRODUCT_CMC_INSTID,
    BOOKSTORE_PRODUCT_PRODUCTID_ATTRID,
    (void **)&cmc_productID,
    NULL) ;
assert(result == 0) ;
printf("product ID = %s\n", cmc_productID) ;

union {
    MRT_EventParams params ;
    struct bookstore_ShoppingCart_addSelection__EPARAMS addselect ;
} selectparams = {
    .addselect = {
        .productID = cmc_productID,
        .quantity = 2, // <1>
    }
} ;
result = mrt_PortalSignalEvent(&bookstore__PORTAL,
    BOOKSTORE_SHOPPINGCART_CLASSID,
    cartInstID,
    BOOKSTORE_SHOPPINGCART_ADDSELECTION_EVENT,
    selectparams.params) ;
assert(result == 0) ;

dispatchEvents() ;
----
<1> We decide we need two copies of the music.

Finally, we checkout.
Since we stubbed out all credit cards to be approved,
we will know the order will progress to the `Being Packed and Shipped`
state.

[source,tcl]
----
<<scenario2>>=
union {
    MRT_EventParams params ;
    struct bookstore_ShoppingCart_checkOut__EPARAMS coparams ;
} checkout = {
    .coparams = {
        .accountNumber = "5555 6666 7777 8888",
        .billingAddress = "100 E Main St., Anywhere, CO 88888",
        .cardExpirationDate = "10/17",
        .cardholderName = "Fred Smith",
        .customerEmail = "fsmith@gmail.com",
        .customerName = "Fred Smith",
        .customerPhone = "222-555-1212",
        .shippingAddress = "100 E Main St., Anywhere, CO 88888",
    }
} ;

result = mrt_PortalSignalEvent(&bookstore__PORTAL,
    BOOKSTORE_SHOPPINGCART_CLASSID,
    cartInstID,
    BOOKSTORE_SHOPPINGCART_CHECKOUT_EVENT,
    checkout.params) ;
assert(result == 0) ;

dispatchEvents() ;
pause() ;
dispatchEvents() ;
----

Again we show the text of the event dispatch traces as well as the
sequence diagram.

[literal]
.State Machine Traces For Scenario 2
--
// include::scenariox.log[]
--

=== Scenario 3 [[scenario3,Scenario 3]]

For our third scenario, we will let the events unwind in the
Shipping subsystem and see how the shipment is packed and made
ready for shipment.

[source,tcl]
----
<<scenario3>>=
syncToStateActivity ShippingClerk CompletingJob 10000

logTraces scenario3
----

[literal]
.State Machine Traces For Scenario 3
--
// include::scenario3.log[]
--

=== Scenario 4 [[scenario4,Scenario 4]]

For scenario 4,
we continue to let the events unwind until we see that the
shipment was delivered.

[source,tcl]
----
<<scenario4>>=
syncToStateActivity Shipment Delivered 10000

logTraces scenario4
----

[literal]
.State Machine Traces For Scenario 4
--
// include::scenario4.log[]
--

== Code Organization [[codeorganization,Code Organization]]

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 - 2016 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<simplebookstore.micca>>=
<<copyright info>>

domain bookstore {
    <<Product Specification Subsystem>>
    <<Ordering Subsystem>>
    <<Shipping Subsystem>>
    <<type aliases>>
    <<external operations>>
    <<domain operations>>
    prologue {
        #include <time.h>
        #include <unistd.h>
    }
    epilogue {
        static void dispatchEvents(void)
        {
            int max = 100 ;
            bool didEvent ;
            do {
                didEvent = mrt_ProcessOneEvent() ;
                max-- ;
                assert(max > 0) ;
            } while (didEvent) ;
        }
        int
        main(
            int argc,
            char *argv[])
        {
            mrt_Initialize() ;
            <<test scenarios>>

            return EXIT_SUCCESS ;
        }
    }
}
----

=== Initial Instance Population

[source,tcl]
----
<<sbs_population.micca>>=
<<copyright info>>

population bookstore {
    <<Product Specification Population>>
    <<Ordering Population>>
    <<Shipping Population>>
}
----

/////

=== XX Class [[xxclass,XX]]

(((Ordering,Classes,XX)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,Relationships,RR)))
[source,tcl]
----
<<XX Class Definition>>=
----

(((Ordering,State Model,XX)))
[source,tcl]
----
<<XX State Model>>=
----
/////

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
