# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 - 2016 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

domain bookstore {
    class Product {
        attribute productID char -dimension 32
        attribute productName char -dimension 64
        attribute copyright char -dimension 8
        attribute unitPrice unsigned
        attribute description char -dimension 256
        attribute website char -dimension 128
        attribute currentlyAvailable bool
    
        classop {struct Product *} findByProductID {productID {char const *}} {
            %<Product foreachWhere product {strcmp(productID, product->productID) == 0}>%
                return product ;
            %<end>%
    
            return NULL ;
        } ; # <1>
    }
    generalization R12 Product SpecialOrderProduct StockedProduct
    generalization R11 Product BookProduct RecordingProduct SoftwareProduct
    association R15 Product 0..*--1 ProductCategory
    association R1 Product 0..*--1 Publisher
    class Publisher {
        attribute groupCode char -dimension 8
        attribute publisherCode char -dimension 16
        attribute name char -dimension 64
        attribute address char -dimension 128
        attribute website char -dimension 128
    }
    class Author {
        attribute name char -dimension 64
        attribute website char -dimension 256
        attribute email char -dimension 64
    }
    class Authorship {
        attribute preCredit char -dimension 32 -default {""}
        attribute postCredit char -dimension 32 -default {""}
    }
    association R2 -associator Authorship BookProduct 1..*--0..* Author
    class AuthorshipSequence {}
    association R3 -associator AuthorshipSequence Authorship 0..1--0..1 Authorship
    class BookProduct {
        attribute bookNumber char -dimension 32
        attribute titleCode char -dimension 32
        attribute title char -dimension 128
        attribute subtitle char -dimension 128
    }
    class RecordingProduct {
        attribute runningTime unsigned
    }
    association R16 -associator RecordingProduct Recording 1..*--1..* RecordingFormat
    class SoftwareProduct {
        attribute productVersion char -dimension 16
    }
    association R19 SoftwareProduct 1..*--1 Platform
    association R20 ComputerSoftware 1..*--1 SoftwareProduct
    class SpecialOrderProduct {
        attribute specialOrderInstructions char -dimension 256
        attribute daysToDeliver unsigned
    }
    class StockedProduct {
        attribute quantityOnHand unsigned
        attribute reorderThreshold unsigned
        attribute reorderIncrement unsigned
        attribute reorderInstructions char -dimension 256
    }
    class ProductCategory {
        attribute categoryName char -dimension 32
    }
    class CategoryGroup {}
    association R14 -associator CategoryGroup\
            ProductCategory 0..*--0..1 ProductCategory
    class Recording {
        attribute title char -dimension 128
    }
    class Artist {
        attribute artistName char -dimension 128
    }
    class PerformanceCredit {
        attribute role char -dimension 32 -default {""}
    }
    association R17 -associator PerformanceCredit Recording 1..*--1..* Artist
    class PerformanceCreditSequence {}
    association R18 -associator PerformanceCreditSequence\
            PerformanceCredit 0..1--0..1 PerformanceCredit
    class RecordingFormat {
        attribute formatName char -dimension 32
    }
    class Platform {
        attribute platformName char -dimension 32
    }
    class ComputerSoftware {
        attribute title char -dimension 128
    }
    class Customer {
        attribute email char -dimension 64
        attribute name char -dimension 64
        attribute shippingAddress char -dimension 64
        attribute phone char -dimension 32
        attribute purchasesMade unsigned -default 0 ; # <1>
    
        classop {struct Customer *} findByEmail {email {char const *}} {
            %<Customer foreachWhere customer {strcmp(email, customer->email) == 0}>%
                return customer ;
            %<end>%
    
            return NULL ;
        }
    }
    class Order {
        attribute orderID unsigned
        attribute dateOrderPlaced DateType -default {0}
        attribute totalValue unsigned
        attribute recipient char -dimension 128
        attribute deliveryAddress char -dimension 128
        attribute contactPhone char -dimension 32
    
        statemodel {
            transition @ - checkOut -> EstablishingCustomerandVerifyingPayment ; # <1>
            state EstablishingCustomerandVerifyingPayment {
                    accountNumber {char const *}
                    billingAddress {char const *}
                    cardExpirationDate DateType
                    cardholderName {char const *}
                    customerEmail {char const *}} {
                %<Customer instref customer>%
                customer = %<Customer operation findByEmail email customerEmail>% ;
                if (customer == NULL) {
                    %<Customer create customer\
                        email customerEmail\
                        name self->recipient\
                        shippingAddress self->deliveryAddress\
                        phone self->contactPhone>%
                } else {
                    %<instance customer update\
                        name self->recipient\
                        shippingAddress self->deliveryAddress\
                        phone self->contactPhone>%
                }
            
                %<OrderPlacement create op R5 {Order self Customer customer}>% // <1>
                time(&self->dateOrderPlaced) ;
            
                %<my signal submitCharge\
                    accountNumber accountNumber\
                    billingAddress billingAddress\
                    cardExpirationDate cardExpirationDate\
                    cardholderName cardholderName>%
            }
            
            transition EstablishingCustomerandVerifyingPayment - submitCharge ->\
                SubmittingCharge
            state SubmittingCharge {
                    accountNumber {char const *}
                    billingAddress {char const *}
                    cardExpirationDate DateType
                    cardholderName {char const *}} {
                unsigned chargeID = %<CreditCardCharge operation genChargeID>% ;
                %<my assign totalValue>%
                %<CreditCardCharge createasync makeCharge {order self}\
                    chargeID chargeID\
                    accountNumber accountNumber\
                    billingAddress billingAddress\
                    cardholderName cardholderName\
                    cardExpirationDate cardExpirationDate\
                    chargeAmount totalValue\
                    R7 self>% // <1> <2>
            }
            
            transition SubmittingCharge - paymentApproved -> BeingPackedandShipped
            transition SubmittingCharge - paymentDeclined -> PaymentNotApproved
            state PaymentNotApproved {} {
                %<instance customer findOneRelated self R5>%
                MRT_InstId customerID = %<instance customer instid>% ;
                %<external OnlineCustomer_chargeDeclined customerID customerID\
                        email customer->email>% ; // <1>
            }
            
            transition PaymentNotApproved - subCharge -> SubmittingCharge
            state BeingPackedandShipped {} {
                %<instance customer findOneRelated self R5>%
                %<instance customer attr purchasesMade>% += 1 ; // <1>
            
                MRT_InstId customerID = %<instance customer instid>% ;
                %<external OnlineCustomer_chargeApproved customerID customerID\
                        email customer->email>% ;
            
                unsigned shipmentID = %<Shipment operation genShipmentID>% ;
                %<Warehouse instref warehouse>% // <2>
                %<my assign orderID>%
                warehouse = %<Warehouse operation chooseWarehouse orderID orderID>% ;
                %<Shipment createasync requestShipment {}\
                    shipmentID shipmentID\
                    recipient self->recipient\
                    deliveryAddress self->deliveryAddress\
                    contactPhone self->contactPhone\
                    R6 self\
                    R24 warehouse>%
            }
            transition BeingPackedandShipped - orderDelivered -> DeliveredtoCustomer
            state DeliveredtoCustomer {} {
                %<instance customer findOneRelated self R5>% // <1>
                MRT_InstId customerID = %<instance customer instid>% ;
                %<external OnlineCustomer_orderReportedDelivered customerID customerID\
                        email customer->email>% ;
            }
        }
    
        classop unsigned genOrderID {} {
            static unsigned orderID = 100 ;
    
            return orderID ++ ;
        } ; # <1>
    }
    association R10 Order 0..1--1 ShoppingCart
    class OrderPlacement {}
    association R5 -associator OrderPlacement Order 1..*--0..1 Customer ; # <1>
    class ProductSelection {
        attribute quantity unsigned -default 0
        attribute unitPriceOfSelection unsigned -default 0
        attribute selectionValue unsigned -dependent {
            *selectionValue = %<my attr unitPriceOfSelection>% * %<my attr quantity>% ;
        }
    
        statemodel {
            initialstate NewSelection ; # <1>
            transition @ - addSelection -> NewSelection
            
            state NewSelection {
                    productID {char const *}
                    quantity unsigned} {
                %<my update quantity quantity>%
            
                %<Product instref product>%
                product = %<Product operation findByProductID productID productID>% ;
                %<instance product assign unitPrice>%
                %<my update unitPriceOfSelection unitPrice>%
            
                %<my signal changeQuantity quantity quantity>%
            }
            transition NewSelection - changeQuantity -> ChangingQuantity
            state ChangingQuantity {quantity unsigned} {
                %<my update quantity quantity>%
                if (%<my attr quantity>% == 0) {
                    %<my signal removeSelection>%
                }
            }
            transition ChangingQuantity - removeSelection -> RemovingSelection
            
            state RemovingSelection {} {
                %<instance cart findOneRelated self ~R4>%
                %<instset prodset selectRelated cart R4>%
                if (%<instset prodset cardinality>% <= 1) { // <1>
                    %<instance cart signal cancel>%
                }
            }
            terminal RemovingSelection
        }
    }
    association R4 -associator ProductSelection ShoppingCart 0..*--1..* Product
    class ShoppingCart {
        attribute cartID unsigned -default 0
        attribute totalValue unsigned -dependent {
            unsigned total = 0 ;
            %<instance psel foreachRelated self {R4 ProductSelection}>%
                %<instance psel assign selectionValue>% ;
                total += selectionValue ;
            %<end>%
            *totalValue = total ;
        }
    
        statemodel {
            transition @ - startCart -> NewOrder
            
            state NewOrder {productID {char const *} quantity unsigned} {
                %<my attr cartID>% = %<ShoppingCart operation genCartID>% ;
                %<my signal addSelection productID productID quantity quantity>%
            }
            transition NewOrder - addSelection -> AddingSelectiontoOrder
            
            state AddingSelectiontoOrder {productID {char const *} quantity unsigned} {
                %<Product instref product>%
                product = %<Product operation findByProductID productID productID>% ;
                %<ProductSelection create newSelection\
                        quantity quantity\
                        unitPriceOfSelection product->unitPrice\
                        R4 {Product product ShoppingCart self}>%
            }
            transition AddingSelectiontoOrder - addSelection -> AddingSelectiontoOrder
            transition AddingSelectiontoOrder - cancel -> CancelingEntireOrder
            transition AddingSelectiontoOrder - checkOut ->\
                    EstablishingCustomerandVerifyingPayment
            state CancelingEntireOrder {} {
                %<instance selection foreachRelated self {R4 ProductSelection}>%
                    %<instance selection delete>% // <1>
                %<end>%
            }
            terminal CancelingEntireOrder
            state EstablishingCustomerandVerifyingPayment {
                    accountNumber {char const *}
                    billingAddress {char const *}
                    cardExpirationDate DateType
                    cardholderName {char const *}
                    customerEmail {char const *}
                    customerName {char const *}
                    customerPhone {char const *}
                    shippingAddress {char const *}} {
                unsigned orderID = %<Order operation genOrderID>% ;
                %<my assign totalValue>%
                %<Order createasync checkOut {
                            accountNumber accountNumber
                            billingAddress billingAddress
                            cardExpirationDate cardExpirationDate
                            cardholderName cardholderName
                            customerEmail customerEmail}\
                        orderID orderID\
                        totalValue totalValue\
                        recipient customerName\
                        deliveryAddress shippingAddress\
                        contactPhone customerPhone\
                        R10 self>%
            }
        }
    
        classop unsigned genCartID {} {
            static unsigned cartID = 1 ;
    
            return cartID++ ;
        }
    
        classop {struct ShoppingCart *} findByCartID {cartID unsigned} {
            %<ShoppingCart foreachWhere cart {cartID == cart->cartID}>%
                return cart ;
            %<end>%
    
            return NULL ;
        }
    }
    class CreditCardCharge {
        attribute chargeID unsigned
        attribute accountNumber char -dimension 32
        attribute cardholderName char -dimension 128
        attribute billingAddress char -dimension 128
        attribute cardExpirationDate DateType
        attribute dateChargeMade DateType -default {0}
        attribute chargeAmount unsigned
        attribute approvalCode AP_Code -default AP_pending
    
        statemodel {
            transition @ - makeCharge -> RequestingChargeApproval
            
            state RequestingChargeApproval {order {struct Order *}} {
                MRT_InstId cccID = %<my instid>% ;
                %<external CreditCardCompany_requestChargeApproval\
                    cccID cccID\
                    accountNumber self->accountNumber\
                    billingAddress self->billingAddress\
                    cardholderName self->cardholderName\
                    cardExpirationDate self->cardExpirationDate\
                    transactionID self->chargeID\
                    chargeAmount self->chargeAmount>% ;
            
                %<my delaysignal 60000 chargeProcessingNotCompleted>%
            }
            transition RequestingChargeApproval - chargeProcessed -> ProcessingCompleted
            transition RequestingChargeApproval - chargeProcessingNotCompleted ->\
                DeclineForTimeout
            state ProcessingCompleted {resultCode AP_Code} {
                %<my update approvalCode resultCode>%
                %<instance order findOneRelated self R7>% // <1>
                %<my canceldelayed chargeProcessingNotCompleted>% // <2>
                if (resultCode == AP_approved) {
                    %<OrderPayment create payment R8 {CreditCardCharge self Order order}>% // <3>
                    %<instance order signal paymentApproved>%
                } else {
                    %<instance order signal paymentDeclined>%
                }
            }
            state DeclineForTimeout {} {
                %<my update approvalCode AP_connectionFailed>%
                %<instance order findOneRelated self R7>% // <1>
                %<instance order signal paymentDeclined>%
            }
        }
    
        classop unsigned genChargeID {} {
            static unsigned idnum = 100 ;
            return idnum++ ;
        }
    }
    association R7 CreditCardCharge 0..*--1 Order
    class OrderPayment {}
    association R8 -associator OrderPayment CreditCardCharge 0..1--0..1 Order ; #<1>
    class Shipment {
        attribute shipmentID unsigned
        attribute trackingNumber char -dimension 32 -default {""}
    
        attribute recipient char -dimension 128
        attribute deliveryAddress char -dimension 128
        attribute contactPhone char -dimension 32
        attribute timePrepared DateType -default {0}
        attribute timePickedUp DateType -default {0}
        attribute timeDelivered DateType -default {0}
        attribute waitingToBePacked bool -default true
    
        statemodel {
            transition @ - requestShipment -> PreparingShipment
            
            state PreparingShipment {} {
                %<instance order findOneRelated self R6>%
                %<instance order assign orderID>%
            
                %<instance selection foreachRelated order R10 {R4 ProductSelection}>%
                    %<ShipmentItem create item\
                            R9 {Shipment self ProductSelection selection}>%
                %<end>% // <1>
                %<instance warehouse findOneRelated self R24>%
                %<instance warehouse signal shipmentReadyToPack>% // <2>
            }
            transition PreparingShipment - packed -> PackedandAwaitingTrackingNumber
            transition PreparingShipment - trackingNumberAssigned ->\
                NumberAssignedandWaitingtobePacked
            state PackedandAwaitingTrackingNumber {clerkID unsigned} {
                %<my operation updatePackingInfo clerkID clerkID>% ;
            }
            transition PackedandAwaitingTrackingNumber - trackingNumberAssigned ->\
                NumberAssigned
            
            state NumberAssignedandWaitingtobePacked {
                    shippingCompany {char const *}
                    trackingNumber {char const *}} {
                %<my operation updateTrackingInfo\
                        shippingCompany shippingCompany\
                        trackingNumber trackingNumber>% ;
            }
            transition NumberAssignedandWaitingtobePacked - packed -> Packed
            
            state NumberAssigned {
                    shippingCompany {char const *}
                    trackingNumber {char const *}} {
                %<my operation updateTrackingInfo\
                        shippingCompany shippingCompany\
                        trackingNumber trackingNumber>% ;
            }
            transition NumberAssigned - pickedUp -> InTransittoCustomer
            
            state Packed {clerkID unsigned} {
                %<my operation updatePackingInfo clerkID clerkID>% ;
            }
            transition Packed - pickedUp -> InTransittoCustomer
            state InTransittoCustomer {} {
                time(&self->timePickedUp) ;
            }
            transition InTransittoCustomer - deliveryConfirmed -> Delivered
            
            state Delivered {timeDelivered DateType} {
                time(&self->timeDelivered) ;
                %<instance order findOneRelated self R6>%
                %<instance order signal orderDelivered>%
            }
        }
    
        instop void updateTrackingInfo {
                shippingCompany {char const *}\
                trackingNumber {char const *}} {
            %<my update trackingNumber trackingNumber>%
            %<ShippingCompany instref company>%
            company = %<ShippingCompany operation findByCompanyName\
                    companyName shippingCompany>% ;
            %<Delivery create delivery R21 {Shipment self ShippingCompany company}>%
        }
        
        instop void updatePackingInfo {clerkID unsigned} {
            time(&self->timePrepared) ;
            %<WarehouseClerk instref clerk>%
            clerk = %<WarehouseClerk operation findByClerkID clerkID clerkID>% ;
            %<PastPacking create pp R22 {Shipment self WarehouseClerk clerk}>%
            
            MRT_InstId shipmentID = %<my instid>% ;
            %<external ShippingCompany_shipmentReadyForPickup shipmentID shipmentID>% ;
        }
        
        classop unsigned genShipmentID {} {
            static unsigned shipmentID = 200 ;
        
            return shipmentID++ ;
        }
    }
    association R24 Shipment 0..*--1 Warehouse
    association R6 Shipment 0..1--1 Order
    class Delivery {}
    association R21 -associator Delivery Shipment 0..*--0..1 ShippingCompany ; #<1>
    class PastPacking {}
    association R22 -associator PastPacking Shipment 0..*--0..1 WarehouseClerk
    class Packing {}
    association R23 -associator Packing ShippingClerk 0..1--0..1 Shipment
    class ShippingCompany {
        attribute companyName char -dimension 32
        attribute trackingWebsite char -dimension 256
        attribute customerServicePhone char -dimension 32
        attribute localDispatchPhone char -dimension 32
        attribute localOffice char -dimension 128
        attribute localContact char -dimension 64
    
        classop {struct ShippingCompany *} findByCompanyName {
                companyName {char const *}} {
            %<ShippingCompany foreachWhere company\
                    {strcmp(companyName, company->companyName) == 0}>%
                return company ;
            %<end>%
    
            return NULL ;
        }
    }
    class WarehouseClerk {
        attribute clerkID unsigned
        attribute clerkName char -dimension 64
        attribute goOffDutyAtEndOfJob bool -default false ; # <1>
    
        classop {struct WarehouseClerk *} findByClerkID {clerkID unsigned} {
            %<WarehouseClerk foreachWhere clerk {clerkID == clerk->clerkID}>%
                return clerk ;
            %<end>%
    
            return NULL ;
        }
    }
    generalization R27 WarehouseClerk OffDutyClerk StockClerk ShippingClerk
    association R25 WarehouseClerk 1..*--1 Warehouse
    class Warehouse {
        attribute warehouseName char -dimension 32
        attribute warehouseLocation char -dimension 128
    
        statemodel {
            initialstate WaitingforaShipment ; # <1>
            defaulttrans IG ; # <2>
            state WaitingforaShipment {} {
                %<Shipment instref readyShipment>%
                readyShipment = %<my operation findReadyShipment>% ;
                if (readyShipment != NULL) {
                    %<my signal shipmentReadyToPack>%
                }
            }
            transition WaitingforaShipment - shipmentReadyToPack -> WaitingforaFreeClerk
            
            state WaitingforaFreeClerk {} {
                %<ShippingClerk instref freeClerk>%
                freeClerk = %<my operation findFreeShippingClerk>% ;
                if (freeClerk != NULL) {
                    %<my signal clerkFree>%
                }
            }
            transition WaitingforaFreeClerk - clerkFree -> AssigningClerktoShipment
            
            state AssigningClerktoShipment {} {
                %<Shipment instref readyShipment>%
                readyShipment = %<my operation findReadyShipment>% ;
            
                %<ShippingClerk instref freeClerk>%
                freeClerk = %<my operation findFreeShippingClerk>% ;
            
                %<Packing create pack R23 {ShippingClerk freeClerk Shipment readyShipment}>% // <1>
                %<instance readyShipment update waitingToBePacked false>%
                %<instance freeClerk update awaitingAssignment false>%
            
                %<instance freeClerk signal clerkAssigned>%
                %<my signal clerkAssignedToShipment>%
            }
            transition AssigningClerktoShipment - clerkAssignedToShipment ->\
                    WaitingforaShipment
        }
    
        classop {struct Warehouse *} chooseWarehouse {orderID unsigned} {
            %<Warehouse idtoref 0 warehouse>% // <1>
            return warehouse ;
        }
        instop {struct Shipment *} findReadyShipment {} {
            %<instance readyShipment foreachRelatedWhere\
                    {readyShipment->waitingToBePacked} self ~R24>%
                return readyShipment ;
            %<end>%
        
            return NULL ;
        }
        
        instop {struct ShippingClerk *} findFreeShippingClerk {} {
            %<instance freeClerk foreachRelatedWhere\
                    {freeClerk->awaitingAssignment} self ~R25 {~R27 ShippingClerk}>%
                return freeClerk ;
            %<end>%
        
            return NULL ;
        }
    }
    class ShippingClerk {
        attribute awaitingAssignment bool -default true
    
        statemodel {
            transition @ - startShipping -> WaitingforaJob
            
            state WaitingforaJob {} {
                %<my update awaitingAssignment true>%
                %<instance warehouse findOneRelated self R27 R25>%
                %<instance warehouse signal clerkFree>%
            }
            transition WaitingforaJob - clerkAssigned -> SelectingBooks
            transition WaitingforaJob - offDuty -> OffDuty
            
            state SelectingBooks {} {
                %<instance shipment findOneRelated self R23>%
                MRT_InstId clerkID = %<my instid>% ;
                %<external ShippingClerk_shipmentReadyToPack clerkID clerkID\
                        shipmentID shipment->shipmentID>% ;
            
                MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ; // <1>
                %<my delaysignal time booksSelected>%
            }
            transition SelectingBooks - booksSelected -> PackingBox
            state PackingBox {} {
                MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
                %<my delaysignal time boxPacked>%
            }
            transition PackingBox - boxPacked -> SealingBox
            state SealingBox {} {
                // <1>
                %<instset items selectRelated self R23 {R9 ShipmentItem}>%
                %<instset items foreachSelected item>%
                    %<instance selection findOneRelated item R9>%
                    %<instance selection assign quantity>%
                    %<instance item update quantityShipped quantity>%
                %<end>%
                MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
                %<my delaysignal time boxSealed>%
            }
            transition SealingBox - boxSealed -> AttachingShippingLabel
            state AttachingShippingLabel {} {
                MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
                %<my delaysignal time shippingLabelAttached>%
            }
            transition AttachingShippingLabel - shippingLabelAttached ->\
                DeliveringBoxtoLoadingDock
            
            state DeliveringBoxtoLoadingDock {} {
                MRT_DelayTime time = %<ShippingClerk operation randomdelay>% ;
                %<my delaysignal time boxAtLoadingDoc>%
            }
            transition DeliveringBoxtoLoadingDock - boxAtLoadingDoc -> CompletingJob
            
            state CompletingJob {} {
                %<instance currentShipment findOneRelated self R23>%
                %<instance clerk findOneRelated self R27>%
                %<instance clerk assign clerkID>%
                %<instance currentShipment signal packed clerkID clerkID>%
            
                %<instance packing findOneRelated self {R23 Packing}>%
                %<instance packing delete>%
                if (%<instance clerk attr goOffDutyAtEndOfJob>%) {
                    %<my signal offDuty>%
                } else {
                    %<my update awaitingAssignment true>%
                    %<instance myWarehouse findOneRelated self R27 R25>%
                    %<instance myWarehouse signal clerkFree>%
                }
            }
            transition CompletingJob - clerkAssigned -> SelectingBooks
            transition CompletingJob - offDuty -> OffDuty
            
            state OffDuty {} {
                %<instance clerk findOneRelated self R27>%
                %<R27 reclassify clerk OffDutyClerk offduty>%
            } ; # <1>
        }
    
        classop MRT_DelayTime randomdelay {} {
            // random number 1 - 10 in tenths of a second
            return (MRT_DelayTime)((rand() % 10 + 1) * 100) ;
        } ; # <1>
    }
    class StockClerk {
        attribute idle bool -default true
    }
    class OffDutyClerk {
    }
    class ShipmentItem {
        attribute quantityShipped unsigned -default 0
    }
    association R9 -associator ShipmentItem Shipment 0..*--1..* ProductSelection
    typealias AP_Code {enum {AP_approved, AP_overlimit, AP_noAccount,\
            AP_connectionFailed, AP_accountDataMismatch, AP_expired, AP_pending}}
    typealias DateType time_t
    externalop void CreditCardCompany_requestChargeApproval {
            cccID MRT_InstId
            accountNumber {char const *}
            billingAddress {char const *}
            cardholderName {char const *}
            cardExpirationDate DateType
            transactionID unsigned
            chargeAmount unsigned} {
        printf("%s:\n", __func__) ;
        printf("    cccID = %u\n", cccID) ;
        printf("    accountNumber = %s\n", accountNumber) ;
        printf("    billingAddress = %s\n", billingAddress) ;
        printf("    cardholderName = %s\n", cardholderName) ;
        printf("    cardExpirationDate = %s", ctime(&cardExpirationDate)) ;
        printf("    transactionID = %u\n", transactionID) ;
        printf("    chargeAmount = $%.2f\n", (double)chargeAmount / 100.0) ;
    
        union {
            MRT_EventParams params ;
            struct bookstore_CreditCardCharge_chargeProcessed__EPARAMS cccparams ;
        } eparams = {
            .cccparams = {
                .resultCode = AP_approved
            }
        } ;
        int result = mrt_PortalSignalDelayedEvent(&bookstore__PORTAL,
            BOOKSTORE_CREDITCARDCHARGE_CLASSID,
            cccID,
            BOOKSTORE_CREDITCARDCHARGE_CHARGEPROCESSED_EVENT,
            eparams.params,
            100) ; // <1>
        assert(result == 0) ;
    }
    externalop void OnlineCustomer_chargeDeclined {
            customerID MRT_InstId
            email {char const *}} {
        printf("%s:\n", __func__) ;
        printf("    customerID = %u\n", customerID) ;
        printf("    email = %s\n", email) ;
    }
    externalop void OnlineCustomer_chargeApproved {
            customerID MRT_InstId
            email {char const *}} {
        printf("%s:\n", __func__) ;
        printf("    customerID = %u\n", customerID) ;
        printf("    email = %s\n", email) ;
    }
    externalop void OnlineCustomer_orderReportedDelivered {
            customerID MRT_InstId
            email {char const *}} {
        printf("%s:\n", __func__) ;
        printf("    customerID = %u\n", customerID) ;
        printf("    email = %s\n", email) ;
    }
    externalop void ShippingCompany_shipmentReadyForPickup {shipmentID MRT_InstId} {
        printf("%s:\n", __func__) ;
        printf("    shipmentID = %u\n", shipmentID) ;
    
        union {
            MRT_EventParams params ;
            struct bookstore_Shipment_trackingNumberAssigned__EPARAMS tnaparams ;
        } tnaevent = {
            .tnaparams = {
                .shippingCompany = "FedEx",
                .trackingNumber = "130047332",
            }
        } ;
    
        int result = mrt_PortalSignalEvent(&bookstore__PORTAL,
            BOOKSTORE_SHIPMENT_CLASSID,
            shipmentID,
            BOOKSTORE_SHIPMENT_TRACKINGNUMBERASSIGNED_EVENT,
            tnaevent.params) ;
        assert(result == 0) ;
    
        result = mrt_PortalSignalDelayedEvent(&bookstore__PORTAL,
            BOOKSTORE_SHIPMENT_CLASSID,
            shipmentID,
            BOOKSTORE_SHIPMENT_PICKEDUP_EVENT,
            NULL,
            200) ; // <1>
        assert(result == 0) ;
    
        time_t now ;
        time(&now) ;
        now += 1 ;
        union {
            MRT_EventParams params ;
            struct bookstore_Shipment_deliveryConfirmed__EPARAMS dcparams ;
        } dcevent = {
            .dcparams = {
                .timeDelivered = now,
            }
        } ;
    
        result = mrt_PortalSignalDelayedEvent(&bookstore__PORTAL,
            BOOKSTORE_SHIPMENT_CLASSID,
            shipmentID,
            BOOKSTORE_SHIPMENT_DELIVERYCONFIRMED_EVENT,
            dcevent.params,
            1000) ; // <2>
        assert(result == 0) ;
    }
    externalop void ShippingClerk_shipmentReadyToPack {
            clerkID MRT_InstId
            shipmentID unsigned} {
        printf("%s:\n", __func__) ;
        printf("    clerkID = %u\n", clerkID) ;
        printf("    shipmentID = %u\n", shipmentID) ;
    }
    domainop void changeSelectionQuantity {
            cartID MRT_InstId
            productID MRT_InstId
            quantity unsigned} {
        %<ShoppingCart idtoref cartID cart>%
        %<Product idtoref productID product>%
        %<ProductSelection instref selection>%
        %<instance selection foreachRelated cart {R4 ProductSelection}>%
            %<instance selectedProduct findOneRelated selection R4>%
            if (selectedProduct == product) {
                break ;
            }
        %<end>%
        if (selection != NULL) {
            %<instance selection signal changeQuantity quantity quantity>%
        }
    }
    interface {
        #include <time.h>
    }
    prologue {
        #include <unistd.h>
    }
    epilogue {
        static void dispatchEvents(void)
        {
            int max = 100 ; // <1>
            bool didEvent ;
            do {
                didEvent = mrt_ProcessOneEvent() ;
                max-- ;
                assert(max > 0) ;
            } while (didEvent) ;
        }
        int
        main(
            int argc,
            char *argv[])
        {
            mrt_Initialize() ;
            puts("**** Scenario 1: begin") ;
            
            char const *xuml_productID ;
            int result = mrt_PortalGetAttrRef(&bookstore__PORTAL,
                BOOKSTORE_PRODUCT_CLASSID,
                BOOKSTORE_PRODUCT_MBXUML_INSTID,
                BOOKSTORE_PRODUCT_PRODUCTID_ATTRID,
                (void **)&xuml_productID,
                NULL) ;
            assert(result == 0) ;
            puts("---- creating a shopping cart") ;
            
            union {
                MRT_EventParams params ;
                struct bookstore_ShoppingCart_startCart__EPARAMS startcart ;
            } cartparams = {
                .startcart = {
                    .productID = xuml_productID,
                    .quantity = 1,
                }
            } ; // <1>
            
            int cartInstID = mrt_PortalCreateAsync(&bookstore__PORTAL,
                BOOKSTORE_SHOPPINGCART_CLASSID,
                BOOKSTORE_SHOPPINGCART_STARTCART_EVENT,
                cartparams.params) ;
            assert(cartInstID >= 0) ;
            dispatchEvents() ;
            puts("---- changing quantity to 0") ;
            bookstore_changeSelectionQuantity(
                cartInstID, BOOKSTORE_PRODUCT_MBXUML_INSTID, 0) ;
            dispatchEvents() ;
            
            puts("**** Scenario 1: end") ;
            puts("**** Scenario 2: begin") ;
            puts("---- creating a new cart") ;
            cartInstID = mrt_PortalCreateAsync(&bookstore__PORTAL,
                BOOKSTORE_SHOPPINGCART_CLASSID,
                BOOKSTORE_SHOPPINGCART_STARTCART_EVENT,
                cartparams.params) ;
            assert(cartInstID >= 0) ;
            
            dispatchEvents() ;
            puts("---- change quantity to 2 books") ;
            bookstore_changeSelectionQuantity(
                cartInstID, BOOKSTORE_PRODUCT_MBXUML_INSTID, 3) ;
            dispatchEvents() ;
            puts("---- adding music to the shopping cart") ;
            char const *cmc_productID ;
            result = mrt_PortalGetAttrRef(&bookstore__PORTAL,
                BOOKSTORE_PRODUCT_CLASSID,
                BOOKSTORE_PRODUCT_CMC_INSTID,
                BOOKSTORE_PRODUCT_PRODUCTID_ATTRID,
                (void **)&cmc_productID,
                NULL) ;
            assert(result == 0) ;
            
            union {
                MRT_EventParams params ;
                struct bookstore_ShoppingCart_addSelection__EPARAMS addselect ;
            } selectparams = {
                .addselect = {
                    .productID = cmc_productID,
                    .quantity = 2, // <1>
                }
            } ;
            result = mrt_PortalSignalEvent(&bookstore__PORTAL,
                BOOKSTORE_SHOPPINGCART_CLASSID,
                cartInstID,
                BOOKSTORE_SHOPPINGCART_ADDSELECTION_EVENT,
                selectparams.params) ;
            assert(result == 0) ;
            
            dispatchEvents() ;
            puts("---- checking out") ;
            struct tm expiration ;
            memset(&expiration, 0, sizeof(expiration)) ;
            strptime("10/17", "%m/%y", &expiration) ;
            union {
                MRT_EventParams params ;
                struct bookstore_ShoppingCart_checkOut__EPARAMS coparams ;
            } checkout = {
                .coparams = {
                    .accountNumber = "5555 6666 7777 8888",
                    .billingAddress = "100 E Main St., Anywhere, CO 88888",
                    .cardExpirationDate = mktime(&expiration),
                    .cardholderName = "Fred Smith",
                    .customerEmail = "fsmith@gmail.com",
                    .customerName = "Fred Smith",
                    .customerPhone = "222-555-1212",
                    .shippingAddress = "100 E Main St., Anywhere, CO 88888",
                }
            } ;
            
            result = mrt_PortalSignalEvent(&bookstore__PORTAL,
                BOOKSTORE_SHOPPINGCART_CLASSID,
                cartInstID,
                BOOKSTORE_SHOPPINGCART_CHECKOUT_EVENT,
                checkout.params) ;
            assert(result == 0) ;
            
            dispatchEvents() ;
            puts("---- payment approval") ;
            
            pause() ; // <1>
            dispatchEvents() ;
            
            puts("**** Scenario 2: end") ;
            puts("**** Scenario 3: begin") ;
            puts("---- packing order") ;
            
            for (int i = 0 ; i < 5 ; i++) { // <1>
                pause() ;
                dispatchEvents() ;
            }
            
            puts("**** Scenario 3: end") ;
            puts("**** Scenario 4: begin") ;
            puts("---- delivering shipment") ;
            
            for (int i = 0 ; i < 2 ; i++) {
                pause() ;
                dispatchEvents() ;
            }
            
            puts("**** Scenario 4: end") ;

            return EXIT_SUCCESS ;
        }
    }
}
