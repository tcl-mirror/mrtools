/*
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 - 2021 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

Micca version:
1.3.2
*/

#define _POSIX_C_SOURCE 200809L

#include "micca_rt.h"
#include "micca_rt_internal.h"
#include <signal.h>
#include <errno.h>
#include <sys/select.h>
#include <sys/time.h>
#include <time.h>

/*
 * Constants
 */
#define TRANS_LEVEL_MAX UINT16_MAX

/*
 * Data Types
 */
typedef uint16_t MRT_LevelCount ;

typedef struct mrtTransEntry {
    struct mrtTransEntry *next ;
    MRT_LevelCount level ;
    MRT_Relationship const *relationship ;
} MRT_TransEntry ;
typedef struct mrteventqueue {
    MRT_ecb *next ;
    MRT_ecb *prev ;
} MRT_EventQueue ;
typedef struct mrtdelayedeventparams {
    MRT_ecb *ecb ;
} MRT_DelayedEventParams ;
typedef struct mrtperiodiceventparams {
    MRT_AllocStatus alloc ;
    MRT_EventCode eventNumber ;
    MRT_Instance *targetInst ;
    MRT_Instance *sourceInst ;
} MRT_PeriodicEventParams ;
typedef struct mrtsyncblock {
    MRT_SyncFunc function ;
    alignas(max_align_t) MRT_SyncParams params ;    // <1>
} MRT_SyncBlock ;
typedef struct mrtsyncqueue {
    MRT_SyncBlock *head ;
    MRT_SyncBlock *tail ;
} MRT_SyncQueue ;
typedef struct mrtfdservicemap {
    bool set ;
    MRT_FDServiceFunc read ;
    MRT_FDServiceFunc write ;
    MRT_FDServiceFunc except ;
} MRT_FDServiceMap ;

/*
 * Forward References
 */
static bool mrtProcessTOCEvent(void) ;
static MRT_Instance *
mrtFindInstSlot(
    MRT_iab *iab) ;
static inline void *mrtNextInstSlot(MRT_iab *iab, void *ptr) ;
static MRT_iab *
mrtGetStorageProperties(
    MRT_Class const *const classDesc,
    size_t *offsetptr) ;
static inline MRT_AllocStatus mrtIncrAllocCounter(MRT_iab *iab) ;
static void
mrtMarkRelationship(
    MRT_Relationship const *const *rel,
    unsigned relCount) ;
static void mrtEndTransaction(void) ;

static bool mrtCheckRelationship(MRT_Relationship const *rel) ;
static void mrtZeroRefCounts(MRT_Class const *const classDesc) ;
static bool
mrtCheckRefCounts(MRT_Class const *const classDesc, MRT_Cardinality cardinality) ;
static bool
mrtCheckAssociatorRefs(MRT_AssociatorRole const *associator) ;
static void
mrtCountAssocRefs(
    MRT_AssociationRole const *source,
    MRT_Class const *const targetClass) ;
static void
mrtCountSingularRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *const targetClass) ;
static void
mrtCountArrayRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *const targetClass) ;
static void
mrtCountLinkedListRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset refOffset,
    MRT_Class const *const targetClass,
    MRT_AttrOffset linkOffset) ;
static void
mrtCountClassAssocRefs(
    MRT_AssociationRole const *participant,
    MRT_Class const *const assocClass) ;
static void
mrtCountGenRefs(
    MRT_RefGeneralization const *gen) ;
static void
mrtCountUnionRefs(
    MRT_UnionGeneralization const *gen) ;
static void mrtDeleteLinks(MRT_Relationship const * const *classRels,
        unsigned relCount, void *inst) ;
static void
mrtUnlinkBackref(
    MRT_AssociationRole const *const targetRole,
    void *source,
    void *target) ;
static void mrtStartDelayedQueueTiming(void) ;
static void mrtStopDelayedQueueTiming(void) ;
static bool mrtDispatchEventFromQueue(MRT_EventQueue *queue) ;

static void mrtDispatchTransitionEvent(MRT_ecb *ecb) ;
static void mrtDispatchPolymorphicEvent(MRT_ecb *ecb) ;
static void mrtDispatchCreationEvent(MRT_ecb *ecb) ;
static void mrtDispatchEvent(MRT_ecb *ecb) ;
static inline bool mrtSyncQueueEmpty(void) ;
static MRT_SyncParams *mrtSyncQueuePut(MRT_SyncFunc f) ;
static MRT_SyncBlock *mrtSyncQueueGet(void) ;
static inline bool mrtInvokeOneSyncFunction(void) ;
#ifndef MRT_NO_TRACE
static char const *mrtTimestamp(void) ;
#endif /* MRT_NO_TRACE */
static void
mrtDefaultFatalErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list ap) ;
noreturn static void
mrtFatalError(MRT_ErrorCode errNum, ...) ;

/*
 * Static Data
 */
#   ifndef MRT_NO_TRACE
static MRT_TraceHandler mrtTraceHandler ;
#   endif /* MRT_NO_TRACE */

static bool mrtExitEventLoop ;
static MRT_LevelCount mrtTransLevel ;
static MRT_TransEntry *mrtFreeTransEntries ;
static MRT_TransEntry *mrtTransEntries ;
static MRT_TransEntry mrtTransStorage[MRT_TRANSACTION_SIZE] ;
static MRT_ecb mrtECBPool[MRT_EVENT_POOL_SIZE] ;
static MRT_EventQueue eventQueue ;
static MRT_EventQueue tocEventQueue ;
static MRT_EventQueue delayedEventQueue ;
static MRT_EventQueue freeEventQueue ;
static MRT_SyncBlock mrtSyncQueueStorage[MRT_SYNC_QUEUE_SIZE] ;
static MRT_SyncQueue mrtSyncQueue = {
    .head = mrtSyncQueueStorage,
    .tail = mrtSyncQueueStorage,
} ;
static char const * const mrtErrorMsgs[] = {
    [0] = "no error",     /* place holder */
    [mrtNoECB] = "no available Event Control Blocks\n",
    [mrtSyncOverflow] = "synchronization queue overflow\n",
    [mrtTransOverflow] = "transaction markings overflow\n",
    [mrtInstSetOverflow] = "instance set overflow: instance number %u\n",
    [mrtStaticRelationship] = "attempt to modify static relationship\n",
    [mrtRelationshipLinkage] = "invalid instance linkage operation or value\n",
    [mrtPanic] = "panic: %s\n",

#       ifndef MRT_NO_NAMES
    [mrtCantHappen] = "can't happen transition: %s.%s: %s - %s -> CH\n",
    [mrtEventInFlight] = "event-in-flight error: %s.%s - %s -> %s.%s\n",
    [mrtNoInstSlot] = "no available instance slots: %s\n",
    [mrtUnallocSlot] = "unallocated instance slot: %u in class %s\n",
    [mrtRefIntegrity] = "referential integrity check failed: %s\n",
    [mrtDupAssociator] = "duplicate associator instance: %s\n",
#       else
    [mrtCantHappen] = "can't happen transition: %p: %u - %u -> CH\n",
    [mrtEventInFlight] = "event-in-flight error: %p - %u -> %p\n",
    [mrtNoInstSlot] = "no available instance slots: %p\n",
    [mrtUnallocSlot] = "unallocated instance slot: %u in class %p\n",
    [mrtRefIntegrity] = "referential integrity check failed: %p\n",
    [mrtDupAssociator] = "duplicate associator instance: %p\n",
#       endif /* MRT_NO_NAMES */

#       ifdef _POSIX_C_SOURCE
    [mrtTimerOpFailed] = "interval timer operation failed: %s\n",
    [mrtSignalOpFailed] = "signal operation failed: %s\n",
    [mrtSelectWaitFailed] = "blocking on pselect() failed: %s\n",
#       endif /* _POSIX_C_SOURCE */
} ;
static MRT_FatalErrorHandler mrtErrHandler = mrtDefaultFatalErrorHandler ;
static sigset_t mrtSigMask ;
static struct mrtfdservicemap mrtFDServicePool[FD_SETSIZE] ;
static int mrtMaxFD = -1 ;
static fd_set mrtReadFDS ;
static fd_set mrtWriteFDS ;
static fd_set mrtExceptFDS ;

/*
 * Static Inline Functions
 */
static inline
void
mrtIncrTransLevel(void)
{
    if (mrtTransLevel == TRANS_LEVEL_MAX) {
        mrtFatalError(mrtTransOverflow) ;       // <1>
    }
    mrtTransLevel += 1 ;
}
static inline
void
mrtDecrTransLevel(void)
{
    if (mrtTransLevel != 0) {
        mrtTransLevel -= 1 ;        // <1>
    }
}
static inline
void
mrtInsertTrans(
    MRT_TransEntry **list,
    MRT_TransEntry *entry)
{
    assert(list != NULL) ;
    assert(entry != NULL) ;

    entry->next = *list ;
    *list = entry ;
}
static inline
MRT_TransEntry *
mrtRemoveTrans(
    MRT_TransEntry **list)
{
    assert(list != NULL) ;

    MRT_TransEntry *entry = *list ;
    if (entry != NULL) {
        *list = entry->next ;
        entry->next = NULL ;                // <1>
    }

    return entry ;
}
static inline
void
mrtDiscardTrans(void)
{
    MRT_TransEntry *entry = mrtRemoveTrans(&mrtTransEntries) ;
    assert(entry != NULL) ;                                     // <1>
    if (entry != NULL) {
        mrtInsertTrans(&mrtFreeTransEntries, entry) ;
    }
}
static inline
uint8_t
mrtIncrRefCount(
    uint8_t count)
{
    return (count == UINT8_MAX) ? 2 : count + 1 ;       // <1>
}
static inline MRT_ecb *
mrtEventQueueBegin(
    MRT_EventQueue *queue)
{
    return queue->next ;
}
static inline MRT_ecb *
mrtEventQueueEnd(
    MRT_EventQueue *queue)
{
    return (MRT_ecb *)queue ;
}
static inline bool
mrtEventQueueEmpty(
    MRT_EventQueue *queue)
{
    return mrtEventQueueBegin(queue) == mrtEventQueueEnd(queue) ;
}
static inline void
mrtEventQueueInsert(
    MRT_ecb *item,
    MRT_ecb *at)
{
    item->prev = at->prev ;
    item->next = at ;
    at->prev->next = item ;
    at->prev = item ;
}
static inline void
mrtEventQueueRemove(
    MRT_ecb *item)
{
    item->prev->next = item->next ;
    item->next->prev = item->prev ;
    item->prev = item->next = NULL ; // <1>
}
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtCantHappenError(
    MRT_Instance *const targetInst,
    MRT_StateCode currentState,
    MRT_EventCode eventNumber)
{
    mrtFatalError(mrtCantHappen,
        targetInst->classDesc->name,
        targetInst->name ? targetInst->name : "?",
        targetInst->classDesc->edb->stateNames[currentState],
        targetInst->classDesc->eventNames[eventNumber]) ;
}

#else

noreturn static void inline
mrtCantHappenError(
    MRT_Instance *const targetInst,
    MRT_StateCode currentState,
    MRT_EventCode eventNumber)
{
    mrtFatalError(mrtCantHappen, targetInst, currentState, eventNumber) ;
}

#endif /* MRT_NO_NAMES */
#ifndef MRT_NO_NAMES
noreturn static void inline
mrtEventInFlightError(
    MRT_Instance *const sourceInst,
    MRT_EventCode eventNumber,
    MRT_Instance *const targetInst)
{
    mrtFatalError(mrtEventInFlight,
            sourceInst ? sourceInst->classDesc->name : "?",
            sourceInst ? sourceInst->name : "?",
            targetInst->classDesc->eventNames[eventNumber],
            targetInst->classDesc->name,
            targetInst->name ? targetInst->name : "?") ;
}

#else

noreturn static void inline
mrtEventInFlightError(
    MRT_Instance *const sourceInst,
    MRT_EventCode eventNumber,
    MRT_Instance *const targetInst)
{
    mrtFatalError(mrtEventInFlight, sourceInst, eventNumber, targetInst) ;
}

#endif /* MRT_NO_NAMES */
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtNoInstSlotError(
    MRT_Class const *const classDesc)
{
    mrtFatalError(mrtNoInstSlot, classDesc->name) ;
}

#else

noreturn static void inline
mrtNoInstSlotError(
    MRT_Class const *const classDesc)
{
    mrtFatalError(mrtNoInstSlot, classDesc) ;
}

#endif /* MRT_NO_NAMES */
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtUnallocSlotError(
    MRT_InstId slot,
    MRT_Class const *const classDesc)
{
    mrtFatalError(mrtUnallocSlot, slot, classDesc->name) ;
}

#else

noreturn static void inline
mrtUnallocSlotError(
    MRT_InstId slot,
    MRT_Class const *const classDesc)
{
    mrtFatalError(mrtUnallocSlot, slot, classDesc) ;
}

#endif /* MRT_NO_NAMES */
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtRefIntegrityError(
    MRT_Relationship const *const rel)
{
    mrtFatalError(mrtRefIntegrity, rel->name) ;
}

#else

noreturn static void inline
mrtRefIntegrityError(
    MRT_Relationship const *const rel)
{
    mrtFatalError(mrtRefIntegrity, rel) ;
}

#endif /* MRT_NO_NAMES */
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtDupAssociatorError(
    MRT_Relationship const *const rel)
{
    mrtFatalError(mrtDupAssociator, rel->name) ;
}

#else

noreturn static void inline
mrtDupAssociatorError(
    MRT_Relationship const *const rel)
{
    mrtFatalError(mrtDupAssociator, rel) ;
}

#endif /* MRT_NO_NAMES */
static inline void
mrtLinkRefInit(
    MRT_LinkRef *ref)
{
    ref->next = ref->prev = ref ;
}
static inline void
mrtLinkRefRemove(
    MRT_LinkRef *item)
{
    item->prev->next = item->next ;
    item->next->prev = item->prev ;
    item->next = item->prev = NULL ; // <1>
}
static inline void
mrtLinkRefInsert(
    MRT_LinkRef *item,
    MRT_LinkRef *at)
{
    if (item->next != NULL || item->prev != NULL) { // <1>
        mrtFatalError(mrtRelationshipLinkage) ;
    }
    item->prev = at->prev ;
    item->next = at ;
    at->prev->next = item ;
    at->prev = item ;
}

/*
 * Static Functions
 */
#   ifndef MRT_NO_TRACE
static inline void
mrtTraceTransitionEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_StateCode currentState,
    MRT_StateCode newState)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace = {
            .eventType = mrtTransitionEvent,
            .eventNumber = event,
            .sourceInst = source,
            .targetInst = target,
            .info.transitionTrace = {
                .currentState = currentState,
                .newState = newState
            }
        } ;
        mrtTraceHandler(&trace) ;
    }
}
static inline void
mrtTracePolymorphicEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_SubclassCode subclass,
    MRT_DispatchCount genNumber,
    MRT_EventCode newEvent)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace = {
            .eventType = mrtPolymorphicEvent,
            .eventNumber = event,
            .sourceInst = source,
            .targetInst = target,
            .info.polyTrace = {
                .subcode = subclass,
                .genNumber = genNumber,
                .mappedEvent = newEvent
            }
        } ;
        mrtTraceHandler(&trace) ;
    }
}
static inline void
mrtTraceCreationEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_Class const *class)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace = {
            .eventType = mrtCreationEvent,
            .eventNumber = event,
            .sourceInst = source,
            .targetInst = target,
            .info.creationTrace = {
                .targetClass = class
            }
        } ;
        mrtTraceHandler(&trace) ;
    }
}
#ifndef MRT_NO_STDIO
#ifndef MRT_NO_NAMES
static void
mrtPrintTraceInfo(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
        char const *newStateName ;
        if (newState == MRT_StateCode_IG) {
            newStateName = "IG" ;
        } else if (newState == MRT_StateCode_CH) {
            newStateName = "CH" ;
        } else {
            newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.newState] ;
        }

        printf("%s: Transition: %s.%s - %s -> %s.%s: %s ==> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.currentState],
            newStateName) ;
    }
        break ;

    case mrtPolymorphicEvent: {
        MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
                genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
        MRT_Class const *subclass ;
        char const *subname = NULL ;
        if (rel->relType == mrtRefGeneralization) {
            subclass = rel->relInfo.refGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
            subname = subclass->name ;
        } else if (rel->relType == mrtUnionGeneralization) {
            subclass = rel->relInfo.unionGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode] ;
            subname = subclass->name ;
        } else {
            printf("%s: bad relationship type in polymorphic event, %d\n",
                mrtTimestamp(), rel->relType) ;
            break ;
        }
        printf("%s: Polymorphic: %s.%s - %s -> %s.%s: %s - %s -> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->pdb->genNames[
                traceInfo->info.polyTrace.genNumber],
            subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
            subname) ;
    }
        break ;

    case mrtCreationEvent:
        printf("%s: Creation: %s.%s - %s -> %s ==> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->info.creationTrace.targetClass->name,
            targetName) ;
        break ;

    default:
        printf("%s: Unknown trace event type, \"%u\"",
                mrtTimestamp(), traceInfo->eventType) ;
        break ;
    }
}
#   else  /* MRT_NO_NAMES is defined */
static void
mrtPrintTraceInfo(
    MRT_TraceInfo const *traceInfo)
{
    switch (traceInfo->eventType) {
    case mrtTransitionEvent:
        printf("%s: Transition: %p - %u -> %p: %u ==> %u\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->targetInst,
                traceInfo->info.transitionTrace.currentState,
                traceInfo->info.transitionTrace.newState) ;
        break ;

    case mrtPolymorphicEvent:
        printf("%s: Polymorphic: %p - %u -> %p: %u - %u -> %d\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->targetInst,traceInfo->info.polyTrace.genNumber,
                traceInfo->info.polyTrace.mappedEvent,
                traceInfo->info.polyTrace.subcode) ;
        break ;

    case mrtCreationEvent:
        printf("%s: Creation: %p - %u -> %p ==> %p\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->info.creationTrace.targetClass,
                traceInfo->targetInst) ;
        break ;

    default:
        printf("%s: Unknown trace event type, \"%u\"",
                mrtTimestamp(), traceInfo->eventType) ;
        break ;
    }
}
#endif /* MRT_NO_NAMES */
#endif /* MRT_NO_STDIO */
static char const *
mrtTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "too big" ;
    }

    return timestamp ;
}
#   endif /* MRT_NO_TRACE */

static inline void
mrtBeginCriticalSection(void)
{
    if (sigprocmask(SIG_BLOCK, &mrtSigMask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
static inline void
mrtEndCriticalSection(void)
{
    if (sigprocmask(SIG_UNBLOCK, &mrtSigMask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
static inline MRT_DelayTime
mrtMsecToTicks(
    MRT_DelayTime msec)
{
    return msec ;
}
static inline MRT_DelayTime
mrtTicksToMsec(
    MRT_DelayTime ticks)
{
    return ticks ;
}
static void
mrtSysTimerMask(void)
{
    /*
     * Make sure SIGALRM does not go off.
     */
    sigset_t mask ;
    sigemptyset(&mask) ;
    sigaddset(&mask, SIGALRM) ;
    if (sigprocmask(SIG_BLOCK, &mask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
static void
mrtSysTimerUnmask(void)
{
    /*
     * Allow SIGALRM to notify us.
     */
    sigset_t mask ;
    sigemptyset(&mask) ;
    sigaddset(&mask, SIGALRM) ;
    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
static void
mrtSysTimerStart(
    MRT_DelayTime time)
{
    struct itimerval delayedEventTimer ;

    delayedEventTimer.it_interval.tv_sec = 0 ;
    delayedEventTimer.it_interval.tv_usec = 0 ;
    delayedEventTimer.it_value.tv_sec = time / 1000 ;
    delayedEventTimer.it_value.tv_usec = (time % 1000) * 1000 ;

    if (setitimer(ITIMER_REAL, &delayedEventTimer, NULL) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }
    mrtSysTimerUnmask() ;
}
static MRT_DelayTime
mrtSysTimerStop(void)
{
    mrtSysTimerMask() ;
    /*
     * Fetch the remaining time.
     */
    struct itimerval delayedEventTimer ;
    if (getitimer(ITIMER_REAL, &delayedEventTimer) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }
    /*
     * Convert the returned time into milliseconds.
     */
    MRT_DelayTime remain =
            delayedEventTimer.it_value.tv_sec * 1000 +
            delayedEventTimer.it_value.tv_usec / 1000 ;
    /*
     * Set the current timer value to zero to turn it off.
     */
    memset(&delayedEventTimer, 0, sizeof(delayedEventTimer)) ;
    if (setitimer(ITIMER_REAL, &delayedEventTimer, NULL) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }

    return remain ;
}
static void
mrtSysTimerExpire(
    int signum)
{
    MRT_DelayTime nextTime = mrt_TimerExpireService() ;
    if (nextTime != 0) {
        mrtSysTimerStart(nextTime) ;
    }
}
static void
mrtInitSysTimer(void)
{
    mrt_RegisterSignal(SIGALRM, mrtSysTimerExpire) ;
}
static void
mrtInitFDService(void)
{
    FD_ZERO(&mrtReadFDS) ;
    FD_ZERO(&mrtWriteFDS) ;
    FD_ZERO(&mrtExceptFDS) ;
}
static void
mrtWait(void)
{
    mrtBeginCriticalSection() ;
    if (mrtSyncQueueEmpty()) {
        /*
         * Copy the file descriptor sets since "pselect" modifies them in place
         * upon return.
         */
        fd_set readfds ;
        memcpy(&readfds, &mrtReadFDS, sizeof(readfds)) ;
        fd_set writefds ;
        memcpy(&writefds, &mrtWriteFDS, sizeof(writefds)) ;
        fd_set exceptfds ;
        memcpy(&exceptfds, &mrtExceptFDS, sizeof(exceptfds)) ;
        /*
         * Allow all the signals during the select.
         */
        sigset_t mask ;
        sigemptyset(&mask) ;
        /*
         * "mrtMaxFD" holds the maximum value of any registered file
         * descriptor. We must add one to get the number of file descriptors
         * "pselect" is to consider.
         */
        int r = pselect(mrtMaxFD + 1, &readfds, &writefds,
                &exceptfds, NULL, &mask) ;
        if (r == -1) {
            if (errno != EINTR) {
                mrtFatalError(mrtSelectWaitFailed, strerror(errno)) ;
            }
            /*
             * Got a signal while waiting. We go back to the main loop on the
             * assumption that something has been placed in the sync queue.
             */
        } else {
            /*
             * Dispatch the service functions for the file descriptors.
             */
            MRT_FDServiceMap *s = mrtFDServicePool ;
            for (int fd = 0 ; r > 0 && fd <= mrtMaxFD ; fd++, s++) {
                /*
                 * Do exceptions first. This is only important for sockets, but
                 * without going first the OOB data processing won't work.
                 */
                if (FD_ISSET(fd, &exceptfds)) {
                    assert(s->except != NULL) ;
                    s->except(fd) ;
                    --r ;
                }
                if (FD_ISSET(fd, &readfds)) {
                    assert(s->read != NULL) ;
                    s->read(fd) ;
                    --r ;
                }
                if (FD_ISSET(fd, &writefds)) {
                    assert(s->write != NULL) ;
                    s->write(fd) ;
                    --r ;
                }
            }
        }
    }
    mrtEndCriticalSection() ;
}
static inline void
mrtPlatformInit(void)
{
    sigemptyset(&mrtSigMask) ;
}
static bool
mrtRunThreadOfControl(void)
{
    bool startedtoc = mrtProcessTOCEvent() ;

    if (startedtoc) {
        while (mrtDispatchEventFromQueue(&eventQueue)) {
            // N.B. empty loop body
        }
        mrtEndTransaction() ;
    }

    return startedtoc ;
}
static bool
mrtProcessTOCEvent(void)
{
    while (mrtInvokeOneSyncFunction()) {
        ; /* empty loop body */
    }

    return mrtDispatchEventFromQueue(&tocEventQueue) ;
}
static MRT_Instance *
mrtFindInstSlot(
    MRT_iab *iab)
{
    assert(iab != NULL) ;
    assert(iab->storageLast < iab->storageFinish) ;
    /*
     * Search for an empty slot in the pool. Start at the next location after
     * where we last allocated an instance.
     */
    MRT_Instance *inst ;
    for (inst = mrtNextInstSlot(iab, iab->storageLast) ;
            inst->alloc != 0 && inst != iab->storageLast ;
            inst = mrtNextInstSlot(iab, inst)) {
        /* Empty Body */
    }
    /*
     * Check if we ended up on a slot that is free.
     */
    return inst->alloc == 0 ? inst : NULL ; // <1>

}
static inline void *
mrtNextInstSlot(
    MRT_iab *iab,
    void *ptr)
{
    ptr = (void *)((uintptr_t)ptr + iab->instanceSize) ; // <1>
    if (ptr >= iab->storageFinish) { // <2>
        ptr = iab->storageStart ;
    }
    return ptr ;
}
static MRT_iab *
mrtGetStorageProperties(
    MRT_Class const *const classDesc,
    MRT_AttrOffset *offsetptr)
{
    assert(classDesc != NULL) ;
    MRT_iab *iab = classDesc->iab ;
    MRT_AttrOffset instanceOffset = 0 ; // <1>
    for (struct mrtsuperclassrole const *container = classDesc->containment ;
            container != NULL ;
            container = container->classDesc->containment) {// <2>
        instanceOffset += container->storageOffset ;
        iab = container->classDesc->iab ;
    }
    if (offsetptr) {// <3>
        *offsetptr = instanceOffset ;
    }

    return iab ;
}
static void *
mrtIndexToInstance(
    MRT_Class const *const classDesc,
    MRT_InstId index)
{
    assert(classDesc != NULL) ;
    MRT_AttrOffset offset ;
    MRT_iab *iab = mrtGetStorageProperties(classDesc, &offset) ;
    void *instance = (void *)((uintptr_t)iab->storageStart +
            (index * iab->instanceSize) + offset) ;
    if (instance >= iab->storageFinish) {                       // <1>
        mrtNoInstSlotError(classDesc) ;
    }

    return (((MRT_Instance *)instance)->alloc <= 0) ? NULL : instance ;
}
static void
mrtInitializeInstance(
    MRT_Instance *inst,
    MRT_Class const *const classDesc,
    MRT_StateCode initialState)
{
    assert(inst != NULL) ;
    assert(classDesc != NULL) ;

    MRT_iab *iab = classDesc->iab ;
    assert(iab != NULL) ;
    /*
     * Start with a zeroed out memory space.
     */
    memset(inst, 0, iab->instanceSize) ;                            // <1>
    inst->classDesc = classDesc ;
    /*
     * Mark the slot as in use.
     */
    inst->alloc = mrtIncrAllocCounter(iab) ;
    if (classDesc->edb != NULL) {
        assert(initialState < classDesc->edb->stateCount) ;

        inst->currentState = (initialState == MRT_StateCode_IG ||
            initialState >= classDesc->edb->stateCount) ?
                classDesc->edb->initialState : initialState ;       // <2>
    } else {
        inst->currentState = MRT_StateCode_IG ;                     // <3>
    }

    MRT_AttrOffset const *offsets = iab->linkOffsets ;              // <4>
    for (unsigned count = iab->linkCount ; count != 0 ; count--) {
        MRT_LinkRef *link = (MRT_LinkRef *)((uintptr_t) inst + *offsets++) ;
        mrtLinkRefInit(link) ;
    }
    /*
     * Run the constructor if there is one.
     */
    if (iab->construct) {
        iab->construct(inst) ;
    }
    mrtMarkRelationship(classDesc->classRels, classDesc->relCount) ; // <5>
}
static inline MRT_AllocStatus
mrtIncrAllocCounter(
    MRT_iab *iab)
{
    /*
     * Catch any overflow
     */
    iab->alloc = (iab->alloc == INT16_MAX ? 1 : iab->alloc + 1) ;
    return iab->alloc ;
}
static void
mrtTransactionsInit(void)
{
    mrtFreeTransEntries = NULL ;
    mrtTransEntries = NULL ;
    mrtTransLevel = 0 ;

    MRT_TransEntry const *end = mrtTransStorage + MRT_TRANSACTION_SIZE ;
    for (MRT_TransEntry *iter = mrtTransStorage ;
            iter < end ; iter++) {
        mrtInsertTrans(&mrtFreeTransEntries, iter) ;
    }
}
static void
mrtAddRelToCheck(
    MRT_Relationship const *rel)
{
    MRT_TransEntry *entry = mrtRemoveTrans(&mrtFreeTransEntries) ;
    if (entry == NULL) {
        mrtFatalError(mrtTransOverflow) ;
    }

    entry->level = mrtTransLevel ;
    entry->relationship = rel ;
    mrtInsertTrans(&mrtTransEntries, entry) ;
}
static bool
mrtFindRelEntry(
    MRT_Relationship const *const rel)
{
    for (MRT_TransEntry *iter = mrtTransEntries ;
            iter != NULL && iter->level >= mrtTransLevel ;  // <1>
            iter = iter->next) {
        if (iter->relationship == rel) {
            return true ;
        }
        // N.B. no "else"
    }

    return false ;
}
static void
mrtMarkRelationship(
    MRT_Relationship const * const *rel,
    unsigned relCount)
{
    for ( ; relCount != 0 ; relCount--, rel++) {
        bool found = mrtFindRelEntry(*rel) ;
        if (!found) {
            mrtAddRelToCheck(*rel) ;
        }
    }
}
static void
mrtEndTransaction(void)
{
    for (MRT_TransEntry *rentry = mrtTransEntries ;
            rentry != NULL && rentry->level >= mrtTransLevel ;  // <1>
            rentry = mrtTransEntries) {
        if (mrtCheckRelationship(rentry->relationship)) {
            mrtDiscardTrans() ;
        } else {
            mrtDecrTransLevel() ;                               // <2>
            mrtRefIntegrityError(rentry->relationship) ;
        }
    }
    mrtDecrTransLevel() ;                                       // <3>
}
static bool
mrtCheckRelationship(
    MRT_Relationship const *rel)
{
    bool result = false ;

    switch (rel->relType) {
    case mrtSimpleAssoc: {
        MRT_SimpleAssociation const *assoc = &rel->relInfo.simpleAssociation ;
        
        MRT_Class const *const targetClass = assoc->target.classDesc ;
        mrtZeroRefCounts(targetClass) ;                                     // <1>
        mrtCountAssocRefs(&assoc->source, targetClass) ;                    // <2>
        
        result = mrtCheckRefCounts(targetClass, assoc->target.cardinality) ;
        if (!result) {
            break ;
        }
        
        MRT_Class const *const sourceClass = assoc->source.classDesc ;  // <3>
        mrtZeroRefCounts(sourceClass) ;
        mrtCountAssocRefs(&assoc->target, sourceClass) ;
        result = mrtCheckRefCounts(sourceClass, assoc->source.cardinality) ;
    }
        break ;

    case mrtClassAssoc: {
        MRT_ClassAssociation const *assoc = &rel->relInfo.classAssociation ;
        
        result = mrtCheckAssociatorRefs(&assoc->associator) ; // <1>
        if (!result) {
            break ;
        }
        /*
         * On the first side, we evaluate the references from the source class
         * to the associator class.
         */
        MRT_Class const *const assocClass = assoc->associator.classDesc ;
        MRT_Class const *const sourceClass = assoc->source.classDesc ;
        
        mrtZeroRefCounts(sourceClass) ;
        mrtCountSingularRefs(assocClass, assoc->associator.backwardOffset,
                sourceClass) ;
        
        result = mrtCheckRefCounts(sourceClass, assoc->source.cardinality) ;
        if (!result) {
            break ;
        }
        
        mrtZeroRefCounts(assocClass) ;
        mrtCountClassAssocRefs(&assoc->source, assocClass) ;
        
        result = mrtCheckRefCounts(assocClass, mrtExactlyOne) ;
        if (!result) {
            break ;
        }
        /*
        * If the first side is okay, then we can evaluate the references from
        * the target class to the associator class.
        */
        MRT_Class const *const targetClass = assoc->target.classDesc ;
        
        mrtZeroRefCounts(targetClass) ;
        mrtCountSingularRefs(assocClass, assoc->associator.forwardOffset,
                targetClass) ;
        
        result = mrtCheckRefCounts(targetClass, assoc->target.cardinality) ;
        if (!result) {
            break ;
        }
        
        mrtZeroRefCounts(assocClass) ;
        mrtCountClassAssocRefs(&assoc->target, assocClass) ;
        result = mrtCheckRefCounts(assocClass, mrtExactlyOne) ;
    }
        break ;

    case mrtRefGeneralization: {
        MRT_RefGeneralization const *gen = &rel->relInfo.refGeneralization ;
        
        mrtZeroRefCounts(gen->superclass.classDesc) ;
        
        MRT_RefSubClassRole const *subclass = gen->subclasses ;
        for (unsigned subcount = gen->subclassCount ; subcount != 0 ;
                subcount--, subclass++) {
            mrtZeroRefCounts(subclass->classDesc) ;
        }
        
        mrtCountGenRefs(gen) ;
        
        result = mrtCheckRefCounts(gen->superclass.classDesc, mrtExactlyOne) ;
        
        subclass = gen->subclasses ;
        for (unsigned subcount = gen->subclassCount ; result && subcount != 0 ;
                subcount--, subclass++) {
            result = mrtCheckRefCounts(subclass->classDesc, mrtExactlyOne) ;
        }
    }
        break ;

    case mrtUnionGeneralization: {
        MRT_UnionGeneralization const *gen = &rel->relInfo.unionGeneralization ;
        
        mrtZeroRefCounts(gen->superclass.classDesc) ;
        
        MRT_Class const *const *subclass = gen->subclasses ;
        for (unsigned subcount = gen->subclassCount ; subcount != 0 ;
                subcount--, subclass++) {
            mrtZeroRefCounts(*subclass) ;
        }
        
        mrtCountUnionRefs(gen) ;                                                // <1>
        
        result = mrtCheckRefCounts(gen->superclass.classDesc, mrtExactlyOne) ;
        
        subclass = gen->subclasses ;
        for (unsigned subcount = gen->subclassCount ; result && subcount != 0 ;
                subcount--, subclass++) {
            result = mrtCheckRefCounts(*subclass, mrtExactlyOne) ;
        }
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }

    return result ;
}
static void
mrtZeroRefCounts(
    MRT_Class const *const classDesc)
{
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, classDesc) ; mrt_InstIteratorMore(&iter) ;
            mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        instref->refCount = 0 ;
    }
}
static bool
mrtCompareAtMostOne(
    unsigned refCount)
{
    return refCount <= 1 ;
}

static bool
mrtCompareExactlyOne(
    unsigned refCount)
{
    return refCount == 1 ;
}

static bool
mrtCompareOneOrMore(
    unsigned refCount)
{
    return refCount >= 1 ;
}
static bool
mrtCheckRefCounts(
    MRT_Class const *const classDesc,
    MRT_Cardinality cardinality)
{
    if (cardinality == mrtZeroOrMore) { // <1>
        return true ;
    }

    static bool (*const compareFuncs[])(unsigned) = {
        [mrtAtMostOne] = mrtCompareAtMostOne,
        [mrtExactlyOne] = mrtCompareExactlyOne,
        [mrtZeroOrMore] = NULL, // <2>
        [mrtOneOrMore] = mrtCompareOneOrMore
    } ;

    assert(cardinality <= mrtOneOrMore) ;
    bool (*const compareCardinality)(unsigned) = compareFuncs[cardinality] ; // <3>

    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, classDesc) ; mrt_InstIteratorMore(&iter) ;
            mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        if (!compareCardinality(instref->refCount)) {
            return false ; // <4>
        }
    }

    return true ;
}
static bool
mrtCheckAssociatorRefs(
    MRT_AssociatorRole const *associator)
{
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, associator->classDesc) ;
            mrt_InstIteratorMore(&iter) ; mrt_InstIteratorNext(&iter)) {
        void *inst = mrt_InstIteratorGet(&iter) ;
        MRT_Instance *ref = *(MRT_Instance **)
                ((uintptr_t)inst + associator->forwardOffset) ;
        if (ref == NULL || ref->alloc <= 0) { // <1>
            return false ;
        }
        ref = *(MRT_Instance **)((uintptr_t)inst + associator->backwardOffset) ;
        if (ref == NULL || ref->alloc <= 0) {
            return false ;
        }
    }

    return true ;
}
static void
mrtCountAssocRefs(
    MRT_AssociationRole const *source,
    MRT_Class const *const targetClass)
{
    switch (source->storageType) {
    case mrtSingular:
        mrtCountSingularRefs(source->classDesc, source->storageOffset,
            targetClass) ;
        break ;

    case mrtArray:
        mrtCountArrayRefs(source->classDesc, source->storageOffset,
            targetClass) ;
        break ;

    case mrtLinkedList:
        mrtCountLinkedListRefs(source->classDesc, source->storageOffset,
                targetClass, source->linkOffset) ;
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
static void
mrtCountSingularRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *const targetClass)
{
    MRT_iab *targetiab = mrtGetStorageProperties(targetClass, NULL) ;

    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&srciter) ;
        MRT_Instance *targetInst =
                *(MRT_Instance **)((uintptr_t)instref + offset) ;
        if ((void *)targetInst >= targetiab->storageStart &&
                (void *)targetInst < targetiab->storageFinish &&
                targetInst->alloc > 0) { // <1>
            targetInst->refCount = mrtIncrRefCount(targetInst->refCount) ;
        }
    }
}
static void
mrtCountArrayRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *const targetClass)
{
    MRT_iab *targetiab = mrtGetStorageProperties(targetClass, NULL) ;

    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&srciter) ;
        MRT_ArrayRef *srcrefs =
                (MRT_ArrayRef *)((uintptr_t)instref + offset) ;
        MRT_Instance *const *iter = srcrefs->links ;
        for (unsigned count = srcrefs->count ; count != 0 ; count--, iter++) {
            MRT_Instance *targetInst = *iter ;
            if ((void *)targetInst >= targetiab->storageStart &&
                    (void *)targetInst < targetiab->storageFinish &&
                    targetInst->alloc > 0) {
                targetInst->refCount = mrtIncrRefCount(targetInst->refCount) ;
            }
        }
    }
}
static void
mrtCountLinkedListRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset refOffset,
    MRT_Class const *const targetClass,
    MRT_AttrOffset linkOffset)
{
    MRT_iab *targetiab = mrtGetStorageProperties(targetClass, NULL) ;
    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *srcInst = mrt_InstIteratorGet(&srciter) ;
        MRT_LinkRef *ref = (MRT_LinkRef *)((uintptr_t)srcInst + refOffset) ;
        for (MRT_LinkRef *trgIter = mrtLinkRefBegin(ref) ;
                !(trgIter == NULL || trgIter == mrtLinkRefEnd(ref)) ;   // <1>
                trgIter = trgIter->next) {
            MRT_Instance *targetInst =
                (MRT_Instance *)((uintptr_t)trgIter - linkOffset) ;     // <2>
            if ((void *)targetInst >= targetiab->storageStart &&
                    (void *)targetInst < targetiab->storageFinish &&
                    targetInst->alloc > 0) {
                targetInst->refCount = mrtIncrRefCount(targetInst->refCount) ;
            }
        }
    }
}
static void
mrtCountClassAssocRefs(
    MRT_AssociationRole const *participant,
    MRT_Class const *const assocClass)
{
    switch (participant->storageType) {
    case mrtSingular:
        mrtCountSingularRefs(participant->classDesc, participant->storageOffset,
            assocClass) ;
        break ;

    case mrtArray:
        mrtCountArrayRefs(participant->classDesc, participant->storageOffset,
            assocClass) ;
        break ;

    case mrtLinkedList:
        mrtCountLinkedListRefs(participant->classDesc,
                participant->storageOffset, assocClass,
                participant->linkOffset) ;
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
static void
mrtCountGenRefs(
    MRT_RefGeneralization const *gen)
{
    MRT_Class const *const superClass = gen->superclass.classDesc ;
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, superClass) ;                 // <1>
            mrt_InstIteratorMore(&iter) ; mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        MRT_Instance *subInst = *(MRT_Instance **)
                ((uintptr_t)instref + gen->superclass.storageOffset) ;
        if (subInst != NULL) {
            MRT_Class const *const subClass = subInst->classDesc ;

            MRT_iab *subiab = mrtGetStorageProperties(subClass, NULL) ;
            if ((void *)subInst >= subiab->storageStart &&
                    (void *)subInst < subiab->storageFinish &&
                    subInst->alloc > 0) {
                subInst->refCount = mrtIncrRefCount(subInst->refCount) ;
            }
        }
    }

    MRT_RefSubClassRole const *subclass = gen->subclasses ;
    for (unsigned subcount = gen->subclassCount ; subcount != 0 ;   // <2>
            subcount--, subclass++) {
        mrtCountSingularRefs(subclass->classDesc, subclass->storageOffset,
                gen->superclass.classDesc) ;
    }
}
static void
mrtCountUnionRefs(
    MRT_UnionGeneralization const *gen)
{
    MRT_Class const *const superClass = gen->superclass.classDesc ;
    MRT_InstIterator superIter ;
    for (mrt_InstIteratorStart(&superIter, superClass) ;
            mrt_InstIteratorMore(&superIter) ;
            mrt_InstIteratorNext(&superIter)) {
        MRT_Instance *superInst = mrt_InstIteratorGet(&superIter) ;
        MRT_Instance *subInst = (MRT_Instance *)
                ((uintptr_t)superInst + gen->superclass.storageOffset) ;

        if (subInst->alloc > 0) {
            subInst->refCount = mrtIncrRefCount(subInst->refCount) ;
        }
    }

    MRT_Class const *const *subclass = gen->subclasses ;
    for (unsigned subcount = gen->subclassCount ; subcount != 0 ;
            subcount--, subclass++) {
        MRT_InstIterator subIter ;
        for (mrt_InstIteratorStart(&subIter, *subclass) ;
                mrt_InstIteratorMore(&subIter) ;
                mrt_InstIteratorNext(&subIter)) {
            MRT_Instance *subInst = mrt_InstIteratorGet(&subIter) ;
            MRT_Instance *superInst = (MRT_Instance *)
                    ((uintptr_t)subInst - gen->superclass.storageOffset) ;

            if (superInst->alloc > 0) {
                superInst->refCount = mrtIncrRefCount(superInst->refCount) ;
            }
        }
    }
}
static void
mrtLink(
    MRT_AssociationRole const *const fromRole,
    void *const fromInst,
    void *const toInst)
{
    void *linkStorage = (void *)((uintptr_t)fromInst + fromRole->storageOffset) ;
    switch (fromRole->storageType) {
    case mrtSingular: {
        void **toLink = linkStorage ;
        *toLink = toInst ;                                          // <1>
    }
        break ;

    case mrtArray:
        // can't link array types
        mrtFatalError(mrtStaticRelationship) ;
        break ;

    case mrtLinkedList: {
        MRT_LinkRef *toLinks =
                (MRT_LinkRef *)((uintptr_t)toInst + fromRole->linkOffset) ;
        if (toLinks->next != NULL && toLinks->prev != NULL) {
            mrtLinkRefRemove(toLinks) ;                             // <2>
        }

        MRT_LinkRef *fromList = linkStorage ;                       // <3>
        mrtLinkRefInsert(toLinks, fromList) ;
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
static int
mrtFindRefGenSubclassCode(
    MRT_Class const *const subclassClass,
    MRT_RefSubClassRole const *subclasses,
    unsigned count)
{
    int subcode ;

    for (subcode = 0 ; subcode < count ; subcode++, subclasses++) {
        if (subclassClass == subclasses->classDesc) {
            return subcode ;
        }
    }

    mrtFatalError(mrtRelationshipLinkage) ;
}
static void
mrtCheckDupAssociator(
    MRT_Relationship const *rel,
    void *source,
    void *target)
{
    assert(rel != NULL) ;
    assert(rel->relType == mrtClassAssoc) ;
    assert(source != NULL) ;
    assert(target != NULL) ;

    MRT_ClassAssociation const *cassoc = &rel->relInfo.classAssociation ;
    MRT_AssociatorRole const *arole = &cassoc->associator ;
    MRT_AssociationRole const *srole = &cassoc->source ;

    switch (srole->storageType) {
    case mrtSingular: {
        void *assocInst = *(void **)((uintptr_t)source + srole->storageOffset) ;
        if (assocInst != NULL) {
            void *currentTarget =
                    *(void **)((uintptr_t)assocInst + arole->forwardOffset) ;
            if (currentTarget == target) {
                mrtDupAssociatorError(rel) ;
            }
        }
    }
        break ;
    case mrtArray:
        mrtFatalError(mrtStaticRelationship) ;
        break ;

    case mrtLinkedList: {
        MRT_LinkRef *linksList =
                (MRT_LinkRef *)((uintptr_t)source + srole->storageOffset) ;     // <1>
        for (MRT_LinkRef *assocLink = mrtLinkRefBegin(linksList) ;
                !(assocLink == NULL || assocLink == mrtLinkRefEnd(linksList)) ;
                assocLink = assocLink->next) {
            assert(srole->linkOffset != 0) ;
            void *assocInst = (void *)((uintptr_t)assocLink - srole->linkOffset) ;// <2>
            void *currentTarget = *(void **)((uintptr_t)assocInst + arole->forwardOffset) ;
            if (currentTarget == target) {
                mrtDupAssociatorError(rel) ;
                break ;
            }
        }
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
static void
mrtDeleteLinks(
    MRT_Relationship const * const *classRels,
    unsigned relCount,
    void *inst)
{
    assert(inst != NULL) ;
    /*
     * Mark the transaction since we are updating the reference pointers.
     */
    mrtMarkRelationship(classRels, relCount) ;

    MRT_Instance *instref = inst ;
    MRT_Class const *const instclass = instref->classDesc ;

    for ( ; relCount != 0 ; relCount--, classRels++) {
        struct mrtrelationship const * const rel = *classRels ;
        switch (rel->relType) {
        case mrtSimpleAssoc: {
            MRT_SimpleAssociation const *assoc = &rel->relInfo.simpleAssociation ;
            
            if (instclass == assoc->source.classDesc) {
                MRT_AssociationRole const *sourceRole = &assoc->source ;
                
                if (sourceRole->storageType == mrtSingular) {
                    void **p_targetInst = (void **)
                            ((uintptr_t)inst + sourceRole->storageOffset) ;
                    MRT_Instance *targetInst = *p_targetInst ;
                    *p_targetInst = NULL ; // <1>
                
                    MRT_AssociationRole const *targetRole = &assoc->target ;
                    if (targetInst != NULL && targetInst->alloc > 0 &&
                            targetInst->classDesc == targetRole->classDesc) { // <2>
                        mrtUnlinkBackref(targetRole, inst, targetInst) ;
                    }
                } else {
                    // Simple forward association links are always singular.
                    mrtFatalError(mrtRelationshipLinkage) ;
                }
            } else if (instclass == assoc->target.classDesc) {
                MRT_AssociationRole const *targetRole = &assoc->target ;
                
                void *linkStorage = (void *)((uintptr_t)inst + targetRole->storageOffset) ;
                switch (targetRole->storageType) {
                case mrtSingular: {
                    void **p_sourceInst = linkStorage ;
                    *p_sourceInst = NULL ;                                  // <1>
                }
                    break ;
                
                case mrtLinkedList: {                                       // <2>
                    MRT_LinkRef *sourceList = linkStorage ;                 // <3>
                    assert(sourceList->next != NULL && sourceList->prev != NULL) ;
                    for (MRT_LinkRef *iter = mrtLinkRefBegin(sourceList) ;
                            iter != mrtLinkRefEnd(sourceList) ; ) {
                        MRT_LinkRef *sourceInst = iter ;
                        iter = iter->next ;                                 // <4>
                        mrtLinkRefRemove(sourceInst) ;
                    }
                }
                    break ;
                
                case mrtArray: {
                    MRT_ArrayRef * alinks = linkStorage ;                   // <5>
                    if (alinks->links != NULL) {
                        // Can't unlink array type linkages.
                        mrtFatalError(mrtStaticRelationship) ;
                    }
                }
                    break ;
                
                default:
                    mrtFatalError(mrtRelationshipLinkage) ;
                    break ;
                }
            } else {
                mrtFatalError(mrtRelationshipLinkage) ;
            }
        }
            break ;

        case mrtClassAssoc: {
            MRT_ClassAssociation const *assoc = &rel->relInfo.classAssociation ;
            
            if (instclass == assoc->associator.classDesc) {
                MRT_AssociatorRole const *assocRole = &assoc->associator ;
                MRT_AssociationRole const *sourceRole = &assoc->source ;
                MRT_AssociationRole const *targetRole = &assoc->target ;
            
                void **p_targetInst = (void **)
                        ((uintptr_t)inst + assocRole->forwardOffset) ; // <1>
                MRT_Instance *targetInst = *p_targetInst ;
                *p_targetInst = NULL ;
                if (targetInst != NULL && targetInst->alloc > 0 &&
                        targetInst->classDesc == targetRole->classDesc) {
                    mrtUnlinkBackref(targetRole, inst, targetInst) ;
                }
            
                void **p_sourceInst = (void **)
                        ((uintptr_t)inst + assocRole->backwardOffset) ;
                MRT_Instance *sourceInst = *p_sourceInst ;
                *p_sourceInst = NULL ;
                if (sourceInst != NULL && sourceInst->alloc > 0) {
                    mrtUnlinkBackref(sourceRole, inst, sourceInst) ;
                }
            }
        }
            break ;

        case mrtRefGeneralization: {
            MRT_RefGeneralization const *gen = &rel->relInfo.refGeneralization ;
            
            if (instclass != gen->superclass.classDesc) {
                // Instance is a subclass instance
                int subclassCode = mrtFindRefGenSubclassCode(instclass, gen->subclasses,
                        gen->subclassCount) ;
                // Obtain the pointer to the superclass instance.
                void **p_superInst = (void **)
                        ((uintptr_t)inst + gen->subclasses[subclassCode].storageOffset) ;
                MRT_Instance *superInst = *p_superInst ;
                *p_superInst = NULL ;
                // NULL out the pointer in the superclass instance pointing to the subclass
                // instance. Watch for a NULL reference to the superclass instances.
                // This can happen if the subclass was simply created on it's on.
                if (superInst != NULL && superInst->alloc > 0) {
                    void **p_subInst = (void **)
                            ((uintptr_t)superInst + gen->superclass.storageOffset) ;
                    *p_subInst = NULL ;
                }
            } else {
                // Instance is a superclass instance
                // NULL out the pointer to the subclass instance only,
                // i.e. only the back reference.
                void **p_subInst = (void **)((uintptr_t)inst + gen->superclass.storageOffset) ;
                *p_subInst = NULL ;
            }
        }
            break ;

        case mrtUnionGeneralization:
            // For a union generalization, there are no pointer links.
            break ;

        default:
            mrtFatalError(mrtRelationshipLinkage) ;
            break ;
        }
    }
}
static void
mrtUnlinkBackref(
    MRT_AssociationRole const *const targetRole,
    void *const source,
    void *const target)
{
    assert(source != NULL) ;
    assert(target != NULL) ;
    assert(targetRole != NULL) ;

    void *linkStorage =
            (void *)((uintptr_t)target + targetRole->storageOffset) ;
    switch (targetRole->storageType) {
    case mrtSingular: {
        void **p_sourceInst = linkStorage ;                             // <1>
        if (*p_sourceInst == source) {                                  // <2>
            *p_sourceInst = NULL ;
        }
    }
        break ;

    case mrtLinkedList: {
        MRT_LinkRef *srcblinks = (MRT_LinkRef *)
                ((uintptr_t)source + targetRole->linkOffset) ;          // <3>
        if (srcblinks->next != NULL && srcblinks->prev != NULL) {       // <4>
            MRT_LinkRef *targetList = linkStorage ;
            for (MRT_LinkRef *targetlink = mrtLinkRefBegin(targetList) ;
                    targetlink != mrtLinkRefEnd(targetList) ;
                    targetlink = targetlink->next) {
                if (targetlink == srcblinks) {
                    mrtLinkRefRemove(srcblinks) ;
                    break ;                                             // <5>
                }
            }
        }
    }
        break ;

    case mrtArray: {
        MRT_ArrayRef *alinks = linkStorage ;
        if (alinks->links != NULL) {                                    // <6>
            // Can't unlink array type linkages.
            mrtFatalError(mrtStaticRelationship) ;
        }
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
static int
mrtFindUnionGenSubclassCode(
    MRT_Class const *const subclassClass,
    MRT_Class const *const *subclasses,
    unsigned count)
{
    int subcode ;

    for (subcode = 0 ; subcode < count ; subcode++, subclasses++) {
        if (subclassClass == *subclasses) {
            return subcode ;
        }
    }

    mrtFatalError(mrtRelationshipLinkage) ;
}
static void
mrtECBPoolInit(void)
{
    assert(MRT_EVENT_POOL_SIZE >= 1) ;
    /*
     * Initialize the queue terminus structures.
     */
    eventQueue.next = eventQueue.prev = (MRT_ecb *)&eventQueue ;
    tocEventQueue.next = tocEventQueue.prev = (MRT_ecb *)&tocEventQueue ;
    delayedEventQueue.next = delayedEventQueue.prev = (MRT_ecb *)&delayedEventQueue ;
    freeEventQueue.next = freeEventQueue.prev = (MRT_ecb *)&freeEventQueue ;
    /*
     * Place all the event control blocks on the free event
     * queue.  Allocation occurs from there.
     */
    for (MRT_ecb *ecb = mrtECBPool ;
            ecb < mrtECBPool + MRT_EVENT_POOL_SIZE ; ecb++) {
        mrtEventQueueInsert(ecb, mrtEventQueueEnd(&freeEventQueue)) ;
    }
}
static inline MRT_ecb *
mrtECBalloc(void)
{
    if (mrtEventQueueEmpty(&freeEventQueue)) {
        mrtFatalError(mrtNoECB) ;
    }

    MRT_ecb *ecb = freeEventQueue.next ;
    mrtEventQueueRemove(ecb) ;
    memset(ecb, 0, sizeof(*ecb)) ; // <1>
    return ecb ;
}
static inline void
mrtECBfree(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;

    mrtEventQueueInsert(ecb, mrtEventQueueEnd(&freeEventQueue)) ;
}
static MRT_ecb *
mrtFindEvent(
    MRT_EventQueue *queue,
    MRT_Instance *sourceInst,
    MRT_Instance *targetInst,
    MRT_EventCode event)
{
    /*
     * Simple iteration through the list of events in the queue.
     */
    for (MRT_ecb *iter = mrtEventQueueBegin(queue) ;
            iter != mrtEventQueueEnd(queue) ;
            iter = iter->next) {
        if (iter->sourceInst == sourceInst && iter->targetInst == targetInst &&
                iter->eventNumber == event) {
            return iter ;
        }
    }
    return NULL ;
}
static void
mrtInsertDelayedEvent(
    MRT_ecb *ecb)
{
    MRT_ecb *iter = mrtEventQueueBegin(&delayedEventQueue) ;
    MRT_ecb *const end = mrtEventQueueEnd(&delayedEventQueue) ;
    for ( ; iter != end ; iter = iter->next) {
        if (ecb->delay < iter->delay) {                         // <1>
            iter->delay -= ecb->delay ;                         // <2>
            break ;
        } else {
            ecb->delay -= iter->delay ;
        }
    }
    mrtEventQueueInsert(ecb, iter) ;
}
static void
mrtRemoveDelayedEvent(
    MRT_Instance *sourceInst,
    MRT_Instance *targetInst,
    MRT_EventCode eventNumber)
{
    MRT_ecb *found = mrtFindEvent(&delayedEventQueue, sourceInst,
            targetInst, eventNumber) ;                                  // <1>
    if (found != NULL) {
        if (found->next != mrtEventQueueEnd(&delayedEventQueue)) {      // <2>
            found->next->delay += found->delay ;
        }
    } else {
        found = mrtFindEvent(&tocEventQueue, sourceInst, targetInst,
                eventNumber) ;
    }
    if (found != NULL) {                                                // <3>
        mrtEventQueueRemove(found) ;
        mrtECBfree(found) ;
    }
}
static void
mrtStartDelayedQueueTiming(void)
{
    if (!mrtEventQueueEmpty(&delayedEventQueue)) {
        MRT_ecb *ecb = mrtEventQueueBegin(&delayedEventQueue) ;
        assert(ecb->delay != 0) ;
        mrtSysTimerStart(ecb->delay) ;
        ecb->delay = 0 ;
    }
}
static void
mrtStopDelayedQueueTiming(void)
{
    /*
     * Avoid the whole thing if there is nothing in the delayed event queue.
     */
    if (!mrtEventQueueEmpty(&delayedEventQueue)) {
        /*
         * Stop the timer, obtaining the residual time.
         */
        MRT_DelayTime remain = mrtSysTimerStop() ;
        MRT_ecb *ecb = mrtEventQueueBegin(&delayedEventQueue) ;
        assert(ecb->delay == 0) ;
        ecb->delay = remain ;
    }
}
static void
mrtExpireDelayedEvent(
    MRT_SyncParams const *params)
{
    MRT_DelayedEventParams *dep = (MRT_DelayedEventParams *)params ;
    mrtEventQueueInsert(dep->ecb, mrtEventQueueEnd(&tocEventQueue)) ;
}
static void
mrtExpirePeriodicEvent(
    MRT_SyncParams const *params)
{
    MRT_PeriodicEventParams *pep = (MRT_PeriodicEventParams *)params ;
    MRT_ecb *ecb = mrtECBalloc() ;
    ecb->eventNumber = pep->eventNumber ;
    ecb->alloc = pep->alloc ;
    ecb->targetInst = pep->targetInst ;
    ecb->sourceInst = pep->sourceInst ;
    mrtEventQueueInsert(ecb, mrtEventQueueEnd(&tocEventQueue)) ;
}
static bool
mrtDispatchEventFromQueue(
    MRT_EventQueue *queue)
{
    static MRT_ecb *ecb = NULL ;            // <1>

    if (ecb != NULL) {                      // <2>
        mrtECBfree(ecb) ;
        ecb = NULL ;
            #if (defined(__ARM_ARCH) &&  __ARM_ARCH == 7)
        __set_BASEPRI(0) ;
            #endif /* __ARM_ARCH */
    }

    if (!mrtEventQueueEmpty(queue)) {
        ecb = queue->next ;
        mrtEventQueueRemove(ecb) ;
        mrtDispatchEvent(ecb) ;             // <3>
        mrtECBfree(ecb) ;
        ecb = NULL ;

        return true ;
    }

    return false ;
}
static void
mrtDispatchEvent(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;

    MRT_Instance *targetInst = ecb->targetInst ;
    assert(targetInst != NULL) ;

    MRT_Class const *const classDesc = targetInst->classDesc ;
    assert(classDesc != NULL) ;

    MRT_edb const *const edb = classDesc->edb ;
    if (edb == NULL) {
        mrtDispatchPolymorphicEvent(ecb) ;                          // <1>
    } else {
        if (ecb->eventNumber < edb->eventCount) {                   // <2>
            if (targetInst->currentState == edb->creationState) {   // <3>
                mrtDispatchCreationEvent(ecb) ;
            } else {
                mrtDispatchTransitionEvent(ecb) ;
            }
        } else {
            assert(classDesc->pdb != NULL) ;
            assert(ecb->eventNumber - edb->eventCount <
                    classDesc->pdb->eventCount) ;
            mrtDispatchPolymorphicEvent(ecb) ;                      // <4>
        }
    }
}
static void
mrtDispatchTransitionEvent(
    MRT_ecb *ecb)
{
    MRT_Instance *const targetInst = ecb->targetInst ;
    MRT_edb const *const edb = targetInst->classDesc->edb ;
    assert(edb != NULL) ;
    assert(edb->stateCount > targetInst->currentState) ;
    assert(edb->eventCount > ecb->eventNumber) ;
    /*
     * Check for the "event-in-flight" error. This occurs when an instance is
     * deleted while there is an event for that instance in the event queue.
     * For this architecture, such occurrences are considered as run-time
     * detected analysis errors.
     */
    if (targetInst->alloc != ecb->alloc) {
        mrtEventInFlightError(ecb->sourceInst, ecb->eventNumber, targetInst) ;
    }
    /*
     * Fetch the new state from the transition table.
     */
    MRT_StateCode newState = *(edb->transitionTable +
            targetInst->currentState * edb->eventCount + ecb->eventNumber) ;

#       ifndef MRT_NO_TRACE
    /*
     * Trace the transition.
     */
    mrtTraceTransitionEvent(ecb->eventNumber, ecb->sourceInst,
            ecb->targetInst, targetInst->currentState, newState) ;
#       endif /* MRT_NO_TRACE */

    /*
     * Check for a can't happen transition.
     */
    if (newState == MRT_StateCode_CH) {
        mrtCantHappenError(targetInst, targetInst->currentState,
                ecb->eventNumber) ;
    } else if (newState != MRT_StateCode_IG) {
        assert(newState < edb->stateCount) ;
        /*
         * We update the current state to reflect the transition before
         * executing the activity for the state.
         */
        targetInst->currentState = newState ;
        /*
         * Invoke the state activity if there is one.
         */
        MRT_PtrActivityFunction activity = edb->activityTable[newState] ;
        if (activity) {
            activity(targetInst, &ecb->eventParameters) ;
        }
        /*
         * Check if we have entered a final state. If so, the instance is
         * deleted.
         */
        if (edb->finalStates && edb->finalStates[newState]) {
            mrt_DeleteInstance(targetInst) ; // <1>
        }
    }
}
static void
mrtDispatchPolymorphicEvent(
    MRT_ecb *ecb)
{
    MRT_Instance *superInst = ecb->targetInst ;
    MRT_Class const *const superClassDesc = superInst->classDesc ;
    MRT_pdb const *const pdb = superClassDesc->pdb ;
    assert(pdb != NULL) ;
    assert(pdb->genCount > 0) ;
    /*
     * Check for the "event-in-flight" error. We must make sure the
     * superclass instance still exists.
     */
    if (superInst->alloc != ecb->alloc) {
        mrtEventInFlightError(ecb->sourceInst, ecb->eventNumber, superInst) ;
    }
    /*
     * Compute the base offset for polymorphic event numbering.  This base
     * offset will be used to turn the polymorphic event number into an array
     * index.
     */
    MRT_edb const *const edb = superClassDesc->edb ;
    MRT_EventCode eventOffset = edb == NULL ? 0 : edb->eventCount ;
    assert(ecb->eventNumber >= eventOffset) ;
    assert(ecb->eventNumber - eventOffset < pdb->eventCount) ;
    /*
     * Save the original event number.  We intend to reuse the same ECB for each
     * event we dispatch and will need this and the super class instance pointer
     * values should there be more than one generalization associated with this
     * superclass.
     */
    MRT_EventCode origEvent = ecb->eventNumber ;
    /*
     * For each generalization that originates at the superclass an event is
     * generated down that generalization to one of the subclasss.
     */
    MRT_gdb const *gdb = pdb->genDispatch ;
    for (unsigned gnum = 0 ; gnum < pdb->genCount ; gdb++, gnum++) {
        MRT_Relationship const *const rel = gdb->relship ;
        MRT_Instance *subInst ;
        int subclassCode ;

        /*
         * Find the target instance reference and the class of the target
         * instance. How we do this depends upon how the generalization is
         * stored in the superclass instance.
         */
        if (rel->relType == mrtRefGeneralization) {
            /*
             * When the generalization is implemented via a pointer, we need an
             * extra level of indirection to fetch the address of the subclass.
             */
            MRT_RefGeneralization const *gen = &rel->relInfo.refGeneralization ;
            subInst = *(MRT_Instance **)
                    ((uintptr_t)superInst + gen->superclass.storageOffset) ;
            assert(subInst != NULL) ;
            /*
             * We must also guard against the possibility that the subclass was
             * unrelated from the superclass before the polymorphic event was
             * dispatched.
             */
            if (subInst == NULL) {
                mrtFatalError(mrtRelationshipLinkage) ;
            }
            assert(subInst->classDesc != NULL) ;
            subclassCode = mrtFindRefGenSubclassCode(subInst->classDesc,
                    gen->subclasses, gen->subclassCount) ;
        } else if (rel->relType == mrtUnionGeneralization) {
            /*
             * When the generalization is implemented by a union, we need only
             * point to the address of the subclass since it is contained
             * within the superclass.
             */
            MRT_UnionGeneralization const *gen =
                    &rel->relInfo.unionGeneralization ;
            subInst = (MRT_Instance *)
                    ((uintptr_t)superInst + gen->superclass.storageOffset) ;
            assert(subInst->classDesc != NULL) ;
            subclassCode = mrtFindUnionGenSubclassCode(subInst->classDesc,
                    gen->subclasses, gen->subclassCount) ;
        } else {
            mrtFatalError(mrtRelationshipLinkage) ;
        }
        /*
         * Check that our subclass instance is indeed allocated and usable.  We
         * are trying to guard against the possiblity that the subclass
         * instance was deleted before the polymorphic event was delivered.
         */
        assert(subInst->alloc > 0) ;
        if (subInst->alloc <= 0) {
            mrtEventInFlightError(ecb->sourceInst, origEvent, subInst) ;
        }
        /*
         * Update the target and allocation status in the ECB to match
         * that of the subclass instance, which is where the event
         * is now directed.
         */
        ecb->targetInst = subInst ;
        ecb->alloc = subInst->alloc ;
        /*
         * Fetch the event number for the subclass from the polymorphic
         * mapping.  The class of the subclass related to the superclass
         * determines the mapped value for the event.  Note we must subtract
         * off any offset in the event encoding that was consumed by the
         * transition events.
         */
        ecb->eventNumber = *(gdb->eventMap + subclassCode * pdb->eventCount +
                origEvent - eventOffset) ;

#           ifndef MRT_NO_TRACE
        /*
         * Trace the transition.
         */
        mrtTracePolymorphicEvent(origEvent, ecb->sourceInst, superInst,
                subclassCode, gnum, ecb->eventNumber) ;
#           endif /* MRT_NO_TRACE */

        mrtDispatchEvent(ecb) ; // <1>
    }
}
static void
mrtDispatchCreationEvent(
    MRT_ecb *ecb)
{
#       ifndef MRT_NO_TRACE
    /*
     * Trace the transition.
     */
    mrtTraceCreationEvent(ecb->eventNumber, ecb->sourceInst, ecb->targetInst,
            ecb->targetInst->classDesc) ;
#       endif /* MRT_NO_TRACE */

    assert(ecb->alloc == ecb->targetInst->alloc) ;
    assert(ecb->alloc < 0) ;
    assert(ecb->targetInst->alloc < 0) ;
    assert(ecb->targetInst->currentState ==
        ecb->targetInst->classDesc->edb->creationState) ;

    ecb->alloc = ecb->targetInst->alloc = -ecb->targetInst->alloc ; // <1>
    mrtDispatchTransitionEvent(ecb) ;
}
static int
mrtPortalGetInstRef(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_Instance **ref)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const pclass = portal->classes + classId ;
    if (instId >= pclass->instCount) {
        return MICCA_PORTAL_NO_INST ;
    }

    MRT_Instance *instance = mrtIndexToInstance(pclass, instId) ;
    if (instance == NULL) {
        return MICCA_PORTAL_UNALLOC ;
    }

    if (instance->classDesc != pclass) {
        return MICCA_PORTAL_NO_INST ;                           // <1>
    }

    if (ref) {
        *ref = instance ;
    }
    return 0 ;
}
static int
mrtPortalNewECB(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize,
    MRT_ecb **ecbRef)
{
    assert(ecbRef != NULL) ;

    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const classDesc = instref->classDesc ;
    assert(classDesc != NULL) ;
    if (classDesc->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= classDesc->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    if (paramSize > sizeof(MRT_EventParams)) {
        return MICCA_PORTAL_SIZE_ERROR ;
    }

    MRT_ecb *ecb = mrt_NewEvent(eventNumber, instref, NULL) ;
    if (eventParameters != NULL) {
        memcpy(ecb->eventParameters, eventParameters, paramSize) ;
    }
    *ecbRef = ecb ;
    return 0 ;
}
static int
mrtPortalGetAssignerRef(
    MRT_DomainPortal const *const portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId,
    MRT_Instance **ref)
{
    assert(portal != NULL) ;

    if (assignerId >= portal->assignerCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const asnClass = portal->assigners + assignerId ;
    if (instId >= asnClass->instCount) {
        return MICCA_PORTAL_NO_INST ;
    }

    MRT_iab *iab = asnClass->iab ;
    assert(iab != NULL) ;
    MRT_Instance *instref = (MRT_Instance *)
            ((uintptr_t)iab->storageStart + iab->instanceSize * instId) ;
    if (instref->alloc <= 0) {
        return MICCA_PORTAL_UNALLOC ;
    }

    if (ref) {
        *ref = instref ;
    }
    return 0 ;
}
static inline bool
mrtSyncQueueEmpty(void)
{
    return mrtSyncQueue.head == mrtSyncQueue.tail ;
}
static MRT_SyncParams *
mrtSyncQueuePut(
    MRT_SyncFunc f)
{
    MRT_SyncParams *params = NULL ;

    mrtBeginCriticalSection() ;

    MRT_SyncBlock *tail = mrtSyncQueue.tail ;                        // <1>
    MRT_SyncBlock *newTail = tail + 1 ;
    if (newTail >= mrtSyncQueueStorage + COUNTOF(mrtSyncQueueStorage)) {
        newTail = mrtSyncQueueStorage ;
    }

    if (newTail != mrtSyncQueue.head) {                              // <2>
        mrtSyncQueue.tail = newTail ;
        tail->function = f ;
        params = &tail->params ;
    }

    mrtEndCriticalSection() ;

    return params ;
}
static MRT_SyncBlock *
mrtSyncQueueGet(void)
{
    MRT_SyncBlock *block = NULL ;

    mrtBeginCriticalSection() ;

    if (!mrtSyncQueueEmpty()) {
        block = mrtSyncQueue.head ;                                     // <1>
        if (++mrtSyncQueue.head >=
                mrtSyncQueueStorage + COUNTOF(mrtSyncQueueStorage)) {   // <2>
            mrtSyncQueue.head = mrtSyncQueueStorage ;
        }
    }

    mrtEndCriticalSection() ;

    return block ;
}
static inline bool
mrtInvokeOneSyncFunction(void)
{
    bool didInvoke = false ;
    do {
        MRT_SyncBlock const *block = mrtSyncQueueGet() ;

        if (block == NULL) {
            break ;                             // <1>
        }
        assert(block->function != NULL) ;       // <2>
        if (block->function != NULL) {
            block->function(&block->params) ;
            didInvoke = true ;
        }
    } while (!didInvoke) ;

    return didInvoke ;
}
static void
mrtDefaultFatalErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list ap)
{
#       ifndef MRT_NO_STDIO
    vfprintf(stderr, fmt, ap) ;
#       endif /* MRT_NO_STDIO */
}
noreturn static void
mrtFatalError(
    MRT_ErrorCode errNum,
    ...)
{
    va_list ap ;

    assert(mrtErrHandler != NULL) ;
    assert(errNum < COUNTOF(mrtErrorMsgs)) ;

    va_start(ap, errNum) ;
    mrtErrHandler(errNum, mrtErrorMsgs[errNum], ap) ;
    va_end(ap) ;
    /*
     *  If the handler does return, we insist that all errors
     *  are fatal. So we abort().
     */
    abort() ;
}

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
MRT_TraceHandler
mrt_RegisterTraceHandler(
    MRT_TraceHandler handler)
{
    MRT_TraceHandler oldhandler = mrtTraceHandler ;
    mrtTraceHandler = handler ;
    return oldhandler ;
}
#   endif /* MRT_NO_TRACE */

void
mrt_RegisterSignal(
    int sigNum,
    MRT_SignalFunc func)
{
    assert(sigNum > 0) ;

    struct sigaction action ;
    if (func) {
        action.sa_handler = func ;
        sigaddset(&mrtSigMask, sigNum) ;
    } else {
        action.sa_handler = SIG_DFL ;
        sigdelset(&mrtSigMask, sigNum) ;
    }
    sigfillset(&action.sa_mask) ;
    action.sa_flags = 0 ;

    int sigresult = sigaction(sigNum, &action, NULL) ;
    if (sigresult != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
MRT_SyncParams *
mrt_SyncRequest(
    MRT_SyncFunc f)
{
    MRT_SyncParams *params = mrtSyncQueuePut(f) ;
    if (params == NULL) {
        mrtFatalError(mrtSyncOverflow) ;
    }
    return params ;
}
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc f)
{
    return mrtSyncQueuePut(f) ;
}
void
mrt_RegisterFDService(
    int fd,
    MRT_FDServiceFunc readService,
    MRT_FDServiceFunc writeService,
    MRT_FDServiceFunc exceptService)
{
    assert(fd >= 0 && fd < FD_SETSIZE) ;
    MRT_FDServiceMap *fds = mrtFDServicePool + fd ;

    fds->read = readService ;
    if (readService) {
        FD_SET(fd, &mrtReadFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtReadFDS) ;
    }

    fds->write = writeService ;
    if (writeService) {
        FD_SET(fd, &mrtWriteFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtWriteFDS) ;
    }

    fds->except = exceptService ;
    if (exceptService) {
        FD_SET(fd, &mrtExceptFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtExceptFDS) ;
    }

    if (fds->read == NULL && fds->write == NULL && fds-> except == NULL) {
        if (fds->set && fd >= mrtMaxFD) {
            --mrtMaxFD ;
        }
        fds->set = false ;
    } else if (fds->set && fd > mrtMaxFD) {
        mrtMaxFD = fd ;
    }
}
void
mrt_UnregisterFDService(
    int fd,
    bool rmRead,
    bool rmWrite,
    bool rmExcept)
{
    assert(fd >= 0 && fd < FD_SETSIZE) ;
    MRT_FDServiceMap *fds = mrtFDServicePool + fd ;

    if (rmRead) {
        fds->read = NULL ;
        FD_CLR(fd, &mrtReadFDS) ;
    }

    if (rmWrite) {
        fds->write = NULL ;
        FD_CLR(fd, &mrtWriteFDS) ;
    }

    if (rmExcept) {
        fds->except = NULL ;
        FD_CLR(fd, &mrtExceptFDS) ;
    }

    if (fds->read == NULL && fds->write == NULL && fds-> except == NULL &&
            fd >= mrtMaxFD) {
        mrtMaxFD = fd - 1 ;
    }
}
void
mrt_Initialize(void)
{
    mrtPlatformInit() ;
    mrtECBPoolInit() ;
    mrtTransactionsInit() ;
    mrtInitSysTimer() ;
    mrtInitFDService() ;
    setvbuf(stdout, NULL, _IOLBF, 0) ; // <1>
#       if !(defined(MRT_NO_TRACE) || defined(MRT_NO_STDIO))
    mrt_RegisterTraceHandler(mrtPrintTraceInfo) ; // <2>
#       endif /* !defined(MRT_NO_TRACE) && !defined(MRT_NO_STDIO) */
}
void
mrt_EventLoop(void)
{
    mrtExitEventLoop = false ;

    for (;;) {
        bool didtoc = mrtRunThreadOfControl() ; // <1>

        if (mrtExitEventLoop) {                 // <2>
            break ;
        } else if (!didtoc) {                   // <3>
            mrtWait() ;
        }
        /*
         * Else we ran a thread of control and weren't requested to exit
         * the event loop.
         */
    }
}
bool
mrt_SyncToEventLoop(void)
{
    bool exitControl = mrtExitEventLoop ;
    mrtExitEventLoop = true ;
    return exitControl ;
}
bool
mrt_DispatchThreadOfControl(
    bool wait)
{
    bool rantoc = mrtRunThreadOfControl() ;
    if (!rantoc && wait) {
        mrtWait() ;
        rantoc = mrtRunThreadOfControl() ;
    }
    return rantoc ;
}
bool
mrt_DispatchSingleEvent(void)
{
    bool didOne ;

    if (mrtEventQueueEmpty(&eventQueue)) {
        didOne = mrtProcessTOCEvent() ;
        if (mrtEventQueueEmpty(&eventQueue)) {              // <1>
            mrtEndTransaction() ;
        }
    } else {
        didOne = mrtDispatchEventFromQueue(&eventQueue) ;
        if (mrtEventQueueEmpty(&eventQueue)) {
            mrtEndTransaction() ;
        }
    }

    return didOne ;
}
MRT_InstId
mrt_InstanceIndex(
    void const *instance)
{
    MRT_Instance const *instref = instance ;
    assert(instref != NULL) ;
    assert(instref->classDesc != NULL) ;

    MRT_AttrOffset offset ;
    MRT_iab *iab = mrtGetStorageProperties(instref->classDesc, &offset) ;
    assert(instance >= iab->storageStart && instance < iab->storageFinish) ;
    MRT_InstId index = (((uintptr_t)instance - offset) -
            (uintptr_t)iab->storageStart) / iab->instanceSize ;     // <1>
    return index ;
}
void *
mrt_InstanceReference(
    MRT_Class const *const classDesc,
    MRT_InstId index)
{
    void *instance = mrtIndexToInstance(classDesc, index) ;     // <1>
    if (instance == NULL) {
        mrtUnallocSlotError(index, classDesc) ;
    }

    return instance ;
}
void *
mrt_CreateInstance(
    MRT_Class const *const classDesc,
    MRT_StateCode initialState)
{
    assert(classDesc != NULL) ;

    /*
     * Search for an empty slot in the pool.
     */
    MRT_iab *iab = classDesc->iab ;
    MRT_Instance *inst = mrtFindInstSlot(iab) ;
    if (inst == NULL) {
        mrtNoInstSlotError(classDesc) ;
    }
    /*
     * Record where we left off for the next allocation attempt.
     */
    iab->storageLast = inst ;
    /*
     * Initialize the memory for the instance.
     */
    mrtInitializeInstance(inst, classDesc, initialState) ;

    return inst ;
}
void *
mrt_CreateUnionInstance(
    MRT_Class const *const classDesc,
    MRT_StateCode initialState,
    MRT_Relationship const *const genRel,
    void *super)
{
    assert(classDesc != NULL) ;
    assert(genRel != NULL) ;
    assert(super != NULL) ;
    assert(genRel->relType == mrtUnionGeneralization) ;

    if (genRel->relType != mrtUnionGeneralization) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }
    MRT_UnionGeneralization const *const gen =
            &genRel->relInfo.unionGeneralization ;
    /*
     * Verify that the new subclass is actually a subclass of the
     * generalization.
     */
    mrtFindUnionGenSubclassCode(classDesc, gen->subclasses,
            gen->subclassCount) ;
    /*
     * Verify the super class instance is truly of the super class.
     */
    MRT_Instance *superInst = super ;
    if (superInst->classDesc != gen->superclass.classDesc) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }
    /*
     * Compute the location of the union subclass instance
     * within the superclass instance.
     */
    void *inst = (void *)((uintptr_t)super + gen->superclass.storageOffset) ;
    /*
     * Initialize the memory for the instance.
     */
    mrtInitializeInstance(inst, classDesc, initialState) ;

    return inst ;
}
void
mrt_DeleteInstance(
    void *instref)
{
    MRT_Instance *inst = instref ;
    assert(inst != NULL) ;
    if (inst == NULL || inst->alloc <= 0) {         // <1>
        return ;
    }
    MRT_Class const *const classDesc = inst->classDesc ;
    assert(classDesc != NULL) ;
    MRT_iab *iab = classDesc->iab ;
    assert(iab != NULL) ;
    /*
     * Unlink the instance from its relationships.
     */
    mrtDeleteLinks(classDesc->classRels, classDesc->relCount, instref) ;
    /*
     * Run the destructor, if there is one.
     */
    if (iab->destruct) {
        iab->destruct(inst) ;
    }
    /*
     * Mark the slot as free.
     */
    inst->alloc = 0 ;
}
void
mrt_InstIteratorStart(
    MRT_InstIterator *iter,
    MRT_Class const *const classDesc)
{
    assert(iter != NULL) ;
    assert(classDesc != NULL) ;
    iter->classDesc = classDesc ;

    MRT_AttrOffset instanceOffset ;
    MRT_iab *iab = mrtGetStorageProperties(classDesc, &instanceOffset) ;
    assert(iab != NULL) ;

    iter->iab = iab ;
    iter->instance = (void *)((uintptr_t)iab->storageStart + instanceOffset) ;
    MRT_Instance *instref = iter->instance ;
    if (instref->alloc <= 0 || instref->classDesc != iter->classDesc) { // <1>
        mrt_InstIteratorNext(iter) ;
    }
    return ;
}
bool
mrt_InstIteratorMore(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance < iter->iab->storageFinish ;
}
void *
mrt_InstIteratorGet(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance ;
}
void
mrt_InstIteratorNext(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;

    MRT_iab *iab = iter->iab ;
    assert(iab != NULL) ;

    while (iter->instance < iab->storageFinish) { // <1>
        iter->instance = (void *)((uintptr_t)iter->instance + iab->instanceSize) ;
        MRT_Instance *instref = iter->instance ;
        if (instref->alloc > 0 && instref->classDesc == iter->classDesc) {// <2>
            break ;
        }
    }
    return ;
}
void
mrt_InstSetInitialize(
    MRT_InstSet *set,
    MRT_Class const *const classDesc)
{
    assert(classDesc != NULL) ;
    set->classDesc = classDesc ;
    memset(set->instvector, 0, sizeof(set->instvector)) ;
}
void
mrt_InstSetAddInstance(
    MRT_InstSet *set,
    void *instance)
{
    assert(instance != NULL) ;
    if (instance == NULL) {
        return ;
    }
    MRT_Instance *instref = instance ;

    assert(instref->classDesc == set->classDesc) ;
    if (instref->classDesc != set->classDesc) {         // <1>
        return ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCE_SET_SIZE) ;
    if (instid >= MRT_INSTANCE_SET_SIZE) {
        mrtFatalError(mrtInstSetOverflow, instid) ;
    }
    set->instvector[instid / MRT_SETWORD_BITS] |=
            (1 << (instid % MRT_SETWORD_BITS)) ;        // <2>
}
void
mrt_InstSetRemoveInstance(
    MRT_InstSet *set,
    void *instance)
{
    assert(instance != NULL) ;
    if (instance == NULL) {
        return ;
    }
    MRT_Instance *instref = instance ;

    assert(instref->classDesc == set->classDesc) ;
    if (instref->classDesc != set->classDesc) {
        return ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCE_SET_SIZE) ;
    if (instid >= MRT_INSTANCE_SET_SIZE) {
        mrtFatalError(mrtInstSetOverflow, instid) ;
    }
    set->instvector[instid / MRT_SETWORD_BITS] &=
            ~(1 << (instid % MRT_SETWORD_BITS)) ; // <1>
}
bool
mrt_InstSetMember(
    MRT_InstSet *set,
    void *instance)
{
    assert(instance != NULL) ;
    if (instance == NULL) {
        return false ;
    }
    MRT_Instance *instref = instance ;

    assert(instref->classDesc == set->classDesc) ;
    if (instref->classDesc != set->classDesc) {
        return false ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCE_SET_SIZE) ;
    if (instid >= MRT_INSTANCE_SET_SIZE) {
        mrtFatalError(mrtInstSetOverflow, instid) ;
    }
    MRT_SetWord w = set->instvector[instid / MRT_SETWORD_BITS] ;
    MRT_SetWord mask = (1 << (instid % MRT_SETWORD_BITS)) ;

    return (w & mask) != 0 ;
}
bool
mrt_InstSetEmpty(
    MRT_InstSet *set)
{
    assert(set != NULL) ;
    MRT_SetWord *pvect = set->instvector ;
    while (pvect < set->instvector + COUNTOF(set->instvector)) {
        if (*pvect++ != 0) {
            return false ;
        }
    }

    return true ;
}
unsigned
mrt_InstSetCardinality(
    MRT_InstSet *set)
{
    assert(set != NULL) ;
    unsigned card = 0 ;
    for (MRT_SetWord *pvect = set->instvector ;
            pvect < set->instvector + COUNTOF(set->instvector) ; pvect++) {
        MRT_SetWord w = *pvect ;
        MRT_SetWord mask = 1 ;
        for (unsigned bit = MRT_SETWORD_BITS ; w != 0 && bit != 0 ; bit--) {
            if ((w & mask) != 0) {
                card++ ;
                w &= ~mask ; // <1>
            }
            mask <<= 1 ;
        }
    }

    return card ;
}
bool
mrt_InstSetEqual(
    MRT_InstSet *set1,
    MRT_InstSet *set2)
{
    assert(set1 != NULL) ;
    assert(set2 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2->classDesc != NULL) ;

    if (set1->classDesc != set2->classDesc) {
        return false ;
    }

    MRT_SetWord *src1 = set1->instvector ;
    MRT_SetWord *src2 = set2->instvector ;
    while (src1 < set1->instvector + COUNTOF(set1->instvector)) {
        if (*src1++ != *src2++) {
            return false ;
        }
    }

    return true ;
}
void
mrt_InstSetUnion(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ | *src2++ ;
        }
    } else {
        memcpy(result->instvector, set1->instvector, sizeof(result->instvector)) ;
    }
}
void
mrt_InstSetIntersect(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ & *src2++ ;
        }
    } else {
        memset(result->instvector, 0, sizeof(result->instvector)) ;
    }
}
void
mrt_InstSetMinus(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ & ~*src2++ ;
        }
    } else {
        memcpy(result->instvector, set1->instvector, sizeof(result->instvector)) ;
    }
}
void
mrt_InstSetIterBegin(
    MRT_InstSet *set,
    MRT_InstSetIterator *iter)
{
    assert(set != NULL) ;
    assert(iter != NULL) ;

    iter->set = set ;
    iter->vectorloc = set->instvector ;
    iter->bitoffset = 0 ;
    if ((*iter->vectorloc & 1) == 0) { // <1>
        mrt_InstSetIterNext(iter) ;
    } else {
        iter->instance = mrtIndexToInstance(iter->set->classDesc, 0) ;
        if (iter->instance == NULL) { // <2>
            mrt_InstSetIterNext(iter) ;
        }
    }
}
bool
mrt_InstSetIterMore(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance != NULL ;
}
void *
mrt_InstSetIterGet(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    assert(iter->instance != NULL) ;
    return iter->instance ;
}
void
mrt_InstSetIterNext(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    
    iter->bitoffset++ ; //<1>
    if (iter->bitoffset >= MRT_SETWORD_BITS) {
        iter->vectorloc++ ;
        iter->bitoffset = 0 ;
    }
    while (iter->vectorloc <
            iter->set->instvector + COUNTOF(iter->set->instvector)) {
        if (*iter->vectorloc != 0) { // <2>
            MRT_SetWord mask = 1 << iter->bitoffset ;
            for ( ; iter->bitoffset < MRT_SETWORD_BITS ; iter->bitoffset++) {
                if ((*iter->vectorloc & mask) != 0) { // <3>
                    unsigned instindex =
                        (iter->vectorloc - iter->set->instvector) *
                        MRT_SETWORD_BITS + iter->bitoffset ; // <4>
                    void *instance = mrtIndexToInstance(iter->set->classDesc,
                            instindex) ;
                    if (instance != NULL) { // <5>
                        iter->instance = instance ;
                        return ;
                    }
                }
                mask <<= 1 ;
            }
        }
        iter->vectorloc++ ; // <6>
        iter->bitoffset = 0 ;
    }

    iter->instance = NULL ;
}
void
mrt_BeginSyncService(void)
{
    mrtIncrTransLevel() ;
}
void
mrt_EndSyncService(void)
{
    mrtEndTransaction() ;
}
void
mrt_CreateSimpleLinks(
    MRT_Relationship const *const rel,
    void *const source,
    void *const target,
    bool isForward)
{
    assert(rel != NULL) ;
    assert(source != NULL) ;
    assert(target != NULL) ;

    switch (rel->relType) {
    case mrtSimpleAssoc: {
        MRT_SimpleAssociation const *const assoc = &rel->relInfo.simpleAssociation ;
        
        MRT_Instance *srcInst = source ;
        MRT_Instance *targetInst = target ;
        if (assoc->source.classDesc != srcInst->classDesc ||
                assoc->target.classDesc != targetInst->classDesc) {
            mrtFatalError(mrtRelationshipLinkage) ;                             // <1>
        }
        
        void *currentTarget =
                *(void **)((uintptr_t)source + assoc->source.storageOffset) ;
        
        if (currentTarget != target) {                                          // <2>
            if (currentTarget != NULL) {
                mrtUnlinkBackref(&assoc->target, source, currentTarget) ;       // <3>
            }
            mrtLink(&assoc->source, source, target) ;                           // <4>
            mrtLink(&assoc->target, target, source) ;
        }
    }
        break ;

    case mrtClassAssoc: {
        MRT_ClassAssociation const *const cassoc = &rel->relInfo.classAssociation ;
        MRT_AssociatorRole const *const arole = &cassoc->associator ;
        MRT_AssociationRole const *const srole = &cassoc->source ;
        MRT_AssociationRole const *const trole = &cassoc->target ;
        
        void *const associator = source ; // Change the variable names to keep things clear
        void *const dest = target ;
        if (arole->classDesc != ((MRT_Instance *)associator)->classDesc) { // <1>
            mrtFatalError(mrtRelationshipLinkage) ;
        }
        
        MRT_AssociationRole const *destrole ;
        MRT_AttrOffset assocOffset ;
        void *srcInst ;
        void *targetInst ;
        
        if (srole->classDesc == trole->classDesc) {                         // <2>
            // reflexive case
            if (trole->classDesc != ((MRT_Instance *)dest)->classDesc) {
                mrtFatalError(mrtRelationshipLinkage) ;
            }
            if (isForward) {                                                // <3>
                destrole = trole ;
                assocOffset = arole->forwardOffset ;
                srcInst = *(void **)((uintptr_t)associator + arole->backwardOffset) ;
                targetInst = dest ;
            } else {
                destrole = srole ;
                assocOffset = arole->backwardOffset ;
                srcInst = dest ;
                targetInst = *(void **)((uintptr_t)associator + arole->forwardOffset) ;
            }
        } else {                                                            // <4>
            // non-reflexive case
            if (srole->classDesc == ((MRT_Instance *)dest)->classDesc) {
                // backward
                destrole = srole ;
                assocOffset = arole->backwardOffset ;
                srcInst = dest ;
                targetInst = *(void **)((uintptr_t)associator + arole->forwardOffset) ;
            } else if (trole->classDesc == ((MRT_Instance *)dest)->classDesc) {
                // forward
                destrole = trole ;
                assocOffset = arole->forwardOffset ;
                srcInst = *(void **)((uintptr_t)associator + arole->backwardOffset) ;
                targetInst = dest ;
            } else {
                mrtFatalError(mrtRelationshipLinkage) ;
            }
        }
        
        void **p_assocRef = (void **)((uintptr_t)associator + assocOffset) ;
        if (*p_assocRef != NULL) {
            mrtUnlinkBackref(destrole, associator, *p_assocRef) ;            // <5>
            *p_assocRef = NULL ;
        }
        
        if (srcInst != NULL && targetInst != NULL && arole->multiple == false) {
            mrtCheckDupAssociator(rel, srcInst, targetInst) ;               // <6>
        }
        
        *p_assocRef = dest ;                                                 // <7>
        mrtLink(destrole, dest, associator) ;
    }
        break ;

    case mrtRefGeneralization: {
        MRT_RefGeneralization const *const gen = &rel->relInfo.refGeneralization ;
        
        MRT_Class const *const subclassClass =
                ((MRT_Instance *)source)->classDesc ;                           // <1>
        int subclassCode = mrtFindRefGenSubclassCode(subclassClass, gen->subclasses,
                gen->subclassCount) ;
        
        MRT_Class const *const superclassClass =
                ((MRT_Instance *)target)->classDesc ;                           // <2>
        if (gen->superclass.classDesc != superclassClass) {
            mrtFatalError(mrtRelationshipLinkage) ;
        }
        
        void **p_superRef = (void **)((uintptr_t)source +
                gen->subclasses[subclassCode].storageOffset) ;
        *p_superRef = target ;
        
        void **p_subRef = (void **)((uintptr_t)target + gen->superclass.storageOffset) ;
        *p_subRef = source ;
    }
        break ;

    case mrtUnionGeneralization:
        // There are no pointer linkages for a union generalization.
        // N.B. fall through

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }

    mrtMarkRelationship(&rel, 1) ;      // <1>
}
void
mrt_CreateAssociatorLinks(
    MRT_Relationship const *rel,
    void *assoc,
    void *source,
    void *target)
{
    assert(rel != NULL) ;
    assert(assoc != NULL) ;
    assert(source != NULL) ;
    assert(target != NULL) ;

    assert(rel->relType == mrtClassAssoc) ;
    if (rel->relType != mrtClassAssoc) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }

    MRT_ClassAssociation const *cassoc = &rel->relInfo.classAssociation ;
    MRT_AssociatorRole const *arole = &cassoc->associator ;

    assert(arole->classDesc == ((MRT_Instance *)assoc)->classDesc) ;
    if (arole->classDesc != ((MRT_Instance *)assoc)->classDesc) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }

    if (!arole->multiple) {
        mrtCheckDupAssociator(rel, source, target) ;    // <1>
    }

    mrt_CreateSimpleLinks(rel, assoc, source, false) ;  // <2>
    mrt_CreateSimpleLinks(rel, assoc, target, true) ;
}
void *
mrt_Reclassify(
    MRT_Relationship const *rel,
    void *sub,
    MRT_Class const *const newSubclass)
{
    assert(rel != NULL) ;
    assert(newSubclass != NULL) ;

    MRT_Instance *currentSubInst = sub ;
    assert(currentSubInst != NULL) ;
    assert(currentSubInst->alloc > 0) ;

    void *newSubInst = NULL ;

    if (rel->relType == mrtRefGeneralization) {
        MRT_RefGeneralization const *const gen = &rel->relInfo.refGeneralization ;
        
        /*
         * Verify the subclass instance is an instance of that class that
         * is part of the relationship.
         */
        int subclassCode = mrtFindRefGenSubclassCode(currentSubInst->classDesc,
                gen->subclasses, gen->subclassCount) ;
        /*
         * Fetch the superclass instance via the reference in the subclass instance.
         */
        MRT_Instance *super = *(MRT_Instance **)((uintptr_t)sub +
                gen->subclasses[subclassCode].storageOffset) ;
        /*
         * Check that the subclass instance is related to a superclass that is
         * the correct one for the relationship.
         */
        if (gen->superclass.classDesc != super->classDesc) {
            mrtFatalError(mrtRelationshipLinkage) ;
        }
        /*
         * Verify that the new subclass is indeed a subclass of the relationship.
         * We don't care about the subtype code and are only using
         * mrtFindRefGenSubclassCode() to validate the new requested subclass.
         */
        mrtFindRefGenSubclassCode(newSubclass, gen->subclasses, gen->subclassCount) ;
        /*
         * Delete the old subclass instance.  Deleting will cause the subclass
         * instance to be unlinked from the generalization.
         */
        mrt_DeleteInstance(sub) ;
        /*
         * Create a new instance of the new subclass.
         */
        newSubInst = mrt_CreateInstance(newSubclass, MRT_StateCode_IG) ;
        /*
         * Create the links to the super class instance.
         */
        mrt_CreateSimpleLinks(rel, newSubInst, super, true) ;
    } else if (rel->relType == mrtUnionGeneralization) {
        MRT_UnionGeneralization const *const gen = &rel->relInfo.unionGeneralization ;
        /*
         * Verify the subclass instance is an instance of that class that
         * is part of the relationship. We don't need the subclass code.
         */
        MRT_Class const *const subClass = currentSubInst->classDesc ;
        mrtFindUnionGenSubclassCode(subClass, gen->subclasses, gen->subclassCount) ;
        /*
         * Compute the pointer to the superclass instance.
         */
        MRT_Instance *super = (MRT_Instance *)((uintptr_t)currentSubInst -
                gen->superclass.storageOffset) ;
        /*
         * Check that the subclass instance is related to a superclass that is
         * the correct one for the relationship.
         */
        if (gen->superclass.classDesc != super->classDesc) {
            mrtFatalError(mrtRelationshipLinkage) ;
        }
        /*
         * Check that the new subclass is one that is part of this generalization.
         * We don't actually need the subclass code itself.
         */
        mrtFindUnionGenSubclassCode(newSubclass, gen->subclasses, gen->subclassCount) ;
        /*
         * Clean up any relationship pointers in the currently related instance.
         */
        mrtDeleteLinks(subClass->classRels, subClass->relCount, currentSubInst) ;
        /*
         * The new instance occupies the same memory as the old one.
         */
        newSubInst = currentSubInst ;
        /*
         * Set up the memory for the subclass instance according to the new subclass.
         */
        mrtInitializeInstance(newSubInst, newSubclass, MRT_StateCode_IG) ;
    } else {
        mrtFatalError(mrtRelationshipLinkage) ;
    }

    return newSubInst ;
}
MRT_ecb *
mrt_NewEvent(
    MRT_EventCode event,
    void *target,
    void *source)
{
    MRT_Instance *targetInst = target ;
    MRT_Instance *sourceInst = source ;

    assert(targetInst != NULL) ;
    assert(targetInst->alloc != 0) ;
    assert(event < targetInst->classDesc->eventCount) ;

    MRT_ecb *ecb = mrtECBalloc() ;

    ecb->eventNumber = event ;
    ecb->alloc = targetInst->alloc ;    // <1>
    ecb->targetInst = targetInst ;
    ecb->sourceInst = sourceInst ;
    ecb->delay = 0 ;                    // <2>
    ecb->reload = 0 ;

    return ecb ;
}
void
mrt_PostEvent(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;
    assert(ecb->targetInst != NULL) ;

        /*
         * The location in some event queue where the ECB will be inserted.
         */
    MRT_ecb *qloc ;

    if (ecb->sourceInst == NULL) {                              // <1>
        qloc = mrtEventQueueEnd(&tocEventQueue) ;
    } else if (ecb->sourceInst != ecb->targetInst) {            // <2>
        qloc = mrtEventQueueEnd(&eventQueue) ;
    } else {                                                    // <3>
        for (qloc = mrtEventQueueBegin(&eventQueue) ;
                qloc != mrtEventQueueEnd(&eventQueue) &&
                    qloc->sourceInst == qloc->targetInst ;
                qloc = qloc->next) {
            // N.B. -- empty loop
        }
    }

    mrtEventQueueInsert(ecb, qloc) ;
}
void
mrt_SignalEvent(
    MRT_EventCode event,
    void *targetInst,
    void *sourceInst,
    void const *eventparams,
    size_t paramsize)
{
    if (targetInst == NULL) {
        return ;                                                    // <1>
    }

    MRT_ecb *ecb = mrt_NewEvent(event, targetInst, sourceInst) ;

    if (eventparams != NULL) {
        assert(paramsize <= sizeof(ecb->eventParameters)) ;
        size_t toCopy = paramsize <= sizeof(ecb->eventParameters) ?
                paramsize : sizeof(ecb->eventParameters) ;
        memcpy(ecb->eventParameters, eventparams, toCopy) ;
    }

    mrt_PostEvent(ecb) ;
}
void *
mrt_CreateInstanceAsync(
    MRT_Class const *const targetClass,
    MRT_EventCode event,
    void const *eventparams,
    size_t paramsize,
    void *sourceInst)
{
    assert(targetClass != NULL) ;
    assert(targetClass->edb != NULL) ;
    assert(targetClass->edb->creationState >= 0) ;
    assert(event < targetClass->edb->eventCount) ;

    MRT_Instance *targetInst = mrt_CreateInstance(targetClass,
            targetClass->edb->creationState) ;                  // <1>
    targetInst->alloc = -targetInst->alloc ;                    // <2>

    mrt_SignalEvent(event, targetInst, sourceInst, eventparams, paramsize) ;

    return targetInst ;
}
void *
mrt_CreateUnionInstanceAsync(
    MRT_Class const *const targetClass,
    MRT_EventCode event,
    void const *eventparams,
    size_t paramsize,
    void *sourceInst,
    MRT_Relationship const *const genRel,
    void *super)
{
    assert(targetClass != NULL) ;
    assert(targetClass->edb != NULL) ;
    assert(targetClass->edb->creationState >= 0) ;
    assert(event < targetClass->edb->eventCount) ;

    MRT_Instance *targetInst = mrt_CreateUnionInstance(targetClass,
            targetClass->edb->creationState, genRel, super) ;
    targetInst->alloc = -targetInst->alloc ;                            // <1>

    mrt_SignalEvent(event, targetInst, sourceInst, eventparams, paramsize) ;

    return targetInst ;
}
void
mrt_PostDelayedEvent(
    MRT_ecb *ecb,
    MRT_DelayTime time)
{
    assert(ecb != NULL) ;

    mrtStopDelayedQueueTiming() ;                                   // <1>
    mrtRemoveDelayedEvent(ecb->sourceInst, ecb->targetInst,
            ecb->eventNumber) ;

    if (time != 0) {
        ecb->delay = mrtMsecToTicks(time) ;
        mrtInsertDelayedEvent(ecb) ;
    } else {
        mrtEventQueueInsert(ecb, mrtEventQueueEnd(&tocEventQueue)) ;// <2>
    }

    mrtStartDelayedQueueTiming() ;                                  // <3>
}
void
mrt_PostPeriodicEvent(
    MRT_ecb *ecb,
    MRT_DelayTime initial,
    MRT_DelayTime reload)
{
    assert(ecb != NULL) ;
    ecb->reload = mrtMsecToTicks(reload) ;
    mrt_PostDelayedEvent(ecb, initial) ;
}
void
mrt_SignalDelayedEvent(
    MRT_DelayTime time,
    MRT_EventCode event,
    void *targetInst,
    void *sourceInst,
    void const *eventparams,
    size_t paramsize)
{
    MRT_ecb *ecb = mrt_NewEvent(event, targetInst, sourceInst) ;

    if (eventparams != NULL) {
        assert(paramsize <= sizeof(ecb->eventParameters)) ;
        size_t toCopy = paramsize <= sizeof(ecb->eventParameters) ?
                paramsize : sizeof(ecb->eventParameters) ;
        memcpy(ecb->eventParameters, eventparams, toCopy) ;
    }

    mrt_PostDelayedEvent(ecb, time) ;
}
void
mrt_SignalPeriodicEvent(
    MRT_DelayTime initial,
    MRT_DelayTime reload,
    MRT_EventCode event,
    void *targetInst,
    void *sourceInst)
{
    MRT_ecb *ecb = mrt_NewEvent(event, targetInst, sourceInst) ;

    mrt_PostPeriodicEvent(ecb, initial, reload) ;
}
void
mrt_CancelDelayedEvent(
    MRT_EventCode event,
    void *target,
    void *source)
{
    assert(target != NULL) ;

    mrtStopDelayedQueueTiming() ;                           // <1>
    mrtRemoveDelayedEvent(source, target, event) ;
    mrtStartDelayedQueueTiming() ;
}
MRT_DelayTime
mrt_RemainingDelayTime(
    MRT_EventCode event,
    void *target,
    void *source)
{
    MRT_Instance *targetInst = target ;
    MRT_Instance *sourceInst = source ;
    assert(targetInst != NULL) ;

    mrtStopDelayedQueueTiming() ;
    /*
     * Iterate through the delayed event time and sum all the delay times to
     * give the total amount of time remaining for the found event.
     */
    MRT_DelayTime remain = 0 ;
    MRT_ecb *iter ;
    MRT_ecb *endOfQueue = mrtEventQueueEnd(&delayedEventQueue) ;
    for (iter = mrtEventQueueBegin(&delayedEventQueue) ; iter != endOfQueue ;
            iter = iter->next) {
        remain += iter->delay ;
        if (iter->sourceInst == sourceInst && iter->targetInst == targetInst &&
                iter->eventNumber == event) {
            break ;
        }
    }
    mrtStartDelayedQueueTiming() ;
    /*
     * Return the amount of time remaining for the event.  If we didn't find
     * the event, the just return 0.
     */
    return iter == endOfQueue ? 0 : mrtTicksToMsec(remain) ;
}
MRT_DelayTime
mrt_TimerExpireService(void)
{
    MRT_DelayTime next_delay = 0 ;
    /*
     * Iterate along the delayed event queue.
     */
    MRT_ecb *iter = mrtEventQueueBegin(&delayedEventQueue) ;
    MRT_ecb *const end = mrtEventQueueEnd(&delayedEventQueue) ;
    while (iter != end) {
        if (iter->delay == 0) {
            MRT_ecb *expired = iter ;
            iter = iter->next ;                                         // <1>
            mrtEventQueueRemove(expired) ;

            if (expired->reload == 0) {
                MRT_DelayedEventParams *params =
                    (MRT_DelayedEventParams *)mrt_SyncRequest(mrtExpireDelayedEvent) ;
                params->ecb = expired ;
            } else {
                MRT_PeriodicEventParams *params =
                    (MRT_PeriodicEventParams *)mrt_SyncRequest(mrtExpirePeriodicEvent) ;
                params->eventNumber = expired->eventNumber ;
                params->alloc = expired->alloc ;
                params->targetInst = expired->targetInst ;
                params->sourceInst = expired->sourceInst ;

                expired->delay = expired->reload ;
                mrtInsertDelayedEvent(expired) ;
                iter = mrtEventQueueBegin(&delayedEventQueue) ;         // <2>
            }
        } else {
            /*
             * Stop at the first non-zero delay time.  This marks the boundary
             * of events that need additional delay time.  The first such event
             * is the next amount of time to delay.
             */
            next_delay = iter->delay ;
            iter->delay = 0 ;
            break ;
        }
    }

    return next_delay ;
}
char const *
mrt_PortalErrorString(
    int portalErrorCode)
{
#       ifndef MRT_NO_NAMES

    static char const * const portalErrStrings[] = {
        "No error",                                     // <1>
        "No such class",
        "No such instance",
        "No such attribute",
        "Instance slot is not in use",
        "Class does not have a state model",
        "No such event for the class",
        "No such state for the class",
        "Class does not support dynamic instances",
        "Operation not allowed on a dependent attribute",
        "Operation failed from insufficient space to transfer value",
    } ;

    assert(portalErrorCode >= MICCA_PORTAL_SIZE_ERROR && portalErrorCode <= 0) ;

    if (portalErrorCode < MICCA_PORTAL_SIZE_ERROR || portalErrorCode > 0) {
        return NULL ;
    }

    return portalErrStrings[-portalErrorCode] ;         // <2>

#       else

    return NULL ;

#       endif /* MRT_NO_NAMES */
}
int
mrt_PortalGetAttrRef(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void **pref,
    MRT_AttrSize *size)
{
    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const class = instref->classDesc ;
    assert(class != NULL) ;
    if (attrId >= class->attrCount) {
        return MICCA_PORTAL_NO_ATTR ;
    }

    MRT_Attribute const *attr = class->classAttrs + attrId ;
    if (attr->type != mrtIndependentAttr) {
        return MICCA_PORTAL_DEPENDENT_ATTR ;
    }

    if (pref) {
        *pref = (void *)((uintptr_t)instref + attr->access.offset) ;
    }
    if (size) {
        *size = attr->size ;
    }
    return 0 ;
}
int
mrt_PortalReadAttr(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void *dst,
    MRT_AttrSize dstSize)
{
    assert(dst != NULL) ;

    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const class = instref->classDesc ;
    if (attrId >= class->attrCount) {
        return MICCA_PORTAL_NO_ATTR ;
    }

    MRT_Attribute const *attr = class->classAttrs + attrId ;
    MRT_AttrSize srcSize = attr->size ;
    if (srcSize > dstSize) {
        return MICCA_PORTAL_SIZE_ERROR ;
    }

    if (attr->type == mrtIndependentAttr) {
        void *src = (void *)((uintptr_t)instref + attr->access.offset) ;
        memcpy(dst, src, srcSize) ;
    } else {
        attr->access.formula(instref, dst, srcSize) ;
    }
    return srcSize ;
}
int
mrt_PortalUpdateAttr(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void const *src,
    MRT_AttrSize srcSize)
{
    assert(src != NULL) ;

    void *dst ;
    MRT_AttrSize dstSize ;

    int result = mrt_PortalGetAttrRef(portal, classId, instId, attrId, &dst,
            &dstSize) ;
    if (result != 0) {
        return result ;
    }

    if (srcSize > dstSize) {
        return MICCA_PORTAL_SIZE_ERROR ;
    }

    assert(dst != NULL) ;
    memcpy(dst, src, srcSize) ;
    return srcSize ;
}
int
mrt_PortalSignalEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize)
{
    int result ;
    MRT_ecb *ecb ;

    result = mrtPortalNewECB(portal, classId, instId, eventNumber,
            eventParameters, paramSize, &ecb) ;
    if (result == 0) {
        mrt_PostEvent(ecb) ;
    }

    return result ;
}
int
mrt_PortalSignalDelayedEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize,
    MRT_DelayTime delay)
{
    MRT_ecb *ecb ;
    int result = mrtPortalNewECB(portal, classId, instId, eventNumber,
            eventParameters, paramSize, &ecb) ;
    if (result == 0) {
        mrt_PostDelayedEvent(ecb, delay) ;
    }

    return result ;
}
int
mrt_PortalCancelDelayedEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber)
{
    MRT_Instance *instref ;

    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    assert(instref != NULL) ;
    MRT_Class const *const class = instref->classDesc ;
    assert(class != NULL) ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= class->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    mrt_CancelDelayedEvent(eventNumber, instref, NULL) ;
    return 0 ;
}
int
mrt_PortalRemainingDelayTime(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_DelayTime *delayRef)
{
    assert(delayRef != NULL) ;

    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const class = instref->classDesc ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= class->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    MRT_DelayTime delay = mrt_RemainingDelayTime(eventNumber, instref, NULL) ;
    if (delayRef) {
        *delayRef = delay ;
    }
    return 0 ;

}
int
mrt_PortalCreateInstance(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_StateCode initialState)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->containment != NULL) {
        return MICCA_PORTAL_NO_DYNAMIC ;
    }

    if (initialState != MRT_StateCode_IG) {
        if (class->edb == NULL) {
            return MICCA_PORTAL_NO_STATE_MODEL ;
        }
        if (initialState <= MRT_StateCode_CH ||
                initialState >= class->edb->stateCount ||
                initialState == class->edb->creationState) {
            return MICCA_PORTAL_NO_STATE ;
        }
    }
    void *inst = mrt_CreateInstance(class, initialState) ;
    return mrt_InstanceIndex(inst) ;
}
int
mrt_PortalCreateInstanceAsync(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->containment != NULL) {                   // <1>
        return MICCA_PORTAL_NO_DYNAMIC ;
    }

    if (class->edb == NULL) {                           // <2>
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= class->edb->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    MRT_Instance *inst = mrt_CreateInstanceAsync(class,
            eventNumber, eventParameters, paramSize, NULL) ;
    return mrt_InstanceIndex(inst) ;
}
int
mrt_PortalDeleteInstance(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId)
{
    MRT_Instance *inst = NULL ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &inst) ;
    if (result == 0) {
        assert(inst != NULL) ;
        mrt_DeleteInstance(inst) ;
    }

    return result ;
}
int
mrt_PortalSignalEventToAssigner(
    MRT_DomainPortal const *const portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize)
{
    MRT_Instance *instref = NULL ;
    int result = mrtPortalGetAssignerRef(portal, assignerId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    assert(instref != NULL) ;
    MRT_Class const *const asnClass = instref->classDesc ;
    MRT_edb const *edb = asnClass->edb ;
    assert(edb != NULL) ;
    if (eventNumber >= edb->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    if (paramSize > sizeof(MRT_EventParams)) {
        return MICCA_PORTAL_SIZE_ERROR ;
    }

    MRT_ecb *ecb = mrt_NewEvent(eventNumber, instref, NULL) ;
    if (eventParameters != NULL) {
        memcpy(ecb->eventParameters, eventParameters, paramSize) ;
    }
    mrt_PostEvent(ecb) ;
    return 0 ;
}
int
mrt_PortalInstanceCurrentState(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId)
{
    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const class = instref->classDesc ;
    assert(class != NULL) ;
    if (class->edb == NULL) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    return instref->currentState ;
}
int
mrt_PortalAssignerCurrentState(
    MRT_DomainPortal const *const portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId)
{
    MRT_Instance *instref = NULL ;
    int result = mrtPortalGetAssignerRef(portal, assignerId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    assert(instref != NULL) ;
    return instref->currentState ;
}
char const *
mrt_PortalDomainName(
    MRT_DomainPortal const *const portal)
{
    assert(portal != NULL) ;

#       ifndef MRT_NO_NAMES
    return portal->name ;
#       else
    return NULL ;
#       endif /* MRT_NO_NAMES */
}
int
mrt_PortalDomainClassCount(
    MRT_DomainPortal const *const portal)
{
    assert(portal != NULL) ;

    return portal != NULL ? portal->classCount : 0 ;
}
int
mrt_PortalClassName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    char const ** const nameRef)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

#       ifndef MRT_NO_NAMES
    MRT_Class const *const class = portal->classes + classId ;
    if (nameRef) {
        *nameRef = class->name ;
    }
#       else
    if (nameRef) {
        *nameRef = NULL ;
    }
#       endif /* MRT_NO_NAMES */

    return 0 ;
}
int
mrt_PortalClassAttributeCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    return class->attrCount ;
}
int
mrt_PortalClassInstanceCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    return class->instCount ;
}
int
mrt_PortalClassEventCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    return class->eventCount ;
}
int
mrt_PortalClassStateCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    MRT_edb const *edb = class->edb ;
    assert(edb != NULL) ;

    return edb != NULL ? edb->stateCount : 0 ;
}
int
mrt_PortalClassAttributeName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_AttrId attrId,
    char const ** const nameRef)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (attrId >= class->attrCount) {
        return MICCA_PORTAL_NO_ATTR ;
    }

    if (nameRef) {
#           ifndef MRT_NO_NAMES
        *nameRef = class->classAttrs[attrId].name ;
#           else
        *nameRef = NULL ;
#           endif /* MRT_NO_NAMES */
    }

    return 0 ;
}
int
mrt_PortalClassAttributeSize(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_AttrId attrId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (attrId >= class->attrCount) {
        return MICCA_PORTAL_NO_ATTR ;
    }

    return class->classAttrs[attrId].size ;
}
int
mrt_PortalClassEventName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_EventCode eventNumber,
    char const ** const nameRef)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= class->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

#       ifndef MRT_NO_NAMES
    char const *const *eventNames = class->eventNames ;
    if (eventNames != NULL && nameRef != NULL) {
        *nameRef = eventNames[eventNumber] ;
    }
#       else
    if (nameRef != NULL) {
        *nameRef = NULL ;
    }
#       endif /* MRT_NO_NAMES */

    return 0 ;
}
int
mrt_PortalClassStateName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_StateCode stateCode,
    char const **nameRef)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    MRT_edb const *edb = class->edb ;
    if (edb == NULL) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (stateCode < 0 || stateCode >= edb->stateCount) {
        return MICCA_PORTAL_NO_STATE ;
    }

    if (nameRef) {
#           ifndef MRT_NO_NAMES
        *nameRef = edb->stateNames[stateCode] ;
#           else
        *nameRef = NULL ;
#           endif /* MRT_NO_NAMES */
    }
    return 0 ;
}
MRT_FatalErrorHandler
mrt_SetFatalErrorHandler(
    MRT_FatalErrorHandler newHandler)
{
    MRT_FatalErrorHandler prevHandler = mrtErrHandler ;
    if (newHandler) {
        mrtErrHandler = newHandler ;
    }
    return prevHandler ;
}
bool
mrt_CanCreateInstance(
    MRT_Class const *const classDesc)
{
    assert(classDesc != NULL) ;

    /*
     * Search for an empty slot in the pool.
     */
    return mrtFindInstSlot(classDesc->iab) != NULL ;
}
bool
mrt_CanSignalEvent(void)
{
    return !mrtEventQueueEmpty(&freeEventQueue) ;
}
noreturn void
mrt_Panic(
    char const *format,
    ...)
{
    char outbuf[128] ;
    va_list ap ;

    va_start(ap, format) ;
    vsnprintf(outbuf, sizeof(outbuf), format, ap) ;
    va_end(ap) ;

    mrtFatalError(mrtPanic, outbuf) ;
}
