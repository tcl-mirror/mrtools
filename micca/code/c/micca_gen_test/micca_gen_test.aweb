// vim:set syntax=asciidoc:

= Micca Run Time Testing

== Singular Associations

[source,c]
----
<<test suites>>=
{"one to one associations", NULL, NULL, NULL, NULL, oneToOneAssocSuiteTests},
----

[source,c]
----
<<suite tests>>=
<<one to one associations suite tests>>

<<one to one associations suite tests>>=
static CU_TestInfo oneToOneAssocSuiteTests[] = {
    <<one to one associations test cases>>
    CU_TEST_INFO_NULL,
} ;
----

=== One to One

["aafigure"]
----
+---+            +---+
|   |1    R1    1|   |
| A +------------+ B |
|   |            |   |
+---+            +---+
----

----
<<test domain configuration>>=
class A {
    attribute count int
}

class B {
    attribute count int
}

association R1 A 1--1 B

<<test domain population>>=
class A {
    allocate 2
}

class B {
    allocate 2
}
----

----
<<test domain configuration>>=
domainop void oneToOne {} {
    <%B create bref1 count 1%>
    <%A create aref1 count 1 R1 bref1%>             // <1>

    <%instance aref1 findOneRelated bfound R1%>     // <2>
    CU_ASSERT(bfound->count == 1) ;
    <%instance bref1 findOneRelated afound ~R1%>
    CU_ASSERT(afound->count == 1) ;

    <%B create bref2 count 2%>                      // <3>
    <%R1 swap aref1 bref2%>

    <%instance aref1 findOneRelated bfound R1%>     // <4>
    CU_ASSERT(bfound->count == 2) ;
    <%instance bref2 findOneRelated afound ~R1%>
    CU_ASSERT(afound->count == 1) ;

    <%instance bref1 findOneRelated afound ~R1%>    // <5>
    CU_ASSERT_PTR_NULL(afound) ;

    <%R1 swap aref1 bref2%>                         // <6>
    <%instance aref1 findOneRelated bfound R1%>
    CU_ASSERT(bfound->count == 2) ;
    <%instance bref2 findOneRelated afound ~R1%>
    CU_ASSERT(afound->count == 1) ;

    <%instance bref1 delete%>                       // <7>

    <%instance aref1 delete%>                       // <8>
    <%instance bref2 findOneRelated afound ~R1%>
    CU_ASSERT_PTR_NULL(afound) ;

    <%instance bref2 delete%>                       // <9>
}
----
<1> Create a related pair.
<2> Check the navigation of R1 to make sure we get the right instance.
<3> Create a new related pair by swaping in a new instance.
<4> Check we are navigating to the correct instances.
<5> The previously related instance is now "dangling" and should
havigate to nowhere.
<6> Check that swapping in the same instance does nothing.
<7> Delete the dangling instance.
<8> Delete the refering instance and check that the referenced
instance now navigates nowhere.
<9> Clean up the dangling instance to prevent referential integrity violation.

[source,c]
----
<<one to one associations test cases>>=
{"1--1", genTest_OneToOne},

<<test functions>>=
static void
genTest_OneToOne(void)
{
    gendomain_oneToOne() ;

    bool didevent = mrt_DispatchSingleEvent() ;
    CU_ASSERT_FALSE(didevent) ;
}
----

=== One Conditional to One

["aafigure"]
----
+---+            +---+
|   |?    R1    1|   |
| C +------------+ D |
|   |            |   |
+---+            +---+
----

[source,tcl]
----
<<test domain configuration>>=
class C {
    attribute count int
}

class D {
    attribute count int
}

association R2 C ?--1 D

<<test domain population>>=
class C {
    allocate 2
}

class D {
    allocate 4
}
----

----
<<test domain configuration>>=
domainop void oneCToOne {} {
    <%D create dref1 count 1%>
    <%C create cref1 count 1 R2 dref1%>

    <%instance cref1 findOneRelated dfound R2%>
    CU_ASSERT(dfound->count == 1) ;

    <%instance dref1 findOneRelated cfound ~R2%>
    CU_ASSERT(cfound->count == 1) ;

    <%D create dref2 count 2%>
    <%instance dref2 findOneRelated cfound ~R2%>
    CU_ASSERT_PTR_NULL(cfound) ;

    <%D create dref3 count 3%>
    <%R2 swap cref1 dref3%>

    <%instance cref1 findOneRelated dfound R2%>
    CU_ASSERT(dfound->count == 3) ;

    <%instance dref3 findOneRelated cfound ~R2%>
    CU_ASSERT(cfound->count == 1) ;
}
----

[source,c]
----
<<one to one associations test cases>>=
{"?--1", genTest_OneCToOne},

<<test functions>>=
static void
genTest_OneCToOne(void)
{
    gendomain_oneCToOne() ;

    bool didevent = mrt_DispatchSingleEvent() ;
    CU_ASSERT_FALSE(didevent) ;
}
----

=== One to One Reflexive

["aafigure"]
----
     +--------+ R3
     |        |
    1|        |
+----+----+   |
|E        |   |
+---------+ 1 |
|count    +---+
|         |
+---------+
----

[source,tcl]
----
<<test domain configuration>>=
class E {
    attribute count int
}

association R3 E 1--1 E

<<test domain population>>=
class E {
    allocate 6
}
----

----
<<test domain configuration>>=
domainop void oneToOneReflexive {} {
    <%E create eref1 count 1 R3 eref1%>
    <%E create eref2 count 2 R3 eref2%>
    <%E create eref3 count 3 R3 eref3%>

    <%R3 swap eref1 eref2%>
    <%R3 swap eref2 eref3%>
    <%R3 swap eref3 eref1%>

    <%instance eref1 findOneRelated efound R3%>
    CU_ASSERT(efound->count == 2) ;
    <%instance eref2 findOneRelated efound R3%>
    CU_ASSERT(efound->count == 3) ;
    <%instance eref3 findOneRelated efound R3%>
    CU_ASSERT(efound->count == 1) ;

    <%instance eref1 findOneRelated efound ~R3%>
    CU_ASSERT(efound->count == 3) ;
    <%instance eref2 findOneRelated efound ~R3%>
    CU_ASSERT(efound->count == 1) ;
    <%instance eref3 findOneRelated efound ~R3%>
    CU_ASSERT(efound->count == 2) ;

    <%instance eref2 delete%>
    <%R3 swap eref1 eref3%>
    <%instance eref1 findOneRelated efound R3%>
    CU_ASSERT(efound->count == 3) ;
    <%instance eref3 findOneRelated efound R3%>
    CU_ASSERT(efound->count == 1) ;
    <%instance eref1 findOneRelated efound ~R3%>
    CU_ASSERT(efound->count == 3) ;
    <%instance eref3 findOneRelated efound ~R3%>
    CU_ASSERT(efound->count == 1) ;
}
----

[source,c]
----
<<one to one associations test cases>>=
{"1--1 reflexive", genTest_OneToOneReflexive},

<<test functions>>=
static void
genTest_OneToOneReflexive(void)
{
    gendomain_oneToOneReflexive() ;

    bool didevent = mrt_DispatchSingleEvent() ;
    CU_ASSERT_FALSE(didevent) ;
}
----

=== One to One Associative

["aafigure"]
----
+---------+              +---------+
|F        |              |G        |
+---------+1     R4     1+---------+
|count    +-------+------+count    |
|         |       |      |         |
+---------+       |      +---------+
             +----+----+
             |"R4assoc"|
             +---------+
             |         |
             +---------+
----

----
<<test domain configuration>>=
class F {
    attribute count int
}

class G {
    attribute count int
}

class R4assoc

association R4 -associator R4assoc F 1--1 G

<<test domain population>>=
class F {
    allocate 4
}

class G {
    allocate 4
}

class R4assoc {
    allocate 4
}
----

----
<<test domain configuration>>=
domainop void oneToOneAssoc {} {
    <%F create fref1 count 1%>
    <%G create gref1 count 1%>
    <%R4assoc create r4ref1 R4 {F fref1 G gref1}%>      // <1>

    <%instance fref1 findOneRelated gfound R4%>         // <2>
    CU_ASSERT(gfound->count == 1) ;
    <%instance gref1 findOneRelated ffound ~R4%>
    CU_ASSERT(ffound->count == 1) ;

    <%instance r4ref1 delete%>                          // <3>

    <%R4assoc create r4ref2 R4 {F fref1 G gref1}%>      // <4>

    <%instance fref1 findOneRelated gfound R4%>         // <5>
    CU_ASSERT(gfound->count == 1) ;
    <%instance gref1 findOneRelated ffound ~R4%>
    CU_ASSERT(ffound->count == 1) ;

    <%G create gref2 count 2%>                          // <6>
    <%R4 swap r4ref2 gref2%>

    <%instance fref1 findOneRelated gfound R4%>         // <7>
    CU_ASSERT(gfound->count == 2) ;
    <%instance gref2 findOneRelated ffound ~R4%>
    CU_ASSERT(ffound->count == 1) ;

    <%R4 swap r4ref2 gref1%>                            // <8>
    <%instance fref1 findOneRelated gfound R4%>         // <9>
    CU_ASSERT(gfound->count == 1) ;
    <%instance gref1 findOneRelated ffound ~R4%>
    CU_ASSERT(ffound->count == 1) ;

    <%instance gref2 delete%>                           // <10>
}
----
<1> Create an instance of R4.
<2> Check we find the right instances.
<3> Delete the instance of R4.
<4> Create a new instance of R4.
<5> Check we find the right instances.
<6> Swap in a new instance of G. The first G instance is dangling.
<7> Check we find the right instances.
<8> Swap back in the original G instance. The second G instance is dangling.
<9> Check we find the right instances.
<10> Deleting the dangling G instance to preserve referential integrity.

[source,c]
----
<<one to one associations test cases>>=
{"1--1 associative", genTest_OneToOneAssoc},

<<test functions>>=
static void
genTest_OneToOneAssoc(void)
{
    gendomain_oneToOneAssoc() ;

    bool didevent = mrt_DispatchSingleEvent() ;
    CU_ASSERT_FALSE(didevent) ;
}
----

=== One to One Reflexive Associative

["aafigure"]
----
                       +---------+
     +--------+ R5     |"R5assoc"|
     |        +--------+---------+
    1|        |        |         |
+----+----+   |        +---------+
|H        |   |
+---------+ 1 |
|count    +---+
|         |
+---------+
----

[source,tcl]
----
<<test domain configuration>>=
class H {
    attribute count int
}

class R5assoc

association R5 -associator R5assoc H 1--1 H

<<test domain population>>=
class H {
    allocate 6
}

class R5assoc {
    allocate 3
}
----

----
<<test domain configuration>>=
domainop void oneToOneReflAssoc {} {
    <%H create h1ref count 1%>                      // <1>
    <%H create h2ref count 2%>
    <%H create h3ref count 3%>
    <%R5assoc create r5ref1 R5 {backward h1ref forward h2ref}%>
    <%R5assoc create r5ref2 R5 {backward h2ref forward h3ref}%>
    <%R5assoc create r5ref3 R5 {backward h3ref forward h1ref}%>

    <%instance h1ref findOneRelated hfound R5%>     // <2>
    CU_ASSERT(hfound->count == 2) ;
    <%instance h2ref findOneRelated hfound ~R5%>    // <3>
    CU_ASSERT(hfound->count == 1) ;

    <%instance h2ref findOneRelated hfound R5%>
    CU_ASSERT(hfound->count == 3) ;
    <%instance h3ref findOneRelated hfound ~R5%>
    CU_ASSERT(hfound->count == 2) ;

    <%instance h3ref findOneRelated hfound R5%>
    CU_ASSERT(hfound->count == 1) ;
    <%instance h1ref findOneRelated hfound ~R5%>
    CU_ASSERT(hfound->count == 3) ;

    <%H create h4ref count 4%>                      // <4>
    <%R5 swap r5ref1 h4ref backward%>
    <%R5 swap r5ref3 h4ref forward%>

    <%instance h4ref findOneRelated hfound R5%>
    CU_ASSERT(hfound->count == 2) ;
    <%instance h2ref findOneRelated hfound ~R5%>
    CU_ASSERT(hfound->count == 4) ;

    <%instance h1ref delete%>                       // <5>
}
----
<1> Create a circle of three instances of H.
<2> Forward from 1 is 2.
<3> Backward from 2 is 1.
<4> Replace H, count = 1 with H, count = 4. Note it takes two swaps
to do that.
<5> Clean up to restore referential integrity.

[source,c]
----
<<one to one associations test cases>>=
{"1--1 reflexive associative", genTest_OneToOneReflAssoc},

<<test functions>>=
static void
genTest_OneToOneReflAssoc(void)
{
    gendomain_oneToOneReflAssoc() ;

    bool didevent = mrt_DispatchSingleEvent() ;
    CU_ASSERT_FALSE(didevent) ;
}
----

=== One Conditional to One Conditional Associative

["aafigure"]
----
+---------+              +---------+
|I        |              |J        |
+---------+?     R6     ?+---------+
|count    +-------+------+count    |
|         |       |      |         |
+---------+       |      +---------+
             +----+----+
             |"R6assoc"|
             +---------+
             |         |
             +---------+
----

----
<<test domain configuration>>=
class I {
    attribute count int
}

class J {
    attribute count int
}

class R6assoc

association R6 -associator R6assoc I ?--? J

<<test domain population>>=
class I {
    allocate 4
}

class J {
    allocate 4
}

class R6assoc {
    allocate 4
}
----

----
<<test domain configuration>>=
domainop void oneCToOneCAssoc {} {
    <%I create i1ref count 1%>
    <%I create i2ref count 2%>
    <%I create i3ref count 3%>
    <%J create j1ref count 1%>
    <%J create j2ref count 2%>
    <%J create j3ref count 3%>

    <%R6assoc create r6ref1 R6 {I i1ref J j1ref}%>
    <%R6assoc create r6ref2 R6 {I i2ref J j2ref}%>

    <%instance i1ref findOneRelated jfound R6%>
    CU_ASSERT(jfound->count == 1) ;
    <%instance j1ref findOneRelated ifound ~R6%>
    CU_ASSERT(ifound->count == 1) ;

    <%instance i3ref findOneRelated jfound R6%>
    CU_ASSERT_PTR_NULL(jfound) ;
    <%instance j3ref findOneRelated ifound ~R6%>
    CU_ASSERT_PTR_NULL(ifound) ;
}
----

[source,c]
----
<<one to one associations test cases>>=
{"?--? associative", genTest_OneCToOneCAssoc},

<<test functions>>=
static void
genTest_OneCToOneCAssoc(void)
{
    gendomain_oneCToOneCAssoc() ;

    bool didevent = mrt_DispatchSingleEvent() ;
    CU_ASSERT_FALSE(didevent) ;
}
----

== CUnit Setup

[source,c]
----
<<micca_gen_test.c>>=
#include "micca_rt.h"
#include <stdlib.h>
#include <setjmp.h>
#include <CUnit/CUnit.h>
#include <CUnit/Basic.h>

#include "gendomain.h"

<<test functions>>

<<suite tests>>

static CU_SuiteInfo suites[] = {
    <<test suites>>
    CU_SUITE_INFO_NULL,
} ;

int
main(
    int argc,
    char **argv)
{
    mrt_Initialize() ;

    CU_initialize_registry() ;

    CU_register_suites(suites) ;

    CU_basic_set_mode(CU_BRM_VERBOSE) ;
    CU_basic_run_tests() ;

    const CU_pFailureRecord failures = CU_get_failure_list() ;
    CU_basic_show_failures(failures) ;

    puts("") ;

    CU_cleanup_registry() ;
}
----

== Test Domain

[source,tcl]
----
<<gendomain.micca>>=
domain gendomain {
    prologue {
        #include <CUnit/CUnit.h>
    }

    <<test domain configuration>>
}
population gendomain {
    <<test domain population>>
}
----
