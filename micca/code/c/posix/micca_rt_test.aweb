// vim :set syntax=asciidoc:

= Testing

[source,c]
----
<<micca_rt_test.c>>=
#include <CUnit/CUnit.h>
#include <CUnit/Basic.h>
#include "micca_rt.h"
#include "micca_rt.c"
#include "testdomain.c"

<<test functions>>

<<initialization suite tests>>
<<event dispatch suite tests>>

static CU_SuiteInfo suites[] = {
    <<test suites>>
    CU_SUITE_INFO_NULL,
} ;

int
main(
    int argc,
    char **argv)
{
    CU_initialize_registry() ;

    CU_register_suites(suites) ;

    CU_basic_run_tests() ;

    CU_cleanup_registry() ;
}
----

== Test Domain

[source,tcl]
----
<<testdomain.micca>>=
source ../../tcl/micca.tcl

micca configure {
    domain testdomain {
        <<test domain configuration>>
    }
    population testdomain {
        <<test domain population>>
    }
}

micca generate
----

== Initialization

[source,c]
----
<<test suites>>=
{"initialization", NULL, NULL, NULL, NULL, initializationSuiteTests},
----

[source,c]
----
<<initialization suite tests>>=
static CU_TestInfo initializationSuiteTests[] = {
    <<initialization test cases>>
    CU_TEST_INFO_NULL,
} ;
----

[source,c]
----
<<initialization test cases>>=
{"initialize run time", mrtTest_InitRunTime},

<<test functions>>=
static void
mrtTest_InitRunTime(void)
{
    mrt_Initialize() ;
    CU_ASSERT_TRUE(mrtEventQueueEmpty(&eventQueue)) ;
    CU_ASSERT_TRUE(mrtEventQueueEmpty(&tocEventQueue)) ;
    CU_ASSERT_TRUE(mrtEventQueueEmpty(&delayedEventQueue)) ;
    CU_ASSERT_FALSE(mrtEventQueueEmpty(&freeEventQueue)) ;
}
----

== Event Dispatch

[source,c]
----
<<test suites>>=
{"event dispatch", NULL, NULL, NULL, NULL, eventDispatchSuiteTests},
----

[source,c]
----
<<event dispatch suite tests>>=
static CU_TestInfo eventDispatchSuiteTests[] = {
    <<event dispatch test cases>>
    CU_TEST_INFO_NULL,
} ;
----

=== Dispatch An Event with Parameters

[source,tcl]
----
<<test domain configuration>>=
class A {
    attribute count int -default 0
    statemodel {
        state s1 {b int} {
            printf("b = %d\n", b) ;
            %<instance self attribute count>% += b ;
        }
        transition s1 - e1 -> s1
    }
}

domainop void signalA {} {
    %<A foreachInstance aref>%
        %<instance aref signal e1 b 20>%
    %<end>%
}

<<test domain population>>=
class A {
    instance a1
}
----

[source,c]
----
<<event dispatch test cases>>=
{"signal event", mrtTest_SignalEvent},

<<test functions>>=
static void
mrtTest_SignalEvent(void)
{
    struct A *aref = &A__POOL[TESTDOMAIN_A_A1_INSTID] ;
    CU_ASSERT_PTR_EQUAL(aref->base__INST.classDesc,
        &testdomain__CLASSES[TESTDOMAIN_A_CLASSID]) ;
    CU_ASSERT(aref->base__INST.alloc > 0) ;

    bool didone = mrt_ProcessOneEvent() ;
    CU_ASSERT_FALSE(didone) ;

    testdomain_signalA() ;

    CU_ASSERT_FALSE(mrtEventQueueEmpty(&tocEventQueue)) ;
    CU_ASSERT_TRUE(mrtEventQueueEmpty(&eventQueue)) ;

    didone = mrt_ProcessOneEvent() ;
    CU_ASSERT_TRUE(didone) ;

    CU_ASSERT_TRUE(mrtEventQueueEmpty(&tocEventQueue)) ;
    CU_ASSERT_TRUE(mrtEventQueueEmpty(&eventQueue)) ;
    CU_ASSERT(aref->count == 20) ;
}
----

==== Event Dispatch Causes Further Generation

[source,tcl]
----
<<test domain configuration>>=
class B {
    attribute count int -default 0

    statemodel {
        state s1 {} {
            printf("In %s\n", MRT_STATENAME) ;
            %<instance self signal e2>%
        }
        transition s1 - e1 -> s1
        transition s1 - e2 -> s2

        state s2 {} {
            printf("In %s\n", MRT_STATENAME) ;
        }
        transition s2 - e1 -> s1
    }
}

domainop void signalB {} {
    %<B foreachInstance bref>%
        %<instance bref signal e1>%
    %<end>%
}

<<test domain population>>=
class B {
    instance b1
}
----

[source,c]
----
<<event dispatch test cases>>=
{"cascade events", mrtTest_CascadeEvents},

<<test functions>>=
static void
mrtTest_CascadeEvents(void)
{
    struct B *bref = &B__POOL[TESTDOMAIN_B_B1_INSTID] ;
    CU_ASSERT_PTR_EQUAL(bref->base__INST.classDesc,
        &testdomain__CLASSES[TESTDOMAIN_B_CLASSID]) ;
    CU_ASSERT(bref->base__INST.alloc > 0) ;
    CU_ASSERT(bref->base__INST.currentState == 0) ;

    testdomain_signalB() ;

    CU_ASSERT_FALSE(mrtEventQueueEmpty(&tocEventQueue)) ;
    CU_ASSERT_TRUE(mrtEventQueueEmpty(&eventQueue)) ;

    bool didone = mrt_ProcessOneEvent() ;
    CU_ASSERT_TRUE(didone) ;

    CU_ASSERT_TRUE(mrtEventQueueEmpty(&tocEventQueue)) ;
    CU_ASSERT_FALSE(mrtEventQueueEmpty(&eventQueue)) ;

    didone = mrt_ProcessOneEvent() ;
    CU_ASSERT_TRUE(didone) ;
    CU_ASSERT(bref->base__INST.currentState == 1) ;
}
----

==== Dispatch Polymorphic Event

[source,tcl]
----
<<test domain configuration>>=
class C {
    polymorphic e1
}

generalization R1 C D E

class D {
    attribute count int -default 0

    statemodel {
        state s1 {} {
            printf("In %s.%s\n", MRT_CLASSNAME, MRT_STATENAME) ;
            %<instance self attribute count>%++ ;
        }
        transition s1 - e1 -> s1
    }
}
class E {
    attribute count int -default 0

    statemodel {
        state s1 {} {
            printf("In %s.%s\n", MRT_CLASSNAME, MRT_STATENAME) ;
            %<instance self attribute count>%++ ;
        }
        transition s1 - e1 -> s1
    }
}

domainop void polysignalC {} {
    %<C foreachInstance cref>%
        %<instance cref signal e1>%
    %<end>%
}

<<test domain population>>=
class C {
    instance c1
    instance c2
}
class D {
    instance d1 R1 c1
}
class E {
    instance e1 R1 c2
}
----

[source,c]
----
<<event dispatch test cases>>=
{"signal polymorphic event", mrtTest_SignalPoly},

<<test functions>>=
static void
mrtTest_SignalPoly(void)
{
    struct C *cref = &C__POOL[TESTDOMAIN_C_C1_INSTID] ;
    CU_ASSERT_PTR_EQUAL(cref->base__INST.classDesc,
        &testdomain__CLASSES[TESTDOMAIN_C_CLASSID]) ;
    CU_ASSERT(cref->base__INST.alloc > 0) ;

    testdomain_polysignalC() ;

    CU_ASSERT_FALSE(mrtEventQueueEmpty(&tocEventQueue)) ;
    CU_ASSERT_TRUE(mrtEventQueueEmpty(&eventQueue)) ;

    bool didone = mrt_ProcessOneEvent() ;
    CU_ASSERT_TRUE(didone) ;

    CU_ASSERT_TRUE(mrtEventQueueEmpty(&tocEventQueue)) ;
    CU_ASSERT_TRUE(mrtEventQueueEmpty(&eventQueue)) ;

    struct D *dref = &D__POOL[TESTDOMAIN_D_D1_INSTID] ;
    CU_ASSERT(dref->count == 1) ;
}
----
