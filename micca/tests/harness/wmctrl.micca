# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 - 2016 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

domain wmctrl {
    class WashingMachine { # <1>
        attribute MachineID char -dimension 32 ; # <2>
    
        statemodel {
            initialstate Stopped
            defaulttrans CH
            
            transition Stopped - Start -> FillingToWash
            
            transition FillingToWash - Full -> Washing
            
            transition Washing - Done -> DrainingWash
            
            transition DrainingWash - Empty -> FillingToRinse
            
            transition FillingToRinse - Full -> Rinsing
            
            transition Rinsing - Done -> DrainingRinse
            
            transition DrainingRinse - Empty -> Spinning
            
            transition Spinning - Done -> Stopped
            state Stopped {} {
                %<instance ct findOneRelated self ~R1>%
                %<instance ct signal Stop>%
            
                // This code is not part of the model activity. <1>
                MRT_InstId selfid = %<my instid>% ;
                %<externalop cycleComplete washerid selfid>% ;
            }
            state FillingToWash {} {
                %<instance wc findOneRelated self R4>%
                %<instance ct findOneRelated self ~R1>%
                WaterTemp washtemp = %<instance wc attr WashWaterTemp>% ;
                %<instance ct signal Fill temp washtemp>%
            }
            state Washing {} {
                %<instance ct findOneRelated self ~R1>%
                %<instance ct signal Agitate>%
                %<instance wc findOneRelated self R4>%
                MRT_DelayTime washtime = %<instance wc attr WashDuration>% * 1000 ;
                %<my delaysignal washtime Done>% // <1>
            }
            state DrainingWash {} {
                %<instance ct findOneRelated self ~R1>%
                %<instance ct signal Drain>%
            }
            state FillingToRinse {} {
                %<instance wc findOneRelated self R4>%
                %<instance ct findOneRelated self ~R1>%
                WaterTemp rinsetemp = %<instance wc attr RinseWaterTemp>% ;
                %<instance ct signal Fill temp rinsetemp>%
            }
            state Rinsing {} {
                %<instance ct findOneRelated self ~R1>%
                %<instance ct signal Agitate>%
                %<instance wc findOneRelated self R4>%
                MRT_DelayTime rinsetime = %<instance wc attr RinseDuration>% * 1000 ;
                %<my delaysignal rinsetime Done>%
            }
            state DrainingRinse {} {
                %<instance ct findOneRelated self ~R1>%
                %<instance ct signal Drain>%
            }
            state Spinning {} {
                %<instance ct findOneRelated self ~R1>%
                %<instance ct signal Spin>%
                %<instance wc findOneRelated self R4>%
                MRT_DelayTime spintime = %<instance wc attr SpinDuration>% * 1000 ;
                %<my delaysignal spintime Done>%
            }
        }
    
        classop {struct WashingMachine *} findByMachineID {id {char const *}} {
            %<WashingMachine instref wm>%
            %<WashingMachine foreachWhere wm {strcmp(id, wm->MachineID) == 0}>%
                return wm ;
            %<end>%
        
            return NULL ;
        }
    }
    class WashingCycle {
        attribute CycleType char -dimension 32
        attribute WashWaterTemp WaterTemp
        attribute RinseWaterTemp WaterTemp
        attribute WashDuration unsigned
        attribute RinseDuration unsigned
        attribute SpinDuration unsigned
        attribute AgitationSpeed WashSpeed
        attribute SpinSpeed WashSpeed
    
        classop {struct WashingCycle *} findByCycleType {cycleType {char const *}} {
            %<WashingCycle instref wc>%
            %<WashingCycle foreachWhere wc {strcmp(cycleType, wc->CycleType) == 0}>%
                return wc ;
            %<end>%
        
            return NULL ;
        }
    }
    class ClothesTub { # <1>
        statemodel {
            initialstate Empty
            defaulttrans CH
            
            transition Empty - Fill -> Filling
            transition Empty - Spin -> Spinning
            
            transition Filling - TubFull -> Full
            transition Filling - TubEmpty -> IG
            
            transition Full - Agitate -> Agitating
            
            transition Agitating - Drain -> Emptying
            
            transition Emptying - TubEmpty -> Empty
            transition Emptying - TubFull -> IG
            
            transition Spinning - Stop -> StoppingSpin
            
            transition StoppingSpin - Fill -> Filling
            state Empty {} {
                %<Motor instref mtr>%
                mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
                assert(mtr != NULL) ;
                %<instance mtr operation Stop>% ;
            
                %<WaterValve instref wv>%
                wv = %<my operation findRelatedValve valveid WV_Drain>% ;
                assert(wv != NULL) ;
                %<instance wv operation Close>% ;
            
                %<instance wls findOneRelated self ~R5>%
                %<instance wls operation Disable>% ;
            
                %<instance wm findOneRelated self R1>%
                %<instance wm signal Empty>%
            }
            state Filling {temp WaterTemp} {
                %<instance wls findOneRelated self ~R5>%
                %<instance wls operation Enable>% ;
                %<WaterValve instref wv>%
            
                if (temp == WT_Hot) {
                    wv = %<my operation findRelatedValve valveid WV_Hot>% ;
                    assert(wv != NULL) ;
                    %<instance wv operation Open>% ;
                } else if (temp == WT_Cold) {
                    wv = %<my operation findRelatedValve valveid WV_Cold>% ;
                    assert(wv != NULL) ;
                    %<instance wv operation Open>% ;
                } else if (temp == WT_Warm) {
                    %<WaterValve instset watervalves>%
                    watervalves = %<my operation findRelatedWaterValves>% ;
                    %<instset watervalves foreachSelected wv>%
                        %<instance wv operation Open>% ;
                    %<end>%
                }
            }
            state Full {} {
                // Disable the sensor
                %<instance wls findOneRelated self ~R5>%
                %<instance wls operation Disable>% ;
            
                // Close all water valves
                %<WaterValve instset watervalves>%
                watervalves = %<my operation findRelatedWaterValves>% ;
                %<instset watervalves foreachSelected wv>%
                    %<instance wv operation Close>% ;
                %<end>%
            
                // Inform the washing machine
                %<instance wm findOneRelated self R1>%
                %<instance wm signal Full>%
            }
            state Agitating {} {
                // Start the agitator motor
                %<Motor instref mtr>%
                mtr = %<my operation findRelatedMotor mtrid MTR_Agitator>% ;
                assert(mtr != NULL) ;
                %<instance mtr operation Start>% ;
            }
            state Emptying {} {
                // Stop the motor
                %<Motor instref mtr>%
                mtr = %<my operation findRelatedMotor mtrid MTR_Agitator>% ;
                assert(mtr != NULL) ;
                %<instance mtr operation Stop>% ;
            
                // Open the drain valve
                %<WaterValve instref wv>%
                wv = %<my operation findRelatedValve valveid WV_Drain>% ;
                assert(wv != NULL) ;
                %<instance wv operation Open>% ;
            
                // Start the pump
                mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
                assert(mtr != NULL) ;
                %<instance mtr operation Start>% ;
            
                // Enable the sensor
                %<instance wls findOneRelated self ~R5>%
                %<instance wls operation Enable>% ;
            }
            state Spinning {} {
                // Open the drain valve
                %<WaterValve instref wv>%
                wv = %<my operation findRelatedValve valveid WV_Drain>% ;
                assert(wv != NULL) ;
                %<instance wv operation Open>% ;
            
                // Start the pump
                %<Motor instref mtr>%
                mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
                assert(mtr != NULL) ;
                %<instance mtr operation Start>% ;
            
                // Start the spin motor
                mtr = %<my operation findRelatedMotor mtrid MTR_Spin>% ;
                assert(mtr != NULL) ;
                %<instance mtr operation Start>% ;
            }
            state StoppingSpin {} {
                // Stop the motor
                %<Motor instref mtr>%
                mtr = %<my operation findRelatedMotor mtrid MTR_Spin>% ;
                assert(mtr != NULL) ;
                %<instance mtr operation Stop>% ;
            
                // Stop the pump
                mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
                assert(mtr != NULL) ;
                %<instance mtr operation Stop>% ;
            
                // Close the drain valve
                %<WaterValve instref wv>%
                wv = %<my operation findRelatedValve valveid WV_Drain>% ;
                assert(wv != NULL) ;
                %<instance wv operation Close>% ;
            }
        }
        instop {struct Motor *} findRelatedMotor {mtrid MotorType} {
            %<instance mtr foreachRelatedWhere {mtr->MotorID == mtrid} self ~R2>%
                return mtr ;
            %<end>%
        
            return NULL ;
        }
        instop {struct WaterValve *} findRelatedValve {valveid ValveType} {
            %<instance valve foreachRelatedWhere {valve->ValveID == valveid} self ~R3>%
                return valve ;
            %<end>%
        
            return NULL ;
        }
        instop MRT_InstSet findRelatedWaterValves {} {
            %<instset watervalves selectRelatedWhere vid\
                    {vid->ValveID == WV_Hot || vid->ValveID == WV_Cold} self ~R3>%
        
            return watervalves ;
        }
    }
    class WaterValve {
        attribute ValveID ValveType
    
        instop void Open {} {
            MRT_InstId selfid = %<my instid>% ;
            %<externalop valveOpen valveid selfid>% ;
        }
        
        instop void Close {} {
            MRT_InstId selfid = %<my instid>% ;
            %<externalop valveClose valveid selfid>% ;
        }
    }
    class Motor {
        attribute MotorID MotorType
    
        instop void Start {} {
            MRT_InstId selfid = %<my instid>% ;
            %<externalop motorStart motorid selfid>% ;
        }
        
        instop void Stop {} {
            MRT_InstId selfid = %<my instid>% ;
            %<externalop motorStop motorid selfid>% ;
        }
    }
    class WaterLevelSensor {
        instop void Enable {} {
            %<instance ct findOneRelated self R5>%
            MRT_InstId ctid = %<instance ct instid>% ;
            %<externalop sensorEnable tubid ctid>% ;
        }
        
        instop void Disable {} {
            %<instance ct findOneRelated self R5>%
            MRT_InstId ctid = %<instance ct instid>% ;
            %<externalop sensorDisable tubid ctid>% ;
        }
    }
    association R4 WashingMachine 0..*--1 WashingCycle
    association R1 ClothesTub 1--1 WashingMachine
    association R3 WaterValve 1..*--1 ClothesTub
    association R2 Motor 1..*--1 ClothesTub
    association R5 WaterLevelSensor 1--1 ClothesTub
    domainop MRT_InstId createWasher {washer {char const *}} {
        %<WashingMachine instref wm>%
        wm = %<WashingMachine operation findByMachineID id washer>% ;
        if (wm == NULL) {
            %<WashingCycle findByName Normal nwc>%
            %<WashingMachine create wm MachineID washer R4 nwc>%
    
            %<ClothesTub create ct R1 wm>%
    
            %<WaterValve create wv ValveID WV_Hot R3 ct>%
            %<WaterValve create wv ValveID WV_Cold R3 ct>%
            %<WaterValve create wv ValveID WV_Drain R3 ct>%
    
            %<Motor create mtr MotorID MTR_Pump R2 ct>%
            %<Motor create mtr MotorID MTR_Agitator R2 ct>%
            %<Motor create mtr MotorID MTR_Spin R2 ct>%
    
            %<WaterLevelSensor create wls R5 ct>%
        }
        return %<instance wm instid>% ;
    }
    domainop void deleteWasher {washer {char const *}} {
        %<WashingMachine instref wm>%
        wm = %<WashingMachine operation findByMachineID id washer>% ;
        if (wm != NULL) {
            %<instance ct findOneRelated wm ~R1>%
            %<instance wls findOneRelated ct ~R5>%
            %<instance wls delete>%
            %<instance wv foreachRelated ct ~R3>%
                %<instance wv delete>%
            %<end>%
            %<instance mtr foreachRelated ct ~R2>%
                %<instance mtr delete>%
            %<end>%
            %<instance ct delete>%
            %<instance wm delete>%
        } else {
            printf("unknown washer, %s\n", washer) ;
        }
    }
    domainop void startWasher {washer {char const *}} {
        %<WashingMachine instref wm>%
        wm = %<WashingMachine operation findByMachineID id washer>% ;
        if (wm != NULL) {
            %<instance wm signal Start>%
        } else {
            printf("unknown washer, %s\n", washer) ;
        }
    }
    domainop void selectCycle {washer {char const *} cycle {char const *}} {
        %<WashingMachine instref wm>%
        wm = %<WashingMachine operation findByMachineID id washer>% ;
        if (wm == NULL) {
            printf("unknown washer, %s\n", washer) ;
            return ;
        }
    
        %<WashingCycle instref reqCycle>%
        reqCycle = %<WashingCycle operation findByCycleType cycleType cycle>% ;
        if (reqCycle == NULL) {
            printf("unknown washing cycle, %s\n", cycle) ;
            return ;
        }
    
        %<R4 swap wm reqCycle>%
    }
    domainop void init {} {
        %<WashingMachine foreachInstance wm>%
            %<instance wm signal Start>%
        %<end>%
    }
    externalop void motorStart {motorid MRT_InstId} {
        printf("%s: starting motor %u\n", __func__, motorid) ;
    }
    externalop void motorStop {motorid MRT_InstId} {
        printf("%s: stopping motor %u\n", __func__, motorid) ;
    }
    externalop void valveOpen {valveid MRT_InstId} {
        printf("%s: opening valve %u\n", __func__, valveid) ;
    }
    externalop void valveClose {valveid MRT_InstId} {
        printf("%s: closing valve %u\n", __func__, valveid) ;
    }
    prologue {
        static bool tubFull[WMCTRL_CLOTHESTUB_INSTCOUNT] ;
    }
    externalop void sensorEnable {tubid MRT_InstId} {
        printf("%s: enable sensor for tub %u\n", __func__, tubid) ;
    
        tubFull[tubid] = !tubFull[tubid] ;
    
        mrt_PortalSignalDelayedEvent(&wmctrl__PORTAL,
            WMCTRL_CLOTHESTUB_CLASSID,
            tubid,
            tubFull[tubid] ?    WMCTRL_CLOTHESTUB_TUBFULL_EVENT :
                                WMCTRL_CLOTHESTUB_TUBEMPTY_EVENT,
            NULL,
            3000) ;
    }
    externalop void sensorDisable {tubid MRT_InstId} {
        printf("%s: disable sensor for tub %u\n", __func__, tubid) ;
    
        mrt_PortalCancelDelayedEvent(&wmctrl__PORTAL,
            WMCTRL_CLOTHESTUB_CLASSID,
            tubid,
            tubFull[tubid] ?    WMCTRL_CLOTHESTUB_TUBFULL_EVENT :
                                WMCTRL_CLOTHESTUB_TUBEMPTY_EVENT) ;
    }
    externalop void cycleComplete {washerid MRT_InstId} {
        printf("%s: cycle complete for washer %u\n", __func__, washerid) ;
        /*
         * Exit the event loop for the purposes of the example.  This call is used
         * to cause the event loop to exit. This means that we will only run one
         * cycle of the washer before the program exits the event loop and then
         * terminates.
         */
        mrt_SyncToEventLoop() ;
    }
    typealias WaterTemp {enum {WT_Hot, WT_Cold, WT_Warm}}
    typealias WashSpeed {enum {WS_Low, WS_Medium, WS_High}}
    typealias ValveType {enum {WV_Hot, WV_Cold, WV_Drain}}
    typealias MotorType {enum {MTR_Pump, MTR_Agitator, MTR_Spin}}
}
