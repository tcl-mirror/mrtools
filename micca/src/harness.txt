// vim:set syntax=asciidoc:

= Generating a Test Harness

[partintro]
.Generating a Test Harness
--
The `micca` run-time is capable of executing in a POSIX environment.
This is intended primarily to be able to simulate and integrate
a system that is ultimately targeted for a micro-processor in an
environment that has more capability for testing and introspection.
To support this important activity,
`micca` can automatically generate a test harness in which one or
more domains may be run.
--

== Introduction

Place holder.

== Test Harness Operation

Place holder.

=== Harness Data Structures

Place holder.

==== Domain Harness Information

Each domain is well encapsulated and stands alone.
The test harness will resolve to which domain an operation is directed
and then will need the information about that domain to carry out
the operation.

One of the most important pieces of information is the
domain portal data that `micca` generates.
This provides much information to the test harness and provides the
means, via the
<<portal-access-functions>>
of the run-time,
to access the various aspects of a domain, _e.g._ send events and read
attributes.

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthdomainharness {
    MRT_DomainPortal const *portal ;
    struct mthoperationmap const *const operations ;
    unsigned operationCount ;
    struct mthclassmap const *const classes ;
    unsigned classCount ;
} MTH_DomainHarness ;
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthoperationmap {
    char const *name ;
    MTH_DomainOpFunc *func ;
} MTH_OperationMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef void MTH_DomainOpFunc(int, char *const *) ;
----

[source,c]
----
<<mth forward references>>=
static MTH_OperationMap const *const
mthFindOperation(
    MTH_DomainHarness const *const harness,
    char const *opName) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_OperationMap const *const
mthFindOperation(
    MTH_DomainHarness const *const harness,
    char const *opName)
{
    MTH_OperationMap key = {
        .name = opName,
        .func = NULL
    } ;
    return (MTH_OperationMap const *const)
            bsearch(&key, harness->operations, harness->operationCount,
            sizeof(key), mthOperationMapCompare) ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthOperationMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthOperationMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_OperationMap const *cm1 = m1 ;
    MTH_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthclassmap {
    char const *name ;
    MRT_ClassId id ;
    struct mthattrmap const *attrs ;
    unsigned attrCount ;
    struct mthinstmap const *insts ;
    unsigned instCount ;
    struct mtheventmap const *events ;
    unsigned eventCount ;
} MTH_ClassMap ;
----

[source,c]
----
<<mth forward references>>=
static MTH_ClassMap const *const
mthFindClass(
    MTH_DomainHarness const *const harness,
    char const *className) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_ClassMap const *const
mthFindClass(
    MTH_DomainHarness const *const harness,
    char const *className)
{
    MTH_ClassMap key = {
        .name = className
    } ;
    return (MTH_ClassMap const *const)
            bsearch(&key, harness->classes, harness->classCount,
            sizeof(key), mthClassMapCompare) ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthClassMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthClassMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_ClassMap const *cm1 = m1 ;
    MTH_ClassMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthattrmap {
    char const *name ;
    MRT_AttrId id ;
    MTH_AttrReadFunc *readFunc ;
    MTH_AttrUpdateFunc *updateFunc ;
} MTH_AttrMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef int MTH_AttrReadFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId, char *, size_t) ;
----

[source,c]
----
<<mth interface simple types>>=
typedef int MTH_AttrUpdateFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId, char const *) ;
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthinstmap {
    char const *name ;
    MRT_InstId id ;
} MTH_InstMap ;
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mtheventmap {
    char const *name ;
    MRT_EventCode number ;
    MTH_EventParamFunc *paramFunc ;
} MTH_EventMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef bool MTH_EventParamFunc(int, char const **, MRT_EventParams) ;
----

=== Harness Functions

Place holder.

==== Harness Initialization

Before any harness activity can happen,
it is necessary invoke the initialization function for the harness
library.
This is typically done in `main` and must be done after
the `micca` run-time is initialized, _i.e._ after `mrt_Initialize`
has been invoked.

[source,c]
----
<<mth external function declarations>>=
extern int mth_Initialize(void) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <sys/socket.h>
#include <errno.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>
----

[source,c]
----
<<mth interface includes>>=
#include <inttypes.h>
----

[source,c]
----
<<mth external function definitions>>=
int
mth_Initialize(void)
{
    mthServiceSock = socket(AF_INET, SOCK_STREAM, 0) ;
    if (mthServiceSock == -1) {
        perror("unable to obtain AF_INET stream socket") ;
        return -1 ;
    }

    struct sockaddr_in hsrvAddr ;
    memset(&hsrvAddr, 0, sizeof(hsrvAddr)) ;
#       ifdef __APPLE__
    hsrvAddr.sin_len = sizeof(hsrvAddr) ;
#       endif /* __APPLE__ */
    hsrvAddr.sin_family = AF_INET ;
    hsrvAddr.sin_port = htons(HARNESS_PORT) ;

    static char const host[] = "localhost" ;
    struct hostent *hostAddr = gethostbyname(host) ;
    if (hostAddr == NULL) {
        perror(host) ;
        return -1 ;
    }
    assert(hostAddr->h_addrtype == AF_INET) ;
    memcpy(&hsrvAddr.sin_addr, hostAddr->h_addr_list[0], hostAddr->h_length) ;

    int err = bind(mthServiceSock, (struct sockaddr const *)&hsrvAddr,
            sizeof(hsrvAddr)) ;
    if (err == -1) {
        perror("bind()") ;
        return -1 ;
    }

    err = listen(mthServiceSock, 1) ;
    if (err == -1) {
        perror("listen()") ;
        return -1 ;
    }

    mrt_RegisterFDService(mthServiceSock, mthAcceptConnection, NULL, NULL) ;
    mrt_RegisterSignal(SIGQUIT, mthExit) ;
    mrt_RegisterSignal(SIGINT, mthExit) ;
    mrt_RegisterSignal(SIGTERM, mthExit) ;

    mrt_RegisterTraceHandler(NULL) ; // start with tracing off

    return mthServiceSock ;
}
----

[source,c]
----
<<mth implementation constants>>=
#ifndef HARNESS_PORT
#   define HARNESS_PORT 3906
#endif /* HARNESS_PORT */
----

[source,c]
----
<<mth static data>>=
int mthServiceSock = -1 ;
----

[source,c]
----
<<mth static functions>>=
static void
mthExit(
    int signal)
{
    dbgprintf("caught signal %d\n", signal) ;
    if (mthServiceSock != -1) {
        shutdown(mthServiceSock, SHUT_RDWR) ;
    }
    if (mthCmdStream != NULL) {
        fclose(mthCmdStream) ;
    }
    exit(EXIT_SUCCESS) ;
}
----
[source,c]
----
<<mth static functions>>=
static void
mthAcceptConnection(
    int sock)
{
    int fd = accept(sock, NULL, 0) ;

    int err = shutdown(mthServiceSock, SHUT_RDWR) ;
    if (err == -1) {
        perror("shutdown()") ;
        exit(EXIT_FAILURE) ;
    }
    mrt_UnregisterFDService(sock, true, false, false) ;
    mthServiceSock = -1 ;

    if (fd == -1) {
        perror("accept()") ;
        exit(EXIT_FAILURE) ;
    }

    mrt_RegisterFDService(fd, mthReadAndEvalCommand, NULL, NULL) ;
    mthCmdStream = fdopen(fd, "w+") ;
    err = setvbuf(mthCmdStream, NULL, _IOLBF, 0) ;
}
----

[source,c]
----
<<mth implementation includes>>=
#include <unistd.h>
----

[source,c]
----
<<mth static data>>=
FILE *mthCmdStream ;
----

==== Command Execution

[source,c]
----
<<mth forward references>>=
static void mthReadAndEvalCommand(int) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthReadAndEvalCommand(
    int rfd)
{
    static char cmdBuffer[BUFSIZ] ;

    char *cmd = fgets(cmdBuffer, sizeof(cmdBuffer), mthCmdStream) ;
    if (cmd == NULL) {
        if (feof(mthCmdStream)) {
            dbgprintf("goodbye\n") ;
            fclose(mthCmdStream) ;
            exit(EXIT_SUCCESS) ;
        } else if (ferror(mthCmdStream)) {
            perror("fgets()") ;
            fclose(mthCmdStream) ;
            exit(EXIT_FAILURE) ;
        } else {
            printf("partial\n") ;
            return ;
        }
    }
    for (char *end = cmdBuffer + strlen(cmdBuffer) - 1 ; isspace(*end) ; end--) {
        *end = ASCII_NUL ;
    }
    dbgprintf("%s\n", cmdBuffer) ;

    int argc ;
    char *const *argv ;
    static char parseBuffer[BUFSIZ] ;
    strcpy(parseBuffer, cmdBuffer) ;

    int err = mthParseCommand(parseBuffer, &argc, &argv) ;
    if (err == -1) {
        mth_CmdResponse(mthErrorReturn, "unknown",
                "failed to parse command: \"%s\"", cmdBuffer) ;
        return ;
    }

#if 0
    dbgprintf("got %d arguments\n", argc) ;
#       ifndef NDEBUG
    for (int i = 0 ; i < argc ; i++) {
        printf("%d: \"%s\"\n", i, argv[i]) ;
    }
#       endif /* NDEBUG */
#endif

    if (argc > 0) {
        mthExecCommand(argc, argv) ;
    }
}
----

[source,c]
----
<<mth forward references>>=
static int mthParseCommand(char *, int *, char *const **) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <ctype.h>
----

[source,c]
----
<<mth static functions>>=
static int
mthParseCommand(
    char *line,
    int *pargc,
    char *const **pargv)
{
    #define MAX_ARGS    64
    static char *args[MAX_ARGS] ;

    char **pArgv = args ;
    char **const argvEnd = pArgv + MAX_ARGS ;

    int quoteCount = 0 ;
    int parseState = OutOfWord ;
    int parseStackStorage[2] ;
    int *parseStackTop = parseStackStorage ;

    char *pWord = line ;
    for ( ; *line != ASCII_NUL ; line++) {
        char c = *line ;
        switch (parseState) {
        case OutOfWord:
            if (isgraph(c)) {
                if (c == ESCAPE_CHAR) {
                    *parseStackTop++ = InWord ;
                    parseState = InEscape ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else if (c == BEGIN_QUOTE) {
                    *parseStackTop++ = OutOfWord ;
                    parseState = InQuote ;
                    ++quoteCount ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else {
                    // new word beginning
                    if (pArgv < argvEnd) {
                        *pArgv++ = pWord ;
                    } else {
                        fprintf(stderr, "exceeded max arguments") ;
                        return -1 ;
                    }
                    *pWord++ = c ;
                    parseState = InWord ;
                }
            } // else the character is just space to skip
            break ;

        case InWord:
            if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = InEscape ;
            } else if (c == BEGIN_QUOTE) {
                *parseStackTop++ = parseState ;
                parseState = InQuote ;
                ++quoteCount ;
            } else if (isspace(c)) {
                // end of word
                parseState = OutOfWord ;
                *pWord++ = ASCII_NUL ;
            } else {
                *pWord++ = c ;
            }
            break ;

        case InEscape:
            switch (c) {
                case 'a':
                    *pWord++ = '\a' ;
                    break ;
                case 'b':
                    *pWord++ = '\b' ;
                    break ;
                case 't':
                    *pWord++ = '\t' ;
                    break ;
                case 'n':
                    *pWord++ = '\n' ;
                    break ;
                case 'v':
                    *pWord++ = '\v' ;
                    break ;
                case 'f':
                    *pWord++ = '\f' ;
                    break ;
                case 'r':
                    *pWord++ = '\r' ;
                    break ;
                default:
                    *pWord++ = c ;
                    break ;
            }
            parseState = *--parseStackTop ;
            break ;

        case InQuote:
            if (c == BEGIN_QUOTE) {
                ++quoteCount ;
                *pWord++ = c ;
            } else if (c == END_QUOTE) {
                if (--quoteCount == 0) {
                    parseState = *--parseStackTop ;
                    // check if ending the quote also ended the word
                    if (parseState == OutOfWord) {
                        *pWord++ = ASCII_NUL ;
                    }
                } else {
                    *pWord++ = c ;
                }
            } else if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = InEscape ;
            } else {
                *pWord++ = c ;
            }
            break ;
        }
    }

    *pWord = ASCII_NUL ;
    *pArgv = NULL ;
    if (quoteCount == 0 && parseState != InEscape) {
        if (pargc) {
            *pargc = pArgv - args ;
        }
        if (pargv) {
            *pargv = args ;
        }
        return 0 ;
    } else {
        return -1 ;
    }
}
----

[source,c]
----
<<mth implementation aggregate types>>=
typedef struct mthcommandmap {
    char const *name ;
    MTH_CommandFunc *commandFunc ;
} MTH_CommandMap ;
----

[source,c]
----
<<mth implementation simple types>>=
typedef void MTH_CommandFunc(int, char * const*) ;
----

==== Defined Commands

[source,c]
----
<<mth static data>>=
static MTH_CommandMap const commands[] = { // must be in ascending "name" order
{
    .name = "dop",
    .commandFunc = mthDopCommand
},
{
    .name = "query",
    .commandFunc = mthQueryCommand
},
{
    .name = "trace",
    .commandFunc = mthTraceCommand
},
} ;
----

[source,c]
----
<<mth forward references>>=
static void mthExecCommand(int, char * const *) ;
----

// HERE!
// use the buffer context from the top down.
// push the stack before calling each level and then have the level
// return the ok/error indication. Here we can pop the stack down
// and format the final reply with the result left in the buffer.

[source,c]
----
<<mth static functions>>=
static void
mthExecCommand(
    int argc,
    char *const *argv)
{
    MTH_CommandMap key = {
        .name = argv[0],
        .commandFunc = NULL
    } ;

    MTH_CommandMap const *cmd = (MTH_CommandMap const *)
            bsearch(&key, commands, COUNTOF(commands), sizeof(commands[0]),
            mthCommandMapCompare) ;
    if (cmd != NULL) {
        assert(cmd->commandFunc != NULL) ;
        cmd->commandFunc(argc, argv) ;
    } else {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown command, \"%s\"", argv[0]) ;
    }
}
----

[source,c]
----
<<mth forward references>>=
static int mthCommandMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthCommandMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_CommandMap const *cm1 = m1 ;
    MTH_CommandMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Registering a Domain

[source,c]
----
<<mth external function declarations>>=
extern bool mth_RegisterDomain(MTH_DomainHarness const *harness) ;
----

[source,c]
----
<<mth external function definitions>>=
bool
mth_RegisterDomain(
    MTH_DomainHarness const *harness)
{
    assert(harness != NULL) ;
    assert(harness->portal != NULL) ;
    assert(harness->portal->name != NULL) ;

    MTH_DomainHarness const *const registeredHarness =
            mthFindHarness(harness->portal->name) ;

    bool inserted ;
    if (registeredHarness == NULL) {
        mthInsertHarness(harness) ;
        inserted = true ;
    } else {
        inserted = false ;
    }

    return inserted ;
}
----

[source,c]
----
<<mth implementation aggregate types>>=
typedef struct mthharnessregistry {
    unsigned count ;
    MTH_DomainHarness const *harnesses[MTH_MAX_DOMAINS] ;
} MTH_HarnessRegistry ;
----

[source,c]
----
<<mth implementation constants>>=
#ifndef MTH_MAX_DOMAINS
#   define MTH_MAX_DOMAINS  16
#endif /* MTH_MAX_DOMAINS */
----

[source,c]
----
<<mth static data>>=
MTH_HarnessRegistry mthHarnesses ;
----

[source,c]
----
<<mth forward references>>=
static MTH_DomainHarness const *const
mthFindHarness(
    char const *domainName) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_DomainHarness const *const
mthFindHarness(
    char const *domainName)
{
    assert(domainName != NULL) ;

    MTH_DomainHarness const *const *hiter = mthHarnesses.harnesses ;
    for (unsigned count = mthHarnesses.count ; count != 0 ; count--) {
        MTH_DomainHarness const *const harness = *hiter++ ;
        assert(harness->portal != NULL) ;
        assert(harness->portal->name != NULL) ;
        if (strcmp(domainName, harness->portal->name) == 0) {
            return harness ;
        }
    }
    return NULL ;
}
----

[source,c]
----
<<mth forward references>>=
static void
mthInsertHarness(
    MTH_DomainHarness const *const) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthInsertHarness(
    MTH_DomainHarness const *const harness)
{
    assert(harness != NULL) ;
    assert(mthHarnesses.count < COUNTOF(mthHarnesses.harnesses)) ;
    if (mthHarnesses.count < COUNTOF(mthHarnesses.harnesses)) {
        mthHarnesses.harnesses[mthHarnesses.count++] = harness ;
    }
}
----

=== Harness Command Functions

==== Domain Operation Command

[source,c]
----
<<mth forward references>>=
static void mthDopCommand(int, char *const *) ;
----

[literal]
--
dop <domain> <operation> ?<arg1> <arg2> ...?
--

[source,c]
----
<<mth static functions>>=
static void
mthDopCommand(
    int argc,
    char *const *argv)
{
    if (argc < 3) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, "
            "dop <domain> <operation> ?<arg1> <arg2> ...?",
            argc) ;
        return ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown domain, \"%s\"", domainName) ;
        return ;
    }

    char *opName = argv[2] ;
    MTH_OperationMap const *const opMap = mthFindOperation(harness, opName) ;
    if (opMap == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "unknown operation, \"%s\"", opName) ;
        return ;
    }
    opMap->func(argc - 2, argv + 2) ;
}
----

==== Query Command

[source,c]
----
<<mth forward references>>=
static void mthQueryCommand(int, char *const *) ;
----

[literal]
--
query domains
query classes <domain>
query attributes <domain> <class>
query instances <domain> <class>
query events <domain> <class>
query states <domain> <class>
query currentstate <domain> <class>
--

[source,c]
----
<<mth static functions>>=
static void
mthQueryCommand(
    int argc,
    char *const *argv)
{
    if (argc < 2) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, "
            "query <subcmd> ?<domain> <arg1> <arg2> ...?",
            argc) ;
        return ;
    }

    char *subcmdName = argv[1] ;
    if (strcmp(subcmdName, "domains") == 0) {
        mthQueryDomains(argc, argv) ;
    } else if (strcmp(subcmdName, "classes") == 0) {
        mthQueryClasses(argc, argv) ;
    } else if (strcmp(subcmdName, "attributes") == 0) {
        mthQueryAttrs(argc, argv) ;
    } else if (strcmp(subcmdName, "instances") == 0) {
        mthQueryInsts(argc, argv) ;
    } else {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "unknown subcommand, \"%s\": expected, "
            "\"domains | classes | attributes | instances | events "
            "| states | currentstate\"", subcmdName) ;
    }
}
----

[source,c]
----
<<mth forward references>>=
static void mthQueryDomains(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthQueryDomains(
    int argc,
    char *const *argv)
{
    mthResetContext() ;

    MTH_DomainHarness const *const *hiter = mthHarnesses.harnesses ;
    for (unsigned count = mthHarnesses.count ; count != 0 ; count--) {
        MTH_DomainHarness const *const harness = *hiter++ ;
        assert(harness->portal != NULL) ;
        assert(harness->portal->name != NULL) ;

        if (mthFormatToContext(strfmtspace, harness->portal->name) == -1) {
            mth_CmdResponse(mthErrorReturn, argv[0], truncateMsg) ;
            return ;
        }
    }
    mthTrimBufContextRight() ;
    mth_CmdResponse(mthOkReturn, argv[0], mthContextGetBuf()) ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthQueryClasses(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthQueryClasses(
    int argc,
    char *const *argv)
{
    if (argc != 3) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, \"query classes <domain>\"",
            argc) ;
        return ;
    }

    char *domainName = argv[2] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown domain, \"%s\"", domainName) ;
        return ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    mthResetContext() ;

    unsigned classCount = mrt_PortalDomainClassCount(portal) ;
    for (MRT_ClassId id = 0 ; id < classCount ; id++) {
        char const *className = NULL ;
        int pcode = mrt_PortalClassName(portal, id, &className) ;
        if (pcode == 0) {
            if (mthFormatToContext(strfmtspace, className) == -1) {
                mth_CmdResponse(mthErrorReturn, argv[0], truncateMsg) ;
                return ;
            }
        } else {
            mthPortalErrorResponse(pcode, argv[0]) ;
        }
    }

    mthTrimBufContextRight() ;
    mth_CmdResponse(mthOkReturn, argv[0], mthContextGetBuf()) ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthQueryAttrs(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthQueryAttrs(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, "
            "\"query attributes <domain> <class>\"",
            argc) ;
        return ;
    }

    char *domainName = argv[2] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown domain, \"%s\"", domainName) ;
        return ;
    }

    char *className = argv[3] ;
    MTH_ClassMap const *const classMap = mthFindClass(harness, className) ;
    if (classMap == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown class, \"%s\"", className) ;
        return ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int attrCount = mrt_PortalClassAttributeCount(portal, classId) ;
    assert(attrCount >= 0) ;
    if (attrCount < 0) {
        mthPortalErrorResponse(attrCount, argv[0]) ;
        return ;
    }

    mthResetContext() ;

    for (MRT_AttrId attrId = 0 ; attrId < attrCount ; attrId++) {
        char const *attrName = NULL ;
        int pcode = mrt_PortalClassAttributeName(portal, classId, attrId,
                &attrName) ;
        if (pcode == 0) {
            if (mthFormatToContext(strfmtspace, attrName) == -1) {
                mth_CmdResponse(mthErrorReturn, argv[0], truncateMsg) ;
                return ;
            }
        } else {
            mthPortalErrorResponse(pcode, argv[0]) ;
        }
    }

    mthTrimBufContextRight() ;
    mth_CmdResponse(mthOkReturn, argv[0], mthContextGetBuf()) ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthQueryInsts(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthQueryInsts(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, "
            "\"query instances <domain> <class>\"",
            argc) ;
        return ;
    }

    char *domainName = argv[2] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown domain, \"%s\"", domainName) ;
        return ;
    }

    char *className = argv[3] ;
    MTH_ClassMap const *const classMap = mthFindClass(harness, className) ;
    if (classMap == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown class, \"%s\"", className) ;
        return ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int instCount = mrt_PortalClassInstanceCount(portal, classId) ;
    assert(instCount >= 0) ;
    if (instCount < 0) {
        mthPortalErrorResponse(instCount, argv[0]) ;
        return ;
    }

    mthResetContext() ;
    if (mthFormatToContext("total %d named ", instCount) == -1) {
        mth_CmdResponse(mthErrorReturn, argv[0], truncateMsg) ;
        return ;
    }

    mthPushContext() ;
    MTH_InstMap const *inst = classMap->insts ;
    for (unsigned namedCount = classMap->instCount ; namedCount != 0 ;
            namedCount--, inst++) {
        if (mthAddWord(inst->name) == -1) {
            mth_CmdResponse(mthErrorReturn, argv[0], truncateMsg) ;
            return ;
        }
    }
    mthPopContext() ;
    mthTrimBufContextRight() ;

    mth_CmdResponse(mthOkReturn, argv[0], mthContextGetBuf()) ;
}
----

[source,c]
----
<<mth static data>>=
static char const truncateMsg[] = "truncated" ;
static char const strfmtspace[] = "%s " ;
----

==== Trace Command

[source,c]
----
<<mth forward references>>=
static void mthTraceCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthTraceCommand(
    int argc,
    char *const *argv)
{
    if (argc == 1) {
        MRT_TraceHandler handler = mrt_RegisterTraceHandler(NULL) ;
        mrt_RegisterTraceHandler(handler) ;
        mth_CmdResponse(mthOkReturn, argv[0], handler == NULL ? "off" : "on") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            mrt_RegisterTraceHandler(mthTraceResponse) ;
            mth_CmdResponse(mthOkReturn, argv[0], "on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            mrt_RegisterTraceHandler(NULL) ;
            mth_CmdResponse(mthOkReturn, argv[0], "off") ;
        } else {
            mth_CmdResponse(mthErrorReturn, argv[0],
                    "unknown trace option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
        }
    } else {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, \"trace ?on | off?\"", argc) ;
        return ;
    }
}
----

=== Common Functions

[source,c]
----
<<mth interface simple types>>=
typedef enum mthreturntype {
    mthOkReturn,
    mthErrorReturn
} MTH_ReturnType ;
----

[source,c]
----
<<mth implementation includes>>=
#include <stdarg.h>
----

[source,c]
----
<<mth external function declarations>>=
extern void
mth_CmdResponse(
    MTH_ReturnType returnCode,
    char const *cmdName,
    char const *resultFmt,
    ...) ;
----

[source,c]
----
<<mth external function definitions>>=
void
mth_CmdResponse(
    MTH_ReturnType returnCode,
    char const *cmdName,
    char const *resultFmt,
    ...)
{
    va_list resultArgs ;
    va_start(resultArgs, resultFmt) ;

    static char resultBuf[BUFSIZ] ;
    int n = vsnprintf(resultBuf, sizeof(resultBuf), resultFmt, resultArgs) ;

    va_end(resultArgs) ;

    if (n < 0) {
        strcpy(resultBuf, "error formating response") ;
    } else if (n >= sizeof(resultBuf)) {
        strcpy(resultBuf, "response truncated") ;
    }

    static char preamble[] = "cmd {" ;
    static char postamble[] = "}\n" ;
    static char nameKey[] = "name" ; // N.B. no leading blank, it's first.
    static char returnKey[] = " return" ;
    static char resultKey[] = " result" ;
    static char unQuotedFmt[] = " %s" ;
    static char quotedFmt[] = " {%s}" ;

    char fmt[sizeof(preamble) +
            sizeof(postamble) +
            sizeof(nameKey) +
            sizeof(returnKey) +
            sizeof(mthErrorReturn) +
            sizeof(resultKey) +
            3 * sizeof(quotedFmt) +
            1] ; // +1 for NUL terminator
    strcpy(fmt, preamble) ;

    strcat(fmt, nameKey) ;
    strcat(fmt, mth_QuoteWord(cmdName) ? quotedFmt : unQuotedFmt) ;

    static char const mthOkValue[] = " ok" ;
    static char const mthErrorValue[] = " error" ;
    strcat(fmt, returnKey) ;
    strcat(fmt, returnCode == mthOkReturn ? mthOkValue : mthErrorValue) ;

    strcat(fmt, resultKey) ;
    strcat(fmt, mth_QuoteWord(resultBuf) ? quotedFmt : unQuotedFmt) ;

    strcat(fmt, postamble) ;

    fprintf(mthCmdStream, fmt, cmdName, resultBuf) ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthTraceResponse(MRT_TraceInfo const *) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthTraceResponse(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
        char const *newStateName ;
        if (newState == MRT_StateCode_IG) {
            newStateName = "IG" ;
        } else if (newState == MRT_StateCode_CH) {
            newStateName = "CH" ;
        } else {
            newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.newState] ;
        }

        fprintf(mthCmdStream,
                "trace {"
                "type transition "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "currstate %s "
                "newstate %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.currentState],
            newStateName,
            mthTimestamp()) ;
    }
        break ;

    case mrtPolymorphicEvent: {
        MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
                genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
        MRT_Class const *subclass ;
        char const *subname = NULL ;
        if (rel->relType == mrtRefGeneralization) {
            subclass = rel->relInfo.refGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
            subname = subclass->name ;
        } else if (rel->relType == mrtUnionGeneralization) {
            subclass = rel->relInfo.unionGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode] ;
            subname = subclass->name ;
        } else {
            printf("%s: bad relationship type in polymorphic event, %d\n",
                mthTimestamp(), rel->relType) ;
            break ;
        }
        fprintf(mthCmdStream,
                "trace {"
                "type polymorphic "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "relationship %s "
                "newevent %s "
                "subclass %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->pdb->genNames[
                traceInfo->info.polyTrace.genNumber],
            subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
            subname,
            mthTimestamp()) ;
    }
        break ;

    case mrtCreationEvent:
        fprintf(mthCmdStream,
                "trace {"
                "type creation "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->info.creationTrace.targetClass->name, targetName,
            mthTimestamp()) ;
        break ;

    default:
        fprintf(mthCmdStream,
                "trace {"
                "type error "
                "result {unknown trace event type, \"%u\"} "
                "time %s"
                "}\n",
            traceInfo->eventType,
            mthTimestamp()) ;
        break ;
    }
}
----

[source,c]
----
<<mth external function declarations>>=
extern void
mth_InstrResponse(
    char const *,
    char const *,
    ...) ;
----

[source,c]
----
<<mth static functions>>=
void
mth_InstrResponse(
    char const *resultKey,
    char const *resultFmt,
    ...)
{
    va_list resultArgs ;
    va_start(resultArgs, resultFmt) ;

    static char resultBuf[BUFSIZ] ;
    int n = vsnprintf(resultBuf, sizeof(resultBuf), resultFmt, resultArgs) ;

    va_end(resultArgs) ;

    if (n < 0) {
        strcpy(resultBuf, "error formating response") ;
    } else if (n >= sizeof(resultBuf)) {
        strcpy(resultBuf, "response truncated") ;
    }

    static char preamble[] = "instr {" ;
    static char postamble[] = "}\n" ;
    static char unQuotedFmt[] = " %s" ;
    static char quotedFmt[] = " {%s}" ;

    char fmt[sizeof(preamble) +
            sizeof(postamble) +
            2 * sizeof(quotedFmt) +
            1] ; // +1 for NUL terminator
    strcpy(fmt, preamble) ;
    strcat(fmt, mth_QuoteWord(resultKey) ? "{%s}" : "%s") ;
    strcat(fmt, mth_QuoteWord(resultBuf) ? quotedFmt : unQuotedFmt) ;
    strcat(fmt, postamble) ;

    fprintf(mthCmdStream, fmt, resultKey, resultBuf) ;
}
----

[source,c]
----
<<mth forward references>>=
static void
mthPortalErrorResponse(
    int portalCode,
    char *cmdName) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthPortalErrorResponse(
    int portalCode,
    char *cmdName)
{
    static char const *const portalErrNames[] = {
        "no error",             // place holder for 0
        "no such class",        // MICCA_PORTAL_NO_CLASS
        "no such instance",     // MICCA_PORTAL_NO_INST
        "no such attribute",    // MICCA_PORTAL_NO_ATTR
        "instance slot is not in use", // MICCA_PORTAL_UNALLOC
        "class has no state model", // MICCA_PORTAL_NO_STATE_MODEL
        "no such event for the class", // MICCA_PORTAL_NO_EVENT
        "no such state for the class", // MICCA_PORTAL_NO_STATE
        "class does not support dynamic instances", // MICCA_PORTAL_NO_DYNAMIC
        "operation not allowed on a dependent attribute", // MICCA_PORTAL_DEPENDENT_ATTR
        "value was truncated due to lack of space", // MICCA_PORTAL_TRUNCATED
    } ;

    portalCode = -portalCode ;
    assert(portalCode < COUNTOF(portalErrNames)) ;
    char const *const errMsg = portalCode < COUNTOF(portalErrNames) ?
            portalErrNames[portalCode] : "unknown portal error" ;

    mth_CmdResponse(mthErrorReturn, cmdName, errMsg) ;
}
----

[source,c]
----
<<mth forward references>>=
static char const *mthTimestamp(void) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <sys/time.h>
#include <time.h>
----

[source,c]
----
<<mth static functions>>=
static char const *
mthTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "too big" ;
    }

    return timestamp ;
}
----

[source,c]
----
<<mth external function declarations>>=
extern bool mth_QuoteWord(char const *) ;
----

[source,c]
----
<<mth external function definitions>>=
bool
mth_QuoteWord(
    char const *pWord)
{
    assert(pWord != NULL) ;
    int wlen = strlen(pWord) ;

    for (char c = *pWord++ ; c != ASCII_NUL ; c = *pWord++) {
        if (isspace(c) || c == '\\' || c == '\"') {
            return true ;
        }
    }

    return wlen == 0 ? true : false ;
}
----

=== Buffer Context

[source,c]
----
<<mth implementation aggregate types>>=
typedef struct mthbufcontext {
    char buf[BUFSIZ] ;
    char *location ;
    size_t remaining ;
} MTH_BufContext ;
----

[source,c]
----
<<mth implementation constants>>=
#ifndef MTH_NESTLIMIT
#   define  MTH_NESTLIMIT   4
#endif /* MTH_NESTLIMIT */
<<mth static data>>=
static MTH_BufContext contextStack[MTH_NESTLIMIT] ;
static MTH_BufContext *contextTOS ;
----

[source,c]
----
<<mth forward references>>=
static void
mthResetContext(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthResetContext(void)
{
    contextTOS = contextStack ;
    mthInitBufContext() ;
}
----

[source,c]
----
<<mth forward references>>=
static void
mthPushContext(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthPushContext(void)
{
    assert(contextTOS != NULL) ;
    assert(contextTOS < contextStack + COUNTOF(contextStack)) ;
    if (contextTOS >= contextStack + COUNTOF(contextStack)) {
        fprintf(stderr, "buffer context stack overflow\n") ;
        abort() ;
    }
    contextTOS++ ;
    mthInitBufContext() ;
}
----

[source,c]
----
<<mth forward references>>=
static void
mthPopContext(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthPopContext(void)
{
    assert(contextTOS > contextStack) ;
    if (contextTOS <= contextStack) {
        fprintf(stderr, "buffer context stack underflow\n") ;
        abort() ;
    }

    mthTrimBufContextRight() ;
    char *prevBuf = mthContextGetBuf() ;
    contextTOS -= 1 ;
    mthAddWord(prevBuf) ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthInitBufContext(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthInitBufContext(void)
{
    assert(contextTOS != NULL) ;
    contextTOS->location = contextTOS->buf ;
    *contextTOS->location = ASCII_NUL ;
    contextTOS->remaining = sizeof(contextTOS->buf) ;
}
----

[source,c]
----
<<mth forward references>>=
static int
mthFormatToContext(
    char const *format,
    ...) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthFormatToContext(
    char const *format,
    ...)
{
    va_list params ;
    va_start(params, format) ;
    int nbytes = vsnprintf(contextTOS->location, contextTOS->remaining,
            format, params) ;
    va_end(params) ;

    if (nbytes < 0 || nbytes >= contextTOS->remaining) {
        return -1 ;
    } else {
        contextTOS->remaining -= nbytes ;
        contextTOS->location += nbytes ;
    }

    return nbytes ;
}
----

[source,c]
----
<<mth forward references>>=
static int
mthAddWord(
    char const *word) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthAddWord(
    char const *word)
{
    int nbytes = snprintf(contextTOS->location, contextTOS->remaining,
            mth_QuoteWord(word) ? "{%s} " : "%s ", word) ;

    if (nbytes < 0 || nbytes >= contextTOS->remaining) {
        return -1 ;
    } else {
        contextTOS->remaining -= nbytes ;
        contextTOS->location += nbytes ;
    }

    return nbytes ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthTrimBufContextRight(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthTrimBufContextRight(void)
{
    while (contextTOS->location > contextTOS->buf) {
        if (isspace(*(contextTOS->location - 1))) {
            *--contextTOS->location = ASCII_NUL ;
        } else {
            break ;
        }
    }
}
----

[source,c]
----
<<mth forward references>>=
static inline char *mthContextGetBuf(void) ;
----

[source,c]
----
<<mth static functions>>=
static inline char *
mthContextGetBuf(void)
{
    return contextTOS->buf ;
}
----

== Generating a Test Harness

[source,tcl]
----
<<micca configuration>>=
operation harness {} {
    return [@Harness@::miccaHarness]
}
----

[source,tcl]
----
<<generation commands namespace>>=
namespace eval @Harness@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<harness data>>
    <<harness commands>>
}
----

[source,tcl]
----
<<harness commands>>=
proc miccaHarness {} {
    <<miccaHarness: set up template expansion>>

    set harnessfiles [list]

    <<miccaHarness: generate harness files>>

    return $harnessfiles
}
----

[source,tcl]
----
<<miccaHarness: set up template expansion>>=
textutil::expander harnessExpand
harnessExpand errmode fail
----

[source,tcl]
----
<<miccaHarness: generate harness files>>=
try {
    variable domain
    forAllRefs domainRef [Domain findAll] {
        assignAttribute $domainRef {Name domain}

        lappend harnessfiles ${domain}_harness.c
        <<miccaHarness: generate file>>
    }
} finally {
    rename harnessExpand {}
}
----

[source,tcl]
----
<<miccaHarness: generate file>>=

harnessExpand evalcmd "namespace eval [namespace current]"
set hchan [::open ${domain}_harness.c w]
try {
    variable harnessTemplate
    puts $hchan [harnessExpand expand $harnessTemplate]
} on error {result opts} {
    puts $::errorInfo
    return -options $opts $result
} finally {
    chan close $hchan
}
----

[source,tcl]
----
<<harness data>>=
set harnessTemplate [textutil::adjust::undent {
    [banner]
    /*
     * Include Files
     */
    #include "micca_tack.h"
    [domainInclude]
    /*
     * Static Data
     */
    [staticData]
    /*
     * Domain Operation Functions
     */
    [opFuncDefinitions]
    /*
     * Domain Operations Map
     */
    [opMapDefinition]
    /*
     * Domain Attribute Read Functions
     */
    [attrReadFuncDefinitions]
    /*
     * Domain Attribute Update Functions
     */
    [attrUpdateFuncDefinitions]
    /*
     * Domain Attributes Map
     */
    [attrMapDefinitions]
    /*
     * Domain Instances Map
     */
    [instMapDefinitions]
    /*
     * Domain Event Parameter Functions
     */
    [eventParamFuncDefinitions]
    /*
     * Domain Event Map
     */
    [eventMapDefinitions]
    /*
     * Domain Classes Map
     */
    [classMapDefinition]
    /*
     * Harness Definition
     */
    [harnessDefinition]
}]
----

=== Template Commands
[source,tcl]
----
<<harness commands>>=
    
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,tcl]
----
<<harness commands>>=
proc staticData {} {
    append result\
        "static char emptyString\[\] = \"\" ;\n"\
        "static char wrongNumArgsMsg\[\] = \"wrong # arguments, %d\" ;\n"\
        "static char badParamMsg\[\] = \"bad parameter, \\\"%s\\\"\" ;\n"\
        "static char badTypeMsg\[\] = \"bad type, \\\"%s\\\"\" ;\n"
}
----

[source,tcl]
----
<<harness commands>>=
proc opFuncDefinitions {} {
    variable domain

    set opRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R5
    } {} |%]

    set result {}
    forAllRefs opRef $opRefs {
        assignAttribute $opRef {Name opName} {ReturnDataType retType}
        append result\
            "static void ${opName}__OPFUNC(\n"\
            "    int argc,\n"\
            "    char *const *argv)\n"\
            "\{\n"\

        set paramRefs [deRef [findRelated $opRef ~R6]]
        set nparams [expr {[relation cardinality $paramRefs] + 1}]
        append result\
            "    if (argc != $nparams) \{\n"\
            "        mth_CmdResponse(mthErrorReturn, argv\[0],\
                        wrongNumArgsMsg, argc) ;\n"\
            "        return ;\n"\
            "    \}\n"

        set argIndex 1
        relation foreach paramRef $paramRefs -ascending Number {
            relation assign $paramRef {DataType type} {Name paramName}
            append result\
                "    [typeCheck composeDeclaration $type $paramName] ;\n"
            try {
                set scnfmt [GetFormat $type Scan]
            } on error {fmtresult} {
                log::error $fmtresult
                append result\
                    "    // cannot input type, \"$type\"\n"\
                    "    mth_CmdResponse(mthErrorReturn, argv\[0],\
                                badTypeMsg, \"$type\") ;\n"\
                    "    return ;\n"\
                    "\}\n"
                break
            }
            if {$scnfmt ne {}} {
                append result\
                    "    if (sscanf(argv\[$argIndex\], \"%\" $scnfmt, "\
                    "&$paramName) != 1) \{\n"\
                    "        mth_CmdResponse(mthErrorReturn, argv\[0],\
                                badParamMsg, argv\[$argIndex]) ;\n"\
                    "        return ;\n"\
                    "    \}\n"
            } else {
                append result "    $paramName = argv\[$argIndex\] ;\n"
            }

            incr argIndex ;
        }

        set invokeParams [pipe {
            relation list $paramRefs Name -ascending Number |
            join ~ {, }
        }]

        try {
            set prifmt [GetFormat $retType Print]
        } on error {fmtresult} {
            log::error $fmtresult
            append result\
                "    // cannot output type, \"$retType\"\n"\
                "    mth_CmdResponse(mthErrorReturn, argv\[0],\
                            badTypeMsg, \"$retType\") ;\n"\
                "    return ;\n"\
                "\}\n"
            continue
        }

        set invocation "${domain}_${opName}($invokeParams) ;\n"
        if {$retType ne "void"} {
            append result\
                "    [typeCheck composeDeclaration $retType result__OP] = "\
                $invocation\
                "    mth_CmdResponse(mthOkReturn, argv\[0], \"%\" $prifmt,\
                        result__OP) ;\n"
        } else {
            append result\
                "    $invocation"\
                "    mth_CmdResponse(mthOkReturn, argv\[0], emptyString) ;\n"
        }

        append result "\}\n"\
    }

    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc opMapDefinition {} {
    variable domain

    set opRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R5 |
        deRef %
    } {} |%]

    set result {}
    if {[relation isnotempty $opRefs]} {
        append result\
            "static MTH_OperationMap const "\
            "${domain}__OPMAP\[[relation cardinality $opRefs]\] = \{\n"

        relation foreach opRef $opRefs -ascending Name {
            relation assign $opRef Name
            append result\
                "    \{\n"\
                "        .name = \"$Name\",\n"\
                "        .func = ${Name}__OPFUNC\n"\
                "    \},\n"
        }

        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc attrReadFuncDefinitions {} {
    variable domain

    set attrRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R20 {~R25 PopulatedComponent}\
            {~R21 Attribute}
    } {} |%]

    set result {}
    forAllRefs attrRef $attrRefs {
        assignAttribute $attrRef {Class className} {Name attrName}\
            {DataType type} {Dimension dim}
        append result\
            "static int ${className}_${attrName}__RD(\n"\
            "    MRT_DomainPortal const *portal,\n"\
            "    MRT_ClassId classId,\n"\
            "    MRT_InstId instId,\n"\
            "    MRT_AttrId attrId,\n"\
            "    char *buf,\n"\
            "    size_t bufsize)\n"\
            "\{\n"

        try {
            set prifmt [GetFormat $type Print]
        } on error {fmtresult} {
            log::error $fmtresult
            append result\
                "    // cannot output type, \"$type\"\n"\
                "    return 0 ;\n"\
                "\}\n"
            continue
        }

        set vardecl [typeCheck composeDeclaration $type attrValue]
        if {$dim > 0} {
            append vardecl \[$dim\]
            set vardeclptr attrValue
        } else {
            set vardeclptr &attrValue
        }

        append result\
            "    $vardecl ;\n"\
            "    int pcode = mrt_PortalReadAttr(portal, classId, instId,\
                    attrId, $vardeclptr, sizeof(attrValue)) ;\n"\
            "    if (pcode < 0) \{\n"\
            "        return pcode ;\n"\
            "    \}\n"

        if {$type eq "char" && $dim > 0} {
            # just an ordinary string
            # Figure out if it needs to be quoted
            set last [expr {$dim - 1}]
            append result\
                "    bool doquote = mth_QuoteWord(attrValue) ;\n"\
                "    return snprintf(buf, bufsize,\
                    doquote ? \"\{%s\}\" : \"%s\", attrValue) ;\n"
        } else {
            if {$dim == 0} {
                # ordinary scalar value
                append result\
                    "    return snprintf(buf, bufsize,\
                            \"%\" $prifmt, attrValue) ;\n"
            } else {
                # attribute is an array
                append result\
                    "    int outbytes = 0 ;\n"\
                    "    size_t remain = bufsize ;\n"\
                    "    int nbytes = snprintf(buf, remain, \"\{\") ;\n"\
                    "    if (nbytes < 0 || nbytes >= remain) \{\n"\
                    "        return bufsize ;\n"\
                    "    \} else \{\n"\
                    "        remain -= nbytes ;\n"\
                    "        buf += nbytes ;\n"\
                    "        outbytes += nbytes ;\n"\
                    "    \}\n"\
                    "    for (int index = 0 ; index < $dim ; index++) \{\n"\
                    "        nbytes = snprintf(buf, remain,\
                        \"%\" $prifmt \" \", attrValue\[index\]) ;\n"\
                    "        if (nbytes < 0 || nbytes >= remain) \{\n"\
                    "            return bufsize ;\n"\
                    "        \} else \{\n"\
                    "            remain -= nbytes ;\n"\
                    "            buf += nbytes ;\n"\
                    "            outbytes += nbytes ;\n"\
                    "        \}\n"\
                    "    \}\n"\
                    "    *(buf - 1) = \'\}\' ;\n"\
                    "    return outbytes ;\n"\
            }
        }
        append result "\}\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc attrUpdateFuncDefinitions {} {
    variable domain

    set attrRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R20 {~R25 PopulatedComponent}\
            {~R21 Attribute}
    } {} |%]

    set result {}
    forAllRefs attrRef $attrRefs {
        assignAttribute $attrRef {Class className} {Name attrName}\
            {DataType type} {Dimension dim}

        set vardecl [typeCheck composeDeclaration $type attrValue]
        append result\
            "static int ${className}_${attrName}__UP(\n"\
            "    MRT_DomainPortal const *portal,\n"\
            "    MRT_ClassId classId,\n"\
            "    MRT_InstId instId,\n"\
            "    MRT_AttrId attrId,\n"\
            "    char const *value)\n"\
            "\{\n"

        if {$type eq "char" && $dim > 0} {
            # attribute is an ordinary string
            append result\
                "    return mrt_PortalUpdateAttr(portal, classId, instId,\
                        attrId, value, strlen(value) + 1) ;\n"
        } else {
            set vardecl [typeCheck composeDeclaration $type convertedValue]
            try {
                set scnfmt [GetFormat $type Scan]
            } on error {fmtresult} {
                log::error $fmtresult
                append result\
                    "    // cannot input type, \"$type\"\n"\
                    "    return 0 ;\n"\
                    "\}\n"
                continue
            }
            if {$dim == 0} {
                append result\
                    "    $vardecl ;\n"\
                    "    int nitems = sscanf(value, \"%\" $scnfmt,\
                        &convertedValue) ;\n"\
                    "    return nitems == 1 ?\n"\
                    "        mrt_PortalUpdateAttr(portal, classId, instId,\
                        attrId, &convertedValue, sizeof(convertedValue)) :\
                        0 ;\n"
            } else {
                set format "\" \" [string repeat "\"%\" $scnfmt \" \" " $dim]"
                for {set index 0} {$index < $dim} {incr index} {
                    append valuerefs ", &convertedValue\[$index\]"
                }
                append result\
                    "    $vardecl\[$dim\] ;\n"\
                    "    int nitems = sscanf(value, $format $valuerefs) ;\n"\
                    "    return nitems == $dim ?\n"\
                    "        mrt_PortalUpdateAttr(portal, classId, instId,\
                        attrId, convertedValue, sizeof(convertedValue)) :\
                        0 ;\n"
            }
        }
        append result "\}\n"\
    }

    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc attrMapDefinitions {} {
    variable domain

    set attrRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R20 {~R25 PopulatedComponent}\
                {~R21 Attribute} |
        deRef % |
        relation group % Attributes Name DataType Dimension
    } {} |%]

    set result {}
    relation foreach attrRef $attrRefs {
        relation assign $attrRef {Class className} Attributes
        set nAttrs [relation cardinality $Attributes]
        append result "static MTH_AttrMap const\
                ${className}__ATTRMAP\[$nAttrs\] = \{\n"
        set attrNum -1
        relation foreach attr $Attributes -ascending Name {
            relation assign $attr {Name attrName} {DataType type}
            set rdFuncName ${className}_${attrName}__RD
            set upFuncName ${className}_${attrName}__UP
            append result\
                "    \{\n"\
                "        .name = \"$attrName\",\n"\
                "        .id = [incr attrNum],\n"\
                "        .readFunc = $rdFuncName,\n"\
                "        .updateFunc = $upFuncName,\n"\
                "    \},\n"
        }
        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc eventParamFuncDefinitions {} {
    variable domain

    set eventRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R51 R50 ~R87 R80 |
        deRef % |
        relation join % $::micca::ParameterSignature |
        relation eliminate % Number ASigID |
        relation join % $::micca::Parameter |
        relation eliminate % PSigID |
        relation join % $::micca::Argument |
        relation group % Params ASigID Name Position DataType |
        relation group % Events Event Params
    } {} |%]
    # puts [relformat $eventRefs eventRefs]

    set result {}
    set typeError false
    relation foreach eventRef $eventRefs {
        relation assign $eventRef {Model className} Events
        relation foreach event $Events {
            relation assign $event {Event eventName} Params
            set nParams [relation cardinality $Params]
            append result\
                "static bool\n"\
                "${className}_${eventName}__EPFUNC(\n"\
                "    int paramc,\n"\
                "    char const **paramv,\n"\
                "    MRT_EventParams parambuf)\n"\
                "\{\n"\
                "    if (paramc != $nParams) \{\n"\
                "        return false ;\n"\
                "    \}\n"

            set structName ${domain}_${className}_${eventName}__EPARAMS
            append result\
                "    struct $structName *params =\
                        (struct $structName *)parambuf ;\n"\
                "    int nitems ;\n"

            set pindex 0
            relation foreach param $Params -ascending Position {
                relation assign $param {Name paramName} {DataType type}
                try {
                    set scnfmt [GetFormat $type Scan]
                } on error {fmtresult} {
                    log::error $fmtresult
                    append result\
                        "    // cannot input type, \"$type\"\n"\
                        "    return false ;\n"\
                        "\}\n"
                    set typeError true
                    continue
                }
                append result\
                    "    nitems = sscanf(paramv\[$pindex\], \"%\" $scnfmt,\
                        &params->$paramName) ;\n"\
                    "    if (nitems != 1) \{\n"\
                    "        return false ;\n"\
                    "    \}\n"

                incr pindex
            }

            if {!$typeError} {
                append result\
                    "    return true ;\n"\
                    "\}\n"
            }
        }
    }
    return $result
}
----

typedef bool MTH_EventParamFunc(int, char const **, MRT_EventParams) ;

[source,tcl]
----
<<harness commands>>=
proc eventMapDefinitions {} {
    variable domain

    set eventRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R51 R50 ~R87 R80 |
        deRef % |
        relation group % Events Event Number PSigID
    } {} |%]

    set result {}
    relation foreach eventRef $eventRefs {
        relation assign $eventRef {Model className} Events
        set nEvents [relation cardinality $Events]
        append result "static MTH_EventMap const\
                ${className}__EVENTMAP\[$nEvents\] = \{\n"
        relation foreach event $Events -ascending Event {
            relation assign $event {Event eventName} {Number eventNumber} PSigID
            set funcName [expr {$PSigID ne {} ?\
                "${className}_${eventName}__EPFUNC" : "NULL"}]
            append result\
                "    \{\n"\
                "        .name = \"$eventName\",\n"\
                "        .number = $eventNumber,\n"\
                "        .paramFunc = $funcName\n"\
                "    \},\n"
        }
        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc instMapDefinitions {} {
    variable domain

    set instRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R20 ~R103 |
        deRef % |
        relation group % Instances Instance Number
    } {} |%]

    set result {}
    relation foreach instRef $instRefs {
        relation assign $instRef {Class className} Instances
        set nInsts [relation cardinality $Instances]
        append result "static MTH_InstMap const\
                ${className}__INSTMAP\[$nInsts\] = \{\n"
        relation foreach inst $Instances -ascending Instance {
            relation assign $inst {Instance instName} {Number instId}
            append result\
                "    \{\n"\
                "        .name = \"$instName\",\n"\
                "        .id = $instId\n"\
                "    \},\n"
        }
        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc classMapDefinition {} {
    variable domain

    set classRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} |
        deRef %
    } {} |%]

    set result {}
    if {[relation isnotempty $classRefs]} {
        append result\
            "static MTH_ClassMap const "\
            "${domain}__CLASSMAP\[[relation cardinality $classRefs]\] = \{\n"

        relation foreach ref $classRefs -ascending Name {
            set classRef [::rosea::Helpers::ToRef ::micca::Class $ref]
            assignAttribute $classRef {Name className} {Number classId}

            set compRefs [findRelated $classRef ~R20]

            set attrRefs [findRelated $compRefs {~R25 PopulatedComponent}\
                {~R21 Attribute}]
            set attrMap [expr {[isNotEmptyRef $attrRefs] ?\
                "${className}__ATTRMAP" : "NULL"}]

            set instRefs [findRelated $compRefs ~R103]
            set instMap [expr {[isNotEmptyRef $instRefs] ?\
                "${className}__INSTMAP" : "NULL"}]

            set eventRefs [findRelated $classRef ~R51 R50 ~R87 R80]
            set eventMap [expr {[isNotEmptyRef $eventRefs] ?\
                "${className}__EVENTMAP" : "NULL"}]

            append result\
                "    \{\n"\
                "        .name = \"$className\",\n"\
                "        .id = $classId,\n"\
                "        .attrs = $attrMap,\n"\
                "        .attrCount = [refMultiplicity $attrRefs],\n"\
                "        .insts = $instMap,\n"\
                "        .instCount = [refMultiplicity $instRefs],\n"\
                "        .events = $eventMap,\n"\
                "        .eventCount = [refMultiplicity $eventRefs],\n"\
                "    \},\n"
        }

        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc harnessDefinition {} {
    variable domain

    append result\
        "extern MRT_DomainPortal const ${domain}__PORTAL ;\n\n"\
        "MTH_DomainHarness const ${domain}__HARNESS = \{\n"\
        "    .portal = &${domain}__PORTAL,\n"

    set domainRef [Domain findWhere {$Name eq $domain}]
    set opRefs [findRelated $domainRef ~R5]
    set opsMap [expr {[isNotEmptyRef $opRefs] ?\
            "${domain}__OPMAP" : "NULL"}]
    append result\
        "    .operations = $opsMap,\n"\
        "    .operationCount = [refMultiplicity $opRefs],\n"

    set classRefs [findRelated $domainRef ~R1 {~R2 Class}]
    set classMap [expr {[isNotEmptyRef $classRefs] ?\
            "${domain}__CLASSMAP" : "NULL"}]
    append result\
        "    .classes = $classMap,\n"\
        "    .classCount = [refMultiplicity $classRefs],\n"
    append result "\} ;\n"
}
----

ifdef::showtests[]
[source,tcl]
----
<<harness command tests>>=
test harness-1.0 {
    Generate harness data structure
} -setup {
    validateutils genMiccaFile harness1 {
        domain harness1 {
            class X {
                attribute temp uint32_t -default 20
                attribute color char -dimension 20 -default {"red"}
                attribute status int -dimension 3 -default {{0 1 2}}

                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    transition s1 - e1 -> s2
                    state s2 {a int b unsigned} {
                        printf("in s2\n") ;
                    }
                    transition s2 - e2 -> s1
                }
            }

            domainop void init {a int b {char *}} {
                printf("initialized\n") ;
            }

            domainop int get5 {} {
                return 5 ;
            }
        }
        population harness1 {
            class X {
                instance x1
                instance x2
            }
        }
    } harness true
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles harness1_harness.c
    validateutils matchLines harness1_harness.c {
        extern MRT_DomainPortal const harness1__PORTAL ;

        MTH_DomainHarness const harness1__HARNESS = {
            .portal = &harness1__PORTAL,
            .operations = harness1__OPMAP,
            .operationCount = 2,
            .classes = harness1__CLASSMAP,
            .classCount = 1,
        } ;
    }
} -result {1}
----

=== Helper Commands

[source,tcl]
----
<<harness data>>=
# Create a simple map that maps "C" implementation types onto
# printf/scanf format strings.
relvar create FormatMap {
    ImplType string
    Print string
    Scan string
} ImplType

relvar set FormatMap [relation table {
    ImplType string             Print string         Scan  string   } {
    int                         {"d"}                {"i"}              } {
    unsigned                    {"u"}                {"i"}              } {
    {unsigned int}              {"u"}                {"i"}              } {
    short                       {"hd"}               {"hi"}             } {
    {short int}                 {"hd"}               {"hi"}             } {
    {unsigned short}            {"hu"}               {"hi"}             } {
    {unsigned short int}        {"hu"}               {"hi"}             } {
    long                        {"ld"}               {"li"}             } {
    {long int}                  {"ld"}               {"li"}             } {
    {unsigned long}             {"lu"}               {"li"}             } {
    {unsigned long int}         {"lu"}               {"li"}             } {
    size_t                      {"lu"}               {"li"}             } {
    {long long}                 {"lld"}              {"lli"}            } {
    {long long int}             {"lld"}              {"lli"}            } {
    {unsigned long long}        {"llu"}              {"lli"}            } {
    {unsigned long long int}    {"llu"}              {"lli"}            } {
    {char *}                    {"s"}                {}                 } {
    {char const *}              {"s"}                {}                 } {
    {const char *}              {"s"}                {}                 } {
    {void *}                    {"p"}                {"p"}              } {
    {const void *}              {"p"}                {"p"}              } {
    {void const *}              {"p"}                {"p"}              } {
    float                       {"g"}                {"g"}              } {
    double                      {"lg"}               {"lg"}             } {
    {long double}               {"Lg"}               {"Lg"}             } {
    char                        {"hhd"}              {"hhi"}            } {
    {unsigned char}             {"hhu"}              {"hhi"}            } {
    void                        void                 {}                 } {
    bool                        {"u"}                {"u"}              } {
    uint8_t                     PRIu8                SCNi8              } {
    uint16_t                    PRIu16               SCNi16             } {
    uint32_t                    PRIu32               SCNi32             } {
    uint64_t                    PRIu64               SCNi64             } {
    int8_t                      PRId8                SCNi8              } {
    int16_t                     PRId16               SCNi16             } {
    int32_t                     PRId32               SCNi32             } {
    int64_t                     PRId64               SCNi64             } {
    intmax_t                    PRIdMAX              SCNiMAX            } {
    uintmax_t                   PRIuMAX              SCNiMAX            } {
    MRT_ClassId                 {"hu"}               {"hi"}             } {
    MRT_AssignerId              {"hu"}               {"hi"}             } {
    MRT_InstId                  {"hu"}               {"hi"}             } {
    MRT_AttrId                  {"hu"}               {"hi"}             } {
    MRT_AttrSize                {"lu"}               {"li"}             } {
    MRT_AttrOffset              {"lu"}               {"li"}             } {
    MRT_DelayTime               PRIu32               SCNi32             } {
    MRT_EventCode               PRIu8                SCNi8              } {
    MRT_StateCode               PRId8                SCNi8              } ]
----

[source,tcl]
----
<<harness commands>>=
proc GetFormat {implType which} {
    variable domain

    set fmt [relvar restrictone FormatMap ImplType $implType]
    if {[relation isempty $fmt]} {
        set alias [TypeAlias findById Domain $domain TypeName $implType]
        if {[isEmptyRef $alias]} {
            error "unknown data type, $implType"
        }
        set tdef [readAttribute $alias TypeDefinition]
        set fmt [relvar restrictone FormatMap ImplType $tdef]
        if {[relation isempty $fmt]} {
            error "unknown data type, $implType aliased to $tdef"
        }
    }
    return [relation extract $fmt $which]
}
----

== Tack Code Organization

Place holder.

=== Tack Header File

[source,c]
----
<<micca_tack.h>>=
/*
<<copyright info>>
*
<<version info>>
*
*/

#ifndef MICCA_HARNESS_H_
#define MICCA_HARNESS_H_

/*
 * Include Files
 */
#include "micca_rt.h"
<<mth interface includes>>

/*
 * Preprocessor Defines
 */
<<mth interface defines>>

/*
 * Constants
 */
<<mth interface constants>>

/*
 * Data Types
 */
<<mth interface simple types>>
<<mth interface aggregate types>>

/*
 * Static Inline Functions
 */
<<mth interface static inlines>>

/*
 * External Functions
 */
<<mth external function declarations>>

#endif /* MICCA_HARNESS_H_ */
----

=== Harness Code File

[source,c]
----
<<micca_tack.c>>=
/*
<<copyright info>>
*
<<version info>>
*
*/

/*
 * Include Files
 */
#define _POSIX_C_SOURCE 200112L
#include "micca_tack.h"
<<mth implementation includes>>

/*
 * Macros
 */
#ifndef NDEBUG
#   define  dbgprintf(...)    printf(__VA_ARGS__)
#else
#   define  dbgprintf(...)
#endif /* NDEBUG */

#define ASCII_NUL       '\0'
#define BEGIN_QUOTE     '{'
#define END_QUOTE       '}'
#define ESCAPE_CHAR     '\\'

#define OutOfWord   0
#define InWord      1
#define InEscape    2
#define InQuote     3

/*
 * Constants
 */
<<mth implementation constants>>

/*
 * Data Types
 */
<<mth implementation simple types>>
<<mth implementation aggregate types>>

/*
 * Forward References
 */
<<mth forward references>>

/*
 * Static Data
 */
<<mth static data>>

/*
 * Static Inline Functions
 */
<<mth implementation static inlines>>

/*
 * Static Functions
 */
<<mth static functions>>

/*
 * External Functions
 */
<<mth external function definitions>>
----
