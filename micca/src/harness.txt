// vim:set syntax=asciidoc:

= Generating a Test Harness

[partintro]
.Generating a Test Harness
--
The `micca` run-time is capable of executing in a POSIX environment.
This is intended primarily to be able to simulate and integrate
a system that is ultimately targeted for a micro-processor in an
environment that has more capability for testing and introspection.
To support this important activity,
`micca` can automatically generate a test harness in which one or
more domains may be run.
--

== Introduction

Place holder.

== Test Harness Operation

Place holder.

=== Harness Data Structures

Place holder.

==== Domain Harness Information

Each domain is well encapsulated and stands alone.
The test harness will resolve to which domain an operation is directed
and then will need the information about that domain to carry out
the operation.

One of the most important pieces of information is the
domain portal data that `micca` generates.
This provides much information to the test harness and provides the
means, via the
<<portal-access-functions>>
of the run-time,
to access the various aspects of a domain, _e.g._ send events and read
attributes.

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthdomainharness {
    MRT_DomainPortal const *portal ;
    struct mthoperationmap const *const operations ;
    unsigned operationCount ;
    struct mthclassmap const *const classes ;
    unsigned classCount ;
} MTH_DomainHarness ;
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthoperationmap {
    char const *name ;
    MTH_DomainOpFunc *func ;
} MTH_OperationMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef bool MTH_DomainOpFunc(int, char *const *) ;
----

[source,c]
----
<<mth forward references>>=
static MTH_OperationMap const *const
mthFindOperation(
    MTH_DomainHarness const *const harness,
    char const *opName) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_OperationMap const *const
mthFindOperation(
    MTH_DomainHarness const *const harness,
    char const *opName)
{
    MTH_OperationMap key = {
        .name = opName,
        .func = NULL
    } ;

    MTH_OperationMap const *const opMap = (MTH_OperationMap const *const)
            bsearch(&key, harness->operations, harness->operationCount,
            sizeof(key), mthOperationMapCompare) ;
    if (opMap == NULL) {
        mth_FormatToContext("unknown operation, \"%s\"", opName) ;
    }

    return opMap ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthOperationMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthOperationMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_OperationMap const *cm1 = m1 ;
    MTH_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthclassmap {
    char const *name ;
    MRT_ClassId id ;
    struct mthattrmap const *attrs ;
    unsigned attrCount ;
    struct mthinstmap const *insts ;
    unsigned instCount ;
    struct mtheventmap const *events ;
    unsigned eventCount ;
} MTH_ClassMap ;
----

[source,c]
----
<<mth forward references>>=
static MTH_ClassMap const *const
mthFindClass(
    MTH_DomainHarness const *const harness,
    char const *className) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_ClassMap const *const
mthFindClass(
    MTH_DomainHarness const *const harness,
    char const *className)
{
    MTH_ClassMap key = {
        .name = className
    } ;

    MTH_ClassMap const *const classMap = (MTH_ClassMap const *const)
            bsearch(&key, harness->classes, harness->classCount,
            sizeof(key), mthClassMapCompare) ;
    if (classMap == NULL) {
        mth_FormatToContext("unknown class, \"%s\"", className) ;
    }

    return classMap ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthClassMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthClassMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_ClassMap const *cm1 = m1 ;
    MTH_ClassMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthattrmap {
    char const *name ;
    MRT_AttrId id ;
    MTH_AttrReadFunc *readFunc ;
    MTH_AttrUpdateFunc *updateFunc ;
} MTH_AttrMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef bool MTH_AttrReadFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId) ;
----

[source,c]
----
<<mth interface simple types>>=
typedef bool MTH_AttrUpdateFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId, char const *) ;
----

[source,c]
----
<<mth forward references>>=
static MTH_AttrMap const *const
mthFindAttr(
    MTH_ClassMap const *const class,
    char const *attrName) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_AttrMap const *const
mthFindAttr(
    MTH_ClassMap const *const class,
    char const *attrName)
{
    MTH_AttrMap key = {
        .name = attrName
    } ;

    return (MTH_AttrMap const *const)
            bsearch(&key, class->attrs, class->attrCount,
            sizeof(key), mthAttrMapCompare) ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthAttrMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthAttrMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_AttrMap const *cm1 = m1 ;
    MTH_AttrMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthinstmap {
    char const *name ;
    MRT_InstId id ;
} MTH_InstMap ;
----

[source,c]
----
<<mth forward references>>=
static int
mthFindInst(
    MTH_ClassMap const *const class,
    char const *instName) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthFindInst(
    MTH_ClassMap const *const class,
    char const *instName)
{
    // First scan to see if we got a number.
    int instId = -1 ;
    int converted = sscanf(instName, "%i", &instId) ;
    if (converted == 1) {
        if (instId < 0) {
            mth_FormatToContext("instance id's must be non-negative: "
                    "got, %i", instId) ;
        }
    } else {
        // Not a number, try to look up the name.
        MTH_InstMap key = {
            .name = instName
        } ;

        MTH_InstMap const *const instMap = (MTH_InstMap const *const)
                bsearch(&key, class->insts, class->instCount,
                sizeof(key), mthInstMapCompare) ;
        if (instMap == NULL) {
            mth_FormatToContext("unknown instance, \"%s\"", instName) ;
            instId = -1 ;
        } else {
            instId = instMap->id ;
        }
    }

    return instId ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthInstMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthInstMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_InstMap const *cm1 = m1 ;
    MTH_InstMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mtheventmap {
    char const *name ;
    MRT_EventCode number ;
    MTH_EventParamFunc *paramFunc ;
} MTH_EventMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef bool MTH_EventParamFunc(int, char * const*, MRT_EventParams) ;
----

[source,c]
----
<<mth forward references>>=
static MTH_EventMap const *
mthFindEvent(
    MTH_ClassMap const *const class,
    char const *eventName) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_EventMap const *
mthFindEvent(
    MTH_ClassMap const *const class,
    char const *eventName)
{
    // First scan to see if we got a number.
    MTH_EventMap const *eventMap = NULL ;
    char *end ;
    MRT_EventCode eventNumber = strtoul(eventName, &end, 0) ;
    if (*end == ASCII_NUL) {
        // search for the event number in the map
        MTH_EventMap const *mapIter = class->events ;
        for (unsigned eventCount = class->eventCount ; eventCount != 0 ;
                eventCount--, mapIter++) {
            if (mapIter->number == eventNumber) {
                eventMap = mapIter ;
                break ;
            }
        }
    } else {
        // Not a number, try to look up the name.
        MTH_EventMap key = {
            .name = eventName
        } ;

        eventMap = (MTH_EventMap const *)
                bsearch(&key, class->events, class->eventCount,
                sizeof(key), mthEventMapCompare) ;
    }

    if (eventMap == NULL) {
        mth_FormatToContext("unknown event, \"%s\"", eventName) ;
    }

    return eventMap ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthEventMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthEventMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_EventMap const *cm1 = m1 ;
    MTH_EventMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

=== Harness Functions

Place holder.

==== Harness Initialization

Before any harness activity can happen,
it is necessary invoke the initialization function for the harness
library.
This is typically done in `main` and must be done after
the `micca` run-time is initialized, _i.e._ after `mrt_Initialize`
has been invoked.

[source,c]
----
<<mth external function declarations>>=
extern bool mth_Initialize(void) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <sys/socket.h>
#include <errno.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>
----

[source,c]
----
<<mth interface includes>>=
#include <inttypes.h>
----

[source,c]
----
<<mth external function definitions>>=
bool
mth_Initialize(void)
{
    mthServiceSock = socket(AF_INET, SOCK_STREAM, 0) ;
    if (mthServiceSock == -1) {
        perror("unable to obtain AF_INET stream socket") ;
        return false ;
    }

    struct sockaddr_in hsrvAddr ;
    memset(&hsrvAddr, 0, sizeof(hsrvAddr)) ;
#       ifdef __APPLE__
    hsrvAddr.sin_len = sizeof(hsrvAddr) ;
#       endif /* __APPLE__ */
    hsrvAddr.sin_family = AF_INET ;
    hsrvAddr.sin_port = htons(HARNESS_PORT) ;

    static char const host[] = "localhost" ;
    struct hostent *hostAddr = gethostbyname(host) ;
    if (hostAddr == NULL) {
        perror(host) ;
        return false ;
    }
    assert(hostAddr->h_addrtype == AF_INET) ;
    memcpy(&hsrvAddr.sin_addr, hostAddr->h_addr_list[0], hostAddr->h_length) ;

    int err = bind(mthServiceSock, (struct sockaddr const *)&hsrvAddr,
            sizeof(hsrvAddr)) ;
    if (err == -1) {
        perror("bind()") ;
        return false ;
    }

    err = listen(mthServiceSock, 1) ;
    if (err == -1) {
        perror("listen()") ;
        return false ;
    }

    mrt_RegisterFDService(mthServiceSock, mthAcceptConnection, NULL, NULL) ;
    mrt_RegisterSignal(SIGQUIT, mthExitOnSignal) ;
    mrt_RegisterSignal(SIGINT, mthExitOnSignal) ;
    mrt_RegisterSignal(SIGTERM, mthExitOnSignal) ;

    mrt_RegisterTraceHandler(NULL) ; // start with tracing off

    return true ;
}
----

[source,c]
----
<<mth implementation constants>>=
#ifndef HARNESS_PORT
#   define HARNESS_PORT 3906
#endif /* HARNESS_PORT */
----

[source,c]
----
<<mth static data>>=
int mthServiceSock = -1 ;
----

[source,c]
----
<<mth static functions>>=
static void
mthClose(void)
{
    if (mthServiceSock != -1) {
        shutdown(mthServiceSock, SHUT_RDWR) ;
    }
    if (mthCmdStream != NULL) {
        fclose(mthCmdStream) ;
    }
}
----

[source,c]
----
<<mth static functions>>=
static void
mthExitOnSignal(
    int signal)
{
    dbgprintf("caught signal %d\n", signal) ;
    mthClose() ;
    exit(EXIT_SUCCESS) ;
}
----

[source,c]
----
<<mth static functions>>=
static void
mthAcceptConnection(
    int sock)
{
    int fd = accept(sock, NULL, 0) ;

    int err = shutdown(mthServiceSock, SHUT_RDWR) ;
    if (err == -1) {
        perror("shutdown()") ;
        exit(EXIT_FAILURE) ;
    }
    mrt_UnregisterFDService(sock, true, false, false) ;
    mthServiceSock = -1 ;

    if (fd == -1) {
        perror("accept()") ;
        exit(EXIT_FAILURE) ;
    }

    mrt_RegisterFDService(fd, mthReadAndEvalCommand, NULL, NULL) ;
    mthCmdStream = fdopen(fd, "w+") ;
    err = setvbuf(mthCmdStream, NULL, _IOLBF, 0) ;
}
----

[source,c]
----
<<mth implementation includes>>=
#include <unistd.h>
----

[source,c]
----
<<mth static data>>=
FILE *mthCmdStream ;
----

==== Running the Harness

[source,c]
----
<<mth external function declarations>>=
extern void mth_Run(void) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <setjmp.h>
----

[source,c]
----
<<mth static data>>=
static jmp_buf mthFatalBuf ;
static enum {
    mthHalted,
    mthRunning,
    mthTerminate,
} mthHarnessState = mthRunning ;
----

[source,c]
----
<<mth external function definitions>>=
void
mth_Run(void)
{
    mrt_SetFatalErrorHandler(mthErrorHandler) ;

    while (mthHarnessState != mthTerminate) {
        if (setjmp(mthFatalBuf) == 0) {
            mrt_EventLoop() ;
        }

        while (mthHarnessState == mthHalted) {
            mthReadAndEvalCommand(0) ;
        }
    }
    mthClose() ;
}
----

[source,c]
----
<<mth static functions>>=
static void mthErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list alist)
{
    static char buf[BUFSIZ] ;

    vsnprintf(buf, sizeof(buf), fmt, alist) ;
    // trim off any whitespace
    for (char *end = buf + strlen(buf) - 1 ;
            end > buf && isspace(*end) ; end--) {
        *end = ASCII_NUL ;
    }
    fprintf(mthCmdStream, "fatal {%s}\n" , buf) ;

    mthHarnessState = mthHalted ;
    longjmp(mthFatalBuf, 1) ;
}
----

==== Command Execution

[source,c]
----
<<mth forward references>>=
static void mthReadAndEvalCommand(int) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthReadAndEvalCommand(
    int rfd)
{
    static char cmdBuffer[BUFSIZ] ;

    char *cmd = fgets(cmdBuffer, sizeof(cmdBuffer), mthCmdStream) ;
    if (cmd == NULL) {
        if (feof(mthCmdStream)) {
            dbgprintf("goodbye\n") ;
            fclose(mthCmdStream) ;
            exit(EXIT_SUCCESS) ;
        } else if (ferror(mthCmdStream)) {
            if (errno == EINTR) {
                clearerr(mthCmdStream) ;
                return ;
            }
            perror("fgets()") ;
            fclose(mthCmdStream) ;
            exit(EXIT_FAILURE) ;
        } else {
            printf("partial\n") ;
            return ;
        }
    }
    for (char *end = cmdBuffer + strlen(cmdBuffer) - 1 ; isspace(*end) ; end--) {
        *end = ASCII_NUL ;
    }
    dbgprintf("%s\n", cmdBuffer) ;

    int argc ;
    char *const *argv ;
    static char parseBuffer[BUFSIZ] ;
    strcpy(parseBuffer, cmdBuffer) ;

    mthBeginResponse() ;
    mthAddWord("cmd") ;
    mthPushContext() ;

    int err = mthParseCommand(parseBuffer, &argc, &argv) ;
    if (err == -1) {
        mth_FormatToContext("name unknown return error result ") ;
        mthPushContext() ;
        mth_FormatToContext("failed to parse command: \"%s\"", cmdBuffer) ;
        mthPopContext() ;
    } else if (argc != 0) {
        mthExecCommand(argc, argv) ;
    } else {
        return ;
    }

    mthPopContext() ;
    mthEndResponse() ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthParseCommand(char *, int *, char *const **) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <ctype.h>
----

[source,c]
----
<<mth static functions>>=
static int
mthParseCommand(
    char *line,
    int *pargc,
    char *const **pargv)
{
    #define MAX_ARGS    64
    static char *args[MAX_ARGS] ;

    char **pArgv = args ;
    char **const argvEnd = pArgv + MAX_ARGS ;

    int quoteCount = 0 ;
    int parseState = OUTOFWORD ;
    int parseStackStorage[2] ;
    int *parseStackTop = parseStackStorage ;

    char *pWord = line ;
    for ( ; *line != ASCII_NUL ; line++) {
        char c = *line ;
        switch (parseState) {
        case OUTOFWORD:
            if (isgraph(c)) {
                if (c == ESCAPE_CHAR) {
                    *parseStackTop++ = INWORD ;
                    parseState = INESCAPE ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else if (c == BEGIN_QUOTE) {
                    *parseStackTop++ = OUTOFWORD ;
                    parseState = INQUOTE ;
                    ++quoteCount ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else {
                    // new word beginning
                    if (pArgv < argvEnd) {
                        *pArgv++ = pWord ;
                    } else {
                        fprintf(stderr, "exceeded max arguments") ;
                        return -1 ;
                    }
                    *pWord++ = c ;
                    parseState = INWORD ;
                }
            } // else the character is just space to skip
            break ;

        case INWORD:
            if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = INESCAPE ;
            } else if (c == BEGIN_QUOTE) {
                *parseStackTop++ = parseState ;
                parseState = INQUOTE ;
                ++quoteCount ;
            } else if (isspace(c)) {
                // end of word
                parseState = OUTOFWORD ;
                *pWord++ = ASCII_NUL ;
            } else {
                *pWord++ = c ;
            }
            break ;

        case INESCAPE:
            switch (c) {
                case 'a':
                    *pWord++ = '\a' ;
                    break ;
                case 'b':
                    *pWord++ = '\b' ;
                    break ;
                case 't':
                    *pWord++ = '\t' ;
                    break ;
                case 'n':
                    *pWord++ = '\n' ;
                    break ;
                case 'v':
                    *pWord++ = '\v' ;
                    break ;
                case 'f':
                    *pWord++ = '\f' ;
                    break ;
                case 'r':
                    *pWord++ = '\r' ;
                    break ;
                default:
                    *pWord++ = c ;
                    break ;
            }
            parseState = *--parseStackTop ;
            break ;

        case INQUOTE:
            if (c == BEGIN_QUOTE) {
                ++quoteCount ;
                *pWord++ = c ;
            } else if (c == END_QUOTE) {
                if (--quoteCount == 0) {
                    parseState = *--parseStackTop ;
                    // check if ending the quote also ended the word
                    if (parseState == OUTOFWORD) {
                        *pWord++ = ASCII_NUL ;
                    }
                } else {
                    *pWord++ = c ;
                }
            } else if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = INESCAPE ;
            } else {
                *pWord++ = c ;
            }
            break ;
        }
    }

    *pWord = ASCII_NUL ;
    *pArgv = NULL ;
    if (quoteCount == 0 && parseState != INESCAPE) {
        if (pargc) {
            *pargc = pArgv - args ;
        }
        if (pargv) {
            *pargv = args ;
        }
        return 0 ;
    } else {
        return -1 ;
    }
}
----

[source,c]
----
<<mth implementation aggregate types>>=
typedef struct mthcommandmap {
    char const *name ;
    MTH_CommandFunc *commandFunc ;
} MTH_CommandMap ;
----

[source,c]
----
<<mth implementation simple types>>=
typedef bool MTH_CommandFunc(int, char * const*) ;
----

==== Defined Commands

[source,c]
----
<<mth static data>>=
static MTH_CommandMap const commands[] = { // must be in ascending "name" order
    {
        .name = "cancel",
        .commandFunc = mthCancelCommand
    },
    {
        .name = "delaysignal",
        .commandFunc = mthDelaySignalCommand
    },
    {
        .name = "delete",
        .commandFunc = mthDeleteCommand
    },
    {
        .name = "domainop",
        .commandFunc = mthDopCommand
    },
    {
        .name = "eloop",
        .commandFunc = mthEloopCommand
    },
    {
        .name = "instr",
        .commandFunc = mthInstrCommand
    },
    {
        .name = "null",
        .commandFunc = mthNullCommand
    },
    {
        .name = "query",
        .commandFunc = mthQueryCommand
    },
    {
        .name = "read",
        .commandFunc = mthReadCommand
    },
    {
        .name = "remaining",
        .commandFunc = mthRemainingCommand
    },
    {
        .name = "signal",
        .commandFunc = mthSignalCommand
    },
    {
        .name = "trace",
        .commandFunc = mthTraceCommand
    },
    {
        .name = "update",
        .commandFunc = mthUpdateCommand
    },
} ;
----

[source,c]
----
<<mth forward references>>=
static void mthExecCommand(int, char * const *) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthExecCommand(
    int argc,
    char *const *argv)
{
    MTH_CommandMap key = {
        .name = argv[0],
        .commandFunc = NULL
    } ;

    MTH_CommandMap const *cmd = (MTH_CommandMap const *)
            bsearch(&key, commands, COUNTOF(commands), sizeof(commands[0]),
            mthCommandMapCompare) ;

    mthAddWord("name") ;
    mthAddWord(argv[0]) ;
    mthAddWord("result") ;
    mthPushContext() ;

    bool success ;
    if (cmd != NULL) {
        assert(cmd->commandFunc != NULL) ;
        success = cmd->commandFunc(argc, argv) ;
    } else {
        mth_FormatToContext("unknown command, \"%s\"", argv[0]) ;
        success = false ;
    }

    mthPopContext() ;
    mthAddWord("code") ;
    mthAddWord(success ? "ok" : "error") ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthCommandMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthCommandMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_CommandMap const *cm1 = m1 ;
    MTH_CommandMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Registering a Domain

[source,c]
----
<<mth external function declarations>>=
extern bool mth_RegisterDomain(MTH_DomainHarness const *harness) ;
----

[source,c]
----
<<mth external function definitions>>=
bool
mth_RegisterDomain(
    MTH_DomainHarness const *harness)
{
    assert(harness != NULL) ;
    assert(harness->portal != NULL) ;
    assert(harness->portal->name != NULL) ;

    MTH_DomainHarness const *const registeredHarness =
            mthFindHarness(harness->portal->name) ;

    bool inserted ;
    if (registeredHarness == NULL) {
        mthInsertHarness(harness) ;
        inserted = true ;
    } else {
        inserted = false ;
    }

    return inserted ;
}
----

[source,c]
----
<<mth implementation aggregate types>>=
typedef struct mthharnessregistry {
    unsigned count ;
    MTH_DomainHarness const *harnesses[MTH_MAX_DOMAINS] ;
} MTH_HarnessRegistry ;
----

[source,c]
----
<<mth implementation constants>>=
#ifndef MTH_MAX_DOMAINS
#   define MTH_MAX_DOMAINS  16
#endif /* MTH_MAX_DOMAINS */
----

[source,c]
----
<<mth static data>>=
MTH_HarnessRegistry mthHarnesses ;
----

[source,c]
----
<<mth forward references>>=
static MTH_DomainHarness const *const
mthFindHarness(
    char const *domainName) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_DomainHarness const *const
mthFindHarness(
    char const *domainName)
{
    assert(domainName != NULL) ;

    MTH_DomainHarness const *const *hiter = mthHarnesses.harnesses ;
    for (unsigned count = mthHarnesses.count ; count != 0 ; count--) {
        MTH_DomainHarness const *const harness = *hiter++ ;
        assert(harness->portal != NULL) ;
        assert(harness->portal->name != NULL) ;
        if (strcmp(domainName, harness->portal->name) == 0) {
            return harness ;
        }
    }
    return NULL ;
}
----

[source,c]
----
<<mth forward references>>=
static void
mthInsertHarness(
    MTH_DomainHarness const *const) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthInsertHarness(
    MTH_DomainHarness const *const harness)
{
    assert(harness != NULL) ;
    assert(mthHarnesses.count < COUNTOF(mthHarnesses.harnesses)) ;
    if (mthHarnesses.count < COUNTOF(mthHarnesses.harnesses)) {
        mthHarnesses.harnesses[mthHarnesses.count++] = harness ;
    }
}
----

=== Harness Command Functions

==== Cancel Command

[literal]
--
cancel <domain> <class> <inst> <event>
--

[source,c]
----
<<mth forward references>>=
static bool mthCancelCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthCancelCommand(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"cancel <domain> <class> <inst> <event>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    MTH_ClassMap const *const class = mthFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = mthFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    MTH_EventMap const *event = mthFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    MRT_EventCode eventNumber = event->number ;
    int pcode = mrt_PortalCancelDelayedEvent(portal, classId, instId, eventNumber) ;
    if (pcode < 0) {
        mth_PortalErrorResponse(pcode) ;
        return false ;
    }

    return true ;
}
----

==== Delay Signal Command


[literal]
--
delaysignal <domain> <class> <inst> <delay> <event> ?<arg1> <arg2> ...?
--

[source,c]
----
<<mth forward references>>=
static bool mthDelaySignalCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthDelaySignalCommand(
    int argc,
    char *const *argv)
{
    if (argc < 6) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"delaysignal <domain> <class> <inst> <delay> <event> "
            "?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    MTH_ClassMap const *const class = mthFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = mthFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *delayTime = argv[4] ;
    MRT_DelayTime delay ;
    int converted = sscanf(delayTime, "%" SCNi32, &delay) ;
    if (converted != 1) {
        mth_FormatToContext("failed to scan, \"%s\" as a \"%s\"", delayTime,
                SCNi32) ;
        return false ;
    }

    char *eventName = argv[5] ;
    MTH_EventMap const *event = mthFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    MTH_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 6, argv + 6, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalSignalDelayedEvent(portal, classId, instId,
                eventNumber, params, delay) ;
    } else {
        pcode = mrt_PortalSignalDelayedEvent(portal, classId, instId,
                eventNumber, NULL, delay) ;
    }

    if (pcode < 0) {
        mth_PortalErrorResponse(pcode) ;
        return false ;
    }

    return true ;
}
----

==== Domain Operation Command

[source,c]
----
<<mth forward references>>=
static bool mthDopCommand(int, char *const *) ;
----

[literal]
--
dop <domain> <operation> ?<arg1> <arg2> ...?
--

[source,c]
----
<<mth static functions>>=
static bool
mthDopCommand(
    int argc,
    char *const *argv)
{
    if (argc < 3) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "dop <domain> <operation> ?<arg1> <arg2> ...?",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }

    char *opName = argv[2] ;
    MTH_OperationMap const *const opMap = mthFindOperation(harness, opName) ;
    if (opMap == NULL) {
        return false ;
    }
    return opMap->func(argc - 2, argv + 2) ;
}
----

==== Delete Command

[literal]
--
delete <domain> <class> <inst>
--

[source,c]
----
<<mth forward references>>=
static bool mthDeleteCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthDeleteCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"delete <domain> <class> <inst>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }

    char *className = argv[2] ;
    MTH_ClassMap const *const class = mthFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = mthFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int pcode = mrt_PortalDeleteInstance(portal, classId, instId) ;
    if (pcode < 0) {
        mth_PortalErrorResponse(pcode) ;
        return false ;
    }

    return true ;
}
----

==== Eloop Command

[source,c]
----
<<mth forward references>>=
static bool mthEloopCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthEloopCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        char const *state ;
        switch (mthHarnessState) {
        case mthHalted :
            state = "halted" ;
            break ;

        case mthRunning:
            state = "running" ;
            break ;

        case mthTerminate:
        default:
            state = "terminated" ;
            break ;
        }
        mthAddWord(state) ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "run") == 0) {
            mthHarnessState = mthRunning ;
            mthAddWord("running") ;
        } else if (strcmp(argv[1], "halt") == 0) {
            mrt_SyncToEventLoop() ;
            mthHarnessState = mthHalted ;
            mthAddWord("halted") ;
        } else if (strcmp(argv[1], "terminate") == 0) {
            mrt_SyncToEventLoop() ;
            mthHarnessState = mthTerminate ;
            mthAddWord("terminated") ;
        } else if (strcmp(argv[1], "once") == 0) {
            if (mthHarnessState != mthRunning) {
                bool didEvent = mrt_ProcessOneEvent() ;
                mthAddWord(didEvent ? "true" : "false") ;
            } else {
                mthAddWord("event loop is running") ;
                status = false ;
            }
        } else {
            mth_FormatToContext(
                "unknown eloop option, \"%s\": expected, "
                "\"run | halt | once | terminate\"",
                argv[1]) ;
            status = false ;
        }
    } else {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"eloop ?run | halt | once | terminate?\"",
            argc) ;
        status = false ;
    }

    return status ;
}
----

==== Instr Command

[source,c]
----
<<mth forward references>>=
static bool mthInstrCommand(int, char *const *) ;
----

[source,c]
----
<<mth static data>>=
static bool instrOn = false ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthInstrCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        mthAddWord(instrOn ? "on" : "off") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            instrOn = true ;
            mthAddWord("on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            instrOn = false ;
            mthAddWord("off") ;
        } else {
            mth_FormatToContext(
                    "unknown instr option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
            status = false ;
        }
    } else {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, \"instr ?on | off?\"", argc) ;
        status = false ;
    }

    return status ;
}
----

==== Null Command

[source,c]
----
<<mth forward references>>=
static bool mthNullCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthNullCommand(
    int argc,
    char *const *argv)
{
    return true ;
}
----

==== Query Command

[source,c]
----
<<mth forward references>>=
static bool mthQueryCommand(int, char *const *) ;
----

[literal]
--
query domains
query classes <domain>
query attributes <domain> <class>
query instances <domain> <class>
query currentstate <domain> <class> <instance>
--

[source,c]
----
<<mth static functions>>=
static bool
mthQueryCommand(
    int argc,
    char *const *argv)
{
    if (argc < 2) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "query <subcmd> ?<domain> <arg1> <arg2> ...?",
            argc) ;
        return false ;
    }

    char *subcmdName = argv[1] ;
    bool status ;
    if (strcmp(subcmdName, "domains") == 0) {
        status = mthQueryDomains(argc, argv) ;
    } else if (strcmp(subcmdName, "classes") == 0) {
        status = mthQueryClasses(argc, argv) ;
    } else if (strcmp(subcmdName, "attributes") == 0) {
        status = mthQueryAttrs(argc, argv) ;
    } else if (strcmp(subcmdName, "instances") == 0) {
        status = mthQueryInsts(argc, argv) ;
    } else if (strcmp(subcmdName, "currentstate") == 0) {
        status = mthQueryCurrentState(argc, argv) ;
    } else {
        mth_FormatToContext(
            "unknown subcommand, \"%s\": expected, "
            "\"domains | classes | attributes | instances | currentstate\"",
            subcmdName) ;
        status = false ;
    }

    return status ;
}
----

[source,c]
----
<<mth forward references>>=
static bool mthQueryDomains(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthQueryDomains(
    int argc,
    char *const *argv)
{
    MTH_DomainHarness const *const *hiter = mthHarnesses.harnesses ;
    for (unsigned count = mthHarnesses.count ; count != 0 ; count--) {
        MTH_DomainHarness const *const harness = *hiter++ ;
        assert(harness->portal != NULL) ;
        assert(harness->portal->name != NULL) ;

        mthAddWord(harness->portal->name) ;
    }
    return true ;
}
----

[source,c]
----
<<mth forward references>>=
static bool mthQueryClasses(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthQueryClasses(
    int argc,
    char *const *argv)
{
    if (argc != 3) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, \"query classes <domain>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    unsigned classCount = mrt_PortalDomainClassCount(portal) ;
    for (MRT_ClassId id = 0 ; id < classCount ; id++) {
        char const *className = NULL ;
        int pcode = mrt_PortalClassName(portal, id, &className) ;
        if (pcode == 0) {
            mthAddWord(className) ;
        } else {
            mth_PortalErrorResponse(pcode) ;
            return false ;
        }
    }
    return true ;
}
----

[source,c]
----
<<mth forward references>>=
static bool mthQueryAttrs(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthQueryAttrs(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"query attributes <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }

    char *className = argv[3] ;
    MTH_ClassMap const *const classMap = mthFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int attrCount = mrt_PortalClassAttributeCount(portal, classId) ;
    assert(attrCount >= 0) ;
    if (attrCount < 0) {
        mth_PortalErrorResponse(attrCount) ;
        return false ;
    }

    for (MRT_AttrId attrId = 0 ; attrId < attrCount ; attrId++) {
        char const *attrName = NULL ;
        int pcode = mrt_PortalClassAttributeName(portal, classId, attrId,
                &attrName) ;
        if (pcode == 0) {
            mthAddWord(attrName) ;
        } else {
            mth_PortalErrorResponse(pcode) ;
            return false ;
        }
    }

    return true ;
}
----

[source,c]
----
<<mth forward references>>=
static bool mthQueryInsts(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthQueryInsts(
    int argc,
    char *const *argv)
{
    if (argc != 4) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"query instances <domain> <class>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }

    char *className = argv[3] ;
    MTH_ClassMap const *const classMap = mthFindClass(harness, className) ;
    if (classMap == NULL) {
        return false ;
    }
    MRT_ClassId classId = classMap->id ;


    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int instCount = mrt_PortalClassInstanceCount(portal, classId) ;
    assert(instCount >= 0) ;
    if (instCount < 0) {
        mth_PortalErrorResponse(instCount) ;
        return false ;
    }

    mth_FormatToContext("total %d named ", instCount) ;

    mthPushContext() ;
    MTH_InstMap const *inst = classMap->insts ;
    for (unsigned namedCount = classMap->instCount ; namedCount != 0 ;
            namedCount--, inst++) {
        mthAddWord(inst->name) ;
    }
    mthPopContext() ;

    return true ;
}
----

[source,c]
----
<<mth forward references>>=
static bool mthQueryCurrentState(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthQueryCurrentState(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"query currentstate <domain> <class> <instance>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[2] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }

    char *className = argv[3] ;
    MTH_ClassMap const *const class = mthFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[4] ;
    int instId = mthFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    int statecode = mrt_PortalInstanceCurrentState(portal, classId, instId) ;
    if (statecode < 0) {
        mth_PortalErrorResponse(statecode) ;
        return false ;
    }

    char const *stateName ;
    int pcode = mrt_PortalClassStateName(portal, classId, statecode, &stateName) ;
    if (pcode < 0) {
        mth_PortalErrorResponse(pcode) ;
        return false ;
    }

    mthAddWord(stateName) ;
    return true ;
}
----

==== Read Command

[literal]
--
read <domain> <class> <inst> ?<attr1> <attr2> ...?
--

[source,c]
----
<<mth forward references>>=
static bool mthReadCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthReadCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"read <domain> <class> <inst> ?<attr1> <attr2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    MTH_ClassMap const *const class = mthFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = mthFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    bool status = true ;
    if (argc == 4) {
        // read all the attributes
        MTH_AttrMap const *attr = class->attrs ;
        for (unsigned attrCount = class->attrCount ; attrCount != 0 ;
                attrCount--, attr++) {
            mthAddWord(attr->name) ;
            mthPushContext() ;
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            mthPopContext() ;

            if (!status) {
                break ;
            }
        }
    } else {
        char *const *attrNames = argv + 4 ;
        for (int attrCount = argc - 4 ; attrCount != 0 ;
                attrCount--, attrNames++) {
            MTH_AttrMap const *const attr = mthFindAttr(class, *attrNames) ;
            if (attr == NULL) {
                mthInitBufContext() ;
                mth_FormatToContext("unknown attribute, \"%s\"", *attrNames) ;
                break ;
            }

            mthAddWord(*attrNames) ;
            mthPushContext() ;
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            mthPopContext() ;

            if (!status) {
                break ;
            }
        }
    }

    return status ;
}
----

==== Remaining Command

[literal]
--
remaining <domain> <class> <inst> <event>
--

[source,c]
----
<<mth forward references>>=
static bool mthRemainingCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthRemainingCommand(
    int argc,
    char *const *argv)
{
    if (argc != 5) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"remaining <domain> <class> <inst> <event>\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    MTH_ClassMap const *const class = mthFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = mthFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    MTH_EventMap const *event = mthFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    MRT_DelayTime delay ;
    MRT_EventCode eventNumber = event->number ;
    int pcode = mrt_PortalRemainingDelayTime(portal, classId, instId,
            eventNumber, &delay) ;
    if (pcode < 0) {
        mth_PortalErrorResponse(pcode) ;
        return false ;
    } else {
        mth_FormatToContext("%" PRIu32, delay) ;
    }

    return true ;
}
----

==== Signal Command

[literal]
--
signal <domain> <class> <inst> <event> ?<arg1> <arg2> ...?
--

[source,c]
----
<<mth forward references>>=
static bool mthSignalCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthSignalCommand(
    int argc,
    char *const *argv)
{
    if (argc < 5) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"signal <domain> <class> <inst> <event> ?<arg1> <arg2> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    MTH_ClassMap const *const class = mthFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = mthFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    char *eventName = argv[4] ;
    MTH_EventMap const *event = mthFindEvent(class, eventName) ;
    if (event == NULL) {
        return false ;
    }

    MTH_EventParamFunc *epfunc = event->paramFunc ;
    MRT_EventCode eventNumber = event->number ;
    int pcode ;
    if (epfunc != NULL) {
        MRT_EventParams params ;
        bool pstatus = epfunc(argc - 5, argv + 5, params) ;
        if (!pstatus) {
            return false ;
        }
        pcode = mrt_PortalSignalEvent(portal, classId, instId, eventNumber,
            params) ;
    } else {
        pcode = mrt_PortalSignalEvent(portal, classId, instId, eventNumber,
            NULL) ;
    }

    if (pcode < 0) {
        mth_PortalErrorResponse(pcode) ;
        return false ;
    }

    return true ;
}
----

==== Trace Command

[source,c]
----
<<mth forward references>>=
static bool mthTraceCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthTraceCommand(
    int argc,
    char *const *argv)
{
    bool status = true ;

    if (argc == 1) {
        MRT_TraceHandler handler = mrt_RegisterTraceHandler(NULL) ;
        mrt_RegisterTraceHandler(handler) ;
        mthAddWord(handler == NULL ? "off" : "on") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            mrt_RegisterTraceHandler(mthTraceResponse) ;
            mthAddWord("on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            mrt_RegisterTraceHandler(NULL) ;
            mthAddWord("off") ;
        } else {
            mth_FormatToContext(
                    "unknown trace option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
            status = false ;
        }
    } else {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, \"trace ?on | off?\"", argc) ;
        status = false ;
    }

    return status ;
}
----

==== Update Command

[literal]
--
update <domain> <class> <inst> ?<attr1> <value1> <attr2> <value2> ...?
--

[source,c]
----
<<mth forward references>>=
static bool mthUpdateCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthUpdateCommand(
    int argc,
    char *const *argv)
{
    if (argc < 4) {
        mth_FormatToContext(
            "wrong # of arguments, %d: expected, "
            "\"update <domain> <class> <inst> ?<attr1> <value1> ...?\"",
            argc) ;
        return false ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_FormatToContext("unknown domain, \"%s\"", domainName) ;
        return false ;
    }

    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    char *className = argv[2] ;
    MTH_ClassMap const *const class = mthFindClass(harness, className) ;
    if (class == NULL) {
        return false ;
    }
    MRT_ClassId classId = class->id ;

    char *instName = argv[3] ;
    int instId = mthFindInst(class, instName) ;
    if (instId < 0) {
        return false ;
    }

    bool status = true ;
    int updateCount = argc - 4 ;
    if (updateCount % 2 != 0) {
        mth_FormatToContext("updates must be given as name / value pairs") ;
        return false ;
    }

    char *const *attrName = argv + 4 ;
    char *const *valueString = argv + 5 ;
    for ( ; updateCount != 0 ;
            updateCount -= 2, attrName += 2, valueString += 2) {
        MTH_AttrMap const *const attr = mthFindAttr(class, *attrName) ;
        if (attr == NULL) {
            mthInitBufContext() ;
            mth_FormatToContext("unknown attribute, \"%s\"", *attrName) ;
            break ;
        }

        mthAddWord(*attrName) ;
        mthPushContext() ;
        status = attr->updateFunc(portal, classId, instId, attr->id,
                *valueString) ;
        if (status) {
            status = attr->readFunc(portal, classId, instId, attr->id) ;
            mthPopContext() ;
        }

        if (!status) {
            break ;
        }
    }

    return status ;
}
----

=== Common Functions

[source,c]
----
<<mth forward references>>=
static void mthTraceResponse(MRT_TraceInfo const *) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthTraceResponse(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
        char const *newStateName ;
        if (newState == MRT_StateCode_IG) {
            newStateName = "IG" ;
        } else if (newState == MRT_StateCode_CH) {
            newStateName = "CH" ;
        } else {
            newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.newState] ;
        }

        fprintf(mthCmdStream,
                "trace {"
                "type transition "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "currstate %s "
                "newstate %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.currentState],
            newStateName,
            mthTimestamp()) ;
    }
        break ;

    case mrtPolymorphicEvent: {
        MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
                genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
        MRT_Class const *subclass ;
        char const *subname = NULL ;
        if (rel->relType == mrtRefGeneralization) {
            subclass = rel->relInfo.refGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
            subname = subclass->name ;
        } else if (rel->relType == mrtUnionGeneralization) {
            subclass = rel->relInfo.unionGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode] ;
            subname = subclass->name ;
        } else {
            printf("%s: bad relationship type in polymorphic event, %d\n",
                mthTimestamp(), rel->relType) ;
            break ;
        }
        fprintf(mthCmdStream,
                "trace {"
                "type polymorphic "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "relationship %s "
                "newevent %s "
                "subclass %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->pdb->genNames[
                traceInfo->info.polyTrace.genNumber],
            subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
            subname,
            mthTimestamp()) ;
    }
        break ;

    case mrtCreationEvent:
        fprintf(mthCmdStream,
                "trace {"
                "type creation "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->info.creationTrace.targetClass->name, targetName,
            mthTimestamp()) ;
        break ;

    default:
        fprintf(mthCmdStream,
                "trace {"
                "type error "
                "result {unknown trace event type, \"%u\"} "
                "time %s"
                "}\n",
            traceInfo->eventType,
            mthTimestamp()) ;
        break ;
    }
}
----

[source,c]
----
<<mth implementation includes>>=
#include <stdarg.h>
----

[source,c]
----
<<mth external function declarations>>=
extern void
mth_InstrResponse(
    char const *,
    char const *,
    ...) ;
----

[source,c]
----
<<mth static functions>>=
void
mth_InstrResponse(
    char const *resultKey,
    char const *resultFmt,
    ...)
{
    if (!instrOn) {
        return ;
    }

    va_list resultArgs ;
    va_start(resultArgs, resultFmt) ;

    static char resultBuf[BUFSIZ] ;
    int n = vsnprintf(resultBuf, sizeof(resultBuf), resultFmt, resultArgs) ;

    va_end(resultArgs) ;

    if (n < 0) {
        strncpy(resultBuf, "error formating response", sizeof(resultBuf)) ;
    } else if (n >= sizeof(resultBuf)) {
        strncpy(resultBuf, "response truncated", sizeof(resultBuf)) ;
    } else {
        // trim off any whitespace
        for (char *end = resultBuf + strlen(resultBuf) - 1 ;
                end > resultBuf && isspace(*end) ; end--) {
            *end = ASCII_NUL ;
        }
    }

    static char preamble[] = "instr {" ;
    static char postamble[] = "}\n" ;
    static char unQuotedFmt[] = " %s" ;
    static char quotedFmt[] = " {%s}" ;

    char fmt[sizeof(preamble) +
            sizeof(postamble) +
            2 * sizeof(quotedFmt) +
            1] ; // +1 for NUL terminator
    strcpy(fmt, preamble) ;
    strcat(fmt, mthQuoteWord(resultKey) ? "{%s}" : "%s") ;
    strcat(fmt, mthQuoteWord(resultBuf) ? quotedFmt : unQuotedFmt) ;
    strcat(fmt, postamble) ;

    fprintf(mthCmdStream, fmt, resultKey, resultBuf) ;
}
----

[source,c]
----
<<mth external function declarations>>=
extern void
mth_PortalErrorResponse(
    int portalCode) ;
----

[source,c]
----
<<mth external function definitions>>=
void
mth_PortalErrorResponse(
    int portalCode)
{
    static char const *const portalErrNames[] = {
        "no error",             // place holder for 0
        "no such class",        // MICCA_PORTAL_NO_CLASS
        "no such instance",     // MICCA_PORTAL_NO_INST
        "no such attribute",    // MICCA_PORTAL_NO_ATTR
        "instance slot is not in use", // MICCA_PORTAL_UNALLOC
        "class has no state model", // MICCA_PORTAL_NO_STATE_MODEL
        "no such event for the class", // MICCA_PORTAL_NO_EVENT
        "no such state for the class", // MICCA_PORTAL_NO_STATE
        "class does not support dynamic instances", // MICCA_PORTAL_NO_DYNAMIC
        "operation not allowed on a dependent attribute", // MICCA_PORTAL_DEPENDENT_ATTR
        "value was truncated due to lack of space", // MICCA_PORTAL_TRUNCATED
    } ;

    portalCode = -portalCode ;
    assert(portalCode < COUNTOF(portalErrNames)) ;
    char const *const errMsg = portalCode < COUNTOF(portalErrNames) ?
            portalErrNames[portalCode] : "unknown portal error" ;

    mthInitBufContext() ;
    mthAddWord(errMsg) ;
}
----

[source,c]
----
<<mth forward references>>=
static char const *mthTimestamp(void) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <sys/time.h>
#include <time.h>
----

[source,c]
----
<<mth static functions>>=
static char const *
mthTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "too big" ;
    }

    return timestamp ;
}
----

[source,c]
----
<<mth forward references>>=
static bool mthQuoteWord(char const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthQuoteWord(
    char const *pWord)
{
    assert(pWord != NULL) ;
    if (strlen(pWord) == 0) {
        return true ; // must quote the empty string
    }

    enum {
        OutOfQuote,
        InQuote
    } quoteState = OutOfQuote ;
    int quoteCount = 0 ;

    for (char c = *pWord++ ; c != ASCII_NUL ; c = *pWord++) {
        if (c == '\\') {
            pWord++ ;
            continue ;
        }
        switch (quoteState) {
        case OutOfQuote:
            if (isspace(c)) {
                return true ;
            } else if (c == '{') {
                quoteCount++ ;
                quoteState = InQuote ;
            }
            break; 

        case InQuote:
            if (c == '{') {
                quoteCount++ ;
            } else if (c == '}') {
                assert(quoteCount > 0) ;
                if (--quoteCount == 0) {
                    quoteState = OutOfQuote ;
                }
            }
            break; 
        }
    }
    return quoteCount == 0 ? false : true ;
}
----

=== Buffer Context

[source,c]
----
<<mth implementation aggregate types>>=
typedef struct mthbufcontext {
    char buf[BUFSIZ] ;
    char *location ;
    size_t remaining ;
} MTH_BufContext ;
----

[source,c]
----
<<mth implementation constants>>=
#ifndef MTH_NESTLIMIT
#   define  MTH_NESTLIMIT   4
#endif /* MTH_NESTLIMIT */
<<mth static data>>=
static MTH_BufContext contextStack[MTH_NESTLIMIT] ;
static MTH_BufContext *contextTOS ;
----

[source,c]
----
<<mth forward references>>=
static void
mthBeginResponse(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthBeginResponse(void)
{
    contextTOS = contextStack ;
    mthInitBufContext() ;
}
----

[source,c]
----
<<mth forward references>>=
static inline void
mthEndResponse(void) ;
----

[source,c]
----
<<mth static functions>>=
static inline void
mthEndResponse(void)
{
    fprintf(mthCmdStream, "%s\n", contextTOS->buf) ;
}
----

[source,c]
----
<<mth forward references>>=
static void
mthPushContext(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthPushContext(void)
{
    assert(contextTOS != NULL) ;
    assert(contextTOS < contextStack + COUNTOF(contextStack)) ;
    if (contextTOS >= contextStack + COUNTOF(contextStack)) {
        fprintf(stderr, "buffer context stack overflow\n") ;
        abort() ;
    }
    contextTOS++ ;
    mthInitBufContext() ;
}
----

[source,c]
----
<<mth forward references>>=
static void
mthPopContext(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthPopContext(void)
{
    assert(contextTOS > contextStack) ;
    if (contextTOS <= contextStack) {
        fprintf(stderr, "buffer context stack underflow\n") ;
        abort() ;
    }

    mthTrimBufContextRight() ;
    char *prevBuf = mthContextGetBuf() ;
    contextTOS -= 1 ;
    mthAddWord(prevBuf) ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthInitBufContext(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthInitBufContext(void)
{
    assert(contextTOS != NULL) ;
    contextTOS->location = contextTOS->buf ;
    *contextTOS->location = ASCII_NUL ;
    contextTOS->remaining = sizeof(contextTOS->buf) ;
}
----

[source,c]
----
<<mth external function declarations>>=
extern int
mth_FormatToContext(
    char const *format,
    ...) ;
----

[source,c]
----
<<mth external function definitions>>=
int
mth_FormatToContext(
    char const *format,
    ...)
{
    va_list params ;
    va_start(params, format) ;
    int nbytes = vsnprintf(contextTOS->location, contextTOS->remaining,
            format, params) ;
    va_end(params) ;

    if (nbytes < 0 || nbytes >= contextTOS->remaining) {
        return -1 ;
    } else {
        contextTOS->remaining -= nbytes ;
        contextTOS->location += nbytes ;
    }

    return nbytes ;
}
----

[source,c]
----
<<mth forward references>>=
static int
mthAddWord(
    char const *word) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthAddWord(
    char const *word)
{
    int nbytes = snprintf(contextTOS->location, contextTOS->remaining,
            mthQuoteWord(word) ? "{%s} " : "%s ", word) ;

    if (nbytes < 0 || nbytes >= contextTOS->remaining) {
        return -1 ;
    } else {
        contextTOS->remaining -= nbytes ;
        contextTOS->location += nbytes ;
    }

    return nbytes ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthTrimBufContextRight(void) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthTrimBufContextRight(void)
{
    while (contextTOS->location > contextTOS->buf) {
        if (isspace(*(contextTOS->location - 1))) {
            *--contextTOS->location = ASCII_NUL ;
        } else {
            break ;
        }
    }
}
----

[source,c]
----
<<mth forward references>>=
static inline char *mthContextGetBuf(void) ;
----

[source,c]
----
<<mth static functions>>=
static inline char *
mthContextGetBuf(void)
{
    return contextTOS->buf ;
}
----

== Generating a Test Harness

[source,tcl]
----
<<micca configuration>>=
operation harness {} {
    return [@Harness@::miccaHarness]
}
----

[source,tcl]
----
<<generation commands namespace>>=
namespace eval @Harness@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<harness data>>
    <<harness commands>>
}
----

[source,tcl]
----
<<harness commands>>=
proc miccaHarness {} {
    <<miccaHarness: set up template expansion>>

    set harnessfiles [list]

    <<miccaHarness: generate harness files>>

    return $harnessfiles
}
----

[source,tcl]
----
<<miccaHarness: set up template expansion>>=
textutil::expander harnessExpand
harnessExpand errmode fail
----

[source,tcl]
----
<<miccaHarness: generate harness files>>=
try {
    variable domain
    forAllRefs domainRef [Domain findAll] {
        assignAttribute $domainRef {Name domain}

        lappend harnessfiles ${domain}_harness.c
        <<miccaHarness: generate file>>
    }
} finally {
    rename harnessExpand {}
}
----

[source,tcl]
----
<<miccaHarness: generate file>>=

harnessExpand evalcmd "namespace eval [namespace current]"
set hchan [::open ${domain}_harness.c w]
try {
    variable harnessTemplate
    puts $hchan [harnessExpand expand $harnessTemplate]
} on error {result opts} {
    puts $::errorInfo
    return -options $opts $result
} finally {
    chan close $hchan
}
----

[source,tcl]
----
<<harness data>>=
set harnessTemplate [textutil::adjust::undent {
    [banner]
    /*
     * Include Files
     */
    #include "micca_tack.h"
    [domainInclude]
    /*
     * Static Data
     */
    [staticData]
    /*
     * Domain Operation Functions
     */
    [opFuncDefinitions]
    /*
     * Domain Operations Map
     */
    [opMapDefinition]
    /*
     * Domain Attribute Read Functions
     */
    [attrReadFuncDefinitions]
    /*
     * Domain Attribute Update Functions
     */
    [attrUpdateFuncDefinitions]
    /*
     * Domain Attributes Map
     */
    [attrMapDefinitions]
    /*
     * Domain Instances Map
     */
    [instMapDefinitions]
    /*
     * Domain Event Parameter Functions
     */
    [eventParamFuncDefinitions]
    /*
     * Domain Event Map
     */
    [eventMapDefinitions]
    /*
     * Domain Classes Map
     */
    [classMapDefinition]
    /*
     * Harness Definition
     */
    [harnessDefinition]
}]
----

=== Template Commands
[source,tcl]
----
<<harness commands>>=
    
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,tcl]
----
<<harness commands>>=
proc staticData {} {
    append result\
        "static char wrongNumArgsMsg\[\] = \"wrong # arguments, %d\" ;\n"\
        "static char wrongNumParamsMsg\[\] = \"wrong # event parameters, %d\" ;\n"\
        "static char badParamMsg\[\] = \"bad parameter, \\\"%s\\\"\" ;\n"\
}
----

[source,tcl]
----
<<harness commands>>=
proc opFuncDefinitions {} {
    variable domain

    set opRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R5
    } {} |%]

    set result {}
    forAllRefs opRef $opRefs {
        assignAttribute $opRef {Name opName} {ReturnDataType retType}
        append result\
            "static bool ${opName}__OPFUNC(\n"\
            "    int argc,\n"\
            "    char *const *argv)\n"\
            "\{\n"\

        set paramRefs [deRef [findRelated $opRef ~R6]]
        set nparams [expr {[relation cardinality $paramRefs] + 1}]
        append result\
            "    if (argc != $nparams) \{\n"\
            "        mth_FormatToContext(wrongNumArgsMsg, argc) ;\n"\
            "        return false ;\n"\
            "    \}\n"

        set argIndex 1
        relation foreach paramRef $paramRefs -ascending Number {
            relation assign $paramRef {DataType type} {Name paramName}
            append result\
                "    [typeCheck composeDeclaration $type $paramName] ;\n"
            try {
                set scnfmt [GetFormat $type Scan]
            } on error {} {
                set type int
                set scnfmt "\"i\""
            }
            if {$scnfmt ne {}} {
                append result\
                    "    if (sscanf(argv\[$argIndex\], \"%\" $scnfmt, "\
                    "&$paramName) != 1) \{\n"\
                    "        mth_FormatToContext(badParamMsg, argv\[$argIndex]) ;\n"\
                    "        return false ;\n"\
                    "    \}\n"
            } else {
                append result "    $paramName = argv\[$argIndex\] ;\n"
            }

            incr argIndex ;
        }

        set invokeParams [pipe {
            relation list $paramRefs Name -ascending Number |
            join ~ {, }
        }]

        try {
            set prifmt [GetFormat $retType Print]
        } on error {fmtresult} {
            set retType int
            set prifmt "\"d\""
        }

        set invocation "${domain}_${opName}($invokeParams) ;\n"
        if {$retType ne "void"} {
            append result\
                "    [typeCheck composeDeclaration $retType result__OP] = "\
                $invocation\
                "    mth_FormatToContext(\"%\" $prifmt,\ result__OP) ;\n"
        } else {
            append result\
                "    $invocation"
        }
        append result\
            "    return true ;\n"\
            "\}\n"
    }

    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc opMapDefinition {} {
    variable domain

    set opRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R5 |
        deRef %
    } {} |%]

    set result {}
    if {[relation isnotempty $opRefs]} {
        append result\
            "static MTH_OperationMap const "\
            "${domain}__OPMAP\[[relation cardinality $opRefs]\] = \{\n"

        relation foreach opRef $opRefs -ascending Name {
            relation assign $opRef Name
            append result\
                "    \{\n"\
                "        .name = \"$Name\",\n"\
                "        .func = ${Name}__OPFUNC\n"\
                "    \},\n"
        }

        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc attrReadFuncDefinitions {} {
    variable domain

    set attrRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R20 {~R25 PopulatedComponent}\
            {~R21 Attribute}
    } {} |%]

    set result {}
    forAllRefs attrRef $attrRefs {
        assignAttribute $attrRef {Class className} {Name attrName}\
            {DataType type} {Dimension dim}
        append result\
            "static bool ${className}_${attrName}__RD(\n"\
            "    MRT_DomainPortal const *portal,\n"\
            "    MRT_ClassId classId,\n"\
            "    MRT_InstId instId,\n"\
            "    MRT_AttrId attrId)\n"\
            "\{\n"

        try {
            set prifmt [GetFormat $type Print]
        } on error {fmtresult} {
            set type int
            set prifmt "\"d\""
        }

        set vardecl [typeCheck composeDeclaration $type attrValue]
        if {$dim > 0} {
            append vardecl \[$dim\]
            set vardeclptr attrValue
        } else {
            set vardeclptr &attrValue
        }

        append result\
            "    $vardecl ;\n"\
            "    int pcode = mrt_PortalReadAttr(portal, classId, instId,\
                    attrId, $vardeclptr, sizeof(attrValue)) ;\n"\
            "    if (pcode < 0) \{\n"\
            "        mth_PortalErrorResponse(pcode) ;\n"\
            "        return false ;\n"\
            "    \}\n"

        if {$type eq "char" && $dim > 0} {
            # just an ordinary string
            append result\
                "    mth_FormatToContext(\"%s\", attrValue) ;\n"\
                "    return true ;\n"
        } else {
            if {$dim == 0} {
                # ordinary scalar value
                append result\
                    "    mth_FormatToContext(\"%\" $prifmt, attrValue) ;\n"\
                    "    return true ;\n"
            } else {
                # attribute is an array
                append result\
                    "    for (int index = 0 ; index < $dim ; index++) \{\n"\
                    "        mth_FormatToContext(\
                        \"%\" $prifmt \" \", attrValue\[index\]) ;\n"\
                    "    \}\n"\
                    "    return true ;\n"
            }
        }
        append result "\}\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc attrUpdateFuncDefinitions {} {
    variable domain

    set attrRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R20 {~R25 PopulatedComponent}\
            {~R21 Attribute}
    } {} |%]

    set result {}
    forAllRefs attrRef $attrRefs {
        assignAttribute $attrRef {Class className} {Name attrName}\
            {DataType type} {Dimension dim}

        set vardecl [typeCheck composeDeclaration $type attrValue]
        append result\
            "static bool ${className}_${attrName}__UP(\n"\
            "    MRT_DomainPortal const *portal,\n"\
            "    MRT_ClassId classId,\n"\
            "    MRT_InstId instId,\n"\
            "    MRT_AttrId attrId,\n"\
            "    char const *value)\n"\
            "\{\n"

        try {
            set scnfmt [GetFormat $type Scan]
        } on error {} {
            set type int
            set scnfmt "\"i\""
        }

        if {$type eq "char" && $dim > 0} {
            # attribute is an ordinary string
            append result\
                "    int pcode = mrt_PortalUpdateAttr(portal, classId, instId,\
                        attrId, value, strlen(value) + 1) ;\n"\
                "    if (pcode < 0) \{\n"\
                "        mth_PortalErrorResponse(pcode) ;\n"\
                "        return false ;\n"\
                "    \}\n"\
                "    return true ;\n"
        } else {
            set vardecl [typeCheck composeDeclaration $type convertedValue]
            if {$dim == 0} {
                set expected 1
                set convertedRef &convertedValue
                append result\
                    "    $vardecl ;\n"\
                    "    int nitems = sscanf(value, \"%\" $scnfmt,\
                            &convertedValue) ;\n"
            } else {
                set expected $dim
                set convertedRef convertedValue
                set format "\" \" [string repeat "\"%\" $scnfmt \" \" " $dim]"
                for {set index 0} {$index < $dim} {incr index} {
                    append valuerefs ", &convertedValue\[$index\]"
                }
                append result\
                    "    $vardecl\[$dim\] ;\n"\
                    "    int nitems = sscanf(value, $format $valuerefs) ;\n"
            }
            append result\
                "    if (nitems == $expected) \{\n"\
                "        int pcode = mrt_PortalUpdateAttr(portal, classId,\
                            instId, attrId, $convertedRef,\
                            sizeof(convertedValue)) ;\n"\
                "        if (pcode < 0) \{\n"\
                "            mth_PortalErrorResponse(pcode) ;\n"\
                "            return false ;\n"\
                "        \}\n"\
                "    \} else \{\n"\
                "        mth_FormatToContext(\"failed to convert,\
                            \\\"%s\\\"  as \\\"%s\\\"\", value, $scnfmt) ;\n"\
                "        return false ;\n"\
                "    \}\n"\
                "    return true ;\n"
        }
        append result "\}\n"\
    }

    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc attrMapDefinitions {} {
    variable domain

    set attrRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R20 {~R25 PopulatedComponent}\
                {~R21 Attribute} |
        deRef % |
        relation group % Attributes Name DataType Dimension
    } {} |%]

    set result {}
    relation foreach attrRef $attrRefs {
        relation assign $attrRef {Class className} Attributes
        set nAttrs [relation cardinality $Attributes]
        append result "static MTH_AttrMap const\
                ${className}__ATTRMAP\[$nAttrs\] = \{\n"
        set attrNum -1
        relation foreach attr $Attributes -ascending Name {
            relation assign $attr {Name attrName} {DataType type}
            set rdFuncName ${className}_${attrName}__RD
            set upFuncName ${className}_${attrName}__UP
            append result\
                "    \{\n"\
                "        .name = \"$attrName\",\n"\
                "        .id = [incr attrNum],\n"\
                "        .readFunc = $rdFuncName,\n"\
                "        .updateFunc = $upFuncName,\n"\
                "    \},\n"
        }
        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc eventParamFuncDefinitions {} {
    variable domain

    set eventRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R51 R50 ~R87 R80 |
        deRef % |
        relation join % $::micca::ParameterSignature |
        relation eliminate % Number ASigID |
        relation join % $::micca::Parameter |
        relation eliminate % PSigID |
        relation join % $::micca::Argument |
        relation group % Params ASigID Name Position DataType |
        relation group % Events Event Params
    } {} |%]
    # puts [relformat $eventRefs eventRefs]

    set result {}
    set typeError false
    relation foreach eventRef $eventRefs {
        relation assign $eventRef {Model className} Events
        relation foreach event $Events {
            relation assign $event {Event eventName} Params
            set nParams [relation cardinality $Params]
            append result\
                "static bool\n"\
                "${className}_${eventName}__EPFUNC(\n"\
                "    int paramc,\n"\
                "    char * const *paramv,\n"\
                "    MRT_EventParams parambuf)\n"\
                "\{\n"\
                "    if (paramc != $nParams) \{\n"\
                "        mth_FormatToContext(wrongNumParamsMsg, paramc) ;\n"\
                "        return false ;\n"\
                "    \}\n"

            set structName ${domain}_${className}_${eventName}__EPARAMS
            append result\
                "    struct $structName *params =\
                        (struct $structName *)parambuf ;\n"\
                "    int nitems ;\n"

            set pindex 0
            relation foreach param $Params -ascending Position {
                relation assign $param {Name paramName} {DataType type}
                try {
                    set scnfmt [GetFormat $type Scan]
                } on error {} {
                    set type int
                    set scnfmt "\"i\""
                }
                append result\
                    "    nitems = sscanf(paramv\[$pindex\], \"%\" $scnfmt,\
                        &params->$paramName) ;\n"\
                    "    if (nitems != 1) \{\n"\
                    "        return false ;\n"\
                    "    \}\n"

                incr pindex
            }

            if {!$typeError} {
                append result\
                    "    return true ;\n"\
                    "\}\n"
            }
        }
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc eventMapDefinitions {} {
    variable domain

    set eventRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R51 R50 ~R87 R80 |
        deRef % |
        relation group % Events Event Number PSigID
    } {} |%]

    set result {}
    relation foreach eventRef $eventRefs {
        relation assign $eventRef {Model className} Events
        set nEvents [relation cardinality $Events]
        append result "static MTH_EventMap const\
                ${className}__EVENTMAP\[$nEvents\] = \{\n"
        relation foreach event $Events -ascending Event {
            relation assign $event {Event eventName} {Number eventNumber} PSigID
            set funcName [expr {$PSigID ne {} ?\
                "${className}_${eventName}__EPFUNC" : "NULL"}]
            append result\
                "    \{\n"\
                "        .name = \"$eventName\",\n"\
                "        .number = $eventNumber,\n"\
                "        .paramFunc = $funcName\n"\
                "    \},\n"
        }
        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc instMapDefinitions {} {
    variable domain

    set instRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} ~R20 ~R103 |
        deRef % |
        relation group % Instances Instance Number
    } {} |%]

    set result {}
    relation foreach instRef $instRefs {
        relation assign $instRef {Class className} Instances
        set nInsts [relation cardinality $Instances]
        append result "static MTH_InstMap const\
                ${className}__INSTMAP\[$nInsts\] = \{\n"
        relation foreach inst $Instances -ascending Instance {
            relation assign $inst {Instance instName} {Number instId}
            append result\
                "    \{\n"\
                "        .name = \"$instName\",\n"\
                "        .id = $instId\n"\
                "    \},\n"
        }
        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc classMapDefinition {} {
    variable domain

    set classRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} |
        deRef %
    } {} |%]

    set result {}
    if {[relation isnotempty $classRefs]} {
        append result\
            "static MTH_ClassMap const "\
            "${domain}__CLASSMAP\[[relation cardinality $classRefs]\] = \{\n"

        relation foreach ref $classRefs -ascending Name {
            set classRef [::rosea::Helpers::ToRef ::micca::Class $ref]
            assignAttribute $classRef {Name className} {Number classId}

            set compRefs [findRelated $classRef ~R20]

            set attrRefs [findRelated $compRefs {~R25 PopulatedComponent}\
                {~R21 Attribute}]
            set attrMap [expr {[isNotEmptyRef $attrRefs] ?\
                "${className}__ATTRMAP" : "NULL"}]

            set instRefs [findRelated $compRefs ~R103]
            set instMap [expr {[isNotEmptyRef $instRefs] ?\
                "${className}__INSTMAP" : "NULL"}]

            set eventRefs [findRelated $classRef ~R51 R50 ~R87 R80]
            set eventMap [expr {[isNotEmptyRef $eventRefs] ?\
                "${className}__EVENTMAP" : "NULL"}]

            append result\
                "    \{\n"\
                "        .name = \"$className\",\n"\
                "        .id = $classId,\n"\
                "        .attrs = $attrMap,\n"\
                "        .attrCount = [refMultiplicity $attrRefs],\n"\
                "        .insts = $instMap,\n"\
                "        .instCount = [refMultiplicity $instRefs],\n"\
                "        .events = $eventMap,\n"\
                "        .eventCount = [refMultiplicity $eventRefs],\n"\
                "    \},\n"
        }

        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc harnessDefinition {} {
    variable domain

    append result\
        "extern MRT_DomainPortal const ${domain}__PORTAL ;\n\n"\
        "MTH_DomainHarness const ${domain}__HARNESS = \{\n"\
        "    .portal = &${domain}__PORTAL,\n"

    set domainRef [Domain findWhere {$Name eq $domain}]
    set opRefs [findRelated $domainRef ~R5]
    set opsMap [expr {[isNotEmptyRef $opRefs] ?\
            "${domain}__OPMAP" : "NULL"}]
    append result\
        "    .operations = $opsMap,\n"\
        "    .operationCount = [refMultiplicity $opRefs],\n"

    set classRefs [findRelated $domainRef ~R1 {~R2 Class}]
    set classMap [expr {[isNotEmptyRef $classRefs] ?\
            "${domain}__CLASSMAP" : "NULL"}]
    append result\
        "    .classes = $classMap,\n"\
        "    .classCount = [refMultiplicity $classRefs],\n"
    append result "\} ;\n"
}
----

ifdef::showtests[]
[source,tcl]
----
<<harness command tests>>=
test harness-1.0 {
    Generate harness data structure
} -setup {
    validateutils genMiccaFile harness1 {
        domain harness1 {
            class X {
                attribute temp uint32_t -default 20
                attribute color char -dimension 20 -default {"red"}
                attribute status int -dimension 3 -default {{0 1 2}}

                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    transition s1 - e1 -> s2
                    state s2 {a int b unsigned} {
                        printf("in s2\n") ;
                    }
                    transition s2 - e2 -> s1
                }
            }

            domainop void init {a int b {char *}} {
                printf("initialized\n") ;
            }

            domainop int get5 {} {
                return 5 ;
            }
        }
        population harness1 {
            class X {
                instance x1
                instance x2
            }
        }
    } harness true
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles harness1_harness.c
    validateutils matchLines harness1_harness.c {
        extern MRT_DomainPortal const harness1__PORTAL ;

        MTH_DomainHarness const harness1__HARNESS = {
            .portal = &harness1__PORTAL,
            .operations = harness1__OPMAP,
            .operationCount = 2,
            .classes = harness1__CLASSMAP,
            .classCount = 1,
        } ;
    }
} -result {1}
----

=== Helper Commands

[source,tcl]
----
<<harness data>>=
# Create a simple map that maps "C" implementation types onto
# printf/scanf format strings.
relvar create FormatMap {
    ImplType string
    Print string
    Scan string
} ImplType

relvar set FormatMap [relation table {
    ImplType string             Print string         Scan  string   } {
    int                         {"d"}                {"i"}              } {
    unsigned                    {"u"}                {"i"}              } {
    {unsigned int}              {"u"}                {"i"}              } {
    short                       {"hd"}               {"hi"}             } {
    {short int}                 {"hd"}               {"hi"}             } {
    {unsigned short}            {"hu"}               {"hi"}             } {
    {unsigned short int}        {"hu"}               {"hi"}             } {
    long                        {"ld"}               {"li"}             } {
    {long int}                  {"ld"}               {"li"}             } {
    {unsigned long}             {"lu"}               {"li"}             } {
    {unsigned long int}         {"lu"}               {"li"}             } {
    size_t                      {"z"}                {"z"}              } {
    {long long}                 {"lld"}              {"lli"}            } {
    {long long int}             {"lld"}              {"lli"}            } {
    {unsigned long long}        {"llu"}              {"lli"}            } {
    {unsigned long long int}    {"llu"}              {"lli"}            } {
    {char *}                    {"s"}                {}                 } {
    {char const *}              {"s"}                {}                 } {
    {const char *}              {"s"}                {}                 } {
    {void *}                    {"p"}                {"p"}              } {
    {const void *}              {"p"}                {"p"}              } {
    {void const *}              {"p"}                {"p"}              } {
    float                       {"g"}                {"g"}              } {
    double                      {"lg"}               {"lg"}             } {
    {long double}               {"Lg"}               {"Lg"}             } {
    char                        {"hhd"}              {"hhi"}            } {
    {unsigned char}             {"hhu"}              {"hhi"}            } {
    void                        void                 {}                 } {
    bool                        {"u"}                {"u"}              } {
    uint8_t                     PRIu8                SCNi8              } {
    uint16_t                    PRIu16               SCNi16             } {
    uint32_t                    PRIu32               SCNi32             } {
    uint64_t                    PRIu64               SCNi64             } {
    int8_t                      PRId8                SCNi8              } {
    int16_t                     PRId16               SCNi16             } {
    int32_t                     PRId32               SCNi32             } {
    int64_t                     PRId64               SCNi64             } {
    intmax_t                    PRIdMAX              SCNiMAX            } {
    uintmax_t                   PRIuMAX              SCNiMAX            } {
    MRT_ClassId                 {"hu"}               {"hi"}             } {
    MRT_AssignerId              {"hu"}               {"hi"}             } {
    MRT_InstId                  {"hu"}               {"hi"}             } {
    MRT_AttrId                  {"hu"}               {"hi"}             } {
    MRT_AttrSize                {"z"}                {"z"}              } {
    MRT_AttrOffset              {"lu"}               {"li"}             } {
    MRT_DelayTime               PRIu32               SCNi32             } {
    MRT_EventCode               PRIu8                SCNi8              } {
    MRT_StateCode               PRId8                SCNi8              } ]
----

[source,tcl]
----
<<harness commands>>=
proc GetFormat {implType which} {
    variable domain

    set fmt [relvar restrictone FormatMap ImplType $implType]
    if {[relation isempty $fmt]} {
        set alias [TypeAlias findById Domain $domain TypeName $implType]
        if {[isEmptyRef $alias]} {
            error "unknown data type, $implType"
        }
        set tdef [readAttribute $alias TypeDefinition]
        set fmt [relvar restrictone FormatMap ImplType $tdef]
        if {[relation isempty $fmt]} {
            error "unknown data type, $tdef"
        }
    }
    return [relation extract $fmt $which]
}
----

== Tack Code Organization

Place holder.

=== Tack Header File

[source,c]
----
<<micca_tack.h>>=
/*
<<copyright info>>
*
<<version info>>
*
*/

#ifndef MICCA_HARNESS_H_
#define MICCA_HARNESS_H_

/*
 * Include Files
 */
#include "micca_rt.h"
<<mth interface includes>>

/*
 * Preprocessor Defines
 */
<<mth interface defines>>

/*
 * Constants
 */
<<mth interface constants>>

/*
 * Data Types
 */
<<mth interface simple types>>
<<mth interface aggregate types>>

/*
 * Static Inline Functions
 */
<<mth interface static inlines>>

/*
 * External Functions
 */
<<mth external function declarations>>

#endif /* MICCA_HARNESS_H_ */
----

=== Harness Code File

[source,c]
----
<<micca_tack.c>>=
/*
<<copyright info>>
*
<<version info>>
*
*/

/*
 * Include Files
 */
#define _POSIX_C_SOURCE 200112L
#include "micca_tack.h"
<<mth implementation includes>>

/*
 * Macros
 */
#ifndef NDEBUG
#   define  dbgprintf(...)    printf(__VA_ARGS__)
#else
#   define  dbgprintf(...)
#endif /* NDEBUG */

#define ASCII_NUL       '\0'
#define BEGIN_QUOTE     '{'
#define END_QUOTE       '}'
#define ESCAPE_CHAR     '\\'

#define OUTOFWORD   0
#define INWORD      1
#define INESCAPE    2
#define INQUOTE     3

/*
 * Constants
 */
<<mth implementation constants>>

/*
 * Data Types
 */
<<mth implementation simple types>>
<<mth implementation aggregate types>>

/*
 * Forward References
 */
<<mth forward references>>

/*
 * Static Data
 */
<<mth static data>>

/*
 * Static Inline Functions
 */
<<mth implementation static inlines>>

/*
 * Static Functions
 */
<<mth static functions>>

/*
 * External Functions
 */
<<mth external function definitions>>
----
