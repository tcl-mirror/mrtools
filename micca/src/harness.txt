// vim:set syntax=asciidoc:

= Generating a Test Harness

[partintro]
.Generating a Test Harness
--
The `micca` run-time is capable of executing in a POSIX environment.
This is intended primarily to be able to simulate and integrate
a system that is ultimately targeted for a micro-processor in an
environment that has more capability for testing and introspection.
To support this important activity,
`micca` can automatically generate a test harness in which one or
more domains may be run.
--

== Introduction

Place holder.

== Test Harness Operation

Place holder.

=== Harness Data Structures

Place holder.

==== Domain Harness Information

Each domain is well encapsulated and stands alone.
The test harness will resolve to which domain an operation is directed
and then will need the information about that domain to carry out
the operation.

One of the most important pieces of information is the
domain portal data that `micca` generates.
This provides much information to the test harness and provides the
means, via the
<<portal-access-functions>>
of the run-time,
to access the various aspects of a domain, _e.g._ send events and read
attributes.

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthdomainharness {
    MRT_DomainPortal const *portal ;
    struct mthoperationmap const *const operations ;
    unsigned operationCount ;
    struct mthclassmap const *const classes ;
    unsigned classCount ;
} MTH_DomainHarness ;
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthoperationmap {
    char const *name ;
    MTH_DomainOpFunc *func ;
} MTH_OperationMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef void MTH_DomainOpFunc(int, char *const *) ;
----

[source,c]
----
<<mth forward references>>=
static MTH_OperationMap const *const
mthFindOperation(
    MTH_DomainHarness const *const harness,
    char const *opName) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_OperationMap const *const
mthFindOperation(
    MTH_DomainHarness const *const harness,
    char const *opName)
{
    MTH_OperationMap key = {
        .name = opName,
        .func = NULL
    } ;
    return (MTH_OperationMap const *const)
            bsearch(&key, harness->operations, harness->operationCount,
            sizeof(key), mthOperationMapCompare) ;
}
----

[source,c]
----
<<mth forward references>>=
static int mthOperationMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthOperationMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_OperationMap const *cm1 = m1 ;
    MTH_OperationMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthclassmap {
    char const *name ;
    MRT_ClassId id ;
    struct mthattrmap const *attrs ;
    unsigned attrCount ;
    struct mthinstmap const *insts ;
    unsigned instCount ;
    struct mtheventmap const *events ;
    unsigned eventCount ;
} MTH_ClassMap ;
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthattrmap {
    char const *name ;
    MRT_AttrId id ;
    MTH_AttrReadFunc *readFunc ;
    MTH_AttrUpdateFunc *updateFunc ;
} MTH_AttrMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef bool MTH_AttrReadFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId, char const **) ;
----

[source,c]
----
<<mth interface simple types>>=
typedef bool MTH_AttrUpdateFunc(MRT_DomainPortal const *, MRT_ClassId,
        MRT_InstId, MRT_AttrId, char const *, char const **) ;
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mthinstmap {
    char const *name ;
    MRT_InstId id ;
} MTH_InstMap ;
----

[source,c]
----
<<mth interface aggregate types>>=
typedef struct mtheventmap {
    char const *name ;
    MRT_EventCode number ;
    MTH_EventParamFunc *paramFunc ;
} MTH_EventMap ;
----

[source,c]
----
<<mth interface simple types>>=
typedef bool MTH_EventParamFunc(int, char const **, MRT_EventParams) ;
----

=== Harness Functions

Place holder.

==== Harness Initialization

Before any harness activity can happen,
it is necessary invoke the initialization function for the harness
library.
This is typically done in `main` and must be done after
the `micca` run-time is initialized, _i.e._ after `mrt_Initialize`
has been invoked.

[source,c]
----
<<mth external function declarations>>=
extern int mth_Initialize(void) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <sys/socket.h>
#include <errno.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>
#include <inttypes.h>
----

[source,c]
----
<<mth external function definitions>>=
int
mth_Initialize(void)
{
    mthServiceSock = socket(AF_INET, SOCK_STREAM, 0) ;
    if (mthServiceSock == -1) {
        perror("unable to obtain AF_INET stream socket") ;
        return -1 ;
    }

    struct sockaddr_in hsrvAddr ;
    memset(&hsrvAddr, 0, sizeof(hsrvAddr)) ;
#       ifdef __APPLE__
    hsrvAddr.sin_len = sizeof(hsrvAddr) ;
#       endif /* __APPLE__ */
    hsrvAddr.sin_family = AF_INET ;
    hsrvAddr.sin_port = htons(HARNESS_PORT) ;

    static char const host[] = "localhost" ;
    struct hostent *hostAddr = gethostbyname(host) ;
    if (hostAddr == NULL) {
        perror(host) ;
        return -1 ;
    }
    assert(hostAddr->h_addrtype == AF_INET) ;
    memcpy(&hsrvAddr.sin_addr, hostAddr->h_addr_list[0], hostAddr->h_length) ;

    int err = bind(mthServiceSock, (struct sockaddr const *)&hsrvAddr,
            sizeof(hsrvAddr)) ;
    if (err == -1) {
        perror("bind()") ;
        return -1 ;
    }

    err = listen(mthServiceSock, 1) ;
    if (err == -1) {
        perror("listen()") ;
        return -1 ;
    }

    mrt_RegisterFDService(mthServiceSock, mthAcceptConnection, NULL, NULL) ;
    mrt_RegisterSignal(SIGQUIT, mthExit) ;
    mrt_RegisterSignal(SIGINT, mthExit) ;
    mrt_RegisterSignal(SIGTERM, mthExit) ;

    mrt_RegisterTraceHandler(NULL) ; // start with tracing off

    return mthServiceSock ;
}
----

[source,c]
----
<<mth implementation constants>>=
#ifndef HARNESS_PORT
#   define HARNESS_PORT 3906
#endif /* HARNESS_PORT */
----

[source,c]
----
<<mth static data>>=
int mthServiceSock = -1 ;
----

[source,c]
----
<<mth static functions>>=
static void
mthExit(
    int signal)
{
    dbgprintf("caught signal %d\n", signal) ;
    if (mthServiceSock != -1) {
        shutdown(mthServiceSock, SHUT_RDWR) ;
    }
    if (mthCmdStream != NULL) {
        fclose(mthCmdStream) ;
    }
    exit(EXIT_SUCCESS) ;
}
----
[source,c]
----
<<mth static functions>>=
static void
mthAcceptConnection(
    int sock)
{
    int fd = accept(sock, NULL, 0) ;

    int err = shutdown(mthServiceSock, SHUT_RDWR) ;
    if (err == -1) {
        perror("shutdown()") ;
        exit(EXIT_FAILURE) ;
    }
    mrt_UnregisterFDService(sock, true, false, false) ;
    mthServiceSock = -1 ;

    if (fd == -1) {
        perror("accept()") ;
        exit(EXIT_FAILURE) ;
    }

    mrt_RegisterFDService(fd, mthReadAndEvalCommand, NULL, NULL) ;
    mthCmdStream = fdopen(fd, "w+") ;
    err = setvbuf(mthCmdStream, NULL, _IOLBF, 0) ;
}
----

[source,c]
----
<<mth implementation includes>>=
#include <unistd.h>
----

[source,c]
----
<<mth static data>>=
FILE *mthCmdStream ;
----

==== Command Execution

[source,c]
----
<<mth forward references>>=
static void mthReadAndEvalCommand(int) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthReadAndEvalCommand(
    int rfd)
{
    static char cmdBuffer[BUFSIZ] ;

    char *cmd = fgets(cmdBuffer, sizeof(cmdBuffer), mthCmdStream) ;
    if (cmd == NULL) {
        if (feof(mthCmdStream)) {
            dbgprintf("goodbye\n") ;
            fclose(mthCmdStream) ;
            exit(EXIT_SUCCESS) ;
        } else if (ferror(mthCmdStream)) {
            perror("fgets()") ;
            fclose(mthCmdStream) ;
            exit(EXIT_FAILURE) ;
        } else {
            printf("partial\n") ;
            return ;
        }
    }
    for (char *end = cmdBuffer + strlen(cmdBuffer) - 1 ; isspace(*end) ; end--) {
        *end = ASCII_NUL ;
    }
    dbgprintf("%s\n", cmdBuffer) ;

    int argc ;
    char *const *argv ;
    static char parseBuffer[BUFSIZ] ;
    strcpy(parseBuffer, cmdBuffer) ;

    int err = mthParseCommand(parseBuffer, &argc, &argv) ;
    if (err == -1) {
        mth_CmdResponse(mthErrorReturn, "unknown",
                "failed to parse command: \"%s\"", cmdBuffer) ;
        return ;
    }

#if 0
    dbgprintf("got %d arguments\n", argc) ;
#       ifndef NDEBUG
    for (int i = 0 ; i < argc ; i++) {
        printf("%d: \"%s\"\n", i, argv[i]) ;
    }
#       endif /* NDEBUG */
#endif

    if (argc > 0) {
        mthExecCommand(argc, argv) ;
    }
}
----

[source,c]
----
<<mth forward references>>=
static int mthParseCommand(char *, int *, char *const **) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <ctype.h>
----

[source,c]
----
<<mth static functions>>=
static int
mthParseCommand(
    char *line,
    int *pargc,
    char *const **pargv)
{
    #define MAX_ARGS    64
    static char *args[MAX_ARGS] ;

    char **pArgv = args ;
    char **const argvEnd = pArgv + MAX_ARGS ;

    int quoteCount = 0 ;
    int parseState = OutOfWord ;
    int parseStackStorage[2] ;
    int *parseStackTop = parseStackStorage ;

    char *pWord = line ;
    for ( ; *line != ASCII_NUL ; line++) {
        char c = *line ;
        switch (parseState) {
        case OutOfWord:
            if (isgraph(c)) {
                if (c == ESCAPE_CHAR) {
                    *parseStackTop++ = InWord ;
                    parseState = InEscape ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else if (c == BEGIN_QUOTE) {
                    *parseStackTop++ = OutOfWord ;
                    parseState = InQuote ;
                    ++quoteCount ;
                    if (pArgv < argvEnd) {
                        *pArgv++ = ++pWord ;
                    } else {
                        return -1 ;
                    }
                } else {
                    // new word beginning
                    if (pArgv < argvEnd) {
                        *pArgv++ = pWord ;
                    } else {
                        fprintf(stderr, "exceeded max arguments") ;
                        return -1 ;
                    }
                    *pWord++ = c ;
                    parseState = InWord ;
                }
            } // else the character is just space to skip
            break ;

        case InWord:
            if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = InEscape ;
            } else if (c == BEGIN_QUOTE) {
                *parseStackTop++ = parseState ;
                parseState = InQuote ;
                ++quoteCount ;
            } else if (isspace(c)) {
                // end of word
                parseState = OutOfWord ;
                *pWord++ = ASCII_NUL ;
            } else {
                *pWord++ = c ;
            }
            break ;

        case InEscape:
            switch (c) {
                case 'a':
                    *pWord++ = '\a' ;
                    break ;
                case 'b':
                    *pWord++ = '\b' ;
                    break ;
                case 't':
                    *pWord++ = '\t' ;
                    break ;
                case 'n':
                    *pWord++ = '\n' ;
                    break ;
                case 'v':
                    *pWord++ = '\v' ;
                    break ;
                case 'f':
                    *pWord++ = '\f' ;
                    break ;
                case 'r':
                    *pWord++ = '\r' ;
                    break ;
                default:
                    *pWord++ = c ;
                    break ;
            }
            parseState = *--parseStackTop ;
            break ;

        case InQuote:
            if (c == BEGIN_QUOTE) {
                ++quoteCount ;
                *pWord++ = c ;
            } else if (c == END_QUOTE) {
                if (--quoteCount == 0) {
                    parseState = *--parseStackTop ;
                    // check if ending the quote also ended the word
                    if (parseState == OutOfWord) {
                        *pWord++ = ASCII_NUL ;
                    }
                } else {
                    *pWord++ = c ;
                }
            } else if (c == ESCAPE_CHAR) {
                *parseStackTop++ = parseState ;
                parseState = InEscape ;
            } else {
                *pWord++ = c ;
            }
            break ;
        }
    }

    *pWord = ASCII_NUL ;
    *pArgv = NULL ;
    if (quoteCount == 0 && parseState != InEscape) {
        if (pargc) {
            *pargc = pArgv - args ;
        }
        if (pargv) {
            *pargv = args ;
        }
        return 0 ;
    } else {
        return -1 ;
    }
}
----

[source,c]
----
<<mth implementation aggregate types>>=
typedef struct mthcommandmap {
    char const *name ;
    MTH_CommandFunc *commandFunc ;
} MTH_CommandMap ;
----

[source,c]
----
<<mth implementation simple types>>=
typedef void MTH_CommandFunc(int, char * const*) ;
----

==== Defined Commands

[source,c]
----
<<mth static data>>=
static MTH_CommandMap const commands[] = { // must be in ascending "name" order
{
    .name = "dop",
    .commandFunc = mthDopCommand
},
{
    .name = "query",
    .commandFunc = mthQueryCommand
},
{
    .name = "trace",
    .commandFunc = mthTraceCommand
},
} ;
----

[source,c]
----
<<mth forward references>>=
static void mthExecCommand(int, char * const *) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthExecCommand(
    int argc,
    char *const *argv)
{
    MTH_CommandMap key = {
        .name = argv[0],
        .commandFunc = NULL
    } ;

    MTH_CommandMap const *cmd = (MTH_CommandMap const *)
            bsearch(&key, commands, COUNTOF(commands), sizeof(commands[0]),
            mthCommandMapCompare) ;
    if (cmd != NULL) {
        assert(cmd->commandFunc != NULL) ;
        cmd->commandFunc(argc, argv) ;
    } else {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown command, \"%s\"", argv[0]) ;
    }
}
----

[source,c]
----
<<mth forward references>>=
static int mthCommandMapCompare(void const*, void const*) ;
----

[source,c]
----
<<mth static functions>>=
static int
mthCommandMapCompare(
    void const *m1,
    void const *m2)
{
    MTH_CommandMap const *cm1 = m1 ;
    MTH_CommandMap const *cm2 = m2 ;

    return strcmp(cm1->name, cm2->name) ;
}
----

==== Registering a Domain

[source,c]
----
<<mth external function declarations>>=
extern bool mth_RegisterDomain(MTH_DomainHarness const *harness) ;
----

[source,c]
----
<<mth external function definitions>>=
bool
mth_RegisterDomain(
    MTH_DomainHarness const *harness)
{
    assert(harness != NULL) ;
    assert(harness->portal != NULL) ;
    assert(harness->portal->name != NULL) ;

    MTH_DomainHarness const *const registeredHarness =
            mthFindHarness(harness->portal->name) ;

    bool inserted ;
    if (registeredHarness == NULL) {
        mthInsertHarness(harness) ;
        inserted = true ;
    } else {
        inserted = false ;
    }

    return inserted ;
}
----

[source,c]
----
<<mth implementation aggregate types>>=
typedef struct mthharnessregistry {
    unsigned count ;
    MTH_DomainHarness const *harnesses[MTH_MAX_DOMAINS] ;
} MTH_HarnessRegistry ;
----

[source,c]
----
<<mth implementation constants>>=
#ifndef MTH_MAX_DOMAINS
#   define MTH_MAX_DOMAINS  16
#endif /* MTH_MAX_DOMAINS */
----

[source,c]
----
<<mth static data>>=
MTH_HarnessRegistry mthHarnesses ;
----

[source,c]
----
<<mth forward references>>=
static MTH_DomainHarness const *const
mthFindHarness(
    char const *domainName) ;
----

[source,c]
----
<<mth static functions>>=
static MTH_DomainHarness const *const
mthFindHarness(
    char const *domainName)
{
    assert(domainName != NULL) ;

    MTH_DomainHarness const *const *hiter = mthHarnesses.harnesses ;
    for (unsigned count = mthHarnesses.count ; count != 0 ; count--) {
        MTH_DomainHarness const *const harness = *hiter++ ;
        assert(harness->portal != NULL) ;
        assert(harness->portal->name != NULL) ;
        if (strcmp(domainName, harness->portal->name) == 0) {
            return harness ;
        }
    }
    return NULL ;
}
----

[source,c]
----
<<mth forward references>>=
static void
mthInsertHarness(
    MTH_DomainHarness const *const) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthInsertHarness(
    MTH_DomainHarness const *const harness)
{
    assert(harness != NULL) ;
    assert(mthHarnesses.count < COUNTOF(mthHarnesses.harnesses)) ;
    if (mthHarnesses.count < COUNTOF(mthHarnesses.harnesses)) {
        mthHarnesses.harnesses[mthHarnesses.count++] = harness ;
    }
}
----

=== Harness Command Functions

==== Domain Operation Command

[source,c]
----
<<mth forward references>>=
static void mthDopCommand(int, char *const *) ;
----

[literal]
--
dop <domain> <operation> ?<arg1> <arg2> ...?
--

[source,c]
----
<<mth static functions>>=
static void
mthDopCommand(
    int argc,
    char *const *argv)
{
    if (argc < 3) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, "
            "dop <domain> <operation> ?<arg1> <arg2> ...?",
            argc) ;
        return ;
    }

    char *domainName = argv[1] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown domain, \"%s\"", domainName) ;
        return ;
    }

    char *opName = argv[2] ;
    MTH_OperationMap const *const opMap = mthFindOperation(harness, opName) ;
    if (opMap == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "unknown operation, \"%s\"", opName) ;
        return ;
    }
    opMap->func(argc, argv) ;
}
----

==== Query Command

[source,c]
----
<<mth forward references>>=
static void mthQueryCommand(int, char *const *) ;
----

[literal]
--
query domains
query classes <domain>
query attributes <domain> <class>
query instances <domain> <class>
query events <domain> <class>
query states <domain> <class>
query currentstate <domain> <class>
--

[source,c]
----
<<mth static functions>>=
static void
mthQueryCommand(
    int argc,
    char *const *argv)
{
    if (argc < 2) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, "
            "query <subcmd> ?<domain> <arg1> <arg2> ...?",
            argc) ;
        return ;
    }

    char *subcmdName = argv[1] ;
    if (strcmp(subcmdName, "domains") == 0) {
        mthQueryDomains(argc, argv) ;
    } else if (strcmp(subcmdName, "classes") == 0) {
        mthQueryClasses(argc, argv) ;
    } else {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "unknown subcommand, \"%s\": expected, "
            "\"domains | classes | attributes | instances | events "
            "| states | currentstate\"", subcmdName) ;
    }
}
----

[source,c]
----
<<mth forward references>>=
static void mthQueryDomains(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthQueryDomains(
    int argc,
    char *const *argv)
{
    static char queryBuf[BUFSIZ] ;

    *queryBuf = ASCII_NUL ;
    size_t bufSize = sizeof(queryBuf) - 1 ; // -1 to account for a NUL

    MTH_DomainHarness const *const *hiter = mthHarnesses.harnesses ;
    for (unsigned count = mthHarnesses.count ; count != 0 ; count--) {
        MTH_DomainHarness const *const harness = *hiter++ ;
        assert(harness->portal != NULL) ;
        assert(harness->portal->name != NULL) ;

        char const *domainName = harness->portal->name ;
        int nameLen = strlen(domainName) ;
        if (nameLen >= bufSize) {
            strncat(queryBuf, domainName, bufSize) ;
            bufSize -= nameLen ;
        } else {
            strncat(queryBuf, "...", bufSize) ;
            break ;
        }
    }
    mth_CmdResponse(mthOkReturn, argv[0], queryBuf) ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthQueryClasses(
    int argc,
    char *const *argv) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthQueryClasses(
    int argc,
    char *const *argv)
{
    if (argc != 3) {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, \"query classes <domain>\"",
            argc) ;
        return ;
    }

    char *domainName = argv[2] ;
    MTH_DomainHarness const *const harness = mthFindHarness(domainName) ;
    if (harness == NULL) {
        mth_CmdResponse(mthErrorReturn, argv[0],
                "unknown domain, \"%s\"", domainName) ;
        return ;
    }
    MRT_DomainPortal const *portal = harness->portal ;
    assert(portal != NULL) ;

    static char queryBuf[BUFSIZ] ;
    *queryBuf = ASCII_NUL ;
    size_t bufSize = sizeof(queryBuf) - 1 ; // -1 to account for a NUL

    unsigned classCount = mrt_PortalDomainClassCount(portal) ;
    for (MRT_ClassId id = 0 ; id < classCount ; id++) {
        char const *className = NULL ;
        int pcode = mrt_PortalClassName(portal, id, &className) ;
        if (pcode == 0) {
            int nameLen = strlen(className) ;
            if (nameLen >= bufSize) {
                strncat(queryBuf, className, bufSize) ;
                bufSize -= nameLen ;
            } else {
                strncat(queryBuf, "...", bufSize) ;
                break ;
            }
        } else {
            mthPortalErrorResponse(pcode, argv[0]) ;
        }
    }

    mth_CmdResponse(mthOkReturn, argv[0], queryBuf) ;
}
----

==== Trace Command

[source,c]
----
<<mth forward references>>=
static void mthTraceCommand(int, char *const *) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthTraceCommand(
    int argc,
    char *const *argv)
{
    if (argc == 1) {
        MRT_TraceHandler handler = mrt_RegisterTraceHandler(NULL) ;
        mrt_RegisterTraceHandler(handler) ;
        mth_CmdResponse(mthOkReturn, argv[0], handler == NULL ? "off" : "on") ;
    } else if (argc == 2) {
        if (strcmp(argv[1], "on") == 0) {
            mrt_RegisterTraceHandler(mthTraceResponse) ;
            mth_CmdResponse(mthOkReturn, argv[0], "on") ;
        } else if (strcmp(argv[1], "off") == 0) {
            mrt_RegisterTraceHandler(NULL) ;
            mth_CmdResponse(mthOkReturn, argv[0], "off") ;
        } else {
            mth_CmdResponse(mthErrorReturn, argv[0],
                    "unknown trace option, \"%s\": expected, \"on | off\"",
                    argv[1]) ;
        }
    } else {
        mth_CmdResponse(mthErrorReturn, argv[0],
            "wrong # of arguments, %d: expected, \"trace ?on | off?\"", argc) ;
        return ;
    }
}
----

=== Common Functions

[source,c]
----
<<mth interface simple types>>=
typedef enum mthreturntype {
    mthOkReturn,
    mthErrorReturn
} MTH_ReturnType ;
----

[source,c]
----
<<mth implementation includes>>=
#include <stdarg.h>
----

[source,c]
----
<<mth external function declarations>>=
extern void
mth_CmdResponse(
    MTH_ReturnType returnCode,
    char const *cmdName,
    char const *resultFmt,
    ...) ;
----

[source,c]
----
<<mth external function definitions>>=
void
mth_CmdResponse(
    MTH_ReturnType returnCode,
    char const *cmdName,
    char const *resultFmt,
    ...)
{
    va_list resultArgs ;
    va_start(resultArgs, resultFmt) ;

    static char resultBuf[BUFSIZ] ;
    int n = vsnprintf(resultBuf, sizeof(resultBuf), resultFmt, resultArgs) ;

    va_end(resultArgs) ;

    if (n < 0) {
        strcpy(resultBuf, "error formating response") ;
    } else if (n > sizeof(resultBuf)) {
        strcpy(resultBuf, "response truncated") ;
    }

    static char preamble[] = "cmd {" ;
    static char postamble[] = "}\n" ;
    static char nameKey[] = "name" ; // N.B. no leading blank, it's first.
    static char returnKey[] = " return" ;
    static char resultKey[] = " result" ;
    static char unQuotedFmt[] = " %s" ;
    static char quotedFmt[] = " {%s}" ;

    char fmt[sizeof(preamble) +
            sizeof(postamble) +
            sizeof(nameKey) +
            sizeof(returnKey) +
            sizeof(mthErrorReturn) +
            sizeof(resultKey) +
            3 * sizeof(quotedFmt) +
            1] ; // +1 for NUL terminator
    strcpy(fmt, preamble) ;

    strcat(fmt, nameKey) ;
    strcat(fmt, mthQuoteWord(cmdName) ? quotedFmt : unQuotedFmt) ;

    static char const mthOkValue[] = " ok" ;
    static char const mthErrorValue[] = " error" ;
    strcat(fmt, returnKey) ;
    strcat(fmt, returnCode == mthOkReturn ? mthOkValue : mthErrorValue) ;

    strcat(fmt, resultKey) ;
    strcat(fmt, mthQuoteWord(resultBuf) ? quotedFmt : unQuotedFmt) ;

    strcat(fmt, postamble) ;

    fprintf(mthCmdStream, fmt, cmdName, resultBuf) ;
}
----

[source,c]
----
<<mth forward references>>=
static void mthTraceResponse(MRT_TraceInfo const *) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthTraceResponse(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
        char const *newStateName ;
        if (newState == MRT_StateCode_IG) {
            newStateName = "IG" ;
        } else if (newState == MRT_StateCode_CH) {
            newStateName = "CH" ;
        } else {
            newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.newState] ;
        }

        fprintf(mthCmdStream,
                "trace {"
                "type transition "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "currstate %s "
                "newstate %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.currentState],
            newStateName,
            mthTimestamp()) ;
    }
        break ;

    case mrtPolymorphicEvent: {
        MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
                genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
        MRT_Class const *subclass ;
        char const *subname = NULL ;
        if (rel->relType == mrtRefGeneralization) {
            subclass = rel->relInfo.refGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
            subname = subclass->name ;
        } else if (rel->relType == mrtUnionGeneralization) {
            subclass = rel->relInfo.unionGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode] ;
            subname = subclass->name ;
        } else {
            printf("%s: bad relationship type in polymorphic event, %d\n",
                mthTimestamp(), rel->relType) ;
            break ;
        }
        fprintf(mthCmdStream,
                "trace {"
                "type polymorphic "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "relationship %s "
                "newevent %s "
                "subclass %s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->pdb->genNames[
                traceInfo->info.polyTrace.genNumber],
            subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
            subname,
            mthTimestamp()) ;
    }
        break ;

    case mrtCreationEvent:
        fprintf(mthCmdStream,
                "trace {"
                "type creation "
                "event %s "
                "source %s.%s "
                "target %s.%s "
                "time %s"
                "}\n",
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            sourceClassName, sourceName,
            traceInfo->info.creationTrace.targetClass->name, targetName,
            mthTimestamp()) ;
        break ;

    default:
        fprintf(mthCmdStream,
                "trace {"
                "type error "
                "result {unknown trace event type, \"%u\"} "
                "time %s"
                "}\n",
            traceInfo->eventType,
            mthTimestamp()) ;
        break ;
    }
}
----

[source,c]
----
<<mth forward references>>=
static void
mthPortalErrorResponse(
    int portalCode,
    char *cmdName) ;
----

[source,c]
----
<<mth static functions>>=
static void
mthPortalErrorResponse(
    int portalCode,
    char *cmdName)
{
    static char const *const portalErrNames[] = {
        "no error",             // place holder for 0
        "no such class",        // MICCA_PORTAL_NO_CLASS
        "no such instance",     // MICCA_PORTAL_NO_INST
        "no such attribute",    // MICCA_PORTAL_NO_ATTR
        "instance slot is not in use", // MICCA_PORTAL_UNALLOC
        "class has no state model", // MICCA_PORTAL_NO_STATE_MODEL
        "no such event for the class", // MICCA_PORTAL_NO_EVENT
        "no such state for the class", // MICCA_PORTAL_NO_STATE
        "class does not support dynamic instances", // MICCA_PORTAL_NO_DYNAMIC
        "operation not allowed on a dependent attribute", // MICCA_PORTAL_DEPENDENT_ATTR
        "value was truncated due to lack of space", // MICCA_PORTAL_TRUNCATED
    } ;

    portalCode = -portalCode ;
    assert(portalCode < COUNTOF(portalErrNames)) ;
    char const *const errMsg = portalCode < COUNTOF(portalErrNames) ?
            portalErrNames[portalCode] : "unknown portal error" ;

    mth_CmdResponse(mthErrorReturn, cmdName, errMsg) ;
}
----

[source,c]
----
<<mth forward references>>=
static char const *mthTimestamp(void) ;
----

[source,c]
----
<<mth implementation includes>>=
#include <sys/time.h>
#include <time.h>
----

[source,c]
----
<<mth static functions>>=
static char const *
mthTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "too big" ;
    }

    return timestamp ;
}
----

[source,c]
----
<<mth forward references>>=
static bool mthQuoteWord(char const *) ;
----

[source,c]
----
<<mth static functions>>=
static bool
mthQuoteWord(
    char const *pWord)
{
    assert(pWord != NULL) ;
    int wlen = strlen(pWord) ;

    for (char c = *pWord++ ; c != ASCII_NUL ; c = *pWord++) {
        if (isspace(c) || c == '\\' || c == '\"') {
            return true ;
        }
    }

    return wlen == 0 ? true : false ;
}
----

== Generating a Test Harness

[source,tcl]
----
<<micca configuration>>=
operation harness {} {
    return [@Harness@::miccaHarness]
}
----

[source,tcl]
----
<<generation commands namespace>>=
namespace eval @Harness@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<harness data>>
    <<harness commands>>
}
----

[source,tcl]
----
<<harness commands>>=
proc miccaHarness {} {
    <<miccaHarness: set up template expansion>>

    set harnessfiles [list]

    <<miccaHarness: generate harness files>>

    return $harnessfiles
}
----

[source,tcl]
----
<<miccaHarness: set up template expansion>>=
textutil::expander harnessExpand
harnessExpand errmode fail
----

[source,tcl]
----
<<miccaHarness: generate harness files>>=
try {
    variable domain
    forAllRefs domainRef [Domain findAll] {
        assignAttribute $domainRef {Name domain}

        lappend harnessfiles ${domain}_harness.c
        <<miccaHarness: generate file>>
    }
} finally {
    rename harnessExpand {}
}
----

[source,tcl]
----
<<miccaHarness: generate file>>=

harnessExpand evalcmd "namespace eval [namespace current]"
set hchan [::open ${domain}_harness.c w]
try {
    variable harnessTemplate
    puts $hchan [harnessExpand expand $harnessTemplate]
} on error {result opts} {
    puts $::errorInfo
    return -options $opts $result
} finally {
    chan close $hchan
}
----

[source,tcl]
----
<<harness data>>=
set harnessTemplate [textutil::adjust::undent {
    [banner]
    /*
     * Include Files
     */
    #include "micca_harness.h"
    /*
     * Static Data
     */
    [staticData]
    /*
     * Domain Operation Functions
     */
    [opFuncDefinitions]
    /*
     * Domain Operations Map
     */
    [opMapDefinition]
    /*
     * Domain Attributes Map
     */
    [attrMapDefinitions]
    /*
     * Domain Classes Map
     */
    [classMapDefinition]
    /*
     * Harness Definition
     */
    [harnessDefinition]
}]
----

==== Template Commands

[source,tcl]
----
<<harness commands>>=
proc staticData {} {
    append result\
        "static char responseBuffer\[BUFSIZ\] ;\n"\
        "static char emptyString\[\] = \"\" ;\n"\
        "static char wrongNumArgsMsg\[\] = \"wrong # arguments, %d\" ;\n"\
        "static char badParamMsg\[\] = \"bad parameter, \\\"%s\\\"\" ;\n"
}
----

[source,tcl]
----
<<harness commands>>=
proc opFuncDefinitions {} {
    variable domain

    set opRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R5
    } {} |%]

    set result {}
    forAllRefs opRef $opRefs {
        assignAttribute $opRef {Name opName} {ReturnDataType retType}
        append result\
            "static void ${opName}__OPFUNC(\n"\
            "    int argc,\n"\
            "    char *const *argv)\n"\
            "\{\n"\

        set paramRefs [deRef [findRelated $opRef ~R6]]
        set nparams [expr {[relation cardinality $paramRefs] + 1}]
        append result\
            "    if (argc != $nparams) \{\n"\
            "        mth_CmdResponse(mthErrorReturn, argv\[0],\
                        wrongNumArgsMsg, argc) ;\n"\
            "        return ;\n"\
            "    \}\n"

        set argIndex 1
        relation foreach paramRef $paramRefs -ascending Number {
            relation assign $paramRef {DataType type} {Name paramName}
            append result\
                "    [typeCheck composeDeclaration $type $paramName] ;\n"
            set scnfmt [GetFormat $type Scan]
            if {$scnfmt ne {}} {
                append result\
                    "    if (sscanf(argv\[$argIndex\], \"%\"$scnfmt, "\
                    "&$paramName) != 1) \{\n"\
                    "        mrt_CmdResponse(mthErrorReturn, argv\[0],\
                                badParamMsg, argv\[$argIndex]) ;\n"\
                    "        return ;\n"\
                    "    \}\n"
            } else {
                append result "    $paramName = argv\[$argIndex\] ;\n"
            }

            incr argIndex ;
        }

        set invokeParams [pipe {
            relation list $paramRefs Name -ascending Number |
            join ~ {, }
        }]

        set invocation "${domain}_${opName}($invokeParams) ;\n"
        if {$retType ne "void"} {
            append result\
                    "    [typeCheck composeDeclaration $retType result__P] = "\
                    $invocation
            set prifmt [GetFormat $retType Print]
            append result\
                "    mth_CmdResponse(mthOkReturn, argv\[0], \"%\"$prifmt,\
                        result__P) ;\n"
        } else {
            append result\
                "    $invocation"\
                "    mth_CmdResponse(mthOkReturn, argv\[0], emptyString) ;\n"
        }

        append result "\}\n"\
    }

    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc opMapDefinition {} {
    variable domain

    set opRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R5 |
        deRef %
    } {} |%]

    set result {}
    if {[relation isnotempty $opRefs]} {
        append result\
            "static MTH_OperationMap const "\
            "${domain}__OPMAP\[[relation cardinality $opRefs]\] = \{\n"

        relation foreach opRef $opRefs -ascending Name {
            relation assign $opRef Name
            append result\
                "    \{\n"\
                "        .name = \"$Name\",\n"\
                "        .func = ${Name}__OPFUNC\n"\
                "    \},\n"
        }

        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc attrMapDefinitions {} {
    variable domain

    set classRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class}
    } {} |%]

    set result {}
    forAllRefs classRef $classRefs {
        assignAttribute $classRef {Name className}

        set attrRefs [findRelated $classRefs ~R20 {~R25 PopulatedComponent}\
            {~R21 Attribute}]
        if {[isNotEmptyRef $attrRefs]} {
            set nAttrs [refMultiplicity $attrRefs]
            append result\
                "static MTH_AttrMap const\
                    ${className}__ATTRMAP\[$nAttrs\] = \{\n"
            set attrNum -1
            relation foreach attr [deRef $attrRefs] -ascending Name {
                relation assign $attr {Name attrName}
                set rdFuncName ${className}_${attrName}__RD
                set upFuncName ${className}_${attrName}__UP
                append result\
                    "    \{\n"\
                    "        .name = \"$attrName\",\n"\
                    "        .id = [incr attrNum],\n"\
                    "        .readFunc = $rdFuncName,\n"\
                    "        .updateFunc = $upFuncName,\n"\
                    "    \},\n"
            }
        }
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc classMapDefinition {} {
    variable domain

    set classRefs [pipe {
        Domain findWhere {$Name eq $domain} |
        findRelated % ~R1 {~R2 Class} |
        deRef %
    } {} |%]

    set result {}
    if {[relation isnotempty $classRefs]} {
        append result\
            "static MTH_ClassMap const "\
            "${domain}__CLASSMAP\[[relation cardinality $classRefs]\] = \{\n"

        relation foreach ref $classRefs -ascending Name {
            set classRef [::rosea::Helpers::ToRef ::micca::Class $ref]
            assignAttribute $classRef {Name className} {Number classId}

            set compRefs [findRelated $classRef ~R20]

            set attrRefs [findRelated $compRefs {~R25 PopulatedComponent}\
                {~R21 Attribute}]
            set attrMap [expr {[isNotEmptyRef $attrRefs] ?\
                "${className}__ATTRMAP" : "NULL"}]

            set instRefs [findRelated $compRefs ~R103]
            set instMap [expr {[isNotEmptyRef $instRefs] ?\
                "${className}__INSTMAP" : "NULL"}]

            set eventRefs [findRelated $classRef ~R51 R50 ~R87 R80]
            set eventMap [expr {[isNotEmptyRef $eventRefs] ?\
                "${className}__EVENTMAP" : "NULL"}]

            append result\
                "    \{\n"\
                "        .name = \"$className\",\n"\
                "        .id = $classId,\n"\
                "        .attrs = $attrMap,\n"\
                "        .attrCount = [refMultiplicity $attrRefs],\n"\
                "        .insts = $instMap,\n"\
                "        .instCount = [refMultiplicity $instRefs],\n"\
                "        .events = $eventMap,\n"\
                "        .eventCount = [refMultiplicity $eventRefs],\n"\
                "    \},\n"
        }

        append result "\} ;\n"
    }
    return $result
}
----

[source,tcl]
----
<<harness commands>>=
proc harnessDefinition {} {
    variable domain

    append result\
        "extern MRT_DomainPortal const ${domain}__PORTAL ;\n\n"\
        "MTH_DomainHarness const ${domain}__HARNESS = \{\n"\
        "    .portal = &${domain}__PORTAL,\n"

    set domainRef [Domain findWhere {$Name eq $domain}]
    set opRefs [findRelated $domainRef ~R5]
    set opsMap [expr {[isNotEmptyRef $opRefs] ?\
            "${domain}__OPMAP" : "NULL"}]
    append result\
        "    .operations = $opsMap,\n"\
        "    .operationCount = [refMultiplicity $opRefs],\n"

    set classRefs [findRelated $domainRef ~R1 {~R2 Class}]
    set classMap [expr {[isNotEmptyRef $classRefs] ?\
            "${domain}__CLASSMAP" : "NULL"}]
    append result\
        "    .classes = $classMap,\n"\
        "    .classCount = [refMultiplicity $classRefs],\n"
    append result "\} ;\n"
}
----

ifdef::showtests[]
[source,tcl]
----
<<harness command tests>>=
test harness-1.0 {
    Generate harness data structure
} -setup {
    validateutils genHarnessFile harness1 {
        domain harness1 {
            class X {
                attribute temp int -default 20
                attribute color int -default 30
                attribute status int -default 40

                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    transition s1 - e1 -> s2
                    state s2 {} {
                        printf("in s2\n") ;
                    }
                    transition s2 - e2 -> s1
                }
            }

            domainop void init {a int b {char *}} {
                printf("initialized\n") ;
            }

            domainop int get5 {} {
                return 5 ;
            }
        }
        population harness1 {
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils matchLines harness1_harness.c {
        extern MRT_DomainPortal const harness1__PORTAL ;

        MTH_DomainHarness const harness1__HARNESS = {
            .portal = &harness1__PORTAL,
            .operations = harness1__OPMAP,
            .operationCount = 2,
            .classes = harness1__CLASSMAP,
            .classCount = 1,
        } ;
    }
} -result {1}
----

=== Helper Commands

[source,tcl]
----
<<harness data>>=
# Create a simple map that maps "C" implementation types onto
# printf/scanf format strings.
relvar create FormatMap {
    ImplType string
    Print string
    Scan string
} ImplType

relvar set FormatMap [relation table {
    ImplType string             Print string         Scan  string   } {
    int                         {"d"}                {"i"}              } {
    unsigned                    {"u"}                {"i"}              } {
    {unsigned int}              {"u"}                {"i"}              } {
    short                       {"hd"}               {"hi"}             } {
    {short int}                 {"hd"}               {"hi"}             } {
    {unsigned short}            {"hu"}               {"hi"}             } {
    {unsigned short int}        {"hu"}               {"hi"}             } {
    long                        {"ld"}               {"li"}             } {
    {long int}                  {"ld"}               {"li"}             } {
    {unsigned long}             {"lu"}               {"li"}             } {
    {unsigned long int}         {"lu"}               {"li"}             } {
    {long long}                 {"lld"}              {"lli"}            } {
    {long long int}             {"lld"}              {"lli"}            } {
    {unsigned long long}        {"llu"}              {"lli"}            } {
    {unsigned long long int}    {"llu"}              {"lli"}            } {
    {char *}                    {"s"}                {}                 } {
    {char const *}              {"s"}                {}                 } {
    {const char *}              {"s"}                {}                 } {
    {void *}                    {"p"}                {"p"}              } {
    {const void *}              {"p"}                {"p"}              } {
    {void const *}              {"p"}                {"p"}              } {
    float                       {"g"}                {"g"}              } {
    double                      {"lg"}               {"lg"}             } {
    {long double}               {"Lg"}               {"Lg"}             } {
    char                        {"hhd"}              {"hhi"}            } {
    {unsigned char}             {"hhu"}              {"hhi"}            } {
    void                        void                 {}                 } {
    bool                        {"u"}                {"u"}              } {
    uint8_t                     PRIu8                SCNi8              } {
    uint16_t                    PRIu16               SCNi16             } {
    uint32_t                    PRIu32               SCNi32             } {
    uint64_t                    PRIu64               SCNi64             } {
    int8_t                      PRId8                SCNi8              } {
    int16_t                     PRId16               SCNi16             } {
    int32_t                     PRId32               SCNi32             } {
    int64_t                     PRId64               SCNi64             } {
    intmax_t                    PRIdMAX              SCNiMAX            } {
    uintmax_t                   PRIuMAX              SCNiMAX            } ]
----

[source,tcl]
----
<<harness commands>>=
proc GetFormat {implType which} {
    set fmt [relvar restrictone FormatMap ImplType $implType]
    if {[relation isempty $fmt]} {
        error "unknown implementation data type, $implType"
    }
    return [relation extract $fmt $which]
}
----

== Harness Code Organization

Place holder.

=== Harness Header File

[source,c]
----
<<micca_harness.h>>=
/*
<<copyright info>>
*/

#ifndef MICCA_HARNESS_H_
#define MICCA_HARNESS_H_

/*
 * Include Files
 */
#include "micca_rt.h"
<<mth interface includes>>

/*
 * Preprocessor Defines
 */
<<mth interface defines>>

/*
 * Constants
 */
<<mth interface constants>>

/*
 * Data Types
 */
<<mth interface simple types>>
<<mth interface aggregate types>>

/*
 * Static Inline Functions
 */
<<mth interface static inlines>>

/*
 * External Functions
 */
<<mth external function declarations>>

#endif /* MICCA_HARNESS_H_ */
----

=== Harness Code File

[source,c]
----
<<micca_harness.c>>=
/*
<<copyright info>>
*/

/*
 * Include Files
 */
#define _POSIX_C_SOURCE 200112L
#include "micca_harness.h"
<<mth implementation includes>>

/*
 * Macros
 */
#ifndef NDEBUG
#   define  dbgprintf(...)    printf(__VA_ARGS__)
#else
#   define  dbgprintf(...)
#endif /* NDEBUG */

#define ASCII_NUL       '\0'
#define BEGIN_QUOTE     '{'
#define END_QUOTE       '}'
#define ESCAPE_CHAR     '\\'

#define OutOfWord   0
#define InWord      1
#define InEscape    2
#define InQuote     3

/*
 * Constants
 */
<<mth implementation constants>>

/*
 * Data Types
 */
<<mth implementation simple types>>
<<mth implementation aggregate types>>

/*
 * Forward References
 */
<<mth forward references>>

/*
 * Static Data
 */
<<mth static data>>

/*
 * Static Inline Functions
 */
<<mth implementation static inlines>>

/*
 * Static Functions
 */
<<mth static functions>>

/*
 * External Functions
 */
<<mth external function definitions>>
----
