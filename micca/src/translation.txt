// vim:set syntax=asciidoc:
= Translation

== Introduction

In this section,
we give an overview of model translation and how `micca` fits into
the larger scheme of modeling and translation.
First,
we consider an idealized view of software development by modeling and
translation.
Next, we compare how a `micca` translation workflow compares to
the idealized one.

=== Translation Reference Model
<<auto-translation>> shows an idealized workflow for translating
and executable model.

[[auto-translation,Figure 1.{counter:fig1counter}]]
image::auto-translation.pdf[title="Automatic Translation Reference Model",scaledwidth="60%"]

=== Micca Translation Model

<<micca-translation>> shows the workflow when `micca` is used to accomplish
the translation of an executable model.

[[micca-translation,Figure 1.{counter:fig1counter}]]
image::micca-translation.pdf[title="Micca Translation Workflow",scaledwidth="40%"]

=== Comparing Translation Techniques

When comparing the two workflows,
note that `micca` requires a human to play significant role in the
translation.
None of the information about the plaform independent models is
transferred into the translation scheme.
Rather,
a human translator uses the modeling artifacts to construct a domain
configuration file.
The domain configuration file is an ordinary text file that consists of
commands that describe the elements of the domain.
For example,
as class might be defined as:

----
class WashingCycle {
    attribute CycleType char[32] ;
    attribute WashTemp int ;
}
----

In the process of preparing the domain configuration file,
the human translator performs two distince roles:

. Structural information about the domain elements is translated to the
configuration file syntax.
State models require little implementation consideration since the
states and transitions are captured in a declarative way.
Class definitions require addition consideration as some attributes
from the platform independent model may not have a role in a
platform specific model.
. State activites are translated from the action language of the
model to ``C'' code and use an embedded command language to
provide model level actions.
For example, navigating a relationship might appear as:
+
----
<%my findOneRelated dog R14%>
if (dog != NULL) {
    // related dog found code
} else {
    // no related dog was found
}
----

Once the domain model is transcribed to the `micca`
domain configuration language, the remaining process is similar to the
fully automated workflow.
`Micca` parses and populates a platform specific model store and
generates the required code to interface to run-time code and
the expand the embedded commands within the domain activities.

The obvious disadvantage of this approach is lack of integration to
the front end modeling tools.
Strangely,
it is also one of the strengths of the approach.
UML modeling tools vary considerably in what and how they draw
the various UML diagram types.
In xUML, we are interested in only a few diagram types
and define a much different set of semantics for the meaning of the
graphical symbols than conventional UML>
Finding a tool that expressing the precise modeling semantics of
the xUML dialect in which we are interested is difficult.
General agreement on the xUML meta-model does not exist
and that meta-model is pivital in any automated translation from a
platform independent model to a platform specific one.
Here, we have simply side-stepped the entire issue by using a human
translator to transcribe the platform independent model into a
domain specific language that maps to the plaform dependent model.

=== Reading This Book

This book contains a lot of material.
We would not expect you to sit and read it front to back.
This book is also a literate program.
See <<literal-programming>> for a description of the literate programming
syntax.
The syntax is not complicated, but you will need to know it
to make much sense of any code sequences in the book.
Being a literate program document means that all the source code for
`micca` is included here.
The `micca` program (and many other components) is built by extracting
the source from the document source.
Including the source code and all the design discussion makes the
text rather long
and skipping around when reading is encouraged.

The next part of the book presents a simple example.
This will give you a general sense of how model translation with
`micca` works.

After the example,
we consider the four major components of `micca`:

. The platform model. This is a complete model of the platform
specifics that the translation targets.
This model is populated by the micca configuration process
and is the information source for the code generation.
. The configuration language is a command language where the elements
of a domain are defined.
. The run-time code implements in ``C'' the model execution rules and
any other things that are not directly supported by the implementation
language.
. Finally, the code generation portion creates the data needed by the
run-time code and expands the embedded commands in domain activities to
``C'' code.
