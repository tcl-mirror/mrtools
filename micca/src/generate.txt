// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time translates model level actions into ``C'' level
execution.
The run time can be compiled separately and is data driven.
The details of how a domain behaves is completely driven by the
data values supplied to the run time and the state activities and
domain operations supplied by ``C'' code as part of the domain configuration.

Code generation consist of two major pieces:

* Generating initialized ``C'' variables of the type required by the run time.
* Generating ``C'' code for state activities and domain operations to
facilitate the interface to the run time.

== Generating Run Time Data

Generating Run Time Data

[source,c]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

[source,c]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    upvar #0 ::micca::@Gen@::errorcount errcount

    set errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: verify domains are populated>>

    textutil::expander expand
    expand setbrackets %< >%
    expand errmode [dict get $options expanderror]
    expand evalcmd "namespace eval ::micca::@Gen@::GenHeader"

    <<miccaGenerate: generate header files>>
    <<miccaGenerate: generate code files>>

    rename expand {}

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return $errcount
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation errors}
----

[source,c]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror fail\
]
set options [dict merge $options $arglist]
----

[source,c]
----
<<miccaGenerate: verify domains are populated>>=
set pops [pipe {
    Domain findAll |
    deRef ~ |
    relation eliminate ~ Interface Prologue Epilogue |
    relation rename ~ Name Domain |
    ralutil::rvajoin ~ $::micca::Population Populations 
}]

set nopops [relation restrictwith $pops {[relation isempty $Populations]}]
relation foreach nopop $nopops {
    relation assign $nopop
    log::error "For domain, \"$Domain\", no population is given"
    incr errcount
}

set multipops [relation restrictwith $pops\
    {[relation cardinality $Populations] > 1}]
relation foreach multipop $multipops {
    relation assign $multipop
    log::error "For domain, \"$Domain\", [relation cardinality $Populations]\
        populations are given"
    incr errcount
}
----

[source,c]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
package require tcl::chan::memchan
----

[source,c]
----
<<miccaGenerate: generate header files>>=
forAllRefs domainRef [Domain findAll] {
    namespace upvar GenHeader\
        domain domain\
        interface interface

    assignAttribute $domainRef\
        {Name domain}\
        {Interface interface}

    variable headerTemplate

    set hchan [::open $domain.h w]
    puts $hchan [expand expand $headerTemplate]
    chan close $hchan
}
----

[source,c]
----
<<generation data>>=
set headerTemplate [string cat\
    %<banner>%\
    "#ifndef %<headerFileGuard>%\n"\
    "#define %<headerFileGuard>%\n"\
    %<interface>%\
    "#include <stddef.h>\n"\
    "#include <stdint.h>\n"\
    "#include <stdbool.h>\n"\
    %<typeAliases>%\
    %<domainOpDeclarations>%\
    %<portalIds>%\
    "#endif /* %<headerFileGuard>% */"\
]
----

[source,c]
----
<<generation header namespace>>=
namespace eval GenHeader {
    <<generation header data>>
    <<generation header commands>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }
}
----

[source,c]
----
<<generation header commands>>=
proc banner {} {
    string cat\
        "/*\n"\
        " * ---------------------------------------------------------------\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * ---------------------------------------------------------------\n"\
        " */\n"
}
----

[source,c]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return [string cat _ [string toupper [string trim $domain]] _H_]
}
----

[source,c]
----
<<generation header commands>>=
proc interface {} {
    set result [comment "Domain Interface Contents"]
    variable interface
    append result $interface\n
}
----

[source,c]
----
<<generate command tests>>=
test header-1.0 {
    Generated header file with interface info
} -setup {
    #makeFile {} foo.h
    micca configure {
        domain foo {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population test foo {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {stdio} foo.h]
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc typeAliases {} {
    set result [comment "Type Aliases"]
    variable domain
    set aliases [pipe {
        TypeAlias findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ TypeName
    }]
    set doRefs [pipe {
        DomainOperation findWhere {$Domain eq $domain &&\
                $ReturnDataType in $aliases} |
        findRelated % R5 ~R7
    } {} |%]
    set dopRefs [pipe {
        DomainOperationParameter findWhere {$Domain eq $domain &&\
                $DataType in $aliases} |
        findRelated % R6 R5 ~R7
    } {} |%]

    set taRefs [refUnion $doRefs $dopRefs]
    forAllRefs taRef $taRefs {
        assignAttribute $taRef TypeName TypeDefinition
        append result\
            "typedef "\
            [typeCheck composeDeclaration $TypeDefinition $TypeName]\
            " \;\n"
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test header-2.0 {
    Generated header file with external type alias
} -setup {
    #makeFile {} foo.h
    micca configure {
        domain foo {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population test foo {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {typedef} foo.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    set result [comment "External Declarations for Domain Operations"]

    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]
    forAllRefs opRef $opRefs {
        assignAttribute $opRef
        append result "extern $ReturnDataType " $Domain _ $Name \(
        set params [deRef [findRelated $opRef ~R6]]
        relation foreach param $params -ascending Number {
            relation assign $param DataType
            append result $DataType {, }
        }
        set result [string trimright $result {, }]
        append result "\) ;\n"
    }
    return $result
}
----

[source,c]
----
<<generate command tests>>=
test header-3.0 {
    Generated header file domain operations
} -setup {
    # makeFile {} bar.h
    micca configure {
        domain bar {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population test bar {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {extern int bar_op[0-9]} bar.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    set result [comment "Numeric encoding of classes, attributes and\
            instances used by the portal functions"]
    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        assignAttribute $classRef
        append result [comment "Class: $Name"]
        set classid [string toupper ${Domain}_${Name}_CLASSID]
        append result "#define $classid $Number\n"

        set attrRefs [findRelated $classRef ~R20 {~R21 Attribute}]
        set attrNumber -1
        relation foreach attr [deRef $attrRefs] -ascending Name {
            relation assign $attr {Name attrName}
            set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
            append result "#define $attrid [incr attrNumber]\n"
        }

        set instRefs [findRelated $classRef ~R20 ~R103]
        relation foreach inst [deRef $instRefs] -ascending Number {
            relation assign $inst Instance {Number InstNumber}
            set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
            append result "#define $instid $InstNumber\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test header-4.0 {
    Generated header file with portal constants
} -setup {
    # makeFile {} bar.h
    micca configure {
        domain bar {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population test bar {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {CLASSID} bar.h]
} -result {2}
----

[source,c]
----
<<miccaGenerate: generate code files>>=
----

[source,c]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation header namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }
    <<generation data>>
    <<generation commands>>
}
----

[source,c]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,c]
----
<<generation helper commands>>=
proc comment {c} {
    string cat\
        "/*\n"\
        [::textutil::adjust::indent [::textutil::adjust::adjust $c] " * "]\n\
        " */\n"
}
----

== Interfacing Domain Code to the Run Time

Interfacing Domain Code to the Run Time
