// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time translates model level actions into ``C'' level
execution.
The run time can be compiled separately and is data driven.
The details of how a domain behaves is completely determined by the
data values supplied to the run time and the state activities and
domain operations supplied as ``C'' code.

Code generation consist of two major pieces:

* Generating initialized ``C'' variables of the type required by the run time.
* Generating ``C'' code for state activities and domain operations to
facilitate interfacing to the run time code.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,c]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,c]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
Generally,
one is required to declare symbols before they are defined.
The ordering has to be quite precise.
One way to accomplish this is to use a template.
The template is orgainized in the order required by the compiler
and contains embedded commands.
When expanded the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from `tcllib`.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,c]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

Because we are using a template expansion technique to generate the code
files,
the code generation has the flavor of a report generator.
Commands imbedded in the template make queries on the populated
platform model and emit a _report_ of the query, which in this case
are ``C'' language statements.
Although the reports generated are intended to be consumed by a compiler
rather than a human,
the design of the generator is very similar to generating reports
from a database.
In this case the database is the platform model and the reports are ``C'' code.

[source,c]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: generate header files>>
    <<miccaGenerate: generate code files>>

    rename expand {} ; # <1>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return
}
----
<1> The template expander creates a new command and we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation errors}
----

We set up options for the generation in a dictionary.
The default values are given and can be overridden by those passed in.

[source,c]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror     fail\
]
set options [dict merge $options $arglist]
----

The `textutil::expander` package creates a command that does all the
expansion work.

[source,c]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand setbrackets %< >% ; # <1>
expand errmode [dict get $options expanderror]
----
<1> The default way to embed commands in the template is with
the conventional Tcl brackets ([ ]).
Those characters are inconvenient in ``C'' so we use bracket strings
that create less interference.

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,c]
----
<<miccaGenerate: verify domains are populated>>=
set badpops [pipe {
    Population findAll |
    findUnrelated ~ R100
}]

forAllRefs badpop $badpops {
    set domainName [readAttribute $badpop Name]
    log::error "for domain, \"$domainName\", no population is given"
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

== Header Files

The header file generated for a domain contains interfacing information.
Typically, the header file is included by bridge code that is
mapping the dependencies of one domain onto another.

Following our usual pattern,
we will execute the header generation commands from the template in
a child namespace to avoid any name conflicts.

[source,c]
----
<<miccaGenerate: generate header files>>=
expand evalcmd "namespace eval [namespace current]::GenHeader"
----

The `GenHeader` namespace is a child of `::micca::@Gen@` and follows
our usual pattern of imports, command path and contents.

[source,c]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

The template for the header file is shown below.
Each embedded command is then shown in the following sections.

[source,c]
----
<<generation data>>=
set headerTemplate [string cat\
    %<banner>%\
    "#ifndef %<headerFileGuard>%\n"\
    "#define %<headerFileGuard>%\n"\
    %<interface>%\
    "#include <stddef.h>\n"\
    "#include <stdint.h>\n"\
    "#include <stdbool.h>\n"\
    %<typeAliases>%\
    %<domainOpDeclarations>%\
    %<eventParamDeclarations>%\
    %<portalIds>%\
    "#endif /* %<headerFileGuard>% */"\
]
----

The generation of the header files is accomplished by iterating
over all the domains and placing the output of the template
expansion into a file.
We use some variables to provide context to the embedded expansion commands.

[source,c]
----
<<miccaGenerate: generate header files>>=
variable headerTemplate

forAllRefs domainRef [Domain findAll] {
    namespace upvar GenHeader\
        domain domain\
        interface interface

    assignAttribute $domainRef\
        {Name domain}\
        {Interface interface}

    set hchan [::open $domain.h w]
    try {
        puts $hchan [expand expand $headerTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $hchan
    }

    unset domain interface
}
----

[source,c]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return [string toupper [string trim $domain]]_H_
}
----

[source,c]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    set result {}
    if {$interface ne {}} {
        append result\
            [comment "Domain Interface Contents"]\
            [indentCode [string trim $interface \n] 0]
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    makeFile {} header1.h
    makeFile {} header1.c
    micca configure {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {stdio} header1.h]
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc typeAliases {} {
    variable domain
    set aliases [pipe {
        TypeAlias findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ TypeName
    }]
    set doRefs [pipe {
        DomainOperation findWhere {$Domain eq $domain &&\
                $ReturnDataType in $aliases} |
        findRelated % R5 ~R7
    } {} |%]
    set dopRefs [pipe {
        DomainOperationParameter findWhere {$Domain eq $domain &&\
                $DataType in $aliases} |
        findRelated % R6 R5 ~R7
    } {} |%]
    set argRefs [pipe {
        Argument findWhere {$Domain eq $domain && $DataType in $aliases} |
        deRef ~ |
        relation semijoin ~ $::micca::TypeAlias\
                -using {Domain Domain DataType TypeName} |
        ::rosea::Helpers::ToRef ::micca::TypeAlias ~
    }]

    set taRefs [refUnion $doRefs $dopRefs]
    set taRefs [refUnion $taRefs $argRefs]
    set result {}
    if {[isNotEmptyRef $taRefs]} {
        append result [comment "Type Aliases"]
        forAllRefs taRef $taRefs {
            assignAttribute $taRef TypeName TypeDefinition
            append result\
                "typedef "\
                [typeCheck composeDeclaration $TypeDefinition $TypeName]\
                " \;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    makeFile {} header2.h
    makeFile {} header2.c
    micca configure {
        domain header2 {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {typedef} header2.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    set result {}
    if {[isNotEmptyRef $opRefs]} {
        append result [comment "External Declarations for Domain Operations"]

        forAllRefs opRef $opRefs {
            assignAttribute $opRef
            if {$Comment ne {}} {
                append result [comment $Comment]
            }
            append result "extern $ReturnDataType " $Domain _ $Name \(

            set params [pipe {
                findRelated $opRef ~R6 |
                deRef % |
                relation list % DataType -ascending Number |
                join % {, }
            } {} |%]
            append result $params "\) ;\n"
        }
    }
    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-3.0 {
    Generated header file domain operations
} -setup {
    makeFile {} header3.h
    makeFile {} header3.c
    micca configure {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {extern int header3_op[0-9]} header3.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    set result [comment "Numeric encoding of classes, attributes and\
            instances used by the portal functions"]
    set classRefs [Class findWhere {$Domain eq $domain}]
    append result "#define [string toupper ${domain}_CLASSCOUNT]\
            [refMultiplicity $classRefs]\n"
    forAllRefs classRef $classRefs {
        assignAttribute $classRef
        append result [comment "Class: $Name"]
        set classid [string toupper ${Domain}_${Name}_CLASSID]
        append result "#define $classid $Number\n"

        set attrRefs [findRelated $classRef ~R20 {~R25 PopulatedComponent}\
                {~R21 Attribute}]
        append result "#define [string toupper ${Domain}_${Name}_ATTRCOUNT]\
                [refMultiplicity $attrRefs]\n"
        set attrNumber -1
        relation foreach attr [deRef $attrRefs] -ascending Name {
            relation assign $attr {Name attrName}
            set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
            append result "#define $attrid [incr attrNumber]\n"
        }

        set instRefs [findRelated $classRef ~R20 ~R103]
        set usubRef [findRelated $classRef {~R41 ClassRole} {~R40 Subclass}\
                {~R47 UnionSubclass}]
        if {[isEmptyRef $usubRef]} {
            append result "#define [string toupper ${Domain}_${Name}_INSTCOUNT]\
                    [refMultiplicity $instRefs]\n"
        }
        relation foreach inst [deRef $instRefs] -ascending Number {
            relation assign $inst Instance {Number InstNumber}
            set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
            append result "#define $instid $InstNumber\n"
        }
    }

    append result [comment "Numeric encoding of event numbers\
            used by the portal functions"]
    set tevents [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        deRef ~ |
        relation eliminate ~ Domain |
        relation group ~ Events Event Number
    }]
    relation foreach tevent $tevents -ascending Model {
        relation assign $tevent
        append result [comment "Class: $Model"]
        append result "#define [string toupper ${domain}_${Model}_EVENTCOUNT]\
            [relation cardinality $Events]\n"
        relation foreach event $Events -ascending Number {
            relation assign $event
            append result "#define\
                [string toupper ${domain}_${Model}_${Event}_EVENT] $Number\n"
        }
    }

    append result [comment "Numeric encoding of polymorphic event numbers\
            used by the portal functions"]
    set pevents [pipe {
        DeferredEvent findWhere {$Domain eq $domain} |
        deRef ~ |
        relation eliminate ~ Domain |
        relation group ~ Events Event Number
    }]
    relation foreach pevent $pevents -ascending Model {
        relation assign $pevent
        append result [comment "Class: $Model"]
        append result "#define [string toupper ${domain}_${Model}_POLYEVENTCOUNT]\
            [relation cardinality $Events]\n"
        relation foreach event $Events -ascending Number {
            relation assign $event
            append result "#define\
                [string toupper ${domain}_${Model}_${Event}_POLYEVENT] $Number\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    makeFile {} header4.h
    makeFile {} header4.c
    micca configure {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population header4 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {CLASSID} header4.h]
} -result {2}
----

== Generating Code Files

[source,c]
----
<<miccaGenerate: generate code files>>=
expand evalcmd "namespace eval [namespace current]::GenCode"
----

[source,c]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    namespace import [namespace parent]::expand

    <<generation code data>>
    <<generation code commands>>
}
----

[source,c]
----
<<generation data>>=
set codeTemplate [string cat\
    %<banner>%\
    %<prologue>%\
    "#include \"micca_rt.h\"\n"\
    "#ifdef MRT_INSTRUMENT\n"\
    "    #ifndef MRT_INSTRUMENT_ENTRY\n"\
    "        #define MRT_INSTRUMENT_ENTRY\
            printf(\"%s: %s %d\\n\", __func__, __FILE__, __LINE__) ;\n"\
    "    #endif /* MRT_INSTRUMENT_ENTRY */\n"\
    "#else\n"\
    "    #define MRT_INSTRUMENT_ENTRY\n"\
    "#endif /* MRT_INSTRUMENT */\n"\
    %<domainInclude>%\
    %<forwardClassDeclarations>%\
    %<forwardRelationshipDeclaration>%\
    %<classDeclarations>%\
    %<stateParamDeclarations>%\
    %<operationDeclarations>%\
    %<ctorDeclarations>%\
    %<dtorDeclarations>%\
    %<activityDeclarations>%\
    %<storageDeclarations>%\
    %<nameDefinitions>%\
    %<iabDefinitions>%\
    %<edbDefinitions>%\
    %<pdbDefinitions>%\
    %<classDefinitions>%\
    %<relationshipDefinitions>%\
    %<instanceDefinitions>%\
    %<activityDefinitions>%\
    %<epilogue>%\
]
----

[source,c]
----
<<miccaGenerate: generate code files>>=
variable codeTemplate

forAllRefs domainRef [Domain findAll] {
    namespace upvar GenCode\
        domain domain\
        prologue prologue\
        epilogue epilogue

    assignAttribute $domainRef\
        {Name domain}\
        {Prologue prologue}\
        {Epilogue epilogue}

    PrepareDomainProperties $domain

    set cchan [::open $domain.c w]
    try {
        puts $cchan [expand expand $codeTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $cchan
    }
}
----

[source,c]
----
<<generation helper commands>>=
proc PrepareDomainProperties {domain} {
    variable ClassProperties

    # Need to handle missing class populations.
    # Not all classes will have a ClassPopulation instance.
    set classRefs [Class findWhere {$Domain eq $domain}]
    set allocs [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} |
        deRef % |
        relation project % Class Allocation |
        relation rename % Class Name
    } {} |%]

    set insts [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation project % Class Number |
        relation rename % Class Name
    } {} |%]

    set ClassProperties [pipe {
        deRef $classRefs |
        relation project ~ Name |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            StorageVariable string {"struct [tuple extract $stup Name]\
                [tuple extract $stup Name]__POOL"} |
        ralutil::rvajoin ~ $allocs Allocations |
        relation extend ~ atup Allocation int {
            [relation isempty [tuple extract $atup Allocations]] ?\
            0 : [relation extract [tuple extract $atup Allocations] Allocation]
        } |
        relation eliminate ~ Allocations |
        ralutil::rvajoin ~ $insts Instances |
        relation extend ~ itup\
            InitialInstance int {
                [relation cardinality [tuple extract $itup Instances]]} \
            TotalInstance int {
                [relation cardinality [tuple extract $itup Instances]] +
                [tuple extract $itup Allocation]} |
        relation eliminate ~ Instances
    }]

    variable AssocProperties

    set AssocProperties [pipe {
        Association findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Association |
        ralutil::rvajoin ~ [deRef [StaticAssociation findAll]] Populations |
        relation extend ~ atup IsStatic boolean {
            [relation isnotempty [tuple extract $atup Populations]]} |
        relation project ~ Association IsStatic |
        relation rename ~ Association Name
    }]

    return
}

proc JoinToClassProperties {proprel} {
    variable ClassProperties
    set ClassProperties [relation join $ClassProperties $proprel]
}

proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}

proc GetAssociationProperty {assoc prop} {
    variable AssocProperties
    set aprop [relation restrictwith $AssocProperties {$Name eq $assoc}]
    if {[relation isnotempty $aprop]} {
        return [relation extract $aprop $prop]
    }

    error "unknown property, \"$prop\", for association, \"$assoc\""
}
----

[source,c]
----
<<generation code commands>>=
proc prologue {} {
    variable prologue

    set result {}
    if {$prologue ne {}} {
        append result\
            [comment "Domain Prologue Begin"]\
            [indentCode [string trim $prologue \n] 0]\
            [comment "Domain Prologue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc epilogue {} {
    variable epilogue

    set result {}
    if {$epilogue ne {}} {
        append result\
            [comment "Domain Epilogue Begin"]\
            [indentCode [string trim $epilogue \n] 0]\
            [comment "Domain Epilogue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,c]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    makeFile {} codegen1.h
    makeFile {} codegen1.c
    micca configure {
        domain codegen1 {
            prologue {#include mySpecial.h}
            prologue {#include theSpecial.h}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population codegen1 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {Special} codegen1.c]
} -result {2}
----

[source,c]
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc forwardRelationshipDeclaration {} {
    variable domain
    return "static MRT_Relationship const\
            ${domain}__RSHIPS\[\] ; // forward reference\n"
}
----

[source,c]
----
<<generation code commands>>=
proc classDeclarations {} {
    variable domain

    variable linkMemberNames [dict create]

    set result [comment "Class structure declarations"]

    set ultimates [pipe {
        FindUltimateSuperclasses $domain |
        findRelated % {~R46 UnionSuperclass}
    } {} |%]
    append result [DeclareUnionSubclassStructures $ultimates]

    set remaining [FindNonUnionSubclasses $domain]
    forAllRefs classRef $remaining {
        append result [DeclareClassStructure $classRef]
    }

    JoinToClassProperties [relation fromdict $linkMemberNames\
        Name string LinkMembers list]

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc FindNonUnionSubclasses {domain} {
    set usubs [UnionSubclass findWhere {$Domain eq $domain}]
    return [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation semiminus [deRef $usubs] ~ -using {Domain Domain Class Name} |
        ::rosea::Helpers::ToRef ::micca::Class ~
    }]
}
----

[source,c]
----
<<generation code commands>>=
proc DeclareUnionSubclassStructures {superRefs} {
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs R44 ~R45]
    forAllRefs subRef $subRefs {
        set newsupers [pipe {
            deRef $subRef |
            relation semijoin ~ $::micca::UnionSuperclass\
                -using {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
        }]

        append result [DeclareUnionSubclassStructures $newsupers]

        append result [DeclareClassStructure [findRelated $subRef R47 R40 R41]]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc DeclareClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__INST ;\n"

    set compRefs [findRelated $classRef ~R20]

    # Attributes first
    forAllRefs attrRef [findRelated $compRefs {~R25 PopulatedComponent}\
            {~R21 Attribute}] {
        assignAttribute $attrRef {Name attrName} DataType
        append result "    $DataType $attrName ;\n"
    }

    # References second
    set refRefs [findRelated $compRefs {~R25 PopulatedComponent}\
            {~R21 Reference}]

    # Superclass References
    forAllRefs superRef [findRelated $refRefs {~R23 SuperclassReference}] {
        assignAttribute $superRef {Name attrName}

        set superDecl [pipe {
            findRelated $superRef ~R91 R37 ~R36 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        append result "    $superDecl$attrName ;\n"
    }

    # Subclass References
    forAllRefs subRef [findRelated $refRefs {~R23 SubclassReference}] {
        assignAttribute $subRef {Name attrName}
        append result "    MRT_Instance *$attrName ;\n"
    }

    # Associator Reference
    forAllRefs atorRef [findRelated $refRefs {~R23 AssociatorReference}] {
        assignAttribute $atorRef {Name attrName}

        set aclassRef [findRelated $atorRef ~R93]
        set sourceDecl [pipe {
            findRelated $aclassRef R42 ~R34 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        set targetDecl [pipe {
            findRelated $aclassRef R42 ~R35 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]

        append result\
            "    struct \{\n"\
            "        ${targetDecl}forward ;\n"\
            "        ${sourceDecl}backward ;\n"\
            "    \} $attrName ;\n"
    }

    # Association Reference
    forAllRefs assocRef [findRelated $refRefs {~R23 AssociationReference}] {
        assignAttribute $assocRef {Name attrName}

        set apcRefs [findRelated $assocRef ~R25 R90]
        set napcRefs [refMultiplicity $apcRefs]
        if {$napcRefs == 1} {
            # non-reflexive case
            set srcRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $srcRef]} {
                set refedRef [findRelated $srcRef R32 ~R33]
                append result [GenDirectionalReference $attrName\
                        {*}[readAttribute $refedRef Relationship Class] false]
            } else {
                set srcRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                if {[isNotEmptyRef $srcRef]} {
                    set refing [findRelated $srcRef R33 ~R32]
                    append result\
                        [GenDirectionalReference $attrName\
                            {*}[readAttribute $refing\
                                Relationship Class Multiplicity]]
                } else {
                    set srcRef [findRelated $apcRefs {~R38 SourceClass}]
                    if {[isNotEmptyRef $srcRef]} {
                        set assoc [findRelated $srcRef R34 ~R42]
                        set target [findRelated $srcRef R34 ~R35]
                        append result\
                            [GenDirectionalReference $attrName\
                                {*}[readAttribute $assoc Relationship Class]\
                                [readAttribute $target Multiplicity]]
                    } else {
                        set trgRef [findRelated $apcRefs {~R38 TargetClass}]
                        if {[isNotEmptyRef $trgRef]} {
                            set assoc [findRelated $trgRef R35 ~R42]
                            set source [findRelated $trgRef R35 ~R34]
                            append result\
                                [GenDirectionalReference $attrName\
                                    {*}[readAttribute $assoc Relationship Class]\
                                    [readAttribute $source Multiplicity]]
                        } else {
                            error "cannot find association participant type\
                                across R38"
                        }
                    }
                }
            }
        } elseif {$napcRefs == 2} {
            # do reflexive case
            append result "    struct \{\n"

            set refingRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $refingRef]} {
                # simple association
                set refedRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                append result "    " [GenDirectionalReference forward\
                    {*}[readAttribute $refedRef Relationship Class] false]
                append result "    " [GenDirectionalReference backward\
                    {*}[readAttribute $refingRef Relationship Class Multiplicity]]
            } else {
                set sourceRef [findRelated $apcRefs {~R38 SourceClass}]
                if {[isNotEmptyRef $sourceRef]} {
                    set targetRef [findRelated $apcRefs {~R38 TargetClass}]
                    set assocRef [findRelated $sourceRef R34 ~R42]
                    append result [GenDirectionalReference forward\
                        {*}[readAttribute $assocRef Relationship Class]\
                        [readAttribute $targetRef Multiplicity] 8]
                    append result [GenDirectionalReference backward\
                        {*}[readAttribute $assocRef Relationship Class]\
                        [readAttribute $sourceRef Multiplicity] 8]

                } else {
                    error "cannot resolve reflexive association"
                }
            }
            append result "    \} $attrName ;\n"
        } else {
            error "unexpected number of directional references, \"$napcRefs\""
        }
    }

    # Subclass container
    # Union supertypes will contain a superclass container.
    forAllRefs contRef [findRelated $compRefs {~R25 GeneratedComponent}\
            {~R24 SubclassContainer}] {
        assignAttribute $contRef {Name attrName}

        set subRefs [findRelated $contRef ~R96 R44 ~R45]
        append result\
            "    union \{\n"
        foreach subName [relation list [deRef $subRefs] Class] {
            append result "        "\
                "[GetClassProperty $subName Declaration] $subName ;\n"
        }
        append result\
            "    \} $attrName ;\n"
    }

    # Target links
    # link pointers in classes that are referred to by classes with
    # link references.
    # Start with associator classes. They will have link containers if
    # either source or target is multiple and non-static
    variable linkMemberNames
    dict set linkMemberNames $className [list]
    set atorRef [findRelated $classRef {~R41 ClassRole} {~R40 AssociatorClass}]
    if {[isNotEmptyRef $atorRef]} {
        set sourceRef [findRelatedWhere $atorRef {R42 ~R34} {$Multiplicity}]
        if {[isNotEmptyRef $sourceRef]} {
            assignAttribute $sourceRef Relationship
            if {![GetAssociationProperty $Relationship IsStatic]} {
                append result "    "\
                    "MRT_LinkRef ${Relationship}__FLINKS ;\n"
                dict lappend linkMemberNames $className ${Relationship}__FLINKS
            }
        }
        set targetRef [findRelatedWhere $atorRef {R42 ~R35} {$Multiplicity}]
        if {[isNotEmptyRef $targetRef]} {
            assignAttribute $targetRef Relationship
            if {![GetAssociationProperty $Relationship IsStatic]} {
                append result "    "\
                    "MRT_LinkRef ${Relationship}__BLINKS ;\n"
                dict lappend linkMemberNames $className ${Relationship}__BLINKS
            }
        }
    }

    # Now simple referring classes, multiple and non-static
    set srcRef [findRelatedWhere $classRef {
        {~R41 ClassRole}
        {~R40 AssociationParticipantClass}
        {~R38 SimpleReferringClass}} {$Multiplicity}]
    if {[isNotEmptyRef $srcRef]} {
        assignAttribute $srcRef Relationship
        if {![GetAssociationProperty $Relationship IsStatic]} {
            append result "    MRT_LinkRef ${Relationship}__LINKS ;\n"
            dict lappend linkMemberNames $className ${Relationship}__LINKS
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc GenDirectionalReference {name assocName reftoClass isMultiple {indent 4}} {
    if {$isMultiple} {
        if {[GetAssociationProperty $assocName IsStatic]} {
            append members\
                "unsigned count ;\n"\
                "[GetClassProperty $reftoClass Reference] const *references ;\n"
            append result\
                "struct \{\n"\
                [indentCode $members 4]\
                "\} $name ;\n"
        } else {
            set result "MRT_LinkRef $name ;\n"
        }
    } else {
        set result "[GetClassProperty $reftoClass Reference]$name ;\n"
    }

    return [indentCode $result $indent]
}
----

[source,c]
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    makeFile {} codegen2.h
    makeFile {} codegen2.c
    micca configure {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population codegen2 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {MRT_Instance} codegen2.c]] == 1}\
        {[llength [fileutil::grep {struct super \*R1} codegen2.c]] == 2}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associative class references
} -setup {
    # makeFile {} codegen3.h
    # makeFile {} codegen3.c
    micca configure {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 fred1
                instance x2 R1 fred2
            }
            class Y {
                instance y1 R1 fred1
                instance y2 R1 fred2
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen3.c]] == 27}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-4.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen4.h
    # makeFile {} codegen4.c
    micca configure {
        domain codegen4 {
            class X {}
            association R1 X 0..1--0..1 X
        }
        population codegen4 {
            class X {
                instance x1 R1 {forward x2 backward {}}
                instance x2 R1 {forward {} backward x1}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen4.c]] == 8}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-5.0 {
    Generated code file reflexive associative class references
} -setup {
    # makeFile {} codegen5.h
    # makeFile {} codegen5.c
    micca configure {
        domain codegen5 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen5 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a1
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen5.c]] == 23}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-6.0 {
    Generated code file union generalization
} -setup {
    # makeFile {} codegen6.h
    # makeFile {} codegen6.c
    micca configure {
        domain codegen6 {
            class super {}
            class sub1 {
                attribute color int -default 10
            }
            class sub2 {
                attribute temp int -default 20
            }
            generalization R1 -union super sub1 sub2

            class sub3 {
                attribute degree int -default 30
            }
            class sub4 {
                attribute yaw int -default 40
            }

            generalization R2 -union sub1 sub3 sub4

            class sub5 {
                attribute degree int -default 30
            }
            class sub6 {
                attribute degree int -default 30
            }

            generalization R3 -union sub1 sub5 sub6

            class X {}
            association R4 X 1--1 sub5
        }
        population codegen6 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R2 {sub3 s3} R3 {sub5 s5}
            }
            class sub2 {
                instance s2
            }
            class sub3 {
                instance s3
            }
            class sub5 {
                instance s5 R4 x1
            }
            class X {
                instance x1 R4 s5
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen6.c]] == 13}\
        {[llength [fileutil::grep {R2} codegen6.c]] == 11}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-7.0 {
    Generated code file associative class references -- non static
} -setup {
    # makeFile {} codegen7.h
    # makeFile {} codegen7.c
    micca configure {
        domain codegen7 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population codegen7 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x1 Y y2}
                instance a4 R1 {X x2 Y y1}
            }
            class X {
                instance x1 R1 {a1 a3}
                instance x2 R1 {a2 a4}
            }
            class Y {
                instance y1 R1 {a1 a4}
                instance y2 R1 {a2 a3}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen7.c]] == 15}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-8.0 {
    Generated code file reflexive associative class references -- non static
} -setup {
    # makeFile {} codegen8.h
    # makeFile {} codegen8.c
    micca configure {
        domain codegen8 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen8 {
            class A {
                instance a12 R1 {forward x2 backward x1}
                instance a13 R1 {forward x3 backward x1}
                instance a23 R1 {forward x3 backward x2}
                instance a24 R1 {forward x4 backward x2}
                instance a34 R1 {forward x4 backward x3}
                instance a41 R1 {forward x1 backward x4}
            }
            class X {
                instance x1 R1 {a12 a13} ; # back a12 a13
                instance x2 R1 {a23 a24}
                instance x3 R1 a34
                instance x4 R1 a41
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen8.c]] == 19}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-9.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen9.h
    # makeFile {} codegen9.c
    micca configure {
        domain codegen9 {
            class X {}
            association R1 X 0..*--0..1 X
        }
        population codegen9 {
            class X {
                instance x1 R1 {forward x2 backward {x1 x3}}
                instance x2 R1 {forward x3 backward {x1 x2}}
                instance x3 R1 {forward x1 backward {x2 x3}}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {LINKS} codegen9.c]] == 11}
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc eventParamDeclarations {} {
    variable domain
    set result {}

    set tevents [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        findRelated ~ R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    if {[relation isnotempty $tevents]} {
        append result [comment "Transition Event Parameter Structure\
                Declarations"]
        relation foreach tevent $tevents -ascending Model {
            relation assign $tevent
            relation foreach event $Events {
                relation assign $event
                append result\
                    "struct ${domain}_${Model}_${Event}_EventParams \{\n"
                relation foreach param $Params -ascending Position {
                    relation assign $param DataType Name
                    append result\
                        "    [typeCheck composeDeclaration $DataType $Name] ;\n"
                }
                append result "\} ;\n"
            }
        }
    }

    set pevents [pipe {
        PolymorphicEvent findWhere {$Domain eq $domain} |
        findRelated ~ R81 R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    if {[relation isnotempty $pevents]} {
        append result [comment "Polymorphic Event Parameter Structure\
                Declarations"]
        relation foreach tevent $pevents -ascending Model {
            relation assign $tevent
            relation foreach event $Events {
                relation assign $event
                append result\
                    "struct ${domain}_${Model}_${Event}_PolyEventParams \{\n"
                relation foreach param $Params -ascending Position {
                    relation assign $param DataType Name
                    append result\
                        "    [typeCheck composeDeclaration $DataType $Name] ;\n"
                }
                append result "\} ;\n"
            }
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc stateParamDeclarations {} {
    variable domain
    set result {}

    set stateargs [pipe {
        State findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name State |
        relation join $::micca::ParameterSignature $::micca::Parameter\
                $::micca::Argument |
        relation project ~ Model State Name Position DataType |
        relation group ~ Params Name Position DataType
    }]

    if {[relation isnotempty $stateargs]} {
        append result [comment "State Parameter Structure Declarations"]
        relation foreach statearg $stateargs -ascending {Model State} {
            relation assign $statearg
            append result "struct ${Model}_${State}_StateParams \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-10.0 {
    Generated event parameter structures
} -setup {
    # makeFile {} codegen10.h
    # makeFile {} codegen10.c
    micca configure {
        domain codegen10 {
            typealias MyCount int
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            class super {
                polymorphic e1 f MyCount g {char *}
                polymorphic e2
            }
            class sub1 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            class sub2 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            generalization R1 super sub1 sub2
        }
        population codegen10 {
            class X {
                instance x1 color 30
            }
            class super {
                instance sup1 R1 {sub1 s1}
                instance sup2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R1 sup1
            }
            class sub2 {
                instance s2 R1 sup2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {_EventParams} codegen10.h]] == 3}\
        {[llength [fileutil::grep {_PolyEventParams} codegen10.h]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc operationDeclarations {} {
    variable domain
    set result {}

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Class Operations Forward Declarations"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "static $ReturnDataType ${Class}_$Operation\("

            if {[relation isempty $Parameters]} {
                append result void
            } else {
                append result [join\
                    [relation list $Parameters DataType -ascending Number] {, }]
            }

            append result "\) ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-11.0 {
    Generated code file with class operations
} -setup {
    # makeFile {} codegen11.h
    # makeFile {} codegen11.c
    micca configure {
        domain codegen11 {
            class X {
                attribute color int -default 20

                classop int count {} {
                    return 42 ;
                }

                instop void addColor {amount int} {
                    self->color += amount
                }
            }
        }
        population codegen11 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X_count} codegen11.c]] == 1}\
        {[llength [fileutil::grep {X_addColor} codegen11.c]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc ctorDeclarations {} {
    variable domain
    set result {}

    set ctors [Constructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $ctors]} {
        append result [comment "Class Constructor Forward Declarations"]
        forAllRefs ctor $ctors {
            assignAttribute $ctor {Class className}
            append result\
                "static void ${className}__CTOR\("\
                [GetClassProperty $className Reference]\
                "\) ; \n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc dtorDeclarations {} {
    variable domain
    set result {}

    set dtors [Destructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $dtors]} {
        append result [comment "Class Destructor Forward Declarations"]
        forAllRefs dtor $dtors {
            assignAttribute $dtor {Class className}
            append result\
                "static void ${className}__DTOR\("\
                [GetClassProperty $className Reference]\
                "\) ; \n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc activityDeclarations {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && $Activity ne {}} |
        deRef ~ |
        relation eliminate ~ Domain Activity IsTerminal PSigID |
        relation group ~ States Name
    }]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Forward Declarations"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            relation foreach state $States {
                relation assign $state
                append result "static void ${Model}_${Name}__ACTIVITY\("\
                    "void *const s__, "\
                    "void const *const p__) ;\n"
            }
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc storageDeclarations {} {
    variable domain
    set result {}

    set cpops [pipe {
        FindNonUnionSubclasses $domain |
        findRelated % R104 {~R101 ElementPopulation} {~R105 ClassPopulation}
    } {} |%]

    if {[isNotEmptyRef $cpops]} {
        append result [comment "Class Instance Storage Forward Declarations"]
        forAllRefs cpop $cpops {
            assignAttribute $cpop {Allocation allocation} {Class className}
            set insts [refMultiplicity [findRelated $cpop ~R102]]
            set total [expr {$allocation + $insts}]
            append result "static "\
                [GetClassProperty $className StorageVariable]\
                "\[[GetClassProperty $className TotalInstance]\] ;\n"
        }
    }

    return $result
}
----

Put out all the naming information.

[source,c]
----
<<generation code commands>>=
proc nameDefinitions {} {
    variable domain
    append result\
        [comment "Domain Naming Definitions"]\
        "#ifndef MRT_NO_NAMES\n"

    set storageType "static char const"

    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        set className [readAttribute $classRef Name]
        append result "$storageType ${className}__NAME\[\] = \"$className\" ;\n"
    }

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    forAllRefs relRef $relRefs {
        set relName [readAttribute $relRef Name]
        append result "$storageType ${relName}__NAME\[\] = \"$relName\" ;\n"
    }

    set stateRefs [State findWhere {$Domain eq $domain}]
    forAllRefs stateRef $stateRefs {
        assignAttribute $stateRef {Model modelName} {Name stateName}
        append result "$storageType ${modelName}_${stateName}__SNAME\[\] =\
                \"$stateName\" ;\n"
    }

    set eventRefs [Event findWhere {$Domain eq $domain}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Model modelName} {Event eventName}
        append result "$storageType ${modelName}_${eventName}__ENAME\[\] =\
                \"$eventName\" ;\n"
    }

    append result "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc iabDefinitions {} {
    variable domain
    set result [comment "Instance Allocation Block Definitions"]

    forAllRefs classRef [FindNonUnionSubclasses $domain] {
        append result [DefineIABMembers $classRef false]
    }

    set unionRefs [pipe {
        UnionSubclass findWhere {$Domain eq $domain} |
        findRelated ~ R47 R40 R41
    }]
    forAllRefs classRef $unionRefs {
        append result [DefineIABMembers $classRef true]
    }

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc DefineIABMembers {classRef isUnionSubclass} {
    assignAttribute $classRef {Name className}

    set linkMembers [GetClassProperty $className LinkMembers]
    set linkCount [llength $linkMembers]
    if {$linkCount == 0} {
        set linkOffsets NULL
    } else {
        set linkOffsets ${className}__LINKS
        append result\
            "static MRT_AttrOffset const $linkOffsets\[\] = \{\n"
        foreach linkMember $linkMembers {
            append result\
                "    "\
                "offsetof\([GetClassProperty $className Declaration],\
                $linkMember\),\n"
        }
        append result "\} ;\n"
    }

    append result\
        "static MRT_iab ${className}__IAB = \{\n"

    if {$isUnionSubclass} {
        append result\
            "    .storageStart = NULL,\n"\
            "    .storageFinish = NULL,\n"\
            "    .storageLast = NULL,\n"
    } else {
        set nelements [GetClassProperty $className TotalInstance]
        append result\
            "    .storageStart = &${className}__POOL\[0\],\n"\
            "    .storageFinish = &${className}__POOL\[$nelements\],\n"\
            "    .storageLast = &${className}__POOL\[[expr {$nelements - 1}]\],\n"
    }
    set ctor [pipe {
        findRelated $classRef ~R8 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__CTOR"}
    } {} |%]
    set dtor [pipe {
        findRelated $classRef ~R9 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__DTOR"}
    } {} |%]
    append result\
        "    .alloc = [expr {[GetClassProperty $className InitialInstance]\
                    + 1}],\n"\
        "    .instanceSize = sizeof\([GetClassProperty $className Declaration]\),\n"\
        "    .construct = $ctor,\n"\
        "    .destruct = $dtor,\n"\
        "    .linkCount = $linkCount,\n"\
        "    .linkOffsets = $linkOffsets\n"\
        "\} ;\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc edbDefinitions {} {
    variable domain
    set result [comment "Event Dispatch Block Definitions"]

    upvar #0 ::micca::@Gen@::options options

    forAllRefs smodel [StateModel findWhere {$Domain eq $domain}] {
        assignAttribute $smodel {Model className}

        append result [GenerateTransitionTable $smodel]
        append result [GenerateActivityTable $smodel]
        set termstates [GenerateTerminalStates $smodel result]

        append result [GenerateModelNames $smodel]

        append result "static MRT_edb const ${className}__EDB = \{\n"

        set stateRefs [findRelated $smodel ~R55]
        set cstateRef [findRelated $smodel ~R56]
        append result\
            "    .stateCount = [expr {[refMultiplicity $stateRefs] +\
                [refMultiplicity $cstateRef]}],\n"

        set eventRefs [findRelated $smodel ~R87]
        append result\
            "    .eventCount = [refMultiplicity $eventRefs],\n"\
            "    .initialState = [readAttribute [findRelated $smodel R58 R57]\
                        Number],\n"
        set crstate [expr {[isNotEmptyRef $cstateRef] ?\
            [readAttribute [findRelated R57] Number] : "MRT_StateCode_IG"}]
        append result\
            "    .creationState = $crstate,\n"\
            "    .transitionTable = ${className}__TTAB,\n"\
            "    .activityTable = ${className}__ATAB,\n"\
            "    .terminalStates = $termstates,\n"

        append result\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .stateNames = ${className}__SNAMES,\n"\
            "    .eventNames = ${className}__ENAMES,\n"\
            "        #endif /* MRT_NO_NAMES */\n"

        append result\
            "\} ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateTransitionTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        findRelated $smodel ~R55 |
        deRef % |
        relation rename % Name State |
        relation eliminate % Activity IsTerminal PSigID
    } {} |%]
    set cstate [pipe {
        findRelated $smodel ~R56 |
        deRef % |
        relation rename % Name State
    } {} |%]
    set states [relation union $states $cstate]
    # puts [relformat $states states]

    set events [pipe {
        findRelated $smodel ~R87 |
        deRef %
    } {} |%]
    # puts [relformat $events events]

    set alltrans [pipe {
        relation eliminate $events Number |
        relation join $states ~
    }]
    # puts [relformat $alltrans alltrans]

    set statetrans [pipe {
        StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation eliminate ~ ASigID
    }]
    # puts [relformat $statetrans statetrans]
    set nontrans [pipe {
        Non-StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ TransRule NewState
    }]
    # puts [relformat $nontrans nontrans]

    set deftrans [pipe {
        TransitionPlace findAll |
        deRef ~ |
        relation minus $alltrans ~ |
        relation join ~ [deRef [StateModel findAll]] |
        relation eliminate ~ InitialState |
        relation rename ~ DefaultTrans NewState |
        relation update ~ dttup {[tuple extract $dttup State] eq "@"} {
                tuple update $dttup NewState CH}
    }]
    # puts [relformat $deftrans deftrans]

    set ntstates [pipe {
        TransitionRule findAll |
        deRef ~ |
        relation rename ~ Name State |
        relation extend ~ nttup\
            Domain string {$domain}\
            Model string {$className}\
            StateNumber string {"MRT_StateCode_[tuple extract $nttup State]"}
    }]
    # puts [relformat $ntstates ntstates]

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ Name State Number StateNumber |
        relation union ~ $ntstates
    }]
    # puts [relformat $places places]
    set transitions [pipe {
        relation union $statetrans $nontrans $deftrans |
        relation join ~ $places\
            -using {Domain Domain Model Model NewState State} |
        relation rename ~ StateNumber NewStateNumber |
        relation join ~ $places $events |
        relation eliminate ~ Domain Model
    }]
    # puts [relformat $transitions transitions]

    set result "static MRT_StateCode const ${className}__TTAB\[\] = \{\n"
    relation foreach transition $transitions -ascending {StateNumber Number} {
        relation assign $transition
        append result "    $NewStateNumber, // $State - $Event -> $NewState\n"
    }
    append result "\} ;\n"

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-12.0 {
    Generated code file with state model
} -setup {
    # makeFile {} codegen12.h
    # makeFile {} codegen12.c
    micca configure {
        domain codegen12 {
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {} {
                        printf("In s1\n") ;
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                    }
                    transition s2 - e1 -> IG
                    transition s2 - e2 -> s3

                    state s3 {} {
                    }
                    transition s3 - e3 -> s1

                    terminal s3
                }
            }
        }
        population codegen12 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X__TTAB} codegen12.c]] == 2}\
        {[llength [fileutil::grep {X__ATAB} codegen12.c]] == 2}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc GenerateActivityTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set result "static MRT_PtrActivityFunction const ${className}__ATAB\[\] = \{\n"

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name Activity
            if {$Activity eq {}} {
                append result "    NULL, // $Name\n"
            } else {
                append result "    ${className}_${Name}__ACTIVITY, // $Name\n"
            }
        } else {
            set cstate [relation semijoin $place $::Micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    NULL, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateTerminalStates {smodel resultVar} {
    set tstates [findRelatedWhere $smodel ~R55 {$IsTerminal}]
    if {[isEmptyRef $tstates]} {
        return NULL
    }
    upvar 1 $resultVar result
    variable domain
    assignAttribute $smodel {Model className}
    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static bool const ${className}__TSTATES\[\] = \{\n"
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name IsTerminal
            append result "    "\
                [expr {$IsTerminal ? "true" : "false"}]\
                ", // $Name\n"
        } else {
            set cstate [relation semijoin $place $::Micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    false, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
    return ${className}__TSTATES
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateModelNames {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result\
        "#ifndef MRT_NO_NAMES\n"\
        "static char const * const ${className}__SNAMES\[\] = \{\n"

    relation foreach state $states -ascending Number {
        relation assign $state Name
        append result "    ${className}_${Name}__SNAME,\n"
    }
    append result "\} ;\n"

    set events [pipe {
        TransitioningEvent findWhere\
                {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static char const * const ${className}__ENAMES\[\] = \{\n"
    relation foreach event $events -ascending Number {
        relation assign $event Event
        append result "    ${className}_${Event}__ENAME,\n"
    }
    append result\
        "\} ;\n"\
        "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc pdbDefinitions {} {
    variable domain

    set enames {}
    set rnames {}
    set pmaps {}
    set gdbs {}
    set pdbs {}

    set superRefs [pipe {
        DeferredEvent findWhere {$Domain eq $domain} |
        findRelated % ~R86
    } {} |%]
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs\
            {~R46 ReferencedSuperclass} R36 ~R37 R47]
    if {[isNotEmptyRef $subRefs]} {
        set supertype mrtPolyReference
    } else {
        set subRefs [findRelated $superRefs\
                {~R46 UnionSuperclass} R44 ~R45 R47]
        set supertype mrtPolyUnion
    }

    set deferred [pipe {
        findRelated $superRefs {R86 DeferralPath} |
        deRef ~ |
        relation join ~ $::micca::DeferredEvent |
        relation eliminate ~ Domain Role |
        relation extend ~ gtup SuperType string {$supertype} |
        relation rename ~ Model Superclass Number SuperNumber
    }]
    # puts [relformat $deferred deferred]

    set nonlocals [pipe {
        findRelated $subRefs ~R85 |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Number RelNumber
    } {} |%]
    # puts [relformat $nonlocals nonlocals]

    set polys [pipe {
        relation join $nonlocals $::micca::DeferredEvent |
        relation extend ~ ptup Type string {"mrtPolymorphicEvent"}
    }]
    # puts [relformat $polys polys]

    set trans [pipe {
        relation join $nonlocals $::micca::TransitioningEvent |
        relation extend ~ ptup Type string {"mrtTransitionEvent"}
    }]
    # puts [relformat $trans trans]

    set supers [pipe {
        relation union $polys $trans |
        relation eliminate ~ Domain Role |
        relation join ~ $deferred |
        relation group ~ EventMap Event SuperNumber Number Type |
        relation group ~ SubMap Model EventMap |
        relation group ~ Generalizations Relationship RelNumber SuperType SubMap
    }]
    # puts [relformat $supers supers]

    relation foreach super $supers {
        relation assign $super

        set gdbvar ${Superclass}__GDBS
        append gdbs "static MRT_gdb $gdbvar\[\] = \{\n"

        set rnamesvar ${Superclass}__RNAMES
        append rnames "static char const *const $rnamesvar\[\] = \{\n"

        relation foreach gen $Generalizations -ascending Relationship {
            relation assign $gen

            append rnames "    ${Relationship}__NAME,\n"

            set pmapvar ${Superclass}_${Relationship}__PMAP
            append pmaps "static MRT_PolyEventMap const $pmapvar\[\] = \{\n"

            relation foreach submap $SubMap -ascending Model {
                relation assign $submap
                relation foreach eventmap $EventMap {
                    relation assign $eventmap
                    append pmaps\
                        "    "\
                        "\{.event = $Number, .eventType = $Type\},"\
                        "// $Event for $Model\n"
                }
            }
            append pmaps "\} ;\n"

            append gdbs\
                "    \{\n"\
                "        .relship = &${domain}__RSHIPS\[$RelNumber\],\n"\
                "        .eventMap = $pmapvar,\n"\
                "    \},\n"
        }
        append rnames "\} ;\n"
        append gdbs "\} ;\n"

        set enamesvar ${Superclass}__PENAMES
        append enames "static char const *const $enamesvar\[\] = \{\n"
        relation foreach eventmap $EventMap {
            relation assign $eventmap Event
            append enames "    ${Superclass}_${Event}__ENAME,\n"
        }
        append enames "\} ;\n"

        append pdbs\
            "static MRT_pdb const ${Superclass}__PDB = \{\n"\
            "    .eventCount = [relation cardinality $SubMap],\n"\
            "    .genCount = [relation cardinality $Generalizations],\n"\
            "    .genDispatch = $gdbvar,\n"\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .eventNames = $enamesvar,\n"\
            "    .genNames = $rnamesvar,\n"\
            "        #endif /* MRT_NO_NAMES */\n"\
            "\} ;\n"
    }


    append result\
        [comment "Polymorphic Event Dispatch Block Definitions"]\
        "#ifndef MRT_NO_NAMES\n"\
        $enames $rnames\
        "#endif /* MRT_NO_NAMES */\n"\
        $pmaps $gdbs $pdbs

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-13.0 {
    polymorphic events -- inject polymorphic event mid-level
} -setup {
    # makeFile {} codegen13.h
    # makeFile {} codegen13.c
    micca configure {
        domain codegen13 {
            class S {
                polymorphic e1
                polymorphic e2
                polymorphic a1
            }
            class X {
                polymorphic a3
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    transition s1 - a1 ->  s1
                }
            }
            class Y {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - a1 -> s1
                }
            }
            generalization R1 -union S X Y

            class F {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - f1 -> s1
                    transition s2 - a1 -> s2
                }
            }
            class G {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - g1 -> s1
                    transition s2 - a1 -> s2
                }
            }

            generalization R3 -union S F G

            class A {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            class B {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            generalization R2 -union X A B
        }
        population codegen13 {
            class S {
                instance s1 R1 {X x1} R3 {F f1}
                instance s2 R1 {Y y1} R3 {F f2}
                instance s3 R1 {X x2} R3 {G g1}
            }
            class X {
                instance x1 R2 {A a1}
                instance x2 R2 {B b1}
            }
            class Y {
                instance y1
            }
            class A {
                instance a1
            }
            class B {
                instance b1
            }
            class F {
                instance f1
                instance f2
            }
            class G {
                instance g1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {}
----

[source,c]
----
<<generate command tests>>=
test codegen-14.0 {
    Generated code file simple references -- non static
} -setup {
    # makeFile {} codegen14.h
    # makeFile {} codegen14.c
    micca configure {
        domain codegen14 {
            class X {}
            class Y {}
            association R1 X 1..*--1 Y
        }
        population codegen14 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1 R1 {x1 x3}
                instance y2 R1 x2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen14.c]] == 8}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-15.0 {
    Generated code file simple references -- static
} -setup {
    # makeFile {} codegen15.h
    # makeFile {} codegen15.c
    micca configure {
        domain codegen15 {
            class X {}
            class Y {}
            association R1 X 1..*--1 Y
        }
        population codegen15 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1 R1 {x1 x3}
                instance y2 R1 x2
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen15.c]] == 7}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-16.0 {
    many to 1 associative relationship
} -setup {
    # makeFile {} codegen16.h
    # makeFile {} codegen16.c
    micca configure {
        domain codegen16 {
            class A {
            }
            class X {
            }
            class Y {
            }

            association R1 -associator A X 1..*--0..1 Y
        }

        population codegen16 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x1 Y y2}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a2
                # instance x3
            }
            class Y {
                instance y1 R1 a1
                instance y2 R1 {a2 a3}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {}
----

[source,c]
----
<<generation code commands>>=
proc classDefinitions {} {
    variable domain
    set front [comment "Class Description Definitions"]

    set classRefs [Class findWhere {$Domain eq $domain}]

    set rels [pipe {
        findRelated $classRefs {~R41 ClassRole} |
        deRef % |
        relation eliminate % Role |
        relation semiminus $::micca::StaticAssociation %\
            -using {Domain Domain Association Relationship} |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number RelNumber
    } {} |%]
    # puts [relformat $rels rels]

    set attrs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Attribute} |
        deRef % |
        relation rename % Name Attribute Class Name
    } {} |%]
    # puts [relformat $attrs attrs]

    set usubs [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 Subclass}\
            {~R47 UnionSubclass} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number SuperNumber |
        relation eliminate % Role Relationship
    } {} |%]
    # puts [relformat $usubs usubs]

    set classes [pipe {
        deRef $classRefs |
        relation extend ~ ctup IAB string {"&[tuple extract $ctup Name]__IAB"} |
        ralutil::rvajoin ~\
            [relation rename $::micca::StateModel Model Name] SModel |
        relation extend ~ etup EDB string {
            [relation cardinality [tuple extract $etup SModel]] == 0 ?\
            "NULL" : "&[tuple extract $etup Name]__EDB"} |
        ralutil::rvajoin ~\
            [relation rename $::micca::DeferredEvent Model Name] PEvents |
        relation extend ~ ptup PDB string {
            [relation cardinality [tuple extract $ptup PEvents]] == 0 ?\
            "NULL" : "&[tuple extract $ptup Name]__PDB"} |
        relation eliminate ~ SModel PEvents |
        ralutil::rvajoin ~ $rels Relationships |
        relation extend ~ rtup\
            relCount int {
                [relation cardinality [tuple extract $rtup Relationships]]}\
            classRels string {
                [relation cardinality [tuple extract $rtup Relationships]] == 0 ?\
                "NULL" : "[tuple extract $rtup Name]__CRELS"} |
        ralutil::rvajoin ~ $attrs Attributes |
        relation extend ~ atup\
            attrCount int {
                [relation cardinality [tuple extract $atup Attributes]]}\
            classAttrs string {
                [relation cardinality [tuple extract $atup Attributes]] == 0 ?\
                "NULL" : "[tuple extract $atup Name]__CATTRS"} |
        ralutil::rvajoin ~ $usubs UnionSubs |
        relation extend ~ utup\
            containment string {
                [relation cardinality [tuple extract $utup UnionSubs]] == 0 ?\
                "NULL" :\
                "&${domain}__RSHIPS\[[relation extract\
                    [tuple extract $utup UnionSubs]\
                    SuperNumber]\].relInfo.unionGeneralization.superclass"} |
        relation eliminate ~ Domain

    }]
    # puts [relformat $classes classes]

    append result "static MRT_Class const\
            ${domain}__CLASSES\[[relation cardinality $classes]\] = \{\n"

    set relrefs {}
    set attrrefs {}
    relation foreach class $classes {
        relation assign $class

        if {[relation isnotempty $Relationships]} {
            append relrefs\
                "static MRT_Relationship const *const\
                    ${Name}__CRELS\[\] = \{\n"

            relation foreach rel $Relationships {
                relation assign $rel
                append relrefs\
                    "    &${domain}__RSHIPS\[$RelNumber\], // $Relationship\n"
            }

            append relrefs "\} ;\n"
        }

        if {[relation isnotempty $Attributes]} {
            append attrrefs\
                "static MRT_Attribute const ${Name}__CATTRS\[\] = \{\n"

            relation foreach attr $Attributes -ascending Attribute {
                relation assign $attr
                set offset "offsetof([GetClassProperty $Name Declaration],\
                        $Attribute)"
                append attrrefs\
                    "    \{\n"\
                    "        .offset = $offset,\n"\
                    "        .size = sizeof($DataType),\n"\
                    "            #ifndef MRT_NO_NAMES\n"\
                    "        .name = \"$Attribute\"\n"\
                    "            #endif /* MRT_NO_NAMES */\n"\
                    "    \},\n"
            }

            append attrrefs "\} ;\n"
        }

        append result\
            "    \[$Number\] = \{\n"\
            "        .iab = $IAB,\n"\
            "        .edb = $EDB,\n"\
            "        .pdb = $PDB,\n"\
            "        .relCount = $relCount,\n"\
            "        .classRels = $classRels,\n"\
            "        .attrCount = $attrCount,\n"\
            "        .classAttrs = $classAttrs,\n"\
            "        .instCount = [GetClassProperty $Name TotalInstance],\n"\
            "        .containment = $containment,\n"\
            "            #ifndef MRT_NO_NAMES\n"\
            "        .name = ${Name}__NAME\n"\
            "            #endif /* MRT_NO_NAMES */\n"\
            "    \},\n"
    }

    append result "\} ;\n"

    return [string cat $front $relrefs $attrrefs $result]
}
----

----
<<generation code commands>>=
proc relationshipDefinitions {} {
    variable domain
    set subroles {}

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    if {[isEmptyRef $relRefs]} {
        return
    }
    append result "static MRT_Relationship const\
        ${domain}__RSHIPS\[[refMultiplicity $relRefs]\] = \{\n"

    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    forAllRefs relRef $relRefs {
        assignAttribute $relRef {Name relName} Number
        append result "$indent\[$Number\] = \{ // $relName\n"

        # Simple Association
        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 SimpleAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set static [StaticAssociation findWhere\
                {$Domain eq $domain && $Association eq $relName}]

            set sourceRef [findRelated $typeRef ~R32]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R38 R40 R41] Number]

            set targetRef [findRelated $typeRef ~R33]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set tMult false
            set stype mrtSingular
            set slink 0

            set tlink 0
            if {!$sMult} {
                set ttype mrtSingular
            } else {
                if {[isNotEmptyRef $static]} {
                    set ttype mrtArray
                } else {
                    set ttype mrtLinkedList
                    set tlink "offsetof([GetClassProperty $sClass Declaration],\
                            ${relName}__LINKS)"
                }
            }

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    $relName"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    $relName"
            if {$sClass eq $tClass} {
                append sstore .forward
                append tstore .backward
            }
            append sstore "\)"
            append tstore "\)"

            append result\
                "$indent2.relType = mrtSimpleAssoc,\n"\
                "$indent2.relInfo.simpleAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\}\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 ClassBasedAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set static [StaticAssociation findWhere\
                {$Domain eq $domain && $Association eq $relName}]

            set sourceRef [findRelated $typeRef ~R34]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R38 R40 R41] Number]

            set targetRef [findRelated $typeRef ~R35]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}\
                {Multiplicity tMult}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set asstorRef [findRelated $typeRef ~R42]
            assignAttribute $asstorRef {Class aClass}
            set aNum [readAttribute [findRelated $asstorRef R40 R41] Number]

            set slink 0
            if {!$tMult} {
                set stype mrtSingular
            } else {
                if {[isNotEmptyRef $static]} {
                    set stype mrtArray
                } else {
                    set stype mrtLinkedList
                    set slink "offsetof([GetClassProperty $aClass Declaration],\
                            ${relName}__FLINKS)"
                }
            }

            set tlink 0
            if {!$sMult} {
                set ttype mrtSingular
            } else {
                if {[isNotEmptyRef $static]} {
                    set ttype mrtArray
                } else {
                    set ttype mrtLinkedList
                    set tlink "offsetof([GetClassProperty $aClass Declaration],\
                            ${relName}__BLINKS)"
                }
            }

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    $relName"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    $relName"
            if {$sClass eq $tClass} {
                append sstore .forward
                append tstore .backward
            }
            append sstore "\)"
            append tstore "\)"


            append result\
                "$indent2.relType = mrtClassAssoc,\n"\
                "$indent2.relInfo.classAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink,\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\},\n"

            set aClassDecl [GetClassProperty $aClass Declaration]
            set aClassForw "offsetof($aClassDecl, ${relName}.forward)"
            set aClassBack "offsetof($aClassDecl, ${relName}.backward)"
            append result\
                "$indent3.associator = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$aNum\], // $aClass\n"\
                "$indent4.forwardOffset = $aClassForw,\n"\
                "$indent4.backwardOffset = $aClassBack,\n"\
                "$indent3\}\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 ReferenceGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R36]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R46 R40 R41] Number]

            set subRefs [findRelated $typeRef ~R37]
            set subClasses [findRelated $subRefs R47 R40 R41]

            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"}\
                    storageOffset string {
                        "offsetof([GetClassProperty\
                            [tuple extract $stup Class] Declaration],\
                            $relName)"} |
                relation project ~ Class classDesc storageOffset
            }]

            append subroles "static struct mrtrefsubclassrole const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs -ascending Class {
                relation assign $sub
                append subroles\
                    "    \{\n"\
                    "        .classDesc = $classDesc,\n"\
                    "        .storageOffset = $storageOffset\n"\
                    "    \},\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtRefGeneralization,\n"\
                "$indent2.relInfo.refGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 UnionGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R44]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R46 R40 R41] Number]
            set subRefs [findRelated $typeRef ~R45]
            set subClasses [findRelated $subRefs R47 R40 R41]
            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"} |
                relation project ~ Class classDesc
            }]

            append subroles "static MRT_Class const * const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs -ascending Class {
                relation assign $sub
                append subroles "    $classDesc\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtUnionGeneralization,\n"\
                "$indent2.relInfo.unionGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }
    }

    append result "\} ;\n"

    return [string cat\
        [comment "Relationship Description Definitions"]\
        $subroles\
        $result\
    ]
}
----

[source,c]
----
<<generation code commands>>=
proc MapToCardinality {cond mult} {
    if {$cond && !$mult} {
        return mrtAtMostOne
    } elseif {!$cond && !$mult} {
        return mrtExactlyOne
    } elseif {$cond && $mult} {
        return mrtZeroOrMore
    } elseif {!$cond && $mult} {
        return mrtOneOrMore
    }
}
----

[source,c]
----
<<generation code commands>>=
proc instanceDefinitions {} {
    try {
    variable domain
    variable staticMultiRefs

    set staticMultiRefs [comment "Multiple Static Reference Definitions"]

    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    set classRefs [FindNonUnionSubclasses $domain]
    set classpops [FindClassPopulation $classRefs]

    set result [comment "Instance Pool Definitions"]
    relation foreach classpop $classpops -ascending ClassNumber {
        relation assign $classpop

        append result\
            "static [GetClassProperty $Class Declaration] ${Class}__POOL"\
            "\[[GetClassProperty $Class TotalInstance]\] = \{\n"

        relation foreach inst $Instances -ascending InstNumber {
            append result [GenInstanceInitializers $Class $ClassNumber $inst]
        }

        append result "\} ;\n"
    }

    return [string cat $staticMultiRefs $result]


    } on error {} {
        puts $::errorInfo
    }
}
----

[source,c]
----
<<generation code commands>>=
proc FindClassPopulation {classRefs} {
    set classes [pipe {
        deRef $classRefs |
        relation rename ~ Name Class Number ClassNumber
    }]

    # Attribute Components
    set attrs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Attribute} |
        deRef % |
        relation rename % Name Component
    } {} |%]

    # Superclass Reference Component
    set refedsupers [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 Superclass}\
            {~R46 ReferencedSuperclass} |
        deRef % |
        relation rename % Class Superclass |
        relation eliminate % Role
    } {} |%]

    set superrefs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Reference}\
            {~R23 SuperclassReference} ~R91 |
        deRef % |
        relation eliminate % Role |
        relation join % $refedsupers |
        relation rename % Relationship Component
    } {} |%]

    # Subclass Reference Components
    set refedsubs [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 Subclass}\
            {~R47 ReferringSubclass} |
        deRef % |
        relation rename % Class Subclass |
        relation eliminate % Role
    } {} |%]

    set subrefs [pipe {
        findRelated $classRefs ~R20 {~R25 GeneratedComponent}\
                {~R24 SubclassReference} ~R92 |
        deRef % |
        relation eliminate % Role |
        relation join % $refedsubs |
        relation rename % Relationship Component
    } {} |%]

    # Associator Reference Components
    set assocrefs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Reference}\
            {~R23 AssociationReference} ~R25 R90 |
        deRef %
    } {} |%]
    # puts [relformat $assocrefs assocrefs]

    set asources [pipe {
        findRelated $classRefs {~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 SourceClass} |
        deRef % |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class SourceClass
    } {} |%]
    set atargets [pipe {
        findRelated $classRefs {~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 TargetClass} |
        deRef % |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class TargetClass
    } {} |%]
    set assctorrefs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Reference}\
            {~R23 AssociatorReference} ~R93 |
        deRef % |
        relation eliminate % Role |
        relation join %\
            $asources -using {Domain Domain Relationship Relationship}\
            $atargets -using {Domain Domain Relationship Relationship} |
        relation rename % Relationship Component
    } {} |%]

    # Association Reference Components -- Simple Associations
    set sdc [pipe {
        relation rename $::micca::SimpleReferencedClass Class RefClass |
        relation eliminate ~ Role Conditionality |
        relation extend ~ sdctup Multiplicity boolean {"false"}
    }]
    set simprefing [pipe {
        findRelated $classRefs {~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 SimpleReferringClass} |
        deRef % |
        relation eliminate % Conditionality Multiplicity |
        relation join % $sdc
    } {} |%]
    # puts [relformat $simprefing simprefing]

    set src [pipe {
        relation rename $::micca::SimpleReferringClass Class RefClass |
        relation eliminate ~ Role Conditionality
    }]
    set simprefed [pipe {
        findRelated $classRefs {~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 SimpleReferencedClass} |
        deRef % |
        relation eliminate % Conditionality |
        relation join % $src
    } {} |%]
    # puts [relformat $simprefed simprefed]

    set simpleassocs [pipe {
        relation union $simprefing $simprefed |
        relation join $assocrefs ~ |
        relation extend ~ satup IsClassBased boolean {"false"}
    }]
    # puts [relformat $simpleassocs simpleassocs]

    # Association Reference Components -- Class Based Associations
    set srcref [pipe {
        findRelated $classRefs {~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 SourceClass} |
        deRef % |
        relation eliminate % Conditionality Multiplicity |
        relation join %\
            [relation eliminate $::micca::TargetClass Class Role Conditionality]
    } {} |%]
    # puts [relformat $srcref srcref]

    set tgtref [pipe {
        findRelated $classRefs {~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 TargetClass} |
        deRef % |
        relation eliminate % Conditionality Multiplicity |
        relation join %\
            [relation eliminate $::micca::SourceClass Class Role Conditionality]
    } {} |%]
    # puts [relformat $tgtref tgtref]

    set ator [pipe {
        relation rename $::micca::AssociatorClass Class RefClass |
        relation eliminate ~ Role
    }]

    set classassocs [pipe {
        relation union $srcref $tgtref |
        relation join $assocrefs ~ $ator |
        relation extend ~ catup IsClassBased boolean {"true"}
    }]
    # puts [relformat $classassocs classassocs]

    set asstionrefs [pipe {
        relation union $simpleassocs $classassocs |
        relation extend ~ satup IsStatic boolean {
            [GetAssociationProperty [tuple extract $satup Relationship]\
            IsStatic]} |
        relation group ~ References Role Multiplicity RefClass\
            IsClassBased IsStatic |
        relation rename ~ Relationship Component
    }]
    # puts [relformat $asstionrefs asstionrefs]

    # Subclass Container
    set subcont [pipe {
        findRelated $classRefs ~R20 {~R25 GeneratedComponent}\
                {~R24 SubclassContainer} ~R96 |
        deRef % |
        relation eliminate % Role |
        relation extend % sctup Type string {"SubclassContainer"} |
        relation rename % Relationship Component
    } {} |%]
    # puts [relformat $subcont subcont]
    # puts [relformat $::micca::ClassComponentValue ClassComponentValue]

    # Link Container
    # The strategy here is to augment the ClassComponentValue with a
    # pseudo-component that are the link contains for linked lists.
    # Then we can use the existing pattern to populate them.
    #
    # First we do the simple associations

    set instances [relation eliminate $::micca::ClassInstance Number]

    set multirefed [pipe {
        findRelatedWhere $classRefs {{~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 SimpleReferringClass}} \
            {$Multiplicity && ![GetAssociationProperty $Relationship IsStatic]} |
        deRef % |
        relation eliminate % Role Conditionality Multiplicity
    } {} |%]

    set linkcomps [pipe {
        relation join $multirefed $instances |
        relation rename ~ Class RefingClass Instance RefingInstance |
        relation join ~ $::micca::SimpleReferencedClass\
            -using {Domain Domain Relationship Relationship} |
        relation eliminate ~ Role Conditionality |
        relation rename ~ Relationship Component |
        relation join ~ $::micca::ClassComponentValue
    }]

    # puts [relformat $linkcomps linkcomps]
    set rflinkcomps [relation restrictwith $linkcomps {$RefingClass eq $Class}]
    set nrflinkcomps [relation minus $linkcomps $rflinkcomps]

    set rflinkcomps [pipe {
        relation eliminate $rflinkcomps RefingClass RefingInstance |
        relation update ~ lctup {1} {tuple update $lctup\
                Value [dict create\
                    RefInst [tuple extract $lctup Instance]\
                    Value [dict get [tuple extract $lctup Value] backward]]\
                Component [tuple extract $lctup Component]__LINKS
        }
    }]
    # puts [relformat $rflinkcomps rflinkcomps]
    set nrflinkcomps [pipe {
        relation restrictwith $nrflinkcomps {$RefingInstance in $Value} |
        relation eliminate  ~ Class |
        relation rename ~ Instance RefInst RefingClass Class\
                RefingInstance Instance |
        relation update ~ nrtup {1} {tuple update $nrtup\
                Component [tuple extract $nrtup Component]__LINKS\
                Value [dict create\
                    RefInst [tuple extract $nrtup RefInst]\
                    Value [tuple extract $nrtup Value]]} |
        relation eliminate ~ RefInst
    }]
    # puts [relformat $nrflinkcomps nrflinkcomps]

    set simplinks [pipe {
        relation join $multirefed $sdc |
        relation eliminate ~ Multiplicity |
        relation extend ~ sltup Component string {
            "[tuple extract $sltup Relationship]__LINKS"}
    }]
    # puts [relformat $simplinks simplinks]

    set linkcomps [pipe {
        relation join $multirefed $instances |
        relation rename ~ Class RefingClass Instance RefingInstance |
        relation join ~ $::micca::SimpleReferencedClass\
            -using {Domain Domain Relationship Relationship} |
        relation eliminate ~ Role Conditionality |
        relation rename ~ Relationship Component |
        relation join ~ $::micca::ClassComponentValue
    }]
    # puts [relformat $linkcomps linkcomps]

    # HERE
    # do the class based associations

    set multisource [pipe {
        findRelatedWhere $classRefs {{~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 SourceClass}} \
            {$Multiplicity && ![GetAssociationProperty $Relationship IsStatic]} |
        deRef % |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class SourceClass
    } {} |%]
    # puts [relformat $multisource multisource]
    set multitarget [pipe {
        findRelatedWhere $classRefs {{~R41 ClassRole}\
            {~R40 AssociationParticipantClass} {~R38 TargetClass}} \
            {$Multiplicity && ![GetAssociationProperty $Relationship IsStatic]} |
        deRef % |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class TargetClass
    } {} |%]
    # puts [relformat $multitarget multitarget]
    set assocs [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 AssociatorClass} |
        deRef % |
        relation eliminate % Role |
        relation rename % Class AssocClass
    } {} |%]
    # puts [relformat $assocs assocs]

    set srclinkcomps [pipe {
        relation eliminate $::micca::SourceClass\
                Role Conditionality Multiplicity |
        relation join ~ $multitarget $assocs |
        relation rename ~ Relationship Component
    }]
    puts [relformat $srclinkcomps srclinkcomps]

    set nrsrclinkcomps [relation restrictwith $srclinkcomps\
            {$Class ne $TargetClass}]
    set rlinkcomps [relation minus $srclinkcomps $nrsrclinkcomps]

    set nrsrclinkcomps [pipe {
        relation join $nrsrclinkcomps $::micca::ClassComponentValue |
        relation project ~ Domain AssocClass Component Value |
        relation rename ~ AssocClass Class |
        relation join ~ $instances |
        relation restrictwith ~ {$Instance in $Value} |
        relation update ~ sctup {1} {tuple update $sctup\
                Component [tuple extract $sctup Component]__FLINKS}
    }]
    puts [relformat $nrsrclinkcomps nrsrclinkcomps]

    set rlinkcomps [pipe {
        relation eliminate $rlinkcomps Class |
        relation rename ~ AssocClass Class |
        relation join ~ $micca::ClassComponentValue |
        relation extend ~ rstup\
            FValue string {[dict get [tuple extract $rstup Value] forward]}\
            BValue string {[dict get [tuple extract $rstup Value] backward]} |
        relation eliminate ~ Value
    }]
    puts [relformat $rlinkcomps rlinkcomps]

    set flinkcomps [pipe {
        relation eliminate $rlinkcomps TargetClass BValue |
        relation rename ~ FValue Value
    }]
    puts [relformat $flinkcomps flinkcomps]

    set blinkcomps [pipe {
        relation eliminate $rlinkcomps TargetClass FValue |
        relation rename ~ BValue Value
    }]
    puts [relformat $blinkcomps blinkcomps]

    set rsrccomps [pipe {
        relation group $flinkcomps Instances Instance
    }]
    puts [relformat $rsrccomps rsrccomps]


    if 0 {
    set rtrglinkcomps [pipe {
        relation eliminate $rlinkcomps FValue |
        relation group ~ BValues BValue |
        relation extend ~ rstup Value string\
            {[relation list [tuple extract $rstup BValues]]} |
        relation eliminate ~ TargetClass BValues |
        relation update ~ sctup {1} {tuple update $sctup\
                Component [tuple extract $sctup Component]__BLINKS}
    }]
    puts [relformat $rtrglinkcomps rtrglinkcomps]
    }

    set trglinkcomps [pipe {
        relation eliminate $::micca::TargetClass\
                Role Conditionality Multiplicity |
        relation join ~ $multisource $assocs |
        relation rename ~ Relationship Component |
        relation join ~ $::micca::ClassComponentValue |
        relation project ~ Domain AssocClass Component Value |
        relation rename ~ AssocClass Class |
        relation join ~ $instances |
        relation restrictwith ~ {$Instance in $Value} |
        relation update ~ sctup {1} {tuple update $sctup\
                Component [tuple extract $sctup Component]__BLINKS}
    }]
    puts [relformat $trglinkcomps trglinkcomps]

    # HERE
    # Have to deal with reflexive case.
    # probably need to separate reflexive cases for both srclinks and trglinks

    set ccvalues [relation union $::micca::ClassComponentValue\
        $rflinkcomps $nrflinkcomps]
    # puts [relformat $ccvalues ccvalues]
    # $srclinkcomps $trglinkcomps

    set classpops [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation rename % Number InstNumber |
        relation join % $classes $ccvalues |
        ralutil::rvajoin % $attrs Attributes |
        ralutil::rvajoin % $superrefs SuperRefs |
        ralutil::rvajoin % $subrefs SubRefs |
        ralutil::rvajoin % $assctorrefs AssociatorRefs |
        ralutil::rvajoin % $asstionrefs AssociationRefs |
        ralutil::rvajoin % $subcont SubclassContainer |
        ralutil::rvajoin % $simplinks SimpleLinks |
        relation group % Components Component Value Attributes SuperRefs\
            SubRefs AssociatorRefs AssociationRefs SubclassContainer\
            SimpleLinks |
        relation group % Instances Instance InstNumber Components |
        relation eliminate % Domain
    } {} |%]
    # puts [relformat $classpops classpops]

    return $classpops
}
----

[source,c]
----
<<generation code commands>>=
proc GenInstanceInitializers {className classNumber inst} {
    variable domain
    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    relation assign $inst

    set sp [pipe {
        StateModel findById Domain $domain Model $className |
        findRelated ~ R58 R57
    }]
    set initstate [expr {[isNotEmptyRef $sp] ?\
        [readAttribute $sp Number] : "MRT_StateCode_IG"}]

    append result\
        "$indent\{\n"\
        "$indent2.base__INST = \{\n"\
        "$indent3.classDesc = &${domain}__CLASSES\[$classNumber\],\n"\
        "$indent3.alloc = [expr {$InstNumber + 1}],\n"\
        "$indent3.currentState = $initstate,\n"\
        "$indent3.refCount = 0,\n"\
        "${indent4}#ifndef MRT_NO_NAMES\n"\
        "$indent3.name = \"$Instance\"\n"\
        "${indent4}#endif /* MRT_NO_NAMES */\n"\
        " $indent2\},\n"

    relation foreach comp $Components {
        relation assign $comp
        if {[relation isnotempty $Attributes]} {
            append result "$indent2.$Component  = $Value,\n"
            continue
        }

        if {[relation isnotempty $SuperRefs]} {
            set superclass [relation extract $SuperRefs Superclass]
            append result\
                "$indent2.$Component = "\
                [GenInstanceAddress $domain $superclass $Value],\n
            continue
        }

        if {[relation isnotempty $SubRefs]} {
            lassign $Value subclass subinstname
            set subinstaddr [GenInstanceAddress $domain $subclass\
                $subinstname]
            append result "$indent2.$Component = (MRT_Instance *)$subinstaddr,\n"
            continue
        }

        if {[relation isnotempty $AssociatorRefs]} {
            relation assign $AssociatorRefs
            # the painful reflexive case again!
            if {$SourceClass eq $TargetClass} {
                # N.B. the inversion. the target instance is the
                # one referenced in the forward direction
                set sinstname [dict get $Value backward]
                set tinstname [dict get $Value forward]
            } else {
                set sinstname [dict get $Value $SourceClass]
                set tinstname [dict get $Value $TargetClass]
            }
            set sourceaddr [GenInstanceAddress $domain $SourceClass\
                $sinstname]
            set targetaddr [GenInstanceAddress $domain $TargetClass\
                $tinstname]

            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.forward = $targetaddr,\n"\
                "$indent3.backward = $sourceaddr\n"\
                "$indent2\},\n"
            continue
        }
        if {[relation isnotempty $AssociationRefs]} {
            relation assign $AssociationRefs
            if {[relation cardinality $References] > 1} {
                # reflexive case
                set sref [relation restrict $References rtup {
                    [tuple extract $rtup Role] eq "source"
                }]
                set tref [relation restrict $References rtup {
                    [tuple extract $rtup Role] eq "target"
                }]

                append result [indentCode [string cat\
                    ".$Component = \{\n"\
                    [indentCode [GenReflexiveReference $domain $className\
                        $InstNumber $Component $sref $Value]]\
                    [indentCode [GenReflexiveReference $domain $className\
                        $InstNumber $Component $tref $Value]]\
                    "\},\n"\
                ] 8]
            } else {
                append result [indentCode\
                    [GenNonReflexiveReference $domain $className\
                        $InstNumber $Component $References $Value] 8]
            }
            continue
        }
        if {[relation isnotempty $SubclassContainer]} {
            lassign $Value subclass subinst

            set subRef [Class findWhere {$Domain eq $domain &&\
                $Name eq $subclass}]
            set subpops [FindClassPopulation $subRef]
            # puts [relformat $subpops subpops]

            relation assign $subpops {Class subclassName}\
                {ClassNumber subclassNumber} {Instances subInstances}
            set instpop [relation restrictwith $subInstances\
                {$Instance eq $subinst}]

            append result\
                "$indent2.$Component.$subclass = "\
                [string trimleft [indentCode [GenInstanceInitializers\
                    $subclassName $subclassNumber $instpop] 8]]
            continue
        }
        if {[relation isnotempty $SimpleLinks]} {
            relation assign $SimpleLinks
            set refInst [dict get $Value RefInst]
            set refs [dict get $Value Value]
            set nrefs [llength $refs]
            set refaddr [GenInstanceAddress $domain $RefClass $refInst].$Relationship
            if {$RefClass eq $className} {
                append refaddr .backward
            }
            if {$nrefs == 0} {
                set next [GenInstanceAddress $domain $className $Instance].$Component
                set prev $next
            } elseif {$nrefs == 1} {
                set next $refaddr
                set prev $refaddr
            } else {
                set instindex [lsearch $refs $Instance]
                if {$instindex == 0} {
                    set next [GenInstanceAddress $domain $className\
                        [lindex $refs 1]].$Component
                    set prev $refaddr
                } elseif {$instindex == $nrefs - 1} {
                    set next $refaddr
                    set prev [GenInstanceAddress $domain $className\
                        [lindex $refs $instindex-1]].$Component
                } else {
                    set next [GenInstanceAddress $domain $className\
                        [lindex $refs $instindex+1]].$Component
                    set prev [GenInstanceAddress $domain $className\
                        [lindex $refs $instindex-1]].$Component
                }
            }
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $next,\n"\
                "$indent3.prev = $prev\n"\
                "$indent2\},\n"
        }
    }

    append result "$indent\},\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc activityDefinitions {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && $Activity ne {}} |
        deRef ~ |
        relation eliminate ~ Domain IsTerminal |
        relation group ~ States Name Activity PSigID
    }]
    # puts [relformat $classes classes]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Definitions"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            append result "#define MRT_CLASSNAME \"$Model\"\n"
            relation foreach state $States {
                relation assign $state
                append result\
                    "static void ${Model}_${Name}__ACTIVITY\(\n"\
                    "    void *const s__,\n"\
                    "    void const *const p__)\n"\
                    "\{\n"\
                    "        #define MRT_STATENAME \"$Name\"\n"\
                    "    MRT_INSTRUMENT_ENTRY\n\n"\
                    "    [GetClassProperty $Model Reference] const self = s__ ;\n"
                if {$PSigID ne {}} {
                    set params [pipe {
                        ParameterSignature findById Domain $domain PSigID $PSigID |
                        findRelated % ~R79 |
                        deRef % |
                        relation join % $::micca::Argument |
                        relation project % Name Position DataType |
                        relation extend % ptup Decl string {
                            [typeCheck composeDeclaration\
                                [tuple extract $ptup DataType]\
                                [tuple extract $ptup Name]]}
                    } {} |%]
                    # puts [relformat $params params]

                    append result "    struct \{\n"
                    relation foreach param $params -ascending Position {
                        relation assign $param Decl
                        append result "        $Decl ;\n"
                    }
                    append result "    \} const *const pp__ = p__ ;\n"
                    relation foreach param $params -ascending Position {
                        relation assign $param {Name pname} Decl
                        append result "    $Decl = pp__->$pname ;\n"
                    }
                }
                # HERE --- need to template expand the code
                append result "\n[indentCode $Activity]"

                append result \n\
                    "        #undef MRT_STATENAME\n"\
                    "\}\n"
            }
            append result "#undef MRT_CLASSNAME\n"
        }
    }

    return $result
}
----

== Helper Commands

[source,c]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,c]
----
<<generation helper commands>>=
proc banner {} {
    string cat\
        "/*\n"\
        " * [string repeat - 70]\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * [string repeat - 70]\n"\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc comment {args} {
    set result "/*\n"

    foreach c $args {
        append result\
            [::textutil::adjust::indent [::textutil::adjust::adjust $c] " * "]\n
    }

    append result " */\n"

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

[source,c]
----
<<generation helper commands>>=
proc GenInstanceAddress {domainName className instName} {
    set path {}
    set usubRef [UnionSubclass findWhere {$Domain eq $domainName &&\
        $Class eq $className}]
    if {[isNotEmptyRef $usubRef]} {
        # puts [relformat [deRef $usubRef] usubRef]
        while {[isNotEmptyRef $usubRef]} {
            assignAttribute $usubRef {Relationship rship} {Class subName}
            set path .$rship.${subName}$path

            set usuperRef [findRelated $usubRef R45 ~R44]
            set superClass [readAttribute $usuperRef Class]

            set usubRef [pipe {
                deRef $usuperRef |
                relation semijoin ~ $::micca::UnionSubclass\
                    -using {Domain Domain Class Class} |
                ::rosea::Helpers::ToRef ::micca::UnionSubclass ~
            }]
            # puts [relformat [deRef $usubRef] usubRef]
        }

        # puts "path = \"$path\""
        set storageClass $superClass
    } else {
        set storageClass $className
    }
    set instNumber [readAttribute\
            [ClassInstance findById Domain $domainName Class $className\
                Instance $instName]\
        Number]
    return &${storageClass}__POOL\[$instNumber\]$path
}
----

[source,c]
----
<<generation helper commands>>=
proc GenReflexiveReference {domainName className instnum component ref refvalue} {
    relation assign $ref
    set dir [expr {$Role eq "source" ? "forward" : "backward"}]
    set ltype [string toupper [string index $dir 0]]
    set inst [expr {$IsClassBased ? $refvalue : [dict get $refvalue $dir]}]

    if {!$Multiplicity} {
        # Singular
        set compvalue [expr {$inst eq {} ? "NULL" :\
            [GenInstanceAddress $domainName $RefClass $inst]}]
        set result ".$dir = $compvalue,\n"
    } elseif {$IsStatic} {
        set refvar ${className}_${instnum}_${component}__${ltype}REFS
        GenStaticReferenceBlock $domainName $RefClass $refvalue $refvar
        set result [string cat\
            ".$dir = \{\n"\
            "    .count = COUNTOF($refvar),\n"\
            "    .references = $refvar\n"\
            "\},\n"\
        ]
    } else {
        # Dynamic multiple
        if {[llength $inst] == 0} {
            set nextvalue &${className}__POOL\[$instnum\].$component
            set prevvalue $nextvalue
        } else {
            set lname __[expr {$IsClassBased ? $ltype : {}}]LINKS
            set nextvalue [string cat\
                [GenInstanceAddress $domainName $RefClass [lindex $inst 0]]\
                .${component}${lname}\
            ]
            set prevvalue [string cat\
                [GenInstanceAddress $domainName $RefClass [lindex $inst end]]\
                .${component}${lname}\
            ]
        }
        set result [string cat\
            ".$dir = \{\n"\
            "    .next = $nextvalue,\n"\
            "    .prev = $prevvalue\n"\
            "\},\n"\
        ]
    }
    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc GenStaticReferenceBlock {domainName refClass classes varName} {
    upvar #0 ::micca::@Gen@::GenCode::staticMultiRefs staticMultiRefs

    append staticMultiRefs\
        "static [GetClassProperty $refClass Declaration] * const "\
        "$varName\[\] = \{\n"
    foreach refinst $classes {
        append staticMultiRefs\
            "    "\
            [GenInstanceAddress $domainName $refClass $refinst],\n
    }
    append staticMultiRefs "\} ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc GenNonReflexiveReference {domainName className instnum component ref\
        refvalue} {
    relation assign $ref
    set dir [expr {$Role eq "source" ? "forward" : "backward"}]
    set ltype [string toupper [string index $dir 0]]

    if {!$Multiplicity} {
        # Singular
        set compvalue [expr {$refvalue eq {} ? "NULL" :\
            [GenInstanceAddress $domainName $RefClass $refvalue]}]
        set result ".$component = $compvalue,\n"
    } elseif {$IsStatic} {
        set refvar ${className}_${instnum}_${component}__${ltype}REFS
        GenStaticReferenceBlock $domainName $RefClass $refvalue $refvar
        set result [string cat\
            ".$component = \{\n"\
            "    .count = COUNTOF($refvar),\n"\
            "    .references = $refvar\n"\
            "\},\n"\
        ]
    } else {
        # Dynamic multiple
        if {[llength $refvalue] == 0} {
            set nextvalue\
                &${className}__POOL\[$instnum\].$component
            set prevvalue $nextvalue
        } else {
            set lname __[expr {$IsClassBased ? $ltype : {}}]LINKS
            set nextvalue [string cat\
                [GenInstanceAddress $domainName $RefClass [lindex $refvalue 0]]\
                .${component}${lname}\
            ]
            set prevvalue [string cat\
                [GenInstanceAddress $domainName $RefClass [lindex $refvalue end]]\
                .${component}${lname}\
            ]
        }
        set result [string cat\
            ".$component = \{\n"\
            "    .next = $nextvalue,\n"\
            "    .prev = $prevvalue\n"\
            "\},\n"\
        ]
    }
}
----

== Interfacing Domain Code to the Run Time

Interfacing Domain Code to the Run Time
