// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time translates model level actions into ``C'' level
execution.
The run time can be compiled separately and is data driven.
The details of how a domain behaves is completely determined by the
data values supplied to the run time and the state activities and
domain operations supplied as ``C'' code.

Code generation consist of two major pieces:

* Generating initialized ``C'' variables of the type required by the run time.
* Generating ``C'' code for state activities and domain operations to
facilitate interfacing to the run time code.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,c]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,c]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
Generally,
one is required to declare symbols before they are defined.
The ordering has to be quite precise.
One way to accomplish this is to use a template.
The template is orgainized in the order required by the compiler
and contains embedded commands.
When expanded the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from `tcllib`.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,c]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

Because we are using a template expansion technique to generate the code
files,
the code generation has the flavor of a report generator.
Commands imbedded in the template make queries on the populated
platform model and emit a _report_ of the query, which in this case
are ``C'' language statements.
Although the reports generated are intended to be consumed by a compiler
rather than a human,
the design of the generator is very similar to generating reports
from a database.
In this case the database is the platform model and the reports are ``C'' code.

[source,c]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: generate header files>>
    <<miccaGenerate: generate code files>>

    rename expand {} ; # <1>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return
}
----
<1> The template expander creates a new command and we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation errors}
----

We set up options for the generation in a dictionary.
The default values are given and can be overridden by those passed in.

[source,c]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror     fail\
]
set options [dict merge $options $arglist]
----

The `textutil::expander` package creates a command that does all the
expansion work.

[source,c]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand setbrackets %< >% ; # <1>
expand errmode [dict get $options expanderror]
----
<1> The default way to embed commands in the template is with
the conventional Tcl brackets ([ ]).
Those characters are inconvenient in ``C'' so we use bracket strings
that create less interference.

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,c]
----
<<miccaGenerate: verify domains are populated>>=
set badpops [pipe {
    Population findAll |
    findUnrelated ~ R100
}]

forAllRefs badpop $badpops {
    set domainName [readAttribute $badpop Name]
    log::error "for domain, \"$domainName\", no population is given"
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

== Header Files

The header file generated for a domain contains interfacing information.
Typically, the header file is included by bridge code that is
mapping the dependencies of one domain onto another.

Following our usual pattern,
we will execute the header generation commands from the template in
a child namespace to avoid any name conflicts.

[source,c]
----
<<miccaGenerate: generate header files>>=
expand evalcmd "namespace eval [namespace current]::GenHeader"
----

The `GenHeader` namespace is a child of `::micca::@Gen@` and follows
our usual pattern of imports, command path and contents.

[source,c]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

The template for the header file is shown below.
Each embedded command is then shown in the following sections.

[source,c]
----
<<generation data>>=
set headerTemplate [string cat\
    %<banner>%\
    "#ifndef %<headerFileGuard>%\n"\
    "#define %<headerFileGuard>%\n"\
    %<interface>%\
    "#include <stddef.h>\n"\
    "#include <stdint.h>\n"\
    "#include <stdbool.h>\n"\
    %<typeAliases>%\
    %<domainOpDeclarations>%\
    %<eventParamDeclarations>%\
    %<portalIds>%\
    "#endif /* %<headerFileGuard>% */"\
]
----

The generation of the header files is accomplished by iterating
over all the domains and placing the output of the template
expansion into a file.
We use some variables to provide context to the embedded expansion commands.

[source,c]
----
<<miccaGenerate: generate header files>>=
variable headerTemplate

forAllRefs domainRef [Domain findAll] {
    namespace upvar GenHeader\
        domain domain\
        interface interface

    assignAttribute $domainRef\
        {Name domain}\
        {Interface interface}

    set hchan [::open $domain.h w]
    try {
        puts $hchan [expand expand $headerTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $hchan
    }

    unset domain interface
}
----

[source,c]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return [string toupper [string trim $domain]]_H_
}
----

[source,c]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    set result {}
    if {$interface ne {}} {
        append result\
            [comment "Domain Interface Contents"]\
            [indentCode [string trim $interface \n] 0]
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    makeFile {} header1.h
    makeFile {} header1.c
    micca configure {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {stdio} header1.h]
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc typeAliases {} {
    variable domain
    set aliases [pipe {
        TypeAlias findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ TypeName
    }]
    set doRefs [pipe {
        DomainOperation findWhere {$Domain eq $domain &&\
                $ReturnDataType in $aliases} |
        findRelated % R5 ~R7
    } {} |%]
    set dopRefs [pipe {
        DomainOperationParameter findWhere {$Domain eq $domain &&\
                $DataType in $aliases} |
        findRelated % R6 R5 ~R7
    } {} |%]
    set argRefs [pipe {
        Argument findWhere {$Domain eq $domain && $DataType in $aliases} |
        deRef ~ |
        relation semijoin ~ $::micca::TypeAlias\
                -using {Domain Domain DataType TypeName} |
        ::rosea::Helpers::ToRef ::micca::TypeAlias ~
    }]

    set taRefs [refUnion $doRefs $dopRefs]
    set taRefs [refUnion $taRefs $argRefs]
    set result {}
    if {[isNotEmptyRef $taRefs]} {
        append result [comment "Type Aliases"]
        forAllRefs taRef $taRefs {
            assignAttribute $taRef TypeName TypeDefinition
            append result\
                "typedef "\
                [typeCheck composeDeclaration $TypeDefinition $TypeName]\
                " \;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    makeFile {} header2.h
    makeFile {} header2.c
    micca configure {
        domain header2 {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {typedef} header2.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    set result {}
    if {[isNotEmptyRef $opRefs]} {
        append result [comment "External Declarations for Domain Operations"]

        forAllRefs opRef $opRefs {
            assignAttribute $opRef
            if {$Comment ne {}} {
                append result [comment $Comment]
            }
            append result "extern $ReturnDataType " $Domain _ $Name \(

            set params [pipe {
                findRelated $opRef ~R6 |
                deRef % |
                relation list % DataType -ascending Number |
                join % {, }
            } {} |%]
            append result $params "\) ;\n"
        }
    }
    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-3.0 {
    Generated header file domain operations
} -setup {
    makeFile {} header3.h
    makeFile {} header3.c
    micca configure {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {extern int header3_op[0-9]} header3.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    set result [comment "Numeric encoding of classes, attributes and\
            instances used by the portal functions"]
    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        assignAttribute $classRef
        append result [comment "Class: $Name"]
        set classid [string toupper ${Domain}_${Name}_CLASSID]
        append result "#define $classid $Number\n"

        set attrRefs [findRelated $classRef ~R20 {~R21 Attribute}]
        set attrNumber -1
        relation foreach attr [deRef $attrRefs] -ascending Name {
            relation assign $attr {Name attrName}
            set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
            append result "#define $attrid [incr attrNumber]\n"
        }

        set instRefs [findRelated $classRef ~R20 ~R103]
        relation foreach inst [deRef $instRefs] -ascending Number {
            relation assign $inst Instance {Number InstNumber}
            set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
            append result "#define $instid $InstNumber\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    makeFile {} header4.h
    makeFile {} header4.c
    micca configure {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population header4 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {CLASSID} header4.h]
} -result {2}
----

== Generating Code Files

[source,c]
----
<<miccaGenerate: generate code files>>=
expand evalcmd "namespace eval [namespace current]::GenCode"
----

[source,c]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    namespace import [namespace parent]::expand

    <<generation code data>>
    <<generation code commands>>
}
----

[source,c]
----
<<generation data>>=
set codeTemplate [string cat\
    %<banner>%\
    %<prologue>%\
    "#include \"micca_rt.h\"\n"\
    %<domainInclude>%\
    %<forwardClassDeclarations>%\
    %<classDeclarations>%\
    %<stateParamDeclarations>%\
    %<operationDeclarations>%\
    %<ctorDeclarations>%\
    %<dtorDeclarations>%\
    %<activityDeclarations>%\
    %<storageDeclarations>%\
    %<nameDefinitions>%\
    %<iabDefinitions>%\
    %<edbDefinitions>%\
    %<pdbDefinitions>%\
    %<classDefinitions>%\
    %<relationshipDefinitions>%\
    %<epilogue>%\
]
----

[source,c]
----
<<miccaGenerate: generate code files>>=
variable codeTemplate

forAllRefs domainRef [Domain findAll] {
    namespace upvar GenCode\
        domain domain\
        prologue prologue\
        epilogue epilogue

    assignAttribute $domainRef\
        {Name domain}\
        {Prologue prologue}\
        {Epilogue epilogue}

    PrepareDomainProperties $domain

    set cchan [::open $domain.c w]
    try {
        puts $cchan [expand expand $codeTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $cchan
    }
}
----

[source,c]
----
<<generation helper commands>>=
proc PrepareDomainProperties {domain} {
    variable ClassProperties

    # Need to handle missing class populations.
    # Not all classes will have a ClassPopulation instance.
    set classRefs [Class findWhere {$Domain eq $domain}]
    set allocs [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} |
        deRef % |
        relation project % Class Allocation |
        relation rename % Class Name
    } {} |%]

    set insts [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation project % Class Number |
        relation rename % Class Name
    } {} |%]

    set ClassProperties [pipe {
        deRef $classRefs |
        relation project ~ Name |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            StorageVariable string {"struct [tuple extract $stup Name]\
                [tuple extract $stup Name]__POOL"} |
        ralutil::rvajoin ~ $allocs Allocations |
        relation extend ~ atup Allocation int {
            [relation isempty [tuple extract $atup Allocations]] ?\
            0 : [relation extract [tuple extract $atup Allocations] Allocation]
        } |
        relation eliminate ~ Allocations |
        ralutil::rvajoin ~ $insts Instances |
        relation extend ~ itup\
            InitialInstance int {
                [relation cardinality [tuple extract $itup Instances]]} \
            TotalInstance int {
                [relation cardinality [tuple extract $itup Instances]] +
                [tuple extract $itup Allocation]} |
        relation eliminate ~ Instances
    }]

    variable AssocProperties

    set AssocProperties [pipe {
        Association findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Association |
        ralutil::rvajoin ~ [deRef [StaticAssociation findAll]] Populations |
        relation extend ~ atup IsStatic boolean {
            [relation isnotempty [tuple extract $atup Populations]]} |
        relation project ~ Association IsStatic |
        relation rename ~ Association Name
    }]

    return
}

proc JoinToClassProperties {proprel} {
    variable ClassProperties
    set ClassProperties [relation join $ClassProperties $proprel]
}

proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}

proc GetAssociationProperty {assoc prop} {
    variable AssocProperties
    set aprop [relation restrictwith $AssocProperties {$Name eq $assoc}]
    if {[relation isnotempty $aprop]} {
        return [relation extract $aprop $prop]
    }

    error "unknown property, \"$prop\", for association, \"$assoc\""
}
----

[source,c]
----
<<generation code commands>>=
proc prologue {} {
    variable prologue

    set result {}
    if {$prologue ne {}} {
        append result\
            [comment "Domain Prologue Begin"]\
            [indentCode [string trim $prologue \n] 0]\
            [comment "Domain Prologue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc epilogue {} {
    variable epilogue

    set result {}
    if {$epilogue ne {}} {
        append result\
            [comment "Domain Epilogue Begin"]\
            [indentCode [string trim $epilogue \n] 0]\
            [comment "Domain Epilogue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,c]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    makeFile {} codegen1.h
    makeFile {} codegen1.c
    micca configure {
        domain codegen1 {
            prologue {#include mySpecial.h}
            prologue {#include theSpecial.h}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population codegen1 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {Special} codegen1.c]
} -result {2}
----

[source,c]
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc classDeclarations {} {
    variable domain

    variable linkMemberNames [dict create]

    set result [comment "Class structure declarations"]

    set ultimates [pipe {
        FindUltimateSuperclasses $domain |
        findRelated % {~R46 UnionSuperclass}
    } {} |%]
    append result [DeclareUnionSubclassStructures $ultimates]

    set remaining [FindNonUnionSubclasses $domain]
    forAllRefs classRef $remaining {
        append result [DeclareClassStructure $classRef]
    }

    JoinToClassProperties [relation fromdict $linkMemberNames\
        Name string LinkMembers list]

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc FindNonUnionSubclasses {domain} {
    set usubs [UnionSubclass findWhere {$Domain eq $domain}]
    return [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation semiminus [deRef $usubs] ~ -using {Domain Domain Class Name} |
        ::rosea::Helpers::ToRef ::micca::Class ~
    }]
}
----

[source,c]
----
<<generation code commands>>=
proc DeclareUnionSubclassStructures {superRefs} {
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs R44 ~R45]
    forAllRefs subRef $subRefs {
        set newsupers [pipe {
            deRef $subRef |
            relation semijoin ~ $::micca::UnionSuperclass\
                -using {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
        }]

        append result [DeclareUnionSubclassStructures $newsupers]

        append result [DeclareClassStructure [findRelated $subRef R47 R40 R41]]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc DeclareClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__INST ;\n"

    set compRefs [findRelated $classRef ~R20]

    # Attributes first
    forAllRefs attrRef [findRelated $compRefs {~R21 Attribute}] {
        assignAttribute $attrRef {Name attrName} DataType
        append result "    $DataType $attrName ;\n"
    }

    # References second
    set refRefs [findRelated $compRefs {~R21 Reference}]

    # Superclass References
    forAllRefs superRef [findRelated $refRefs {~R23 SuperclassReference}] {
        assignAttribute $superRef {Name attrName}

        set superDecl [pipe {
            findRelated $superRef ~R91 R37 ~R36 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        append result "    $superDecl$attrName ;\n"
    }

    # Subclass References
    forAllRefs subRef [findRelated $refRefs {~R23 SubclassReference}] {
        assignAttribute $subRef {Name attrName}
        append result "    MRT_SuperclassRef $attrName ;\n"
    }

    # Associator Reference
    forAllRefs atorRef [findRelated $refRefs {~R23 AssociatorReference}] {
        assignAttribute $atorRef {Name attrName}

        set aclassRef [findRelated $atorRef ~R93]
        set sourceDecl [pipe {
            findRelated $aclassRef R42 ~R34 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        set targetDecl [pipe {
            findRelated $aclassRef R42 ~R35 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]

        append result\
            "    struct \{\n"\
            "        ${targetDecl}forward ;\n"\
            "        ${sourceDecl}backward ;\n"\
            "    \} $attrName ;\n"
    }

    # Association Reference
    forAllRefs assocRef [findRelated $refRefs {~R23 AssociationReference}] {
        assignAttribute $assocRef {Name attrName}

        set apcRefs [findRelated $assocRef ~R25 R90]
        set napcRefs [refMultiplicity $apcRefs]
        if {$napcRefs == 1} {
            set srcRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $srcRef]} {
                set refedRef [findRelated $srcRef R32 ~R33]
                append result [GenDirectionalReference $attrName\
                        {*}[readAttribute $refedRef Relationship Class] false]
            } else {
                set srcRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                if {[isNotEmptyRef $srcRef]} {
                    set refing [findRelated $srcRef R33 ~R32]
                    append result\
                        [GenDirectionalReference $attrName\
                            {*}[readAttribute $refedRef\
                                Relationship Class Multiplicity]]
                } else {
                    set srcRef [findRelated $apcRefs {~R38 SourceClass}]
                    if {[isNotEmptyRef $srcRef]} {
                        set assoc [findRelated $srcRef R34 ~R42]
                        set target [findRelated $srcRef R34 ~R35]
                        append result\
                            [GenDirectionalReference $attrName\
                                {*}[readAttribute $assoc Relationship Class]\
                                [readAttribute $target Multiplicity]]
                    } else {
                        set trgRef [findRelated $apcRefs {~R38 TargetClass}]
                        if {[isNotEmptyRef $trgRef]} {
                            set assoc [findRelated $trgRef R35 ~R42]
                            set source [findRelated $trgRef R35 ~R34]
                            append result\
                                [GenDirectionalReference $attrName\
                                    {*}[readAttribute $assoc Relationship Class]\
                                    [readAttribute $source Multiplicity]]
                        } else {
                            error "cannot find association participant type\
                                across R38"
                        }
                    }
                }
            }
        } elseif {$napcRefs == 2} {
            # do reflexive case
            append result "    struct \{\n"

            set refingRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $refingRef]} {
                # simple association
                set refedRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                append result "    " [GenDirectionalReference forward\
                    {*}[readAttribute $refedRef Relationship Class] false]
                append result "    " [GenDirectionalReference backward\
                    {*}[readAttribute $refingRef Relationship Class Multiplicity]]
            } else {
                set sourceRef [findRelated $apcRefs {~R38 SourceClass}]
                if {[isNotEmptyRef $sourceRef]} {
                    set targetRef [findRelated $apcRefs {~R38 TargetClass}]
                    set assocRef [findRelated $sourceRef R34 ~R42]
                    append result [GenDirectionalReference forward\
                        {*}[readAttribute $assocRef Relationship Class]\
                        [readAttribute $targetRef Multiplicity] 8]
                    append result [GenDirectionalReference backward\
                        {*}[readAttribute $assocRef Relationship Class]\
                        [readAttribute $sourceRef Multiplicity] 8]

                } else {
                    error "cannot resolve reflexive association"
                }
            }
            append result "    \} $attrName ;\n"
        } else {
            error "unexpected number of directional references, \"$napcRefs\""
        }
    }

    # Subclass container
    # Union supertypes will contain a superclass container.
    forAllRefs contRef [findRelated $compRefs {~R21 SubclassContainer}] {
        assignAttribute $contRef {Name attrName}

        append result\
            "    struct \{\n"\
            "        MRT_SubclassCode subCode ;\n"
        set subRefs [findRelated $contRef ~R96 R44 ~R45]
        append result\
            "        union \{\n"
        foreach subName [relation list [deRef $subRefs] Class] {
            append result "            "\
                "[GetClassProperty $subName Declaration] $subName ;\n"
        }
        append result\
            "        \} subInst ;\n"\
            "    \} $attrName ;\n"
    }

    # Target links
    # link pointers in classes that are referred to by classes with
    # link references.
    # Start with associator classes. They will have link containers if
    # either source or target is multiple and non-static
    variable linkMemberNames
    dict set linkMemberNames $className [list]
    set atorRef [findRelated $classRef {~R41 ClassRole} {~R40 AssociatorClass}]
    if {[isNotEmptyRef $atorRef]} {
        set sourceRef [findRelatedWhere $atorRef {R42 ~R34} {$Multiplicity}]
        if {[isNotEmptyRef $sourceRef]} {
            assignAttribute $sourceRef Relationship
            if {![GetAssociationProperty $Relationship IsStatic]} {
                append result "    "\
                    "MRT_LinkRef ${Relationship}__FORW ;\n"
                dict lappend linkMemberNames $className ${Relationship}__FORW
            }
        }
        set targetRef [findRelatedWhere $atorRef {R42 ~R35} {$Multiplicity}]
        if {[isNotEmptyRef $targetRef]} {
            assignAttribute $targetRef Relationship
            if {![GetAssociationProperty $Relationship IsStatic]} {
                append result "    "\
                    "MRT_LinkRef ${Relationship}__BACK ;\n"
                dict lappend linkMemberNames $className ${Relationship}__BACK
            }
        }
    }

    # Now simple referring classes, multiple and non-static
    set srcRef [findRelatedWhere $classRef {
        {~R41 ClassRole}
        {~R40 AssociationParticipantClass}
        {~R38 SimpleReferringClass}} {$Multiplicity}]
    if {[isNotEmptyRef $srcRef]} {
        assignAttribute $srcRef Relationship
        if {![GetAssociationProperty $Relationship IsStatic]} {
            append result "    MRT_LinkRef ${Relationship}__LINKS ;\n"
            dict lappend linkMemberNames $className ${Relationship}__LINKS
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc GenDirectionalReference {name assocName reftoClass isMultiple {indent 4}} {
    if {$isMultiple} {
        if {[GetAssociationProperty $assocName IsStatic]} {
            append members\
                "unsigned count ;\n"\
                "[GetClassProperty $reftoClass Reference] const *references ;\n"
            append result\
                "struct \{\n"\
                [indentCode $members $indent]\
                "\} $name ;\n"
        } else {
            set result "MRT_LinkRef $name ;\n"
        }
    } else {
        set result "[GetClassProperty $reftoClass Reference]$name ;\n"
    }

    return [indentCode $result $indent]
}
----

[source,c]
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    makeFile {} codegen2.h
    makeFile {} codegen2.c
    micca configure {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population codegen2 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {MRT_SuperclassRef} codegen2.c]] == 1}\
        {[llength [fileutil::grep {struct super \*R1} codegen2.c]] == 2}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associative class references
} -setup {
    # makeFile {} codegen3.h
    # makeFile {} codegen3.c
    micca configure {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 fred1
                instance x2 R1 fred2
            }
            class Y {
                instance y1 R1 fred1
                instance y2 R1 fred2
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen3.c]] == 9}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-4.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen4.h
    # makeFile {} codegen4.c
    micca configure {
        domain codegen4 {
            class X {}
            association R1 X 0..1--0..1 X
        }
        population codegen4 {
            class X {
                instance x1 R1 {forward x2 backward {}}
                instance x2 R1 {forward {} backward x1}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen4.c]] == 6}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-5.0 {
    Generated code file reflexive associative class references
} -setup {
    # makeFile {} codegen5.h
    # makeFile {} codegen5.c
    micca configure {
        domain codegen5 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen5 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a1
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen5.c]] == 8}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-6.0 {
    Generated code file union generalization
} -setup {
    # makeFile {} codegen6.h
    # makeFile {} codegen6.c
    micca configure {
        domain codegen6 {
            class super {}
            class sub1 {
                attribute color int -default 10
            }
            class sub2 {
                attribute temp int -default 20
            }
            generalization R1 -union super sub1 sub2

            class sub3 {
                attribute degree int -default 30
            }
            class sub4 {
                attribute yaw int -default 40
            }

            generalization R2 -union sub1 sub3 sub4

            class sub5 {
                attribute degree int -default 30
            }
            class sub6 {
                attribute degree int -default 30
            }

            generalization R3 -union sub1 sub5 sub6
        }
        population codegen6 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R2 {sub3 s3} R3 {sub5 s5}
            }
            class sub2 {
                instance s2
            }
            class sub3 {
                instance s3
            }
            class sub5 {
                instance s5
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen6.c]] == 10}\
        {[llength [fileutil::grep {R2} codegen6.c]] == 10}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-7.0 {
    Generated code file associative class references -- non static
} -setup {
    # makeFile {} codegen7.h
    # makeFile {} codegen7.c
    micca configure {
        domain codegen7 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population codegen7 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 fred1
                instance x2 R1 fred2
            }
            class Y {
                instance y1 R1 fred1
                instance y2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen7.c]] == 7}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-8.0 {
    Generated code file reflexive associative class references -- non static
} -setup {
    # makeFile {} codegen8.h
    # makeFile {} codegen8.c
    micca configure {
        domain codegen8 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen8 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen8.c]] == 7}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-9.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen9.h
    # makeFile {} codegen9.c
    micca configure {
        domain codegen9 {
            class X {}
            association R1 X 0..*--0..1 X
        }
        population codegen9 {
            class X {
                instance x1 R1 {forward x2 backward {x1 x3}}
                instance x2 R1 {forward x3 backward {x1 x2}}
                instance x3 R1 {forward x1 backward {x2 x3}}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1__LINKS} codegen9.c]] == 3}
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc eventParamDeclarations {} {
    variable domain
    set result {}

    set tevents [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        findRelated ~ R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    if {[relation isnotempty $tevents]} {
        append result [comment "Transition Event Parameter Structure\
                Declarations"]
        relation foreach tevent $tevents -ascending Model {
            relation assign $tevent
            relation foreach event $Events {
                relation assign $event
                append result\
                    "struct ${domain}_${Model}_${Event}_EventParams \{\n"
                relation foreach param $Params -ascending Position {
                    relation assign $param DataType Name
                    append result\
                        "    [typeCheck composeDeclaration $DataType $Name] ;\n"
                }
                append result "\} ;\n"
            }
        }
    }

    set pevents [pipe {
        PolymorphicEvent findWhere {$Domain eq $domain} |
        findRelated ~ R81 R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    if {[relation isnotempty $pevents]} {
        append result [comment "Polymorphic Event Parameter Structure\
                Declarations"]
        relation foreach tevent $pevents -ascending Model {
            relation assign $tevent
            relation foreach event $Events {
                relation assign $event
                append result\
                    "struct ${domain}_${Model}_${Event}_PolyEventParams \{\n"
                relation foreach param $Params -ascending Position {
                    relation assign $param DataType Name
                    append result\
                        "    [typeCheck composeDeclaration $DataType $Name] ;\n"
                }
                append result "\} ;\n"
            }
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc stateParamDeclarations {} {
    variable domain
    set result {}

    set stateargs [pipe {
        State findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name State |
        relation join $::micca::ParameterSignature $::micca::Parameter\
                $::micca::Argument |
        relation project ~ Model State Name Position DataType |
        relation group ~ Params Name Position DataType
    }]

    if {[relation isnotempty $stateargs]} {
        append result [comment "State Parameter Structure Declarations"]
        relation foreach statearg $stateargs -ascending {Model State} {
            relation assign $statearg
            append result "struct ${Model}_${State}_StateParams \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-10.0 {
    Generated event parameter structures
} -setup {
    # makeFile {} codegen10.h
    # makeFile {} codegen10.c
    micca configure {
        domain codegen10 {
            typealias MyCount int
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            class super {
                polymorphic e1 f MyCount g {char *}
                polymorphic e2
            }
            class sub1 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            class sub2 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            generalization R1 super sub1 sub2
        }
        population codegen10 {
            class X {
                instance x1 color 30
            }
            class super {
                instance sup1 R1 {sub1 s1}
                instance sup2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R1 sup1
            }
            class sub2 {
                instance s2 R1 sup2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {_EventParams} codegen10.h]] == 3}\
        {[llength [fileutil::grep {_PolyEventParams} codegen10.h]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc operationDeclarations {} {
    variable domain
    set result {}

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Class Operations Forward Declarations"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "static $ReturnDataType ${Class}_$Operation\("

            if {[relation isempty $Parameters]} {
                append result void
            } else {
                append result [join\
                    [relation list $Parameters DataType -ascending Number] {, }]
            }

            append result "\) ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-11.0 {
    Generated code file with class operations
} -setup {
    # makeFile {} codegen11.h
    # makeFile {} codegen11.c
    micca configure {
        domain codegen11 {
            class X {
                attribute color int -default 20

                classop int count {} {
                    return 42 ;
                }

                instop void addColor {amount int} {
                    self->color += amount
                }
            }
        }
        population codegen11 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X_count} codegen11.c]] == 1}\
        {[llength [fileutil::grep {X_addColor} codegen11.c]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc ctorDeclarations {} {
    variable domain
    set result {}

    set ctors [Constructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $ctors]} {
        append result [comment "Class Constructor Forward Declarations"]
        forAllRefs ctor $ctors {
            assignAttribute $ctor {Class className}
            append result\
                "static void ${className}__CTOR\("\
                [GetClassProperty $className Reference]\
                "\) ; \n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc dtorDeclarations {} {
    variable domain
    set result {}

    set dtors [Destructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $dtors]} {
        append result [comment "Class Destructor Forward Declarations"]
        forAllRefs dtor $dtors {
            assignAttribute $dtor {Class className}
            append result\
                "static void ${className}__DTOR\("\
                [GetClassProperty $className Reference]\
                "\) ; \n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc activityDeclarations {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && $Activity ne {}} |
        deRef ~ |
        relation eliminate ~ Domain Activity IsTerminal PSigID |
        relation group ~ States Name
    }]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Forward Declarations"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            relation foreach state $States {
                relation assign $state
                append result "static void ${Model}_${Name}__ACTIVITY\("\
                    "void *const s__, "\
                    "void const *const p__) ;\n"
            }
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc storageDeclarations {} {
    variable domain
    set result {}

    set cpops [pipe {
        FindNonUnionSubclasses $domain |
        findRelated % R104 {~R101 ElementPopulation} {~R105 ClassPopulation}
    } {} |%]

    if {[isNotEmptyRef $cpops]} {
        append result [comment "Class Instance Storage Forward Declarations"]
        forAllRefs cpop $cpops {
            assignAttribute $cpop {Allocation allocation} {Class className}
            set insts [refMultiplicity [findRelated $cpop ~R102]]
            set total [expr {$allocation + $insts}]
            append result "static "\
                [GetClassProperty $className StorageVariable]\
                "\[[GetClassProperty $className TotalInstance]\] ;\n"
        }
    }

    return $result
}
----

Put out all the naming information.

[source,c]
----
<<generation code commands>>=
proc nameDefinitions {} {
    variable domain
    append result\
        [comment "Domain Naming Definitions"]\
        "#ifndef MRT_NO_NAMES\n"

    set storageType "static char const"

    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        set className [readAttribute $classRef Name]
        append result "$storageType ${className}__NAME\[\] = \"$className\" ;\n"
    }

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    forAllRefs relRef $relRefs {
        set relName [readAttribute $relRef Name]
        append result "$storageType ${relName}__NAME\[\] = \"$relName\" ;\n"
    }

    set stateRefs [State findWhere {$Domain eq $domain}]
    forAllRefs stateRef $stateRefs {
        assignAttribute $stateRef {Model modelName} {Name stateName}
        append result "$storageType ${modelName}_${stateName}__SNAME\[\] =\
                \"$stateName\" ;\n"
    }

    set eventRefs [Event findWhere {$Domain eq $domain}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Model modelName} {Event eventName}
        append result "$storageType ${modelName}_${eventName}__ENAME\[\] =\
                \"$eventName\" ;\n"
    }

    append result\
        "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc iabDefinitions {} {
    variable domain
    set result [comment "Instance Allocation Block Definitions"]

    forAllRefs classRef [FindNonUnionSubclasses $domain] {
        append result [DefineIABMembers $classRef false]
    }

    set unionRefs [pipe {
        UnionSubclass findWhere {$Domain eq $domain} |
        findRelated ~ R47 R40 R41
    }]
    forAllRefs classRef $unionRefs {
        append result [DefineIABMembers $classRef true]
    }

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc DefineIABMembers {classRef isUnionSubclass} {
    assignAttribute $classRef {Name className}

    set linkMembers [GetClassProperty $className LinkMembers]
    set linkCount [llength $linkMembers]
    if {$linkCount == 0} {
        set linkOffsets NULL
    } else {
        set linkOffsets ${className}__LINKS
        append result\
            "static MRT_AttrOffset const $linkOffsets\[\] = \{\n"
        foreach linkMember $linkMembers {
            append result\
                "    "\
                "offsetof\([GetClassProperty $className Declaration],\
                $linkMember\),\n"
        }
        append result "\} ;\n"
    }

    append result\
        "static MRT_iab ${className}__IAB = \{\n"

    if {$isUnionSubclass} {
        append result\
            "    .storageStart = NULL,\n"\
            "    .storageFinish = NULL,\n"\
            "    .storageLast = NULL,\n"
    } else {
        set nelements [GetClassProperty $className TotalInstance]
        append result\
            "    .storageStart = &${className}__POOL\[0\],\n"\
            "    .storageFinish = &${className}__POOL\[$nelements\],\n"\
            "    .storageLast = &${className}__POOL\[[expr {$nelements - 1}]\],\n"
    }
    set ctor [pipe {
        findRelated $classRef ~R8 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__CTOR"}
    } {} |%]
    set dtor [pipe {
        findRelated $classRef ~R9 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__DTOR"}
    } {} |%]
    append result\
        "    .alloc = [expr {[GetClassProperty $className InitialInstance]\
                    + 1}],\n"\
        "    .instanceSize = sizeof\([GetClassProperty $className Declaration]\),\n"\
        "    .construct = $ctor,\n"\
        "    .destruct = $dtor,\n"\
        "    .linkCount = $linkCount,\n"\
        "    .linkOffsets = $linkOffsets\n"\
        "\} ;\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc edbDefinitions {} {
    variable domain
    set result [comment "Event Dispatch Block Definitions"]

    upvar #0 ::micca::@Gen@::options options

    forAllRefs smodel [StateModel findWhere {$Domain eq $domain}] {
        assignAttribute $smodel {Model className}

        append result [GenerateTransitionTable $smodel]
        append result [GenerateActivityTable $smodel]
        set termstates [GenerateTerminalStates $smodel result]

        append result [GenerateModelNames $smodel]

        append result "static MRT_edb const ${className}__EDB = \{\n"

        set stateRefs [findRelated $smodel ~R55]
        set cstateRef [findRelated $smodel ~R56]
        append result\
            "    .stateCount = [expr {[refMultiplicity $stateRefs] +\
                [refMultiplicity $cstateRef]}],\n"

        set eventRefs [findRelated $smodel ~R87]
        append result\
            "    .eventCount = [refMultiplicity $eventRefs],\n"\
            "    .initialState = [readAttribute [findRelated $smodel R58 R57]\
                        Number],\n"
        set crstate [expr {[isNotEmptyRef $cstateRef] ?\
            [readAttribute [findRelated R57] Number] : "MRT_StateCode_IG"}]
        append result\
            "    .creationState = $crstate,\n"\
            "    .transitionTable = ${className}__TTAB,\n"\
            "    .activityTable = ${className}__ATAB,\n"\
            "    .terminalStates = $termstates,\n"

        append result\
            "#        ifndef MRT_NO_NAMES\n"\
            "    .stateNames = ${className}__SNAMES,\n"\
            "    .eventNames = ${className}__ENAMES,\n"\
            "#        endif /* MRT_NO_NAMES */\n"

        append result\
            "\} ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateTransitionTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        findRelated $smodel ~R55 |
        deRef % |
        relation rename % Name State |
        relation eliminate % Activity IsTerminal PSigID
    } {} |%]
    set cstate [pipe {
        findRelated $smodel ~R56 |
        deRef % |
        relation rename % Name State
    } {} |%]
    set states [relation union $states $cstate]
    # puts [relformat $states states]

    set events [pipe {
        findRelated $smodel ~R87 |
        deRef %
    } {} |%]
    # puts [relformat $events events]

    set alltrans [pipe {
        relation eliminate $events Number |
        relation join $states ~
    }]
    # puts [relformat $alltrans alltrans]

    set statetrans [pipe {
        StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation eliminate ~ ASigID
    }]
    # puts [relformat $statetrans statetrans]
    set nontrans [pipe {
        Non-StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ TransRule NewState
    }]
    # puts [relformat $nontrans nontrans]

    set deftrans [pipe {
        TransitionPlace findAll |
        deRef ~ |
        relation minus $alltrans ~ |
        relation join ~ [deRef [StateModel findAll]] |
        relation eliminate ~ InitialState |
        relation rename ~ DefaultTrans NewState |
        relation update ~ dttup {[tuple extract $dttup State] eq "@"} {
                tuple update $dttup NewState CH}
    }]
    # puts [relformat $deftrans deftrans]

    set ntstates [pipe {
        TransitionRule findAll |
        deRef ~ |
        relation rename ~ Name State |
        relation extend ~ nttup\
            Domain string {$domain}\
            Model string {$className}\
            StateNumber string {"MRT_StateCode_[tuple extract $nttup State]"}
    }]
    # puts [relformat $ntstates ntstates]

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ Name State Number StateNumber |
        relation union ~ $ntstates
    }]
    # puts [relformat $places places]
    set transitions [pipe {
        relation union $statetrans $nontrans $deftrans |
        relation join ~ $places\
            -using {Domain Domain Model Model NewState State} |
        relation rename ~ StateNumber NewStateNumber |
        relation join ~ $places $events |
        relation eliminate ~ Domain Model
    }]
    # puts [relformat $transitions transitions]

    set result "static MRT_StateCode const ${className}__TTAB\[\] = \{\n"
    relation foreach transition $transitions -ascending {StateNumber Number} {
        relation assign $transition
        append result "    $NewStateNumber, // $State - $Event -> $NewState\n"
    }
    append result "\} ;\n"

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-12.0 {
    Generated code file with state model
} -setup {
    # makeFile {} codegen12.h
    # makeFile {} codegen12.c
    micca configure {
        domain codegen12 {
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {} {
                        printf("In s1\n") ;
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                    }
                    transition s2 - e1 -> IG
                    transition s2 - e2 -> s3

                    state s3 {} {
                    }
                    transition s3 - e3 -> s1

                    terminal s3
                }
            }
        }
        population codegen12 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X__TTAB} codegen12.c]] == 2}\
        {[llength [fileutil::grep {X__ATAB} codegen12.c]] == 2}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc GenerateActivityTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set result "static PtrActivityFunction const ${className}__ATAB\[\] = \{\n"

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name Activity
            if {$Activity eq {}} {
                append result "    NULL, // $Name\n"
            } else {
                append result "    ${className}_${Name}__ACTIVITY, // $Name\n"
            }
        } else {
            set cstate [relation semijoin $place $::Micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    NULL, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateTerminalStates {smodel resultVar} {
    set tstates [findRelatedWhere $smodel ~R55 {$IsTerminal}]
    if {[isEmptyRef $tstates]} {
        return NULL
    }
    upvar 1 $resultVar result
    variable domain
    assignAttribute $smodel {Model className}
    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static bool const ${className}__TSTATES\[\] = \{\n"
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name IsTerminal
            append result "    "\
                [expr {$IsTerminal ? "true" : "false"}]\
                ", // $Name\n"
        } else {
            set cstate [relation semijoin $place $::Micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    false, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
    return ${className}__TSTATES
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateModelNames {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result\
        "#ifndef MRT_NO_NAMES\n"\
        "static char const * const ${className}__SNAMES\[\] = \{\n"

    relation foreach state $states -ascending Number {
        relation assign $state Name
        append result "    ${className}_${Name}__SNAME,\n"
    }
    append result "\} ;\n"

    set events [pipe {
        TransitioningEvent findWhere\
                {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static char const * const ${className}__ENAMES\[\] = \{\n"
    relation foreach event $events -ascending Number {
        relation assign $event Event
        append result "    ${className}_${Event}__ENAME,\n"
    }
    append result\
        "\} ;\n"\
        "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc pdbDefinitions {} {
    variable domain

    set subnames {}
    set enames {}
    set rnames {}
    set pmaps {}
    set gdbs {}
    set pdbs {}

    set superRefs [pipe {
        DeferredEvent findWhere {$Domain eq $domain} |
        findRelated % ~R86
    } {} |%]
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs {~R46 ReferencedSuperclass}\
        R36 ~R37 R47]
    if {[isNotEmptyRef $subRefs]} {
        set supertype mrtPolyReference
    } else {
        set subRefs [findRelated $superRefs {~R46 UnionSuperclass}\
               R44 ~R45 R47]
        set supertype mrtPolyUnion
    }

    set deferred [pipe {
        findRelated $superRefs {R86 DeferralPath} |
        deRef ~ |
        relation join ~ $::micca::DeferredEvent |
        relation eliminate ~ Domain Role |
        relation extend ~ gtup SuperType string {$supertype} |
        relation rename ~ Model Superclass Number SuperNumber
    }]
    # puts [relformat $deferred deferred]

    set nonlocals [deRef [findRelated $subRefs ~R85]]
    set polys [pipe {
        relation join $nonlocals $::micca::DeferredEvent |
        relation extend ~ ptup Type string {"mrtPolymorphicEvent"}
    }]
    # puts [relformat $polys polys]

    set trans [pipe {
        relation join $nonlocals $::micca::TransitioningEvent |
        relation extend ~ ptup Type string {"mrtTransitionEvent"}
    }]
    # puts [relformat $trans trans]

    set supers [pipe {
        relation union $polys $trans |
        relation eliminate ~ Domain Role |
        relation join ~ $deferred |
        relation group ~ EventMap Event SuperNumber Number Type |
        relation group ~ SubMap Model EventMap |
        relation group ~ Generalizations Relationship SuperType SubMap
    }]
    # puts [relformat $supers supers]

    relation foreach super $supers {
        relation assign $super

        set gdbvar ${Superclass}__GDB
        append gdbs "static MRT_gdb $gdbvar\[\] = \{\n"

        set rnamesvar ${Superclass}__RNAMES
        append rnames "static char const *const $rnamesvar\[\] = \{\n"

        relation foreach gen $Generalizations -ascending Relationship {
            relation assign $gen

            append rnames "    ${Relationship}__NAME,\n"

            set pmapvar ${Superclass}_${Relationship}__PMAP
            append pmaps "static MRT_PolyEventMap const $pmapvar\[\] = \{\n"

            set subnamesvar ${Superclass}_${Relationship}__SUBNAMES
            append subnames\
                "static char const *const $subnamesvar\[\] = \{\n"

            relation foreach submap $SubMap -ascending Model {
                relation assign $submap
                append subnames "    ${Model}__NAME, \n"
                relation foreach eventmap $EventMap {
                    relation assign $eventmap
                    append pmaps\
                        "    "\
                        "\{.event = $Number, .eventType = $Type\},"\
                        "// $Event for $Model\n"
                }
            }
            append pmaps "\} ;\n"
            append subnames "\} ;\n"

            append gdbs\
                "    \{\n"\
                "        .refStorage = $SuperType,\n"\
                "        .subCodeOffset =\
                    offsetof([GetClassProperty $Superclass Declaration],\
                    $Relationship.subCode),\n"\
                "        .subInstOffset =\
                    offsetof([GetClassProperty $Superclass Declaration],\
                    $Relationship.subInst),\n"\
                "        .subclassCount = [relation cardinality $SubMap],\n"\
                "        .eventMap = $pmapvar,\n"\
                "#            ifndef MRT_NO_NAMES\n"\
                "        .subclassNames = $subnamesvar,\n"\
                "#            endif /* MRT_NO_NAMES */\n"\
                "    \},\n"
        }
        append rnames "\} ;\n"
        append gdbs "\} ;\n"

        set enamesvar ${Superclass}__PENAMES
        append enames "static char const *const $enamesvar\[\] = \{\n"
        relation foreach eventmap $EventMap {
            relation assign $eventmap Event
            append enames "    ${Superclass}_${Event}__ENAME,\n"
        }
        append enames "\} ;\n"

        append pdbs\
            "static MRT_pdb const ${Superclass}__PDB = \{\n"\
            "    .eventCount = [relation cardinality $SubMap],\n"\
            "    .genCount = [relation cardinality $Generalizations],\n"\
            "    .genDispatch = $gdbvar,\n"\
            "#        ifndef MRT_NO_NAMES\n"\
            "    .eventNames = $enamesvar,\n"\
            "    .genNames = $rnamesvar,\n"\
            "#        endif /* MRT_NO_NAMES */\n"\
            "\} ;\n"
    }


    append result\
        [comment "Polymorphic Event Dispatch Block Definitions"]\
        "#ifndef MRT_NO_NAMES\n"\
        $subnames $enames $rnames\
        "#endif /* MRT_NO_NAMES */\n"\
        $pmaps $gdbs $pdbs

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-13.0 {
    polymorphic events -- inject polymorphic event mid-level
} -setup {
    # makeFile {} codegen13.h
    # makeFile {} codegen13.c
    micca configure {
        domain codegen13 {
            class S {
                polymorphic e1
                polymorphic e2
                polymorphic a1
            }
            class X {
                polymorphic a3
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    transition s1 - a1 ->  s1
                }
            }
            class Y {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - a1 -> s1
                }
            }
            generalization R1 -union S X Y

            class F {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - f1 -> s1
                    transition s2 - a1 -> s2
                }
            }
            class G {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - g1 -> s1
                    transition s2 - a1 -> s2
                }
            }

            generalization R3 -union S F G

            class A {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            class B {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            generalization R2 -union X A B
        }
        population codegen13 {
            class S {
                instance s1 R1 {X x1} R3 {F f1}
                instance s2 R1 {Y y1} R3 {F f2}
                instance s3 R1 {X x2} R3 {G g1}
            }
            class X {
                instance x1 R2 {A a1}
                instance x2 R2 {B b1}
            }
            class Y {
                instance y1
            }
            class A {
                instance a1
            }
            class B {
                instance b1
            }
            class F {
                instance f1
                instance f2
            }
            class G {
                instance g1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {}
----

[source,c]
----
<<generation code commands>>=
proc classDefinitions {} {
    variable domain
    set front [comment "Class Description Definitions"]

    append front "static MRT_Relationship const\
            ${domain}__RSHIPS\[\] ; // forward reference\n"

    set classRefs [Class findWhere {$Domain eq $domain}]

    set rels [pipe {
        findRelated $classRefs {~R41 ClassRole} |
        deRef % |
        relation eliminate % Role |
        relation semiminus $::micca::StaticAssociation %\
            -using {Domain Domain Association Relationship} |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number RelNumber
    } {} |%]
    # puts [relformat $rels rels]

    set attrs [pipe {
        findRelated $classRefs ~R20 {~R21 Attribute} |
        deRef % |
        relation rename % Name Attribute Class Name
    } {} |%]
    # puts [relformat $attrs attrs]

    set usubs [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 Subclass}\
            {~R47 UnionSubclass} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number SuperNumber |
        relation eliminate % Role Relationship
    } {} |%]
    # puts [relformat $usubs usubs]

    set classes [pipe {
        deRef $classRefs |
        relation extend ~ ctup IAB string {"&[tuple extract $ctup Name]__IAB"} |
        ralutil::rvajoin ~\
            [relation rename $::micca::StateModel Model Name] SModel |
        relation extend ~ etup EDB string {
            [relation cardinality [tuple extract $etup SModel]] == 0 ?\
            "NULL" : "&[tuple extract $etup Name]__EDB"} |
        ralutil::rvajoin ~\
            [relation rename $::micca::DeferredEvent Model Name] PEvents |
        relation extend ~ ptup PDB string {
            [relation cardinality [tuple extract $ptup PEvents]] == 0 ?\
            "NULL" : "&[tuple extract $ptup Name]__PDB"} |
        relation eliminate ~ SModel PEvents |
        ralutil::rvajoin ~ $rels Relationships |
        relation extend ~ rtup\
            relCount int {
                [relation cardinality [tuple extract $rtup Relationships]]}\
            classRels string {
                [relation cardinality [tuple extract $rtup Relationships]] == 0 ?\
                "NULL" : "[tuple extract $rtup Name]__CRELS"} |
        ralutil::rvajoin ~ $attrs Attributes |
        relation extend ~ atup\
            attrCount int {
                [relation cardinality [tuple extract $atup Attributes]]}\
            classAttrs string {
                [relation cardinality [tuple extract $atup Attributes]] == 0 ?\
                "NULL" : "[tuple extract $atup Name]__CATTRS"} |
        ralutil::rvajoin ~ $usubs UnionSubs |
        relation extend ~ utup\
            containment string {
                [relation cardinality [tuple extract $utup UnionSubs]] == 0 ?\
                "NULL" :\
                "&${domain}__RSHIPS\[[relation extract\
                    [tuple extract $utup UnionSubs]\
                    SuperNumber]\].relInfo.unionGeneralization.superclass"} |
        relation eliminate ~ Domain

    }]
    # puts [relformat $classes classes]

    append result "static MRT_Class const\
            ${domain}__CLASSES\[[relation cardinality $classes]\] = \{\n"

    set relrefs {}
    set attrrefs {}
    relation foreach class $classes {
        relation assign $class

        if {[relation isnotempty $Relationships]} {
            append relrefs\
                "static MRT_Relationship const *const\
                    ${Name}__CRELS\[\] = \{\n"

            relation foreach rel $Relationships {
                relation assign $rel
                append relrefs\
                    "    &${domain}__RSHIPS\[$RelNumber\], // $Relationship\n"
            }

            append relrefs "\} ;\n"
        }

        if {[relation isnotempty $Attributes]} {
            append attrrefs\
                "static MRT_Attribute const ${Name}__CATTRS\[\] = \{\n"

            relation foreach attr $Attributes -ascending Attribute {
                relation assign $attr
                set offset "offsetof([GetClassProperty $Name Declaration],\
                        $Attribute)"
                append attrrefs\
                    "    \{\n"\
                    "        .offset = $offset,\n"\
                    "        .size = sizeof($DataType),\n"\
                    "#           ifndef MRT_NO_NAMES\n"\
                    "        .name = \"$Attribute\"\n"\
                    "#           endif /* MRT_NO_NAMES */\n"\
                    "    \},\n"
            }

            append attrrefs "\} ;\n"
        }

        append result\
            "    \[$Number\] = \{\n"\
            "        .iab = $IAB,\n"\
            "        .edb = $EDB,\n"\
            "        .pdb = $PDB,\n"\
            "        .relCount = $relCount,\n"\
            "        .classRels = $classRels,\n"\
            "        .attrCount = $attrCount,\n"\
            "        .classAttrs = $classAttrs,\n"\
            "        .instCount = [GetClassProperty $Name TotalInstance],\n"\
            "        .containment = $containment,\n"\
            "#           ifndef MRT_NO_NAMES\n"\
            "        .name = ${Name}__NAME\n"\
            "#           endif /* MRT_NO_NAMES */\n"\
            "    \},\n"
    }

    append result "\} ;\n"

    return [string cat $front $relrefs $attrrefs $result]
}
----

----
<<generation code commands>>=
proc relationshipDefinitions {} {
    variable domain
    set subroles {}

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    if {[isEmptyRef $relRefs]} {
        return
    }
    append result "static MRT_Relationship const\
        ${domain}__RSHIPS\[[refMultiplicity $relRefs]\] = \{\n"

    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    forAllRefs relRef $relRefs {
        assignAttribute $relRef {Name relName} Number
        append result "$indent\[$Number\] = \{ // $relName\n"

        # Simple Association
        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 SimpleAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set static [StaticAssociation findWhere\
                {$Domain eq $domain && $Association eq $relName}]

            set sourceRef [findRelated $typeRef ~R32]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R38 R40 R41] Number]

            set targetRef [findRelated $typeRef ~R33]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set tMult false
            set stype mrtSingular
            set slink 0

            set tlink 0
            if {!$sMult} {
                set ttype mrtSingular
            } else {
                if {[isNotEmptyRef $static]} {
                    set ttype mrtArray
                } else {
                    set ttype mrtLinkedList
                    set tlink "offsetof([GetClassProperty $sClass Declaration],\
                            ${relName}__LINKS)"
                }
            }

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    $relName"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    $relName"
            if {$sClass eq $tClass} {
                append sstore .forward
                append tstore .backward
            }
            append sstore "\)"
            append tstore "\)"

            append result\
                "$indent2.relType = mrtSimpleAssoc,\n"\
                "$indent2.relInfo.simpleAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\}\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 ClassBasedAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set static [StaticAssociation findWhere\
                {$Domain eq $domain && $Association eq $relName}]

            set sourceRef [findRelated $typeRef ~R34]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R38 R40 R41] Number]

            set targetRef [findRelated $typeRef ~R35]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}\
                {Multiplicity tMult}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set asstorRef [findRelated $typeRef ~R42]
            assignAttribute $asstorRef {Class aClass}
            set aNum [readAttribute [findRelated $asstorRef R40 R41] Number]

            set slink 0
            if {!$tMult} {
                set stype mrtSingular
            } else {
                if {[isNotEmptyRef $static]} {
                    set stype mrtArray
                } else {
                    set stype mrtLinkedList
                    set slink "offsetof([GetClassProperty $aClass Declaration],\
                            ${relName}__FORW)"
                }
            }

            set tlink 0
            if {!$sMult} {
                set ttype mrtSingular
            } else {
                if {[isNotEmptyRef $static]} {
                    set ttype mrtArray
                } else {
                    set ttype mrtLinkedList
                    set tlink "offsetof([GetClassProperty $aClass Declaration],\
                            ${relName}__BACK)"
                }
            }

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    $relName"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    $relName"
            if {$sClass eq $tClass} {
                append sstore .forward
                append tstore .backward
            }
            append sstore "\)"
            append tstore "\)"


            append result\
                "$indent2.relType = mrtClassAssoc,\n"\
                "$indent2.relInfo.classAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink,\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\},\n"

            set aClassDecl [GetClassProperty $aClass Declaration]
            set aClassForw "offsetof($aClassDecl, ${relName}.forward)"
            set aClassBack "offsetof($aClassDecl, ${relName}.backward)"
            append result\
                "$indent3.associator = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$aNum\], // $aClass\n"\
                "$indent4.forwardOffset = $aClassForw,\n"\
                "$indent4.backwardOffset = $aClassBack,\n"\
                "$indent3\}\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 ReferenceGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R36]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R46 R40 R41] Number]

            set subRefs [findRelated $typeRef ~R37]
            set subClasses [findRelated $subRefs R47 R40 R41]

            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation tag ~ subCode -ascending Class |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"}\
                    storageOffset string {
                        "offsetof([GetClassProperty\
                            [tuple extract $stup Class] Declaration],\
                            $relName)"} |
                relation project ~ subCode classDesc storageOffset
            }]

            append subroles "static struct mrtrefsubclassrole const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs {
                relation assign $sub
                append subroles\
                    "    \{\n"\
                    "        .classDesc = $classDesc,\n"\
                    "        .storageOffset = $storageOffset,\n"\
                    "        .subCode = $subCode\n"\
                    "    \},\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtRefGeneralization,\n"\
                "$indent2.relInfo.refGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 UnionGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R44]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R46 R40 R41] Number]
            set subRefs [findRelated $typeRef ~R45]
            set subClasses [findRelated $subRefs R47 R40 R41]
            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation tag ~ subCode -ascending Class |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"} |
                relation project ~ subCode classDesc
            }]

            append subroles "static struct mrtunionsubclassrole const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs {
                relation assign $sub
                append subroles\
                    "    \{\n"\
                    "        .classDesc = $classDesc\n"\
                    "        .subCode = $subCode\n"\
                    "    \},\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtUnionGeneralization,\n"\
                "$indent2.relInfo.unionGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.subCodeOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName.subCode),\n"\
                "$indent4.subInstOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName.subInst)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }
    }

    append result "\} ;\n"

    return [string cat\
        [comment "Relationship Description Definitions"]\
        $subroles\
        $result\
    ]
}
----

[source,c]
----
<<generation code commands>>=
proc MapToCardinality {cond mult} {
    if {$cond && !$mult} {
        return mrtAtMostOne
    } elseif {!$cond && !$mult} {
        return mrtExactlyOne
    } elseif {$cond && $mult} {
        return mrtZeroOrMore
    } elseif {!$cond && $mult} {
        return mrtOneOrMore
    }
}
----

== Helper Commands

[source,c]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,c]
----
<<generation helper commands>>=
proc banner {} {
    string cat\
        "/*\n"\
        " * [string repeat - 70]\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * [string repeat - 70]\n"\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc comment {args} {
    set result "/*\n"

    foreach c $args {
        append result\
            [::textutil::adjust::indent [::textutil::adjust::adjust $c] " * "]\n
    }

    append result " */\n"

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
# Remove extraneous blanks from the beginning of lines of code
# if so requested by the options.
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

== Interfacing Domain Code to the Run Time

Interfacing Domain Code to the Run Time
