// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain implementation.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time provides functions to map model level actions
onto the target platform.

The remaining component is to generate ``C'' code for a domain.
Code generation consist of two major pieces:

* Generating initialized ``C'' variables that supply the data values
required by the run time.
* Generating the ``C'' code for model level operations in
state activities and domain operations.
This facilitates interfacing to the run time code.

`Micca` does not compile an action language into the target ``C'' for
state activities.
Rather,
it passes along the ``C'' code provided for the activities wrapped up
as functions.
However,
to insulate the user supplied ``C'' code from the details of
the run time function interfaces and the data structures used,
`micca` performs an additional level of macro expansion on the
state activities and operations code.
Thus the supplied ``C'' code for activities contains embedded macros
and these are expanded to support interfacing to the run time and performing
other model level activities.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,tcl]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,tcl]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation support namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

=== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
Generally,
one is required to declare symbols before they are defined.
The ordering has to be quite precise.
One way to accomplish this is to use a template.
The template is orgainized in the order required by the compiler
and contains embedded commands.
When expanded,
the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from `tcllib`.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,tcl]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

Because we are using a template expansion technique to generate the code
files,
the implementation of code generation has the flavor of a report generator.
Commands imbedded in the template make queries on the populated
platform model and emit a _report_ of the query, which in this case
is a set of ``C'' language statements.
Although the reports generated are intended to be consumed by a compiler
rather than a human,
the design of the generator is very similar to generating reports
from a database.
In this case the database is the platform model as populated by
a configuration script and the reports are ``C'' code placed in files
and intended to be processed later by a compiler.

(((micca,Gen,miccaGenerate)))
[source,tcl]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: generate files>>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return $genfiles
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation error(s)}
----

We set up options for the generation in a dictionary.
The default values are given and can be overridden by those passed in.

[source,tcl]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror     fail\
    stubexternalops false\
]
set options [dict merge $options $arglist]
----

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,tcl]
----
<<miccaGenerate: verify domains are populated>>=
set badpops [pipe {
    Population findAll |
    findUnrelated ~ R100
}]

forAllRefs badpop $badpops {
    set domainName [readAttribute $badpop Name]
    log::error "for domain, \"$domainName\", no population is given"
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

The `expander` package creates a command that, when invoked with a
template, performs the expansion.
Here we set up that command and specify some options to it.

[source,tcl]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand errmode [dict get $options expanderror]
----

Generating the files happens by iterating over all the domains and
generating a header file and a code file for each one.

[source,tcl]
----
<<miccaGenerate: generate files>>=
set genfiles [list]
try {
    forAllRefs domainRef [Domain findAll] {
        assignAttribute $domainRef {Name domain} {Interface interface}\
            {Prologue prologue} {Epilogue epilogue}

        GatherDomainProperties $domain

        lappend genfiles $domain.h
        <<miccaGenerate: generate header file>>
        lappend genfiles $domain.c
        <<miccaGenerate: generate code file>>
    }
} finally {
    rename expand {} ; # <1>
}
----
<1> The template expander creates a new command and we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

To generate the header file,
we set up some variable in the namespace where the template
expansion occurs.
These variables define the domain context for the header generation.
We perform the expansion in the `GenHeader` namespace so that the
command embedded in the template resolve without qualification and
we don't have any name conflicts between those commands and other
code generation commands.

[source,tcl]
----
<<miccaGenerate: generate header file>>=
set GenHeader::domain $domain
set GenHeader::interface $interface
set GenSupport::domain $domain

expand evalcmd "namespace eval [namespace current]::GenHeader"
set hchan [::open $domain.h w]
try {
    variable headerTemplate
    puts $hchan [expand expand $headerTemplate]
} on error {result opts} {
    # puts $::errorInfo
    return -options $opts $result
} finally {
    chan close $hchan
}
----

Generating the code files is done in a similar manner.
In this case,
we perform the generation in the `GenCode` namespace.

[source,tcl]
----
<<miccaGenerate: generate code file>>=
set GenCode::domain $domain
set GenCode::prologue $prologue
set GenCode::epilogue $epilogue

CreateActivityCommands $domain

expand evalcmd "namespace eval [namespace current]::GenCode"
set cchan [::open $domain.c w]
try {
    variable codeTemplate
    puts $cchan [expand expand $codeTemplate]
} on error {result opts} {
    # puts $::errorInfo
    return -options $opts $result
} finally {
    chan close $cchan
    namespace delete GenActivity
}
----

=== Common Domain Queries

There are a number of queries about the properties of domains that
common and frequent enough to warrant factoring the queries into a
more convenient form.

We start by accumulating some common properties of a domain.
We will store these properties in a relation value that are held in
an ordinary namespace variables

(((micca,Helpers,GatherDomainProperties)))
[source,tcl]
----
<<generation helper commands>>=
proc GatherDomainProperties {domain} {
    variable ClassProperties

    set assigners [pipe {
        AssignerStateModel findWhere {$Domain eq $domain} |
        deRef ~ |
        ralutil::rvajoin ~ $::micca::SingleAssigner Single |
        ralutil::rvajoin ~ $::micca::MultipleAssigner Multiple |
        relation tag ~ Number -ascending Association |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Association]"}\
            Reference string {"struct [tuple extract $stup Association] *"}\
            StorageVariable string {"[tuple extract $stup Association]__POOL"}
    }]

    set sassigners [pipe {
        relation restrictwith $assigners {[relation isnotempty $Single]} |
        relation eliminate ~ Domain Single Multiple |
        relation rename ~ Association Name |
        relation extend ~ stup\
            Allocation int {0}\
            InitialInstance int {1}\
            TotalInstance int {1}
    }]
    # puts [relformat $sassigners sassigners]

    set massigners [pipe {
        relation restrictwith $assigners {[relation isnotempty $Multiple]} |
        relation rename ~ Number AssignerNumber |
        ralutil::rvajoin ~ $::micca::MultipleAssignerInstance Instances |
        relation ungroup ~ Multiple |
        relation join ~ $::micca::ClassPopulation |
        relation extend ~ stup\
            InitialInstance int\
                {[relation cardinality [tuple extract $stup Instances]]}\
            TotalInstance int {[tuple extract $stup Allocation]} |
        relation eliminate ~ Domain Single Class Instances |
        relation rename ~ Association Name AssignerNumber Number
    }]
    # puts [relformat $massigners massigners]

    set classRefs [Class findWhere {$Domain eq $domain}]
    set allocs [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} |
        deRef % |
        relation project % Class Allocation |
        relation rename % Class Name
    } {} |%]

    set insts [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation project % Class Number |
        relation rename % Class Name
    } {} |%]

    set ClassProperties [pipe {
        deRef $classRefs |
        relation project ~ Name Number |
        relation rename ~ Number ClassNumber |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            StorageVariable string {"[tuple extract $stup Name]__POOL"} |
        ralutil::rvajoin ~ $allocs Allocations |
        relation extend ~ atup Allocation int {
            [relation isempty [tuple extract $atup Allocations]] ?\
            0 : [relation extract [tuple extract $atup Allocations] Allocation]
        } |
        relation eliminate ~ Allocations |
        ralutil::rvajoin ~ $insts Instances |
        relation extend ~ itup\
            InitialInstance int {
                [relation cardinality [tuple extract $itup Instances]]} \
            TotalInstance int {
                [relation cardinality [tuple extract $itup Instances]] +
                [tuple extract $itup Allocation]} |
        relation eliminate ~ Instances |
        relation rename ~ ClassNumber Number |
        relation union ~ $sassigners $massigners
    }]
    # puts [relformat $ClassProperties ClassProperties]

    return
}
----

We need some procedures to access the properties.

(((micca,Helpers,GetClassProperty)))
[source,tcl]
----
<<generation helper commands>>=
proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}
----

The class descriptor array element for a given class is commonly needed.

(((micca,Helpers,GetClassDescriptor)))
[source,tcl]
----
<<generation helper commands>>=
proc GetClassDescriptor {domain className} {
    return ${domain}__CLASSES\[[GetClassProperty $className Number]\]
}
----

== Header Files

The header file generated for a domain contains interfacing information.
The header file is included in the generated ``C'' code file and,
typically, is included by bridge code that is
mapping the dependencies of one domain onto another.

Following our usual pattern,
we will execute the header generation commands from the template in
a child namespace to avoid any name conflicts.

The `GenHeader` namespace is a child of `::micca::@Gen@` and follows
our usual pattern of imports, command path and contents.

[source,tcl]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

The template for the header file is shown below.
Each embedded command is then shown in the following sections.

[source,tcl]
----
<<generation data>>=
set headerTemplate [textutil::adjust::undent {
    [banner]
    #ifndef [headerFileGuard]
    #define [headerFileGuard]
    #include "micca_rt.h"
    [interface]
    [interfaceTypeAliases]
    [domainOpDeclarations]
    [externalOpDeclarations]
    [eventParamDeclarations]
    [portalIds]
    [portalDeclaration]
    #endif /* [headerFileGuard] */
}]
----

The generation of the header files is accomplished by iterating
over all the domains and placing the output of the template
expansion into a file.
We use some variables to provide context to the embedded expansion commands.

The commands embedded in the template all follow a similar pattern.
The return values of the commands are placed in the output of the
template expansion.

=== Header File Guard

The generated header file includes definitions of preprocessor symbols
to prevent the header file from being included multiple times.

(((micca,Header Generation,headerFileGuard)))
[source,tcl]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return [string toupper [string trim $domain]]_H_
}
----

=== Domain Interface

Arbitrary code may be placed in the generated header file by
invoking the `interface` command as part of the domain configuration.
The text provided during configuration is simply passed into the
generated header file.

(((micca,Header Generation,interface)))
[source,tcl]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    return [string cat\
        [comment "Domain Interface Contents"]\
        [textutil::adjust::undent [string trim $interface \n]]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    validateutils genMiccaFile header1 {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils matchLines header1.h {
        #include <stdio.h>
    }
} -result {1}
----
endif::showtests[]

=== Type Aliases

The domain configuration can contain type aliases.
Normally,
the type alias information is placed in the generated code file.
However, if a type alias name is used in a context where it would be
exposed outside of the domain,
_e.g._ as a parameter to a domain operation,
then the type alias definition is placed in the generated header file.
There are three circumstances where a type is needed external to the domain:

. As the return type or parameter type of a domain operation.
. As the return type or parameter type of an external operation.
. As an argument to an event (since events can be signaled by the
portal operations).

We will have need to compute the type aliases needed by the interface
more than once, so we factor the code into a procedure.

(((micca,Helpers,FindInterfaceTypeAliases)))
[source,tcl]
----
<<generation helper commands>>=
proc FindInterfaceTypeAliases {domain} {
    set domRef [Domain findWhere {$Name eq $domain}]

    <<FindInterfaceTypeAliases:: find type alias names>>
    <<FindInterfaceTypeAliases:: find aliases in domain operations>>
    <<FindInterfaceTypeAliases:: find aliases in external operations>>
    <<FindInterfaceTypeAliases:: find aliases in events>>
    <<FindInterfaceTypeAliases:: union the combination>>

    return $aliasRefs
}
----

We compute a list of all the type alias names.
This is used below in the queries for the various types
of parameters types to determine if they are indeed one of the
type aliases.

[source,tcl]
----
<<FindInterfaceTypeAliases:: find type alias names>>=
set aliasNames [pipe {
    findRelated $domRef ~R7 |
    deRef % |
    relation list % TypeName
} {} |%]
----

Query the return types and parameters of the domain operations.

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in domain operations>>=
set doRefs [pipe {
    findRelatedWhere $domRef ~R5 {$ReturnDataType in $aliasNames} |
    findRelated % R5 ~R7
} {} |%]
set dopRefs [pipe {
    findRelatedWhere $domRef {~R5 ~R6} {$DataType in $aliasNames} |
    findRelated % R6 R5 ~R7
} {} |%]
----

The same type of query is needed for the external operations.

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in external operations>>=
set eoRefs [pipe {
    findRelatedWhere $domRef ~R10 {$ReturnDataType in $aliasNames} |
    findRelated % R10 ~R7
} {} |%]
set eopRefs [pipe {
    findRelatedWhere $domRef {~R10 ~R11} {$DataType in $aliasNames} |
    findRelated % R11 R10 ~R7
} {} |%]
----

And finally, we examine the event parameters.

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in events>>=
set argRefs [pipe {
    Argument findWhere {$Domain eq $domain && $DataType in $aliasNames} |
    deRef ~ |
    relation semijoin ~ $::micca::TypeAlias\
            -using {Domain Domain DataType TypeName} |
    ::rosea::Helpers::ToRef ::micca::TypeAlias ~
}]
----

The union of these sets is then the set of type aliases that will need
to be made available outside of the domain.

[source,tcl]
----
<<FindInterfaceTypeAliases:: union the combination>>=
set aliasRefs [refUnion $doRefs $dopRefs]
set aliasRefs [refUnion $aliasRefs $eoRefs]
set aliasRefs [refUnion $aliasRefs $eopRefs]
set aliasRefs [refUnion $aliasRefs $argRefs]
----

The implementation of the `interfaceTypeAliases` iterates over the
type aliases that are used in the domain interfaces and emits the
corresponding ``C'' `typedef` statement.

(((micca,Header Generation,interfaceTypeAliases)))
[source,tcl]
----
<<generation header commands>>=
proc interfaceTypeAliases {} {
    variable domain
    append result [comment "Type Aliases"]
    forAllRefs taRef [FindInterfaceTypeAliases $domain] {
        assignAttribute $taRef TypeName TypeDefinition
        append result\
            "typedef "\
            [typeCheck composeDeclaration $TypeDefinition $TypeName]\
            " \;\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    validateutils genMiccaFile header2 {
        domain header2 {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    testConditions\
        {[validateutils matchLines header2.h {
            typedef uint32_t pCount ;
        }]}\
        {[validateutils matchLines header2.h {
            typedef uint64_t gCount ;
        }]}
} -result {1}
----
endif::showtests[]

=== Domain Operation Declarations

``C'' language programs tend to be composed of _declarations_ and
_definitions_.
A declaration makes symbol names and types known to the compiler.
A definition associates specific data or code statements to a symbol.
Header files contain a lot of declarations.
Here we start with declarations for the domain operations.
Domain operations are just ordinary ``C'' functions but are given
external scope.

There are several different operations defined in the platform model.
Since they use the same attribute names,
it is possible to factor the generation of declaration code into
a common procedure.
What we need to know is are instance references to the operation
and the name of the relationship used to find the parameters of
the operation.

(((micca,Helpers,GenOperationDeclarations)))
[source,tcl]
----
<<generation helper commands>>=
proc GenOperationDeclarations {opRefs paramRel {suffix {}}} {
    set result {}

    set params [deRef [findRelated $opRefs $paramRel]] ; # <1>
    set ops [pipe {
        deRef $opRefs |
        relation rename ~ Name Operation |
        relation join ~ $params |
        relation group ~ Parameters Name Number DataType
    }]

    relation foreach op $ops {
        relation assign $op
        if {$Comment ne {}} {
            append result [comment [string trim $Comment \n]]
        }
        append result\
            "extern $ReturnDataType "\
            $Domain _ $Operation $suffix \(\
            [join [relation list $Parameters DataType] {, }]\
            "\) ;\n" ; # <2>
    }

    return $result
}
----
<1> Passing in a relationship name as an argument may appear unconventional,
but this is Tcl and queries need not be composed strictly of constant
data.
<2> Note that we prepend the domain name to the operation name
in order to avoid naming conflicts in the global namespace.
Naming conventions are necessary when dealing with a language like
``C'' which does not have support for name spaces.

Given a procedure to emit the operation declaration,
then the template expansion for the domain operations just invokes
the common code with the correct references and relationship name.

(((micca,Header Generation,domainOpDeclarations)))
[source,tcl]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    return [string cat\
        [comment "Domain Operations External Declarations"]\
        [GenOperationDeclarations $opRefs ~R6]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-3.0 {
    Domain operation declarations in header file
} -setup {
    validateutils genMiccaFile header3 {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            externalop void ext1 {b int c {void *}}
            externalop void ext2 {d char e unsigned}
            class c1 {
                attribute color int -default 20
            }
        }
        population header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    testConditions\
        {[validateutils matchLines header3.h {
            /*
             * two parameters
             */
            extern int header3_op1(int, char) ;
        }]}\
        {[validateutils matchLines header3.h {
            /*
             * pointer type parameters
             */
            extern int header3_op2(char *, uint8_t *) ;
        }]}
} -result {1}
----
endif::showtests[]

=== External Operation Declarations

The declarations for external operations follows the same pattern as
for domain operations.

(((micca,Header Generation,externalOpDeclarations)))
[source,tcl]
----
<<generation header commands>>=
proc externalOpDeclarations {} {
    variable domain
    set opRefs [ExternalOperation findWhere {$Domain eq $domain}]

    return [string cat\
        [comment "External Operations Declarations"]\
        [GenOperationDeclarations $opRefs ~R11 __EOP]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-3.1 {
    External operation declarations in header file
} -setup {
} -cleanup {
    validateutils forgetFiles
} -body {
    testConditions\
        {[validateutils matchLines header3.h {
            extern void header3_ext1__EOP(int, void *) ;
        }]}\
        {[validateutils matchLines header3.h {
            extern void header3_ext2__EOP(char, unsigned) ;
        }]}
} -result {1}
----
endif::showtests[]

=== Portal Function Constants

The run time code provides a set of
<<portal-access-functions,portal functions>>
that allow bridge code to tunnel simple model level operations, such a
signaling an event, into a domain.
The functions require integer constants that encode identifiers
for the various entities that can be accessed via the portal.
Those constants are placed in the generated header file.

We generate information on three aspects of the domain:

. Classes
. Transitioning events
. Polymorphic events

(((micca,Header Generation,portalIds)))
[source,tcl]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    <<portalIds:: generate class information>>
    <<portalIds:: generate assigner information>>
    <<portalIds:: generate event information>>
    <<portalIds:: generate polymorphic event information>>

    return $result
}
----

For classes,
we generate encodings for the class itself,
its attributes and its initial instances.

[source,tcl]
----
<<portalIds:: generate class information>>=
append result [comment "Numeric encoding of classes, attributes and\
        instances used by the portal functions"]
set classRefs [Class findWhere {$Domain eq $domain}]
append result "#define [string toupper ${domain}_CLASSCOUNT]\
        [refMultiplicity $classRefs]\n"
forAllRefs classRef $classRefs {
    assignAttribute $classRef
    <<portalIds:: generate class encodings>>
    <<portalIds:: generate attribute encodings>>
    <<portalIds:: generate instance encodings>>
}
----

Each class was given a unique number within the domain when
the platform model was populated.
This is the basis for the class id encodings.

[source,tcl]
----
<<portalIds:: generate class encodings>>=
append result [comment "Class: $Name"]
set classid [string toupper ${Domain}_${Name}_CLASSID]
append result "#define $classid $Number\n"
----

Attributes are encoded in alphabetical order.
Note that the portal does not allow access to relationships or
the pointer values that are used to navigate a relationship.

[source,tcl]
----
<<portalIds:: generate attribute encodings>>=
set attrRefs [findRelated $classRef ~R20 {~R25 PopulatedComponent}\
        {~R21 Attribute}]
append result "#define [string toupper ${Domain}_${Name}_ATTRCOUNT]\
        [refMultiplicity $attrRefs]\n"
set attrNumber -1
relation foreach attr [deRef $attrRefs] -ascending Name {
    relation assign $attr {Name attrName}
    set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
    append result "#define $attrid [incr attrNumber]\n"
}
----

We generate encodings for instances that are part of the initial
instance population.

[source,tcl]
----
<<portalIds:: generate instance encodings>>=
set instRefs [findRelated $classRef ~R20 ~R103]
append result "#define [string toupper ${Domain}_${Name}_INSTCOUNT]\
        [GetClassProperty $Name TotalInstance]\n"
forAllRefs inst $instRefs {
    assignAttribute $inst Instance {Number InstNumber}
    set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
    append result "#define $instid $InstNumber\n"
}
----

Assigners are treated much like classes.

[source,tcl]
----
<<portalIds:: generate assigner information>>=
set assigners [pipe {
    AssignerStateModel findWhere {$Domain eq $domain} |
    deRef ~ |
    relation tag ~ Number -ascending Association
}]
relation foreach assigner $assigners {
    relation assign $assigner
    append result [comment "Assigner: $Association"]
    set prefix [string toupper ${Domain}_${Association}]
    append result\
        "#define ${prefix}_ASSIGNERID $Number\n"\
        "#define ${prefix}_INSTCOUNT\
            [GetClassProperty $Association TotalInstance]\n"
}
----

The encoding for event numbers is obtained straight from the platform
model as they are numbered there.
In this case we query the *TransitioningEvent* class.

[source,tcl]
----
<<portalIds:: generate event information>>=
append result [comment "Numeric encoding of event numbers\
        used by the portal functions"]
set mevents [pipe {
    Event findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Domain PSigID |
    relation group ~ Events Event Number
}]
relation foreach mevent $mevents -ascending Model {
    relation assign $mevent
    append result [comment "Class: $Model"]
    append result "#define [string toupper ${domain}_${Model}_EVENTCOUNT]\
        [relation cardinality $Events]\n"
    relation foreach event $Events -ascending Number {
        relation assign $event
        append result "#define\
            [string toupper ${domain}_${Model}_${Event}_EVENT] $Number\n"
    }
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    validateutils genMiccaFile header4 {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population header4 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    testConditions\
        {[validateutils matchLines header4.h {
            #define HEADER4_CLASSCOUNT 2
        }]}\
        {[validateutils matchLines header4.h {
            #define HEADER4_C1_CLASSID 0
            #define HEADER4_C1_ATTRCOUNT 2
        }]}\
        {[validateutils matchLines header4.h {
            #define HEADER4_C2_CLASSID 1
            #define HEADER4_C2_ATTRCOUNT 2
        }]}
} -result {1}
----
endif::showtests[]

=== Portal Data Structure Declaration

The portal functions require a
<<portal-data-structures,data structure>>
and we must emit the
declaration of that data structure.

(((micca,Header Generation,portalDeclaration)))
[source,tcl]
----
<<generation header commands>>=
proc portalDeclaration {} {
    variable domain
    append result\
        [comment "Domain Portal Declaration"]\
        "extern MRT_DomainPortal ${domain}__PORTAL ;\n"
}
----

== Generating Code Files

In this section we describe the code used to generate the domain
code file.
We follow the pattern established for the header file.
A namespace is used to prevent any naming conflicts for the
template expansion commands.

[source,tcl]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    namespace import [namespace parent]::expand
    namespace import [namespace parent]::GenSupport::ExpandActivity

    <<generation code data>>
    <<generation code commands>>
}
----

The template for code generation is much more complicated.
In the code file we will find it necessary to emit many forward
declaration in addition to the required definitions.
For example,
it is necessary to emit forward declarations for all instance operations
since we do not know in which activity one of them might be invoked.

[source,tcl]
----
<<generation data>>=
set codeTemplate [textutil::adjust::undent {
    [banner]
    #ifdef MRT_INSTRUMENT
        #ifndef MRT_INSTRUMENT_ENTRY
            #define MRT_INSTRUMENT_ENTRY\
            printf("%s: %s %d\n", __func__, __FILE__, __LINE__) ;
        #endif /* MRT_INSTRUMENT_ENTRY */
    #else
        #define MRT_INSTRUMENT_ENTRY
    #endif /* MRT_INSTRUMENT */
    [domainInclude]
    [prologueDeclarations]
    [implementationTypeAliases]
    [forwardClassDeclarations]
    [forwardRelationshipDeclaration]
    [classDeclarations]
    [assignerDeclarations]
    [stateParamDeclarations]
    [operationDeclarations]
    [ctorDeclarations]
    [dtorDeclarations]
    [activityDeclarations]
    [storageDeclarations]
    [nameDefinitions]
    [iabDefinitions]
    [edbDefinitions]
    [pdbDefinitions]
    [classDefinitions]
    [assignerDefinitions]
    [relationshipDefinitions]
    [classInstanceDefinitions]
    [assignerInstanceDefinitions]
    [operationDefinitions]
    [ctorDefinitions]
    [dtorDefinitions]
    [activityDefinitions]
    [domainCtorDefinition]
    [domainOpDefinitions]
    [externalOpDefinitions]
    [portalDefinition]
    [epilogueDeclarations]
}]
----

In the following sections, we show the procedures that are
invoked as part of the code template expansion.

=== Including the Domain Header File

The generated code file includes the generated header file automatically.

(((micca,Code Generation,domainInclude)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

=== Domain Prologue

Any prologue text defined during domain configuration is placed early
in the generated code file.

(((micca,Code Generation,prologueDeclarations)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc prologueDeclarations {} {
    variable prologue

    return [string cat\
        [comment "Domain Prologue"]\
        [textutil::adjust::undent [string trim $prologue \n]]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    validateutils genMiccaFile codegen1 {
        domain codegen1 {
            prologue {#include "string.h"}
            prologue {#include "stdlib.h"}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population codegen1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen1.c
    testConditions\
        {[validateutils matchLines codegen1.c {
            #include "string.h"
        }]}\
        {[validateutils matchLines codegen1.c {
            #include "stdlib.h"
        }]}\
        {[validateutils matchLines codegen1.c {
            static int count(
                int a)
            {
                return a + 1 ;
            }
        }]}
} -result {1}
----
endif::showtests[]

=== Implementation Type Aliases

The type aliases that are not placed in the header file are placed in the
code file.

(((micca,Code Generation,implementationTypeAliases)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc implementationTypeAliases {} {
    variable domain
    set domRef [Domain findWhere {$Name eq $domain}]
    set aliasRefs [refMinus [findRelated $domRef ~R7]\
            [FindInterfaceTypeAliases $domain]] ; # <1>
    append result [comment "Type Aliases"]
    forAllRefs taRef $aliasRefs {
        assignAttribute $taRef TypeName TypeDefinition
        append result\
            "typedef "\
            [typeCheck composeDeclaration $TypeDefinition $TypeName]\
            " \;\n"
    }

    return $result
}
----
<1> The set difference between all the type aliases and those used
in the domain interface is the set that we are interested in here.

=== Forward Class Declarations

We need to introduce the structure names for the classes early in
the generated code file.
No definition of the structure is given here.
That will come later, but since class structures have pointers to
other class structures we need to tell the compiler about the names.
Sometimes the pointer references between classes are so direct
that we have no choice but to forward declare the class.
Rather than attempting to figure out some order does not reference
a class structure name before it is defined,
we just emit forward declarations for all the classes.
There is no reason to do the compiler's job here.

(((micca,Code Generation,forwardClassDeclarations)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

=== Forward Relationshp Declaration

The same reasoning applies to the array that holds the
relationship description information.
Class definitions will make reference to and we need to have its name
known to the compiler.

(((micca,Code Generation,forwardRelationshipDeclaration)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc forwardRelationshipDeclaration {} {
    variable domain
    return [string cat\
        [comment "Relationship descriptors forward declaration"]\
        "static MRT_Relationship const ${domain}__RSHIPS\[\] ;\n"\
    ]
}
----

=== Class Declarations

To declare the structures of the classes has one complication.
As usual,
union subclasses have to be treated separately.
Because the class structure of union based generalization nests
the subclasses as part of the superclass structure,
we must emit the union subclass declarations in the correct order
for the compiler.
Otherwise,
the compiler will complain as it must know the size of every member of a
structure as it is being defined.

The strategy here is start with the ultimate superclasses and find
those ultimate superclasses that are part of a union based generalization.
An ultimate superclass is one at the top of a generalization hierarchy,
_i.e._ a superclass that is not also a subclass of some other generalization
relationship.
For those ultimate superclasses that are part of a union based
generalization we can emit the class declarations in the tree in
reverse order.
After dealing with the union superclasses then the non-union ones can be
declared in an arbitrary order.

(((micca,Code Generation,classDeclarations)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc classDeclarations {} {
    variable domain

    set result [comment "Class structure declarations"]

    set ultimates [pipe {
        FindUltimateSuperclasses $domain |
        findRelated % {~R48 UnionSuperclass}
    } {} |%]
    append result [DeclareUnionSubclassStructures $ultimates]

    set remaining [FindNonUnionSubclasses $domain]
    forAllRefs classRef $remaining {
        append result [DeclareClassStructure $classRef]
    }

    return $result
}
----

Since the union subclasses form a tree,
we will use a recursive procedure to walk the implied tree.
The order of traversal will be depth first which insures that
union subclasses are defined before they must be used in the
definition of the including union superclass.

(((micca,Code Generation,DeclareUnionSubclassStructures)))
[source,tcl]
----
<<generation code commands>>=
proc DeclareUnionSubclassStructures {superRefs} {
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs R44 ~R45]
    forAllRefs subRef $subRefs {
        set newsupers [pipe {
            deRef $subRef |
            relation semijoin ~ $::micca::UnionSuperclass\
                -using {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
        }] ; # <1>

        append result [DeclareUnionSubclassStructures $newsupers] ; # <2>

        append result [DeclareClassStructure [findRelated $subRef R47 R40 R41]] ; # <3>
    }

    return $result
}
----
<1> By performing the `semijoin` only across the Domain and Class attributes,
we in effect are asking if the union subclass is also a union superclass
regardless of the relationship.
<2> Recursively define the subclass structures first
so we get a depth first walk.
<3> Emit the declaration for the current subclass node.

We can find the classes not part of a union generalization by the difference
of all the classes and those that are union subclasses.

(((micca,Code Generation,FindNonUnionSubclasses)))
[source,tcl]
----
<<generation helper commands>>=
proc FindNonUnionSubclasses {domain} {
    set usubs [UnionSubclass findWhere {$Domain eq $domain}]
    return [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation semiminus [deRef $usubs] ~ -using {Domain Domain Class Name} |
        ::rosea::Helpers::ToRef ::micca::Class ~
    }]
}
----

Class structure definitions consist of three components:

. The base
<<instance-data,instance data structure>>
as required and defined by the run time code.
. Attributes defined by the class.
. References used to implement relationship navigation.

Of the three, references are the most complicated in that they come
in a larger number of types.

(((micca,Code Generation,DeclareClassStructure)))
[source,tcl]
----
<<generation code commands>>=
proc DeclareClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__INST ;\n"

    set compRefs [findRelated $classRef ~R20] ; # <1>

    <<DeclareClassStructure: attribute declarations>>
    <<DeclareClassStructure: reference declarations>>

    append result "\} ;\n"
}
----
<1> Find all the class components for the given class.

Declaring the structure members for attributes is a matter of finding
the attributes and emiting ``C'' declarations, knowing the data type
and attribute name.
The only minor complication is for attributes that are specified to be
arrays.

[source,tcl]
----
<<DeclareClassStructure: attribute declarations>>=
set attrRefs [findRelated $compRefs {~R25 PopulatedComponent} {~R21 Attribute}] ; # <1>
forAllRefs attrRef $attrRefs {
    assignAttribute $attrRef {Name attrName} DataType Dimension
    append result "    [typeCheck composeDeclaration $DataType $attrName]"
    if {$Dimension > 0} { # <2>
        append result "\[$Dimension\]"
    }
    append result " ;\n"
}
----
<1> This query finds all the attributes of the class.
<2> Check if we need to make this attribute an array.


As can be seen from the portion of the platform model that
<<classes-subsystem-discussion,deals with classes>>
there are a lot of different types of references.
In the code below we assiduously consider each different type.

[source,tcl]
----
<<DeclareClassStructure: reference declarations>>=
set refRefs [findRelated $compRefs {~R25 PopulatedComponent} {~R21 Reference}] ; # <1>
<<DeclareClassStructure: superclass references>>
<<DeclareClassStructure: associator references>>
<<DeclareClassStructure: association references>>

set genRefs [findRelated $compRefs {~R25 GeneratedComponent}] ; # <2>
<<DeclareClassStructure: subclass references>>
<<DeclareClassStructure: subclass containers>>
<<DeclareClassStructure: link containers>>
<<DeclareClassStructure: complementary references>>
----
<1> First we deal with those references that can be populated.
Referring to the platform model will make this clearer.
<2> The other references are generated to support navigating relationships
in both directions.

A superclass reference declaration takes the form of a simple pointer to the
superclass structure.
[source,tcl]
----
<<DeclareClassStructure: superclass references>>=
set superRefs [findRelated $refRefs {~R23 SuperclassReference} ~R91\
        {~R47 ReferringSubclass} R37 ~R36]
forAllRefs superRef $superRefs {
    assignAttribute $superRef {Relationship attrName} {Class className}
    append result "    [GetClassProperty $className Reference]$attrName ;\n"
}
----

Associative classes make two references,
one to each class participating in the association,
which are grouped together in an unnamed structure.

[source,tcl]
----
<<DeclareClassStructure: associator references>>=
set atorRefs [findRelated $refRefs {~R23 AssociatorReference} ~R93 R42]
forAllRefs atorRef $atorRefs {
    assignAttribute $atorRef {Name attrName}

    set sourceDecl [pipe {
        findRelated $atorRef ~R34 |
        readAttribute % Class |
        GetClassProperty % Reference
    } {} |%]
    set targetDecl [pipe {
        findRelated $atorRef ~R35 |
        readAttribute % Class |
        GetClassProperty % Reference
    } {} |%]

    append result\
        "    struct \{\n"\
        "        ${targetDecl}forward ;\n"\
        "        ${sourceDecl}backward ;\n"\
        "    \} $attrName ;\n"
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associator class references
} -setup {
    validateutils genMiccaFile codegen3 {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -static -associator A X 0..*--0..* Y
        }
        population codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen3.c
    testConditions\
        {[validateutils matchLines codegen3.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct Y *forward ;
                    struct X *backward ;
                } R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen3.c {
            struct X {
                MRT_Instance base__INST ;
                struct {
                    struct A *const *links ;
                    unsigned count ;
                } R1__FORW ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-20.0 {
    Generated code file associative class references
} -setup {
    validateutils genMiccaFile codegen20 {
        domain codegen20 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..1--0..1 Y
        }
        population codegen20 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen20.c
    testConditions\
        {[validateutils matchLines codegen20.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct Y *forward ;
                    struct X *backward ;
                } R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen20.c {
            struct X {
                MRT_Instance base__INST ;
                struct A *R1__FORW ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

Simple association references also resolve to a single pointer declaration
to the referenced class.

[source,tcl]
----
<<DeclareClassStructure: association references>>=
set assocRefs [findRelated $refRefs {~R23 AssociationReference} ~R90 R32 ~R33]
forAllRefs assocRef $assocRefs {
    assignAttribute $assocRef {Relationship attrName} {Class className}
    append result "    [GetClassProperty $className Reference]$attrName ;\n"
}
----

Generated references deal with the "other" side of a relationship.
When a class serves as a superclass,
it has a pointer to its related subclass instance.
For the superclass,
we use a `void` pointer since the type of the subclass instance varies.

[source,tcl]
----
<<DeclareClassStructure: subclass references>>=
set subRefs [findRelated $genRefs {~R24 SubclassReference}]
forAllRefs subRef $subRefs {
    assignAttribute $subRef {Name attrName}
    append result "    void *$attrName ;\n"
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    validateutils genMiccaFile codegen2 {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population codegen2 {
            class super {
                instance fred1
                instance fred2
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen2.c
    testConditions\
        {[validateutils matchLines codegen2.c {
            struct super {
                MRT_Instance base__INST ;
                void *R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen2.c {
            struct sub1 {
                MRT_Instance base__INST ;
                struct super *R1 ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

Union superclasses use a union to serve as the container for
subclass instances.

[source,tcl]
----
<<DeclareClassStructure: subclass containers>>=
set contRefs [findRelated $genRefs {~R24 SubclassContainer}]
forAllRefs contRef $contRefs {
    assignAttribute $contRef {Name attrName}

    set subRefs [findRelated $contRef ~R96 R44 ~R45]
    append result "    union \{\n"
    foreach subName [relation list [deRef $subRefs] Class] {
        append result "        "\
            "[GetClassProperty $subName Declaration] $subName ;\n"
    }
    append result "    \} $attrName ;\n"
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test codegen-6.0 {
    Generated code file union generalization
} -setup {
    validateutils genMiccaFile codegen6 {
        domain codegen6 {
            class super {}
            class sub1 {
                attribute color int -default 10
            }
            class sub2 {
                attribute temp int -default 20
            }
            generalization R1 -union super sub1 sub2

            class sub3 {
                attribute degree int -default 30
            }
            class sub4 {
                attribute yaw int -default 40
            }

            generalization R2 -union sub1 sub3 sub4

            class sub5 {
                attribute degree int -default 30
            }
            class sub6 {
                attribute degree int -default 30
            }

            generalization R3 -union sub1 sub5 sub6

            class X {}
            association R4 X 1--1 sub5
        }
        population codegen6 {
            class super {
                instance fred1
                instance fred2
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
            class sub3 {
                instance s3 R2 s1
            }
            class sub5 {
                instance s5 R3 s1
            }
            class X {
                instance x1 R4 s5
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen6.c
    testConditions\
        {[validateutils matchLines codegen6.c {
            struct super {
                MRT_Instance base__INST ;
                union {
                    struct sub1 sub1 ;
                    struct sub2 sub2 ;
                } R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen6.c {
            struct sub1 {
                MRT_Instance base__INST ;
                int color ;
                union {
                    struct sub3 sub3 ;
                    struct sub4 sub4 ;
                } R2 ;
                union {
                    struct sub5 sub5 ;
                    struct sub6 sub6 ;
                } R3 ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

For class instances that are part of a linked list,
we have to provide storage in the class structure for the list links.

[source,tcl]
----
<<DeclareClassStructure: link containers>>=
set linkRefs [findRelated $genRefs {~R24 LinkContainer}]
forAllRefs linkRef $linkRefs {
    append result "    MRT_LinkRef [readAttribute $linkRef Name] ;\n"
}
----

Complementary references are used by associations to implement the
back references.
There are several types depending upon the multiplicity and
whether the association is static.

[source,tcl]
----
<<DeclareClassStructure: complementary references>>=
set complRefs [findRelated $genRefs {~R24 ComplementaryReference}]
forAllRefs complRef $complRefs {
    set singRef [findRelated $complRef {~R26 SingularReference} R26]
    if {[isNotEmptyRef $singRef]} {
        set attrName [readAttribute $singRef Name]
        set refedClass [FindReferencedClass $singRef]
        append result\
            "    [GetClassProperty $refedClass Reference]$attrName ;\n"
        continue
    }

    set arrayRef [findRelated $complRef {~R26 ArrayReference} R26]
    if {[isNotEmptyRef $arrayRef]} {
        set attrName [readAttribute $arrayRef Name]
        set classref [GetClassProperty [FindReferencedClass $arrayRef] Reference]
        append result\
            "    struct \{\n"\
            "        ${classref}const *links ;\n"\
            "        unsigned count ;\n"\
            "    \} $attrName ;\n"
        continue
    }

    set linkRef [findRelated $complRef {~R26 LinkReference} R26]
    if {[isNotEmptyRef $linkRef]} {
        set attrName [readAttribute $linkRef Name]
        append result "    MRT_LinkRef $attrName ;\n"
        continue
    }
}
----

For complementary references,
we need to be able to find the class to which they refer.
We factor out the mucking around the platform model that is necessary
to determine the class referenced by a complementary reference.

(((micca,Code Generation,FindReferencedClass)))
[source,tcl]
----
<<generation helper commands>>=
proc FindReferencedClass {compRef} {
    set destRef [findRelated $compRef {~R28 BackwardReference} ~R94]

    # backward, simple
    set refing [findRelated $destRef {~R38 SimpleReferencedClass} R33 ~R32]
    if {[isNotEmptyRef $refing]} {
        set refedClass [readAttribute $refing Class]
    } else {
        # backward, target
        set src [findRelated $destRef {~R38 TargetClass} R35 ~R42]
        if {[isNotEmptyRef $src]} {
            set refedClass [readAttribute $src Class]
        } else {
            # forward, source
            set trg [findRelated $compRef {~R28 ForwardReference} ~R95 R34 ~R42]
            if {[isNotEmptyRef $trg]} {
                set refedClass [readAttribute $trg Class]
            }
        }
    }
    return $refedClass
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-4.0 {
    Generated code file reflexive class references
} -setup {
    validateutils genMiccaFile codegen4 {
        domain codegen4 {
            class X {}
            association R1 X 0..1--0..1 X
        }
        population codegen4 {
            class X {
                instance x1 R1 x2
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen4.c
    testConditions\
        {[validateutils matchLines codegen4.c {
            struct X {
                MRT_Instance base__INST ;
                struct X *R1 ;
                struct X *R1__BACK ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-5.0 {
    Generated code file reflexive associative class references
} -setup {
    validateutils genMiccaFile codegen5 {
        domain codegen5 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen5 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen5.c
    testConditions\
        {[validateutils matchLines codegen5.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct X *forward ;
                    struct X *backward ;
                } R1 ;
                MRT_LinkRef R1__FLINKS ;
                MRT_LinkRef R1__BLINKS ;
            } ;
        }]}\
        {[validateutils matchLines codegen5.c {
            struct X {
                MRT_Instance base__INST ;
                MRT_LinkRef R1__FORW ;
                MRT_LinkRef R1__BACK ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-21.0 {
    Generated code file reflexive associative class references -- static
} -setup {
    validateutils genMiccaFile codegen21 {
        domain codegen21 {
            class A {}
            class X {}
            association R1 -static -associator A X 0..*--0..* X
        }
        population codegen21 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen21.c
    testConditions\
        {[validateutils matchLines codegen21.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct X *forward ;
                    struct X *backward ;
                } R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen21.c {
            struct X {
                MRT_Instance base__INST ;
                struct {
                    struct A *const *links ;
                    unsigned count ;
                } R1__FORW ;
                struct {
                    struct A *const *links ;
                    unsigned count ;
                } R1__BACK ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-7.0 {
    Generated code file associative class references -- non static
} -setup {
    validateutils genMiccaFile codegen7 {
        domain codegen7 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population codegen7 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x1 Y y2}
                instance a4 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen7.c
    testConditions\
        {[validateutils matchLines codegen7.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct Y *forward ;
                    struct X *backward ;
                } R1 ;
                MRT_LinkRef R1__FLINKS ;
                MRT_LinkRef R1__BLINKS ;
            } ;
        }]}\
        {[validateutils matchLines codegen7.c {
            struct X {
                MRT_Instance base__INST ;
                MRT_LinkRef R1__FORW ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-8.0 {
    Generated code file reflexive associative class references -- non static
} -setup {
    validateutils genMiccaFile codegen8 {
        domain codegen8 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen8 {
            class A {
                instance a12 R1 {forward x2 backward x1}
                instance a13 R1 {forward x3 backward x1}
                instance a23 R1 {forward x3 backward x2}
                instance a24 R1 {forward x4 backward x2}
                instance a34 R1 {forward x4 backward x3}
                instance a41 R1 {forward x1 backward x4}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen8.c
    testConditions\
        {[validateutils matchLines codegen8.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct X *forward ;
                    struct X *backward ;
                } R1 ;
                MRT_LinkRef R1__FLINKS ;
                MRT_LinkRef R1__BLINKS ;
            } ;
        }]}\
        {[validateutils matchLines codegen8.c {
            struct X {
                MRT_Instance base__INST ;
                MRT_LinkRef R1__FORW ;
                MRT_LinkRef R1__BACK ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-9.0 {
    Generated code file simple reflexive class references
} -setup {
    validateutils genMiccaFile codegen9 {
        domain codegen9 {
            class X {}
            association R1 X 0..*--0..1 X
        }
        population codegen9 {
            class X {
                instance x1 R1 x2
                instance x2 R1 x3
                instance x3 R1 x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen9.c
    testConditions\
        {[validateutils matchLines codegen9.c {
            struct X {
                MRT_Instance base__INST ;
                struct X *R1 ;
                MRT_LinkRef R1__BLINKS ;
                MRT_LinkRef R1__BACK ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

=== Assigner Declarations

An assigner is declared in much the same manner as a class.
This gives us the ability to deal with the state model of an assigner
using the same code as for classes.
There are a few different rules for assigners:

* Single assigners have no attributes and are never created dynamically.
Their single instance is created as part of the initial instance population.
* Multiple assigners have a single attribute and may be created dynamically.

(((micca,Code Generation,assignerDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc assignerDeclarations {} {
    variable domain

    append result [comment "Single Assigner Structure Declarations"]

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $singles {
        assignAttribute $assigner
        append result\
            "struct $Association \{\n"\
            "    MRT_Instance base__INST ;\n"\
            "\} ;\n"
    }

    append result [comment "Multiple Assigner Structure Declarations"]

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $multis {
        assignAttribute $assigner
        append result\
            "struct $Association \{\n"\
            "    MRT_Instance base__INST ;\n"\
            "    [GetClassProperty $Class Reference] idinstance ;\n"\
            "\} ;\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-22.0 {
    Generate a single assigner declaration
} -setup {
    validateutils genMiccaFile codegen22 {
        domain codegen22 {
            class clerk {}
            class client {}
            association R1 clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
        }
        population codegen22 {
            class clerk {
                allocate 2
            }
            class client {
                allocate 3
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen22.c
    testConditions\
        {[validateutils matchLines codegen22.c {
            struct R1 {
                MRT_Instance base__INST ;
            } ;
        }]}\
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-23.0 {
    Generate a multi assigner declaration
} -setup {
    validateutils genMiccaFile codegen23 {
        domain codegen23 {
            class clerk {}
            class client {}
            association R1 clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {}
            association R2 department 1..*--1 clerk
        }
        population codegen23 {
            class department {
                instance mens R2 fred
                instance children R2 fred
                instance womens R2 alice
                instance sports R2 biff
            }
            class clerk {
                instance fred
                instance alice
                instance biff
            }
            class client {
                allocate 3
            }
            assigner R1 {
                instance mens mens
                instance children children
                instance womens womens
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen23.c
    testConditions\
        {[validateutils matchLines codegen23.c {
            struct R1 {
                MRT_Instance base__INST ;
                struct department * idinstance ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

=== Event Parameter Declarations

(((micca,Code Generation,eventParamDeclarations)))
[source,tcl]
.Implementation
----
<<generation header commands>>=
proc eventParamDeclarations {} {
    variable domain

    append result [comment "Transition Event Parameter Structure\
            Declarations"]
    set tevents [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        findRelated ~ R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    relation foreach tevent $tevents -ascending Model {
        relation assign $tevent
        relation foreach event $Events {
            relation assign $event
            set pstructname "struct ${domain}_${Model}_${Event}__EPARAMS"
            append result "$pstructname \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
            append result\
                "static_assert(sizeof($pstructname) <= sizeof(MRT_EventParams), "\
                "\"Parameters for class or assigner, $Model, event,\
                    $Event, are too large\") ;\n"
        }
    }

    set pevents [pipe {
        PolymorphicEvent findWhere {$Domain eq $domain} |
        findRelated ~ R81 R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    append result [comment "Polymorphic Event Parameter Structure\
            Declarations"]
    relation foreach tevent $pevents -ascending Model {
        relation assign $tevent
        relation foreach event $Events {
            relation assign $event
            set pstructname "struct ${domain}_${Model}_${Event}__PEPARAMS"
            append result "$pstructname \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
            append result\
                "static_assert(sizeof($pstructname) <= sizeof(MRT_EventParams), "\
                "\"Parameters for class or assigner, $Model, event,\
                    $Event, are too large\") ;\n"
        }
    }

    return $result
}
----

=== State Parameter Declarations

(((micca,Code Generation,stateParamDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc stateParamDeclarations {} {
    variable domain
    set result {}

    set stateargs [pipe {
        State findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name State |
        relation join $::micca::ParameterSignature $::micca::Parameter\
                $::micca::Argument |
        relation project ~ Model State Name Position DataType |
        relation group ~ Params Name Position DataType
    }]

    if {[relation isnotempty $stateargs]} {
        append result [comment "State Parameter Structure Declarations"]
        relation foreach statearg $stateargs -ascending {Model State} {
            relation assign $statearg
            set pstructname "struct ${Model}_${State}__SPARAMS"
            append result "$pstructname \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
            append result\
                "static_assert(sizeof($pstructname) <= sizeof(MRT_EventParams), "\
                "\"Parameters for class or assigner, $Model, state,\
                    $State, are too large\") ;\n"
        }
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-10.0 {
    Generated event parameter structures
} -setup {
    # makeFile {} codegen10.h
    # makeFile {} codegen10.c
    micca configure {
        domain codegen10 {
            typealias MyCount int
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            class super {
                polymorphic e1 f MyCount g {char *}
                polymorphic e2
            }
            class sub1 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            class sub2 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            generalization R1 super sub1 sub2
        }
        population codegen10 {
            class X {
                instance x1 color 30
            }
            class super {
                instance sup1
                instance sup2
            }
            class sub1 {
                instance s1 R1 sup1
            }
            class sub2 {
                instance s2 R1 sup2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {__EPARAMS} codegen10.h]] == 6}\
        {[llength [fileutil::grep {__PEPARAMS} codegen10.h]] == 2}
} -result {1}
----
endif::showtests[]

=== Operation Declarations

(((micca,Code Generation,operationDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc operationDeclarations {} {
    variable domain
    set result {}

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Operation Forward Declarations"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "static $ReturnDataType ${Class}_$Operation\("

            if {[relation isempty $Parameters]} {
                append result void
            } else {
                append result [join\
                    [relation list $Parameters DataType -ascending Number] {, }]
            }

            append result "\) ;\n"
        }
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-11.0 {
    Generated code file with class operations
} -setup {
    # makeFile {} codegen11.h
    # makeFile {} codegen11.c
    micca configure {
        domain codegen11 {
            class X {
                attribute color int -default 20

                classop int count {} {
                    return 42 ;
                }

                instop void addColor {amount int} {
                    self->color += amount ;
                }
            }
        }
        population codegen11 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X_count} codegen11.c]] == 2}\
        {[llength [fileutil::grep {X_addColor} codegen11.c]] == 2}
} -result {1}
----
endif::showtests[]

=== Constructor Declarations

(((micca,Code Generation,ctorDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc ctorDeclarations {} {
    variable domain
    set result {}

    set ctors [Constructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $ctors]} {
        append result [comment "Class Constructor Forward Declarations"]
        forAllRefs ctor $ctors {
            assignAttribute $ctor {Class className}
            append result\
                "static void ${className}__CTOR\(void *const) ;\n"
        }
    }

    return $result
}
----

=== Destructor Declarations

(((micca,Code Generation,dtorDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc dtorDeclarations {} {
    variable domain
    set result {}

    set dtors [Destructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $dtors]} {
        append result [comment "Class Destructor Forward Declarations"]
        forAllRefs dtor $dtors {
            assignAttribute $dtor {Class className}
            append result\
                "static void ${className}__DTOR\(void *const) ;\n"
        }
    }

    return $result
}
----

=== Activity Declarations

(((micca,Code Generation,activityDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc activityDeclarations {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && [string trim $Activity] ne {}} |
        deRef ~ |
        relation eliminate ~ Domain Activity IsTerminal PSigID |
        relation group ~ States Name
    }]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Forward Declarations"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            relation foreach state $States {
                relation assign $state
                append result "static void ${Model}_${Name}__ACTIVITY\("\
                    "void *const s__SELF, "\
                    "void const *const p__PARAMS) ;\n"
            }
        }
    }

    return $result
}
----

=== Storage Declarations

(((micca,Code Generation,storageDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc storageDeclarations {} {
    variable domain
    set result {}

    set cpops [pipe {
        FindNonUnionSubclasses $domain |
        findRelated % R104 {~R101 ElementPopulation} {~R105 ClassPopulation}
    } {} |%]

    if {[isNotEmptyRef $cpops]} {
        append result [comment "Class Instance Storage Forward Declarations"]
        forAllRefs cpop $cpops {
            assignAttribute $cpop {Allocation allocation} {Class className}
            set insts [refMultiplicity [findRelated $cpop ~R102]]
            set total [expr {$allocation + $insts}]
            append result "static struct $className "\
                [GetClassProperty $className StorageVariable]\
                "\[[GetClassProperty $className TotalInstance]\] ;\n"
        }
    }

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs single $singles {
        assignAttribute $single Association
        append result "static struct ${Association} ${Association}__POOL\[1\] ;\n"
    }

    # Total number of multiple assigner instances is the same as the
    # total number of instances of the id class
    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        assignAttribute $multi Association {Class idclass}
        set totalinsts [GetClassProperty $idclass TotalInstance]
        append result "static struct ${Association}\
            ${Association}__POOL\[$totalinsts\] ;\n"
    }

    return $result
}
----

=== Name Definitions

(((micca,Code Generation,nameDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc nameDefinitions {} {
    variable domain
    append result\
        [comment "Domain Naming Definitions"]\
        "#ifndef MRT_NO_NAMES\n"

    set storageType "static char const"

    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        set className [readAttribute $classRef Name]
        append result "$storageType ${className}__NAME\[\] = \"$className\" ;\n"
    }

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    forAllRefs relRef $relRefs {
        set relName [readAttribute $relRef Name]
        append result "$storageType ${relName}__NAME\[\] = \"$relName\" ;\n"
    }

    set stateRefs [StatePlace findWhere {$Domain eq $domain}]
    forAllRefs stateRef $stateRefs {
        assignAttribute $stateRef {Model modelName} {Name stateName}
        set namevar [expr {$stateName eq "@" ? "AT" : $stateName}]
        append result "$storageType ${modelName}_${namevar}__SNAME\[\] =\
                \"$stateName\" ;\n"
    }

    set eventRefs [Event findWhere {$Domain eq $domain}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Model modelName} {Event eventName}
        append result "$storageType ${modelName}_${eventName}__ENAME\[\] =\
                \"$eventName\" ;\n"
    }

    set saRefs [SingleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $saRefs]} {
        append result "$storageType single_assigner_instance__NAME\[\] =\
                \"assigner\" ;\n"
    }

    set maRefs [MultipleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $maRefs]} {
        append result "$storageType multi_assigner_attribute__NAME\[\] =\
                \"idinstance\" ;\n"
    }

    append result "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

=== Instance Allocation Block Definitions

[source,tcl]
----
<<generation code commands>>=
proc iabDefinitions {} {
    variable domain
    set result [comment "Instance Allocation Block Definitions"]

    forAllRefs classRef [FindNonUnionSubclasses $domain] {
        append result [DefineIABMembers $classRef false]
    }

    set unionRefs [pipe {
        UnionSubclass findWhere {$Domain eq $domain} |
        findRelated ~ R47 R40 R41
    }]
    forAllRefs classRef $unionRefs {
        append result [DefineIABMembers $classRef true]
    }

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs single $singles {
        assignAttribute $single Association
        append result\
            "static MRT_iab ${Association}__IAB = \{\n"\
            "    .storageStart = &${Association}__POOL\[0\],\n"\
            "    .storageFinish = &${Association}__POOL\[1\],\n"\
            "    .storageLast = &${Association}__POOL\[0\],\n"\
            "    .alloc = 1,\n"\
            "    .instanceSize = sizeof\(struct ${Association}\),\n"\
            "    .construct = NULL,\n"\
            "    .destruct = NULL,\n"\
            "    .linkCount = 0,\n"\
            "    .linkOffsets = NULL\n"\
            "\} ;\n"
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        set initial [refMultiplicity [findRelated $multi ~R106]]
        assignAttribute $multi Association {Class idclass}
        set total [GetClassProperty $idclass TotalInstance]

        append result\
            "static MRT_iab ${Association}__IAB = \{\n"\
            "    .storageStart = &${Association}__POOL\[0\],\n"\
            "    .storageFinish = &${Association}__POOL\[$total\],\n"\
            "    .storageLast = &${Association}__POOL\[[expr {$total - 1}]\],\n"\
            "    .alloc = $initial,\n"\
            "    .instanceSize = sizeof\(struct ${Association}\),\n"\
            "    .construct = NULL,\n"\
            "    .destruct = NULL,\n"\
            "    .linkCount = 0,\n"\
            "    .linkOffsets = NULL\n"\
            "\} ;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc DefineIABMembers {classRef isUnionSubclass} {
    assignAttribute $classRef {Name className}

    set linkRefs [findRelated $classRef ~R20 {~R25 GeneratedComponent}\
        {~R24 ComplementaryReference} {~R26 LinkReference}]
    if {[isEmptyRef $linkRefs]} {
        set linkOffsets NULL
    } else {
        set linkOffsets ${className}__LINKS
        append result\
            "static MRT_AttrOffset const $linkOffsets\[\] = \{\n"
        set linkMembers [relation list [deRef $linkRefs] Name]
        foreach linkMember $linkMembers {
            append result\
                "    "\
                "offsetof\([GetClassProperty $className Declaration],\
                $linkMember\),\n"
        }
        append result "\} ;\n"
    }

    append result\
        "static MRT_iab ${className}__IAB = \{\n"

    if {$isUnionSubclass} {
        append result\
            "    .storageStart = NULL,\n"\
            "    .storageFinish = NULL,\n"\
            "    .storageLast = NULL,\n"
    } else {
        set nelements [GetClassProperty $className TotalInstance]
        append result\
            "    .storageStart = &${className}__POOL\[0\],\n"\
            "    .storageFinish = &${className}__POOL\[$nelements\],\n"\
            "    .storageLast = &${className}__POOL\[[expr {$nelements - 1}]\],\n"
    }
    set ctor [pipe {
        findRelated $classRef ~R8 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__CTOR"}
    } {} |%]
    set dtor [pipe {
        findRelated $classRef ~R9 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__DTOR"}
    } {} |%]
    append result\
        "    .alloc = [GetClassProperty $className InitialInstance],\n"\
        "    .instanceSize = sizeof\([GetClassProperty $className Declaration]\),\n"\
        "    .construct = $ctor,\n"\
        "    .destruct = $dtor,\n"\
        "    .linkCount = [refMultiplicity $linkRefs],\n"\
        "    .linkOffsets = $linkOffsets\n"\
        "\} ;\n"

    return $result
}
----

=== Event Dispatch Block Definitions

[source,tcl]
----
<<generation code commands>>=
proc edbDefinitions {} {
    variable domain
    set result [comment "Event Dispatch Block Definitions"]

    upvar #0 ::micca::@Gen@::options options

    forAllRefs smodel [StateModel findWhere {$Domain eq $domain}] {
        assignAttribute $smodel {Model className}

        append result [GenerateTransitionTable $smodel]
        append result [GenerateActivityTable $smodel]
        set termstates [GenerateTerminalStates $smodel result]

        append result [GenerateStateNames $smodel]

        append result "static MRT_edb const ${className}__EDB = \{\n"

        set stateRefs [findRelated $smodel ~R55]
        set cstateRef [findRelated $smodel ~R56]
        append result\
            "    .stateCount = [expr {[refMultiplicity $stateRefs] +\
                [refMultiplicity $cstateRef]}],\n"

        set eventRefs [findRelated $smodel ~R87]
        append result\
            "    .eventCount = [refMultiplicity $eventRefs],\n"\
            "    .initialState = [readAttribute [findRelated $smodel R58 R57]\
                        Number],\n"
        set crstate [expr {[isNotEmptyRef $cstateRef] ?\
            [readAttribute [findRelated $cstateRef R57] Number] :\
            "MRT_StateCode_IG"}]
        append result\
            "    .creationState = $crstate,\n"\
            "    .transitionTable = ${className}__TTAB,\n"\
            "    .activityTable = ${className}__ATAB,\n"\
            "    .terminalStates = $termstates,\n"

        append result\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .stateNames = ${className}__SNAMES,\n"\
            "        #endif /* MRT_NO_NAMES */\n"

        append result\
            "\} ;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateTransitionTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        findRelated $smodel ~R55 |
        deRef % |
        relation rename % Name State |
        relation eliminate % Activity IsTerminal PSigID
    } {} |%]
    set cstate [pipe {
        findRelated $smodel ~R56 |
        deRef % |
        relation rename % Name State
    } {} |%]
    set states [relation union $states $cstate]
    # puts [relformat $states states]

    set events [pipe {
        findRelated $smodel ~R87 R80 |
        deRef % |
        relation eliminate % PSigID
    } {} |%]
    # puts [relformat $events events]

    set alltrans [pipe {
        relation eliminate $events Number |
        relation join $states ~
    }]
    # puts [relformat $alltrans alltrans]

    set statetrans [pipe {
        StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation eliminate ~ ASigID
    }]
    # puts [relformat $statetrans statetrans]
    set nontrans [pipe {
        NonStateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ TransRule NewState
    }]
    # puts [relformat $nontrans nontrans]

    set deftrans [pipe {
        TransitionPlace findAll |
        deRef ~ |
        relation minus $alltrans ~ |
        relation join ~ [deRef [StateModel findAll]] |
        relation eliminate ~ InitialState |
        relation rename ~ DefaultTrans NewState |
        relation update ~ dttup {[tuple extract $dttup State] eq "@"} {
                tuple update $dttup NewState CH}
    }]
    # puts [relformat $deftrans deftrans]

    set ntstates [pipe {
        TransitionRule findAll |
        deRef ~ |
        relation rename ~ Name State |
        relation extend ~ nttup\
            Domain string {$domain}\
            Model string {$className}\
            StateNumber string {"MRT_StateCode_[tuple extract $nttup State]"}
    }]
    # puts [relformat $ntstates ntstates]

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ Name State Number StateNumber |
        relation union ~ $ntstates
    }]
    # puts [relformat $places places]
    set transitions [pipe {
        relation union $statetrans $nontrans $deftrans |
        relation join ~ $places\
            -using {Domain Domain Model Model NewState State} |
        relation rename ~ StateNumber NewStateNumber |
        relation join ~ $places $events |
        relation eliminate ~ Domain Model
    }]
    # puts [relformat $transitions transitions]

    set result "static MRT_StateCode const ${className}__TTAB\[\] = \{\n"
    relation foreach transition $transitions -ascending {StateNumber Number} {
        relation assign $transition
        append result "    $NewStateNumber, // $State - $Event -> $NewState\n"
    }
    append result "\} ;\n"

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-12.0 {
    Generated code file with state model
} -setup {
    # makeFile {} codegen12.h
    # makeFile {} codegen12.c
    micca configure {
        domain codegen12 {
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {} {
                        printf("In s1\n") ;
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                    }
                    transition s2 - e1 -> IG
                    transition s2 - e2 -> s3

                    state s3 {} {
                    }
                    transition s3 - e3 -> s1

                    terminal s3
                }
            }
        }
        population codegen12 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X__TTAB} codegen12.c]] == 2}\
        {[llength [fileutil::grep {X__ATAB} codegen12.c]] == 2}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation code commands>>=
proc GenerateActivityTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set result "static MRT_PtrActivityFunction const ${className}__ATAB\[\] = \{\n"

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name Activity
            if {[string trim $Activity] eq {}} {
                append result "    NULL, // $Name\n"
            } else {
                append result "    ${className}_${Name}__ACTIVITY, // $Name\n"
            }
        } else {
            set cstate [relation semijoin $place $::micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    NULL, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateTerminalStates {smodel resultVar} {
    set tstates [findRelatedWhere $smodel ~R55 {$IsTerminal}]
    if {[isEmptyRef $tstates]} {
        return NULL
    }
    upvar 1 $resultVar result
    variable domain
    assignAttribute $smodel {Model className}
    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static bool const ${className}__TSTATES\[\] = \{\n"
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name IsTerminal
            append result "    "\
                [expr {$IsTerminal ? "true" : "false"}]\
                ", // $Name\n"
        } else {
            set cstate [relation semijoin $place $::micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    false, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
    return ${className}__TSTATES
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateStateNames {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result\
        "#ifndef MRT_NO_NAMES\n"\
        "static char const * const ${className}__SNAMES\[\] = \{\n"

    relation foreach state $states -ascending Number {
        relation assign $state Name
        set Name [string map {@ AT} $Name]
        append result "    ${className}_${Name}__SNAME,\n"
    }

    append result\
        "\} ;\n"\
        "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

=== Polymorphic Dispatch Block Definitions

[source,tcl]
----
<<generation code commands>>=
proc pdbDefinitions {} {
    variable domain

    set rnames {}
    set pmaps {}
    set gdbs {}
    set pdbs {}

    set deRefs [DeferredEvent findWhere {$Domain eq $domain}]
    set superRefs [findRelated $deRefs ~R86]
    if {[isEmptyRef $superRefs]} {
        return
    }

    set deferred [pipe {
        findRelated $superRefs {R86 DeferralPath} |
        deRef ~ |
        relation join ~ $::micca::DeferredEvent $::micca::Event |
        relation eliminate ~ Domain Role PSigID |
        relation rename ~ Model Superclass Number SuperNumber
    }]
    # puts [relformat $deferred deferred]

    set nonlocals [pipe {
        NonLocalEvent findWhere {$Domain eq $domain} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Number RelNumber
    } {} |%]
    # puts [relformat $nonlocals nonlocals]

    set polys [relation join $nonlocals\
            $::micca::DeferredEvent $::micca::Event]
    # puts [relformat $polys polys]

    set trans [relation join $nonlocals\
            $::micca::TransitioningEvent $::micca::Event]
    # puts [relformat $trans trans]

    set supers [pipe {
        relation union $polys $trans |
        relation eliminate ~ Domain Role PSigID |
        relation join ~ $deferred |
        relation group ~ EventMap Event SuperNumber Number |
        relation group ~ SubMap Model EventMap |
        relation group ~ Generalizations Relationship RelNumber SubMap
    }]
    # puts [relformat $supers supers]

    relation foreach super $supers {
        relation assign $super

        set gdbvar ${Superclass}__GDBS
        append gdbs "static MRT_gdb $gdbvar\[\] = \{\n"

        set rnamesvar ${Superclass}__RNAMES
        append rnames "static char const *const $rnamesvar\[\] = \{\n"

        relation foreach gen $Generalizations -ascending Relationship {
            relation assign $gen

            append rnames "    ${Relationship}__NAME,\n"

            set pmapvar ${Superclass}_${Relationship}__PMAP
            append pmaps "static MRT_EventCode const $pmapvar\[\] = \{\n"

            relation foreach submap $SubMap -ascending Model {
                relation assign $submap
                relation foreach eventmap $EventMap -ascending Number {
                    relation assign $eventmap
                    append pmaps "    $Number, // $Event for $Model\n"
                }
            }
            append pmaps "\} ;\n"

            append gdbs\
                "    \{\n"\
                "        .relship = &${domain}__RSHIPS\[$RelNumber\],\n"\
                "        .eventMap = $pmapvar,\n"\
                "    \},\n"
        }
        append rnames "\} ;\n"
        append gdbs "\} ;\n"

        append pdbs\
            "static MRT_pdb const ${Superclass}__PDB = \{\n"\
            "    .eventCount = [relation cardinality $EventMap],\n"\
            "    .genCount = [relation cardinality $Generalizations],\n"\
            "    .genDispatch = $gdbvar,\n"\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .genNames = $rnamesvar,\n"\
            "        #endif /* MRT_NO_NAMES */\n"\
            "\} ;\n"
    }


    append result\
        [comment "Polymorphic Event Dispatch Block Definitions"]\
        "#ifndef MRT_NO_NAMES\n"\
        $rnames\
        "#endif /* MRT_NO_NAMES */\n"\
        $pmaps $gdbs $pdbs

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-13.0 {
    polymorphic events -- inject polymorphic event mid-level
} -setup {
    # makeFile {} codegen13.h
    # makeFile {} codegen13.c
    micca configure {
        domain codegen13 {
            class S {
                polymorphic e1
                polymorphic e2
                polymorphic a1
            }
            class X {
                polymorphic a3
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    transition s1 - a1 ->  s1
                }
            }
            class Y {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - a1 -> s1
                }
            }
            generalization R1 -union S X Y

            class F {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - f1 -> s1
                    transition s2 - a1 -> s2
                }
            }
            class G {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - g1 -> s1
                    transition s2 - a1 -> s2
                }
            }

            generalization R3 -union S F G

            class A {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            class B {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            generalization R2 -union X A B
        }
        population codegen13 {
            class S {
                instance s1
                instance s2
                instance s3
            }
            class X {
                instance x1 R1 s1
                instance x2 R1 s3
            }
            class Y {
                instance y1 R1 s2
            }
            class A {
                instance a1 R2 x1
            }
            class B {
                instance b1 R2 x2
            }
            class F {
                instance f1 R3 s1
                instance f2 R3 s2
            }
            class G {
                instance g1 R3 s3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    return
} -result {}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-14.0 {
    Generated code file simple references -- non static
} -setup {
    # makeFile {} codegen14.h
    # makeFile {} codegen14.c
    micca configure {
        domain codegen14 {
            class X {}
            class Y {}
            association R1 X 1..*--1 Y
        }
        population codegen14 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen14.c]] == 22}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-15.0 {
    Generated code file simple references -- static
} -setup {
    # makeFile {} codegen15.h
    # makeFile {} codegen15.c
    micca configure {
        domain codegen15 {
            class X {}
            class Y {}
            association R1 -static X 1..*--1 Y
        }
        population codegen15 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen15.c]] == 10}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-16.0 {
    many to 1 associative relationship
} -setup {
    # makeFile {} codegen16.h
    # makeFile {} codegen16.c
    micca configure {
        domain codegen16 {
            class A {
            }
            class X {
            }
            class Y {
            }

            association R1 -associator A X 1..*--0..1 Y
        }

        population codegen16 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x3 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    return
} -result {}
----
endif::showtests[]

=== Class Description Definitions

[source,tcl]
----
<<generation code commands>>=
proc classDefinitions {} {
    variable domain
    set front [comment "Class Description Definitions"]

    set classRefs [Class findWhere {$Domain eq $domain}]

    set classinrel [pipe {
        findRelated $classRefs {~R41 ClassRole} |
        deRef % |
        relation eliminate % Role
    } {} |%]
    set assocrels [pipe {
        relation join $classinrel $::micca::Association -using\
            {Domain Domain Relationship Name} |
        relation eliminate ~ IsStatic
    }]
    set genrels [relation join $classinrel $::micca::Generalization\
            -using {Domain Domain Relationship Name}]

    set rels [pipe {
        relation union $assocrels $genrels |
        relation join ~ $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename ~ Class Name Number RelNumber
    }]
    # puts [relformat $rels rels]

    set attrs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Attribute} |
        deRef % |
        relation rename % Name Attribute Class Name
    } {} |%]
    # puts [relformat $attrs attrs]

    set usubs [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 Subclass}\
            {~R47 UnionSubclass} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number SuperNumber |
        relation eliminate % Role Relationship
    } {} |%]
    # puts [relformat $usubs usubs]

    set allevents [pipe {
        Event findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Model Name Number EvtNumber |
        relation eliminate ~ PSigID
    }]
    # puts [relformat $allevents allevents]

    set classes [pipe {
        deRef $classRefs |
        relation extend ~ ctup IAB string {"&[tuple extract $ctup Name]__IAB"} |
        ralutil::rvajoin ~ $allevents AEvents |
        ralutil::rvajoin ~\
            [relation rename $::micca::TransitioningEvent Model Name] TEvents |
        ralutil::rvajoin ~\
            [relation rename $::micca::DeferredEvent Model Name] PEvents |
        relation extend ~ etup\
            EDB string {
                [relation isempty [tuple extract $etup TEvents]] ?\
                "NULL" : "&[tuple extract $etup Name]__EDB"}\
            PDB string {
                [relation isempty [tuple extract $etup PEvents]] ?\
                "NULL" : "&[tuple extract $etup Name]__PDB"}\
            eventNames string {
                [relation isempty [tuple extract $etup AEvents]] ? "NULL" :\
                "[tuple extract $etup Name]__ENAMES"} |
        relation eliminate ~ TEvents PEvents |
        ralutil::rvajoin ~ $rels Relationships |
        relation extend ~ rtup\
            relCount int {
                [relation cardinality [tuple extract $rtup Relationships]]}\
            classRels string {
                [relation cardinality [tuple extract $rtup Relationships]] == 0 ?\
                "NULL" : "[tuple extract $rtup Name]__CRELS"} |
        ralutil::rvajoin ~ $attrs Attributes |
        relation extend ~ atup\
            attrCount int {
                [relation cardinality [tuple extract $atup Attributes]]}\
            classAttrs string {
                [relation isempty [tuple extract $atup Attributes]] ?\
                "NULL" : "[tuple extract $atup Name]__CATTRS"} |
        ralutil::rvajoin ~ $usubs UnionSubs |
        relation extend ~ utup\
            containment string {
                [relation isempty [tuple extract $utup UnionSubs]] ?\
                "NULL" :\
                "&${domain}__RSHIPS\[[relation extract\
                    [tuple extract $utup UnionSubs]\
                    SuperNumber]\].relInfo.unionGeneralization.superclass"} |
        relation eliminate ~ Domain

    }]
    # puts [relformat $classes classes]

    append result "static MRT_Class const\
            ${domain}__CLASSES\[[relation cardinality $classes]\] = \{\n"

    set relrefs {}
    set attrrefs {}
    set namerefs {}
    relation foreach class $classes {
        relation assign $class

        if {[relation isnotempty $Relationships]} {
            append relrefs\
                "static MRT_Relationship const *const\
                    ${Name}__CRELS\[\] = \{\n"

            relation foreach rel $Relationships {
                relation assign $rel
                append relrefs\
                    "    &${domain}__RSHIPS\[$RelNumber\], // $Relationship\n"
            }

            append relrefs "\} ;\n"
        }

        if {[relation isnotempty $Attributes]} {
            append attrrefs\
                "static MRT_Attribute const ${Name}__CATTRS\["\
                [relation cardinality $Attributes]\
                "\] = \{\n"

            relation foreach attr $Attributes -ascending Attribute {
                relation assign $attr
                set offset "offsetof([GetClassProperty $Name Declaration],\
                        $Attribute)"
                set size "sizeof($DataType"
                if {$Dimension > 0} {
                    append size "\[$Dimension\]"
                }
                append size )
                append attrrefs\
                    "    \{\n"\
                    "        .offset = $offset,\n"\
                    "        .size = $size,\n"\
                    "            #ifndef MRT_NO_NAMES\n"\
                    "        .name = \"$Attribute\"\n"\
                    "            #endif /* MRT_NO_NAMES */\n"\
                    "    \},\n"
            }

            append attrrefs "\} ;\n"
        }

        if {[relation isnotempty $AEvents]} {
            append namerefs\
                "static char const *const ${Name}__ENAMES\["\
                [relation cardinality $AEvents]\
                "\] = \{\n"

            relation foreach event $AEvents -ascending EvtNumber {
                relation assign $event {Event eventName}
                append namerefs "    ${Name}_${eventName}__ENAME,\n"
            }

            append namerefs "\} ;\n"
        }

        append result\
            "    \[$Number\] = \{ // $Name\n"\
            "        .iab = $IAB,\n"\
            "        .eventCount = [relation cardinality $AEvents],\n"\
            "        .edb = $EDB,\n"\
            "        .pdb = $PDB,\n"\
            "        .relCount = $relCount,\n"\
            "        .classRels = $classRels,\n"\
            "        .attrCount = $attrCount,\n"\
            "        .classAttrs = $classAttrs,\n"\
            "        .instCount = [GetClassProperty $Name TotalInstance],\n"\
            "        .containment = $containment,\n"\
            "            #ifndef MRT_NO_NAMES\n"\
            "        .name = ${Name}__NAME,\n"\
            "        .eventNames = $eventNames,\n"\
            "            #endif /* MRT_NO_NAMES */\n"\
            "    \},\n"
    }

    append result "\} ;\n"

    return [string cat $front $namerefs $relrefs $attrrefs $result]
}
----

=== Assigner Definitions

[source,tcl]
----
<<generation code commands>>=
proc assignerDefinitions {} {
    variable domain

    append result [comment "Assigner Class Description Definitions"]

    set events [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        deRef ~ |
        relation join ~ $::micca::Event |
        relation eliminate ~ PSigID |
        relation rename ~ Model Association
    }]
    set assigners [pipe {
        AssignerStateModel findWhere {$Domain eq $domain} |
        deRef ~ |
        ralutil::rvajoin ~ $::micca::SingleAssigner Single |
        ralutil::rvajoin ~ $::micca::MultipleAssigner Multiple |
        relation join ~ $events |
        relation group ~ Events Event Number
    }]

    set result {}
    set attrResult {}
    set enameResult {}
    if {[relation isnotempty $assigners]} {
        set nassign [relation cardinality $assigners]
        append result\
            "static MRT_Class const ${domain}__ASSIGNERS\[$nassign\]= \{\n"\

        relation foreach assigner $assigners -ascending Association {
            relation assign $assigner

            append enameResult\
                "static char const *const ${Association}__ENAMES\["\
                [relation cardinality $Events]\
                "\] = \{\n"

            relation foreach event $Events -ascending Number {
                relation assign $event {Event eventName}
                append enameResult "    ${Association}_${eventName}__ENAME,\n"
            }

            append enameResult "\} ;\n"

            append result\
                "    \{ // $Association\n"\
                "        .iab = &${Association}__IAB,\n"\
                "        .eventCount = [relation cardinality $Events],\n"\
                "        .edb = &${Association}__EDB,\n"\
                "        .pdb = NULL,\n"
            if {[relation isnotempty $Single]} {
                append result\
                    "        .attrCount = 0,\n"\
                    "        .classAttrs = NULL,\n"\
            } else {
                relation assign $Multiple
                append attrResult\
                    "static MRT_Attribute const ${Association}__CATTRS\[1\] = \{\n"\
                    "    \{\n"\
                    "        .offset = offsetof(struct $Association, idinstance),\n"\
                    "        .size = sizeof([GetClassProperty $Class Reference]),\n"\
                    "            #ifndef MRT_NO_NAMES\n"\
                    "        .name = multi_assigner_attribute__NAME\n"\
                    "            #endif /* MRT_NO_NAMES */\n"\
                    "    \}\n"\
                    "\} ;\n"
                append result\
                    "        .attrCount = 1,\n"\
                    "        .classAttrs = ${Association}__CATTRS,\n"\
            }
            set ninst [GetClassProperty $Association TotalInstance]
            append result\
                "        .instCount = $ninst,\n"\
                "        .relCount = 0,\n"\
                "        .classRels = NULL,\n"\
                "        .containment = NULL,\n"\
                "            #ifndef MRT_NO_NAMES\n"\
                "        .name = ${Association}__NAME,\n"\
                "        .eventNames = ${Association}__ENAMES,\n"\
                "            #endif /* MRT_NO_NAMES */\n"\
                "    \},\n"
        }
        append result "\} ;\n"
    }

    return [string cat $enameResult $attrResult $result]
}
----

=== Relationship Description Definitions

----
<<generation code commands>>=
proc relationshipDefinitions {} {
    variable domain
    set subroles {}

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    if {[isEmptyRef $relRefs]} {
        return
    }
    append result "static MRT_Relationship const\
        ${domain}__RSHIPS\[[refMultiplicity $relRefs]\] = \{\n"

    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    forAllRefs relRef $relRefs {
        assignAttribute $relRef {Name relName} Number
        append result "$indent\[$Number\] = \{ // $relName\n"

        # Simple Association
        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 SimpleAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set sourceRef [findRelated $typeRef ~R32]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R40 R41] Number]

            set targetRef [findRelated $typeRef ~R33]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set tMult false
            set stype mrtSingular
            set slink 0

            set tcomp [findRelated $targetRef R38 R94 R28]
            lassign [FindRelOffsets $tcomp] ttype tlink

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    $relName)"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    [readAttribute $tcomp Name])"

            append result\
                "$indent2.relType = mrtSimpleAssoc,\n"\
                "$indent2.relInfo.simpleAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\}\n"

            append result\
                "$indent2\},\n"\
                "${indent3}#ifndef MRT_NO_NAMES\n"\
                "$indent2.name = ${relName}__NAME\n"\
                "${indent3}#endif /* MRT_NO_NAMES */\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 ClassBasedAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set sourceRef [findRelated $typeRef ~R34]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R40 R41] Number]

            set targetRef [findRelated $typeRef ~R35]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}\
                {Multiplicity tMult}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set asstorRef [findRelated $typeRef ~R42]
            assignAttribute $asstorRef {Class aClass}
            set aNum [readAttribute [findRelated $asstorRef R40 R41] Number]

            set scomp [findRelated $sourceRef R95 R28]
            lassign [FindRelOffsets $scomp] stype slink

            set tcomp [findRelated $targetRef R38 R94 R28]
            lassign [FindRelOffsets $tcomp] ttype tlink

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    [readAttribute $scomp Name])"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    [readAttribute $tcomp Name])"

            append result\
                "$indent2.relType = mrtClassAssoc,\n"\
                "$indent2.relInfo.classAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink,\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\},\n"

            set aClassDecl [GetClassProperty $aClass Declaration]
            set aClassForw "offsetof($aClassDecl, ${relName}.forward)"
            set aClassBack "offsetof($aClassDecl, ${relName}.backward)"
            append result\
                "$indent3.associator = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$aNum\], // $aClass\n"\
                "$indent4.forwardOffset = $aClassForw,\n"\
                "$indent4.backwardOffset = $aClassBack,\n"\
                "$indent3\}\n"

            append result\
                "$indent2\},\n"\
                "${indent3}#ifndef MRT_NO_NAMES\n"\
                "$indent2.name = ${relName}__NAME\n"\
                "${indent3}#endif /* MRT_NO_NAMES */\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 ReferenceGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R36]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R48 R40 R41] Number]

            set subRefs [findRelated $typeRef ~R37]
            set subClasses [findRelated $subRefs R47 R40 R41]

            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"}\
                    storageOffset string {
                        "offsetof([GetClassProperty\
                            [tuple extract $stup Class] Declaration],\
                            $relName)"} |
                relation project ~ Class classDesc storageOffset
            }]

            append subroles "static struct mrtrefsubclassrole const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs -ascending Class {
                relation assign $sub
                append subroles\
                    "    \{\n"\
                    "        .classDesc = $classDesc,\n"\
                    "        .storageOffset = $storageOffset\n"\
                    "    \},\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtRefGeneralization,\n"\
                "$indent2.relInfo.refGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\},\n"\
                "${indent3}#ifndef MRT_NO_NAMES\n"\
                "$indent2.name = ${relName}__NAME\n"\
                "${indent3}#endif /* MRT_NO_NAMES */\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 UnionGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R44]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R48 R40 R41] Number]
            set subRefs [findRelated $typeRef ~R45]
            set subClasses [findRelated $subRefs R47 R40 R41]
            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"} |
                relation project ~ Class classDesc
            }]

            append subroles "static MRT_Class const * const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs -ascending Class {
                relation assign $sub
                append subroles "    $classDesc\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtUnionGeneralization,\n"\
                "$indent2.relInfo.unionGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\},\n"\
                "${indent3}#ifndef MRT_NO_NAMES\n"\
                "$indent2.name = ${relName}__NAME\n"\
                "${indent3}#endif /* MRT_NO_NAMES */\n"\
                "$indent\},\n"
            continue
        }
    }

    append result "\} ;\n"

    return [string cat\
        [comment "Relationship Description Definitions"]\
        $subroles\
        $result\
    ]
}
----

[source,tcl]
----
<<generation helper commands>>=
proc FindRelOffsets {complRef} {
    set typeRef [findRelated $complRef {~R26 SingularReference}]
    set offset 0
    if {[isNotEmptyRef $typeRef]} {
        set type mrtSingular
    } else {
        set typeRef [findRelated $complRef {~R26 ArrayReference}]
        if {[isNotEmptyRef $typeRef]} {
            set type mrtArray
        } else {
            set typeRef [findRelated $complRef {~R26 LinkReference}]
            set type mrtLinkedList
            assignAttribute [findRelated $typeRef ~R27]\
                {Class lClass} {Name lcomp}
            set offset "offsetof([GetClassProperty $lClass Declaration], $lcomp)"
        }
    }
    return [list $type $offset]
}
----

[source,tcl]
----
<<generation code commands>>=
proc MapToCardinality {cond mult} {
    if {$cond && !$mult} {
        return mrtAtMostOne
    } elseif {!$cond && !$mult} {
        return mrtExactlyOne
    } elseif {$cond && $mult} {
        return mrtZeroOrMore
    } elseif {!$cond && $mult} {
        return mrtOneOrMore
    }
}
----

=== Class Instance Definitions

[source,tcl]
----
<<generation code commands>>=
proc classInstanceDefinitions {} {
    variable domain
    variable staticMultiRefs {}

    set classRefs [FindNonUnionSubclasses $domain]
    set classpops [FindClassPopulation $classRefs]

    set result [comment "Instance Pool Definitions"]
    relation foreach classpop $classpops -ascending ClassNumber {
        relation assign $classpop

        append result\
            "static struct $Class "\
            [GetClassProperty $Class StorageVariable]\
            "\[[GetClassProperty $Class TotalInstance]\] = \{\n"

        relation foreach inst $Instances -ascending InstNumber {
            append result [GenInstanceInitializers $Class $ClassNumber $inst]
        }

        append result "\} ;\n"
    }

    if {$staticMultiRefs ne {}} {
        set staticMultiRefs [string cat\
            [comment "Static Reference Definitions"] $staticMultiRefs]
    }
    return [string cat $staticMultiRefs $result]
}
----

[source,tcl]
----
<<generation code commands>>=
proc FindClassPopulation {classRefs} {
    set classes [pipe {
        deRef $classRefs |
        relation rename ~ Name Class Number ClassNumber
    }]

    set compRefs [findRelated $classRefs ~R20]

    # Populated Components
    set popCompRefs [findRelated $compRefs {~R25 PopulatedComponent}]

    # Attribute Components
    set attrs [pipe {
        findRelated $popCompRefs {~R21 Attribute} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $attrs attrs]

    # Reference Components
    # For the populated reference components we will go ahead and
    # compute the class to which the reference is made.
    set refCompRefs [findRelated $popCompRefs {~R21 Reference}]

    # Superclass Reference Component
    set screfs [findRelated $refCompRefs {~R23 SuperclassReference}]
    set refedsuper [pipe {
        findRelated $screfs ~R91 {~R47 ReferringSubclass} R37 ~R36 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class SuperClass Relationship Component
    } {} |%]
    set superrefs [pipe {
        deRef $screfs |
        relation rename ~ Name Component |
        relation join ~ $refedsuper
    }]
    # puts [relformat $superrefs superrefs]

    # Associator Reference Components
    set arrefs [findRelated $refCompRefs {~R23 AssociatorReference}]
    set cbainfo [pipe {
        findRelated $arrefs ~R93 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class AssociatorClass |
        relation join % $::micca::SourceClass |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class SourceClass |
        relation join % $::micca::TargetClass |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class TargetClass AssociatorClass Class\
                Relationship Component
    } {} |%]
    set atorrefs [pipe {
        deRef $arrefs |
        relation rename ~ Name Component |
        relation join ~ $cbainfo
    }]
    # puts [relformat $atorrefs atorrefs]

    # Association Reference Components
    set asrrefs [findRelated $refCompRefs {~R23 AssociationReference}]
    set srcinfo [pipe {
        findRelated $asrrefs ~R90 R32 ~R33 |
        deRef % |
        relation eliminate % Role Conditionality |
        relation rename % Class ReferencedClass Relationship Component
    } {} |%]
    set assocrefs [pipe {
        deRef $asrrefs |
        relation rename ~ Name Component |
        relation join ~ $srcinfo
    }]
    # puts [relformat $assocrefs assocrefs]

    # Generated components
    set genCompRefs [findRelated $compRefs {~R25 GeneratedComponent}]

    # Subclass Reference Components
    set subrefs [pipe {
        findRelated $genCompRefs {~R24 SubclassReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $subrefs subrefs]

    # Subclass Container
    set subconts [pipe {
        findRelated $genCompRefs {~R24 SubclassContainer} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $subconts subconts]

    # Link Container
    set linkconts [pipe {
        findRelated $genCompRefs {~R24 LinkContainer} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $linkconts linkconts]

    # Complementary Reference
    set complRefs [findRelated $genCompRefs {~R24 ComplementaryReference}]

    # Singular Reference
    set singRefs [pipe {
        findRelated $complRefs {~R26 SingularReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $singRefs singRefs]

    # Array Reference
    set arrayRefs [pipe {
        findRelated $complRefs {~R26 ArrayReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $arrayRefs arrayRefs]

    # Link Reference
    set linkRefs [pipe {
        findRelated $complRefs {~R26 LinkReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $linkRefs linkRefs]

    set classpops [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation rename % Number InstNumber |
        relation join % $classes $::micca::ClassComponentValue |
        ralutil::rvajoin % $attrs Attributes |
        ralutil::rvajoin % $superrefs SuperRefs |
        ralutil::rvajoin % $atorrefs AssociatorRefs |
        ralutil::rvajoin % $assocrefs AssociationRefs |
        ralutil::rvajoin % $subrefs SubRefs |
        ralutil::rvajoin % $subconts SubclassContainers |
        ralutil::rvajoin % $linkconts LinkContainers |
        ralutil::rvajoin % $singRefs SingularRefs |
        ralutil::rvajoin % $arrayRefs ArrayRefs |
        ralutil::rvajoin % $linkRefs LinkRefs |
        relation group % Components Component Value Attributes SuperRefs\
            AssociatorRefs AssociationRefs SubRefs SubclassContainers\
            LinkContainers SingularRefs ArrayRefs LinkRefs |
        relation group % Instances Instance InstNumber Components |
        relation eliminate % Domain
    } {} |%]
    # puts [relformat $classpops classpops]

    return $classpops
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenInstanceInitializers {className classNumber inst} {
    variable domain
    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    relation assign $inst

    set sp [pipe {
        StateModel findById Domain $domain Model $className |
        findRelated ~ R58 R57
    }]
    set initstate [expr {[isNotEmptyRef $sp] ?\
        [readAttribute $sp Number] : "MRT_StateCode_IG"}]

    append result\
        "$indent\{ // $Instance\n"\
        "$indent2.base__INST = \{\n"\
        "$indent3.classDesc = &${domain}__CLASSES\[$classNumber\],\n"\
        "$indent3.alloc = [expr {$InstNumber + 1}],\n"\
        "$indent3.currentState = $initstate,\n"\
        "$indent3.refCount = 0,\n"\
        "${indent4}#ifndef MRT_NO_NAMES\n"\
        "$indent3.name = \"$Instance\"\n"\
        "${indent4}#endif /* MRT_NO_NAMES */\n"\
        " $indent2\},\n"

    relation foreach comp $Components {
        relation assign $comp
        if {[relation isnotempty $Attributes]} {
            append result "$indent2.$Component = $Value,\n"
            continue
        }

        if {[relation isnotempty $SuperRefs]} {
            set superclass [relation extract $SuperRefs SuperClass]
            append result\
                "$indent2.$Component = "\
                [GenInstanceAddress $domain $superclass $Value],\n
            continue
        }

        if {[relation isnotempty $AssociatorRefs]} {
            relation assign $AssociatorRefs
            # the painful reflexive case again!
            if {$SourceClass eq $TargetClass} {
                # N.B. the inversion. the target instance is the
                # one referenced in the forward direction
                set sinstname [dict get $Value backward]
                set tinstname [dict get $Value forward]
            } else {
                set sinstname [dict get $Value $SourceClass]
                set tinstname [dict get $Value $TargetClass]
            }
            set sourceaddr [GenInstanceAddress $domain $SourceClass\
                $sinstname]
            set targetaddr [GenInstanceAddress $domain $TargetClass\
                $tinstname]

            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.forward = $targetaddr,\n"\
                "$indent3.backward = $sourceaddr\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $AssociationRefs]} {
            set refvalue [expr {$Value eq "@nil@" ?\
                "NULL" : [GenInstanceAddress $domain\
                    [relation extract $AssociationRefs ReferencedClass]\
                    $Value]}]
            append result "$indent2.$Component = $refvalue,\n"
            continue
        }

        if {[relation isnotempty $SubRefs]} {
            lassign $Value subclass subinstname
            set subinstaddr [GenInstanceAddress $domain $subclass $subinstname]
            append result "$indent2.$Component = $subinstaddr,\n"
            continue
        }

        if {[relation isnotempty $SubclassContainers]} {
            lassign $Value subclass subinst

            set subRef [Class findWhere {$Domain eq $domain &&\
                $Name eq $subclass}]
            set subpops [FindClassPopulation $subRef]
            # puts [relformat $subpops subpops]

            relation assign $subpops {Class subclassName}\
                {ClassNumber subclassNumber} {Instances subInstances}
            set instpop [relation restrictwith $subInstances\
                {$Instance eq $subinst}]

            append result\
                "$indent2.$Component.$subclass = "\
                [string trimleft [indentCode [GenInstanceInitializers\
                    $subclassName $subclassNumber $instpop] 8]]
            continue
        }

        if {[relation isnotempty $LinkContainers]} {
            lassign [dict get $Value next] nclass ninst ncomp
            set nextaddr [GenInstanceAddress $domain $nclass $ninst]
            lassign [dict get $Value prev] pclass pinst pcomp
            set prevaddr [GenInstanceAddress $domain $pclass $pinst]
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $nextaddr.$ncomp,\n"\
                "$indent3.prev = $prevaddr.$pcomp\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $SingularRefs]} {
            if {$Value eq "@nil@"} {
                set refaddr NULL
            } else {
                lassign $Value refclass refinst
                set refaddr [GenInstanceAddress $domain $refclass $refinst]
            }
            append result "$indent2.$Component = $refaddr,\n"
            continue
        }

        if {[relation isnotempty $ArrayRefs]} {
            if {$Value eq "@nil@"} {
                set refcount 0
                set refaddr NULL
            } else {
                lassign $Value refclass refinsts
                set refcount [llength $refinsts]
                set refaddr ${Component}_${className}_${InstNumber}

                # Build reference array
                variable staticMultiRefs
                append staticMultiRefs\
                    "static [GetClassProperty $refclass Reference]\
                        const $refaddr\[$refcount\] = \{\n"
                foreach inst $refinsts {
                    append staticMultiRefs\
                        "$indent[GenInstanceAddress $domain $refclass $inst],\n"
                }
                append staticMultiRefs "\} ;\n"
            }
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.links = $refaddr,\n"\
                "$indent3.count = $refcount\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $LinkRefs]} {
            lassign [dict get $Value next] nclass ninst ncomp
            set nextaddr [GenInstanceAddress $domain $nclass $ninst]
            lassign [dict get $Value prev] pclass pinst pcomp
            set prevaddr [GenInstanceAddress $domain $pclass $pinst]
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $nextaddr.$ncomp,\n"\
                "$indent3.prev = $prevaddr.$pcomp\n"\
                "$indent2\},\n"
            continue
        }
    }

    append result "$indent\},\n"

    return $result
}
----

=== Assigner Instance Definitions

[source,tcl]
----
<<generation code commands>>=
proc assignerInstanceDefinitions {} {
    variable domain
    set result {}

    append result [comment "Single Assigner Instance Definitions"]
    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $singles {
        set initstate [pipe {
            findRelated $assigner R53 R50 R58 R57 |
            readAttribute ~ Number
        }]
        assignAttribute $assigner
        set instnum [GetClassProperty $Association Number]
        append result\
            "static struct $Association ${Association}__POOL\[1\] = \{\n"\
            "    \{\n"\
            "        .base__INST = \{\n"\
            "            .classDesc = &${domain}__ASSIGNERS\[$instnum\],\n"\
            "            .alloc = 1,\n"\
            "            .currentState = $initstate,\n"\
            "            .refCount = 0,\n"\
            "                #ifndef MRT_NO_NAMES\n"\
            "            .name = single_assigner_instance__NAME\n"\
            "                #endif /* MRT_NO_NAMES */\n"\
            "        \}\n"\
            "    \}\n"\
            "\} ;\n"
    }

    append result [comment "Multiple Assigner Instance Definitions"]
    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        assignAttribute $multi
        set initstate [pipe {
            findRelated $multi R53 R50 R58 R57 |
            readAttribute ~ Number
        }]

        set multiinsts [findRelated $multi ~R106]
        if {[isNotEmptyRef $multiinsts]} {
            set totalinsts [GetClassProperty $Class TotalInstance]
            set instnum [GetClassProperty $Association Number]
            append result "static struct $Association\
                    ${Association}__POOL\[$totalinsts\] = \{\n"
            forAllRefs assigner $multiinsts {
                assignAttribute $assigner
                set allocnum 0
                append result\
                    "    \[$Number\] = \{\n"\
                    "        .base__INST = \{\n"\
                    "            .classDesc = &${domain}__ASSIGNERS\[$instnum\],\n"\
                    "            .alloc = [incr allocnum],\n"\
                    "            .currentState = $initstate,\n"\
                    "            .refCount = 0,\n"\
                    "                #ifndef MRT_NO_NAMES\n"\
                    "            .name = \"$Instance\"\n"\
                    "                #endif /* MRT_NO_NAMES */\n"\
                    "        \},\n"\
                    "        .idinstance = [GenInstanceAddress $domain $IdClass\
                            $IdInstance]\n"\
                    "    \},\n"\
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

=== Operation Definitions

[source,tcl]
----
<<generation code commands>>=
proc operationDefinitions {} {
    variable domain

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    set result [comment "Operation Definitions"]
    relation foreach op $ops {
        relation assign $op
        append result\
            "static $ReturnDataType\n${Class}_$Operation"

        if {[relation isempty $Parameters]} {
            append result "\(void\)\n"
            set syms [relation create {
                Name string Ctype string Type string Class string
            }]
        } else {
            set pdecls {}
            relation foreach param $Parameters -ascending Number {
                relation assign $param
                append pdecls\
                    [typeCheck composeDeclaration $DataType $Name]\
                    ,\n
            }
            set pdecls [string trimright $pdecls ",\n"]\)\n
            append result\
                "\(\n"\
                [indentCode $pdecls]

            set syms [pipe {
                relation project $Parameters Name DataType |
                relation rename ~ DataType Ctype |
                relation extend ~ stup\
                    Type string {{}}\
                    Class string {{}} |
                relation update ~ utup {
                    [tuple extract $utup Name] eq "self"} {
                    tuple update $utup Type Reference Class $Class
                }
            }]
        }

        append result\
            [blockcomment $Body]\
            "\{\n"\
            "    MRT_INSTRUMENT_ENTRY\n"\
            [ExpandActivity "$Operation operation" $Body $syms]\
            "\}\n"
    }

    return $result
}
----

=== Constructor Definitions

[source,tcl]
----
<<generation code commands>>=
proc ctorDefinitions {} {
    return [TorDefinitions Constructor]
}
----

[source,tcl]
----
<<generation code commands>>=
proc TorDefinitions {which} {
    variable domain
    set suffixmap [dict create\
        Constructor CTOR\
        Destructor DTOR\
    ]
    set result {}

    set tors [$which findWhere {$Domain eq $domain}]

    if {[isNotEmptyRef $tors]} {
        append result [comment "$which Definitions"]
        forAllRefs tor $tors {
            assignAttribute $tor

            set selfdecl [GetClassProperty $Class Reference]const
            set syms [relation create {
                Name string Ctype string Type string Class string
            } [list Name self Ctype $selfdecl Type Reference Class $Class]]
            append result\
                "static void\n${Class}__[dict get $suffixmap $which]\(\n"\
                "    void *const s__SELF\)\n"\
                [blockcomment $Body]\
                "\{\n"\
                [string cat\
                    "    MRT_INSTRUMENT_ENTRY\n"\
                    "    $selfdecl self = s__SELF ;\n"\
                    [ExpandActivity "$Class $which" $Body $syms]\
                ]\
                "\}\n"
        }
    }

    return $result
}
----

=== Destructor Definitions

[source,tcl]
----
<<generation code commands>>=
proc dtorDefinitions {} {
    return [TorDefinitions Destructor]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-17.0 {
    Generated code file with constructor and destructor
} -setup {
    # makeFile {} codegen17.h
    # makeFile {} codegen17.c
    micca configure {
        domain codegen17 {
            domainop void initialize {} {
                codegen17__INIT() ;
            }

            class X {
                attribute color int -default 20

                constructor {
                    self->color += 20 ;
                }
                destructor {
                    self->color -= 20 ;
                }
            }
        }
        population codegen17 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {CTOR} codegen17.c]] == 4}\
        {[llength [fileutil::grep {DTOR} codegen17.c]] == 3}
} -result {1}
----
endif::showtests[]

=== Activity Definitions

[source,tcl]
----
<<generation code commands>>=
proc activityDefinitions {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && [string trim $Activity] ne {}} |
        deRef ~ |
        relation eliminate ~ Domain IsTerminal |
        relation group ~ States Name Activity PSigID
    }]
    # puts [relformat $classes classes]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Definitions"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            append result "#define MRT_CLASSNAME \"$Model\"\n"
            relation foreach state $States {
                relation assign $state
                set selfdecl [GetClassProperty $Model Reference]const
                append result\
                    "static void\n${Model}_${Name}__ACTIVITY\(\n"\
                    "    void *const s__SELF,\n"\
                    "    void const *const p__PARAMS)\n"\
                    [blockcomment $Activity]\
                    "\{\n"\
                    "        #define MRT_STATENAME \"$Name\"\n"\
                    "    MRT_INSTRUMENT_ENTRY\n"\
                    "    $selfdecl self = s__SELF ;\n"
                if {$PSigID ne {}} {
                    set signame ${Model}_${Name}__SPARAMS
                    append result\
                        "    struct $signame const *const pp__PARAMS = p__PARAMS ;\n"
                    set params [pipe {
                        ParameterSignature findById Domain $domain PSigID $PSigID |
                        FindParamsFromSig ~
                    }]
                    relation foreach param $params -ascending Position {
                        relation assign $param {Name pname} Declaration
                        append result "    $Declaration = pp__PARAMS->$pname ;\n"
                    }

                    set syms [pipe {
                        relation project $params Name Declaration |
                        relation rename ~ Declaration Ctype |
                        relation extend ~ stup\
                            Type string {{}}\
                            Class string {{}}
                    }]
                } else {
                    set syms [relation create {
                        Name string Ctype string Type string Class string
                    }]
                }
                set syms [relation insert $syms [list Name self Ctype $selfdecl\
                        Type Reference Class $Model]]

                append result\
                    [ExpandActivity "$Model $Name activity" $Activity $syms]

                append result\
                    "        #undef MRT_STATENAME\n"\
                    "\}\n"
            }
            append result "#undef MRT_CLASSNAME\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc FindParamsFromSig {psigRef} {
    return [pipe {
        findRelated $psigRef ~R79 |
        deRef % |
        relation join % $::micca::Argument |
        relation extend % ptup Declaration string {\
            [typeCheck composeDeclaration\
                [tuple extract $ptup DataType]\
                [tuple extract $ptup Name]]}
    } {} |%]
}
----

=== Domain Constructor Definition

[source,tcl]
----
<<generation code commands>>=
proc domainCtorDefinition {} {
    variable domain
    set result {}

    set ctorinsts [pipe {
        Constructor findWhere {$Domain eq $domain} |
        deRef ~ |
        relation eliminate ~ Body |
        relation join ~ $::micca::ClassInstance |
        relation group ~ Instances Instance Number
    }]

    if {[relation isnotempty $ctorinsts]} {
        append result [comment "Definition of Function to Construct\
            Initial Instances"]
        relation foreach ctorinst $ctorinsts {
            relation assign $ctorinst
            relation foreach instance $Instances -ascending Number {
                relation assign $instance
                append invocations\
                    "${Class}__CTOR\("\
                    [GenInstanceAddress $domain $Class $Instance]\
                    "\) ;\n"
            }
        }
        append result\
            "static void\n${domain}__INIT\(void\)\n"\
            "\{\n"\
            [indentCode $invocations]\
            "\}\n"
    }

    return $result
}
----

=== Domain Operation Definitions

[source,tcl]
----
<<generation code commands>>=
proc domainOpDefinitions {} {
    variable domain
    set result {}

    set ops [pipe {
        DomainOperation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::DomainOperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Domain Operation Definitions"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "$ReturnDataType\n${domain}_${Operation}"

            if {[relation isempty $Parameters]} {
                set decl "\(void\)\n"
                append result $decl
                set syms [relation create {
                    Name string Ctype string Type string Class string
                }]
            } else {
                set pdecls {}
                relation foreach param $Parameters -ascending Number {
                    relation assign $param
                    append pdecls\
                        [typeCheck composeDeclaration $DataType $Name]\
                        ,\n
                }
                set pdecls [string trimright $pdecls ",\n"]\)\n
                set decl [string cat\
                    "\(\n"\
                    [indentCode $pdecls]\
                ]
                append result $decl
                set syms [pipe {
                    relation project $Parameters Name DataType |
                    relation rename ~ DataType Ctype |
                    relation extend ~ stup\
                        Type string {{}}\
                        Class string {{}}
                }]
            }

            append result\
                [blockcomment $Body]\
                "\{\n"\
                "    MRT_INSTRUMENT_ENTRY\n"\
                [ExpandActivity "$Operation domain operation" $Body $syms]\
                "\}\n"
        }
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-18.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -setup {
    # makeFile {} codegen18.h
    # makeFile {} codegen18.c
    micca configure {
        domain codegen18 {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }

            class X {
                attribute color int -default 10
            }
        }
        population codegen18 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {codegen18_color} codegen18.c]] == 1}
} -result {1}
----
endif::showtests[]

=== External Operation Definitions

[source,tcl]
----
<<generation code commands>>=
proc externalOpDefinitions {} {
    upvar #0 [namespace parent]::options options
    if {![dict get $options stubexternalops]} {
        return
    }

    variable domain
    set result {}

    set ops [pipe {
        ExternalOperation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::ExternalOperationParameter Parameters
    }]

    append result [comment "External Operation Stub Definitions"]
    relation foreach op $ops {
        relation assign $op
        append result\
            "$ReturnDataType\n${domain}_${Operation}__EOP"

        if {[relation isempty $Parameters]} {
            append result "\(void\)\n"
            set syms [relation create {
                Name string Ctype string Type string Class string
            }]
        } else {
            set pdecls {}
            relation foreach param $Parameters -ascending Number {
                relation assign $param
                append pdecls\
                    [typeCheck composeDeclaration $DataType $Name]\
                    ,\n
            }
            set pdecls [string trimright $pdecls ",\n"]\)\n
            append result\
                "\(\n"\
                [indentCode $pdecls]
            set syms [pipe {
                relation project $Parameters Name DataType |
                relation rename ~ DataType Ctype |
                relation extend ~ stup\
                    Type string {{}}\
                    Class string {{}}
            }]
        }

        append result\
            [blockcomment $Body]\
            "\{\n"\
            [ExpandActivity "$Operation external operation" $Body $syms]\
            "\}\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-19.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -setup {
    # makeFile {} codegen19.h
    # makeFile {} codegen19.c
    micca configure {
        domain codegen19 {
            externalop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }

            class X {
                attribute color int -default 10
            }
        }
        population codegen19 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate stubexternalops true
    testConditions\
        {[llength [fileutil::grep {codegen19_color__EOP} codegen19.c]] == 1}
} -result {1}
----
endif::showtests[]

=== Portal Data Definitions

[source,tcl]
----
<<generation code commands>>=
proc portalDefinition {} {
    variable domain

    set classRefs [Class findWhere {$Domain eq $domain}]
    set assignRefs [AssignerStateModel findWhere {$Domain eq $domain}]
    set acount [refMultiplicity $assignRefs]
    set aptr [expr {$acount == 0 ? "NULL" : "${domain}__ASSIGNERS"}]
    append result\
        [comment "Domain Portal Definition"]\
        "MRT_DomainPortal ${domain}__PORTAL = \{\n"\
        "    .classCount = [refMultiplicity $classRefs],\n"\
        "    .classes = ${domain}__CLASSES,\n"\
        "    .assignerCount = $acount,\n"\
        "    .assigners = $aptr,\n"\
        "        #ifndef MRT_NO_NAMES\n"\
        "    .name = \"$domain\"\n"\
        "        #endif /* MRT_NO_NAMES */\n"\
        "\} ;\n"
}
----

=== Epilogue Declarations

[source,tcl]
----
<<generation code commands>>=
proc epilogueDeclarations {} {
    variable epilogue

    return [string cat\
        [comment "Domain Epilogue"]\
        [indentCode [string trim $epilogue \n] 0]\
    ]
}
----

== Generating Activity Code

In this section we discuss the macro commands that are available
to a translator for easing the burden of translating model level
execution into the required ``C'' code.
When using `micca` to translate a model,
state activities are coded in ``C'' and passed along to the generated
code file.
To make coding model level actions easier,
the ``C'' code supplied by the translator for state activities and other
operations can contain embedded macros which are further expanded
by the code generator.
The macros are simple commands with arguments that are enclosed
in the special delimiters *%<* and *>%*.
For example,
the macro to access the *Color* attribute of an instance could be written
as:

*****
ColorType c = %<my attribute Color>% ;
*****

For this example,
the code generator expands the commands contained between the *%<*
and *>%* delimiters and replaces the embedded macro with ``C'' code required to
access the value of the *Color* attribute of the instance referenced by the
value of the *self* variable.
This is a very simple case, but even here the code generator
performs a number of significant checks in an attempt to discover
errors before code is sent to the compiler.
In this case, the code generator insures that the attribute named
*Color* exists for the class to which the `self` instance refers.

There are many of these macro commands to handle common model level
processing.
State activities are then a mix of ``C'' code and embedded macros commands
to accomplish the purpose of the activity.
The straight ``C'' contains the algorithmic processing and the
expanded macros handle the model level actions such as navigating
relationships, finding instances and dealing with attribute updates.
These types of model level actions must account for the data structures
and naming conventions that the run-time code uses.
Since the code generator has access to the populated platform model,
it performs many consistency checks that would otherwise result in
compiler errors.
Discovering errors earlier makes them much easier to correct since
relating compiler error messages back to the `micca` source
becomes more difficult in the face of another level of translation.

The macro commands expand to one of three types of ``C'' constructs:

. A macro command may expand to a statement in ``C''.
For statement macros,
the expansion yields one or more lines of code and the code generator
takes care of the semicolon punctuation.
. A macro command may expand to an expression in ``C''.
For expression macros,
the code generator just replaces the macro and does not add any punctuation.
This enables a expression macro to be used inside of another ``C'' expression.
. A macro command may expand to a construct in ``C'' requiring a
compound statement.
For macros generating compound statements,
additional ``C'' code is included in the compound statement body and
the end of the loop is given by invoking the `%<end>%` macro.
Typically, the these macros allow iteration over sets of instances
and the compound statement body is executed once for
each instance.

In the descriptions below we state the expansion type of each macro.

=== Expanding the Activities Macros

Just as we have been using the `textutil::expander` command to perform
macro expansion for generating the header and code files,
we will use it to expand the embedded macros in the state activities.
We will use a separate instance of the the expander and will direct
this expansion to happen in its own namespace.
The namespace will allow us to define the macro commands so that the commands
will resolve with unqualified names.
We will also use a namespace to handle the details of the expansion code
itself.
Following our usual pattern,
we define the namespace for the generation of the embedded macros.

[source,tcl]
----
<<generation support namespace>>=
namespace eval GenSupport {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar

    namespace export ExpandActivity

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }
    upvar #0 ::micca::@Gen@::errcount errcount

    textutil::expander actexpand
    actexpand setbrackets %< >% ; # <1>
    actexpand evalcmd "namespace eval [namespace parent]::GenActivity"
    actexpand errmode fail
    actexpand textcmd [namespace current]::ProcessCodeLines

    <<generation support data>>
    <<generation support commands>>
}
----
<1> The default way to embed commands in the template is with
the conventional Tcl brackets ([ ]).
Those characters are inconvenient in ``C'' so we use bracket strings
that create less interference.

=== Creating the Macro Commands

The commands available for embedding into ``C'' activity code
are organized into groups.

* A command to invoke external operations.
* Commands related to classes.
* Commands related to relationships.
* Commands related to instances.
* Commands related to instance sets.

Each of these different command groups are discussed in sections below.
Since we are using a template expander to expand the commands,
in this section we show how the expansion commands are created.

For classes and relationships,
embedded macro commands named after the classes and relationships themselves
are created.
For example, if the domain contains a class named `WashingMachine`,
then there will be an embedded command named `WashingMachine`
that can be used to access class level functions specific to the
`WashingMachine` class.
The same holds true for a relationship.
If `R27` exists in the domain, then there will be an embedded command
named `R27` that can be used to relate and unrelate instances
across the relationship.
To insure that there is no conflict in names,
we will create the embedded commands in their own namespace,
`GenActivity` as a child namespace of `GenSupport`.
Since all classes (or relationships) have the same set of subcommands
available to them, we will namespace ensembles to obtain the
``object oriented'' Tcl style for the embedded commands.

[source,tcl]
----
<<generation commands>>=
proc CreateActivityCommands {domain} {
    namespace eval GenActivity {
        logger::initNamespace [namespace current]
    }

    set currns [namespace current]
    set actns ${currns}::GenActivity
    set suppns ${currns}::GenSupport

    <<CreateActivityCommands: classes>>
    <<CreateActivityCommands: relationships>>
    <<CreateActivityCommands: instances>>
    <<CreateActivityCommands: instance sets>>

    interp alias {} ${actns}::external {} ${suppns}::InvokeExternalOp
    interp alias {} ${actns}::end {} ${suppns}::End
}
----

We see that the code is sectioned into four chunks based on what
the namespace ensemble command refers to.

First,
we query some information about the classes in the domain we are
generating.
The class commands will vary depending upon:
\(1) the class having a defined state model and
\(2) if a class with a state model has creation events.

[source,tcl]
----
<<CreateActivityCommands: classes>>=
set classInfo [pipe {
    Class findWhere {$Domain eq $domain} |
    deRef ~ |
    ralutil::rvajoin ~ [relation rename $::micca::StateModel Model Name]\
        StateModels |
    relation extend ~ itup HasStateModel boolean {
        [relation isnotempty [tuple extract $itup StateModels]]} |
    ralutil::rvajoin ~\
        [relation rename $::micca::CreationState Name State Model Name]\
        CreationStates |
    relation extend ~ ctup HasCreationState boolean {
        [relation isnotempty [tuple extract $ctup CreationStates]]} |
    relation project ~ Name HasStateModel HasCreationState
}]
----

We first need to find out all the union subclass names.
As usual, union subclasses have to be treated a bit differently.
A union subclass cannot be created either synchronously or asynchronously.
A union subclass can only be migrated as part of a generalization.

[source,tcl]
----
<<CreateActivityCommands: classes>>=
set usubnames [pipe {
    UnionSubclass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation list ~ Class
}]
----

We now iterate over the classes for the domain and construct the
namespace ensemble command map.
Command maps are the key to ensemble commands and allow you to
forward the command invocation with additional information
(in this case the name of the class).

[source,tcl]
----
<<CreateActivityCommands: classes>>=
set cmdmap [dict create]
relation foreach info $classInfo {
    relation assign $info
    set cmdmap [dict create\
        foreachInstance [list ${suppns}::ClassForeachInstance $Name]\
        foreachWhere [list ${suppns}::ClassForeachWhere $Name]\
        selectWhere [list ${suppns}::ClassSelectWhere $Name]\
        instref [list ${suppns}::ClassInstanceReference $Name]\
        idtoref [list ${suppns}::ClassIdToRef $Name]\
        instset [list ${suppns}::ClassInstanceSet $Name]\
        findByName [list ${suppns}::ClassFindByName $Name]\
        operation [list ${suppns}::ClassOperation $Name]\
    ]
    if {$Name ni $usubnames} {
        dict set cmdmap create [list ${suppns}::ClassCreate $Name]
        if {$HasStateModel} {
            dict set cmdmap createin [list ${suppns}::ClassCreateIn $Name]
        }
        if {$HasCreationState} {
            dict set cmdmap createasync [list ${suppns}::ClassCreateAsync $Name]
        }
    }
    namespace ensemble create\
        -command ${actns}::$Name\
        -map $cmdmap
}
----

For relationships,
we must consider each type of relationships separately.
As shown in the platform model,
the top level specialization of relationships is between
associations and generalizations.

[source,tcl]
----
<<CreateActivityCommands: relationships>>=
set relRefs [Relationship findWhere {$Domain eq $domain}]

<<CreateActivityCommands: associations>>
<<CreateActivityCommands: generalizations>>
----

The functions for association commands deal primarily with
relating and unrelating instances across the association.
Given the syntax for relationship traverals we have used,
we will also create a _forward_ and _backward_ command
to be used in relationship linkage.
Both these commands require the instance argument be provided in
a specific order, source then target for the forward command and
target then source for the backward command.
For example,
the association

.....
association R22 A 1..*--1 B
.....

will result in both a `R22` command and a `~R22` command.
Instances of `A` and `B` are related by using either command:

.....
%<R22 relate ainst binst>%
%<~R22 relate binst ainst>%
.....

Associations can also have an assigner defined for them.
In that case they need to be able to signal an event to the assigner.
In the case of a multiple assigner,
the relationship command also need to support creating an instance
of the assigner.
Associations are further specialized into simple associations and
class based associations.
All the permutations of these commands are considered below.

[source,tcl]
----
<<CreateActivityCommands: associations>>=
set assocs [findRelatedWhere $relRefs {{~R30 Association}} {!$IsStatic}]

<<CreateActivityCommands: simple associations>>
<<CreateActivityCommands: class based associations>>
----

[source,tcl]
----
<<CreateActivityCommands: simple associations>>=
set simpassocs [findRelated $assocs {~R31 SimpleAssociation}]
forAllRefs simpassoc $simpassocs {
    set simpname [readAttribute $simpassoc Name]
    set cmdmap [dict create\
        relate [list ${suppns}::RelSimpleRelateForw $simpname]\
        unrelate [list ${suppns}::RelSimpleUnrelateForw $simpname]\
    ]
    set assigner [findRelated $simpassoc R31 ~R52]
    if {[isNotEmptyRef $assigner]} {
        if {[isNotEmptyRef [findRelated $assigner {~R53 SingleAssigner}]]} {
            dict set cmdmap signal\
                [list ${suppns}::SingleAssignerSignal $simpname]
        } else {
            dict set cmdmap signal [list ${suppns}::InstanceSignal $simpname]
            dict set cmdmap create [list ${suppns}::MultiAssignerCreate $simpname]
        }
    }
    namespace ensemble create\
        -command ${actns}::$simpname\
        -map $cmdmap

    set cmdmap [dict create\
        relate [list ${suppns}::RelSimpleRelateBack $simpname]\
        unrelate [list ${suppns}::RelSimpleUnrelateBack $simpname]\
    ]
    namespace ensemble create\
        -command ${actns}::~$simpname\
        -map $cmdmap
}
----

[source,tcl]
----
<<CreateActivityCommands: class based associations>>=
set classassocs [findRelated $assocs {~R31 ClassBasedAssociation}]
forAllRefs classassoc $classassocs {
    set cbname [readAttribute $classassoc Name]
    set cmdmap [dict create\
        relate [list ${suppns}::RelClassRelateForw $cbname]\
        unrelate [list ${suppns}::RelClassUnrelateForw $cbname]\
    ]
    set assigner [findRelated $classassoc R31 ~R52]
    if {[isNotEmptyRef $assigner]} {
        if {[isNotEmptyRef [findRelated $assigner {~R53 SingleAssigner}]]} {
            dict set cmdmap signal\
                [list ${suppns}::SingleAssignerSignal $simpname]
        } else {
            dict set cmdmap signal [list ${suppns}::InstanceSignal $simpname]
            dict set cmdmap create [list ${suppns}::MultiAssignerCreate $simpname]
        }
    }
    namespace ensemble create\
        -command ${actns}::$cbname\
        -map $cmdmap

    set cmdmap [dict create\
        relate [list ${suppns}::RelClassRelateBack $cbname]\
        unrelate [list ${suppns}::RelClassUnrelateBack $cbname]\
    ]
    namespace ensemble create\
        -command ${actns}::~$cbname\
        -map $cmdmap
}
----

Generalization relationships are specialized into those using
references and those using unions.
The command distinction is that union generalizations only support
a single subcommand, namely `migrate`.
Given the storage arrangement for union generalizations,
relating and unrelating instances does not make sense
since subclass instances are bound to the storage of their superclass
instances..

[source,tcl]
----
<<CreateActivityCommands: generalizations>>=
set gens [findRelated $relRefs {~R30 Generalization}]

<<CreateActivityCommands: reference generalizations>>
<<CreateActivityCommands: union generalizations>>
----

[source,tcl]
----
<<CreateActivityCommands: reference generalizations>>=
set refgens [findRelated $gens {~R43 ReferenceGeneralization}]
foreach rgname [relation list [deRef $refgens] Name] {
    set cmdmap [dict create\
        relate [list ${suppns}::RelRefGenRelateForw $rgname]\
        unrelate [list ${suppns}::RelRefGenUnrelateForw $rgname]\
        reclassify [list ${suppns}::RelRefGenReclassify $rgname]\
    ]
    namespace ensemble create\
        -command ${actns}::$rgname\
        -map $cmdmap

    set cmdmap [dict create\
        relate [list ${suppns}::RelRefGenRelateBack $rgname]\
        unrelate [list ${suppns}::RelRefGenUnrelateBack $rgname]\
    ]
    namespace ensemble create\
        -command ${actns}::~$rgname\
        -map $cmdmap
}
----

[source,tcl]
----
<<CreateActivityCommands: union generalizations>>=
set uniongens [findRelated $gens {~R43 UnionGeneralization}]
foreach ugname [relation list [deRef $uniongens] Name] {
    namespace ensemble create\
        -command ${actns}::$ugname\
        -map [dict create\
            reclassify [list ${suppns}::RelUnionGenReclassify $ugname]\
        ]
}
----

The ensemble command for class instances is much simpler.
All instances have the same set of subcommands and they
are simply enumerated in the command map of the ensemble.

[source,tcl]
----
<<CreateActivityCommands: instances>>=
set cmdmap [dict create\
    attribute ${suppns}::InstanceAttribute\
    assign ${suppns}::InstanceAssign\
    signal ${suppns}::InstanceSignal\
    delaysignal ${suppns}::InstanceDelaySignal\
    canceldelayed ${suppns}::InstanceCancelSignal\
    delayremaining ${suppns}::InstanceRemainingTime\
    delete ${suppns}::InstanceDelete\
    operation ${suppns}::InstanceOperation\
    foreachRelated ${suppns}::InstanceForeachRelated\
    foreachRelatedWhere ${suppns}::InstanceForeachRelatedWhere\
    findOneRelated ${suppns}::InstanceFindOneRelated\
    instid ${suppns}::InstanceRefToId\
]
namespace ensemble create\
    -command ${actns}::instance\
    -parameters instref\
    -map $cmdmap
----

To save some typing,
we create an ensemble command named `my` which is just a shorthand for
`instance self`.

[source,tcl]
----
<<CreateActivityCommands: instances>>=
set cmdmap [dict create\
    attribute [list ${suppns}::InstanceAttribute self]\
    assign [list ${suppns}::InstanceAssign self]\
    signal [list ${suppns}::InstanceSignal self]\
    delaysignal [list ${suppns}::InstanceDelaySignal self]\
    canceldelayed [list ${suppns}::InstanceCancelSignal self]\
    delayremaining [list ${suppns}::InstanceRemainingTime self]\
    delete [list ${suppns}::InstanceDelete self]\
    operation [list ${suppns}::InstanceOperation self]\
    instid [list ${suppns}::InstanceRefToId self]\
]
namespace ensemble create\
    -command ${actns}::my\
    -map $cmdmap
----

Instance sets also have a fixed set of subcommand operations.

[source,tcl]
----
<<CreateActivityCommands: instance sets>>=
set cmdmap [dict create\
    foreachSelected ${suppns}::InstanceSetForeachSelected\
    selectRelated ${suppns}::InstanceSetSelectRelated\
    selectRelatedWhere ${suppns}::InstanceSetSelectRelatedWhere\
    empty ${suppns}::InstanceSetEmpty\
    cardinality ${suppns}::InstanceSetCardinality\
    notempty ${suppns}::InstanceSetNotEmpty\
    equal ${suppns}::InstanceSetEqual\
    notequal ${suppns}::InstanceSetNotEqual\
    add ${suppns}::InstanceSetAdd\
    remove ${suppns}::InstanceSetRemove\
    member ${suppns}::InstanceSetMember\
    union ${suppns}::InstanceSetUnion\
    intersect ${suppns}::InstanceSetIntersect\
    minus ${suppns}::InstanceSetMinus\
]
namespace ensemble create\
    -command ${actns}::instset\
    -parameters instset\
    -map $cmdmap
----

=== Symbol Table

[source,tcl]
----
<<generation support data>>=
relvar create Symbol {
    Name string
    Ctype string
    Type string
    Class string
    Block int
} Name


variable symcounter 0
----

[source,tcl]
----
<<generation support commands>>=
proc LookUpSymbol {name} {
    variable block
    set sym [relvar restrictone Symbol Name $name]
    if {[relation isnotempty $sym]} {
        return [tuple get [relation tuple $sym]]
    }

    return
}

proc InsertSymbol {args} {
    variable block
    dict set args Block $block
    try {
        set sym [relvar insert Symbol $args]
        return [tuple get [relation tuple $sym]]
    } trap {RAL relvar insert DUPLICATE_TUPLE*} {result} {
        error "duplicate symbol, [dict get $args Name], $result"
    } on error {result opts} {
        return -options $opts $result
    }
}

proc DeleteSymbol {name} {
    return [relvar deleteone Symbol Name $name]
}

proc CreateTempSymbol {args} {
    variable symcounter
    set name t__T[incr symcounter]
    InsertSymbol Name $name {*}$args
    return $name
}

proc CreateTempRefSymbol {className} {
    set reftype [GetClassProperty $className Reference]
    set symName [CreateTempSymbol Ctype $reftype Type Reference Class $className]
    return [list $reftype $symName]
}

proc CheckSymbol {name args} {
    set sym [LookUpSymbol $name]
    if {$sym eq {}} {
        error "unknown symbol, $name"
    }
    if {[llength $args] != 0} {
        CheckSymProperties $sym {*}$args
    }
    return $sym
}

proc CheckSymProperties {sym args} {
    foreach {prop value} $args {
        # if the property is empty, then we will assume the value that
        # is checked first. This lets us pass parameters where we
        # don't quite know the data type needs.
        if {[dict get $sym $prop] eq {}} {
            dict set sym $prop $value
            relvar update Symbol stup {
                    [tuple extract $stup Name] eq [dict get $sym Name] &&\
                    [tuple extract $stup $prop] eq {}
                } {
                    tuple update $stup $prop $value
                }
        }
        if {[dict get $sym $prop] ne $value} {
            error "for variable, [dict get $sym Name], expected $prop to be,\
                    $value: got [dict get $sym $prop] instead"
        }
    }
    return
}

proc CreateInstRefSymbol {className varName} {
    set sym [LookUpSymbol $varName]
    if {$sym ne {}} {
        CheckSymProperties $sym Class $className Type Reference
        return
    }
    set creftype [GetClassProperty $className Reference]
    InsertSymbol Name $varName Ctype $creftype Type Reference Class $className
    return "$creftype$varName ;\n"
}

proc CheckInstRefSymbol {varName args} {
    tailcall CheckSymbol $varName Type Reference {*}$args
}

proc CreateInstSetSymbol {className varName} {
    set sym [LookUpSymbol $varName]
    if {$sym ne {}} {
        CheckSymProperties $sym Class $className Type InstanceSet
        return
    }
    set ctype MRT_InstSet
    InsertSymbol Name $varName Ctype $ctype Type InstanceSet Class $className
    return "$ctype $varName ;\n"
}

proc CheckInstSetSymbol {varName args} {
    tailcall CheckSymbol $varName Type InstanceSet {*}$args
}

proc ProcessCodeLines {text} {
    variable block

    # puts "text = \"$text\""
    set newlines [list]

    foreach line [split $text \n] {
        if {[string is space $line]} {
            if {[llength $newlines] != 0 && [lindex $newlines end] ne {}} {
                lappend newlines {}
            }
        } else {
            if {[string first \} $line] != -1} {
                incr block -1
            }
            if {[regsub -- {\A\s{4,}} $line {} newline] != 0} {
                set line [string repeat { } [expr {$block * 4}]]$newline
            }
            lappend newlines $line
            if {[string first \{ $line] != -1} {
                incr block
            }
        }
    }
    set newtext [join $newlines \n]
    # puts "newtext = \"$newtext\""

    return $newtext
}
----

[source,tcl]
----
<<generation support commands>>=
proc PushContext {context args} {
    actexpand cpush $context
    foreach {var value} $args {
        actexpand cset $var $value
    }
}

proc PopContext {context args} {
    foreach varname $args {
        upvar 1 $varname cvar
        set cvar [actexpand cget $varname]
    }
    return [actexpand cpop $context]
}

proc IndentToBlock {code} {
    variable block
    # indent seems to swallow a trailing new line
    return [::textutil::adjust::indent $code\
        [string repeat { } [expr {$block * 4}]]]\n
}

proc PushBlock {{by 1}} {
    variable block
    incr block $by
}

proc PopBlock {{by -1}} {
    variable block
    relvar delete Symbol stup {[tuple extract $stup Block] == $block}
    incr block $by
}

proc GetBlock {} {
    variable block
    return $block
}
----

=== Template Expansion of Activity Code

[source,tcl]
----
<<generation support commands>>=
proc ExpandActivity {name body parameters} {
    # parameters is a relation value with heading:
    # Name string Ctype string Type string Class string

    variable block 1
    try {
        foreach param [relation body $parameters] {
            InsertSymbol {*}$param
        }
        return [actexpand expand $body]
    } on error {result} {
        # puts $::errorInfo
        log::error "$name: $result"
        variable errcount
        incr errcount
        set msg [pipe {
            split $result \n |
            lrange ~ 1 2 |
            string map [list \" {}] ~ |
            join ~
        }]
        return "#error \"$msg\""
    } finally {
        relvar set Symbol [relation emptyof [relvar set Symbol]]
        variable symcounter 0
    }
}
----

[source,tcl]
----
<<generation support commands>>=
proc End {} {
    set result {}

    set context [actexpand cname]
    switch -exact -- $context {
        InstanceSetForeachSelected -
        InstanceForeachRelated -
        InstanceForeachRelatedWhere -
        ClassForeachInstance -
        ClassForeachWhere {
            set result [PopContext $context depth]
            for {set i 0} {$i < $depth} {incr i} {
                PopBlock
                append result [IndentToBlock "\}\n"]
            }
        }
        default {
            error "unknown context, \"$context\""
        }
    }
    append result [IndentToBlock [linecomment end]]

    return $result
}
----

=== Invoking External Operations

[source,tcl]
----
<<generation support commands>>=
proc InvokeExternalOp {opName args} {
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set opRef [ExternalOperation findWhere {$Domain eq $domain &&\
            $Name eq $opName}]
    if {[isEmptyRef $opRef]} {
        error "unknown external operation, $opName, for domain, $domain"
    }

    set provided [dict keys $args]
    set params [deRef [findRelated $opRef ~R11]]
    set required [relation list $params Name -ascending Number]
    ValidateParams $opName $provided $required

    set pset {}
    foreach pname $required {
        append pset "[dict get $args $pname], "
    }
    set pset [string trimright $pset {, }]

    return "${domain}_${opName}__EOP\($pset\)"
}
----

=== Instance Macro Commands

The macro command, `instance` has a number of subcommands used to
access various aspects of a class instance.
The instance commands follow a pattern:

*****
`%<instance` _instvar_ `subcommand` _other arguments_ `>%`
*****

The instance operation is performed on class instance whose reference
is held in the _instvar_ variable.
The `subcommand` argument names the specific instance operation to
be performed.
Each possible `subcommand` is given in a section below describing the
operation.
Difference `subcommand` operation may require additional arguments
as described.

==== Access to Instance Attributes

*****
`%<instance` _instvar_ `attribute` _attrname_ `>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
attrname::
    The name of the attribute to be accessed.

The `attribute` subccommand generates a ``C'' expression to access
_attrname_ for the instance whose reference is contained in the
variable named, _instvar_.
The class whose instance is held in _instvar_ must contain an attribute whose
name is _attrname_ or an error is generated.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceAttribute {instref attr} {
    variable domain

    set sym [CheckInstRefSymbol $instref]
    set attrRef [Attribute findById Domain $domain Class [dict get $sym Class]\
            Name $attr]
    if {[isEmptyRef $attrRef]} {
        error "instance reference, $instref, refers to an instance of\
            class, [dict get $sym Class], which does not have an attribute\
            named, $attr"
    }
    return "$instref->$attr"
}
----

==== Assigning Instance Attributes to Variables

*****
`%<instance` _instvar_ `assign` _?assignspec1 assignspec2  ...?_ `>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
assignspecN::
    A set of attribute name / variable name pairs. Each _assignspec_
    argument consists of a list of one or two elements.
    The first element is the name of the attribute of _instvar_ to assign.
    The second element is the name of a local variable into which the
    assignment is made.
    If the second element is absent, then the assignment is made to
    a local variable with the same name as the attribute.

The `assign` subccommand generates ``C'' statements to assign
a set of attributes of _instvar_ according the the _assignspec_ arguments.
The class whose instance is held in _instvar_ must contain an attribute whose
name matches the attribute name in the _assignspec_ or an error is generated.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceAssign {instref args} {
    variable domain

    set sym [CheckInstRefSymbol $instref]

    set result {}
    foreach attrspec $args {
        if {[llength $attrspec] == 1} {
            set attrname [lindex $attrspec 0]
            set varname $attrname
        } elseif {[llength $attrspec] == 2} {
            lassign $attrspec attrname varname
        } else {
            error "bad attribute specification, \"$attrspec\":\
                expected 1 or 2 element list"
        }
        set attrRef [Attribute findById Domain $domain\
                Class [dict get $sym Class] Name $attrname]
        if {[isEmptyRef $attrRef]} {
            error "instance reference, $instref, refers to an instance of\
                class, [dict get $sym Class], which does not have an attribute\
                named, $attrname"
        }
        # HERE, need to be able to reuse local symbol names
        # if the C type matches
        assignAttribute $attrRef {DataType attrtype} Dimension
        set vardecl [typeCheck composeDeclaration $attrtype $varname]
        if {$Dimension > 0} { # <2>
            append result\
                "$vardecl\[$Dimension\] ;\n"\
                "memcpy($varname, $instref->$attrname, sizeof($varname)) ;\n"
        } else {
            append result "$vardecl = $instref->$attrname ;\n"
        }
    }

    return [IndentToBlock $result]
}
----

==== Deleting Instances

*****
`%<instance` _instvar_ `delete>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.

The `delete` subccommand generates a ``C'' statement to delete the
class instance whose reference is contained in _instvar_.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceDelete {instref} {
    CheckInstRefSymbol $instref
    append result\
        [linecomment "instance $instref delete"]\
        "mrt_DeleteInstance($instref) ;\n"
    DeleteSymbol $instref
    return [IndentToBlock $result]
}
----

==== Invoking Instance Based Operations

*****
`%<instance` _instvar_ `operation` _opname param1 value1 param2 value2 ..._ `>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
opname::
    The name of the instance operation to be invoked.
paramN valueN::
    A set of named parameter values to the operation.

The `operation` subccommand generates a ``C'' expression to invoke the instance
based operation on the class instance whose reference is contained in
_instvar_.
The _opname_ argument must be a valid instance based operation defined
on the class of the _instvar_ instance.
Parameter arguments are parameter name / parameter value pairs,
where the parameter name must match that provided in the definition of
the operation.
Parameter values may be any valid ``C'' value expression such as a
variable name or a constant.
Parameters may be given in any order since they are named.
It is an error not to provide values for all the parameters of the
operation.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceOperation {instref opName args} {
    set instsym [CheckInstRefSymbol $instref]
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set className [dict get $instsym Class]
    set opRef [Operation findWhere {$Domain eq $domain && $Class eq $className\
        && $Name eq $opName && $IsInstance}]
    if {[isEmptyRef $opRef]} {
        error "unknown instance operation, $opName, for class, $className"
    }

    dict set args self $instref ; # <1>
    set provided [dict keys $args]
    set params [deRef [findRelated $opRef ~R4]]
    set required [relation list $params Name -ascending Number] ; # <2>
    ValidateParams $opName $provided $required

    set pset {}
    foreach pname $required {
        append pset "[dict get $args $pname], "
    }
    set pset [string trimright $pset {, }]

    return "${className}_$opName\($pset\)"
}
----
<1> The value of the implicit `self` argument is just the instance reference
upon which the macro command was invoked.
<2> The order is important here since ``C'' passes parameters by order.
We use the parameter numbering to translate from pass by name to pass by order.

[source,tcl]
----
<<generation support commands>>=
proc ValidateParams {name provided required} {
    if {![struct::set equal $provided $required]} {
        lassign [struct::set intersect3 $provided $required]\
            p_inter_r p_minus_r r_minus_p
        if {![struct::set empty $p_minus_r]} {
            error "provided parameter(s), \"[join $p_minus_r ,]\", which are\
                not parameters to, $name"
        }
        if {![struct::set empty $r_minus_p]} {
            error "parameter(s), \"[join $r_minus_p ,]\", are required for,\
                $name, but were not provided"
        }
    }
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-49.0 {
    Navigate simple association -- singular
} -setup {
    validateutils genMiccaFile codegen49 {
        domain codegen49 {
            class X {
                attribute temp int -default 10

                instop void incrTemp {quantity int} {
                    %<my attribute temp>% += quantity ;
                }
            }
            domainop void findys {} {
                %<X findByName x1 xref>%
                int x = 3 ;
                %<instance xref operation incrTemp quantity {x + 2}>% ;
            }
        }
        population codegen49 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen49.c
    testConditions\
        {[validateutils matchLines codegen49.c {
            X_incrTemp(xref, x + 2) ;
        }]}
} -result {1}
----
endif::showtests[]

==== Iterating Across Related Instances

One of the more complicated model level actions is to navigate a
chain of relationships.
Navigation starts at a given class instance and then traverses
relationships to obtain a related set of class instances.
Often,
it is not necessary to actually accumulate the set of related instance
references.
For simple operations on the related instances,
it is sufficient to iterate across them and perform the operation as
each related instance is found.

What makes relationship navigation complicated is the different
``C'' level storage strategies for the relationship pointers.
Sometimes the pointer is just a single value, sometimes a linked list
and sometimes a counted array.
Some relationships are conditional and so traversal through a conditional
relationship must insure that we have actually found an instance.
All of these considerations make is essential to provide an embedded
macro command to generate the required code.

<<relationship-naming-conventions,Previously>>, we explained the conventions
used to specify relationship traversal.
Those same conventions will be used here to specify, as a set of arguments,
the relationship chain to be navigated.

*****
`%<instance` _instvar_ `foreachRelated` _start rel1 ?rel2? ..._ `>%` +
{nbsp}{nbsp} _Loop Body_ +
`%<end>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
start::
    The name of a ``C'' variable containing the instance reference where
    the relationship navigation will begin.
relN::
    A set of relationship navigation specifications.

The `foreachRelated` subccommand generates ``C'' statements
to iterate across the set of instances obtained by navigating
the relationship chain which starts at the _start_ instance
and is given by the _relN_ arguments.
A reference to each instance found in the navigation is assigned into
the _instvar_ variable and then _Loop Body_ is executed.
Statements in the _Loop Body_ terminate at the `%<end>%` macro command.
The scope of the _instvar_ variable is confined to the statements in
the _Loop Body_.

The relationship traversal is given as a set of relationship navigation
specifications of the form:

* `Rdd` -- traversing relationship _Rdd_ in the forward direction.
* `~Rdd` -- traversing relationship _Rdd_ in the backward direction.
* `{Rdd class}` -- traversing relationship _Rdd_ in the forward direction and
stopping at `class`.
* `{~Rdd class}` -- traversing relationship _Rdd_ in the backward direction and
stopping at `class`.
*****
{nbsp}
[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceForeachRelated {instref startref args} {
    set startblock [GetBlock]
    set result [IndentToBlock\
        [linecomment "instance $instref foreachRelated $startref [list $args]"]\
    ]

    lassign [TraverseRelChain $startref $args] chaincode targetclass targetref
    append result $chaincode
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $targetclass $instref]\
        "$instref = $targetref ;\n"]]

    PushContext InstanceForeachRelated depth [expr {[GetBlock] - $startblock}]

    return $result
}
----

The difficult part of the code generation for traversing a relationship
chain is factored in the to procedure below.
The `TraversRelChain` procedure generates the code to access the pointer
in the instance structures associated with a given set of relationships.
Since there are many different pointer arrangements,
the traversal code will be specific to each type of relationships
being traversed.
The return value of the function is a three element list giving the
generated code to traverse the relationship chain, the target class
of the end of the chain and a variable name containing the target instance
reference of the end.

[source,tcl]
----
<<generation support commands>>=
proc TraverseRelChain {startref relspecs} {
    variable domain

    if {[llength $relspecs] == 0} {
        error "empty relationship chain specification"
    }

    set result {}
    set startsym [CheckInstRefSymbol $startref]
    set startClass [dict get $startsym Class]

    foreach relspec $relspecs {
        set relinfo [LookUpRelationship $startClass $relspec]
        while {[llength $relinfo] != 0} {
            # puts "relinfo = \"$relinfo\""
            set relinfo [lassign $relinfo sourceclass targetclass reftype cond\
                comp]
            switch -exact -- $reftype {
                reference {
                    <<TraverseRelChain: single reference>>
                }
                array {
                    <<TraverseRelChain: array reference>>
                }
                linked {
                    <<TraverseRelChain: linked reference>>
                }
                reftosuper {
                    <<TraverseRelChain: reference to superclass>>
                }
                reftosub {
                    <<TraverseRelChain: reference to subclass>>
                }
                uniontosuper {
                    <<TraverseRelChain: union subclass to superclass reference>>
                }
                uniontosub {
                    <<TraverseRelChain: union superclass to subclass reference>>
                }
            }
            set startClass $targetclass
            set startref $targetref
        }
    }

    return [list $result $targetclass $targetref]
}
----

Instance references stored as a single pointer value generate
code to assign the pointer value into a temporary variable that
is suitable as an instance reference to the target of the navigation.

[source,tcl]
----
<<TraverseRelChain: single reference>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
set refcode "$targettype$targetref = $startref->$comp ; // $relspec \n"
if {$cond} { # <1>
    append refcode "if ($targetref != NULL) \{\n"
    append result [IndentToBlock $refcode]
    PushBlock
} else {
    append result [IndentToBlock $refcode]
}
----
<1> If the relationship is conditional, then we must generate code
to test if we obtained an instance pointer.

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-36.0 {
    Navigate simple association -- singular
} -setup {
    validateutils genMiccaFile codegen36 {
        domain codegen36 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 20
            }
            association R2 Z 0..1--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance z foreachRelated xs R1 ~R2>%
                    printf("z.value = %d\n",
                        %<instance z attribute value>%) ;
                %<end>%
            }
        }
        population codegen36 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen36.c
    testConditions\
        {[validateutils matchLines codegen36.c {
    struct Y *t__T1 = xs->R1 ; // R1
    struct Z *t__T2 = t__T1->R2__BACK ; // ~R2
    if (t__T2 != NULL) {
        struct Z *z ;
        z = t__T2 ;
        printf("z.value = %d\n",
z->value) ;
    }
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-43.0 {
    Navigate class based association -- singular
} -setup {
    validateutils genMiccaFile codegen43 {
        domain codegen43 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -associator A X 1--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance y foreachRelated xs R1>%
                    printf("y.value = %d\n", %<instance y attribute value>%) ;
                %<end>%
            }
        }
        population codegen43 {
            class A {
                instance a1 R1 {X x1 Y y1}
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen43.c
    testConditions\
        {[validateutils matchLines codegen43.c {
    struct A *t__T1 = xs->R1__FORW ; // R1
    struct Y *t__T2 = t__T1->R1.forward ; // R1
    struct Y *y ;
    y = t__T2 ;
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-44.0 {
    Navigate class based association -- singular, stop at associator
} -setup {
    validateutils genMiccaFile codegen44 {
        domain codegen44 {
            class A {
                attribute value int -default 40
            }
            class X {}
            class Y {}
            association R1 -associator A X 1--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance a foreachRelated xs {R1 A}>%
                    printf("a.value = %d\n", %<instance a attribute value>%) ;
                %<end>%
            }
        }
        population codegen44 {
            class A {
                instance a1 R1 {X x1 Y y1}
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen44.c
    testConditions\
        {[validateutils matchLines codegen44.c {
            struct A *t__T1 = xs->R1__FORW ; // R1 A
            struct A *a ;
            a = t__T1 ;
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-51.0 {
    Navigate class based association -- singular, start at associator
} -setup {
    validateutils genMiccaFile codegen51 {
        domain codegen51 {
            class A {
                attribute value int -default 40
            }
            class X {}
            class Y {}
            association R1 -associator A X 1--1 Y

            domainop void findys {} {
                %<A findByName a1 aref>%
                %<instance yref findOneRelated aref R1>%
                printf("y name = %s\n", yref->base__INST.name) ;
                %<instance xref findOneRelated aref ~R1>%
                printf("x name = %s\n", xref->base__INST.name) ;
            }
        }
        population codegen51 {
            class A {
                instance a1 R1 {X x1 Y y1}
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen51.c
    testConditions\
        {[validateutils matchLines codegen51.c {
            struct Y *yref ;
            struct Y *t__T1 = aref->R1.forward ; // R1
            yref = t__T1 ;
        }]}\
        {[validateutils matchLines codegen51.c {
            struct X *xref ;
            struct X *t__T2 = aref->R1.backward ; // ~R1
            xref = t__T2 ;
        }]}
} -result {1}
----
endif::showtests[]

When we encounter a set of instance references stored in an array,
the generated code must set up a loop construct to visit all the
members of the set.

[source,tcl]
----
<<TraverseRelChain: array reference>>=
set itervar [CreateTempSymbol\
    Ctype "struct $targetclass *const *"\
    Type "ReferenceArray" Class $targetclass]
set cntvar [CreateTempSymbol Ctype size_t\
    Type ArrayCounter Class $targetclass]
set refcode\
    "struct $targetclass *const *$itervar =\
        $startref->$comp.links ; // $relspec\n"
append refcode\
    "for (size_t $cntvar = $startref->$comp.count ;\
        $cntvar != 0 ; $cntvar--, $itervar++) \{" ; # <1>
append result [IndentToBlock $refcode]
PushBlock
lassign [CreateTempRefSymbol $targetclass] targettype\
        targetref
append result [IndentToBlock\
    "$targettype$targetref = *$itervar ;"]
----
<1> For the array case there is no special handling in case the
set of related instance is empty.
In the empty case, the code generator will have set the count
value to 0 and the loop will not be executed.

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-37.0 {
    Navigate simple association -- multiple static
} -setup {
    validateutils genMiccaFile codegen37 {
        domain codegen37 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 10
            }
            association R2 -static Z 0..*--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance z foreachRelated xs R1 ~R2>%
                    printf("z.value = %d\n",
                        %<instance z attribute value>%) ;
                %<end>%
            }
        }
        population codegen37 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
                instance z2 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen37.c
    testConditions\
        {[validateutils matchLines codegen37.c {
    struct Y *t__T1 = xs->R1 ; // R1
    struct Z *const *t__T2 = t__T1->R2__BACK.links ; // ~R2
    for (size_t t__T3 = t__T1->R2__BACK.count ; t__T3 != 0 ; t__T3--, t__T2++) {
        struct Z *t__T4 = *t__T2 ;
        struct Z *z ;
        z = t__T4 ;
        printf("z.value = %d\n",
z->value) ;
    }
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-45.0 {
    Navigate class based association -- multiple, static
} -setup {
    validateutils genMiccaFile codegen45 {
        domain codegen45 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -static -associator A X 1..*--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance y foreachRelated xs R1>%
                    printf("y.value = %d\n", %<instance y attribute value>%) ;
                %<end>%
            }
        }
        population codegen45 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen45.c
    testConditions\
        {[validateutils matchLines codegen45.c {
            struct A *t__T1 = xs->R1__FORW ; // R1
            struct Y *t__T2 = t__T1->R1.forward ; // R1
            struct Y *y ;
            y = t__T2 ;
        }]}
} -result {1}
----
endif::showtests[]

For references stored in linked lists,
we again have generate code to iterate across the links.

[source,tcl]
----
<<TraverseRelChain: linked reference>>=
set itervar [CreateTempSymbol Ctype "MRT_LinkRef *"\
    Type "ReferenceLink" Class $targetclass]
lassign $comp termcomp linkcomp
append result [IndentToBlock\
    "for (MRT_LinkRef *$itervar =\
        mrtLinkRefBegin(&$startref->$termcomp) ;\
        $itervar != mrtLinkRefEnd(&$startref->$termcomp) ;)\
        \{\n"] ; # <1>
PushBlock
lassign [CreateTempRefSymbol $targetclass] targettype\
        targetref
append result [IndentToBlock [string cat\
    "$targettype$targetref =\
        ($targettype)((uintptr_t)$itervar -\
        offsetof(struct $targetclass, $linkcomp)) ;\n"\
    "$itervar = $itervar->next ;\n"\
]] ; # <2>
----
<1> Again, there is no special empty case for linked lists.
If there are no related instances linked together,
the linked list iterator will be at the end and the loop will not
be entered.
<2> Two complications arise using linked list.
Since a class instance may be threaded onto several linked lists,
we must do some pointer arithmetic to transform the link value
stored in the linked list into a pointer to the beginning of the
instance. So, we must subtract off the offset to the link pointers
in the instance.
Secondly, we advance the linked list iterator at the beginning of the
loop rather than at the end.
This is to make sure that any user supplied code that might unlink
the instance from the linked list does not invalidate our iterator.

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-38.0 {
    Navigate simple association -- multiple dynamic
} -setup {
    validateutils genMiccaFile codegen38 {
        domain codegen38 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 20
            }
            association R2 -dynamic Z 0..*--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance z foreachRelated xs R1 ~R2>%
                    printf("z.value = %d\n",
                        %<instance z attribute value>%) ;
                %<end>%
            }
        }
        population codegen38 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
                instance z2 R2 y1
                instance z3 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen38.c
    testConditions\
        {[validateutils matchLines codegen38.c {
    struct Y *t__T1 = xs->R1 ; // R1
    for (MRT_LinkRef *t__T2 = mrtLinkRefBegin(&t__T1->R2__BACK) ; t__T2 != mrtLinkRefEnd(&t__T1->R2__BACK) ;) {
        struct Z *t__T3 = (struct Z *)((uintptr_t)t__T2 - offsetof(struct Z, R2__BLINKS)) ;
        t__T2 = t__T2->next ;
        struct Z *z ;
        z = t__T3 ;
        printf("z.value = %d\n",
z->value) ;
    }
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-46.0 {
    Navigate class based association -- multiple, dynamic
} -setup {
    validateutils genMiccaFile codegen46 {
        domain codegen46 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -associator A X 1..*--1..* Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance y foreachRelated xs R1>%
                    printf("y.value = %d\n", %<instance y attribute value>%) ;
                %<end>%
            }
        }
        population codegen46 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen46.c
    testConditions\
        {[validateutils matchLines codegen46.c {
    for (MRT_LinkRef *t__T1 = mrtLinkRefBegin(&xs->R1__FORW) ; t__T1 != mrtLinkRefEnd(&xs->R1__FORW) ;) {
        struct A *t__T2 = (struct A *)((uintptr_t)t__T1 - offsetof(struct A, R1__FLINKS)) ;
        t__T1 = t__T1->next ;
        struct Y *t__T3 = t__T2->R1.forward ; // R1
        struct Y *y ;
        y = t__T3 ;
        printf("y.value = %d\n", y->value) ;
    }
        }]}
} -result {1}
----
endif::showtests[]

References from subclasses to superclasses are just a single pointer
value that is unconditional.

[source,tcl]
----
<<TraverseRelChain: reference to superclass>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
append result [IndentToBlock\
    "$targettype$targetref = $startref->$comp ; // $relspec \n"\
]
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-39.0 {
    Navigate reference generalization from subclass to superclass
} -setup {
    validateutils genMiccaFile codegen39 {
        domain codegen39 {
            class S {
                attribute value int -default 20
            }
            class Y {}
            class Z {}
            generalization R1 -reference S Y Z

            domainop void findss {} {
                %<Y findByName y1 ys>%
                %<instance s foreachRelated ys R1>%
                    printf("s.value = %d\n", %<instance s attribute value>%) ;
                %<end>%
            }
        }
        population codegen39 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen39.c
    testConditions\
        {[validateutils matchLines codegen39.c {
            struct S *t__T1 = ys->R1 ; // R1
            struct S *s ;
            s = t__T1 ;
        }]}
} -result {1}
----
endif::showtests[]

References from a superclass to a subclass are also just a single
pointer value.
However, the traversal is conditional.
When specifying a traversal to a subclass, the subclass class name
must be given and the generated code has to insure that we are currently
related to an instance of the designated subclass.

[source,tcl]
----
<<TraverseRelChain: reference to subclass>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
set classDesc [GetClassDescriptor $domain $targetclass]
set refcode "$targettype$targetref = $startref->$comp ; // $relspec\n"
append refcode "if ($targetref->base__INST.classDesc == &$classDesc) \{\n"
append result [IndentToBlock $refcode]
PushBlock
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-41.0 {
    Navigate reference generalization from superclass to subclass
} -setup {
    validateutils genMiccaFile codegen41 {
        domain codegen41 {
            class S {}
            class Y {
                attribute value int -default 20
            }
            class Z {}
            generalization R1 -reference S Y Z

            domainop void findss {} {
                %<S findByName s1 ss>%
                %<instance y foreachRelated ss {~R1 Y}>%
                    printf("y.value = %d\n", %<instance y attribute value>%) ;
                %<end>%
            }
        }
        population codegen41 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen41.c
    testConditions\
        {[validateutils matchLines codegen41.c {
            struct Y *t__T1 = ss->R1 ; // ~R1 Y
            if (t__T1->base__INST.classDesc == &codegen41__CLASSES[1]) {
                struct Y *y ;
                y = t__T1 ;
                printf("y.value = %d\n", y->value) ;
            }
        }]}
} -result {1}
----
endif::showtests[]

When a generalization is stored in a union,
then pointer arithmetic alone is sufficient to _up cast_ to the
supeclass instance.

[source,tcl]
----
<<TraverseRelChain: union subclass to superclass reference>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
append result [IndentToBlock\
    "$targettype$targetref = ($targettype)((uintptr_t)$startref -\
    offsetof(struct $targetclass, $comp.$startClass)) ;\
    // $relspec \n"]
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-40.0 {
    Navigate union generalization from subclass to superclass
} -setup {
    validateutils genMiccaFile codegen40 {
        domain codegen40 {
            class S {
                attribute value int -default 20
            }
            class Y {}
            class Z {}
            generalization R1 -union S Y Z

            domainop void findss {} {
                %<Y findByName y1 ys>%
                %<instance s foreachRelated ys R1>%
                    printf("s.value = %d\n", %<instance s attribute value>%) ;
                %<end>%
            }
        }
        population codegen40 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen40.c
    testConditions\
        {[validateutils matchLines codegen40.c {
    struct S *t__T1 = (struct S *)((uintptr_t)ys - offsetof(struct S, R1.Y)) ; // R1
    struct S *s ;
    s = t__T1 ;
        }]}
} -result {1}
----
endif::showtests[]

Going from the superclass to the subclass with a union storage arrangement
has the same complication as when pointers are used, namely we must
make sure that the instance is currently related to an instance of the
given target subclass.
The addressing expression is much easier as the compiler will
do the address arithmetic for us.

[source,tcl]
----
<<TraverseRelChain: union superclass to subclass reference>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
set classDesc [GetClassDescriptor $domain $targetclass]
set refcode "$targettype$targetref = &$startref->$comp.$targetclass ;\
        // $relspec\n"
append refcode\
    "if ($targetref->base__INST.classDesc == &$classDesc) \{\n"
append result [IndentToBlock $refcode]
PushBlock
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-42.0 {
    Navigate union generalization from superclass to subclass
} -setup {
    validateutils genMiccaFile codegen42 {
        domain codegen42 {
            class S {}
            class Y {
                attribute value int -default 20
            }
            class Z {}
            generalization R1 -union S Y Z

            domainop void findss {} {
                %<S findByName s1 ss>%
                %<instance y foreachRelated ss {~R1 Y}>%
                    printf("y.value = %d\n", %<instance y attribute value>%) ;
                %<end>%
            }
        }
        population codegen42 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen42.c
    testConditions\
        {[validateutils matchLines codegen42.c {
            struct Y *t__T1 = &ss->R1.Y ; // ~R1 Y
            if (t__T1->base__INST.classDesc == &codegen42__CLASSES[1]) {
                struct Y *y ;
                y = t__T1 ;
                printf("y.value = %d\n", y->value) ;
            }
        }]}
} -result {1}
----
endif::showtests[]

To simplify the code of `TraverseRelChain`,
we use the `LookUpRelationship` procedure to summarize the
relationship characteristics that are needed to navigate the relationship.

The 
<<relationship-subsystem,Relationship Subsystem>>
of the platform model discusses the various arrangements for
reference pointer storage and how for class based associations
traversal is decomposed into two steps.
The structure of `LookUpRelationship` follows directly from the
platform model for relationships, searching for associations and
generalizations and the various types of each.

[source,tcl]
----
<<generation support commands>>=
proc LookUpRelationship {startclass relspec} {
    variable domain

    lassign $relspec relname destclass
    if {[string index $relname 0] eq "~"} {
        set dir back
        set relname [string range $relname 1 end]
    } else {
        set dir forw
    }

    set relRef [Relationship findById Domain $domain Name $relname]
    set assocRef [findRelated $relRef {~R30 Association}]
    if {[isNotEmptyRef $assocRef]} {
        <<LookUpRelationship: associations>>
    } else {
        <<LookUpRelationship: generalizations>>
    }
}
----

Association type relationships are partitioned into either simple
associations or class based associations.
We follow that division in the code below.

[source,tcl]
----
<<LookUpRelationship: associations>>=
set isstatic [readAttribute $assocRef IsStatic]
set sassocRef [findRelated $assocRef {~R31 SimpleAssociation}]
if {[isNotEmptyRef $sassocRef]} {
    <<LookUpRelationship: simple associations>>
} else {
    <<LookUpRelationship: class based associations>>
}
----

[source,tcl]
----
<<LookUpRelationship: simple associations>>=
if {$destclass ne {}} {
    error "simple association, $relname, cannot have a\
        destination specifier"
}
assignAttribute [findRelated $sassocRef ~R32]\
    {Class srcclass} {Conditionality srccond} {Multiplicity srcmult}
assignAttribute [findRelated $sassocRef ~R33]\
    {Class trgclass} {Conditionality trgcond}
if {$dir eq "forw"} {
    if {$startclass ne $srcclass} {
        error "relationship, $relname, is from\
            $srcclass to $trgclass: got, $startclass,\
            as the traversal start"
    }
    return [list $srcclass $trgclass reference $trgcond $relname]
} else {
    if {$startclass ne $trgclass} {
        error "relationship, ~$relname, is from\
            $trgclass to $srcclass: got, $startclass,\
            as the traversal start"
    }
    if {!$srcmult} {
        set type reference
        set comp ${relname}__BACK
    } else {
        if {$isstatic} {
            set type array
            set comp ${relname}__BACK
        } else {
            set type linked
            set comp [list ${relname}__BACK ${relname}__BLINKS]
        }
    }
    return [list $trgclass $srcclass $type $srccond $comp]
}
----

[source,tcl]
----
<<LookUpRelationship: class based associations>>=
set cassocRef [findRelated $assocRef {~R31 ClassBasedAssociation}]
assignAttribute [findRelated $cassocRef ~R34]\
    {Class srcclass} {Conditionality srccond} {Multiplicity srcmult}
assignAttribute [findRelated $cassocRef ~R35]\
    {Class trgclass} {Conditionality trgcond} {Multiplicity trgmult}
assignAttribute [findRelated $cassocRef ~R42]\
    {Class assocclass}
if {!$trgmult} {
    set srctype reference
    set srccomp ${relname}__FORW
} else {
    if {$isstatic} {
        set srctype array
        set srccomp ${relname}__FORW
    } else {
        set srctype linked
        set srccomp [list ${relname}__FORW ${relname}__FLINKS]
    }
}
if {!$srcmult} {
    set trgtype reference
    set trgcomp ${relname}__BACK
} else {
    if {$isstatic} {
        set trgtype array
        set trgcomp ${relname}__BACK
    } else {
        set trgtype linked
        set trgcomp [list ${relname}__BACK ${relname}__BLINKS]
    }
}
if {$destclass eq {}} {
    if {$dir eq "forw"} {
        if {$startclass eq $srcclass} {
            return [list\
                $srcclass $assocclass $srctype $trgcond $srccomp\
                $assocclass $trgclass reference false ${relname}.forward\
            ]
        } elseif {$startclass eq $assocclass} {
            return [list\
                $assocclass $trgclass reference false ${relname}.forward\
            ]
        } else {
            error "relationship, $relname, is from class based from\
                $srcclass to $trgclass via $assocclass: got, $startclass,\
                as the traversal start"
        }
    } else {
        if {$startclass eq $trgclass} {
            return [list\
                $trgclass $assocclass $trgtype $srccond $trgcomp\
                $assocclass $srcclass reference false ${relname}.backward\
            ]
        } elseif {$startclass eq $assocclass} {
            return [list\
                $assocclass $srcclass reference false ${relname}.backward\
            ]
        } else {
            error "relationship, ~$relname, is from class based from\
                $trgclass to $srcclass via $assocclass: got, $startclass,\
                as the traversal start"
        }
    }
} else {
    if {$destclass eq $assocclass} {
        if {$dir eq "forw"} {
            return [list $srcclass $assocclass $srctype $trgcond $srccomp]
        } else {
            return [list $trgclass $assocclass $trgtype $srccond $trgcomp]
        }
    } elseif {$destclass eq $trgclass} {
        if {$dir eq "forw"} {
            return [list $assocclass $trgclass reference false ${relname}.forward]
        } else {
            error "navigating forward from $assocclass arrives at\
                $trgclass: got $destclass"
        }
    } elseif {$destclass eq $srcclass} {
        if {$dir eq "back"} {
            return [list $assocclass $srcclass reference false ${relname}.backward]
        } else {
            error "navigating backward from $assocclass arrives at\
                $srcclass: got $destclass"
        }
    } else {
        error "$destclass does not participate in $relname"
    }
}
----

Generalizations are divided into those implemented using references
and those using a union.

[source,tcl]
----
<<LookUpRelationship: generalizations>>=
set genRef [findRelated $relRef {~R30 Generalization}]
set refGenRef [findRelated $genRef {~R43 ReferenceGeneralization}]
if {[isNotEmptyRef $refGenRef]} {
    set super [readAttribute [findRelated $refGenRef ~R36] Class]
    set subs [findRelated $refGenRef ~R37]
    set subnames [relation list [deRef $subs] Class]
    set isRefGen true
} else {
    set uGenRef [findRelated $genRef {~R43 UnionGeneralization}]
    set super [readAttribute [findRelated $uGenRef ~R44] Class]
    set subs [findRelated $uGenRef ~R45]
    set subnames [relation list [deRef $subs] Class]
    set isRefGen false
}
----

[source,tcl]
----
<<LookUpRelationship: generalizations>>=
if {$dir eq "forw"} {
    if {$destclass ne {}} {
        error "generalization, $relname, cannot have a\
            destination specifier when traversing to the superclass"
    } elseif {$startclass ni $subnames} {
        error "relationship, $relname, is from\
            \"[join $subnames {, }]\", to $targetclass,\
            got, $startclass, as the traversal start"
    }
    set reftype [expr {$isRefGen ? "reftosuper" : "uniontosuper"}]
    return [list $startclass $super $reftype false $relname]
} else {
    if {$destclass eq {}} {
        error "generalization, ~$relname, must specify a\
            destination when traversing to a subclass"
    } elseif {$startclass ne $super} {
        error "relationship, ~$relname, is from\
            $super to \"[join $subnames {, }]\", got, $startclass,\
            as the traversal start"
    } elseif {$destclass ni $subnames} {
        error "generalization, ~$relname, cannot traverse to\
            class, $destclass: should be one of:\
            \"[join $subnames {, }]\""
    }
    set reftype [expr {$isRefGen ? "reftosub" : "uniontosub"}]
    return [list $super $destclass $reftype false $relname]
}
----

==== Iterating Across Selected Related Instances
[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceForeachRelatedWhere {instref where startref args} {
    set startblock [GetBlock]
    set result [IndentToBlock\
        [linecomment "instance $instref foreachRelatedWhere [list $where]\
                $startref [list $args]"]\
    ]

    lassign [TraverseRelChain $startref $args] chaincode targetclass targetref
    append result $chaincode
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $targetclass $instref]\
        "$instref = $targetref ;\n"\
        "if ($where) \{\n"\
    ]]
    PushBlock

    PushContext InstanceForeachRelatedWhere\
            depth [expr {[GetBlock] - $startblock}]

    return $result
}
----

==== Finding a Single Related Instance

*****
`%<instance` _instvar_ `findOneRelated` _start rel1 ?rel2? ..._ `>%`

instvar::
    The name of a ``C'' variable that will hold the related instance.
start::
    The name of a ``C'' variable containing the instance reference where
    the relationship navigation will begin.
relN::
    A set of relationship navigation specifications.

The `findOneRelated` subccommand generates ``C'' statements
obtain a single instance reference by navigating
the relationship chain which starts at the _start_ instance
and is given by the _relN_ arguments.
A reference to the related instance is assigned into
the _instvar_ variable.
The _instvar_ variable is declared if necessary.
If the traversal of the relationship chain would yield more than a
single instance,
then an error is thrown.
*****
{nbsp}

[source,tcl]
----
<<generation support commands>>=
proc InstanceFindOneRelated {instref startref args} {
    variable domain

    set startsym [CheckInstRefSymbol $startref]
    set startClass [dict get $startsym Class]
    set heading [IndentToBlock\
        [linecomment "instance $instref findOneRelated $startref [list $args]"]\
    ]
    set startlevel [GetBlock]
    set isCond false

    foreach relspec $args {
        set relinfo [LookUpRelationship $startClass $relspec]
        while {[llength $relinfo] != 0} {
            # puts "relinfo = \"$relinfo\""
            set relinfo [lassign $relinfo sourceclass targetclass reftype cond\
                comp]
            switch -exact -- $reftype {
                reference {
                    if {$startClass ne $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            $sourceclass to $targetclass, got, $startClass,\
                            as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass]\
                        targettype targetref
                    set refcode "$targettype$targetref = $startref->$comp ;\
                    // $relspec \n"
                    if {$cond} {
                        set isCond true
                        append refcode "if ($targetref != NULL) \{\n"
                        append result [IndentToBlock $refcode]
                        PushBlock
                    } else {
                        append result [IndentToBlock $refcode]
                    }
                }
                array -
                linked {
                    error "relationship, [lindex $relspec 0], is\
                        multiple from $sourceclass to $targetclass"
                }
                reftosuper {
                    if {$startClass ni $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            \"[join $sourceclass {, }]\", to $targetclass,\
                            got, $startClass, as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref = $startref->$comp ;\
                        // $relspec \n"]
                }
                reftosub {
                    set isCond true
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    set classDesc [GetClassDescriptor $domain $targetclass]
                    set refcode "$targettype$targetref = $startref->$comp ;\
                            // $relspec\n"
                    append refcode\
                        "if ($targetref->base__INST.classDesc == &$classDesc) \{\n"
                    append result [IndentToBlock $refcode]
                    PushBlock
                }
                uniontosuper {
                    if {$startClass ni $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            \"[join $sourceclass {, }]\", to $targetclass,\
                            got, $startClass, as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref =\
                        ($targettype)((uintptr_t)$startref -\
                        offsetof(struct $targetclass, $comp.$startClass)) ;\
                        // $relspec \n"]
                }
                uniontosub {
                    set isCond true
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    set classDesc [GetClassDescriptor $domain $targetclass]
                    set refcode\
                        "$targettype$targetref = &$startref->$comp.$targetclass ;\
                            // $relspec\n"
                    append refcode\
                        "if ($targetref->base__INST.classDesc == &$classDesc) \{\n"
                    append result [IndentToBlock $refcode]
                    PushBlock
                }
            }
            set startClass $targetclass
            set startref $targetref
        }
    }
    append result [IndentToBlock "$instref = $targetref ;\n"]

    for {set i [expr {[GetBlock] - $startlevel}]} {$i > 0} {incr i -1} {
        PopBlock
        append result [IndentToBlock "\}\n"]
    }
    append heading [IndentToBlock [CreateInstRefSymbol $targetclass $instref]]
    if {$isCond} {
        append heading [IndentToBlock "$instref = NULL ;\n"]
    }

    return [string cat $heading $result]
}
----

==== Signaling an Instance

*****
`%<instance` _instvar_ `signal` _event_ _?name1 value1 name2 value2 ...?_ `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.
event::
    The name of an event in the state model for the class to which
    the instance belongs.
nameN / valueN::
    A set of event parameter name / event parameter value pairs for the
    parameters that match the parameter signature of _event_.

The `signal` subccommand generates ``C'' statements
to arrange for _event_ to be signaled to the instance referenced by the
_instvar_ variable.
Any given name / value pairs are passed as the parameters of the event.
All event parameters must be supplied and parameter names must match
the event signature of the _event_ being signaled.
If _event_ is not an event for the state model of _instvar_ then
an error is thrown.
*****
{nbsp}

[source,tcl]
----
<<generation support commands>>=
proc InstanceSignal {instref event args} {
    lassign [InstanceNewECB $instref $event $args] ecbvar ecbcode
    return [IndentToBlock [string cat\
        [linecomment "instance $instref signal $event [list $args]"]\
        $ecbcode\
        "mrt_PostEvent($ecbvar) ;\n"\
    ]]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceNewECB {instref event arglist} {
    variable domain

    if {[llength $arglist] % 2 != 0} {
        error "event parameters must be given as name / value pairs, got:\
            \"$arglist\""
    }
    set target [CheckInstRefSymbol $instref]

    dict with target {
        set eventRef [Event findById Domain $domain Model $Class Event $event]
        if {[isEmptyRef $eventRef]} {
            error "event, $event, is not a known event for class, $Class"
        }
        set eventNum [readAttribute $eventRef Number]

        set psig [findRelated $eventRef R69]
        set params [FindParamsFromSig $psig]
        set required [relation list $params Name -ascending Position]
        set supplied [dict keys $arglist]
        ValidateParams $event $supplied $required

        set result {}
        set sourceinst [expr {[LookUpSymbol self] eq {} ? "NULL" : "self"}]
        set ecbvar [CreateTempSymbol Ctype {MRT_ecb *} Type ECB Class $Class]
        append result "MRT_ecb *$ecbvar =\
                mrt_NewEvent($eventNum, $instref, $sourceinst) ;\n"
        if {[llength $required] != 0} {
            set eparamsname ${domain}_${Class}_${event}__EPARAMS
            set ptrparams [CreateTempSymbol Ctype "struct *$eparamsname"\
                Type EventParams Class $Class]
            append result\
                "struct $eparamsname *const $ptrparams =\n"\
                "    (struct $eparamsname *)$ecbvar->eventParameters ;\n"
            foreach param $required {
                append result "$ptrparams->$param = [dict get $arglist $param] ;\n"
            }
        }
    }
    return [list $ecbvar $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-50.0 {
    Signal an event with parameters
} -setup {
    validateutils genMiccaFile codegen50 {
        domain codegen50 {
            class X {
                attribute temp int -default 20

                statemodel {
                    state Idle {} {
                    }
                    transition Idle - E1 -> Running

                    state Running {incr int} {
                        %<my attribute temp>% += incr ;
                    }
                    transition Running - E1 -> Running ;
                }
            }

            domainop void startx1 {} {
                %<X findByName x1 xref>%
                %<instance xref signal E1 incr 30>%
            }
        }
        population codegen50 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen50.c
    testConditions\
        {[validateutils matchLines codegen50.c {
            MRT_ecb *t__T1 = mrt_NewEvent(0, xref, NULL) ;
            struct codegen50_X_E1__EPARAMS *const t__T2 =
                (struct codegen50_X_E1__EPARAMS *)t__T1->eventParameters ;
            t__T2->incr = 30 ;
            mrt_PostEvent(t__T1) ;
        }]}
} -result {1}
----
endif::showtests[]

==== Delayed Signaling of an Instance

*****
`%<instance` _instvar_ `delaysignal` _time_ _event_
_?name1 value1 name2 value2 ...?_ `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.
time::
    The minimum number of milliseconds that are to elapse before
    the event is signaled.
event::
    The name of an event in the state model for the class to which
    the instance belongs.
nameN / valueN::
    A set of event parameter name / event parameter value pairs for the
    parameters that match the parameter signature of _event_.

The `delaysignal` subccommand generates ``C'' statements
to arrange for _event_ to be signaled to the instance referenced by the
_instvar_ variable after _time_ number of milliseconds has elapsed.
The value of _time_ may be zero, in which case the event is signaled
immediately.
Any given name / value pairs are passed as the parameters of the event.
All event parameters must be supplied and parameter names must match
the event signature of the _event_ being signaled.
If _event_ is not an event for the state model of _instvar_ then
an error is thrown.
*****
{nbsp}

[source,tcl]
----
<<generation support commands>>=
proc InstanceDelaySignal {instref time event args} {
    lassign [InstanceNewECB $instref $event $args] ecbvar ecbcode
    return [IndentToBlock [string cat\
        [linecomment "instance $instref delaysignal $time $event [list $args]"]\
        $ecbcode\
        "mrt_PostDelayedEvent($ecbvar, $time) ;\n"\
    ]]
}
----

==== Cancel a Delayed Signal

*****
`%<instance` _instvar_ `canceldelayed` _event_ _?sourceinst?_ `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.
event::
    The name of an event in the state model for the class to which
    the instance belongs.
sourceinst::
    The name of a variable whose value is a reference to the
    instance which originally signaled the delayed event.

The `canceldelay` subccommand generates ``C'' statements
to arrange the delayed evetn, _event_, not be delivered to the
instance referenced by _instvar_.
If the delayed event was signaled from outside of a state activity,
then the _sourceinst_ argument is omitted.
Otherwise, _sourceinst_ is the name of a variable containing a reference
to the instance that signaled the event.
After it is canceled, _event_ will not be dispatched.
It is not an error to cancel an event that does not exist or has
already been dispatched.
Only events that were signaled as delayed events may be canceled.
*****
{nbsp}

[source,tcl]
----
<<generation support commands>>=
proc InstanceCancelSignal {instref event {sourceref {}}} {
    variable domain

    append result [linecomment "instance $instref canceldelayed $event\
        [list $sourceref]"]
    set target [CheckInstRefSymbol $instref]
    set eventNum [FindEventNumber [dict get $target Class] $event]
    if {$sourceref ne {}} {
        CheckInstRefSymbol $sourceref
        set sourceinst $sourceref
    } else {
        set sourceinst NULL
    }
    append result\
        "mrt_CancelDelayedEvent($eventNum, $instref, $sourceinst) ;\n"
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc FindEventNumber {class event} {
    variable domain
    set eventRef [Event findById Domain $domain Model $class Event $event]
    if {[isEmptyRef $eventRef]} {
        error "event, $event, is not a known event for class, $Class"
    }
    return [readAttribute $eventRef Number]
}
----

==== Time Remaining for a Delayed Event

*****
`%<instance` _instvar_ `delayremaining` _event_ _?sourceinst?_ `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.
event::
    The name of an event in the state model for the class to which
    the instance belongs.
sourceinst::
    The name of a variable whose value is a reference to the
    instance which originally signaled the delayed event.

The `delayremaining` subccommand generates a ``C'' expression
containing the number of milliseconds that remain before _event_ is
signaled to the instance referenced by _instvar_.
If the delayed event was signaled from outside of a state activity,
then the _sourceinst_ argument is omitted.
Otherwise, _sourceinst_ is the name of a variable containing a reference
to the instance that signaled the event.
A return value of zero implies that the event has already been dispatched
or does not exist.
*****
{nbsp}

[source,tcl]
----
<<generation support commands>>=
proc InstanceRemainingTime {instref event {sourceref {}}} {
    variable domain

    set target [CheckInstRefSymbol $instref]
    set eventNum [FindEventNumber [dict get $target Class] $event]
    if {$sourceref ne {}} {
        CheckInstRefSymbol $sourceref
        set sourceinst $sourceref
    } else {
        set sourceinst NULL
    }
    return "mrt_RemainingDelayTime($eventNum, $instref, $sourceinst)"
}
----

==== Obtaining an Instance Identifier

It is often useful for external operation to be given a token
that can be used to identify an instance of a class.
Directly passing instance reference pointers outside of a domain
is *strongly discouraged*.
Since class instances are stored in an array,
the index into the array provides a convenient identifier.

*****
`%<instance` _instvar_ `instid` `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.

The `instvar` subccommand generates a ``C'' expression
for an identifier which corresponds to the instance reference of _instvar_.
The identifier values range from 0 to the number of instance of
the class of _instvar_ minus one.
*****
{nbsp}

[source,tcl]
----
<<generation support commands>>=
proc InstanceRefToId {instref} {
    CheckInstRefSymbol $instref
    return "mrt_InstanceIndex($instref)"
}
----

=== Instance Set Commands

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetForeachSelected {set inst} {
    set setsym [CheckInstSetSymbol $set]

    set startlevel [GetBlock]
    set iter [CreateTempSymbol Ctype MRT_InstSetIterator Type SetIterator\
            Class [dict get $setsym Class]]
    append result [IndentToBlock [string cat\
        "MRT_InstSetIterator $iter ;\n"\
        "for (mrt_InstSetIterBegin(&$set, &$iter) ;\
        mrt_InstSetIterMore(&$iter) ; mrt_InstSetIterNext(&$iter)) \{\n"\
    ]]
    PushBlock

    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol [dict get $setsym Class] $inst]\
        "$inst = mrt_InstSetIterGet(&$iter) ;\n"\
    ]]

    PushContext InstanceSetForeachSelected\
            depth [expr {[GetBlock] - $startlevel}]

    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetEmpty {set} {
    CheckInstSetSymbol $set
    return "mrt_InstSetEmpty(&$set)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetNotEmpty {set} {
    return !([InstanceSetEmpty $set])
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetCardinality {set} {
    CheckInstSetSymbol $set
    return "mrt_InstSetCardinality(&$set) ;\n"
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetEqual {set1 set2} {
    set sym1 [CheckInstSetSymbol $set1]
    CheckInstSetSymbol $set2 Class [dict get $sym1 Class]
    return "mrt_InstSetEqual(&$set1, &$set2)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetNotEqual {set1 set2} {
    return ![InstanceSetEqual $set1 $set2]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetAdd {set inst} {
    set setsym [CheckInstSetSymbol $set]
    CheckInstRefSymbol $inst Class [dict get $setsym Class]
    return [IndentToBlock [string cat\
        [linecomment "instset $set add $inst"]\
        "mrt_InstSetAddInstance(&$set, $inst) ;\n"\
    ]]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetRemove {set inst} {
    set setsym [CheckInstSetSymbol $set]
    CheckInstRefSymbol $inst Class [dict get $setsym Class]
    return [IndentToBlock [string cat\
        [linecomment "instset $set remove $inst"]\
        "mrt_InstSetRemoveInstance(&$set, $inst) ;\n"\
    ]]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetMember {set inst} {
    set setsym [CheckInstSetSymbol $set]
    CheckInstRefSymbol $inst Class [dict get $setsym Class]
    return "mrt_InstSetMember(&$set, $inst)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetSelectRelated {set startref args} {
    variable domain

    set startlevel [GetBlock]
    set result [IndentToBlock\
        [linecomment "instset $set selectedRelated $startref [list $args]"]\
    ]

    lassign [TraverseRelChain $startref $args] chaincode targetclass targetref
    set targetclassDesc [GetClassDescriptor $domain $targetclass]
    append chaincode\
        [IndentToBlock "mrt_InstSetAddInstance(&$set, $targetref) ;\n"]

    set depth [expr {[GetBlock] - $startlevel}]
    for {set i 0} {$i < $depth} {incr i} {
        PopBlock
        append chaincode [IndentToBlock "\}\n"]
    }

    append result [IndentToBlock [string cat\
        [CreateInstSetSymbol $targetclass $set]\
        "mrt_InstSetInitialize(&$set, &$targetclassDesc) ;\n"]]
    append result $chaincode

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-48.0 {
    Generated code file to select related instances
} -setup {
    validateutils genMiccaFile codegen48 {
        domain codegen48 {
            class X {
                attribute color int -default 20
            }
            class Y {
                attribute temp int -default 30
            }
            association R1 Y 1..*--1 X
            class Z {
                attribute pressure int -default 40
            }
            association R2 Z 0..1--1 Y
            domainop void find {} {
                %<X findByName x1 xref>%
                %<instset zset selectRelated xref ~R1 ~R2>%
            }
        }
        population codegen48 {
            class X {
                instance x1
            }
            class Y {
                instance y1 R1 x1 temp 31
                instance y2 R1 x1 temp 32
                instance y3 R1 x1 temp 33
                instance y4 R1 x1 temp 34
            }
            class Z {
                instance z1 R2 y1 pressure 41
                instance z2 R2 y2 pressure 42
                instance z3 R2 y3 pressure 43
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen48.c
    testConditions\
        {[validateutils matchLines codegen48.c {
        struct Y *t__T2 = (struct Y *)((uintptr_t)t__T1 - offsetof(struct Y, R1__BLINKS)) ;
        t__T1 = t__T1->next ;
        struct Z *t__T3 = t__T2->R2__BACK ; // ~R2
        if (t__T3 != NULL) {
            mrt_InstSetAddInstance(&zset, t__T3) ;
        }
        }]}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetSelectRelatedWhere {set instref where startref args} {
    variable domain

    set startlevel [GetBlock]
    set result [IndentToBlock\
        [linecomment "instset $set selectRelatedWhere [list $where] $startref\
                [list $args]"]\
    ]

    lassign [TraverseRelChain $startref $args] chaincode targetclass targetref
    append chaincode [IndentToBlock [string cat\
        [CreateInstRefSymbol $targetclass $instref]\
        "$instref = $targetref ;\n"\
        "if ($where) \{\n"\
    ]]
    PushBlock
    append chaincode [IndentToBlock\
        "mrt_InstSetAddInstance(&$set, $instref) ;\n"]

    set depth [expr {[GetBlock] - $startlevel}]
    for {set i 0} {$i < $depth} {incr i} {
        PopBlock
        append chaincode [IndentToBlock "\}\n"]
    }

    set targetclassDesc [GetClassDescriptor $domain $targetclass]
    append result [IndentToBlock [string cat\
        [CreateInstSetSymbol $targetclass $set]\
        "mrt_InstSetInitialize(&$set, &$targetclassDesc) ;\n"]]
    append result $chaincode

    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetUnion {opset set1 set2 args} {
    tailcall InstanceSetOperation union mrt_InstSetUnion $opset $set1 $set2\
            {*}$args
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetIntersect {opset set1 set2 args} {
    tailcall InstanceSetOperation intersect mrt_InstSetIntersect $opset\
            $set1 $set2 {*}$args
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetOperation {label op opset set1 set2 args} {
    variable domain

    set sym1 [CheckInstSetSymbol $set1]
    set className [dict get $sym1 Class]
    CheckInstSetSymbol $set2 Class $className

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [linecomment "instset $opset $label $set1 [list $args]"]\
        [CreateInstSetSymbol $className $opset]\
        "mrt_InstSetInitialize(&$opset, &$classDesc) ;\n"\
        "$op\(&$set1, &$set2, &$opset\) ;\n"
    foreach set $args {
        CheckInstSetSymbol $set Class $className
        append result "$op\(&$opset, &$set, &$opset\) ;\n"
    }
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetMinus {diffset set1 set2} {
    variable domain

    set sym1 [CheckInstSetSymbol $set1]
    set className [dict get $sym1 Class]
    set sym2 [CheckInstSetSymbol $set2 Class $className]

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [linecomment "instset $diffset minus $set1 $set2"]\
        [CreateInstSetSymbol $className $diffset]\
        "mrt_InstSetInitialize(&$diffset, &$classDesc) ;\n"\
        "mrt_InstSetMinus(&$set1, &$set2, &$diffset) ;\n"
    return [IndentToBlock $result]
}
----

=== Class Commands

For each class in a domain,
the code generator creates a macro command that has the same name
as the class.
For example,
if a domain contains a class named, *WashingMachine*,
the there will be an embedded macro command named, WashingMachine,
which can be invoked as:

*****
`%<WashingMachine` `subcommand` ?_arg1 arg2 ..._? `>%`
*****

where `subcommand` is a class model level operation command.

In this section we describe the model level subcommands that
are available for each class.

==== Synchronous Instance Creation

*****
`%<` _class_ `create` _instref_ _?attr1 value1 att2 value2 ...?_ `>%`

_class_::
    The name of a domain class for which an instance is synchronously created.
instref::
    The name of a variable into which a reference to the newly created
    class instance is placed.
attrN / valueN::
    A set of attribute name / attribute values which are used to set the
    attribute values of the newly created instance.

The `create` subcommand for a class creates ``C'' statements to
synchronously create a new instance of the class.
A reference to the instance is placed in the variable called, _instref_.
If _instref_ has not been previously declared, it is declared
automatically.
The attributes of the newly created instance are set to the values given
by the _attrN / valueN_ pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the `create` subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
If _class_ has an associated state model,
then the newly created instance is placed in the default initial state
that was defined for the state model.
No state activity is executed since the instance creation is done
synchronously.
*****
{nbsp}

[source,tcl]
----
<<generation support commands>>=
proc ClassCreate {className instref args} {
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    set attrvalues [GetAttrInitialValues $className $args]

    append result\
        [linecomment "$className create $instref [list $args]"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_CreateInstance(&$classDesc, MRT_StateCode_IG) ;\n"\
        [AssignAttributeValues $className $instref $attrvalues]

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc AssignAttributeValues {className instref attrvalues} {
    variable domain
    set result {}
    foreach {attrName attrValue} $attrvalues {
        set attrRef [Attribute findById Domain $domain Class $className\
            Name $attrName]
        lassign [readAttribute $attrRef DataType Dimension] type dim
        if {$dim > 0} {
            # Got a matrix, see if it is a string
            if {$type eq "char"} {
                set maxchars [expr {$dim - 1}]
                append result\
                    "strncpy($instref->$attrName, $attrValue, $maxchars) ;\n"\
                    "$instref->$attrName\[$maxchars\] = '\\0' ;\n"
            } else {
                append result "memcpy($instref->$attrName, $attrValue,\
                    sizeof($instref->$attrName)) ;\n"
            }
        } else {
            append result "$instref->$attrName = $attrValue ;\n"
        }
    }
    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc GetAttrInitialValues {className attrvalues} {
    if {[llength $attrvalues] % 2 != 0} {
        error "attribute names / values must be given in pairs,\
            got: \"$attrvalues\""
    }
    set required [FindRequiredAttributes $className]
    set defaulted [FindDefaultedAttributes $className]
    set supplied [dict keys $attrvalues]

    set missing [::struct::set difference $required $supplied]
    if {![::struct::set empty $missing]} {
        error "values for attributes, \"[join $missing {, }]\", must be\
            provided"
    }
    set all [::struct::set union $required [dict keys $defaulted]]
    set extra [::struct::set difference $supplied $all]
    if {![::struct::set empty $extra]} {
        error "class, $className, has no attribute(s) named,\
            \"[join $extra {, }]\""
    }

    return [dict merge $defaulted $attrvalues]
}
----

[source,tcl]
----
<<generation support commands>>=
proc FindRequiredAttributes {className} {
    variable domain
    set attrRefs [Attribute findWhere\
        {$Domain eq $domain && $Class eq $className}]
    set defRefs [findRelated $attrRefs ~R22 R22]
    return [pipe {
        refMinus $attrRefs $defRefs |
        deRef ~ |
        relation list ~ Name
    }]
}

proc FindDefaultedAttributes {className} {
    variable domain
    return [pipe {
        DefaultValue findWhere {$Domain eq $domain && $Class eq $className} |
        deRef ~ |
        relation dict ~ Attribute Value
    }]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-26.0 {
    Generated code file instance creation
} -setup {
    validateutils genMiccaFile codegen26 {
        domain codegen26 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx color 30 temp 22>%
                printf("%d\n", %<instance newx attribute color>%) ;
            }
        }
        population codegen26 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen26.c
    testConditions\
        {[validateutils matchLines codegen26.c {
        struct X *newx ;
        newx = mrt_CreateInstance(&codegen26__CLASSES[0], MRT_StateCode_IG) ;
        newx->color = 30 ;
        newx->temp = 22 ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.1 {
    Generated code file instance creation -- bad arguments to create
} -setup {
    makeFile {} codegen26_1.h
    makeFile {} codegen26_1.c
    micca configure {
        domain codegen26_1 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx 30>% // need name / value pairs
            }
        }
        population codegen26_1 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.2 {
    Generated code file instance creation -- missing attribute
} -setup {
    makeFile {} codegen26_2.h
    makeFile {} codegen26_2.c
    micca configure {
        domain codegen26_2 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx>% // missing attribute, temp
            }
        }
        population codegen26_2 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.3 {
    Generated code file instance creation -- extra attribute
} -setup {
    makeFile {} codegen26_3.h
    makeFile {} codegen26_3.c
    micca configure {
        domain codegen26_3 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx temp 20 size 30>% // no attribute, size
            }
        }
        population codegen26_3 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.4 {
    Generated code file instance creation with string
} -setup {
    # makeFile {} codegen26_4.h
    # makeFile {} codegen26_4.c
    micca configure {
        domain codegen26_4 {
            class X {
                attribute color char -dimension 32 -default {"red"}
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx color {"blue"} temp 22>%
                printf("%s\n", %<instance newx attribute color>%) ;
                char *newcolor = "yellow" ;
                %<X create newx color newcolor temp 10>%
            }
        }
        population codegen26_4 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {strncpy} codegen26_4.c]] == 2}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc ClassCreateIn {className instref state args} {
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    set statenum [GetStateNumber $domain $className $state]
    set attrvalues [GetAttrInitialValues $className $args]

    append result\
        [linecomment "$className createin $instref $state [list $args]"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_CreateInstance(&$classDesc, $statenum) ;\n"\
        [AssignAttributeValues $className $instref $attrvalues]

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc GetStateNumber {domain className state} {
    set stateRef [StatePlace findById Domain $domain Model $className\
            Name $state]
    if {[isEmptyRef $stateRef]} {
        error "class, $className, has no state named, $state"
    }
    return [readAttribute $stateRef Number]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-27.0 {
    Generated code file instance creation in a given state
} -setup {
    # makeFile {} codegen27.h
    # makeFile {} codegen27.c
    micca configure {
        domain codegen27 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    state s2 {} {
                        printf("in s2\n") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createin newx s2 color 30>%
                printf("%d\n", %<instance newx attribute color>%) ;
            }
        }
        population codegen27 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_CreateInstance} codegen27.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-27.1 {
    Generated code file instance creation in a given state -- bad state
} -setup {
    makeFile {} codegen27_1.h
    makeFile {} codegen27_1.c
    micca configure {
        domain codegen27_1 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    state s2 {} {
                        printf("in s2\n") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createin newx s3>%
                printf("%d\n", %<instance newx attribute color>%) ;
            }
        }
        population codegen27_1 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc ClassCreateAsync {className event eventparams args} {
    variable domain

    if {[llength $eventparams] % 2 != 0} {
        error "event parameters must be given as name / value pairs, got:\
            \"$eventparams\""
    }
    set eventRef [Event findById Domain $domain Model $className Event $event]
    if {[isEmptyRef $eventRef]} {
        error "class, $className, has no event named, $event"
    }
    set eventNum [readAttribute $eventRef Number]

    append result\
        [linecomment "$className createasync $event [list $eventparams]\
            [list $args]"]

    set psig [findRelated $eventRef R69]
    set params [FindParamsFromSig $psig]
    if {[relation isnotempty $params]} {
        set required [relation list $params Name]
        set supplied [dict keys $eventparams]
        if {![::struct::set equal $required $supplied]} {
            error "event, $event, requires parameters,\
                \"[join $required {, }]\", got:\
                \"[join $supplied {, }]\""
        }

        set eparamsname ${domain}_${className}_${event}__EPARAMS
        set paramvar [CreateTempSymbol Ctype "struct *$eparamsname"\
            Type EventParams Class $className]

        append result\
            "struct $eparamsname $paramvar = \{\n"
        relation foreach param $params -ascending Position {
            relation assign $param Name
            append result "    .$Name = [dict get $eventparams $Name],\n"
        }
        append result "\} ;\n"

        set paramptr &$paramvar
        set paramsize sizeof($paramvar)
    } else {
        set paramptr = NULL ;
        set paramsize = 0 ;
    }

    set sourceinst [expr {[LookUpSymbol self] eq {} ? "NULL" : "self"}]

    lassign [CreateTempRefSymbol $className] reftype refvar
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    set attrvalues [GetAttrInitialValues $className $args]
    append result\
        "$reftype$refvar = mrt_CreateAsync(&$classDesc, $eventNum,\
            $paramptr, $paramsize, $sourceinst) ;\n"\
        [AssignAttributeValues $className $refvar $attrvalues]

    return [IndentToBlock $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-28.0 {
    asynchronous instance creation
} -setup {
    # makeFile {} codegen28.h
    # makeFile {} codegen28.c
    micca configure {
        domain codegen28 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {a int} {
                        printf("in s1 with %d\n", a) ;
                    }
                    state s2 {b char} {
                        printf("in s2 with %c\n", b) ;
                    }
                    transition @ - e3 -> s1
                    transition @ - e4 -> s2
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createasync e3 {a 20} color 30>%
            }
        }
        population codegen28 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_CreateAsync} codegen28.c]] == 1}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc ClassForeachInstance {className instref} {
    variable domain

    set iter [CreateTempSymbol Ctype {MRT_InstIterator}\
            Type InstanceIterator Class $className]

    set startlevel [GetBlock]

    set classDesc [GetClassDescriptor $domain $className]
    set result [IndentToBlock [string cat\
        [linecomment "$className foreachInstance $instref"]\
        "MRT_InstIterator $iter ;\n"\
        "for (mrt_InstIteratorStart(&$iter, &$classDesc) ;\
            mrt_InstIteratorMore(&$iter) ;\
            mrt_InstIteratorNext(&$iter)) \{\n"\
    ]]
    PushBlock
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstIteratorGet(&$iter) ;\n"\
    ]]

    PushContext ClassForeachInstance depth [expr {[GetBlock] - $startlevel}]

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-29.0 {
    Iterate over non-union subclass
} -setup {
    # makeFile {} codegen29.h
    # makeFile {} codegen29.c
    micca configure {
        domain codegen29 {
            class X {
                attribute color int -default 20
            }

            domainop void printcolors {} {
                %<X foreachInstance xref>%
                    printf("%d\n", %<instance xref attribute color>%) ;
                %<end>%
            }
        }
        population codegen29 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {xref->color} codegen29.c]] == 1}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc ClassForeachWhere {className instref where} {
    variable domain

    set startlevel [GetBlock]

    set classDesc [GetClassDescriptor $domain $className]
    set iter [CreateTempSymbol Ctype {MRT_InstIterator}\
            Type InstanceIterator Class $className]
    set result [IndentToBlock [string cat\
        [linecomment "$className foreachWhere $instref [list $where]"]\
        "MRT_InstIterator $iter ;\n"\
        "for (mrt_InstIteratorStart(&$iter, &$classDesc) ;\
            mrt_InstIteratorMore(&$iter) ;\
            mrt_InstIteratorNext(&$iter)) \{\n"\
    ]]
    PushBlock
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstIteratorGet(&$iter) ;\n"\
        "if ($where) \{\n"\
    ]]
    PushBlock

    PushContext ClassForeachWhere depth [expr {[GetBlock] - $startlevel}]

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-53.0 {
    Generate instance set from class instances.
} -setup {
    validateutils genMiccaFile codegen53 {
        domain codegen53 {
            class X {
                attribute id unsigned
                attribute color int -default 20

                classop {struct X *} findById {id unsigned} {
                    %<X instref xref>%
                    %<X foreachWhere xref {xref->id == id}>%
                        return xref ;
                    %<end>%
                    return NULL ;
                }
            }
        }
        population codegen53 {
            class X {
                instance x1 id 100 color 30
                instance x2 id 101
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen53.c
    validateutils matchLines codegen53.c {
        MRT_InstIterator t__T1 ;
        for (mrt_InstIteratorStart(&t__T1, &codegen53__CLASSES[0]) ; mrt_InstIteratorMore(&t__T1) ; mrt_InstIteratorNext(&t__T1)) {
            xref = mrt_InstIteratorGet(&t__T1) ;
            if (xref->id == id) {
                return xref ;
            }
        }
    }
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc ClassSelectWhere {className instref where instset} {
    variable domain
    set result [IndentToBlock\
        [linecomment "$className selectWhere $instref [list $where] $instset"]\
    ]

    set startlevel [GetBlock]

    set classDesc [GetClassDescriptor $domain $className]
    append result [IndentToBlock [string cat\
        [CreateInstSetSymbol $className $instset]\
        "mrt_InstSetInitialize(&$instset, &$classDesc) ;\n"]\
    ]

    set iter [CreateTempSymbol Ctype {MRT_InstIterator}\
            Type InstanceIterator Class $className]
    append result [IndentToBlock [string cat\
        "MRT_InstIterator $iter ;\n"\
        "for (mrt_InstIteratorStart(&$iter, &$classDesc) ;\
            mrt_InstIteratorMore(&$iter) ;\
            mrt_InstIteratorNext(&$iter)) \{\n"\
    ]]
    PushBlock

    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstIteratorGet(&$iter) ;\n"\
        "if ($where) \{\n"\
    ]]
    PushBlock

    append result [IndentToBlock\
        "mrt_InstSetAddInstance(&$instset, $instref) ;\n"\
    ]

    set depth [expr {[GetBlock] - $startlevel}]
    for {set i 0} {$i < $depth} {incr i} {
        PopBlock
        append result [IndentToBlock "\}\n"]
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-52.0 {
    Generate instance set from class instances.
} -setup {
    validateutils genMiccaFile codegen52 {
        domain codegen52 {
            class X {
                attribute color int -default 20
            }

            domainop void printcolors {} {
                %<X selectWhere xref {xref->color != 20} xset>%
            }
        }
        population codegen52 {
            class X {
                instance x1 color 30
                instance x2
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen52.c
    validateutils matchLines codegen52.c {
        MRT_InstSet xset ;
        mrt_InstSetInitialize(&xset, &codegen52__CLASSES[0]) ;
        MRT_InstIterator t__T1 ;
        for (mrt_InstIteratorStart(&t__T1, &codegen52__CLASSES[0]) ; mrt_InstIteratorMore(&t__T1) ; mrt_InstIteratorNext(&t__T1)) {
            struct X *xref ;
            xref = mrt_InstIteratorGet(&t__T1) ;
            if (xref->color != 20) {
                mrt_InstSetAddInstance(&xset, xref) ;
            }
        }
    }
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc ClassInstanceReference {className varName} {
    return [IndentToBlock [string cat\
        [linecomment "$className instref $varName"]\
        "[CreateInstRefSymbol $className $varName]"\
        "$varName = NULL ;\n"\
    ]]
}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassIdToRef {className instid instref} {
    variable domain

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstanceReference(&$classDesc, $instid) ;\n"
    return [IndentToBlock $result] ;
}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassFindByName {className instName instref} {
    variable domain
    set instRef [ClassInstance findById Domain $domain Class $className\
        Instance $instName]
    if {[isEmptyRef $instRef]} {
        error "class, $className, has no instance named, $instName"
    }
    set classDesc [GetClassDescriptor $domain $className]
    set instNum [readAttribute $instRef Number]
    append result\
        [linecomment "$className findByName $instName $instref"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstanceReference(&$classDesc, $instNum) ;\n"
    return [IndentToBlock $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-25.0 {
    Iterate over union subclass
} -setup {
    # makeFile {} codegen25.h
    # makeFile {} codegen25.c
    micca configure {
        domain codegen25 {
            class A {}
            class B {}
            class X {
                attribute color int -default 20
                attribute temp int -default 40
                attribute size int -default 50

            }
            generalization R1 -union A B X

            class Y {
                attribute sign bool -default true
                attribute cost int -default 10

                statemodel {
                    state s1 {} {
                        %<Z foreachInstance zref>%
                            printf("%d\n", %<instance zref attribute plus>%) ;
                        %<end>%
                    }
                    transition s1 - e1 -> s1
                }
            }
            class Z {
                attribute magnitude bool -default false
                attribute plus int -default 42
            }

            generalization R2 -union X Y Z
        }
        population codegen25 {
            class A {
                instance a1
                instance a2
                instance a3
                instance a4
            }
            class B {
                instance b1 R1 a1
            }
            class X {
                instance x1 R1 a2
                instance x2 R1 a3
                instance x3 R1 a4
            }
            class Y {
                instance y1 R2 x1
            }
            class Z {
                instance z1 R2 x2
                instance z2 R2 x3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {struct Z} codegen25.c]] == 7}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc ClassOperation {className opName args} {
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set opRef [Operation findWhere {$Domain eq $domain && $Class eq $className\
        && $Name eq $opName && !$IsInstance}]
    if {[isEmptyRef $opRef]} {
        error "unknown class operation, $opName, for class, $className"
    }

    set provided [dict keys $args]
    set params [deRef [findRelated $opRef ~R4]]
    set required [relation list $params Name -ascending Number]
    ValidateParams $opName $provided $required

    set pset {}
    foreach pname $required {
        append pset "[dict get $args $pname], "
    }
    set pset [string trimright $pset {, }]

    return "${className}_$opName\($pset\)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassInstanceSet {className varName} {
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    return [IndentToBlock [string cat\
        [linecomment "$className instSet $varName"]\
        [CreateInstSetSymbol $className $varName]\
        "mrt_InstSetInitialize(&$varName, &$classDesc) ;\n"\
    ]]
}
----

=== Relationship Commands

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleRelateForw {relName source target} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $source $target"]]\
        [SimpleAssocLinkage $relName $source $target mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleRelateBack {relName target source} {
    return [string cat [IndentToBlock\
        [linecomment "~$relName relate $target $source"]]\
        [SimpleAssocLinkage $relName $source $target mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleUnrelateForw {relName source target} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $source $target"]]\
        [SimpleAssocLinkage $relName $source $target mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleUnrelateBack {relName target source} {
    return [string cat [IndentToBlock\
        [linecomment "~$relName unrelate $source $target"]]\
        [SimpleAssocLinkage $relName $source $target mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc SimpleAssocLinkage {relName sourceref targetref opname} {
    variable domain
    set relRef [SimpleAssociation findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R31 R30] Number]
    set rship &${domain}__RSHIPS\[$relNum\]

    set sourceClass [readAttribute [findRelated $relRef ~R32] Class]
    CheckInstRefSymbol $sourceref Class $sourceClass

    set targetClass [readAttribute [findRelated $relRef ~R33] Class]
    CheckInstRefSymbol $targetref Class $targetClass

    return [IndentToBlock "$opname\($rship, $sourceref, $targetref\) ;\n"]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-30.0 {
    Relate and unrelate simple association
} -setup {
    # makeFile {} codegen30.h
    # makeFile {} codegen30.c
    micca configure {
        domain codegen30 {
            class X {}
            class Y {}

            association R1 X 0..1--0..1 Y

            domainop void makePair {} {
                %<X create xref>%
                %<Y create yref>%
                %<~R1 relate yref xref>%
            }

            domainop void breakPair {} {
                %<X foreachInstance xref>%
                    %<Y foreachInstance yref>%
                        %<R1 unrelate xref yref>%
                    %<end>%
                %<end>%
            }
        }
        population codegen30 {
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Relate} codegen30.c]] == 1}\
        {[llength [fileutil::grep {mrt_Unrelate} codegen30.c]] == 1}
} -result {1}
----
endif::showtests[]

// HERE
// Improve this interface to take advantage of automatically creating
// the associator class instance.
// proc arguments should be:
// proc RelClassRelate {relName oneref otherref {assocref {}} args}
// If the assocref is empty, then create an instance using args as the
// attribute values. Otherwise, use the named reference and args must
// be empty.

[source,tcl]
----
<<generation support commands>>=
proc RelClassRelateForw {relName source target assoc} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $source $target $assoc"]]\
        [ClassAssocLinkage $relName $source $target $assoc mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelClassRelateBack {relName target source assoc} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $target $source $assoc"]]\
        [ClassAssocLinkage $relName $source $target $assoc mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelClassUnrelateForw {relName source target assoc} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $source $target $assoc"]]\
        [ClassAssocLinkage $relName $source $target $assoc mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelClassUnrelateBack {relName target source assoc} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $target $source $assoc"]]\
        [ClassAssocLinkage $relName $source $target $assoc mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassAssocLinkage {relName sourceref targetref assocref opname} {
    variable domain
    set relRef [ClassBasedAssociation findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R31 R30] Number]
    set rship &${domain}__RSHIPS\[$relNum\]

    set sourceClass [readAttribute [findRelated $relRef ~R34] Class]
    CheckInstRefSymbol $sourceref Class $sourceClass

    set targetClass [readAttribute [findRelated $relRef ~R35] Class]
    CheckInstRefSymbol $targetref Class $targetClass

    set assocClass [readAttribute [findRelated $relRef ~R42] Class]
    set assocsym [CheckInstRefSymbol $assocref Class $assocClass]

    return [IndentToBlock "$opname\($rship, $sourceref, $targetref, $assocref\) ;\n"]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-31.0 {
    Relate and unrelate class based association
} -setup {
    # makeFile {} codegen31.h
    # makeFile {} codegen31.c
    micca configure {
        domain codegen31 {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 0..*--0..* Y

            domainop void makePair {} {
                %<X create xref>%
                %<Y create yref>%
                %<A create aref>%
                %<~R1 relate yref xref aref>%
                %<R1 unrelate xref yref aref>%
            }
        }
        population codegen31 {
            class A {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Relate} codegen31.c]] == 1}\
        {[llength [fileutil::grep {mrt_Unrelate} codegen31.c]] == 1}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenRelateForw {relName subref superref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $subref $superref"]]\
        [RefGenLinkage $relName $subref $superref mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenRelateBack {relName superref subref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $superref $subref"]]\
        [RefGenLinkage $relName $subref $superref mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenUnrelateForw {relName subref superref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $subref $superref"]]\
        [RefGenLinkage $relName $subref $superref mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenUnrelateBack {relName superref subref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $superref $subref"]]\
        [RefGenLinkage $relName $subref $superref mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RefGenLinkage {relName source target opname} {
    variable domain
    set relRef [ReferenceGeneralization findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R43 R30] Number]
    set rship &${domain}__RSHIPS\[$relNum\]

    set superClass [readAttribute [findRelated $relRef ~R36] Class]
    CheckInstRefSymbol $target Class $superClass

    set subsym [CheckInstRefSymbol $source]
    set subrefs [findRelated $relRef ~R37]
    set subclasses [relation list [deRef $subrefs] Class]
    if {[dict get $subsym Class] ni $subclasses} {
        error "expected $source to be a reference to one of,\
            \"[join $subclasses {, }]\", got: [dict get $subsym Class]"
    }

    return [IndentToBlock "$opname\($rship, $source, $target\) ;\n"]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-32.0 {
    Relate and unrelate reference generalization
} -setup {
    # makeFile {} codegen32.h
    # makeFile {} codegen32.c
    micca configure {
        domain codegen32 {
            class S {}
            class X {}
            class Y {}

            generalization R1 S X Y

            domainop void makePair {} {
                %<X create x1>%
                %<S create s1>%
                %<~R1 relate s1 x1>%
                %<R1 unrelate x1 s1>%
            }
        }
        population codegen32 {
            class S {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Relate} codegen32.c]] == 1}\
        {[llength [fileutil::grep {mrt_Unrelate} codegen32.c]] == 1}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenReclassify {relName superref subclass subref args} {
    set result [linecomment "$relName reclassify $superref $subclass $subref"]

    variable domain
    set relRef [ReferenceGeneralization findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R43 R30] Number]

    set supername [readAttribute [findRelated $relRef ~R36] Class]
    CheckSuperClassReference $supername $superref
    CheckSubClassName $subclass [findRelated $relRef ~R37]

    set classDesc [GetClassDescriptor $domain $subclass]
    append result\
        [CreateInstRefSymbol $subclass $subref]\
        "$subref = mrt_Reclassify\(&${domain}__RSHIPS\[$relNum\], $superref, "\
        "&$classDesc\) ;\n"

    set attrvalues [GetAttrInitialValues $subclass $args]
    foreach {attrName attrValue} $attrvalues {
        append result "$subref->$attrName = $attrValue ;\n"
    }

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc CheckSuperClassReference {supername superref} {
    set supersym [CheckSymbol $superref]
    if {[dict get $supersym Type] ne "Reference"} {
        error "variable, $superref, is not an instance reference"
    }
    if {$supername ne [dict get $supersym Class]} {
        error "$superref refers to an instance of class,\
            [dict get $supersym Class], but $supername is the super class\
            for $relName"
    }
}
----

[source,tcl]
----
<<generation support commands>>=
proc CheckSubClassName {subclass subRefs} {
    set subclassnames [pipe {
        deRef $subRefs |
        relation list ~ Class
    }]
    if {$subclass ni $subclassnames} {
        error "bad subclass, $subclass, should be one of:\
                [join $subclassnames {, }]"
    }
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-33.0 {
    Reclassify reference generalization
} -setup {
    # makeFile {} codegen33.h
    # makeFile {} codegen33.c
    micca configure {
        domain codegen33 {
            class S {}
            class X {}
            class Y {
                attribute color int
            }

            generalization R1 S X Y

            domainop void makePair {} {
                %<X create x1>%
                %<S create s1>%
                %<~R1 relate s1 x1>%
                %<R1 reclassify s1 Y y1 color 20>%
            }
        }
        population codegen33 {
            class S {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Reclassify} codegen33.c]] == 1}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc RelUnionGenReclassify {relName superref newClassName subref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName reclassify $superref $newClassName $subref"]]\
        [ReclassifyUnionGen $relName $superref $newClassName $subref]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelUnionGenReclassify {relName superref subclass subref args} {
    set result [linecomment "$relName reclassify $superref $subclass $subref"]

    variable domain
    set relRef [UnionGeneralization findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R43 R30] Number]

    set supername [readAttribute [findRelated $relRef ~R44] Class]
    CheckSuperClassReference $supername $superref
    CheckSubClassName $subclass [findRelated $relRef ~R45]

    set classDesc [GetClassDescriptor $domain $subclass]
    append result\
        [CreateInstRefSymbol $subclass $subref]\
        "$subref = mrt_Reclassify\(&${domain}__RSHIPS\[$relNum\], $superref, "\
        "&$classDesc\) ;\n"

    set attrvalues [GetAttrInitialValues $subclass $args]
    foreach {attrName attrValue} $attrvalues {
        append result "$subref->$attrName = $attrValue ;\n"
    }

    return [IndentToBlock $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-34.0 {
    Reclassify union generalization
} -setup {
    # makeFile {} codegen34.h
    # makeFile {} codegen34.c
    micca configure {
        domain codegen34 {
            class S {}
            class X {}
            class Y {
                attribute color int
            }

            generalization R1 -union S X Y

            domainop void makePair {} {
                %<S create s1>%
                %<R1 reclassify s1 Y y1 color 30>%
            }
        }
        population codegen34 {
            class S {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Reclassify} codegen34.c]] == 1}
} -result {1}
----
endif::showtests[]

=== Assigner Commands

[source,tcl]
----
<<generation support commands>>=
proc SingleAssignerSignal {relName event args} {
    set reftype "struct $relName *"
    set instref [CreateTempSymbol Ctype $reftype Type Reference Class $relName]

    append result\
        [linecomment "$relName signal $event [list $args]"]\
        "$reftype$instref = &${relName}__POOL\[0\] ;\n"

    return [string cat\
        [IndentToBlock $result]\
        [InstanceSignal $instref $event {*}$args]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-35.0 {
    Signal a single assigner
} -setup {
    # makeFile {} codegen35.h
    # makeFile {} codegen35.c
    micca configure {
        domain codegen35 {
            class clerk {}
            class client {}
            association R1 clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }

            domainop void clerkready {} {
                %<R1 signal clerkReady>%
            }
        }
        population codegen35 {
            class clerk {
                instance clerk1
            }
            class client {
                instance client1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_PostEvent} codegen35.c]] == 1}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc MultiAssignerCreate {relName instref idinst} {
    variable domain

    set maRef [MultipleAssigner findWhere {$Domain eq $domain &&\
            $Association eq $relName}]
    set idClass [readAttribute $maRef Class]
    CheckInstRefSymbol $idinst Class $idClass

    set assignerClass ${domain}__ASSIGNERS\[[GetClassProperty $relName Number]\]
    append result\
        [linecomment "$relName create $instref $idinst"]\
        [CreateInstRefSymbol $relName $instref]\
        "$instref = mrt_CreateInstance(&$assignerClass, MRT_StateCode_IG) ;\n"\
        "$instref->idinstance = $idinst ;\n"

    return [IndentToBlock $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-47.0 {
    Create a multi assigner
} -setup {
    # makeFile {} codegen47.h
    # makeFile {} codegen47.c
    micca configure {
        domain codegen47 {
            class clerk {}
            class client {}
            class department {
                attribute name char -dimension 32
            }

            association R1 clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            domainop void newDept {name {char const *}} {
                %<department create deptref name name>%
                %<R1 create r1ref deptref>%
            }
        }
        population codegen47 {
            class department {
                allocate 4
            }
            class clerk {
                allocate 3
            }
            class client {
                allocate 3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1__POOL} codegen47.c]] == 4}
} -result {1}
----
endif::showtests[]

== Helper Commands

[source,tcl]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }
    namespace import ::micca::@Config@::Helpers::typeCheck

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,tcl]
----
<<generation helper commands>>=
proc banner {} {
    set marker [string repeat - 70]
    string cat\
        "/*\n"\
        " * $marker\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * $marker\n"\
        " */\n"
}
----

[source,tcl]
----
<<generation helper commands>>=
proc comment {args} {
    set result "/*\n"
    foreach c $args {
        append result [::textutil::adjust::indent\
            [::textutil::adjust::adjust $c] { * }]\n
    }
    append result " */\n"

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc linecomment {text} {
    set result {}
    foreach line [split $text \n] {
        append result "// $line\n"
    }
    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc blockcomment {block} {
    return [textutil::adjust::indent [textutil::adjust::undent\
            [string trim $block \n]] {// }]\n
}
----

[source,tcl]
----
<<generation helper commands>>=
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

[source,tcl]
----
<<generation helper commands>>=
proc GenInstanceAddress {domainName className instName} {
    set path {}
    set usubRef [UnionSubclass findWhere {$Domain eq $domainName &&\
        $Class eq $className}]
    if {[isNotEmptyRef $usubRef]} {
        # puts [relformat [deRef $usubRef] usubRef]
        while {[isNotEmptyRef $usubRef]} {
            assignAttribute $usubRef {Relationship rship} {Class subName}
            set path .$rship.${subName}$path

            set usuperRef [findRelated $usubRef R45 ~R44]
            set superClass [readAttribute $usuperRef Class]

            set usubRef [pipe {
                deRef $usuperRef |
                relation semijoin ~ $::micca::UnionSubclass\
                    -using {Domain Domain Class Class} |
                ::rosea::Helpers::ToRef ::micca::UnionSubclass ~
            }]
            # puts [relformat [deRef $usubRef] usubRef]
        }

        # puts "path = \"$path\""
        set storageClass $superClass
    } else {
        set storageClass $className
    }
    set instNumber [readAttribute\
            [ClassInstance findById Domain $domainName Class $className\
                Instance $instName]\
        Number]
    return &${storageClass}__POOL\[$instNumber\]$path
}
----
