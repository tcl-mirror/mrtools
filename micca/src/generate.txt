// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain implementation.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time provides functions to map model level actions
onto the target platform.

The remaining component is to generate ``C'' code for a domain.
Code generation consist of two major pieces:

* Generating initialized ``C'' variables that supply the data values
required by the run time.
* Generating the ``C'' code for model level operations in
state activities and domain operations.
This facilitates interfacing to the run time code.

`Micca` does not compile an action language into the target ``C'' for
state activities.
Rather,
it passes along the ``C'' code provided for the activities wrapped up
as functions.
However,
to insulate the user supplied ``C'' code from the details of
the run time function interfaces and the data structures used,
`micca` performs an additional level of macro expansion on the
state activities and operations code.
Thus the supplied ``C'' code for activities contains embedded macros
and these are expanded to support interfacing to the run time and performing
other model level activities.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,tcl]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,tcl]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation support namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

=== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
Generally,
one is required to declare symbols before they are defined.
The ordering has to be quite precise.
One way to accomplish this is to use a template.
The template is organized in the order required by the compiler
and contains embedded commands.
When expanded,
the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from `tcllib`.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,tcl]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

Because we are using a template expansion technique to generate the code
files,
the implementation of code generation has the flavor of a report generator.
Commands imbedded in the template make queries on the populated
platform model and emit a _report_ of the query, which in this case
is a set of ``C'' language statements.
Although the reports generated are intended to be consumed by a compiler
rather than a human,
the design of the generator is very similar to generating reports
from a database.
In this case the database is the platform model as populated by
a configuration script and the reports are ``C'' code placed in files
and intended to be processed later by a compiler.

(((micca,Gen,miccaGenerate)))
[source,tcl]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: generate files>>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return $genfiles
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation error(s)}
----

We set up options for the generation in a dictionary.
The default values are given and can be overridden by those passed in.

[source,tcl]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror     fail\
    stubexternalops false\
]
set options [dict merge $options $arglist]
----

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,tcl]
----
<<miccaGenerate: verify domains are populated>>=
set badpops [pipe {
    Population findAll |
    findUnrelated ~ R100
}]

forAllRefs badpop $badpops {
    set domainName [readAttribute $badpop Name]
    log::error "for domain, \"$domainName\", no population is given"
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

The `expander` package creates a command that, when invoked with a
template, performs the expansion.
Here we set up that command and specify some options to it.

[source,tcl]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand setbrackets %< >%
expand errmode [dict get $options expanderror]
----

Generating the files happens by iterating over all the domains and
generating a header file and a code file for each one.

[source,tcl]
----
<<miccaGenerate: generate files>>=
set genfiles [list]
try {
    forAllRefs domainRef [Domain findAll] {
        assignAttribute $domainRef {Name domain} {Interface interface}\
            {Prologue prologue} {Epilogue epilogue}

        GatherDomainProperties $domain

        lappend genfiles $domain.h
        <<miccaGenerate: generate header file>>
        lappend genfiles $domain.c
        <<miccaGenerate: generate code file>>
    }
} finally {
    rename expand {} ; # <1>
}
----
<1> The template expander creates a new command and we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

To generate the header file,
we set up some variable in the namespace where the template
expansion occurs.
These variables define the domain context for the header generation.
We perform the expansion in the `GenHeader` namespace so that the
command embedded in the template resolve without qualification and
we don't have any name conflicts between those commands and other
code generation commands.

[source,tcl]
----
<<miccaGenerate: generate header file>>=
set GenHeader::domain $domain
set GenHeader::interface $interface
set GenSupport::domain $domain

expand evalcmd "namespace eval [namespace current]::GenHeader"
set hchan [::open $domain.h w]
try {
    variable headerTemplate
    puts $hchan [expand expand $headerTemplate]
} on error {result opts} {
    # puts $::errorInfo
    return -options $opts $result
} finally {
    chan close $hchan
}
----

Generating the code files is done in a similar manner.
In this case,
we perform the generation in the `GenCode` namespace.

[source,tcl]
----
<<miccaGenerate: generate code file>>=
set GenCode::domain $domain
set GenCode::prologue $prologue
set GenCode::epilogue $epilogue

CreateActivityCommands $domain

expand evalcmd "namespace eval [namespace current]::GenCode"
set cchan [::open $domain.c w]
try {
    variable codeTemplate
    puts $cchan [expand expand $codeTemplate]
} on error {result opts} {
    # puts $::errorInfo
    return -options $opts $result
} finally {
    chan close $cchan
    namespace delete GenActivity
}
----

=== Common Domain Queries

There are a number of queries about the properties of domains that
common and frequent enough to warrant factoring the queries into a
more convenient form.

We start by accumulating some common properties of a domain.
We will store these properties in a relation value that are held in
an ordinary namespace variables

(((micca,Helpers,GatherDomainProperties)))
[source,tcl]
----
<<generation helper commands>>=
proc GatherDomainProperties {domain} {
    variable ClassProperties

    set assigners [pipe {
        AssignerStateModel findWhere {$Domain eq $domain} |
        deRef ~ |
        ralutil::rvajoin ~ $::micca::SingleAssigner Single |
        ralutil::rvajoin ~ $::micca::MultipleAssigner Multiple |
        relation tag ~ Number -ascending Association |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Association]"}\
            Reference string {"struct [tuple extract $stup Association] *"}\
            ConstReference string\
                    {"struct [tuple extract $stup Association] const *"}\
            StorageVariable string {"[tuple extract $stup Association]__POOL"}\
            ClassVariable string {"${domain}__ASSIGNERS"}
    }]

    set sassigners [pipe {
        relation restrictwith $assigners {[relation isnotempty $Single]} |
        relation eliminate ~ Domain Single Multiple |
        relation rename ~ Association Name |
        relation extend ~ stup\
            Allocation int {0}\
            InitialInstance int {1}\
            TotalInstance int {1}
    }]
    # puts [relformat $sassigners sassigners]

    set massigners [pipe {
        relation restrictwith $assigners {[relation isnotempty $Multiple]} |
        relation rename ~ Number AssignerNumber |
        ralutil::rvajoin ~ $::micca::MultipleAssignerInstance Instances |
        relation ungroup ~ Multiple |
        relation join ~ $::micca::ClassPopulation |
        relation extend ~ stup\
            InitialInstance int\
                {[relation cardinality [tuple extract $stup Instances]]}\
            TotalInstance int {[tuple extract $stup Allocation]} |
        relation eliminate ~ Domain Single Class Instances |
        relation rename ~ Association Name AssignerNumber Number
    }]
    # puts [relformat $massigners massigners]

    set classRefs [Class findWhere {$Domain eq $domain}]
    set allocs [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} |
        deRef % |
        relation project % Class Allocation |
        relation rename % Class Name
    } {} |%]

    set insts [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation project % Class Number |
        relation rename % Class Name
    } {} |%]

    set ClassProperties [pipe {
        deRef $classRefs |
        relation project ~ Name Number |
        relation rename ~ Number ClassNumber |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            ConstReference string {"struct [tuple extract $stup Name] const *"}\
            StorageVariable string {"[tuple extract $stup Name]__POOL"}\
            ClassVariable string {"${domain}__CLASSES"} |
        ralutil::rvajoin ~ $allocs Allocations |
        relation extend ~ atup Allocation int {
            [relation isempty [tuple extract $atup Allocations]] ?\
            0 : [relation extract [tuple extract $atup Allocations] Allocation]
        } |
        relation eliminate ~ Allocations |
        ralutil::rvajoin ~ $insts Instances |
        relation extend ~ itup\
            InitialInstance int {
                [relation cardinality [tuple extract $itup Instances]]} \
            TotalInstance int {
                [relation cardinality [tuple extract $itup Instances]] +
                [tuple extract $itup Allocation]} |
        relation eliminate ~ Instances |
        relation rename ~ ClassNumber Number |
        relation union ~ $sassigners $massigners
    }]
    # puts [relformat $ClassProperties ClassProperties]

    return
}
----

We need some procedures to access the properties.

(((micca,Helpers,GetClassProperty)))
[source,tcl]
----
<<generation helper commands>>=
proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}
----

The class descriptor array element for a given class is commonly needed.

(((micca,Helpers,GetClassDescriptor)))
[source,tcl]
----
<<generation helper commands>>=
proc GetClassDescriptor {domain className} {
    return [string cat\
        [GetClassProperty $className ClassVariable]\
        \[ [GetClassProperty $className Number] \]

    ]
}
----

== Header Files

The header file generated for a domain contains interfacing information.
The header file is included in the generated ``C'' code file and,
typically, is included by bridge code that is
mapping the dependencies of one domain onto another.

Following our usual pattern,
we will execute the header generation commands from the template in
a child namespace to avoid any name conflicts.

The `GenHeader` namespace is a child of `::micca::@Gen@` and follows
our usual pattern of imports, command path and contents.

[source,tcl]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

The template for the header file is shown below.
Each embedded command is then shown in the following sections.

[source,tcl]
----
<<generation data>>=
set headerTemplate [textutil::adjust::undent {
    %<banner>%
    #ifndef %<headerFileGuard>%
    #define %<headerFileGuard>%
    #include "micca_rt.h"
    %<interface>%
    %<interfaceTypeAliases>%
    %<domainOpDeclarations>%
    %<externalOpDeclarations>%
    %<eventParamDeclarations>%
    %<portalIds>%
    %<portalDeclaration>%
    #endif /* %<headerFileGuard>% */
}]
----

The generation of the header files is accomplished by iterating
over all the domains and placing the output of the template
expansion into a file.
We use some variables to provide context to the embedded expansion commands.

The commands embedded in the template all follow a similar pattern.
The return values of the commands are placed in the output of the
template expansion.

=== Header File Guard

The generated header file includes definitions of preprocessor symbols
to prevent the header file from being included multiple times.

(((micca,Header Generation,headerFileGuard)))
[source,tcl]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return [string toupper [string trim $domain]]_H_
}
----

=== Domain Interface

Arbitrary code may be placed in the generated header file by
invoking the `interface` command as part of the domain configuration.
The text provided during configuration is simply passed into the
generated header file.

(((micca,Header Generation,interface)))
[source,tcl]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    return [string cat\
        [comment "Domain Interface Contents"]\
        [textutil::adjust::undent [string trim $interface]]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    validateutils genMiccaFile header1 {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils matchLines header1.h {
        #include <stdio.h>
    }
} -result {1}
----
endif::showtests[]

=== Type Aliases

The domain configuration can contain type aliases.
Normally,
the type alias information is placed in the generated code file.
However, if a type alias name is used in a context where it would be
exposed outside of the domain,
_e.g._ as a parameter to a domain operation,
then the type alias definition is placed in the generated header file.
There are three circumstances where a type is needed external to the domain:

. As the return type or parameter type of a domain operation.
. As the return type or parameter type of an external operation.
. As an argument to an event (since events can be signaled by the
portal operations).

We will have need to compute the type aliases needed by the interface
more than once, so we factor the code into a procedure.

(((micca,Helpers,FindInterfaceTypeAliases)))
[source,tcl]
----
<<generation helper commands>>=
proc FindInterfaceTypeAliases {domain} {
    set domRef [Domain findWhere {$Name eq $domain}]

    <<FindInterfaceTypeAliases:: find type alias names>>
    <<FindInterfaceTypeAliases:: find aliases in domain operations>>
    <<FindInterfaceTypeAliases:: find aliases in external operations>>
    <<FindInterfaceTypeAliases:: find aliases in events>>
    <<FindInterfaceTypeAliases:: union the combination>>

    return $aliasRefs
}
----

We compute a list of all the type alias names.
This is used below in the queries for the various types
of parameters types to determine if they are indeed one of the
type aliases.

[source,tcl]
----
<<FindInterfaceTypeAliases:: find type alias names>>=
set aliasNames [pipe {
    findRelated $domRef ~R7 |
    deRef % |
    relation list % TypeName
} {} |%]
----

Query the return types and parameters of the domain operations.

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in domain operations>>=
set doRefs [pipe {
    findRelatedWhere $domRef ~R5 {$ReturnDataType in $aliasNames} |
    findRelated % R5 ~R7
} {} |%]
set dopRefs [pipe {
    findRelatedWhere $domRef {~R5 ~R6} {$DataType in $aliasNames} |
    findRelated % R6 R5 ~R7
} {} |%]
----

The same type of query is needed for the external operations.

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in external operations>>=
set eoRefs [pipe {
    findRelatedWhere $domRef ~R10 {$ReturnDataType in $aliasNames} |
    findRelated % R10 ~R7
} {} |%]
set eopRefs [pipe {
    findRelatedWhere $domRef {~R10 ~R11} {$DataType in $aliasNames} |
    findRelated % R11 R10 ~R7
} {} |%]
----

And finally, we examine the event parameters.

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in events>>=
set argRefs [pipe {
    Argument findWhere {$Domain eq $domain && $DataType in $aliasNames} |
    deRef ~ |
    relation semijoin ~ $::micca::TypeAlias\
            -using {Domain Domain DataType TypeName} |
    ::rosea::Helpers::ToRef ::micca::TypeAlias ~
}]
----

The union of these sets is then the set of type aliases that will need
to be made available outside of the domain.

[source,tcl]
----
<<FindInterfaceTypeAliases:: union the combination>>=
set aliasRefs [refUnion $doRefs $dopRefs]
set aliasRefs [refUnion $aliasRefs $eoRefs]
set aliasRefs [refUnion $aliasRefs $eopRefs]
set aliasRefs [refUnion $aliasRefs $argRefs]
----

The implementation of the `interfaceTypeAliases` iterates over the
type aliases that are used in the domain interfaces and emits the
corresponding ``C'' `typedef` statement.

(((micca,Header Generation,interfaceTypeAliases)))
[source,tcl]
----
<<generation header commands>>=
proc interfaceTypeAliases {} {
    variable domain
    append result [comment "Type Aliases"]
    forAllRefs taRef [FindInterfaceTypeAliases $domain] {
        assignAttribute $taRef TypeName TypeDefinition
        append result "typedef "\
            [typeCheck composeDeclaration $TypeDefinition $TypeName] " ;\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    validateutils genMiccaFile header2 {
        domain header2 {
            typealias Gcount_t uint64_t
            typealias Pcount_t uint32_t

            domainop Gcount_t countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b Pcount_t} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    testConditions\
        {[validateutils matchLines header2.h {
            typedef uint32_t Pcount_t ;
        }]}\
        {[validateutils matchLines header2.h {
            typedef uint64_t Gcount_t ;
        }]}
} -result {1}
----
endif::showtests[]

=== Domain Operation Declarations

``C'' language programs are composed of _declarations_ and
_definitions_.
A declaration makes symbol names and types known to the compiler.
A definition associates specific data or code statements to a symbol.
Header files contain a lot of declarations.
Here we start with declarations for the domain operations.
Domain operations are just ordinary ``C'' functions but are given
external scope.

There are several different operations defined in the platform model.
Since they use the same attribute names,
it is possible to factor the generation of declaration code into
a common procedure.
We need to know the instance references to the operation
and the name of the relationship used to find the parameters of
the operation.
Optionally, a suffix can be added to the ``C'' identifier for the
operation.

(((micca,Helpers,GenOperationDeclarations)))
[source,tcl]
----
<<generation helper commands>>=
proc GenOperationDeclarations {opRefs paramRel {suffix {}}} {
    set result {}

    set params [deRef [findRelated $opRefs $paramRel]] ; # <1>
    set ops [pipe {
        deRef $opRefs |
        relation project ~ Domain Name ReturnDataType Comment |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $params Parameters
    }]
    # puts [relformat $ops ops]

    relation foreach op $ops {
        relation assign $op
        if {$Comment ne {}} {
            append result [comment [string trim $Comment \n]]
        }
        set plist [relation list $Parameters DataType -ascending Number]
        set pdecl [expr {[llength $plist] == 0 ? "void" : [join $plist {, }]}]
        append result "extern $ReturnDataType\
                ${Domain}_${Operation}$suffix\($pdecl\) ;\n" ; # <2>
    }

    return $result
}
----
<1> Passing in a relationship name as an argument may appear unconventional,
but this is Tcl and portions of a query can be variable.
<2> Note that we prepend the domain name to the operation name
in order to avoid naming conflicts in the global namespace.
Naming conventions are necessary when dealing with a language like
``C'' which does not have support for name spaces.

Given a procedure to emit the operation declaration,
then the template expansion for the domain operations just invokes
the common code with the correct references and relationship name.

(((micca,Header Generation,domainOpDeclarations)))
[source,tcl]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    return [string cat\
        [comment "Domain Operations External Declarations"]\
        [GenOperationDeclarations $opRefs ~R6]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-3.0 {
    Domain operation declarations in header file
} -setup {
    validateutils genMiccaFile header3 {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            externalop void ext1 {b int c {void *}}
            externalop void ext2 {d char e unsigned}
            class c1 {
                attribute color int -default 20
            }
        }
        population header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    testConditions\
        {[validateutils matchLines header3.h {
            /*
             * two parameters
             */
            extern int header3_op1(int, char) ;
        }]}\
        {[validateutils matchLines header3.h {
            /*
             * pointer type parameters
             */
            extern int header3_op2(char *, uint8_t *) ;
        }]}
} -result {1}
----
endif::showtests[]

=== External Operation Declarations

The declarations for external operations follows the same pattern as
for domain operations.

(((micca,Header Generation,externalOpDeclarations)))
[source,tcl]
----
<<generation header commands>>=
proc externalOpDeclarations {} {
    variable domain
    set opRefs [ExternalOperation findWhere {$Domain eq $domain}]

    return [string cat\
        [comment "External Operations Declarations"]\
        [GenOperationDeclarations $opRefs ~R11 __EOP]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-3.1 {
    External operation declarations in header file
} -setup {
} -cleanup {
    validateutils forgetFiles
} -body {
    testConditions\
        {[validateutils matchLines header3.h {
            extern void header3_ext1__EOP(int, void *) ;
        }]}\
        {[validateutils matchLines header3.h {
            extern void header3_ext2__EOP(char, unsigned) ;
        }]}
} -result {1}
----
endif::showtests[]

=== Event Parameter Declarations

Since events can be signaled via the portal functions,
we need to make the parameter signature of an event available
in the header file.
Typically, bridge code will need to supply any parameter an event
may need and will need a structure declaration to do that.

(((micca,Header Generation,eventParamDeclarations)))
[source,tcl]
.Implementation
----
<<generation header commands>>=
proc eventParamDeclarations {} {
    variable domain

    set result [comment "Event Parameter Structure Declarations"]
    set evtparams [pipe {
        Event findWhere {$Domain eq $domain} |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    relation foreach evtparam $evtparams -ascending Model {
        relation assign $evtparam
        relation foreach event $Events {
            relation assign $event
            set pstructname "struct ${domain}_${Model}_${Event}__EPARAMS"
            append result "$pstructname \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
            append result\
                "static_assert(sizeof($pstructname) <= sizeof(MRT_EventParams), "\
                "\"Parameters for class or assigner, $Model, event,\
                    $Event, are too large\") ;\n" ; # <1>
        }
    }

    return $result
}
----
<1> The static assertion about the size of event parameters is an
important protection to insure there are not memory overruns.

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-10.0 {
    Generated event parameter structures
} -setup {
    validateutils genMiccaFile codegen10 {
        domain codegen10 {
            typealias MyCount_t int
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {a MyCount_t b {char *}} {
                        printf("%d %s\n", a, b) ;
                        (void)self ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            class super {
                polymorphic e1 f MyCount_t g {char *}
                polymorphic e2
            }
            class sub1 {
                statemodel {
                    state s1 {a MyCount_t b {char *}} {
                        printf("%d %s\n", a, b) ;
                        (void)self ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                        (void)self ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            class sub2 {
                statemodel {
                    state s1 {a MyCount_t b {char *}} {
                        printf("%d %s\n", a, b) ;
                        (void)self ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                        (void)self ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            generalization R1 super sub1 sub2
        }
        population codegen10 {
            class X {
                instance x1 color 30
            }
            class super {
                instance sup1
                instance sup2
            }
            class sub1 {
                instance s1 R1 sup1
            }
            class sub2 {
                instance s2 R1 sup2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen10.c
    testConditions\
        {[validateutils matchLines codegen10.h {
            struct codegen10_sub1_e1__EPARAMS {
                MyCount_t f ;
                char * g ;
            } ;
        }]}\
        {[validateutils matchLines codegen10.h {
            struct codegen10_sub2_e1__EPARAMS {
                MyCount_t f ;
                char * g ;
            } ;
        }]}\
        {[validateutils matchLines codegen10.h {
            struct codegen10_super_e1__EPARAMS {
                MyCount_t f ;
                char * g ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

=== Portal Function Constants

The run time code provides a set of
<<portal-access-functions,portal functions>>
that allow bridge code to tunnel simple model level operations, such a
signaling an event, into a domain.
The functions require integer constants that encode identifiers
for the various entities that can be accessed via the portal.
Those constants are placed in the generated header file.

We generate information on several aspects of the domain:

* Classes
* Instances
* Attributes
* Events

(((micca,Header Generation,portalIds)))
[source,tcl]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    <<portalIds:: generate class information>>
    <<portalIds:: generate assigner information>>
    <<portalIds:: generate event information>>
    <<portalIds:: generate polymorphic event information>>

    return $result
}
----

For classes,
we generate encodings for the class itself,
its attributes and its initial instances.

[source,tcl]
----
<<portalIds:: generate class information>>=
append result [comment "Numeric encoding of classes, attributes and\
        instances used by the portal functions"]
set classRefs [Class findWhere {$Domain eq $domain}]
append result "#define [string toupper ${domain}_CLASSCOUNT]\
        [refMultiplicity $classRefs]\n"
forAllRefs classRef $classRefs {
    assignAttribute $classRef
    <<portalIds:: generate class encodings>>
    <<portalIds:: generate attribute encodings>>
    <<portalIds:: generate instance encodings>>
}
----

Each class was given a unique number within the domain when
the platform model was populated.
This is the basis for the class id encodings.

[source,tcl]
----
<<portalIds:: generate class encodings>>=
append result [comment "Class: $Name"]
set classid [string toupper ${Domain}_${Name}_CLASSID]
append result "#define $classid $Number\n"
----

Attributes are encoded in alphabetical order.
Note that the portal does not allow access to relationships or
the pointer values that are used to navigate a relationship.

[source,tcl]
----
<<portalIds:: generate attribute encodings>>=
set attrRefs [findRelated $classRef ~R20 {~R25 PopulatedComponent}\
        {~R21 Attribute}]
append result "#define [string toupper ${Domain}_${Name}_ATTRCOUNT]\
        [refMultiplicity $attrRefs]\n"
set attrNumber -1
relation foreach attr [deRef $attrRefs] -ascending Name {
    relation assign $attr {Name attrName}
    set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
    append result "#define $attrid [incr attrNumber]\n"
}
----

We generate encodings for instances that are part of the initial
instance population.

[source,tcl]
----
<<portalIds:: generate instance encodings>>=
set instRefs [findRelated $classRef ~R20 ~R103]
append result "#define [string toupper ${Domain}_${Name}_INSTCOUNT]\
        [GetClassProperty $Name TotalInstance]\n"
forAllRefs inst $instRefs {
    assignAttribute $inst Instance {Number InstNumber}
    set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
    append result "#define $instid $InstNumber\n"
}
----

Assigners are treated much like classes.

[source,tcl]
----
<<portalIds:: generate assigner information>>=
set assigners [pipe {
    AssignerStateModel findWhere {$Domain eq $domain} |
    deRef ~ |
    relation tag ~ Number -ascending Association
}]
relation foreach assigner $assigners {
    relation assign $assigner
    append result [comment "Assigner: $Association"]
    set prefix [string toupper ${Domain}_${Association}]
    append result\
        "#define ${prefix}_ASSIGNERID $Number\n"\
        "#define ${prefix}_INSTCOUNT\
            [GetClassProperty $Association TotalInstance]\n"
}
----

The encoding for event numbers is obtained straight from the platform
model as they are numbered there.
In this case we query the *Event* class.

[source,tcl]
----
<<portalIds:: generate event information>>=
append result [comment "Numeric encoding of event numbers\
        used by the portal functions"]
set mevents [pipe {
    Event findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Domain PSigID |
    relation group ~ Events Event Number
}]
relation foreach mevent $mevents -ascending Model {
    relation assign $mevent
    append result [comment "Class: $Model"]
    append result "#define [string toupper ${domain}_${Model}_EVENTCOUNT]\
        [relation cardinality $Events]\n"
    relation foreach event $Events -ascending Number {
        relation assign $event
        append result "#define\
            [string toupper ${domain}_${Model}_${Event}_EVENT] $Number\n"
    }
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    validateutils genMiccaFile header4 {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population header4 {
            class c1 {
                table {
                    color
                    temp
                } fred1 {
                    20
                    3.4
                }
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    testConditions\
        {[validateutils matchLines header4.h {
            #define HEADER4_CLASSCOUNT 2
        }]}\
        {[validateutils matchLines header4.h {
            #define HEADER4_C1_CLASSID 0
            #define HEADER4_C1_ATTRCOUNT 2
        }]}\
        {[validateutils matchLines header4.h {
            #define HEADER4_C2_CLASSID 1
            #define HEADER4_C2_ATTRCOUNT 2
        }]}
} -result {1}
----
endif::showtests[]

=== Portal Data Structure Declaration

The portal functions require a
<<portal-data-structures,data structure>>
and we must emit the
declaration of that data structure.

(((micca,Header Generation,portalDeclaration)))
[source,tcl]
----
<<generation header commands>>=
proc portalDeclaration {} {
    variable domain
    append result\
        [comment "Domain Portal Declaration"]\
        "extern MRT_DomainPortal const ${domain}__PORTAL ;\n"
}
----

== Generating Code Files

In this section we describe the code used to generate the domain
code file.
We follow the pattern established for the header file.
A namespace is used to prevent any naming conflicts for the
template expansion commands.

[source,tcl]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    namespace import [namespace parent]::expand
    namespace import [namespace parent]::GenSupport::ExpandActivity

    <<generation code data>>
    <<generation code commands>>
}
----

The template for code generation is much more complicated.
In the code file we will find it necessary to emit many forward
declaration in addition to the required definitions.
For example,
it is necessary to emit forward declarations for all instance operations
since we do not know in which activity one of them might be invoked.

[source,tcl]
----
<<generation data>>=
set codeTemplate [textutil::adjust::undent {
    %<banner>%
    #ifdef MRT_INSTRUMENT
        #ifndef MRT_INSTRUMENT_ENTRY
            #define MRT_INSTRUMENT_ENTRY\
                printf("%s: %s %d\n", __func__, __FILE__, __LINE__) ;
        #endif /* MRT_INSTRUMENT_ENTRY */
        #ifndef MRT_DEBUG
            #define MRT_DEBUG(...) printf(__VA_ARGS__)
        #endif /* MRT_DEBUG */
    #else
        #define MRT_INSTRUMENT_ENTRY
        #define MRT_DEBUG(...)
    #endif /* MRT_INSTRUMENT */
    %<domainInclude>%
    %<prologueDeclarations>%
    %<implementationTypeAliases>%
    %<forwardClassDeclarations>%
    %<forwardRelationshipDeclaration>%
    %<classDeclarations>%
    %<assignerDeclarations>%
    %<stateParamDeclarations>%
    %<operationDeclarations>%
    %<ctorDeclarations>%
    %<dtorDeclarations>%
    %<formulaDeclarations>%
    %<activityDeclarations>%
    %<storageDeclarations>%
    %<nameDefinitions>%
    %<iabDefinitions>%
    %<edbDefinitions>%
    %<pdbDefinitions>%
    %<classDefinitions>%
    %<assignerDefinitions>%
    %<relationshipDefinitions>%
    %<classInstanceDefinitions>%
    %<assignerInstanceDefinitions>%
    %<operationDefinitions>%
    %<ctorDefinitions>%
    %<dtorDefinitions>%
    %<formulaDefinitions>%
    %<activityDefinitions>%
    %<domainCtorDefinition>%
    %<domainOpDefinitions>%
    %<externalOpDefinitions>%
    %<portalDefinition>%
    %<epilogueDeclarations>%
}]
----

In the following sections, we show the procedures that are
invoked as part of the code template expansion.

=== Including the Domain Header File

The generated code file includes the generated header file automatically.

(((micca,Code Generation,domainInclude)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

=== Domain Prologue

Any prologue text defined during domain configuration is placed early
in the generated code file.

(((micca,Code Generation,prologueDeclarations)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc prologueDeclarations {} {
    variable prologue

    return [string cat\
        [comment "Domain Prologue"]\
        [textutil::adjust::undent [string trim $prologue \n]]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    validateutils genMiccaFile codegen1 {
        domain codegen1 {
            prologue {#include "string.h"}
            prologue {#include "stdlib.h"}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population codegen1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen1.c
    testConditions\
        {[validateutils matchLines codegen1.c {
            #include "string.h"
        }]}\
        {[validateutils matchLines codegen1.c {
            #include "stdlib.h"
        }]}\
        {[validateutils matchLines codegen1.c {
            static int count(
                int a)
            {
                return a + 1 ;
            }
        }]}
} -result {1}
----
endif::showtests[]

=== Implementation Type Aliases

The type aliases that are not placed in the header file are placed in the
code file.

(((micca,Code Generation,implementationTypeAliases)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc implementationTypeAliases {} {
    variable domain
    set domRef [Domain findWhere {$Name eq $domain}]
    set aliasRefs [refMinus [findRelated $domRef ~R7]\
            [FindInterfaceTypeAliases $domain]] ; # <1>
    append result [comment "Type Aliases"]
    forAllRefs taRef $aliasRefs {
        assignAttribute $taRef TypeName TypeDefinition
        append result\
            "typedef "\
            [typeCheck composeDeclaration $TypeDefinition $TypeName]\
            " \;\n"
    }

    return $result
}
----
<1> The set difference between all the type aliases and those used
in the domain interface is the set that we are interested in here.

=== Forward Class Declarations

We need to introduce the structure names for the classes early in
the generated code file.
No definition of the structure is given here.
That will come later, but since class structures have pointers to
other class structures we need to tell the compiler about the names.
Sometimes the pointer references between classes are so intertwined
that we have no choice but to forward declare the class.
Rather than attempting to figure out some order that does not reference
a class structure name before it is defined,
we just emit forward declarations for all the classes.
There is no reason to do the compiler's job here.

(((micca,Code Generation,forwardClassDeclarations)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

=== Forward Relationship Declaration

The same reasoning applies to the array that holds the
relationship description information.
Class definitions will make reference to relationship descriptions
and we need to have its name known to the compiler.

(((micca,Code Generation,forwardRelationshipDeclaration)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc forwardRelationshipDeclaration {} {
    variable domain
    if {[isNotEmptyRef [Relationship findAll]]} {
        set fwrd "static MRT_Relationship const ${domain}__RSHIPS\[\] ;\n"
    } else {
        set fwrd {}
    }
    return [string cat\
        [comment "Relationship descriptors forward declaration"]\
        $fwrd\
    ]
}
----

=== Class Declarations

To declare the structures of the classes has one complication.
As usual,
union subclasses have to be treated separately.
Because the class structure of union based generalization nests
the subclasses as part of the superclass structure,
we must emit the union subclass declarations in the correct order
for the compiler.
Otherwise,
the compiler will complain as it must know the size of every member of a
structure as the structure is being declared.

The strategy here is start with the ultimate superclasses and find
those ultimate superclasses that are part of a union based generalization.
An ultimate superclass is one at the top of a generalization hierarchy,
_i.e._ a superclass that is not also a subclass of some other generalization
relationship.
For those ultimate superclasses that are part of a union based
generalization we can emit the class declarations in the tree in
reverse order.
After dealing with the union superclasses then the non-union ones can be
declared in an arbitrary order.

(((micca,Code Generation,classDeclarations)))
[source,tcl]
.Implementation
----
<<generation code commands>>=
proc classDeclarations {} {
    variable domain

    set result [comment "Class structure declarations"]

    set ultimates [pipe {
        FindUltimateSuperclasses $domain |
        findRelated % {~R48 UnionSuperclass}
    } {} |%]
    append result [DeclareUnionSubclassStructures $ultimates]

    set remaining [FindNonUnionSubclasses $domain]
    forAllRefs classRef $remaining {
        append result [DeclareClassStructure $classRef]
    }

    return $result
}
----

Since the union subclasses form a tree,
we will use a recursive procedure to walk the implied tree.
The order of traversal will be depth first which insures that
union subclasses are defined before they must be used in the
definition of the including union superclass.

(((micca,Code Generation,DeclareUnionSubclassStructures)))
[source,tcl]
----
<<generation code commands>>=
proc DeclareUnionSubclassStructures {superRefs} {
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs R44 ~R45]
    forAllRefs subRef $subRefs {
        set newsupers [pipe {
            deRef $subRef |
            relation semijoin ~ $::micca::UnionSuperclass\
                -using {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
        }] ; # <1>

        append result [DeclareUnionSubclassStructures $newsupers] ; # <2>

        append result [DeclareClassStructure [findRelated $subRef R47 R40 R41]] ; # <3>
    }

    return $result
}
----
<1> By performing the `semijoin` only across the Domain and Class attributes,
we in effect are asking if the union subclass is also a union superclass
regardless of the relationship.
<2> Recursively define the subclass structures first
so we get a depth first walk.
<3> Emit the declaration for the current subclass node.

We can find the classes not part of a union generalization by the difference
of all the classes and those that are union subclasses.

(((micca,Code Generation,FindNonUnionSubclasses)))
[source,tcl]
----
<<generation helper commands>>=
proc FindNonUnionSubclasses {domain} {
    set usubs [UnionSubclass findWhere {$Domain eq $domain}]
    return [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation semiminus [deRef $usubs] ~ -using {Domain Domain Class Name} |
        ::rosea::Helpers::ToRef ::micca::Class ~
    }]
}
----

Class structure definitions consist of three components:

. The base
<<instance-data,instance data structure>>
as required and defined by the run time code.
. Attributes defined by the class.
. References used to implement relationship navigation.

Of the three, references are the most complicated in that they come
in a larger number of variations.

(((micca,Code Generation,DeclareClassStructure)))
[source,tcl]
----
<<generation code commands>>=
proc DeclareClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__INST ;\n"

    set compRefs [findRelated $classRef ~R20] ; # <1>

    <<DeclareClassStructure: attribute declarations>>
    <<DeclareClassStructure: reference declarations>>

    append result "\} ;\n"
}
----
<1> Find all the class components for the given class.

Declaring the structure members for attributes is a matter of finding
the attributes and emiting ``C'' declarations, knowing the data type
and attribute name.
The only minor complication is for attributes that are specified to be
arrays.

[source,tcl]
----
<<DeclareClassStructure: attribute declarations>>=
set attrRefs [findRelated $compRefs {~R25 PopulatedComponent}\
    {~R21 Attribute} {~R29 IndependentAttribute} R29] ; # <1>
forAllRefs attrRef $attrRefs {
    assignAttribute $attrRef {Name attrName} DataType
    append result "    [typeCheck composeDeclaration $DataType $attrName] ;\n"
}
----
<1> This query finds all the attributes of the class
that are independent attributes. Those are the ones that will have
a structure member.


As can be seen from the portion of the platform model that
<<classes-subsystem-discussion,deals with classes>>
there are a lot of different types of references.
In the code below we assiduously consider each different type.

[source,tcl]
----
<<DeclareClassStructure: reference declarations>>=
set refRefs [findRelated $compRefs {~R25 PopulatedComponent} {~R21 Reference}] ; # <1>
<<DeclareClassStructure: superclass references>>
<<DeclareClassStructure: associator references>>
<<DeclareClassStructure: association references>>

set genRefs [findRelated $compRefs {~R25 GeneratedComponent}] ; # <2>
<<DeclareClassStructure: subclass references>>
<<DeclareClassStructure: subclass containers>>
<<DeclareClassStructure: link containers>>
<<DeclareClassStructure: complementary references>>
----
<1> First we deal with those references that can be populated.
Referring to the platform model will make this clearer.
<2> The other references are generated to support navigating relationships
in both directions.

A superclass reference declaration takes the form of a simple pointer to the
superclass structure.
[source,tcl]
----
<<DeclareClassStructure: superclass references>>=
set superRefs [findRelated $refRefs {~R23 SuperclassReference} ~R91\
        {~R47 ReferringSubclass} R37 ~R36]
forAllRefs superRef $superRefs {
    assignAttribute $superRef {Relationship attrName} {Class className}
    append result "    [GetClassProperty $className Reference]$attrName ;\n"
}
----

Associative classes make two references,
one to each class participating in the association,
which are grouped together in an unnamed structure.

[source,tcl]
----
<<DeclareClassStructure: associator references>>=
set atorRefs [findRelated $refRefs {~R23 AssociatorReference} ~R93 R42]
forAllRefs atorRef $atorRefs {
    assignAttribute $atorRef {Name attrName}

    set sourceDecl [pipe {
        findRelated $atorRef ~R34 |
        readAttribute % Class |
        GetClassProperty % Reference
    } {} |%]
    set targetDecl [pipe {
        findRelated $atorRef ~R35 |
        readAttribute % Class |
        GetClassProperty % Reference
    } {} |%]

    append result\
        "    struct \{\n"\
        "        ${targetDecl}forward ;\n"\
        "        ${sourceDecl}backward ;\n"\
        "    \} $attrName ;\n"
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associator class references
} -setup {
    validateutils genMiccaFile codegen3 {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -static -associator A X 0..*--0..* Y
        }
        population codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen3.c
    testConditions\
        {[validateutils matchLines codegen3.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct Y *forward ;
                    struct X *backward ;
                } R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen3.c {
            struct X {
                MRT_Instance base__INST ;
                struct {
                    struct A *const *links ;
                    unsigned count ;
                } R1__FORW ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-20.0 {
    Generated code file associative class references
} -setup {
    validateutils genMiccaFile codegen20 {
        domain codegen20 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..1--0..1 Y
        }
        population codegen20 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen20.c
    testConditions\
        {[validateutils matchLines codegen20.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct Y *forward ;
                    struct X *backward ;
                } R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen20.c {
            struct X {
                MRT_Instance base__INST ;
                struct A *R1__FORW ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

Simple association references also resolve to a single pointer declaration
to the referenced class.

[source,tcl]
----
<<DeclareClassStructure: association references>>=
set assocRefs [findRelated $refRefs {~R23 AssociationReference} ~R90 R32 ~R33]
forAllRefs assocRef $assocRefs {
    assignAttribute $assocRef {Relationship attrName} {Class className}
    append result "    [GetClassProperty $className Reference]$attrName ;\n"
}
----

Generated references deal with the "other" side of a relationship.
When a class serves as a superclass,
it has a pointer to its related subclass instance.
For the superclass,
we use a `void` pointer since the type of the subclass instance varies.

[source,tcl]
----
<<DeclareClassStructure: subclass references>>=
set subRefs [findRelated $genRefs {~R24 SubclassReference}]
forAllRefs subRef $subRefs {
    assignAttribute $subRef {Name attrName}
    append result "    void *$attrName ;\n"
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    validateutils genMiccaFile codegen2 {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population codegen2 {
            class super {
                instance fred1
                instance fred2
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen2.c
    testConditions\
        {[validateutils matchLines codegen2.c {
            struct super {
                MRT_Instance base__INST ;
                void *R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen2.c {
            struct sub1 {
                MRT_Instance base__INST ;
                struct super *R1 ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

Union superclasses use a union to serve as the container for
subclass instances.

[source,tcl]
----
<<DeclareClassStructure: subclass containers>>=
set contRefs [findRelated $genRefs {~R24 SubclassContainer}]
forAllRefs contRef $contRefs {
    assignAttribute $contRef {Name attrName}

    set subRefs [findRelated $contRef ~R96 R44 ~R45]
    append result "    union \{\n"
    foreach subName [relation list [deRef $subRefs] Class] {
        append result "        "\
            "[GetClassProperty $subName Declaration] $subName ;\n"
    }
    append result "    \} $attrName ;\n"
}
----

ifdef::showtests[]
[source,tcl]
.Tests
----
<<generate command tests>>=
test codegen-6.0 {
    Generated code file union generalization
} -setup {
    validateutils genMiccaFile codegen6 {
        domain codegen6 {
            class super {}
            class sub1 {
                attribute color int -default 10
            }
            class sub2 {
                attribute temp int -default 20
            }
            generalization R1 -union super sub1 sub2

            class sub3 {
                attribute degree int -default 30
            }
            class sub4 {
                attribute yaw int -default 40
            }

            generalization R2 -union sub1 sub3 sub4

            class sub5 {
                attribute degree int -default 30
            }
            class sub6 {
                attribute degree int -default 30
            }

            generalization R3 -union sub1 sub5 sub6

            class X {}
            association R4 X 1--1 sub5
        }
        population codegen6 {
            class super {
                instance fred1
                instance fred2
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
            class sub3 {
                instance s3 R2 s1
            }
            class sub5 {
                instance s5 R3 s1
            }
            class X {
                instance x1 R4 s5
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen6.c
    testConditions\
        {[validateutils matchLines codegen6.c {
            struct super {
                MRT_Instance base__INST ;
                union {
                    struct sub1 sub1 ;
                    struct sub2 sub2 ;
                } R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen6.c {
            struct sub1 {
                MRT_Instance base__INST ;
                int color ;
                union {
                    struct sub3 sub3 ;
                    struct sub4 sub4 ;
                } R2 ;
                union {
                    struct sub5 sub5 ;
                    struct sub6 sub6 ;
                } R3 ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

For class instances that are part of a linked list,
we have to provide storage in the class structure for the list links.

[source,tcl]
----
<<DeclareClassStructure: link containers>>=
set linkRefs [findRelated $genRefs {~R24 LinkContainer}]
forAllRefs linkRef $linkRefs {
    append result "    MRT_LinkRef [readAttribute $linkRef Name] ;\n"
}
----

Complementary references are used by associations to implement the
back references.
There are several types depending upon the multiplicity and
whether the association is static.

[source,tcl]
----
<<DeclareClassStructure: complementary references>>=
set complRefs [findRelated $genRefs {~R24 ComplementaryReference}]
forAllRefs complRef $complRefs {
    set singRef [findRelated $complRef {~R26 SingularReference} R26]
    if {[isNotEmptyRef $singRef]} {
        set attrName [readAttribute $singRef Name]
        set refedClass [FindReferencedClass $singRef]
        append result\
            "    [GetClassProperty $refedClass Reference]$attrName ;\n"
        continue
    }

    set arrayRef [findRelated $complRef {~R26 ArrayReference} R26]
    if {[isNotEmptyRef $arrayRef]} {
        set attrName [readAttribute $arrayRef Name]
        set classref [GetClassProperty [FindReferencedClass $arrayRef] Reference]
        append result\
            "    struct \{\n"\
            "        ${classref}const *links ;\n"\
            "        unsigned count ;\n"\
            "    \} $attrName ;\n"
        continue
    }

    set linkRef [findRelated $complRef {~R26 LinkReference} R26]
    if {[isNotEmptyRef $linkRef]} {
        set attrName [readAttribute $linkRef Name]
        append result "    MRT_LinkRef $attrName ;\n"
        continue
    }
}
----

For complementary references,
we need to be able to find the class to which they refer.
We factor out the mucking around the platform model that is necessary
to determine the class referenced by a complementary reference.

(((micca,Code Generation,FindReferencedClass)))
[source,tcl]
----
<<generation helper commands>>=
proc FindReferencedClass {compRef} {
    set destRef [findRelated $compRef {~R28 BackwardReference} ~R94]

    # backward, simple
    set refing [findRelated $destRef {~R38 SimpleReferencedClass} R33 ~R32]
    if {[isNotEmptyRef $refing]} {
        set refedClass [readAttribute $refing Class]
    } else {
        # backward, target
        set src [findRelated $destRef {~R38 TargetClass} R35 ~R42]
        if {[isNotEmptyRef $src]} {
            set refedClass [readAttribute $src Class]
        } else {
            # forward, source
            set trg [findRelated $compRef {~R28 ForwardReference} ~R95 R34 ~R42]
            if {[isNotEmptyRef $trg]} {
                set refedClass [readAttribute $trg Class]
            }
        }
    }
    return $refedClass
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-4.0 {
    Generated code file reflexive class references
} -setup {
    validateutils genMiccaFile codegen4 {
        domain codegen4 {
            class X {}
            class A {}
            association R1 -associator A X 0..1--0..1 X
        }
        population codegen4 {
            class X {
                instance x1
                instance x2
            }
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen4.c
    testConditions\
        {[validateutils matchLines codegen4.c {
            struct X {
                MRT_Instance base__INST ;
                struct A *R1__FORW ;
                struct A *R1__BACK ;
            } ;
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct X *forward ;
                    struct X *backward ;
                } R1 ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-5.0 {
    Generated code file reflexive associative class references
} -setup {
    validateutils genMiccaFile codegen5 {
        domain codegen5 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen5 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen5.c
    testConditions\
        {[validateutils matchLines codegen5.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct X *forward ;
                    struct X *backward ;
                } R1 ;
                MRT_LinkRef R1__FLINKS ;
                MRT_LinkRef R1__BLINKS ;
            } ;
        }]}\
        {[validateutils matchLines codegen5.c {
            struct X {
                MRT_Instance base__INST ;
                MRT_LinkRef R1__FORW ;
                MRT_LinkRef R1__BACK ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-21.0 {
    Generated code file reflexive associative class references -- static
} -setup {
    validateutils genMiccaFile codegen21 {
        domain codegen21 {
            class A {}
            class X {}
            association R1 -static -associator A X 0..*--0..* X
        }
        population codegen21 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen21.c
    testConditions\
        {[validateutils matchLines codegen21.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct X *forward ;
                    struct X *backward ;
                } R1 ;
            } ;
        }]}\
        {[validateutils matchLines codegen21.c {
            struct X {
                MRT_Instance base__INST ;
                struct {
                    struct A *const *links ;
                    unsigned count ;
                } R1__FORW ;
                struct {
                    struct A *const *links ;
                    unsigned count ;
                } R1__BACK ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-7.0 {
    Generated code file associative class references -- non static
} -setup {
    validateutils genMiccaFile codegen7 {
        domain codegen7 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population codegen7 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x1 Y y2}
                instance a4 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen7.c
    testConditions\
        {[validateutils matchLines codegen7.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct Y *forward ;
                    struct X *backward ;
                } R1 ;
                MRT_LinkRef R1__FLINKS ;
                MRT_LinkRef R1__BLINKS ;
            } ;
        }]}\
        {[validateutils matchLines codegen7.c {
            struct X {
                MRT_Instance base__INST ;
                MRT_LinkRef R1__FORW ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-8.0 {
    Generated code file reflexive associative class references -- non static
} -setup {
    validateutils genMiccaFile codegen8 {
        domain codegen8 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen8 {
            class A {
                instance a12 R1 {forward x2 backward x1}
                instance a13 R1 {forward x3 backward x1}
                instance a23 R1 {forward x3 backward x2}
                instance a24 R1 {forward x4 backward x2}
                instance a34 R1 {forward x4 backward x3}
                instance a41 R1 {forward x1 backward x4}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen8.c
    testConditions\
        {[validateutils matchLines codegen8.c {
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct X *forward ;
                    struct X *backward ;
                } R1 ;
                MRT_LinkRef R1__FLINKS ;
                MRT_LinkRef R1__BLINKS ;
            } ;
        }]}\
        {[validateutils matchLines codegen8.c {
            struct X {
                MRT_Instance base__INST ;
                MRT_LinkRef R1__FORW ;
                MRT_LinkRef R1__BACK ;
            } ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-9.0 {
    Generated code file class based reflexive class references
} -setup {
    validateutils genMiccaFile codegen9 {
        domain codegen9 {
            class X {}
            class A {}
            association R1 -associator A X 0..*--0..1 X
        }
        population codegen9 {
            class A {
                instance a1 R1 {forward x2 backward x1}
                instance a2 R1 {forward x3 backward x2}
                instance a3 R1 {forward x1 backward x3}
            }
            class X {
                instance x1
                instance x2
                instance x3
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen9.c
    testConditions\
        {[validateutils matchLines codegen9.c {
            struct X {
                MRT_Instance base__INST ;
                struct A *R1__FORW ;
                MRT_LinkRef R1__BACK ;
            } ;
            struct A {
                MRT_Instance base__INST ;
                struct {
                    struct X *forward ;
                    struct X *backward ;
                } R1 ;
                MRT_LinkRef R1__BLINKS ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

=== Assigner Declarations

An assigner is declared in much the same manner as a class.
This gives us the ability to deal with the state model of an assigner
using the same code as for classes.
There are a few different rules for assigners:

* Single assigners have no attributes and are never created dynamically.
Their single instance is created as part of the initial instance population.
* Multiple assigners have a single attribute and may be created dynamically.

(((micca,Code Generation,assignerDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc assignerDeclarations {} {
    variable domain

    append result [comment "Single Assigner Structure Declarations"]

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $singles {
        assignAttribute $assigner
        append result\
            "struct $Association \{\n"\
            "    MRT_Instance base__INST ;\n"\
            "\} ;\n"
    }

    append result [comment "Multiple Assigner Structure Declarations"]

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $multis {
        assignAttribute $assigner
        append result\
            "struct $Association \{\n"\
            "    MRT_Instance base__INST ;\n"\
            "    [GetClassProperty $Class Reference] idinstance ;\n"\
            "\} ;\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-22.0 {
    Generate a single assigner declaration
} -setup {
    validateutils genMiccaFile codegen22 {
        domain codegen22 {
            class clerk {}
            class client {}
            class service {}
            association R1 -associator service clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
        }
        population codegen22 {
            class clerk {
                allocate 2
            }
            class client {
                allocate 3
            }
            class service {
                allocate 6
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen22.c
    testConditions\
        {[validateutils matchLines codegen22.c {
            struct R1 {
                MRT_Instance base__INST ;
            } ;
        }]}\
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-23.0 {
    Generate a multi assigner declaration
} -setup {
    validateutils genMiccaFile codegen23 {
        domain codegen23 {
            class clerk {}
            class client {}
            class service {}
            association R1 -associator service clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {}
            association R2 department 1..*--1 clerk
        }
        population codegen23 {
            class department {
                instance mens R2 fred
                instance children R2 fred
                instance womens R2 alice
                instance sports R2 biff
            }
            class clerk {
                instance fred
                instance alice
                instance biff
            }
            class client {
                allocate 3
            }
            class service {
                allocate 6
            }
            assigner R1 {
                instance mens mens
                instance children children
                instance womens womens
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen23.c
    testConditions\
        {[validateutils matchLines codegen23.c {
            struct R1 {
                MRT_Instance base__INST ;
                struct department * idinstance ;
            } ;
        }]}
} -result {1}
----
endif::showtests[]

=== State Parameter Declarations

The parameter signatures for state activities are strictly
private to the domain and so their structure declarations are
placed in the generated code file.

(((micca,Code Generation,stateParamDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc stateParamDeclarations {} {
    variable domain
    set result [comment "State Parameter Structure Declarations"]

    set stateargs [pipe {
        State findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name State |
        relation join $::micca::ParameterSignature $::micca::Parameter\
                $::micca::Argument |
        relation project ~ Model State Name Position DataType |
        relation group ~ Params Name Position DataType
    }]

    relation foreach statearg $stateargs -ascending {Model State} {
        relation assign $statearg
        set pstructname "struct ${Model}_${State}__SPARAMS"
        append result "$pstructname \{\n"
        relation foreach param $Params -ascending Position {
            relation assign $param DataType Name
            append result\
                "    [typeCheck composeDeclaration $DataType $Name] ;\n"
        }
        append result "\} ;\n"
        append result\
            "static_assert(sizeof($pstructname) <= sizeof(MRT_EventParams), "\
            "\"Parameters for class or assigner, $Model, state,\
                $State, are too large\") ;\n"
    }

    return $result
}
----

=== Operation Declarations

Both class based and instance based operations must have names
that are unique within the class,
so we can emit the forward declarations for both types of operations
in a single query.

(((micca,Code Generation,operationDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc operationDeclarations {} {
    variable domain
    set result [comment "Operation Forward Declarations"]

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    relation foreach op $ops {
        relation assign $op
        append result\
            "static $ReturnDataType ${Class}_$Operation\("

        if {[relation isempty $Parameters]} {
            append result void
        } else {
            append result [join\
                [relation list $Parameters DataType -ascending Number] {, }]
        }

        append result "\) ;\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-11.0 {
    Generated code file with class operations
} -setup {
    validateutils genMiccaFile codegen11 {
        domain codegen11 {
            class X {
                attribute color int -default 20

                classop int count {} {
                    return 42 ;
                }

                instop void addColor {amount int} {
                    self->color += amount ;
                }
            }
        }
        population codegen11 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen11.c
    validateutils matchLines codegen11.c {
        static int
        X_count(void)
        // return 42 ;
        {
            MRT_INSTRUMENT_ENTRY
            return 42 ;
        }
        static void
        X_addColor(
            struct X *const self,
            int amount)
        // self->color += amount ;
        {
            MRT_INSTRUMENT_ENTRY
            self->color += amount ;
        }
    }
} -result {1}
----
endif::showtests[]

=== Constructor Declarations

Pointers to constructors are part of the IAB for a class
and so we need to have forward declarations for them.

(((micca,Code Generation,ctorDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc ctorDeclarations {} {
    variable domain
    set result [comment "Class Constructor Forward Declarations"]

    set ctors [Constructor findWhere {$Domain eq $domain}]
    forAllRefs ctor $ctors {
        assignAttribute $ctor {Class className}
        append result\
            "static void ${className}__CTOR\(void *const) ;\n"
    }

    return $result
}
----

=== Destructor Declarations

Destructor declarations follow the same pattern as constructors.

(((micca,Code Generation,dtorDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc dtorDeclarations {} {
    variable domain
    set result [comment "Class Destructor Forward Declarations"]

    set dtors [Destructor findWhere {$Domain eq $domain}]
    forAllRefs dtor $dtors {
        assignAttribute $dtor {Class className}
        append result\
            "static void ${className}__DTOR\(void *const) ;\n"
    }

    return $result
}
----

=== Formula Declarations

Formula declarations arise for dependent attributes.

(((micca,Code Generation,formulaDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc formulaDeclarations {} {
    variable domain
    set result [comment "Dependent Attribute Formula Forward Declarations"]

    set deps [DependentAttribute findWhere {$Domain eq $domain}]
    forAllRefs dep $deps {
        assignAttribute $dep {Class className} {Name attrName}
        append result\
            "static void ${className}_${attrName}__FORMULA\(void const *const,\
                void *const, MRT_AttrSize) ;\n"
    }

    return $result
}
----

=== Activity Declarations

State activities must also be declared so that pointers to them
can be used as activity table initializer values.

(((micca,Code Generation,activityDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc activityDeclarations {} {
    variable domain
    set result [comment "State Activities Forward Declarations"]

    set classes [pipe {
        State findWhere {$Domain eq $domain && [string trim $Activity] ne {}} |
        deRef ~ |
        relation eliminate ~ Domain Activity IsFinal PSigID |
        relation group ~ States Name
    }]

    relation foreach class $classes -ascending Model {
        relation assign $class
        relation foreach state $States {
            relation assign $state
            append result "static void ${Model}_${Name}__ACTIVITY\("\
                "void *const s__SELF, "\
                "void const *const p__PARAMS) ;\n"
        }
    }

    return $result
}
----

=== Storage Declarations

Because the relationship pointers in the initial instance population
initializers will involve address expressions into the storage pool
of the instances of a class,
we need to make the storage pool names known to the compiler.
Later, we will put down the initializers, if any.
If there is not an initial instance population for a class,
then this declaration is sufficient to allocate the memory for the
instance storage.

(((micca,Code Generation,storageDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc storageDeclarations {} {
    variable domain
    set result [comment "Class Instance Storage Forward Declarations"]

    set cpops [pipe {
        FindNonUnionSubclasses $domain |
        findRelated % R104 {~R101 ElementPopulation} {~R105 ClassPopulation}
    } {} |%]

    forAllRefs cpop $cpops {
        assignAttribute $cpop {Allocation allocation} {Class className}
        set insts [refMultiplicity [findRelated $cpop ~R102]]
        set total [expr {$allocation + $insts}]
        append result "static struct $className "\
            [GetClassProperty $className StorageVariable]\
            "\[[GetClassProperty $className TotalInstance]\] ;\n"
    }

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs single $singles {
        assignAttribute $single Association
        append result "static struct ${Association} ${Association}__POOL\[1\] ;\n"
    }

    # Total number of multiple assigner instances is the same as the
    # total number of instances of the id class
    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        assignAttribute $multi Association {Class idclass}
        set totalinsts [GetClassProperty $idclass TotalInstance]
        append result "static struct ${Association}\
            ${Association}__POOL\[$totalinsts\] ;\n"
    }

    return $result
}
----

=== Name Definitions

The naming information for classes, relationships, states, events, etc.
is placed in the generated code file.
Note that the names can be compiled out by defining the `MRT_NO_NAMES`
preprocessor symbol.
Naming consumes a lot of memory and is most useful only during debugging.

(((micca,Code Generation,nameDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc nameDefinitions {} {
    variable domain
    append result\
        [comment "Domain Naming Definitions"]\
        "#ifndef MRT_NO_NAMES\n"

    set storageType "static char const"

    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        set className [readAttribute $classRef Name]
        append result "$storageType ${className}__NAME\[\] = \"$className\" ;\n"
    }

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    forAllRefs relRef $relRefs {
        set relName [readAttribute $relRef Name]
        append result "$storageType ${relName}__NAME\[\] = \"$relName\" ;\n"
    }

    set stateRefs [StatePlace findWhere {$Domain eq $domain}]
    forAllRefs stateRef $stateRefs {
        assignAttribute $stateRef {Model modelName} {Name stateName}
        set namevar [expr {$stateName eq "@" ? "AT" : $stateName}]
        append result "$storageType ${modelName}_${namevar}__SNAME\[\] =\
                \"$stateName\" ;\n"
    }

    set eventRefs [Event findWhere {$Domain eq $domain}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Model modelName} {Event eventName}
        append result "$storageType ${modelName}_${eventName}__ENAME\[\] =\
                \"$eventName\" ;\n"
    }

    set saRefs [SingleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $saRefs]} {
        append result "$storageType single_assigner_instance__NAME\[\] =\
                \"assigner\" ;\n"
    }

    set maRefs [MultipleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $maRefs]} {
        append result "$storageType multi_assigner_attribute__NAME\[\] =\
                \"idinstance\" ;\n"
    }

    append result "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

=== Instance Allocation Block Definitions

An Instance Allocation Block defines the characteristics of the instance
storage pool to the run-time code.

(((micca,Code Generation,iabDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc iabDefinitions {} {
    variable domain
    set result [comment "Instance Allocation Block Definitions"]

    forAllRefs classRef [FindNonUnionSubclasses $domain] {
        append result [DefineIABMembers $classRef false]
    }

    set unionRefs [pipe {
        UnionSubclass findWhere {$Domain eq $domain} |
        findRelated ~ R47 R40 R41
    }]
    forAllRefs classRef $unionRefs {
        append result [DefineIABMembers $classRef true]
    }

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs single $singles {
        assignAttribute $single Association
        append result\
            "static MRT_iab ${Association}__IAB = \{\n"\
            "    .storageStart = &${Association}__POOL\[0\],\n"\
            "    .storageFinish = &${Association}__POOL\[1\],\n"\
            "    .storageLast = &${Association}__POOL\[0\],\n"\
            "    .alloc = 1,\n"\
            "    .instanceSize = sizeof\(struct ${Association}\),\n"\
            "    .construct = NULL,\n"\
            "    .destruct = NULL,\n"\
            "    .linkCount = 0,\n"\
            "    .linkOffsets = NULL\n"\
            "\} ;\n"
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        set initial [refMultiplicity [findRelated $multi ~R106]]
        assignAttribute $multi Association {Class idclass}
        set total [GetClassProperty $idclass TotalInstance]

        append result\
            "static MRT_iab ${Association}__IAB = \{\n"\
            "    .storageStart = &${Association}__POOL\[0\],\n"\
            "    .storageFinish = &${Association}__POOL\[$total\],\n"\
            "    .storageLast = &${Association}__POOL\[[expr {$total - 1}]\],\n"\
            "    .alloc = $initial,\n"\
            "    .instanceSize = sizeof\(struct ${Association}\),\n"\
            "    .construct = NULL,\n"\
            "    .destruct = NULL,\n"\
            "    .linkCount = 0,\n"\
            "    .linkOffsets = NULL\n"\
            "\} ;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc DefineIABMembers {classRef isUnionSubclass} {
    assignAttribute $classRef {Name className}

    set linkRefs [findRelated $classRef ~R20 {~R25 GeneratedComponent}\
        {~R24 ComplementaryReference} {~R26 LinkReference}]
    if {[isEmptyRef $linkRefs]} {
        set linkOffsets NULL
    } else {
        set linkOffsets ${className}__LINKS
        set linkCount [refMultiplicity $linkRefs]
        append result\
            "static MRT_AttrOffset const $linkOffsets\[$linkCount\] = \{\n"
        set linkMembers [relation list [deRef $linkRefs] Name]
        foreach linkMember $linkMembers {
            append result\
                "    "\
                "offsetof\([GetClassProperty $className Declaration],\
                $linkMember\),\n"
        }
        append result "\} ;\n"
    }

    append result\
        "static MRT_iab ${className}__IAB = \{\n"

    if {$isUnionSubclass} {
        append result\
            "    .storageStart = NULL,\n"\
            "    .storageFinish = NULL,\n"\
            "    .storageLast = NULL,\n"
    } else {
        set nelements [GetClassProperty $className TotalInstance]
        append result\
            "    .storageStart = &${className}__POOL\[0\],\n"\
            "    .storageFinish = &${className}__POOL\[$nelements\],\n"\
            "    .storageLast = &${className}__POOL\[[expr {$nelements - 1}]\],\n"
    }
    set ctor [pipe {
        findRelated $classRef ~R8 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__CTOR"}
    } {} |%]
    set dtor [pipe {
        findRelated $classRef ~R9 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__DTOR"}
    } {} |%]
    append result\
        "    .alloc = [GetClassProperty $className InitialInstance],\n"\
        "    .instanceSize = sizeof\([GetClassProperty $className Declaration]\),\n"\
        "    .construct = $ctor,\n"\
        "    .destruct = $dtor,\n"\
        "    .linkCount = [refMultiplicity $linkRefs],\n"\
        "    .linkOffsets = $linkOffsets\n"\
        "\} ;\n"

    return $result
}
----

=== Event Dispatch Block Definitions

The Event Dispatch Block is the critical data structure used to
dispatch events to the state models.

(((micca,Code Generation,edbDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc edbDefinitions {} {
    variable domain
    set result [comment "Event Dispatch Block Definitions"]

    upvar #0 ::micca::@Gen@::options options

    forAllRefs smodel [StateModel findWhere {$Domain eq $domain}] {
        assignAttribute $smodel {Model className}

        append result [GenerateTransitionTable $smodel]
        append result [GenerateActivityTable $smodel]
        set finalstates [GenerateFinalStates $smodel result]

        append result [GenerateStateNames $smodel]

        append result "static MRT_edb const ${className}__EDB = \{\n"

        set stateRefs [findRelated $smodel ~R55]
        set cstateRef [findRelated $smodel ~R56]
        append result\
            "    .stateCount = [expr {[refMultiplicity $stateRefs] +\
                [refMultiplicity $cstateRef]}],\n"

        set eventRefs [findRelated $smodel ~R87]
        append result\
            "    .eventCount = [refMultiplicity $eventRefs],\n"\
            "    .initialState = [readAttribute [findRelated $smodel R58 R57]\
                        Number],\n"
        set crstate [expr {[isNotEmptyRef $cstateRef] ?\
            [readAttribute [findRelated $cstateRef R57] Number] :\
            "MRT_StateCode_IG"}]
        append result\
            "    .creationState = $crstate,\n"\
            "    .transitionTable = ${className}__TTAB,\n"\
            "    .activityTable = ${className}__ATAB,\n"\
            "    .finalStates = $finalstates,\n"

        append result\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .stateNames = ${className}__SNAMES,\n"\
            "        #endif /* MRT_NO_NAMES */\n"

        append result\
            "\} ;\n"
    }

    return $result
}
----

The transition table is key to event dispatch.
The data structure is a matrix of _state_ rows and _events_ columns.
However, the matrix is held as a one-dimensional array
since that is a consistent single data type that can be declared
for the EDB.
The dispatch code deals with finding the correct state row and
event column by performing the required scaling of row access by the
number of event columns.

In the platform model,
the *Transition Place* only holds those transitions that are
explicitly mentioned in `transition` statements.
To compute the whole transition matrix,
we have to combine the explicit transition with the default ones.

We compute the transition matrix in three steps:

. Compute the entries for the explicitly mentioned transitions.
. Compute the default transitions not explicitly given.
. Combine the two groups into the transition matrix.

[source,tcl]
----
<<generation code commands>>=
proc GenerateTransitionTable {smodelref} {
    variable domain
    assignAttribute $smodelref {Model className}

    <<GenerateTransitionTable: compute specified transitions>>
    <<GenerateTransitionTable: compute default transitions>>
    <<GenerateTransitionTable: compute transition matrix>>

    set result "static MRT_StateCode const ${className}__TTAB\[\] = \{\n"
    relation foreach transition $transmatrix -ascending {StateNumber EventNumber} {
        relation assign $transition
        append result "    $NewStateNumber, // $State - $Event -> $NewState\n"
    } ; # <1>
    append result "\} ;\n"

    return $result
}
----
<1> Order here is first by state number and then by event number.
This is the order that the run-time code requires.

Transitions specified in a `transition` statement are one of two types.
Either a transition to a state or one of the non-transitioning
destinations of ``IG'' or ``CH''.

[source,c]
----
<<GenerateTransitionTable: compute specified transitions>>=
set tplaces [pipe {
    TransitionPlace findWhere {$Domain eq $domain && $Model eq $className} |
    deRef ~
}]
# puts [relformat $tplaces tplaces]

set statetrans [pipe {
    relation join $tplaces $::micca::StateTransition |
    relation eliminate ~ ASigID |
    relation join ~ $::micca::StatePlace\
        -using {Domain Domain Model Model NewState Name} |
    relation extend ~ stup\
        NewStateNumber string {[tuple extract $stup Number]} |
    relation eliminate ~ Number
}] ; # <1>
# puts [relformat $statetrans statetrans]

set nontrans [pipe {
    relation join $tplaces $::micca::NonStateTransition |
    relation extend ~ ntup\
        NewState string {[tuple extract $ntup TransRule]}\
        NewStateNumber string {"MRT_StateCode_[tuple extract $ntup TransRule]"} |
    relation eliminate ~ TransRule
}] ; # <2>
# puts [relformat $nontrans nontrans]
----
<1> The transitions to an actual state need to pick up the
number for the new state.
The numerical encoding is what the run-time code actually uses.
<2> For non-transitioning destinations,
the new state number is actually a symbolic constant.
This is the reason that the *NewStateNumber* attribute is a string.

The default transitions are computed by difference.
First we compute all possible transitions and then subtract off
the ones that were specified as a *TransitionPlace* instance.
All possible transitions is just the Cartesian product of the states
and events.

[source,c]
----
<<GenerateTransitionTable: compute default transitions>>=
set smodel [deRef $smodelref]
set srcstates [pipe {
    relation semijoin $smodel $::micca::StatePlace |
    relation eliminate ~ Number |
    relation rename ~ Name State
}] ; # <1>
# puts [relformat $srcstates srcstates]

set events [pipe {
    findRelated $smodelref ~R87 |
    deRef %
} {} |%]
# puts [relformat $events events]

set defrule [readAttribute $smodelref DefaultTrans]
# puts "defrule = \"$defrule\""

set deftrans [pipe {
    relation join $srcstates $events |
    relation minus ~ $tplaces |
    relation extend ~ dtup NewState string {$defrule} |
    relation update ~ ftup {[tuple extract $ftup State] eq "@"}\
        {tuple update $ftup NewState CH} |
    relation extend ~ ttup\
        NewStateNumber string {"MRT_StateCode_[tuple extract $ttup NewState]"}
}] ; # <2>
# puts [relformat $deftrans deftrans]
----
<1> We need to clean up some attributes here.
<2> The `join` here effectively computes the Cartesian product since
the only attributes in common are `Domain` and `Model`.

The final transition matrix is just a union of the three types
of transitions, namely, explicitly specified transitions,
explicitly specified non-state transitions and
default transitions.
We also need to join on the state and event numbers since they are
used to order the transition matrix during output.

[source,c]
----
<<GenerateTransitionTable: compute transition matrix>>=
set transmatrix [pipe {
    relation union $statetrans $nontrans $deftrans |
    relation join ~ $::micca::StatePlace\
        -using {Domain Domain Model Model State Name} |
    relation rename ~ Number StateNumber |
    relation join ~ $::micca::Event |
    relation eliminate ~ PSigID |
    relation rename ~ Number EventNumber |
    relation eliminate ~ Domain Model
}]
# puts [relformat $transmatrix transmatrix]
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-12.0 {
    Generated code file with state model
} -setup {
    validateutils genMiccaFile codegen12 {
        domain codegen12 {
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {} {
                        printf("In s1\n") ;
                        (void)self ;
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                    }
                    transition s2 - e1 -> IG
                    transition s2 - e2 -> s3

                    state s3 {} {
                    }
                    final s3
                }
            }
        }
        population codegen12 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen12.c
    validateutils matchLines codegen12.c {
        static MRT_StateCode const X__TTAB[] = {
            1, // s1 - e1 -> s2
            MRT_StateCode_CH, // s1 - e2 -> CH
            MRT_StateCode_IG, // s2 - e1 -> IG
            2, // s2 - e2 -> s3
            MRT_StateCode_CH, // s3 - e1 -> CH
            MRT_StateCode_CH, // s3 - e2 -> CH
        } ;
        static MRT_PtrActivityFunction const X__ATAB[] = {
            X_s1__ACTIVITY, // s1
            NULL, // s2
            NULL, // s3
        } ;
        static bool const X__TSTATES[] = {
            false, // s1
            false, // s2
            true, // s3
        } ;
    }
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation code commands>>=
proc GenerateActivityTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set result "static MRT_PtrActivityFunction const ${className}__ATAB\[\] = \{\n"

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name Activity
            if {[string trim $Activity] eq {}} {
                append result "    NULL, // $Name\n"
            } else {
                append result "    ${className}_${Name}__ACTIVITY, // $Name\n"
            }
        } else {
            set cstate [relation semijoin $place $::micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    NULL, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateFinalStates {smodel resultVar} {
    set tstates [findRelatedWhere $smodel ~R55 {$IsFinal}]
    if {[isEmptyRef $tstates]} {
        return NULL
    }
    upvar 1 $resultVar result
    variable domain
    assignAttribute $smodel {Model className}
    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static bool const ${className}__TSTATES\[\] = \{\n"
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name IsFinal
            append result "    "\
                [expr {$IsFinal ? "true" : "false"}]\
                ", // $Name\n"
        } else {
            set cstate [relation semijoin $place $::micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    false, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
    return ${className}__TSTATES
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateStateNames {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result\
        "#ifndef MRT_NO_NAMES\n"\
        "static char const * const ${className}__SNAMES\[\] = \{\n"

    relation foreach state $states -ascending Number {
        relation assign $state Name
        set Name [string map {@ AT} $Name]
        append result "    ${className}_${Name}__SNAME,\n"
    }

    append result\
        "\} ;\n"\
        "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

=== Polymorphic Dispatch Block Definitions

Polymorphic event dispatch involves mapping events at run time
across a generalization.
Here the data structures required by the run-time are more complicated.

(((micca,Code Generation,pdbDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc pdbDefinitions {} {
    variable domain

    set rnames {}
    set pmaps {}
    set gdbs {}
    set pdbs {}

    set deRefs [DeferredEvent findWhere {$Domain eq $domain}]
    set superRefs [findRelated $deRefs ~R86]
    if {[isEmptyRef $superRefs]} {
        return
    }

    set deferred [pipe {
        findRelated $superRefs {R86 DeferralPath} |
        deRef ~ |
        relation join ~ $::micca::DeferredEvent $::micca::Event |
        relation eliminate ~ Domain Role PSigID |
        relation rename ~ Model Superclass Number SuperNumber
    }]
    # puts [relformat $deferred deferred]

    set nonlocals [pipe {
        NonLocalEvent findWhere {$Domain eq $domain} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Number RelNumber
    } {} |%]
    # puts [relformat $nonlocals nonlocals]

    set polys [relation join $nonlocals\
            $::micca::DeferredEvent $::micca::Event]
    # puts [relformat $polys polys]

    set trans [relation join $nonlocals\
            $::micca::TransitioningEvent $::micca::Event]
    # puts [relformat $trans trans]

    set supers [pipe {
        relation union $polys $trans |
        relation eliminate ~ Domain Role PSigID |
        relation join ~ $deferred |
        relation group ~ EventMap Event SuperNumber Number |
        relation group ~ SubMap Model EventMap |
        relation group ~ Generalizations Relationship RelNumber SubMap
    }]
    # puts [relformat $supers supers]

    relation foreach super $supers {
        relation assign $super

        set gdbvar ${Superclass}__GDBS
        append gdbs "static MRT_gdb $gdbvar\[\] = \{\n"

        set rnamesvar ${Superclass}__RNAMES
        append rnames "static char const *const $rnamesvar\[\] = \{\n"

        relation foreach gen $Generalizations -ascending Relationship {
            relation assign $gen

            append rnames "    ${Relationship}__NAME,\n"

            set pmapvar ${Superclass}_${Relationship}__PMAP
            append pmaps "static MRT_EventCode const $pmapvar\[\] = \{\n"

            relation foreach submap $SubMap -ascending Model {
                relation assign $submap
                relation foreach eventmap $EventMap -ascending Number {
                    relation assign $eventmap
                    append pmaps "    $Number, // $Event for $Model\n"
                }
            }
            append pmaps "\} ;\n"

            append gdbs\
                "    \{\n"\
                "        .relship = &${domain}__RSHIPS\[$RelNumber\],\n"\
                "        .eventMap = $pmapvar,\n"\
                "    \},\n"
        }
        append rnames "\} ;\n"
        append gdbs "\} ;\n"

        append pdbs\
            "static MRT_pdb const ${Superclass}__PDB = \{\n"\
            "    .eventCount = [relation cardinality $EventMap],\n"\
            "    .genCount = [relation cardinality $Generalizations],\n"\
            "    .genDispatch = $gdbvar,\n"\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .genNames = $rnamesvar,\n"\
            "        #endif /* MRT_NO_NAMES */\n"\
            "\} ;\n"
    }


    append result\
        [comment "Polymorphic Event Dispatch Block Definitions"]\
        "#ifndef MRT_NO_NAMES\n"\
        $rnames\
        "#endif /* MRT_NO_NAMES */\n"\
        $pmaps $gdbs $pdbs

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-13.0 {
    polymorphic events -- inject polymorphic event mid-level
} -setup {
    validateutils genMiccaFile codegen13 {
        domain codegen13 {
            generalization R1 -union S X Y
            generalization R2 -union X A B
            generalization R3 -union S F G

            class S {
                polymorphic e1
                polymorphic e2
                polymorphic a1
            }
            class X {
                polymorphic a3 ; # new polymorphic event => A and B
                statemodel {
                    state s1 {} {
                    }
                    transition s1 - a1 ->  s1 ; # consume a1
                }
            }
            class Y {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                    }
                    state s2 {} {
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - a1 -> s1
                }
            }

            class F {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                    }
                    state s2 {} {
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - f1 -> s1
                    transition s2 - a1 -> s2
                }
            }
            class G {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                    }
                    state s2 {} {
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - g1 -> s1
                    transition s2 - a1 -> s2
                }
            }

            class A {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                    }
                    state s2 {} {
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            class B {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                    }
                    state s2 {} {
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
        }
        population codegen13 {
            class S {
                instance s1
                instance s2
                instance s3
            }
            class X {
                instance x1 R1 s1
                instance x2 R1 s3
            }
            class Y {
                instance y1 R1 s2
            }
            class A {
                instance a1 R2 x1
            }
            class B {
                instance b1 R2 x2
            }
            class F {
                instance f1 R3 s1
                instance f2 R3 s2
            }
            class G {
                instance g1 R3 s3
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen13.c
    validateutils matchLines codegen13.c {
        static MRT_EventCode const S_R1__PMAP[] = {
            0, // a1 for X
            2, // e1 for X
            3, // e2 for X
            0, // a1 for Y
            1, // e1 for Y
            2, // e2 for Y
        } ;
        static MRT_EventCode const S_R3__PMAP[] = {
            0, // a1 for F
            1, // e1 for F
            2, // e2 for F
            0, // a1 for G
            1, // e1 for G
            2, // e2 for G
        } ;
        static MRT_EventCode const X_R2__PMAP[] = {
            1, // a3 for A
            2, // e1 for A
            3, // e2 for A
            1, // a3 for B
            2, // e1 for B
            3, // e2 for B
        } ;
    }
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-14.0 {
    Generated code file simple references -- non static
} -setup {
    validateutils genMiccaFile codegen14 {
        domain codegen14 {
            class X {}
            class Y {}
            association R1 X 1..*--1 Y
        }
        population codegen14 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen14.c
    validateutils matchLines codegen14.c {
        struct X {
            MRT_Instance base__INST ;
            struct Y *R1 ;
            MRT_LinkRef R1__BLINKS ;
        } ;
        struct Y {
            MRT_Instance base__INST ;
            MRT_LinkRef R1__BACK ;
        } ;
    }
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-15.0 {
    Generated code file simple references -- static
} -setup {
    validateutils genMiccaFile codegen15 {
        domain codegen15 {
            class X {}
            class Y {}
            association R1 -static X 1..*--1 Y
        }
        population codegen15 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen15.c
    validateutils matchLines codegen15.c {
        struct X {
            MRT_Instance base__INST ;
            struct Y *R1 ;
        } ;
        struct Y {
            MRT_Instance base__INST ;
            struct {
                struct X *const *links ;
                unsigned count ;
            } R1__BACK ;
        } ;
    }
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-16.0 {
    many to 1 associative relationship
} -setup {
    validateutils genMiccaFile codegen16 {
        domain codegen16 {
            class A {
            }
            class X {
            }
            class Y {
            }

            association R1 -associator A X 1..*--0..1 Y
        }

        population codegen16 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x3 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen16.c
    testConditions\
    {[validateutils matchLines codegen16.c {
        struct A {
            MRT_Instance base__INST ;
            struct {
                struct Y *forward ;
                struct X *backward ;
            } R1 ;
            MRT_LinkRef R1__BLINKS ;
        } ;
        struct X {
            MRT_Instance base__INST ;
            struct A *R1__FORW ;
        } ;
        struct Y {
            MRT_Instance base__INST ;
            MRT_LinkRef R1__BACK ;
        } ;
    }]}\
    {[validateutils matchLines codegen16.c {
        static struct A A__POOL[3] = {
            [0] = { // a1
                .base__INST = {
                    .classDesc = &codegen16__CLASSES[0],
                    .alloc = 1,
                    .currentState = MRT_StateCode_IG,
                    .refCount = 0,
                        #ifndef MRT_NO_NAMES
                    .name = "a1"
                        #endif /* MRT_NO_NAMES */
                 },
                .R1 = {
                    .forward = &Y__POOL[0],
                    .backward = &X__POOL[0]
                },
                .R1__BLINKS = {
                    .next = &Y__POOL[0].R1__BACK,
                    .prev = &Y__POOL[0].R1__BACK
                },
            },
            [1] = { // a2
                .base__INST = {
                    .classDesc = &codegen16__CLASSES[0],
                    .alloc = 2,
                    .currentState = MRT_StateCode_IG,
                    .refCount = 0,
                        #ifndef MRT_NO_NAMES
                    .name = "a2"
                        #endif /* MRT_NO_NAMES */
                 },
                .R1 = {
                    .forward = &Y__POOL[1],
                    .backward = &X__POOL[1]
                },
                .R1__BLINKS = {
                    .next = &A__POOL[2].R1__BLINKS,
                    .prev = &Y__POOL[1].R1__BACK
                },
            },
            [2] = { // a3
                .base__INST = {
                    .classDesc = &codegen16__CLASSES[0],
                    .alloc = 3,
                    .currentState = MRT_StateCode_IG,
                    .refCount = 0,
                        #ifndef MRT_NO_NAMES
                    .name = "a3"
                        #endif /* MRT_NO_NAMES */
                 },
                .R1 = {
                    .forward = &Y__POOL[1],
                    .backward = &X__POOL[2]
                },
                .R1__BLINKS = {
                    .next = &Y__POOL[1].R1__BACK,
                    .prev = &A__POOL[1].R1__BLINKS
                },
            },
        } ;
    }]}
} -result {1}
----
endif::showtests[]

=== Class Description Definitions

The class descriptions are another run-time data structure that is
used extensively.
It is the key focus of how a particular instance is to be treated
since all instances of a class exhibit the same behavior.

The strategy here is to build a single, rather large relation value
that contains attributes for the values of the `MRT_Class` structure
elements and then iterate over the relation value to output
the ``C'' structure member initializer values.

(((micca,Code Generation,classDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc classDefinitions {} {
    variable domain
    set front [comment "Class Description Definitions"]

    set classRefs [Class findWhere {$Domain eq $domain}]

    set classinrel [pipe {
        findRelated $classRefs {~R41 ClassRole} |
        deRef % |
        relation eliminate % Role
    } {} |%]
    set assocrels [pipe {
        relation join $classinrel $::micca::Association -using\
            {Domain Domain Relationship Name} |
        relation eliminate ~ IsStatic
    }]
    set genrels [relation join $classinrel $::micca::Generalization\
            -using {Domain Domain Relationship Name}]

    set rels [pipe {
        relation union $assocrels $genrels |
        relation join ~ $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename ~ Class Name Number RelNumber
    }]
    # puts [relformat $rels rels]

    set attrs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Attribute} |
        deRef % |
        ralutil::rvajoin % $::micca::IndependentAttribute Indep |
        ralutil::rvajoin % $::micca::DependentAttribute Dep |
        relation rename % Name Attribute Class Name
    } {} |%]
    # puts [relformat $attrs attrs]

    set usubs [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 Subclass}\
            {~R47 UnionSubclass} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number SuperNumber |
        relation eliminate % Role Relationship
    } {} |%]
    # puts [relformat $usubs usubs]

    set allevents [pipe {
        Event findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Model Name Number EvtNumber |
        relation eliminate ~ PSigID
    }]
    # puts [relformat $allevents allevents]

    set classes [pipe {
        deRef $classRefs |
        relation extend ~ ctup IAB string {"&[tuple extract $ctup Name]__IAB"} |
        ralutil::rvajoin ~ $allevents AEvents |
        ralutil::rvajoin ~\
            [relation rename $::micca::TransitioningEvent Model Name] TEvents |
        ralutil::rvajoin ~\
            [relation rename $::micca::DeferredEvent Model Name] PEvents |
        relation extend ~ etup\
            EDB string {
                [relation isempty [tuple extract $etup TEvents]] ?\
                "NULL" : "&[tuple extract $etup Name]__EDB"}\
            PDB string {
                [relation isempty [tuple extract $etup PEvents]] ?\
                "NULL" : "&[tuple extract $etup Name]__PDB"}\
            eventNames string {
                [relation isempty [tuple extract $etup AEvents]] ? "NULL" :\
                "[tuple extract $etup Name]__ENAMES"} |
        relation eliminate ~ TEvents PEvents |
        ralutil::rvajoin ~ $rels Relationships |
        relation extend ~ rtup\
            relCount int {
                [relation cardinality [tuple extract $rtup Relationships]]}\
            classRels string {
                [relation cardinality [tuple extract $rtup Relationships]] == 0 ?\
                "NULL" : "[tuple extract $rtup Name]__CRELS"} |
        ralutil::rvajoin ~ $attrs Attributes |
        relation extend ~ atup\
            attrCount int {
                [relation cardinality [tuple extract $atup Attributes]]}\
            classAttrs string {
                [relation isempty [tuple extract $atup Attributes]] ?\
                "NULL" : "[tuple extract $atup Name]__CATTRS"} |
        ralutil::rvajoin ~ $usubs UnionSubs |
        relation extend ~ utup\
            containment string {
                [relation isempty [tuple extract $utup UnionSubs]] ?\
                "NULL" :\
                "&${domain}__RSHIPS\[[relation extract\
                    [tuple extract $utup UnionSubs]\
                    SuperNumber]\].relInfo.unionGeneralization.superclass"} |
        relation eliminate ~ Domain

    }]
    # puts [relformat $classes classes]

    append result "static MRT_Class const\
            ${domain}__CLASSES\[[relation cardinality $classes]\] = \{\n"

    set relrefs {}
    set attrrefs {}
    set namerefs "#ifndef MRT_NO_NAMES\n"
    relation foreach class $classes {
        relation assign $class

        if {[relation isnotempty $Relationships]} {
            append relrefs\
                "static MRT_Relationship const *const\
                    ${Name}__CRELS\[\] = \{\n"

            relation foreach rel $Relationships {
                relation assign $rel
                append relrefs\
                    "    &${domain}__RSHIPS\[$RelNumber\], // $Relationship\n"
            }

            append relrefs "\} ;\n"
        }

        if {[relation isnotempty $Attributes]} {
            append attrrefs\
                "static MRT_Attribute const ${Name}__CATTRS\["\
                [relation cardinality $Attributes]\
                "\] = \{\n"

            relation foreach attr $Attributes -ascending Attribute {
                relation assign $attr
                append attrrefs\
                    "    \{\n"\
                    "        .size = sizeof($DataType),\n"
                if {[relation isnotempty $Indep]} {
                    set offset "offsetof([GetClassProperty $Name Declaration],\
                            $Attribute)"
                    append attrrefs\
                        "        .type = mrtIndependentAttr,\n"\
                        "        .access.offset = $offset,\n"
                } else {
                    set formfunc "${Name}_${Attribute}__FORMULA"
                    append attrrefs\
                        "        .type = mrtDependentAttr,\n"\
                        "        .access.formula = $formfunc,\n"
                }
                append attrrefs\
                    "            #ifndef MRT_NO_NAMES\n"\
                    "        .name = \"$Attribute\"\n"\
                    "            #endif /* MRT_NO_NAMES */\n"\
                    "    \},\n"
            }

            append attrrefs "\} ;\n"
        }

        if {[relation isnotempty $AEvents]} {
            append namerefs\
                "static char const *const ${Name}__ENAMES\["\
                [relation cardinality $AEvents]\
                "\] = \{\n"

            relation foreach event $AEvents -ascending EvtNumber {
                relation assign $event {Event eventName}
                append namerefs "    ${Name}_${eventName}__ENAME,\n"
            }

            append namerefs "\} ;\n"
        }

        append result\
            "    \[$Number\] = \{ // $Name\n"\
            "        .iab = $IAB,\n"\
            "        .eventCount = [relation cardinality $AEvents],\n"\
            "        .edb = $EDB,\n"\
            "        .pdb = $PDB,\n"\
            "        .relCount = $relCount,\n"\
            "        .classRels = $classRels,\n"\
            "        .attrCount = $attrCount,\n"\
            "        .classAttrs = $classAttrs,\n"\
            "        .instCount = [GetClassProperty $Name TotalInstance],\n"\
            "        .containment = $containment,\n"\
            "            #ifndef MRT_NO_NAMES\n"\
            "        .name = ${Name}__NAME,\n"\
            "        .eventNames = $eventNames,\n"\
            "            #endif /* MRT_NO_NAMES */\n"\
            "    \},\n"
    }
    append namerefs "#endif /* MRT_NO_NAMES */\n"

    append result "\} ;\n"

    return [string cat $front $namerefs $relrefs $attrrefs $result]
}
----

=== Assigner Definitions

(((micca,Code Generation,assignerDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc assignerDefinitions {} {
    variable domain

    append result [comment "Assigner Class Description Definitions"]

    set events [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        deRef ~ |
        relation join ~ $::micca::Event |
        relation eliminate ~ PSigID |
        relation rename ~ Model Association
    }]
    set assigners [pipe {
        AssignerStateModel findWhere {$Domain eq $domain} |
        deRef ~ |
        ralutil::rvajoin ~ $::micca::SingleAssigner Single |
        ralutil::rvajoin ~ $::micca::MultipleAssigner Multiple |
        relation join ~ $events |
        relation group ~ Events Event Number
    }]

    set result {}
    set attrResult {}
    set enameResult {}
    if {[relation isnotempty $assigners]} {
        append enameResult "#ifndef MRT_NO_NAMES\n"

        set nassign [relation cardinality $assigners]
        append result\
            "static MRT_Class const ${domain}__ASSIGNERS\[$nassign\]= \{\n"\

        relation foreach assigner $assigners -ascending Association {
            relation assign $assigner

            append enameResult\
                "static char const *const ${Association}__ENAMES\["\
                [relation cardinality $Events]\
                "\] = \{\n"

            relation foreach event $Events -ascending Number {
                relation assign $event {Event eventName}
                append enameResult "    ${Association}_${eventName}__ENAME,\n"
            }

            append enameResult "\} ;\n"

            append result\
                "    \{ // $Association\n"\
                "        .iab = &${Association}__IAB,\n"\
                "        .eventCount = [relation cardinality $Events],\n"\
                "        .edb = &${Association}__EDB,\n"\
                "        .pdb = NULL,\n"
            if {[relation isnotempty $Single]} {
                append result\
                    "        .attrCount = 0,\n"\
                    "        .classAttrs = NULL,\n"\
            } else {
                relation assign $Multiple
                append attrResult\
                    "static MRT_Attribute const ${Association}__CATTRS\[1\] = \{\n"\
                    "    \{\n"\
                    "        .size = sizeof([GetClassProperty $Class Reference]),\n"\
                    "        .type = mrtIndependentAttr,\n"\
                    "        .access.offset = offsetof(struct $Association,\
                                idinstance),\n"\
                    "            #ifndef MRT_NO_NAMES\n"\
                    "        .name = multi_assigner_attribute__NAME\n"\
                    "            #endif /* MRT_NO_NAMES */\n"\
                    "    \}\n"\
                    "\} ;\n"
                append result\
                    "        .attrCount = 1,\n"\
                    "        .classAttrs = ${Association}__CATTRS,\n"\
            }
            set ninst [GetClassProperty $Association TotalInstance]
            append result\
                "        .instCount = $ninst,\n"\
                "        .relCount = 0,\n"\
                "        .classRels = NULL,\n"\
                "        .containment = NULL,\n"\
                "            #ifndef MRT_NO_NAMES\n"\
                "        .name = ${Association}__NAME,\n"\
                "        .eventNames = ${Association}__ENAMES,\n"\
                "            #endif /* MRT_NO_NAMES */\n"\
                "    \},\n"
        }
        append enameResult "#endif /* MRT_NO_NAMES */\n"

        append result "\} ;\n"
    }

    return [string cat $enameResult $attrResult $result]
}
----

=== Relationship Description Definitions

The calculation of relationship descriptions breaks down along the
lines of the four different types of relationships found in the
platform model.

(((micca,Code Generation,relationshipDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc relationshipDefinitions {} {
    variable domain
    set subroles {}

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    if {[isEmptyRef $relRefs]} {
        return
    }
    append result "static MRT_Relationship const\
        ${domain}__RSHIPS\[[refMultiplicity $relRefs]\] = \{\n"

    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    forAllRefs relRef $relRefs {
        assignAttribute $relRef {Name relName} Number
        append result "$indent\[$Number\] = \{ // $relName\n"

        <<relationshipDefinitions: simple associations>>
        <<relationshipDefinitions: class based associations>>
        <<relationshipDefinitions: reference generalizations>>
        <<relationshipDefinitions: union generalizations>>
    }

    append result "\} ;\n"

    return [string cat\
        [comment "Relationship Description Definitions"]\
        $subroles\
        $result\
    ]
}
----

[source,tcl]
----
<<relationshipDefinitions: simple associations>>=
set typeRef [findRelated $relRef {~R30 Association} {~R31 SimpleAssociation}]
if {[isNotEmptyRef $typeRef]} {
    set sourceRef [findRelated $typeRef ~R32]
    assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
        {Multiplicity sMult}
    set sNum [readAttribute [findRelated $sourceRef R40 R41] Number]

    set targetRef [findRelated $typeRef ~R33]
    assignAttribute $targetRef {Class tClass}
    set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

    set tCond false
    set tMult false
    set stype mrtSingular
    set slink 0

    set tcomp [findRelated $targetRef R38 R94 R28]
    lassign [FindRelOffsets $tcomp] ttype tlink

    set sstore "offsetof([GetClassProperty $sClass Declaration],\
            $relName)"
    set tstore "offsetof([GetClassProperty $tClass Declaration],\
            [readAttribute $tcomp Name])"

    append result\
        "$indent2.relType = mrtSimpleAssoc,\n"\
        "$indent2.relInfo.simpleAssociation = \{\n"

    append result\
        "$indent3.source = \{\n"\
        "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
        "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
        "$indent4.storageType = $stype,\n"\
        "$indent4.storageOffset = $sstore,\n"\
        "$indent4.linkOffset = $slink\n"\
        "$indent3\},\n"

    append result\
        "$indent3.target = \{\n"\
        "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
        "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
        "$indent4.storageType = $ttype,\n"\
        "$indent4.storageOffset = $tstore,\n"\
        "$indent4.linkOffset = $tlink\n"\
        "$indent3\}\n"

    append result\
        "$indent2\},\n"\
        "${indent3}#ifndef MRT_NO_NAMES\n"\
        "$indent2.name = ${relName}__NAME\n"\
        "${indent3}#endif /* MRT_NO_NAMES */\n"\
        "$indent\},\n"
    continue
}
----

[source,tcl]
----
<<relationshipDefinitions: class based associations>>=
set typeRef [findRelated $relRef\
        {~R30 Association} {~R31 ClassBasedAssociation}]
if {[isNotEmptyRef $typeRef]} {
    set sourceRef [findRelated $typeRef ~R34]
    assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
        {Multiplicity sMult}
    set sNum [readAttribute [findRelated $sourceRef R40 R41] Number]

    set targetRef [findRelated $typeRef ~R35]
    assignAttribute $targetRef {Class tClass} {Conditionality tCond}\
        {Multiplicity tMult}
    set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

    set asstorRef [findRelated $typeRef ~R42]
    assignAttribute $asstorRef {Class aClass}
    set aNum [readAttribute [findRelated $asstorRef R40 R41] Number]

    set scomp [findRelated $sourceRef R95 R28]
    lassign [FindRelOffsets $scomp] stype slink

    set tcomp [findRelated $targetRef R38 R94 R28]
    lassign [FindRelOffsets $tcomp] ttype tlink

    set sstore "offsetof([GetClassProperty $sClass Declaration],\
            [readAttribute $scomp Name])"
    set tstore "offsetof([GetClassProperty $tClass Declaration],\
            [readAttribute $tcomp Name])"

    append result\
        "$indent2.relType = mrtClassAssoc,\n"\
        "$indent2.relInfo.classAssociation = \{\n"

    append result\
        "$indent3.source = \{\n"\
        "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
        "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
        "$indent4.storageType = $stype,\n"\
        "$indent4.storageOffset = $sstore,\n"\
        "$indent4.linkOffset = $slink,\n"\
        "$indent3\},\n"

    append result\
        "$indent3.target = \{\n"\
        "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
        "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
        "$indent4.storageType = $ttype,\n"\
        "$indent4.storageOffset = $tstore,\n"\
        "$indent4.linkOffset = $tlink\n"\
        "$indent3\},\n"

    set aClassDecl [GetClassProperty $aClass Declaration]
    set aClassForw "offsetof($aClassDecl, ${relName}.forward)"
    set aClassBack "offsetof($aClassDecl, ${relName}.backward)"
    append result\
        "$indent3.associator = \{\n"\
        "$indent4.classDesc = &${domain}__CLASSES\[$aNum\], // $aClass\n"\
        "$indent4.forwardOffset = $aClassForw,\n"\
        "$indent4.backwardOffset = $aClassBack,\n"\
        "$indent3\}\n"

    append result\
        "$indent2\},\n"\
        "${indent3}#ifndef MRT_NO_NAMES\n"\
        "$indent2.name = ${relName}__NAME\n"\
        "${indent3}#endif /* MRT_NO_NAMES */\n"\
        "$indent\},\n"
    continue
}
----

[source,tcl]
----
<<relationshipDefinitions: reference generalizations>>=
set typeRef [findRelated $relRef\
        {~R30 Generalization} {~R43 ReferenceGeneralization}]
if {[isNotEmptyRef $typeRef]} {
    set superRef [findRelated $typeRef ~R36]
    assignAttribute $superRef {Class superClass}
    set supNum [readAttribute [findRelated $superRef R48 R40 R41] Number]

    set subRefs [findRelated $typeRef ~R37]
    set subClasses [findRelated $subRefs R47 R40 R41]

    set subs [pipe {
        deRef $subRefs |
        relation join ~ [deRef $subClasses]\
            -using {Domain Domain Class Name} |
        relation extend ~ stup\
            classDesc string {
                "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                // [tuple extract $stup Class]"}\
            storageOffset string {
                "offsetof([GetClassProperty\
                    [tuple extract $stup Class] Declaration],\
                    $relName)"} |
        relation project ~ Class classDesc storageOffset
    }]

    append subroles "static struct mrtrefsubclassrole const\
            ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
    relation foreach sub $subs -ascending Class {
        relation assign $sub
        append subroles\
            "    \{\n"\
            "        .classDesc = $classDesc,\n"\
            "        .storageOffset = $storageOffset\n"\
            "    \},\n"
    }
    append subroles "\} ;\n"

    append result\
        "$indent2.relType = mrtRefGeneralization,\n"\
        "$indent2.relInfo.refGeneralization = \{\n"

    append result\
        "$indent3.superclass = \{\n"\
        "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
        "$indent4.storageOffset =\
            offsetof([GetClassProperty $superClass Declaration],\
            $relName)\n"\
        "$indent3\},\n"

    append result\
        "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
        "$indent3.subclasses = ${relName}__SROLES\n"

    append result\
        "$indent2\},\n"\
        "${indent3}#ifndef MRT_NO_NAMES\n"\
        "$indent2.name = ${relName}__NAME\n"\
        "${indent3}#endif /* MRT_NO_NAMES */\n"\
        "$indent\},\n"
    continue
}
----

[source,tcl]
----
<<relationshipDefinitions: union generalizations>>=
set typeRef [findRelated $relRef\
        {~R30 Generalization} {~R43 UnionGeneralization}]
if {[isNotEmptyRef $typeRef]} {
    set superRef [findRelated $typeRef ~R44]
    assignAttribute $superRef {Class superClass}
    set supNum [readAttribute [findRelated $superRef R48 R40 R41] Number]
    set subRefs [findRelated $typeRef ~R45]
    set subClasses [findRelated $subRefs R47 R40 R41]
    set subs [pipe {
        deRef $subRefs |
        relation join ~ [deRef $subClasses]\
            -using {Domain Domain Class Name} |
        relation extend ~ stup\
            classDesc string {
                "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                // [tuple extract $stup Class]"} |
        relation project ~ Class classDesc
    }]

    append subroles "static MRT_Class const * const\
            ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
    relation foreach sub $subs -ascending Class {
        relation assign $sub
        append subroles "    $classDesc\n"
    }
    append subroles "\} ;\n"

    append result\
        "$indent2.relType = mrtUnionGeneralization,\n"\
        "$indent2.relInfo.unionGeneralization = \{\n"

    append result\
        "$indent3.superclass = \{\n"\
        "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
        "$indent4.storageOffset =\
            offsetof([GetClassProperty $superClass Declaration],\
            $relName)\n"\
        "$indent3\},\n"

    append result\
        "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
        "$indent3.subclasses = ${relName}__SROLES\n"

    append result\
        "$indent2\},\n"\
        "${indent3}#ifndef MRT_NO_NAMES\n"\
        "$indent2.name = ${relName}__NAME\n"\
        "${indent3}#endif /* MRT_NO_NAMES */\n"\
        "$indent\},\n"
    continue
}
----

We use a helper function to compute the byte offset to link list pointers
used for dynamic multiple reference pointer storage.
If it's not a linked list storage scheme,
then the offset is always 0.

[source,tcl]
----
<<generation helper commands>>=
proc FindRelOffsets {complRef} {
    set typeRef [findRelated $complRef {~R26 SingularReference}]
    set offset 0
    if {[isNotEmptyRef $typeRef]} {
        set type mrtSingular
    } else {
        set typeRef [findRelated $complRef {~R26 ArrayReference}]
        if {[isNotEmptyRef $typeRef]} {
            set type mrtArray
        } else {
            set typeRef [findRelated $complRef {~R26 LinkReference}]
            set type mrtLinkedList
            assignAttribute [findRelated $typeRef ~R27]\
                {Class lClass} {Name lcomp}
            set offset "offsetof([GetClassProperty $lClass Declaration], $lcomp)"
        }
    }
    return [list $type $offset]
}
----

Map separate conditionality and multiplicity values to a single
encoded enumerator used by the run-time.

[source,tcl]
----
<<generation code commands>>=
proc MapToCardinality {cond mult} {
    if {$cond && !$mult} {
        return mrtAtMostOne
    } elseif {!$cond && !$mult} {
        return mrtExactlyOne
    } elseif {$cond && $mult} {
        return mrtZeroOrMore
    } elseif {!$cond && $mult} {
        return mrtOneOrMore
    }
}
----

=== Class Instance Definitions

(((micca,Code Generation,classInstanceDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc classInstanceDefinitions {} {
    variable domain
    variable staticMultiRefs {}

    set classRefs [FindNonUnionSubclasses $domain]
    set classpops [FindClassPopulation $classRefs]

    set result [comment "Instance Pool Definitions"]
    relation foreach classpop $classpops -ascending ClassNumber {
        relation assign $classpop

        append result\
            "static struct $Class "\
            [GetClassProperty $Class StorageVariable]\
            "\[[GetClassProperty $Class TotalInstance]\] = \{\n"

        relation foreach inst $Instances -ascending InstNumber {
            append result\
                "    \[[relation extract $inst InstNumber]\] = "\
                [string trimleft [GenInstanceInitializers $Class $ClassNumber $inst]]
        }

        append result "\} ;\n"
    }

    if {$staticMultiRefs ne {}} {
        set staticMultiRefs [string cat\
            [comment "Static Reference Definitions"] $staticMultiRefs]
    }
    return [string cat $staticMultiRefs $result]
}
----

[source,tcl]
----
<<generation code commands>>=
proc FindClassPopulation {classRefs} {
    set classes [pipe {
        deRef $classRefs |
        relation rename ~ Name Class Number ClassNumber
    }]

    set compRefs [findRelated $classRefs ~R20]

    # Populated Components
    set popCompRefs [findRelated $compRefs {~R25 PopulatedComponent}]

    # Attribute Components
    set attrs [pipe {
        findRelated $popCompRefs {~R21 Attribute} {~R29 IndependentAttribute}\
                R29 |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $attrs attrs]

    # Reference Components
    # For the populated reference components we will go ahead and
    # compute the class to which the reference is made.
    set refCompRefs [findRelated $popCompRefs {~R21 Reference}]

    # Superclass Reference Component
    set screfs [findRelated $refCompRefs {~R23 SuperclassReference}]
    set refedsuper [pipe {
        findRelated $screfs ~R91 {~R47 ReferringSubclass} R37 ~R36 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class SuperClass Relationship Component
    } {} |%]
    set superrefs [pipe {
        deRef $screfs |
        relation rename ~ Name Component |
        relation join ~ $refedsuper
    }]
    # puts [relformat $superrefs superrefs]

    # Associator Reference Components
    set arrefs [findRelated $refCompRefs {~R23 AssociatorReference}]
    set cbainfo [pipe {
        findRelated $arrefs ~R93 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class AssociatorClass |
        relation join % $::micca::SourceClass |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class SourceClass |
        relation join % $::micca::TargetClass |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class TargetClass AssociatorClass Class\
                Relationship Component
    } {} |%]
    set atorrefs [pipe {
        deRef $arrefs |
        relation rename ~ Name Component |
        relation join ~ $cbainfo
    }]
    # puts [relformat $atorrefs atorrefs]

    # Association Reference Components
    set asrrefs [findRelated $refCompRefs {~R23 AssociationReference}]
    set srcinfo [pipe {
        findRelated $asrrefs ~R90 R32 ~R33 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class ReferencedClass Relationship Component
    } {} |%]
    set assocrefs [pipe {
        deRef $asrrefs |
        relation rename ~ Name Component |
        relation join ~ $srcinfo
    }]
    # puts [relformat $assocrefs assocrefs]

    # Generated components
    set genCompRefs [findRelated $compRefs {~R25 GeneratedComponent}]

    # Subclass Reference Components
    set subrefs [pipe {
        findRelated $genCompRefs {~R24 SubclassReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $subrefs subrefs]

    # Subclass Container
    set subconts [pipe {
        findRelated $genCompRefs {~R24 SubclassContainer} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $subconts subconts]

    # Link Container
    set linkconts [pipe {
        findRelated $genCompRefs {~R24 LinkContainer} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $linkconts linkconts]

    # Complementary Reference
    set complRefs [findRelated $genCompRefs {~R24 ComplementaryReference}]

    # Singular Reference
    set singRefs [pipe {
        findRelated $complRefs {~R26 SingularReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $singRefs singRefs]

    # Array Reference
    set arrayRefs [pipe {
        findRelated $complRefs {~R26 ArrayReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $arrayRefs arrayRefs]

    # Link Reference
    set linkRefs [pipe {
        findRelated $complRefs {~R26 LinkReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $linkRefs linkRefs]

    set classpops [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation rename % Number InstNumber |
        relation join % $classes $::micca::ClassComponentValue |
        ralutil::rvajoin % $attrs Attributes |
        ralutil::rvajoin % $superrefs SuperRefs |
        ralutil::rvajoin % $atorrefs AssociatorRefs |
        ralutil::rvajoin % $assocrefs AssociationRefs |
        ralutil::rvajoin % $subrefs SubRefs |
        ralutil::rvajoin % $subconts SubclassContainers |
        ralutil::rvajoin % $linkconts LinkContainers |
        ralutil::rvajoin % $singRefs SingularRefs |
        ralutil::rvajoin % $arrayRefs ArrayRefs |
        ralutil::rvajoin % $linkRefs LinkRefs |
        relation group % Components Component Value Attributes SuperRefs\
            AssociatorRefs AssociationRefs SubRefs SubclassContainers\
            LinkContainers SingularRefs ArrayRefs LinkRefs |
        relation group % Instances Instance InstNumber Components |
        relation eliminate % Domain
    } {} |%]
    # puts [relformat $classpops classpops]

    return $classpops
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenInstanceInitializers {className classNumber inst} {
    variable domain
    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    relation assign $inst

    set sp [pipe {
        StateModel findById Domain $domain Model $className |
        findRelated ~ R58 R57
    }]
    set initstate [expr {[isNotEmptyRef $sp] ?\
        [readAttribute $sp Number] : "MRT_StateCode_IG"}]

    append result\
        "$indent\{ // $Instance\n"\
        "$indent2.base__INST = \{\n"\
        "$indent3.classDesc = &${domain}__CLASSES\[$classNumber\],\n"\
        "$indent3.alloc = [expr {$InstNumber + 1}],\n"\
        "$indent3.currentState = $initstate,\n"\
        "$indent3.refCount = 0,\n"\
        "${indent4}#ifndef MRT_NO_NAMES\n"\
        "$indent3.name = \"$Instance\"\n"\
        "${indent4}#endif /* MRT_NO_NAMES */\n"\
        " $indent2\},\n"

    relation foreach comp $Components {
        relation assign $comp
        if {[relation isnotempty $Attributes]} {
            append result "$indent2.$Component = $Value,\n"
            continue
        }

        if {[relation isnotempty $SuperRefs]} {
            set superclass [relation extract $SuperRefs SuperClass]
            append result\
                "$indent2.$Component = "\
                [GenInstanceAddress $domain $superclass $Value],\n
            continue
        }

        if {[relation isnotempty $AssociatorRefs]} {
            relation assign $AssociatorRefs
            # the painful reflexive case again!
            if {$SourceClass eq $TargetClass} {
                # N.B. the inversion. the target instance is the
                # one referenced in the forward direction
                set sinstname [dict get $Value backward]
                set tinstname [dict get $Value forward]
            } else {
                set sinstname [dict get $Value $SourceClass]
                set tinstname [dict get $Value $TargetClass]
            }
            set sourceaddr [GenInstanceAddress $domain $SourceClass\
                $sinstname]
            set targetaddr [GenInstanceAddress $domain $TargetClass\
                $tinstname]

            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.forward = $targetaddr,\n"\
                "$indent3.backward = $sourceaddr\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $AssociationRefs]} {
            set refvalue [GenInstanceAddress $domain\
                    [relation extract $AssociationRefs ReferencedClass]\
                    $Value]
            append result "$indent2.$Component = $refvalue,\n"
            continue
        }

        if {[relation isnotempty $SubRefs]} {
            lassign $Value subclass subinstname
            set subinstaddr [GenInstanceAddress $domain $subclass $subinstname]
            append result "$indent2.$Component = $subinstaddr,\n"
            continue
        }

        if {[relation isnotempty $SubclassContainers]} {
            lassign $Value subclass subinst

            set subRef [Class findWhere {$Domain eq $domain &&\
                $Name eq $subclass}]
            set subpops [FindClassPopulation $subRef]
            # puts [relformat $subpops subpops]

            relation assign $subpops {Class subclassName}\
                {ClassNumber subclassNumber} {Instances subInstances}
            set instpop [relation restrictwith $subInstances\
                {$Instance eq $subinst}]

            append result\
                "$indent2.$Component.$subclass = "\
                [string trimleft [indentCode [GenInstanceInitializers\
                    $subclassName $subclassNumber $instpop] 8]]
            continue
        }

        if {[relation isnotempty $LinkContainers]} {
            lassign [dict get $Value next] nclass ninst ncomp
            set nextaddr [GenInstanceAddress $domain $nclass $ninst]
            lassign [dict get $Value prev] pclass pinst pcomp
            set prevaddr [GenInstanceAddress $domain $pclass $pinst]
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $nextaddr.$ncomp,\n"\
                "$indent3.prev = $prevaddr.$pcomp\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $SingularRefs]} {
            if {$Value eq "@nil@"} {
                set refaddr NULL
            } else {
                lassign $Value refclass refinst
                set refaddr [GenInstanceAddress $domain $refclass $refinst]
            }
            append result "$indent2.$Component = $refaddr,\n"
            continue
        }

        if {[relation isnotempty $ArrayRefs]} {
            if {$Value eq "@nil@"} {
                set refcount 0
                set refaddr NULL
            } else {
                lassign $Value refclass refinsts
                set refcount [llength $refinsts]
                set refaddr ${Component}_${className}_${InstNumber}

                # Build reference array
                variable staticMultiRefs
                append staticMultiRefs\
                    "static [GetClassProperty $refclass Reference]\
                        const $refaddr\[$refcount\] = \{\n"
                foreach inst $refinsts {
                    append staticMultiRefs\
                        "$indent[GenInstanceAddress $domain $refclass $inst],\n"
                }
                append staticMultiRefs "\} ;\n"
            }
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.links = $refaddr,\n"\
                "$indent3.count = $refcount\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $LinkRefs]} {
            lassign [dict get $Value next] nclass ninst ncomp
            set nextaddr [GenInstanceAddress $domain $nclass $ninst]
            lassign [dict get $Value prev] pclass pinst pcomp
            set prevaddr [GenInstanceAddress $domain $pclass $pinst]
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $nextaddr.$ncomp,\n"\
                "$indent3.prev = $prevaddr.$pcomp\n"\
                "$indent2\},\n"
            continue
        }
    }

    append result "$indent\},\n"

    return $result
}
----

=== Assigner Instance Definitions

(((micca,Code Generation,assignerInstanceDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc assignerInstanceDefinitions {} {
    variable domain
    set result {}

    append result [comment "Single Assigner Instance Definitions"]
    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $singles {
        set initstate [pipe {
            findRelated $assigner R53 R50 R58 R57 |
            readAttribute ~ Number
        }]
        assignAttribute $assigner
        set instnum [GetClassProperty $Association Number]
        append result\
            "static struct $Association ${Association}__POOL\[1\] = \{\n"\
            "    \{\n"\
            "        .base__INST = \{\n"\
            "            .classDesc = &${domain}__ASSIGNERS\[$instnum\],\n"\
            "            .alloc = 1,\n"\
            "            .currentState = $initstate,\n"\
            "            .refCount = 0,\n"\
            "                #ifndef MRT_NO_NAMES\n"\
            "            .name = single_assigner_instance__NAME\n"\
            "                #endif /* MRT_NO_NAMES */\n"\
            "        \}\n"\
            "    \}\n"\
            "\} ;\n"
    }

    append result [comment "Multiple Assigner Instance Definitions"]
    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        assignAttribute $multi
        set initstate [pipe {
            findRelated $multi R53 R50 R58 R57 |
            readAttribute ~ Number
        }]

        set multiinsts [findRelated $multi ~R106]
        if {[isNotEmptyRef $multiinsts]} {
            set totalinsts [GetClassProperty $Class TotalInstance]
            set instnum [GetClassProperty $Association Number]
            append result "static struct $Association\
                    ${Association}__POOL\[$totalinsts\] = \{\n"
            forAllRefs assigner $multiinsts {
                assignAttribute $assigner
                set allocnum 0
                append result\
                    "    \[$Number\] = \{\n"\
                    "        .base__INST = \{\n"\
                    "            .classDesc = &${domain}__ASSIGNERS\[$instnum\],\n"\
                    "            .alloc = [incr allocnum],\n"\
                    "            .currentState = $initstate,\n"\
                    "            .refCount = 0,\n"\
                    "                #ifndef MRT_NO_NAMES\n"\
                    "            .name = \"$Instance\"\n"\
                    "                #endif /* MRT_NO_NAMES */\n"\
                    "        \},\n"\
                    "        .idinstance = [GenInstanceAddress $domain $IdClass\
                            $IdInstance]\n"\
                    "    \},\n"\
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

=== Operation Definitions

(((micca,Code Generation,operationDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc operationDefinitions {} {
    variable domain

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    set result [comment "Operation Definitions"]
    relation foreach op $ops {
        relation assign $op
        append result\
            "static $ReturnDataType\n${Class}_$Operation"

        if {[relation isempty $Parameters]} {
            append result "\(void\)\n"
            set syms [relation create {
                Name string Ctype string Type string Class string
            }]
        } else {
            set pdecls {}
            relation foreach param $Parameters -ascending Number {
                relation assign $param
                append pdecls\
                    [typeCheck composeDeclaration $DataType $Name]\
                    ,\n
            }
            set pdecls [string trimright $pdecls ",\n"]\)\n
            append result\
                "\(\n"\
                [indentCode $pdecls]

            set syms [pipe {
                relation project $Parameters Name DataType |
                relation rename ~ DataType Ctype |
                relation extend ~ stup\
                    Type string {{}}\
                    Class string {{}} |
                relation update ~ utup {
                    [tuple extract $utup Name] eq "self"} {
                    tuple update $utup Type Reference Class $Class
                }
            }]
        }

        append result\
            [blockcomment $Body]\
            "\{\n"\
            "    MRT_INSTRUMENT_ENTRY\n"\
            [ExpandActivity "$Operation operation" $Body $syms]\
            "\}\n"
    }

    return $result
}
----

=== Constructor Definitions

(((micca,Code Generation,ctorDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc ctorDefinitions {} {
    return [TorDefinitions Constructor]
}
----

[source,tcl]
----
<<generation code commands>>=
proc TorDefinitions {which} {
    variable domain
    set suffixmap [dict create\
        Constructor CTOR\
        Destructor DTOR\
    ]
    set result [comment "$which Definitions"]

    set tors [$which findWhere {$Domain eq $domain}]

    forAllRefs tor $tors {
        assignAttribute $tor

        set selfdecl [GetClassProperty $Class Reference]const
        set syms [relation create {
            Name string Ctype string Type string Class string
        } [list Name self Ctype $selfdecl Type Reference Class $Class]]
        append result\
            "static void\n${Class}__[dict get $suffixmap $which]\(\n"\
            "    void *const s__SELF\)\n"\
            [blockcomment $Body]\
            "\{\n"\
            "    MRT_INSTRUMENT_ENTRY\n"\
            "    $selfdecl self = s__SELF ;\n"\
            [ExpandActivity "$Class $which" $Body $syms]\
            "\}\n"
    }

    return $result
}
----

=== Destructor Definitions

(((micca,Code Generation,dtorDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc dtorDefinitions {} {
    return [TorDefinitions Destructor]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-17.0 {
    Generated code file with constructor and destructor
} -setup {
    validateutils genMiccaFile codegen17 {
        domain codegen17 {
            domainop void initialize {} {
                codegen17__INIT() ;
            }

            class X {
                attribute color int -default 20

                constructor {
                    self->color += 20 ;
                }
                destructor {
                    self->color -= 20 ;
                }
            }
        }
        population codegen17 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen17.c
    testConditions\
    {[validateutils matchLines codegen17.c {
        static void
        X__CTOR(
            void *const s__SELF)
        // self->color += 20 ;
        {
            MRT_INSTRUMENT_ENTRY
            struct X *const self = s__SELF ;
            self->color += 20 ;
        }
    }]}\
    {[validateutils matchLines codegen17.c {
        static void
        X__DTOR(
            void *const s__SELF)
        // self->color -= 20 ;
        {
            MRT_INSTRUMENT_ENTRY
            struct X *const self = s__SELF ;
            self->color -= 20 ;
        }
    }]}
} -result {1}
----
endif::showtests[]

=== Formula Definitions

(((micca,Code Generation,formulaDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc formulaDefinitions {} {
    variable domain
    set result [comment "Dependent Attribute Formula Definitions"]

    set deps [DependentAttribute findWhere {$Domain eq $domain}]

    forAllRefs dep $deps {
        assignAttribute $dep
        set type [readAttribute [findRelated $dep R29] DataType]

        set selfdecl [GetClassProperty $Class ConstReference]const
        set syms [relation create {
            Name string Ctype string Type string Class string
        }\
            [list Name self Ctype $selfdecl Type Reference Class $Class]\
            [list Name $Name Ctype "void *const" Type {} Class {}]\
            [list Name size Ctype MRT_AttrSize Type {} Class {}]\
        ]
        append result\
            "static void\n${Class}_${Name}__FORMULA\(\n"\
            "    void const *const s__,\n"\
            "    void *const v__,\n"\
            "    MRT_AttrSize size\)\n"\
            [blockcomment $Formula]\
            "\{\n"\
            "    MRT_INSTRUMENT_ENTRY\n"\
            "    $selfdecl self = s__ ;\n"\
            "    $type *const $Name = v__ ;\n"\
            [ExpandActivity "$Class $Name Formula" $Formula $syms]\
            "\}\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-54.0 {
    Generated code file with dependent attribute
} -setup {
    validateutils genMiccaFile codegen54 {
        domain codegen54 {
            class X {
                attribute width unsigned -default 10
                attribute length unsigned -default 15
                attribute area unsigned -dependent {
                    *area = %<my attr width>% * %<my attr length>% ;
                }

                classop {struct X *} findByArea {requestedArea unsigned} {
                    %<X foreachInstance xref>%
                        %<instance xref assign area>%
                        if (area == requestedArea) {
                            return xref ;
                        }
                    %<end>%
                    return NULL ;
                }
            }
        }
        population codegen54 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen54.c
    testConditions\
    {[validateutils matchLines codegen54.c {
        struct X const *const self = s__ ;
        unsigned *const area = v__ ;
        *area = self->width * self->length ;
    }]}\
    {[validateutils matchLines codegen54.c {
        unsigned area ;
        X_area__FORMULA(xref, &area, sizeof(area)) ;
        if (area == requestedArea) {
            return xref ;
        }
    }]}
} -result {1}
----
endif::showtests[]

=== Activity Definitions

(((micca,Code Generation,activityDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc activityDefinitions {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && [string trim $Activity] ne {}} |
        deRef ~ |
        relation eliminate ~ Domain IsFinal |
        relation group ~ States Name Activity PSigID
    }]
    # puts [relformat $classes classes]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Definitions"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            append result "#define MRT_CLASSNAME \"$Model\"\n"
            relation foreach state $States {
                relation assign $state
                set selfdecl [GetClassProperty $Model Reference]const
                append result\
                    "static void\n${Model}_${Name}__ACTIVITY\(\n"\
                    "    void *const s__SELF,\n"\
                    "    void const *const p__PARAMS)\n"\
                    [blockcomment $Activity]\
                    "\{\n"\
                    "        #define MRT_STATENAME \"$Name\"\n"\
                    "    MRT_INSTRUMENT_ENTRY\n"\
                    "    $selfdecl self = s__SELF ;\n"
                if {$PSigID ne {}} {
                    set signame ${Model}_${Name}__SPARAMS
                    append result\
                        "    struct $signame const *const pp__PARAMS = p__PARAMS ;\n"
                    set params [pipe {
                        ParameterSignature findById Domain $domain PSigID $PSigID |
                        FindParamsFromSig ~
                    }]
                    # HERE ! we are unwrapping the event parameters into
                    # local variables. Parameters passed as arrays, should
                    # be able to be unwrapped as just a pointer to the
                    # array contained in the event parameter data.
                    # This code creates a new array and copies the value
                    # from the event parameter into the new local array.
                    # Seems a waste.
                    relation foreach param $params -ascending Position {
                        relation assign $param {Name pname} Declaration DataType
                        set asgnment [string cat\
                            "$Declaration ;\n"\
                            [GenValueAssignment $domain $pname\
                                pp__PARAMS->$pname $DataType]\
                        ]
                        append result [indentCode $asgnment]
                    }

                    set syms [pipe {
                        relation project $params Name Declaration |
                        relation rename ~ Declaration Ctype |
                        relation extend ~ stup\
                            Type string {{}}\
                            Class string {{}}
                    }]
                } else {
                    set syms [relation create {
                        Name string Ctype string Type string Class string
                    }]
                }
                set syms [relation insert $syms [list Name self Ctype $selfdecl\
                        Type Reference Class $Model]]

                append result\
                    [ExpandActivity "$Model $Name activity" $Activity $syms]

                append result\
                    "        #undef MRT_STATENAME\n"\
                    "\}\n"
            }
            append result "#undef MRT_CLASSNAME\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc FindParamsFromSig {psigRef} {
    return [pipe {
        findRelated $psigRef ~R79 |
        deRef % |
        relation join % $::micca::Argument |
        relation extend % ptup Declaration string {\
            [typeCheck composeDeclaration\
                [tuple extract $ptup DataType]\
                [tuple extract $ptup Name]]}
    } {} |%]
}
----

[source,tcl]
----
<<generation helper commands>>=
proc GenValueAssignment {domain dest src datatype} {
    set asgnType [typeCheck assignmentType [UnaliasType $domain $datatype]]
    switch -exact -- [dict get $asgnType type] {
        scalar {
            append result "$dest = $src ;\n"
        }
        string {
            set dimension [dict get $asgnType dimension]
            set maxchars [expr {$dimension - 1}]
            append result\
                "strncpy($dest, $src, $maxchars) ;\n"\
                "$dest\[$maxchars\] = '\\0' ;\n"
        }
        array {
            append result "memcpy($dest, $src, sizeof($dest)) ;\n"
        }
        default {
            error "unknown assignment type, \"[dict get $asgnType type]\""
        }
    }
    return $result
}
----

=== Domain Constructor Definition

(((micca,Code Generation,domainCtorDefinition)))
[source,tcl]
----
<<generation code commands>>=
proc domainCtorDefinition {} {
    variable domain
    set result [comment "Definition of Function to Construct Initial Instances"]

    set ctorinsts [pipe {
        Constructor findWhere {$Domain eq $domain} |
        deRef ~ |
        relation eliminate ~ Body |
        relation join ~ $::micca::ClassInstance |
        relation group ~ Instances Instance Number
    }]

    if {[relation isnotempty $ctorinsts]} {
        relation foreach ctorinst $ctorinsts {
            relation assign $ctorinst
            relation foreach instance $Instances -ascending Number {
                relation assign $instance
                append invocations\
                    "${Class}__CTOR\("\
                    [GenInstanceAddress $domain $Class $Instance]\
                    "\) ;\n"
            }
        }
        append result\
            "static void\n${domain}__INIT\(void\)\n"\
            "\{\n"\
            [indentCode $invocations]\
            "\}\n"
    }

    return $result
}
----

=== Domain Operation Definitions

(((micca,Code Generation,domainOpDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc domainOpDefinitions {} {
    variable domain
    set result [comment "Domain Operation Definitions"]

    set ops [pipe {
        DomainOperation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::DomainOperationParameter Parameters
    }]

    relation foreach op $ops {
        relation assign $op
        append result\
            "$ReturnDataType\n${domain}_${Operation}"

        if {[relation isempty $Parameters]} {
            set decl "\(void\)\n"
            append result $decl
            set syms [relation create {
                Name string Ctype string Type string Class string
            }]
        } else {
            set pdecls {}
            relation foreach param $Parameters -ascending Number {
                relation assign $param
                append pdecls\
                    [typeCheck composeDeclaration $DataType $Name]\
                    ,\n
            }
            set pdecls [string trimright $pdecls ",\n"]\)\n
            set decl [string cat\
                "\(\n"\
                [indentCode $pdecls]\
            ]
            append result $decl
            set syms [pipe {
                relation project $Parameters Name DataType |
                relation rename ~ DataType Ctype |
                relation extend ~ stup\
                    Type string {{}}\
                    Class string {{}}
            }]
        }

        append result\
            [blockcomment $Body]\
            "\{\n"\
            "    MRT_INSTRUMENT_ENTRY\n"\
            [ExpandActivity "$Operation domain operation" $Body $syms]\
            "\}\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-18.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -setup {
    # makeFile {} codegen18.h
    # makeFile {} codegen18.c
    micca configure {
        domain codegen18 {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }

            class X {
                attribute color int -default 10
            }
        }
        population codegen18 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {codegen18_color} codegen18.c]] == 1}
} -result {1}
----
endif::showtests[]

=== External Operation Definitions

(((micca,Code Generation,externalOpDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc externalOpDefinitions {} {
    upvar #0 [namespace parent]::options options
    if {![dict get $options stubexternalops]} {
        return
    }

    variable domain
    set result [comment "External Operation Stub Definitions"]

    set ops [pipe {
        ExternalOperation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::ExternalOperationParameter Parameters
    }]

    relation foreach op $ops {
        relation assign $op
        append result\
            "$ReturnDataType\n${domain}_${Operation}__EOP"

        if {[relation isempty $Parameters]} {
            append result "\(void\)\n"
            set syms [relation create {
                Name string Ctype string Type string Class string
            }]
        } else {
            set pdecls {}
            relation foreach param $Parameters -ascending Number {
                relation assign $param
                append pdecls\
                    [typeCheck composeDeclaration $DataType $Name]\
                    ,\n
            }
            set pdecls [string trimright $pdecls ",\n"]\)\n
            append result\
                "\(\n"\
                [indentCode $pdecls]
            set syms [pipe {
                relation project $Parameters Name DataType |
                relation rename ~ DataType Ctype |
                relation extend ~ stup\
                    Type string {{}}\
                    Class string {{}}
            }]
        }

        append result\
            [blockcomment $Body]\
            "\{\n"\
            "    MRT_INSTRUMENT_ENTRY\n"\
            [ExpandActivity "$Operation external operation" $Body $syms]\
            "\}\n"
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-19.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -setup {
    # makeFile {} codegen19.h
    # makeFile {} codegen19.c
    micca configure {
        domain codegen19 {
            externalop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }

            class X {
                attribute color int -default 10
            }
        }
        population codegen19 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate stubexternalops true
    testConditions\
        {[llength [fileutil::grep {codegen19_color__EOP} codegen19.c]] == 1}
} -result {1}
----
endif::showtests[]

=== Portal Data Definitions

(((micca,Code Generation,portalDefinitions)))
[source,tcl]
----
<<generation code commands>>=
proc portalDefinition {} {
    variable domain

    set classRefs [Class findWhere {$Domain eq $domain}]
    set assignRefs [AssignerStateModel findWhere {$Domain eq $domain}]
    set acount [refMultiplicity $assignRefs]
    set aptr [expr {$acount == 0 ? "NULL" : "${domain}__ASSIGNERS"}]
    append result\
        [comment "Domain Portal Definition"]\
        "MRT_DomainPortal const ${domain}__PORTAL = \{\n"\
        "    .classCount = [refMultiplicity $classRefs],\n"\
        "    .classes = ${domain}__CLASSES,\n"\
        "    .assignerCount = $acount,\n"\
        "    .assigners = $aptr,\n"\
        "        #ifndef MRT_NO_NAMES\n"\
        "    .name = \"$domain\"\n"\
        "        #endif /* MRT_NO_NAMES */\n"\
        "\} ;\n"
}
----

=== Epilogue Declarations

(((micca,Code Generation,epilogueDeclarations)))
[source,tcl]
----
<<generation code commands>>=
proc epilogueDeclarations {} {
    variable epilogue

    return [string cat\
        [comment "Domain Epilogue"]\
        [indentCode [string trim $epilogue] 0]\
    ]
}
----

== Generating Activity Code

In this section we discuss the macro commands that are available
to a translator for easing the burden of translating model level
execution into the required ``C'' code.
When using `micca` to translate a model,
state activities are coded in ``C'' and passed along to the generated
code file.
To make coding model level actions easier,
the ``C'' code supplied by the translator for state activities and other
operations can contain embedded macros which are further expanded
by the code generator.
The macros are simple commands with arguments that are enclosed
in the special delimiters *%<* and *>%*.
For example,
the macro to access the *Color* attribute of an instance could be written
as:

*****
ColorType c = %<my attr Color>% ;
*****

For this example,
the code generator expands the commands contained between the *%<*
and *>%* delimiters and replaces the embedded macro with ``C'' code required to
access the value of the *Color* attribute of the instance referenced by the
value of the *self* variable.
This is a very simple case, but even here the code generator
performs a number of significant checks in an attempt to discover
errors before code is sent to the compiler.
In this case, the code generator insures that the attribute named
*Color* exists for the class to which the `self` instance refers.

There are many of these macro commands to handle common model level
processing.
State activities are then a mix of ``C'' code and embedded macros commands
to accomplish the purpose of the activity.
The straight ``C'' contains the algorithmic processing and the
expanded macros handle the model level actions such as navigating
relationships, finding instances and dealing with attribute updates.
These types of model level actions must account for the data structures
and naming conventions that the run-time code uses.
Since the code generator has access to the populated platform model,
it performs many consistency checks that would otherwise result in
compiler errors.
Discovering errors earlier makes them much easier to correct since
relating compiler error messages back to the `micca` source
becomes more difficult in the face of another level of translation.

The macro commands expand to one of three types of ``C'' constructs:

. A macro command may expand to a statement in ``C''.
For statement macros,
the expansion yields one or more lines of code and the code generator
takes care of the semicolon punctuation.
. A macro command may expand to an expression in ``C''.
For expression macros,
the code generator just replaces the macro and does not add any punctuation.
This enables a expression macro to be used inside of another ``C'' expression.
. A macro command may expand to a construct in ``C'' requiring a
compound statement.
For macros generating compound statements,
additional ``C'' code is included in the compound statement body and
the end of the loop is given by invoking the `%<end>%` macro.
Typically, the these macros allow iteration over sets of instances
and the compound statement body is executed once for
each instance.

In the descriptions below we state the expansion type of each macro.

=== Expanding the Activities Macros

Just as we have been using the `textutil::expander` command to perform
macro expansion for generating the header and code files,
we will use it to expand the embedded macros in the state activities.
We will use a separate instance of the the expander and will direct
this expansion to happen in its own namespace.
The namespace will allow us to define the macro commands so that the commands
will resolve with unqualified names.
We will also use a namespace to handle the details of the expansion code
itself.
Following our usual pattern,
we define the namespace for the generation of the embedded macros.

[source,tcl]
----
<<generation support namespace>>=
namespace eval GenSupport {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar

    namespace export ExpandActivity

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }
    upvar #0 ::micca::@Gen@::errcount errcount

    textutil::expander actexpand
    actexpand setbrackets %< >% ; # <1>
    actexpand evalcmd "namespace eval [namespace parent]::GenActivity"
    actexpand errmode fail
    actexpand textcmd [namespace current]::ProcessCodeLines

    <<generation support data>>
    <<generation support commands>>
}
----
<1> The default way to embed commands in the template is with
the conventional Tcl brackets ([ ]).
Those characters are inconvenient in ``C'' so we use bracket strings
that create less interference.

=== Creating the Macro Commands

The commands available for embedding into ``C'' activity code
are organized into groups.

* A command to invoke external operations.
* Commands related to classes.
* Commands related to relationships.
* Commands related to instances.
* Commands related to instance sets.

Each of these different command groups are discussed in sections below.
Since we are using a template expander to expand the commands,
in this section we show how the expansion commands are created.

For classes and relationships,
embedded macro commands named after the classes and relationships themselves
are created.
For example, if the domain contains a class named `WashingMachine`,
then there will be an embedded command named `WashingMachine`
that can be used to access class level functions specific to the
`WashingMachine` class.
The same holds true for a relationship.
If `R27` exists in the domain, then there will be an embedded command
named `R27` that can be used to relate and unrelate instances
across the relationship.
To insure that there is no conflict in names,
we will create the embedded commands in their own namespace,
`GenActivity` as a child namespace of `GenSupport`.
Since all classes (or relationships) have the same set of subcommands
available to them, we will namespace ensembles to obtain the
``object oriented'' Tcl style for the embedded commands.

[source,tcl]
----
<<generation commands>>=
proc CreateActivityCommands {domain} {
    namespace eval GenActivity {
        logger::initNamespace [namespace current]
    }

    set currns [namespace current]
    set actns ${currns}::GenActivity
    set suppns ${currns}::GenSupport

    <<CreateActivityCommands: classes>>
    <<CreateActivityCommands: relationships>>
    <<CreateActivityCommands: instances>>
    <<CreateActivityCommands: instance sets>>

    interp alias {} ${actns}::externalop {} ${suppns}::InvokeExternalOp
    interp alias {} ${actns}::end {} ${suppns}::End
}
----

We see that the code is sectioned into four chunks based on what
the namespace ensemble command refers to.

First,
we query some information about the classes in the domain we are
generating.
The class commands will vary depending upon:
\(1) the class having a defined state model and
\(2) if a class with a state model has creation events.

[source,tcl]
----
<<CreateActivityCommands: classes>>=
set classInfo [pipe {
    Class findWhere {$Domain eq $domain} |
    deRef ~ |
    ralutil::rvajoin ~ [relation rename $::micca::StateModel Model Name]\
        StateModels |
    relation extend ~ itup HasStateModel boolean {
        [relation isnotempty [tuple extract $itup StateModels]]} |
    ralutil::rvajoin ~\
        [relation rename $::micca::CreationState Name State Model Name]\
        CreationStates |
    relation extend ~ ctup HasCreationState boolean {
        [relation isnotempty [tuple extract $ctup CreationStates]]} |
    relation project ~ Name HasStateModel HasCreationState
}]
----

We first need to find out all the union subclass names.
As usual, union subclasses have to be treated a bit differently.
A union subclass cannot be created either synchronously or asynchronously.
A union subclass can only be migrated as part of a generalization.

[source,tcl]
----
<<CreateActivityCommands: classes>>=
set usubnames [pipe {
    UnionSubclass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation list ~ Class
}]
----

We now iterate over the classes for the domain and construct the
namespace ensemble command map.
Command maps are the key to ensemble commands and allow you to
forward the command invocation with additional information
(in this case the name of the class).

[source,tcl]
----
<<CreateActivityCommands: classes>>=
set cmdmap [dict create]
relation foreach info $classInfo {
    relation assign $info
    set cmdmap [dict create\
        foreachInstance [list ${suppns}::ClassForeachInstance $Name]\
        foreachWhere [list ${suppns}::ClassForeachWhere $Name]\
        findWhere [list ${suppns}::ClassFindWhere $Name]\
        selectWhere [list ${suppns}::ClassSelectWhere $Name]\
        instref [list ${suppns}::ClassInstanceReference $Name]\
        idtoref [list ${suppns}::ClassIdToRef $Name]\
        instset [list ${suppns}::ClassInstanceSet $Name]\
        findByName [list ${suppns}::ClassFindByName $Name]\
        operation [list ${suppns}::ClassOperation $Name]\
    ]
    if {$Name ni $usubnames} {
        dict set cmdmap create [list ${suppns}::ClassCreate $Name]
        if {$HasStateModel} {
            dict set cmdmap createin [list ${suppns}::ClassCreateIn $Name]
        }
        if {$HasCreationState} {
            dict set cmdmap createasync [list ${suppns}::ClassCreateAsync $Name]
        }
    }
    namespace ensemble create\
        -command ${actns}::$Name\
        -map $cmdmap
}
----

For relationships,
we must consider each type of relationships separately.
As shown in the platform model,
the top level specialization of relationships is between
associations and generalizations.

[source,tcl]
----
<<CreateActivityCommands: relationships>>=
set relRefs [Relationship findWhere {$Domain eq $domain}]

<<CreateActivityCommands: associations>>
<<CreateActivityCommands: generalizations>>
----

The functions for association commands deal primarily with
swapping instances instances across the association.
Associations can also have an assigner defined for them.
In that case they need to be able to signal an event to the assigner.
In the case of a multiple assigner,
the relationship command also need to support creating an instance
of the assigner.
Associations are further specialized into simple associations and
class based associations.
All the permutations of these commands are considered below.

[source,tcl]
----
<<CreateActivityCommands: associations>>=
set assocs [findRelatedWhere $relRefs {{~R30 Association}} {!$IsStatic}]

<<CreateActivityCommands: simple associations>>
<<CreateActivityCommands: class based associations>>
----

[source,tcl]
----
<<CreateActivityCommands: simple associations>>=
set simpassocs [findRelated $assocs {~R31 SimpleAssociation}]
forAllRefs simpassoc $simpassocs {
    set simpname [readAttribute $simpassoc Name]
    set cmdmap [dict create\
        swap [list ${suppns}::RelSimpleSwap $simpname]\
    ]
    set assigner [findRelated $simpassoc R31 ~R52]
    if {[isNotEmptyRef $assigner]} {
        if {[isNotEmptyRef [findRelated $assigner {~R53 SingleAssigner}]]} {
            dict set cmdmap signal\
                [list ${suppns}::SingleAssignerSignal $simpname]
        } else {
            dict set cmdmap findWhere [list ${suppns}::ClassFindWhere $simpname]
            dict set cmdmap create [list ${suppns}::MultiAssignerCreate $simpname]
        }
    }
    namespace ensemble create\
        -command ${actns}::$simpname\
        -map $cmdmap
}
----

[source,tcl]
----
<<CreateActivityCommands: class based associations>>=
set classassocs [findRelated $assocs {~R31 ClassBasedAssociation}]
forAllRefs classassoc $classassocs {
    set cbname [readAttribute $classassoc Name]
    set cmdmap [dict create\
        swap [list ${suppns}::RelClassSwap $cbname]\
    ]
    set assigner [findRelated $classassoc R31 ~R52]
    if {[isNotEmptyRef $assigner]} {
        if {[isNotEmptyRef [findRelated $assigner {~R53 SingleAssigner}]]} {
            dict set cmdmap signal\
                [list ${suppns}::SingleAssignerSignal $cbname]
        } else {
            dict set cmdmap findWhere [list ${suppns}::ClassFindWhere $cbname]
            dict set cmdmap create [list ${suppns}::MultiAssignerCreate $cbname]
        }
    }
    namespace ensemble create\
        -command ${actns}::$cbname\
        -map $cmdmap
}
----

Generalization relationships are specialized into those using
references and those using unions.
The command distinction is that union generalizations only support
a single subcommand, namely `migrate`.
Given the storage arrangement for union generalizations,
relating and unrelating instances does not make sense
since subclass instances are bound to the storage of their superclass
instances..

[source,tcl]
----
<<CreateActivityCommands: generalizations>>=
set gens [findRelated $relRefs {~R30 Generalization}]

<<CreateActivityCommands: reference generalizations>>
<<CreateActivityCommands: union generalizations>>
----

[source,tcl]
----
<<CreateActivityCommands: reference generalizations>>=
set refgens [findRelated $gens {~R43 ReferenceGeneralization}]
foreach rgname [relation list [deRef $refgens] Name] {
    set cmdmap [dict create\
        reclassify [list ${suppns}::RelRefGenReclassify $rgname]\
    ]
    namespace ensemble create\
        -command ${actns}::$rgname\
        -map $cmdmap
}
----

[source,tcl]
----
<<CreateActivityCommands: union generalizations>>=
set uniongens [findRelated $gens {~R43 UnionGeneralization}]
foreach ugname [relation list [deRef $uniongens] Name] {
    namespace ensemble create\
        -command ${actns}::$ugname\
        -map [dict create\
            reclassify [list ${suppns}::RelUnionGenReclassify $ugname]\
        ]
}
----

The ensemble command for class instances is much simpler.
All instances have the same set of subcommands and they
are simply enumerated in the command map of the ensemble.

[source,tcl]
----
<<CreateActivityCommands: instances>>=
set cmdmap [dict create\
    attr ${suppns}::InstanceAttrRead\
    update ${suppns}::InstanceAttrUpdate\
    assign ${suppns}::InstanceAssign\
    signal ${suppns}::InstanceSignal\
    delaysignal ${suppns}::InstanceDelaySignal\
    canceldelayed ${suppns}::InstanceCancelSignal\
    delayremaining ${suppns}::InstanceRemainingTime\
    delete ${suppns}::InstanceDelete\
    operation ${suppns}::InstanceOperation\
    foreachRelated ${suppns}::InstanceForeachRelated\
    foreachRelatedWhere ${suppns}::InstanceForeachRelatedWhere\
    findOneRelated ${suppns}::InstanceFindOneRelated\
    instid ${suppns}::InstanceRefToId\
]
namespace ensemble create\
    -command ${actns}::instance\
    -parameters instref\
    -map $cmdmap
----

To save some typing,
we create an ensemble command named `my` which is just a shorthand for
`instance self`.

[source,tcl]
----
<<CreateActivityCommands: instances>>=
set cmdmap [dict create\
    attr [list ${suppns}::InstanceAttrRead self]\
    update [list ${suppns}::InstanceAttrUpdate self]\
    assign [list ${suppns}::InstanceAssign self]\
    signal [list ${suppns}::InstanceSignal self]\
    delaysignal [list ${suppns}::InstanceDelaySignal self]\
    canceldelayed [list ${suppns}::InstanceCancelSignal self]\
    delayremaining [list ${suppns}::InstanceRemainingTime self]\
    delete [list ${suppns}::InstanceDelete self]\
    operation [list ${suppns}::InstanceOperation self]\
    instid [list ${suppns}::InstanceRefToId self]\
]
namespace ensemble create\
    -command ${actns}::my\
    -map $cmdmap
----

Instance sets also have a fixed set of subcommand operations.

[source,tcl]
----
<<CreateActivityCommands: instance sets>>=
set cmdmap [dict create\
    foreachSelected ${suppns}::InstanceSetForeachSelected\
    selectRelated ${suppns}::InstanceSetSelectRelated\
    selectRelatedWhere ${suppns}::InstanceSetSelectRelatedWhere\
    empty ${suppns}::InstanceSetEmpty\
    cardinality ${suppns}::InstanceSetCardinality\
    notempty ${suppns}::InstanceSetNotEmpty\
    equal ${suppns}::InstanceSetEqual\
    notequal ${suppns}::InstanceSetNotEqual\
    add ${suppns}::InstanceSetAdd\
    remove ${suppns}::InstanceSetRemove\
    contains ${suppns}::InstanceSetContains\
    union ${suppns}::InstanceSetUnion\
    intersect ${suppns}::InstanceSetIntersect\
    minus ${suppns}::InstanceSetMinus\
]
namespace ensemble create\
    -command ${actns}::instset\
    -parameters instset\
    -map $cmdmap
----

=== Symbol Table

The embedded macro commands have need to keep track of ``C'' variables.
So we provide some rudamentary symbol table support.
We must also account for the scoping rules for identifiers in ``C''.
In modern dialects of ``C'',
automatic variables may be declared almost anywhere in a function.
Each compound statement introduces a new variable scope and variables
declared within that scope go out of scope at the end of the compound
statement.
Further,
a variable declared in an interior scope may _hide_ a variable of the
same name in an outer scope.
Although this language feature may have some uses,
we will avoid it here.
Embedded commands that declare variables will not reuse a variable name
and thus risk hiding a variable by the same name in some outer scope.
In the case where a variable name is reused and there is a conflict
in the type of the variable,
an error is generated.

We also have to track ``C'' language scope in order to remove variables from
the symbol table as they go out of scope.
Otherwise, the generated code would elicit compiler errors by referring to
variables that a no longer in scope.

We hold the symbol table information in a relation variable.

[source,tcl]
----
<<generation support data>>=
relvar create Symbol {
    Name string
    Ctype string
    Type string
    Class string
    Block int
} Name
----

Name::
    The name of a variable.
Ctype::
    The ``C'' language type name for the variable.
Type::
    The type of the variable as it is used in the code generation.
    This may be the empty string if we do not know its usage from
    the context.
Class::
    The name of the class to which the variable pertains, if any.
Block::
    The block number in which the variable was declared.

We will also be creating temporary variables during the code generation
and will use a simple counter to make the names unique.
The counter is reset back to zero after each activity's code is generated
in order to have consistent symbol names in the generated code.

[source,tcl]
----
<<generation support data>>=
variable symcounter 0
----

Looking up a symbol returns a dictionary of the symbol attributes.

[source,tcl]
----
<<generation support commands>>=
proc LookUpSymbol {name} {
    set sym [relvar restrictone Symbol Name $name]
    if {[relation isnotempty $sym]} {
        return [tuple get [relation tuple $sym]]
    }

    return
}
----

Inserting a symbol also returns the dictionary of its attributes.

[source,tcl]
----
<<generation support commands>>=
proc InsertSymbol {args} {
    variable block
    dict set args Block $block
    try {
        set sym [relvar insert Symbol $args]
        return [tuple get [relation tuple $sym]]
    } trap {RAL relvar insert DUPLICATE_TUPLE*} {result} {
        error "duplicate symbol, [dict get $args Name], $result" ; # <1>
    } on error {result opts} {
        return -options $opts $result
    }
}
----
<1> We trap duplicates to give a better error message.

==== Verifying Symbols

The code generator needs to verify that symbols exist and have the
correct data types and other properties.

[source,tcl]
----
<<generation support commands>>=
proc CheckSymbol {name args} {
    set sym [LookUpSymbol $name]
    if {[dict size $sym] == 0} {
        error "unknown symbol, $name"
    }
    if {[llength $args] != 0} {
        CheckSymProperties $sym {*}$args
    }
    return $sym
}
----

[source,tcl]
----
<<generation support commands>>=
proc CheckSymProperties {sym args} {
    foreach {prop value} $args {
        # If the value of the property is the empty string, then we will assume
        # the value that is checked first. This lets us pass parameters where
        # we don't quite know the data type needs.
        if {[dict get $sym $prop] eq {}} {
            dict set sym $prop $value
            relvar update Symbol stup {
                    [tuple extract $stup Name] eq [dict get $sym Name] &&\
                    [tuple extract $stup $prop] eq {}
                } {
                    tuple update $stup $prop $value
                }
        }
        if {[dict get $sym $prop] ne $value} {
            error "for variable, [dict get $sym Name], expected $prop to be,\
                    $value: got [dict get $sym $prop] instead"
        }
    }
    return
}
----

We can specialize the symbol verification to the types of symbols most
commonly used by the code generation.

[source,tcl]
----
<<generation support commands>>=
proc CheckInstRefSymbol {varName args} {
    tailcall CheckSymbol $varName Type Reference {*}$args
}
----

[source,tcl]
----
<<generation support commands>>=
proc CheckInstSetSymbol {varName args} {
    tailcall CheckSymbol $varName Type InstanceSet {*}$args
}
----

The macro commands create temporary variables to hold intermediary results.

[source,tcl]
----
<<generation support commands>>=
proc CreateTempSymbol {args} {
    variable symcounter
    set name t__T[incr symcounter]
    InsertSymbol Name $name {*}$args
    return $name
}
----

Again, we specialize the creation procedure for the variable types
commonly used in code generation.

[source,tcl]
----
<<generation support commands>>=
proc CreateTempRefSymbol {className} {
    set reftype [GetClassProperty $className Reference]
    set symName [CreateTempSymbol Ctype $reftype Type Reference Class $className]
    return [list $reftype $symName]
}
----

Sometimes we know the name of a variable and want a declaration
for it.
However, if the variable has already been declared, then we don't want
a duplicate declaration.
This idea is again specialized for the common types of variable created
during code generation.

[source,tcl]
----
<<generation support commands>>=
proc CreateInstRefSymbol {className varName} {
    set sym [LookUpSymbol $varName]
    if {$sym ne {}} {
        CheckSymProperties $sym Class $className Type Reference
        return
    }
    set creftype [GetClassProperty $className Reference]
    InsertSymbol Name $varName Ctype $creftype Type Reference Class $className
    return "$creftype$varName ;\n"
}
----

[source,tcl]
----
<<generation support commands>>=
proc CreateInstSetSymbol {className varName} {
    set sym [LookUpSymbol $varName]
    if {$sym ne {}} {
        CheckSymProperties $sym Class $className Type InstanceSet
        return
    }
    set ctype MRT_InstSet
    InsertSymbol Name $varName Ctype $ctype Type InstanceSet Class $className
    return "$ctype $varName ;\n"
}
----

==== Tracking Code Blocks

Code blocks are tracked with a simple variable and are treated with
stack type semantics.

[source,tcl]
----
<<generation support commands>>=
proc PushBlock {{by 1}} {
    variable block
    incr block $by
}
----

[source,tcl]
----
<<generation support commands>>=
proc GetBlock {} {
    variable block
    return $block
}
----

To pop a code block has the side effect of deleting any symbols
defined with the block.

[source,tcl]
----
<<generation support commands>>=
proc PopBlock {{by -1}} {
    variable block
    relvar delete Symbol stup {[tuple extract $stup Block] == $block}
    incr block $by
}
----

In order to format the generated code neatly,
and to keep track of variable scopes introduced by ``C'' statements
in an activity,
we examine all the text as it is processed to deduce blocks going
in and out of scope and to format passed through code.
In the end the format of the generated code is not perfect,
but is much better than code generators usually produce.
Although the ``C'' compiler does not care about whitespace and code format,
the generated files from `micca` do show up during debugging and a consistent
format is worthwhile.

[source,tcl]
----
<<generation support commands>>=
proc ProcessCodeLines {text} {
    variable block

    # puts "text = \"$text\""
    set newlines [list]

    foreach line [split $text \n] {
        if {[string is space $line]} {
            if {[llength $newlines] != 0 && [lindex $newlines end] ne {}} {
                lappend newlines {}
            }
        } else {
            if {[string first \} $line] != -1} {
                incr block -1
            }
            if {[regsub -- {\A\s{4,}} $line {} newline] != 0} {
                set line [string repeat { } [expr {$block * 4}]]$newline
            }
            lappend newlines $line
            if {[string first \{ $line] != -1} {
                incr block
            }
        }
    }
    set newtext [join $newlines \n]
    # puts "newtext = \"$newtext\""

    return $newtext
}
----

To maintain the generated code formatting,
we supply a procedure to indent to the current block level.

[source,tcl]
----
<<generation support commands>>=
proc IndentToBlock {code} {
    variable block
    # indent seems to swallow a trailing new line
    return [::textutil::adjust::indent $code\
        [string repeat { } [expr {$block * 4}]]]\n
}
----

==== Expansion Context

The template expansion library supports the notion of a _context_.
A context is a temporary diversion of processing that can have its own
separate environment.
In that environment,
one can store variables that can be accessed later.
The expander code insures that all contexts are popped by the end.
The use we have here for the contexts is to implement the
`%<end>%` macro command.
The work that must be done is to close out any open compound statements
in the generated ``C'' code.
We will store one variable in the context called _depth_ which will be
the number of open blocks that need to be closed off.

[source,tcl]
----
<<generation support commands>>=
proc PushContext {context startblock} {
    actexpand cpush $context

    variable block
    actexpand cset depth [expr {$block - $startblock}]
    return
}
----

In our usage of expansion contexts,
some commands allow other code to be given that is executed
when certain conditions are met
(_e.g._ a code body that is part of an iteration).
At the end of the code block,
we must close off the open contexts.

[source,tcl]
----
<<generation support commands>>=
proc End {} {
    set result {}

    set context [actexpand cname]
    switch -exact -- $context {
        InstanceSetForeachSelected -
        InstanceForeachRelated -
        InstanceForeachRelatedWhere -
        ClassForeachInstance -
        ClassForeachWhere {
            set depth [actexpand cget depth]
            set result [actexpand cpop $context] ; # <1>
            for {set i 0} {$i < $depth} {incr i} {
                PopBlock
                append result [IndentToBlock "\}\n"]
            }
        } # <2>
        default {
            error "unknown context, \"$context\""
        }
    }
    append result [IndentToBlock [linecomment end]]

    return $result
}
----
<1> When the expander pops a context, it returns what has been
accumulated in that context.
<2> We check the context name to be one of the allowed ones
just to trap any errant calls to `PushContext`.

=== Template Expansion of Activity Code

[source,tcl]
----
<<generation support commands>>=
proc ExpandActivity {name body parameters} {
    # parameters is a relation value with heading:
    # Name string Ctype string Type string Class string

    variable block 1
    try {
        foreach param [relation body $parameters] {
            InsertSymbol {*}$param
        }
        return [actexpand expand $body]
    } on error {result} {
        # puts $::errorInfo
        log::error "$name: $result"
        variable errcount
        incr errcount
        set msg [pipe {
            split $result \n |
            lrange ~ 1 2 |
            string map [list \" {}] ~ |
            join ~
        }] ; # <1>
        return "#error \"$msg\"\n" ; <2>
    } finally {
        relvar set Symbol [relation emptyof [relvar set Symbol]]
        variable symcounter 0
    }
}
----
<1> Preparing a message suitable for `#error` from the error result.
<2> We place a `#error` statement in the code to make sure it
will not compile.

=== Invoking External Operations

*****
`%<externalop` _opname_ _?name1 value1 name2 value2 ...?_ `>%`

opname::
    The name of the external operation.
nameN / valueN::
    The arguments to the external operation are given as a set of
    name / value pairs.

The `external` command generates a ``C'' expression to invoke
the external operation given by, _opname_.
Arguments passed to the operation are given as name / value pairs.
The ordering of the pairs is arbitrary but all arguments of the
operation must be given.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InvokeExternalOp {opName args} {
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set opRef [ExternalOperation findWhere {$Domain eq $domain &&\
            $Name eq $opName}]
    if {[isEmptyRef $opRef]} {
        error "unknown external operation, $opName, for domain, $domain"
    }

    set provided [dict keys $args]
    set params [deRef [findRelated $opRef ~R11]]
    set required [relation list $params Name -ascending Number]
    ValidateParams $opName $provided $required

    set pset {}
    foreach pname $required {
        append pset "[dict get $args $pname], "
    }
    set pset [string trimright $pset {, }]

    return "${domain}_${opName}__EOP\($pset\)"
}
----

=== Instance Macro Commands

The macro command, `instance` has a number of subcommands used to
access various aspects of a class instance.
The instance commands follow a pattern:

*****
`%<instance` _instvar_ `subcommand` _?argument1 argument2 ...?_ `>%`
*****

The operation of the `subcommand`
is performed on class instance whose reference
is held in the _instvar_ variable.
The `subcommand` argument names the specific instance operation to
be performed.
Each possible `subcommand` is given in a section below describing the
operation.
Difference `subcommand` operation may require additional arguments
as described.

==== Access to Instance Attributes

It is possible and often desirable to access attributes of an instance
directly using ``C'' pointer indirection.
For example, the `Color` attribute of the instance referenced by
a `self` variable can be obtained using `self->Color`.

However,
`micca` also provides an embedded macro command to generate the pointer
indirection expression.
The command has the advantage of checking that the attribute name is
valid for the class and thus catching potential errors before compilation.

*****
`%<instance` _instvar_ `attr` _attrname_ `>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
attrname::
    The name of the attribute to be retrieved.

The `attr` subccommand generates a ``C'' expression to read
_attrname_ for the instance whose reference is contained in the
variable named, _instvar_.
The generated code is suitable for use in either an rvalue or lvalue context.
The class whose instance is held in _instvar_ must contain an attribute whose
name is _attrname_ or an error is generated.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceAttrRead {instref attr} {
    variable domain

    set sym [CheckInstRefSymbol $instref]
    set className [dict get $sym Class]
    set attrRef [Attribute findById Domain $domain Class $className Name $attr]
    if {[isNotEmptyRef $attrRef]} {
        set depRef [findRelated $attrRef {~R29 DependentAttribute}]
        if {[isNotEmptyRef $depRef]} {
            error "cannot use \"attr\" command for dependent attribute:\
                use \"assign\" command instead"
        }
        return "$instref->$attr"
    } else {
        set massRef [MultipleAssigner findById Domain $domain\
            Association $className]
        if {[isNotEmptyRef $massRef] && $attr eq "idinstance"} {
            return "$instref->$attr"
        }
        error "instance reference, $instref, refers to an instance of\
            class, $className, which does not have an attribute\
            named, $attr"
    }
}
----

*****
`%<instance` _instvar_ `update` ? _attrname1_ _value1_ ... ? `>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
attrnameN::
    The name of the attribute to be updated.
valueN::
    A valid ``C'' rvalue expression to be used as the new value for the
    attribute

The `update` subccommand generates a ``C'' statements to update zero or more
attribute values for the instance whose reference is contained in the variable
named, _instvar_.
Arguments are given in _attrname_ / _value_ pairs.
The class whose instance is held in _instvar_ must contain an attribute whose
name is _attrname_ or an error is generated.
Updating dependent attributes is not allowed.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceAttrUpdate {instref args} {
    variable domain

    if {[llength $args] % 2 != 0} {
        error "attribute name / values must be given in pairs, got:\
            \"$args\""
    }

    set sym [CheckInstRefSymbol $instref]
    set className [dict get $sym Class]

    set result [linecomment "instance $instref update $args"]
    foreach {attr value} $args {
        set attrRef [Attribute findById Domain $domain Class $className Name $attr]
        if {[isEmptyRef $attrRef]} {
            error "instance reference, $instref, refers to an instance of\
                class, $className, which does not have an attribute\
                named, $attr"
        }

        set depRef [findRelated $attrRef {~R29 DependentAttribute}]
        if {[isNotEmptyRef $depRef]} {
            error "cannot update dependent attribute"
        }

        append result [GenValueAssignment $domain $instref->$attr\
                $value [readAttribute $attrRef DataType]]
    }

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation helper commands>>=
proc UnaliasType {domain typename} {
    set aliasRef [TypeAlias findById Domain $domain TypeName $typename]
    return [expr {[isEmptyRef $aliasRef] ? $typename :\
        [readAttribute $aliasRef TypeDefinition]}]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-55.0 {
    Update attributes
} -setup {
    validateutils genMiccaFile codegen55 {
        domain codegen55 {
            typealias Name_t {char[32]}
            class X {
                attribute name Name_t -default {"n"}
                attribute temp {int[2]} -default {{0, 1}}
                attribute total int -default 0

                instop void updateAttrs {\
                        name {char const *}\
                        temp {int const *}\
                        total int} {
                    %<my update\
                        name name\
                        temp temp\
                        total total>%
                }
            }
        }
        population codegen55 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen55.c
    validateutils matchLines codegen55.c {
        // instance self update name name temp temp total total
        strncpy(self->name, name, 31) ;
        self->name[31] = '\0' ;
        memcpy(self->temp, temp, sizeof(self->temp)) ;
        self->total = total ;
    }
} -result {1}
----
endif::showtests[]

==== Assigning Instance Attributes to Variables

*****
`%<instance` _instvar_ `assign` _?assignspec1 assignspec2  ...?_ `>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
assignspecN::
    A set of attribute name / variable name pairs. Each _assignspec_
    argument consists of a list of one or two elements.
    The first element is the name of the attribute of _instvar_ to assign.
    The second element is the name of a local variable into which the
    assignment is made.
    If the second element is absent, then the assignment is made to
    a local variable with the same name as the attribute.

The `assign` subccommand generates ``C'' statements to assign
a set of attributes of _instvar_ to local variables
according the the _assignspec_ arguments.
All local variables are declared as necessary.
The class whose instance is held in _instvar_ must contain an attribute whose
name matches the attribute name in the _assignspec_ or an error is generated.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceAssign {instref args} {
    variable domain

    set sym [CheckInstRefSymbol $instref]
    set className [dict get $sym Class]

    set result [linecomment "instance $instref assign [list $args]"]
    foreach attrspec $args {
        if {[llength $attrspec] == 1} {
            set attrname [lindex $attrspec 0]
            set varname $attrname
        } elseif {[llength $attrspec] == 2} {
            lassign $attrspec attrname varname
        } else {
            error "bad attribute specification, \"$attrspec\":\
                expected 1 or 2 element list"
        }
        set attrRef [Attribute findById Domain $domain Class $className\
                Name $attrname]
        if {[isEmptyRef $attrRef]} {
            error "instance reference, $instref, refers to an instance of\
                class, $className, which does not have an attribute\
                named, $attrname"
        }
        assignAttribute $attrRef {DataType attrtype}

        set varsym [LookUpSymbol $varname]
        if {[dict size $varsym] != 0} {
            CheckSymProperties $varsym Ctype $attrtype
        } else {
            InsertSymbol Name $varname Ctype $attrtype Type {} Class {}
            append result "[typeCheck composeDeclaration $attrtype $varname] ;\n"
        }

        set indepRef [findRelated $attrRef {~R29 IndependentAttribute}]
        if {[isNotEmptyRef $indepRef]} {
            append result [GenValueAssignment $domain $varname\
                    $instref->$attrname $attrtype]
        } else {
            set asgnType [typeCheck assignmentType\
                    [UnaliasType $domain $attrtype]]
            set varref [expr {[dict get $asgnType type] ne "scalar" ?\
                    "$varname" : "&$varname"}]
            append result\
                "${className}_${attrname}__FORMULA($instref, $varref,\
                sizeof($varname)) ;\n"
        }
    }

    return [IndentToBlock $result]
}
----

==== Deleting Instances

*****
`%<instance` _instvar_ `delete>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.

The `delete` subccommand generates a ``C'' statement to delete the
class instance whose reference is contained in _instvar_.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceDelete {instref} {
    CheckInstRefSymbol $instref
    return [IndentToBlock [string cat\
        [linecomment "instance $instref delete"]\
        "mrt_DeleteInstance($instref) ;\n"\
    ]]
    return [IndentToBlock $result]
}
----

==== Invoking Instance Based Operations

*****
`%<instance` _instvar_ `operation` _opname param1 value1 param2 value2 ..._ `>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
opname::
    The name of the instance operation to be invoked.
paramN valueN::
    A set of named parameter values to the operation.

The `operation` subccommand generates a ``C'' expression to invoke the instance
based operation on the class instance whose reference is contained in
_instvar_.
The _opname_ argument must be a valid instance based operation defined
on the class of the _instvar_ instance.
Parameter arguments are parameter name / parameter value pairs,
where the parameter name must match that provided in the definition of
the operation.
Parameter values may be any valid ``C'' value expression such as a
variable name or a constant.
Parameters may be given in any order since they are named.
It is an error not to provide values for all the parameters of the
operation.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceOperation {instref opName args} {
    set instsym [CheckInstRefSymbol $instref]
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set className [dict get $instsym Class]
    set opRef [Operation findWhere {$Domain eq $domain && $Class eq $className\
        && $Name eq $opName && $IsInstance}]
    if {[isEmptyRef $opRef]} {
        error "unknown instance operation, $opName, for class, $className"
    }

    dict set args self $instref ; # <1>
    set provided [dict keys $args]
    set params [deRef [findRelated $opRef ~R4]]
    set required [relation list $params Name -ascending Number] ; # <2>
    ValidateParams $opName $provided $required

    set pset {}
    foreach pname $required {
        append pset "[dict get $args $pname], "
    }
    set pset [string trimright $pset {, }]

    return "${className}_$opName\($pset\)"
}
----
<1> The value of the implicit `self` argument is just the instance reference
upon which the macro command was invoked.
<2> The order is important here since ``C'' passes parameters by order.
We use the parameter numbering to translate from pass by name to pass by order.

We factor out some validation code which will be reused when generating
code for invoking other types of operations.

[source,tcl]
----
<<generation support commands>>=
proc ValidateParams {name provided required} {
    if {![struct::set equal $provided $required]} {
        lassign [struct::set intersect3 $provided $required]\
            p_inter_r p_minus_r r_minus_p
        if {![struct::set empty $p_minus_r]} {
            error "provided parameter(s), \"[join $p_minus_r ,]\", which are\
                not parameters to, $name"
        }
        if {![struct::set empty $r_minus_p]} {
            error "parameter(s), \"[join $r_minus_p ,]\", are required for,\
                $name, but were not provided"
        }
    }
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-49.0 {
    Invoke instance based operation
} -setup {
    validateutils genMiccaFile codegen49 {
        domain codegen49 {
            class X {
                attribute temp int -default 10

                instop void incrTemp {quantity int} {
                    %<my attr temp>% += quantity ;
                }
            }
            domainop void findys {} {
                %<X findByName x1 xref>%
                int x = 3 ;
                %<instance xref operation incrTemp quantity {x + 2}>% ;
            }
        }
        population codegen49 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen49.c
    testConditions\
        {[validateutils matchLines codegen49.c {
            X_incrTemp(xref, x + 2) ;
        }]}
} -result {1}
----
endif::showtests[]

==== Iterating Across Related Instances

Navigating a chain of relationships is one of the more
complicated model level actions in terms of the required code.
A relationship chain starts at a given class instance and then traverses
relationships to obtain a related set of class instances.
Often,
it is not necessary to actually accumulate the set of related instance
references.
For simple operations on the related instances,
it is sufficient to iterate across them and perform the operation as
each related instance is visited.

The different ``C'' level storage strategies for relationship pointers
is what makes navigation complicated.
Sometimes the navigation is accomplished by a single pointer,
sometimes a linked list and sometimes a counted array.
Some relationships are conditional and traversal through a conditional
relationship must insure that we have actually found an instance.
All of these considerations make is essential to provide an embedded
macro command to generate the required code.

<<relationship-naming-conventions,Previously>>, we explained the conventions
used to specify relationship traversal.
Those same conventions will be used here to specify, as a set of arguments,
the relationship chain to be navigated.

*****
`%<instance` _instvar_ `foreachRelated` _start rel1 ?rel2? ..._ `>%` +
_Loop Body_ +
`%<end>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
start::
    The name of a ``C'' variable containing the instance reference where
    the relationship navigation will begin.
relN::
    A set of relationship navigation specifications.

The `foreachRelated` subccommand generates ``C'' statements
to iterate across the set of instances obtained by navigating
the relationship chain which starts at the _start_ instance
and is given by the _relN_ arguments.
A reference to each instance found in the navigation is assigned to
the _instvar_ variable and then _Loop Body_ is executed.
Statements in the _Loop Body_ terminate at the `%<end>%` macro command.
The scope of the _instvar_ variable is confined to the statements in
the _Loop Body_ unless it was declared previously.

The relationship traversal is given as a set of relationship navigation
specifications of the form:

* `Rdd` -- traversing relationship _Rdd_ in the forward direction.
* `~Rdd` -- traversing relationship _Rdd_ in the backward direction.
* `{Rdd class}` -- traversing relationship _Rdd_ in the forward direction and
stopping at `class`.
* `{~Rdd class}` -- traversing relationship _Rdd_ in the backward direction and
stopping at `class`.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceForeachRelated {instref startref args} {
    set startblock [GetBlock]
    set result [IndentToBlock\
        [linecomment "instance $instref foreachRelated $startref [list $args]"]\
    ]

    lassign [TraverseRelChain $startref $args] chaincode targetclass targetref
    append result $chaincode
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $targetclass $instref]\
        "$instref = $targetref ;\n"]]

    PushContext InstanceForeachRelated $startblock

    return $result
}
----

The difficult part of the code generation for traversing a relationship
chain is factored in the to procedure below.
The `TraversRelChain` procedure generates the code to access the pointer
in the instance structures associated with a given set of relationships.
Since there are many different pointer arrangements,
the traversal code will be specific to each type of relationships
being traversed.
The return value of the function is a three element list giving the
generated code to traverse the relationship chain, the target class
of the end of the chain and a variable name containing the target instance
reference of the end.

[source,tcl]
----
<<generation support commands>>=
proc TraverseRelChain {startref relspecs} {
    variable domain

    if {[llength $relspecs] == 0} {
        error "empty relationship chain specification"
    }

    set result {}
    set startsym [CheckInstRefSymbol $startref]
    set startClass [dict get $startsym Class]

    foreach relspec $relspecs {
        set relinfo [LookUpRelationship $startClass $relspec]
        while {[llength $relinfo] != 0} {
            # puts "relinfo = \"$relinfo\""
            set relinfo [lassign $relinfo sourceclass targetclass reftype cond\
                comp]
            switch -exact -- $reftype {
                reference {
                    <<TraverseRelChain: single reference>>
                }
                array {
                    <<TraverseRelChain: array reference>>
                }
                linked {
                    <<TraverseRelChain: linked reference>>
                }
                reftosuper {
                    <<TraverseRelChain: reference to superclass>>
                }
                reftosub {
                    <<TraverseRelChain: reference to subclass>>
                }
                uniontosuper {
                    <<TraverseRelChain: union subclass to superclass reference>>
                }
                uniontosub {
                    <<TraverseRelChain: union superclass to subclass reference>>
                }
            }
            set startClass $targetclass
            set startref $targetref
        }
    }

    return [list $result $targetclass $targetref]
}
----

Instance references stored as a single pointer value generate
code to assign the pointer value into a temporary variable that
is suitable as an instance reference to the target of the navigation.

[source,tcl]
----
<<TraverseRelChain: single reference>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
set refcode "$targettype$targetref = $startref->$comp ; // $relspec \n"
if {$cond} { # <1>
    append refcode "if ($targetref != NULL) \{\n"
    append result [IndentToBlock $refcode]
    PushBlock
} else {
    append result [IndentToBlock $refcode]
}
----
<1> If the relationship is conditional, then we must generate code
to test if we obtained an instance pointer.

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-36.0 {
    Navigate simple association -- singular
} -setup {
    validateutils genMiccaFile codegen36 {
        domain codegen36 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 20
            }
            association R2 Z 0..1--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance z foreachRelated xs R1 ~R2>%
                    printf("z.value = %d\n", %<instance z attr value>%) ;
                %<end>%
            }
        }
        population codegen36 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen36.c
    testConditions\
        {[validateutils matchLines codegen36.c {
            struct Y *t__T1 = xs->R1 ; // R1
            struct Z *t__T2 = t__T1->R2__BACK ; // ~R2
            if (t__T2 != NULL) {
                struct Z *z ;
                z = t__T2 ;
                printf("z.value = %d\n", z->value) ;
            }
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-43.0 {
    Navigate class based association -- singular
} -setup {
    validateutils genMiccaFile codegen43 {
        domain codegen43 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -associator A X 1--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance y foreachRelated xs R1>%
                    printf("y.value = %d\n", %<instance y attr value>%) ;
                %<end>%
            }
        }
        population codegen43 {
            class A {
                instance a1 R1 {X x1 Y y1}
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen43.c
    testConditions\
        {[validateutils matchLines codegen43.c {
    struct A *t__T1 = xs->R1__FORW ; // R1
    struct Y *t__T2 = t__T1->R1.forward ; // R1
    struct Y *y ;
    y = t__T2 ;
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-44.0 {
    Navigate class based association -- singular, stop at associator
} -setup {
    validateutils genMiccaFile codegen44 {
        domain codegen44 {
            class A {
                attribute value int -default 40
            }
            class X {}
            class Y {}
            association R1 -associator A X 1--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance a foreachRelated xs {R1 A}>%
                    printf("a.value = %d\n", %<instance a attr value>%) ;
                %<end>%
            }
        }
        population codegen44 {
            class A {
                instance a1 R1 {X x1 Y y1}
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen44.c
    testConditions\
        {[validateutils matchLines codegen44.c {
            struct A *t__T1 = xs->R1__FORW ; // R1 A
            struct A *a ;
            a = t__T1 ;
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-51.0 {
    Navigate class based association -- singular, start at associator
} -setup {
    validateutils genMiccaFile codegen51 {
        domain codegen51 {
            class A {
                attribute value int -default 40
            }
            class X {}
            class Y {}
            association R1 -associator A X 1--1 Y

            domainop void findys {} {
                %<A findByName a1 aref>%
                %<instance yref findOneRelated aref R1>%
                printf("y name = %s\n", yref->base__INST.name) ;
                %<instance xref findOneRelated aref ~R1>%
                printf("x name = %s\n", xref->base__INST.name) ;
            }
        }
        population codegen51 {
            class A {
                instance a1 R1 {X x1 Y y1}
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen51.c
    testConditions\
        {[validateutils matchLines codegen51.c {
            struct Y *yref ;
            struct Y *t__T1 = aref->R1.forward ; // R1
            yref = t__T1 ;
        }]}\
        {[validateutils matchLines codegen51.c {
            struct X *xref ;
            struct X *t__T2 = aref->R1.backward ; // ~R1
            xref = t__T2 ;
        }]}
} -result {1}
----
endif::showtests[]

When we encounter a set of instance references stored in an array,
the generated code must set up a loop construct to visit all the
members of the set.

[source,tcl]
----
<<TraverseRelChain: array reference>>=
set itervar [CreateTempSymbol\
    Ctype "struct $targetclass *const *"\
    Type "ReferenceArray" Class $targetclass]
set cntvar [CreateTempSymbol Ctype size_t\
    Type ArrayCounter Class $targetclass]
set refcode "struct $targetclass *const *$itervar =\
        $startref->$comp.links ; // $relspec\n"
append refcode\
    "for (size_t $cntvar = $startref->$comp.count ;\
        $cntvar != 0 ; $cntvar--, $itervar++) \{" ; # <1>
append result [IndentToBlock $refcode]
PushBlock
lassign [CreateTempRefSymbol $targetclass] targettype targetref
append result [IndentToBlock "$targettype$targetref = *$itervar ;"]
----
<1> For the array case there is no special handling in case the
set of related instance is empty.
In the empty case, the code generator will have set the count
value to 0 and the loop will not be executed.

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-37.0 {
    Navigate simple association -- multiple static
} -setup {
    validateutils genMiccaFile codegen37 {
        domain codegen37 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 10
            }
            association R2 -static Z 0..*--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance z foreachRelated xs R1 ~R2>%
                    printf("z.value = %d\n", %<instance z attr value>%) ;
                %<end>%
            }
        }
        population codegen37 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
                instance z2 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen37.c
    testConditions\
        {[validateutils matchLines codegen37.c {
    struct Y *t__T1 = xs->R1 ; // R1
    struct Z *const *t__T2 = t__T1->R2__BACK.links ; // ~R2
    for (size_t t__T3 = t__T1->R2__BACK.count ; t__T3 != 0 ; t__T3--, t__T2++) {
        struct Z *t__T4 = *t__T2 ;
        struct Z *z ;
        z = t__T4 ;
        printf("z.value = %d\n", z->value) ;
    }
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-45.0 {
    Navigate class based association -- multiple, static
} -setup {
    validateutils genMiccaFile codegen45 {
        domain codegen45 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -static -associator A X 1..*--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance y foreachRelated xs R1>%
                    printf("y.value = %d\n", %<instance y attr value>%) ;
                %<end>%
            }
        }
        population codegen45 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen45.c
    testConditions\
        {[validateutils matchLines codegen45.c {
            struct A *t__T1 = xs->R1__FORW ; // R1
            struct Y *t__T2 = t__T1->R1.forward ; // R1
            struct Y *y ;
            y = t__T2 ;
        }]}
} -result {1}
----
endif::showtests[]

For references stored in linked lists,
we again have generate code to iterate across the links.

[source,tcl]
----
<<TraverseRelChain: linked reference>>=
set itervar [CreateTempSymbol Ctype "MRT_LinkRef *"\
    Type "ReferenceLink" Class $targetclass]
lassign $comp termcomp linkcomp
append result [IndentToBlock\
    "for (MRT_LinkRef *$itervar =\
        mrtLinkRefBegin(&$startref->$termcomp) ;\
        $itervar != mrtLinkRefEnd(&$startref->$termcomp) ;)\
        \{\n"] ; # <1>
PushBlock
lassign [CreateTempRefSymbol $targetclass] targettype targetref
append result [IndentToBlock [string cat\
    "$targettype$targetref =\
        ($targettype)((uintptr_t)$itervar -\
        offsetof(struct $targetclass, $linkcomp)) ;\n"\
    "$itervar = $itervar->next ;\n"\
]] ; # <2>
----
<1> Again, there is no special empty case for linked lists.
If there are no related instances linked together,
the linked list iterator will be at the end and the loop will not
be entered.
<2> Two complications arise using linked list.
Since a class instance may be threaded onto several linked lists,
we must do some pointer arithmetic to transform the pointer value
stored in the linked list into a pointer to the beginning of the
instance. So, we must subtract off the offset to the link pointers
in the instance.
Secondly, we advance the linked list iterator at the beginning of the
loop rather than at the end.
This is to make sure that any user supplied code that might unlink
the instance from the linked list does not invalidate our iterator.

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-38.0 {
    Navigate simple association -- multiple dynamic
} -setup {
    validateutils genMiccaFile codegen38 {
        domain codegen38 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 20
            }
            association R2 -dynamic Z 0..*--1 Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance z foreachRelated xs R1 ~R2>%
                    printf("z.value = %d\n", %<instance z attr value>%) ;
                %<end>%
            }
        }
        population codegen38 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
                instance z2 R2 y1
                instance z3 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen38.c
    testConditions\
        {[validateutils matchLines codegen38.c {
    struct Y *t__T1 = xs->R1 ; // R1
    for (MRT_LinkRef *t__T2 = mrtLinkRefBegin(&t__T1->R2__BACK) ; t__T2 != mrtLinkRefEnd(&t__T1->R2__BACK) ;) {
        struct Z *t__T3 = (struct Z *)((uintptr_t)t__T2 - offsetof(struct Z, R2__BLINKS)) ;
        t__T2 = t__T2->next ;
        struct Z *z ;
        z = t__T3 ;
        printf("z.value = %d\n", z->value) ;
    }
        }]}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-46.0 {
    Navigate class based association -- multiple, dynamic
} -setup {
    validateutils genMiccaFile codegen46 {
        domain codegen46 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -associator A X 1..*--1..* Y

            domainop void findys {} {
                %<X findByName x1 xs>%
                %<instance y foreachRelated xs R1>%
                    printf("y.value = %d\n", %<instance y attr value>%) ;
                %<end>%
            }
        }
        population codegen46 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen46.c
    testConditions\
        {[validateutils matchLines codegen46.c {
    for (MRT_LinkRef *t__T1 = mrtLinkRefBegin(&xs->R1__FORW) ; t__T1 != mrtLinkRefEnd(&xs->R1__FORW) ;) {
        struct A *t__T2 = (struct A *)((uintptr_t)t__T1 - offsetof(struct A, R1__FLINKS)) ;
        t__T1 = t__T1->next ;
        struct Y *t__T3 = t__T2->R1.forward ; // R1
        struct Y *y ;
        y = t__T3 ;
        printf("y.value = %d\n", y->value) ;
    }
        }]}
} -result {1}
----
endif::showtests[]

References from subclasses to superclasses are just a single pointer
value that is unconditional.

[source,tcl]
----
<<TraverseRelChain: reference to superclass>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
append result [IndentToBlock\
    "$targettype$targetref = $startref->$comp ; // $relspec \n"\
]
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-39.0 {
    Navigate reference generalization from subclass to superclass
} -setup {
    validateutils genMiccaFile codegen39 {
        domain codegen39 {
            class S {
                attribute value int -default 20
            }
            class Y {}
            class Z {}
            generalization R1 -reference S Y Z

            domainop void findss {} {
                %<Y findByName y1 ys>%
                %<instance s foreachRelated ys R1>%
                    printf("s.value = %d\n", %<instance s attr value>%) ;
                %<end>%
            }
        }
        population codegen39 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen39.c
    testConditions\
        {[validateutils matchLines codegen39.c {
            struct S *t__T1 = ys->R1 ; // R1
            struct S *s ;
            s = t__T1 ;
        }]}
} -result {1}
----
endif::showtests[]

References from a superclass to a subclass are also just a single
pointer value.
However, the traversal is conditional.
When specifying a traversal to a subclass, the subclass class name
must be given and the generated code has to insure that we are currently
related to an instance of the designated subclass.

[source,tcl]
----
<<TraverseRelChain: reference to subclass>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
set classDesc [GetClassDescriptor $domain $targetclass]
set refcode "$targettype$targetref = $startref->$comp ; // $relspec\n"
append refcode "if ($targetref->base__INST.classDesc == &$classDesc) \{\n"
append result [IndentToBlock $refcode]
PushBlock
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-41.0 {
    Navigate reference generalization from superclass to subclass
} -setup {
    validateutils genMiccaFile codegen41 {
        domain codegen41 {
            class S {}
            class Y {
                attribute value int -default 20
            }
            class Z {}
            generalization R1 -reference S Y Z

            domainop void findss {} {
                %<S findByName s1 ss>%
                %<instance y foreachRelated ss {~R1 Y}>%
                    printf("y.value = %d\n", %<instance y attr value>%) ;
                %<end>%
            }
        }
        population codegen41 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen41.c
    testConditions\
        {[validateutils matchLines codegen41.c {
            struct Y *t__T1 = ss->R1 ; // ~R1 Y
            if (t__T1->base__INST.classDesc == &codegen41__CLASSES[1]) {
                struct Y *y ;
                y = t__T1 ;
                printf("y.value = %d\n", y->value) ;
            }
        }]}
} -result {1}
----
endif::showtests[]

When a generalization is stored in a union,
then pointer arithmetic alone is sufficient to _up cast_ to the
supeclass instance.

[source,tcl]
----
<<TraverseRelChain: union subclass to superclass reference>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
append result [IndentToBlock\
    "$targettype$targetref = ($targettype)((uintptr_t)$startref -\
    offsetof(struct $targetclass, $comp.$startClass)) ;\
    // $relspec \n"]
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-40.0 {
    Navigate union generalization from subclass to superclass
} -setup {
    validateutils genMiccaFile codegen40 {
        domain codegen40 {
            class S {
                attribute value int -default 20
            }
            class Y {}
            class Z {}
            generalization R1 -union S Y Z

            domainop void findss {} {
                %<Y findByName y1 ys>%
                %<instance s foreachRelated ys R1>%
                    printf("s.value = %d\n", %<instance s attr value>%) ;
                %<end>%
            }
        }
        population codegen40 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen40.c
    testConditions\
        {[validateutils matchLines codegen40.c {
    struct S *t__T1 = (struct S *)((uintptr_t)ys - offsetof(struct S, R1.Y)) ; // R1
    struct S *s ;
    s = t__T1 ;
        }]}
} -result {1}
----
endif::showtests[]

Going from the superclass to the subclass with a union storage arrangement
has the same complication as when pointers are used, namely we must
make sure that the instance is currently related to an instance of the
given target subclass.
The addressing expression is much easier as the compiler will
do the address arithmetic for us.

[source,tcl]
----
<<TraverseRelChain: union superclass to subclass reference>>=
lassign [CreateTempRefSymbol $targetclass] targettype targetref
set classDesc [GetClassDescriptor $domain $targetclass]
set refcode "$targettype$targetref = &$startref->$comp.$targetclass ;\
        // $relspec\n"
append refcode\
    "if ($targetref->base__INST.classDesc == &$classDesc) \{\n"
append result [IndentToBlock $refcode]
PushBlock
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-42.0 {
    Navigate union generalization from superclass to subclass
} -setup {
    validateutils genMiccaFile codegen42 {
        domain codegen42 {
            class S {}
            class Y {
                attribute value int -default 20
            }
            class Z {}
            generalization R1 -union S Y Z

            domainop void findss {} {
                %<S findByName s1 ss>%
                %<instance y foreachRelated ss {~R1 Y}>%
                    printf("y.value = %d\n", %<instance y attr value>%) ;
                %<end>%
            }
        }
        population codegen42 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen42.c
    testConditions\
        {[validateutils matchLines codegen42.c {
            struct Y *t__T1 = &ss->R1.Y ; // ~R1 Y
            if (t__T1->base__INST.classDesc == &codegen42__CLASSES[1]) {
                struct Y *y ;
                y = t__T1 ;
                printf("y.value = %d\n", y->value) ;
            }
        }]}
} -result {1}
----
endif::showtests[]

To simplify the code of `TraverseRelChain`,
we use the `LookUpRelationship` procedure to summarize the
relationship characteristics that are needed to navigate the relationship.

The 
<<relationship-subsystem,Relationship Subsystem>>
of the platform model discusses the various arrangements for
reference pointer storage and how for class based associations
traversal is decomposed into two steps.
The structure of `LookUpRelationship` follows directly from the
platform model for relationships, searching for associations and
generalizations and the various types of each.

[source,tcl]
----
<<generation support commands>>=
proc LookUpRelationship {startclass relspec} {
    variable domain

    lassign $relspec relname destclass
    if {[string index $relname 0] eq "~"} {
        set dir back
        set relname [string range $relname 1 end]
    } else {
        set dir forw
    }

    set relRef [Relationship findById Domain $domain Name $relname]
    set assocRef [findRelated $relRef {~R30 Association}]
    if {[isNotEmptyRef $assocRef]} {
        <<LookUpRelationship: associations>>
    } else {
        <<LookUpRelationship: generalizations>>
    }
}
----

Association type relationships are partitioned into either simple
associations or class based associations.
We follow that division in the code below.

[source,tcl]
----
<<LookUpRelationship: associations>>=
set isstatic [readAttribute $assocRef IsStatic]
set sassocRef [findRelated $assocRef {~R31 SimpleAssociation}]
if {[isNotEmptyRef $sassocRef]} {
    <<LookUpRelationship: simple associations>>
} else {
    <<LookUpRelationship: class based associations>>
}
----

[source,tcl]
----
<<LookUpRelationship: simple associations>>=
if {$destclass ne {}} {
    error "simple association, $relname, cannot have a\
        destination specifier"
}
assignAttribute [findRelated $sassocRef ~R32]\
    {Class srcclass} {Conditionality srccond} {Multiplicity srcmult}
assignAttribute [findRelated $sassocRef ~R33] {Class trgclass}
if {$dir eq "forw"} {
    if {$startclass ne $srcclass} {
        error "relationship, $relname, is from\
            $srcclass to $trgclass: got, $startclass,\
            as the traversal start"
    }
    return [list $srcclass $trgclass reference false $relname]
} else {
    if {$startclass ne $trgclass} {
        error "relationship, ~$relname, is from\
            $trgclass to $srcclass: got, $startclass,\
            as the traversal start"
    }
    if {!$srcmult} {
        set type reference
        set comp ${relname}__BACK
    } else {
        if {$isstatic} {
            set type array
            set comp ${relname}__BACK
        } else {
            set type linked
            set comp [list ${relname}__BACK ${relname}__BLINKS]
        }
    }
    return [list $trgclass $srcclass $type $srccond $comp]
}
----

[source,tcl]
----
<<LookUpRelationship: class based associations>>=
set cassocRef [findRelated $assocRef {~R31 ClassBasedAssociation}]
assignAttribute [findRelated $cassocRef ~R34]\
    {Class srcclass} {Conditionality srccond} {Multiplicity srcmult}
assignAttribute [findRelated $cassocRef ~R35]\
    {Class trgclass} {Conditionality trgcond} {Multiplicity trgmult}
assignAttribute [findRelated $cassocRef ~R42]\
    {Class assocclass}
if {!$trgmult} {
    set srctype reference
    set srccomp ${relname}__FORW
} else {
    if {$isstatic} {
        set srctype array
        set srccomp ${relname}__FORW
    } else {
        set srctype linked
        set srccomp [list ${relname}__FORW ${relname}__FLINKS]
    }
}
if {!$srcmult} {
    set trgtype reference
    set trgcomp ${relname}__BACK
} else {
    if {$isstatic} {
        set trgtype array
        set trgcomp ${relname}__BACK
    } else {
        set trgtype linked
        set trgcomp [list ${relname}__BACK ${relname}__BLINKS]
    }
}
if {$destclass eq {}} {
    if {$dir eq "forw"} {
        if {$startclass eq $srcclass} {
            return [list\
                $srcclass $assocclass $srctype $trgcond $srccomp\
                $assocclass $trgclass reference false ${relname}.forward\
            ]
        } elseif {$startclass eq $assocclass} {
            return [list\
                $assocclass $trgclass reference false ${relname}.forward\
            ]
        } else {
            error "relationship, $relname, is from class based from\
                $srcclass to $trgclass via $assocclass: got, $startclass,\
                as the traversal start"
        }
    } else {
        if {$startclass eq $trgclass} {
            return [list\
                $trgclass $assocclass $trgtype $srccond $trgcomp\
                $assocclass $srcclass reference false ${relname}.backward\
            ]
        } elseif {$startclass eq $assocclass} {
            return [list\
                $assocclass $srcclass reference false ${relname}.backward\
            ]
        } else {
            error "relationship, ~$relname, is from class based from\
                $trgclass to $srcclass via $assocclass: got, $startclass,\
                as the traversal start"
        }
    }
} else {
    if {$destclass eq $assocclass} {
        if {$dir eq "forw"} {
            return [list $srcclass $assocclass $srctype $trgcond $srccomp]
        } else {
            return [list $trgclass $assocclass $trgtype $srccond $trgcomp]
        }
    } elseif {$destclass eq $trgclass} {
        if {$dir eq "forw"} {
            return [list $assocclass $trgclass reference false ${relname}.forward]
        } else {
            error "navigating forward from $assocclass arrives at\
                $trgclass: got $destclass"
        }
    } elseif {$destclass eq $srcclass} {
        if {$dir eq "back"} {
            return [list $assocclass $srcclass reference false ${relname}.backward]
        } else {
            error "navigating backward from $assocclass arrives at\
                $srcclass: got $destclass"
        }
    } else {
        error "$destclass does not participate in $relname"
    }
}
----

Generalizations are divided into those implemented using references
and those using a union.

[source,tcl]
----
<<LookUpRelationship: generalizations>>=
set genRef [findRelated $relRef {~R30 Generalization}]
set refGenRef [findRelated $genRef {~R43 ReferenceGeneralization}]
if {[isNotEmptyRef $refGenRef]} {
    set super [readAttribute [findRelated $refGenRef ~R36] Class]
    set subs [findRelated $refGenRef ~R37]
    set subnames [relation list [deRef $subs] Class]
    set isRefGen true
} else {
    set uGenRef [findRelated $genRef {~R43 UnionGeneralization}]
    set super [readAttribute [findRelated $uGenRef ~R44] Class]
    set subs [findRelated $uGenRef ~R45]
    set subnames [relation list [deRef $subs] Class]
    set isRefGen false
}
----

[source,tcl]
----
<<LookUpRelationship: generalizations>>=
if {$dir eq "forw"} {
    if {$destclass ne {}} {
        error "generalization, $relname, cannot have a\
            destination specifier when traversing to the superclass"
    } elseif {$startclass ni $subnames} {
        error "relationship, $relname, is from\
            \"[join $subnames {, }]\", to $super,\
            got, $startclass, as the traversal start"
    }
    set reftype [expr {$isRefGen ? "reftosuper" : "uniontosuper"}]
    return [list $startclass $super $reftype false $relname]
} else {
    if {$destclass eq {}} {
        error "generalization, ~$relname, must specify a\
            destination when traversing to a subclass"
    } elseif {$startclass ne $super} {
        error "relationship, ~$relname, is from\
            $super to \"[join $subnames {, }]\", got, $startclass,\
            as the traversal start"
    } elseif {$destclass ni $subnames} {
        error "generalization, ~$relname, cannot traverse to\
            class, $destclass: should be one of:\
            \"[join $subnames {, }]\""
    }
    set reftype [expr {$isRefGen ? "reftosub" : "uniontosub"}]
    return [list $super $destclass $reftype false $relname]
}
----

==== Iterating Across Selected Related Instances

*****
`%<instance` _instvar_ `foreachRelatedWhere` _clause start rel1 ?rel2? ..._ `>%` +
_Loop Body_ +
`%<end>%`

instvar::
    The name of a ``C'' variable that holds a reference to a class instance.
clause::
    A ``C'' expression that evaluates to a value that can be interpreted
    as a boolean.
start::
    The name of a ``C'' variable containing the instance reference where
    the relationship navigation will begin.
relN::
    A set of relationship navigation specifications.

The `foreachRelatedWhere` subccommand generates ``C'' statements
to iterate across the set of instances obtained by navigating
the relationship chain which starts at the _start_ instance
and is given by the _relN_ arguments.
A reference to each instance found in the navigation is assigned to
the _instvar_ variable and then `clause` is executed.
If the result of executing `clause` is non-zero,
then _Loop Body_ is executed.
Otherwise, _Loop Body_ is skipped.
Statements in the _Loop Body_ terminate at the `%<end>%` macro command.
The scope of the _instvar_ variable is confined to the statements in
the _Loop Body_ unless it was declared previously.
The relationship traversal is given as a set of relationship navigation
specifications of the same form as for the `foreachRelated` subcommand.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceForeachRelatedWhere {instref where startref args} {
    set startblock [GetBlock]
    set result [IndentToBlock\
        [linecomment "instance $instref foreachRelatedWhere [list $where]\
                $startref [list $args]"]\
    ]

    lassign [TraverseRelChain $startref $args] chaincode targetclass targetref
    append result $chaincode
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $targetclass $instref]\
        "$instref = $targetref ;\n"\
        "if ($where) \{\n"\
    ]]
    PushBlock

    PushContext InstanceForeachRelatedWhere $startblock

    return $result
}
----

==== Finding a Single Related Instance

*****
`%<instance` _instvar_ `findOneRelated` _start rel1 ?rel2? ..._ `>%`

instvar::
    The name of a ``C'' variable that will hold the related instance.
start::
    The name of a ``C'' variable containing the instance reference where
    the relationship navigation will begin.
relN::
    A set of relationship navigation specifications.

The `findOneRelated` subccommand generates ``C'' statements
obtain a single instance reference by navigating
the relationship chain which starts at the _start_ instance
and is given by the _relN_ arguments.
A reference to the related instance is assigned into
the _instvar_ variable.
The _instvar_ variable is declared if necessary.
If the traversal of the relationship chain would yield more than a
single instance,
then an error is thrown.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceFindOneRelated {instref startref args} {
    variable domain

    set startsym [CheckInstRefSymbol $startref]
    set startClass [dict get $startsym Class]
    set heading [IndentToBlock\
        [linecomment "instance $instref findOneRelated $startref [list $args]"]\
    ]
    set startlevel [GetBlock]
    set isCond false

    foreach relspec $args {
        set relinfo [LookUpRelationship $startClass $relspec]
        while {[llength $relinfo] != 0} {
            set relinfo [lassign $relinfo sourceclass targetclass reftype cond\
                comp]
            switch -exact -- $reftype {
                reference {
                    if {$startClass ne $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            $sourceclass to $targetclass, got, $startClass,\
                            as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass]\
                        targettype targetref
                    set refcode "$targettype$targetref = $startref->$comp ;\
                    // $relspec \n"
                    if {$cond} {
                        set isCond true
                        append refcode "if ($targetref != NULL) \{\n"
                        append result [IndentToBlock $refcode]
                        PushBlock
                    } else {
                        append result [IndentToBlock $refcode]
                    }
                }
                array -
                linked {
                    error "relationship, [lindex $relspec 0], is\
                        multiple from $sourceclass to $targetclass"
                }
                reftosuper {
                    if {$startClass ni $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            \"[join $sourceclass {, }]\", to $targetclass,\
                            got, $startClass, as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref = $startref->$comp ;\
                        // $relspec \n"]
                }
                reftosub {
                    set isCond true
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    set classDesc [GetClassDescriptor $domain $targetclass]
                    set refcode "$targettype$targetref = $startref->$comp ;\
                            // $relspec\n"
                    append refcode\
                        "if ($targetref->base__INST.classDesc == &$classDesc) \{\n"
                    append result [IndentToBlock $refcode]
                    PushBlock
                }
                uniontosuper {
                    if {$startClass ni $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            \"[join $sourceclass {, }]\", to $targetclass,\
                            got, $startClass, as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref =\
                        ($targettype)((uintptr_t)$startref -\
                        offsetof(struct $targetclass, $comp.$startClass)) ;\
                        // $relspec \n"]
                }
                uniontosub {
                    set isCond true
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    set classDesc [GetClassDescriptor $domain $targetclass]
                    set refcode\
                        "$targettype$targetref = &$startref->$comp.$targetclass ;\
                            // $relspec\n"
                    append refcode\
                        "if ($targetref->base__INST.classDesc == &$classDesc) \{\n"
                    append result [IndentToBlock $refcode]
                    PushBlock
                }
            }
            set startClass $targetclass
            set startref $targetref
        }
    }
    append result [IndentToBlock "$instref = $targetref ;\n"]

    for {set i [expr {[GetBlock] - $startlevel}]} {$i > 0} {incr i -1} {
        PopBlock
        append result [IndentToBlock "\}\n"]
    }
    append heading [IndentToBlock [CreateInstRefSymbol $targetclass $instref]]
    if {$isCond} {
        append heading [IndentToBlock "$instref = NULL ;\n"]
    }

    return [string cat $heading $result]
}
----

==== Signaling an Event

*****
`%<instance` _instvar_ `signal` _event_ _?name1 value1 name2 value2 ...?_ `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.
event::
    The name of an event in the state model for the class to which
    the instance belongs.
nameN / valueN::
    A set of event parameter name / event parameter value pairs for the
    parameters that match the parameter signature of _event_.

The `signal` subccommand generates ``C'' statements
to arrange for _event_ to be signaled to the instance referenced by the
_instvar_ variable.
Any given name / value pairs are passed as the parameters of the event.
All event parameters must be supplied and parameter names must match
the event signature of the _event_ being signaled.
If _event_ is not an event for the state model of _instvar_ then
an error is thrown.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSignal {instref event args} {
    lassign [InstanceNewECB $instref $event $args] ecbvar ecbcode
    return [IndentToBlock [string cat\
        [linecomment "instance $instref signal $event [list $args]"]\
        $ecbcode\
        "mrt_PostEvent($ecbvar) ;\n"\
    ]]
}
----

Since we will be signaling events in a number of different contexts,
we have factored out the code to generate the ``C'' required to
obtain an ECB from the run-time and fill in any event parameters.

[source,tcl]
----
<<generation support commands>>=
proc InstanceNewECB {instref event arglist} {
    variable domain

    if {[llength $arglist] % 2 != 0} {
        error "event parameters must be given as name / value pairs, got:\
            \"$arglist\""
    }
    set target [CheckInstRefSymbol $instref]

    dict with target {
        set eventRef [Event findById Domain $domain Model $Class Event $event]
        if {[isEmptyRef $eventRef]} {
            error "event, $event, is not a known event for class, $Class"
        }
        set eventNum [readAttribute $eventRef Number]

        set psig [findRelated $eventRef R69]
        set params [FindParamsFromSig $psig]
        set required [relation list $params Name -ascending Position]
        set supplied [dict keys $arglist]
        ValidateParams $event $supplied $required

        set result {}
        set sourceinst [expr {[LookUpSymbol self] eq {} ? "NULL" : "self"}]
        set ecbvar [CreateTempSymbol Ctype {MRT_ecb *} Type ECB Class $Class]
        append result "MRT_ecb *$ecbvar =\
                mrt_NewEvent($eventNum, $instref, $sourceinst) ; // $event\n"
        if {[llength $required] != 0} {
            set eparamsname ${domain}_${Class}_${event}__EPARAMS
            set ptrparams [CreateTempSymbol Ctype "struct *$eparamsname"\
                Type EventParams Class $Class]
            append result\
                "struct $eparamsname *const $ptrparams =\n"\
                "    (struct $eparamsname *)$ecbvar->eventParameters ;\n"
            relation foreach param $params -ascending Position {
                relation assign $param {Name pname} {DataType datatype}
                if {![dict exists $arglist $pname]} {
                    error "required event parameter, $pname,\
                            was not supplied a value"
                }
                append result [GenValueAssignment $domain $ptrparams->$pname\
                        [dict get $arglist $pname] $datatype]
            }
        }
    }
    return [list $ecbvar $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-50.0 {
    Signal an event with parameters
} -setup {
    validateutils genMiccaFile codegen50 {
        domain codegen50 {
            class X {
                attribute temp int -default 20
                attribute name {char[4]}

                statemodel {
                    state Idle {} {
                    }
                    transition Idle - E1 -> Running

                    state Running {incr int newname {char[4]}} {
                        %<my attr temp>% += incr ;
                        strcpy(%<my attr name>%, newname) ;
                    }
                    transition Running - E1 -> Running ;
                }
            }

            domainop void startx1 {} {
                %<X findByName x1 xref>%
                %<instance xref signal E1 incr 30 newname {"bar"}>%
            }
        }
        population codegen50 {
            class X {
                instance x1 name {"foo"}
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen50.c
    validateutils matchLines codegen50.c {
        // instance xref signal E1 {incr 30 newname {"bar"}}
        MRT_ecb *t__T1 = mrt_NewEvent(0, xref, NULL) ; // E1
        struct codegen50_X_E1__EPARAMS *const t__T2 =
            (struct codegen50_X_E1__EPARAMS *)t__T1->eventParameters ;
            t__T2->incr = 30 ;
            strncpy(t__T2->newname, "bar", 3) ;
            t__T2->newname[3] = '\0' ;
        mrt_PostEvent(t__T1) ;
    }
} -result {1}
----
endif::showtests[]

==== Delayed Signaling of an Event

*****
`%<instance` _instvar_ `delaysignal` _time_ _event_
_?name1 value1 name2 value2 ...?_ `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.
time::
    The minimum number of milliseconds that are to elapse before
    the event is signaled.
event::
    The name of an event in the state model for the class to which
    the instance belongs.
nameN / valueN::
    A set of event parameter name / event parameter value pairs for the
    parameters that match the parameter signature of _event_.

The `delaysignal` subccommand generates ``C'' statements
to arrange for _event_ to be signaled to the instance referenced by the
_instvar_ variable after _time_ number of milliseconds has elapsed.
The value of _time_ may be zero, in which case the event is signaled
immediately.
Any given name / value pairs are passed as the parameters of the event.
All event parameters must be supplied and parameter names must match
the event signature of the _event_ being signaled.
If _event_ is not an event for the state model of _instvar_ then
an error is thrown.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceDelaySignal {instref time event args} {
    lassign [InstanceNewECB $instref $event $args] ecbvar ecbcode
    return [IndentToBlock [string cat\
        [linecomment "instance $instref delaysignal $time $event [list $args]"]\
        $ecbcode\
        "mrt_PostDelayedEvent($ecbvar, $time) ;\n"\
    ]]
}
----

==== Cancel a Delayed Signal

*****
`%<instance` _instvar_ `canceldelayed` _event_ _?sourceinst?_ `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.
event::
    The name of an event in the state model for the class to which
    the instance belongs.
sourceinst::
    The name of a variable whose value is a reference to the
    instance which originally signaled the delayed event.

The `canceldelay` subccommand generates ``C'' statements
to arrange the delayed evetn, _event_, not be delivered to the
instance referenced by _instvar_.
If the delayed event was signaled from outside of a state activity,
then the _sourceinst_ argument is omitted.
Otherwise, _sourceinst_ is the name of a variable containing a reference
to the instance that signaled the event.
After it is canceled, _event_ will not be dispatched.
It is not an error to cancel an event that does not exist or has
already been dispatched.
Only events that were signaled as delayed events may be canceled.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceCancelSignal {instref event {sourceref {}}} {
    variable domain

    append result [linecomment "instance $instref canceldelayed $event\
        [list $sourceref]"]
    set target [CheckInstRefSymbol $instref]
    set eventNum [FindEventNumber [dict get $target Class] $event]
    if {$sourceref ne {}} {
        CheckInstRefSymbol $sourceref
        set sourceinst $sourceref
    } else {
        set sourceinst NULL
    }
    append result\
        "mrt_CancelDelayedEvent($eventNum, $instref, $sourceinst) ;\n"
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc FindEventNumber {class event} {
    variable domain
    set eventRef [Event findById Domain $domain Model $class Event $event]
    if {[isEmptyRef $eventRef]} {
        error "event, $event, is not a known event for class, $class"
    }
    return [readAttribute $eventRef Number]
}
----

==== Time Remaining for a Delayed Event

*****
`%<instance` _instvar_ `delayremaining` _event_ _?sourceinst?_ `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.
event::
    The name of an event in the state model for the class to which
    the instance belongs.
sourceinst::
    The name of a variable whose value is a reference to the
    instance which originally signaled the delayed event.

The `delayremaining` subccommand generates a ``C'' expression
containing the number of milliseconds that remain before _event_ is
signaled to the instance referenced by _instvar_.
If the delayed event was signaled from outside of a state activity,
then the _sourceinst_ argument is omitted.
Otherwise, _sourceinst_ is the name of a variable containing a reference
to the instance that signaled the event.
A return value of zero implies that the event has already been dispatched
or does not exist.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceRemainingTime {instref event {sourceref {}}} {
    variable domain

    set target [CheckInstRefSymbol $instref]
    set eventNum [FindEventNumber [dict get $target Class] $event]
    if {$sourceref ne {}} {
        CheckInstRefSymbol $sourceref
        set sourceinst $sourceref
    } else {
        set sourceinst NULL
    }
    return "mrt_RemainingDelayTime($eventNum, $instref, $sourceinst)"
}
----

==== Obtaining an Instance Identifier

It is often useful for external operation to be given a token
that can be used to identify an instance of a class.
Directly passing instance reference pointers outside of a domain
is *strongly discouraged*.
Since class instances are stored in an array,
the index into the array provides a convenient identifier.

*****
`%<instance` _instvar_ `instid` `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.

The `instvar` subccommand generates a ``C'' expression
for an identifier which corresponds to the instance reference of _instvar_.
The identifier values range from 0 to the number of instance of
the class of _instvar_ minus one.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceRefToId {instref} {
    CheckInstRefSymbol $instref
    return "mrt_InstanceIndex($instref)"
}
----

=== Instance Set Commands

The run-time code provides functions for instance sets and
so we also provide embedded macro commands to access the instance set
functions.

All instance set operations are accessed via the `instset` command

==== Iterating Over an Instance Set

*****
`%<instset` _instsetvar_ `foreachSelected` _instvar_ `>%` +
_Loop Body_ +
`%<end>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.
instvar::
    The name of a ``C'' variable into which a reference to a class
    instance is assigned.

The `foreachSelected` subcommand generates ``C'' statements to
iterate over the instances contain in the variable named, _instsetvar_.
For each instance in the set,
_instvar_ is assigned a reference to it and _Loop Body_ is executed.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetForeachSelected {set inst} {
    set setsym [CheckInstSetSymbol $set]

    set startlevel [GetBlock]
    set iter [CreateTempSymbol Ctype MRT_InstSetIterator Type SetIterator\
            Class [dict get $setsym Class]]
    append result [IndentToBlock [string cat\
        "MRT_InstSetIterator $iter ;\n"\
        "for (mrt_InstSetIterBegin(&$set, &$iter) ;\
        mrt_InstSetIterMore(&$iter) ; mrt_InstSetIterNext(&$iter)) \{\n"\
    ]]
    PushBlock

    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol [dict get $setsym Class] $inst]\
        "$inst = mrt_InstSetIterGet(&$iter) ;\n"\
    ]]

    PushContext InstanceSetForeachSelected $startlevel

    return $result
}
----

==== Testing for an Empty Set

*****
`%<instset` _instsetvar_ `empty>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.

The `empty` subcommand generates a ``C'' expression to test whether
the instance set contained in the _instsetvar_ variable contains
zero elements.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetEmpty {set} {
    CheckInstSetSymbol $set
    return "mrt_InstSetEmpty(&$set)"
}
----

==== Testing for an Non-Empty Set

*****
`%<instset` _instsetvar_ `notempty>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.

The `notempty` subcommand generates a ``C'' expression to test whether
the instance set contained in the _instsetvar_ variable contains
at least one element.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetNotEmpty {set} {
    return (![InstanceSetEmpty $set])
}
----

==== Number of Instances in a Set

*****
`%<instset` _instsetvar_ `cardinality>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.

The `cardinality` subcommand generates a ``C'' expression containing the number
instances in the instance set contained in the _instsetvar_ variable.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetCardinality {set} {
    CheckInstSetSymbol $set
    return "mrt_InstSetCardinality(&$set)"
}
----

==== Instance Set Equality

*****
`%<instset` _instsetvar_ `equal` _instsetvar2_ `>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.
instsetvar2::
    The name of a ``C'' variable which holds an instance set.

The `equal` subcommand generates a ``C'' expression that evaluates
to non-zero if the instance set held in _instsetvar_ is equal to the
instance set held in _instsetvar2_.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetEqual {set1 set2} {
    set sym1 [CheckInstSetSymbol $set1]
    CheckInstSetSymbol $set2 Class [dict get $sym1 Class]
    return "mrt_InstSetEqual(&$set1, &$set2)"
}
----

==== Instance Set Inequality

*****
`%<instset` _instsetvar_ `notequal` _instsetvar2_ `>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.
instsetvar2::
    The name of a ``C'' variable which holds an instance set.

The `notequal` subcommand generates a ``C'' expression that evaluates
to non-zero if the instance set held in _instsetvar_ is *not* equal to the
instance set held in _instsetvar2_.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetNotEqual {set1 set2} {
    return (![InstanceSetEqual $set1 $set2])
}
----

==== Adding to an Instance Set

*****
`%<instset` _instsetvar_ `add` _instref_ `>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.
instref::
    The name of a ``C'' variable which holds an instance reference.

The `add` subcommand generates a ``C'' statement that
adds the instance held in the _instref_ variable to the instance
set held in the _instservar_ variable.
It is not an error if _instref_ is already contained in _instsetvar_.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetAdd {set inst} {
    set setsym [CheckInstSetSymbol $set]
    CheckInstRefSymbol $inst Class [dict get $setsym Class]
    return [IndentToBlock [string cat\
        [linecomment "instset $set add $inst"]\
        "mrt_InstSetAddInstance(&$set, $inst) ;\n"\
    ]]
}
----

==== Removing from an Instance Set

*****
`%<instset` _instsetvar_ `remove` _instref_ `>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.
instref::
    The name of a ``C'' variable which holds an instance reference.

The `remove` subcommand generates a ``C'' statement that
removes the instance held in the _instref_ variable to the instance
set held in the _instservar_ variable.
It is not an error if _instref_ is not present in _instsetvar_.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetRemove {set inst} {
    set setsym [CheckInstSetSymbol $set]
    CheckInstRefSymbol $inst Class [dict get $setsym Class]
    return [IndentToBlock [string cat\
        [linecomment "instset $set remove $inst"]\
        "mrt_InstSetRemoveInstance(&$set, $inst) ;\n"\
    ]]
}
----

==== Instance Set Membership

*****
`%<instset` _instsetvar_ `contains` _instsetvar2_ `>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.
instref::
    The name of a ``C'' variable which holds an instance reference.

The `contains` subcommand generates a ``C'' expression that evaluates
to non-zero if the instance held in _instvar_ is a member of the
instance set held in _instsetvar_.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetContains {set inst} {
    set setsym [CheckInstSetSymbol $set]
    CheckInstRefSymbol $inst Class [dict get $setsym Class]
    return "mrt_InstSetMember(&$set, $inst)"
}
----

==== Selecting Into an Instance Set

*****
`%<instset` _instsetvar_ `selectRelated` _start rel1 ?rel2? ..._ `>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.
start::
    The name of a ``C'' variable containing the instance reference where
    the relationship navigation will begin.
relN::
    A set of relationship navigation specifications.

The `selectRelated` subccommand generates ``C'' statements
to iterate across the set of instances obtained by navigating
the relationship chain which starts at the _start_ instance
and is given by the _relN_ arguments.
Each instance found in the navigation is added to the instance set
contained in the _instsetvar_ variable.
The _instsetvar_ variable is declared if necessary.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetSelectRelated {set startref args} {
    variable domain

    set startlevel [GetBlock]

    lassign [TraverseRelChain $startref $args] chaincode targetclass targetref
    set targetclassDesc [GetClassDescriptor $domain $targetclass]
    append chaincode\
        [IndentToBlock "mrt_InstSetAddInstance(&$set, $targetref) ;\n"]

    set depth [expr {[GetBlock] - $startlevel}]
    for {set i 0} {$i < $depth} {incr i} {
        PopBlock
        append chaincode [IndentToBlock "\}\n"]
    }

    set result [IndentToBlock [string cat\
        [linecomment "instset $set selectedRelated $startref [list $args]"]\
        [CreateInstSetSymbol $targetclass $set]\
        "mrt_InstSetInitialize(&$set, &$targetclassDesc) ;\n"]]
    append result $chaincode

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-48.0 {
    Generated code file to select related instances
} -setup {
    validateutils genMiccaFile codegen48 {
        domain codegen48 {
            class X {
                attribute color int -default 20
            }
            class Y {
                attribute temp int -default 30
            }
            association R1 Y 1..*--1 X
            class Z {
                attribute pressure int -default 40
            }
            association R2 Z 0..1--1 Y
            domainop void find {} {
                %<X findByName x1 xref>%
                %<instset zset selectRelated xref ~R1 ~R2>%
            }
        }
        population codegen48 {
            class X {
                instance x1
            }
            class Y {
                instance y1 R1 x1 temp 31
                instance y2 R1 x1 temp 32
                instance y3 R1 x1 temp 33
                instance y4 R1 x1 temp 34
            }
            class Z {
                instance z1 R2 y1 pressure 41
                instance z2 R2 y2 pressure 42
                instance z3 R2 y3 pressure 43
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen48.c
    testConditions\
        {[validateutils matchLines codegen48.c {
        struct Y *t__T2 = (struct Y *)((uintptr_t)t__T1 - offsetof(struct Y, R1__BLINKS)) ;
        t__T1 = t__T1->next ;
        struct Z *t__T3 = t__T2->R2__BACK ; // ~R2
        if (t__T3 != NULL) {
            mrt_InstSetAddInstance(&zset, t__T3) ;
        }
        }]}
} -result {1}
----
endif::showtests[]

==== Conditionally Selecting Into an Instance Set

*****
`%<instset` _instsetvar_ `selectRelatedWhere` _instref_ _clause_ _start rel1 ?rel2? ..._ `>%`

instsetvar::
    The name of a ``C'' variable which holds an instance set.
instref::
    The name of a variable into which a reference to a class instance is placed.
clause::
    A ``C'' expression that evaluates to a value that can be interpreted
    as a boolean.
start::
    The name of a ``C'' variable containing the instance reference where
    the relationship navigation will begin.
relN::
    A set of relationship navigation specifications.

The `selectRelatedWhere` subccommand generates ``C'' statements
to iterate across the set of instances obtained by navigating
the relationship chain which starts at the _start_ instance
and is given by the _relN_ arguments.
A reference to each instance found in the navigation is assigned to the
_instvar_ variable and _clause_ is evaluated.
If _clause_ evaluates to non-zero, then
the instance is added to the instance set
contained in the _instsetvar_ variable.
The _instsetvar_ and _instvar_ variables are declared if necessary.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetSelectRelatedWhere {set instref where startref args} {
    variable domain

    set startlevel [GetBlock]

    lassign [TraverseRelChain $startref $args] chaincode targetclass targetref
    append chaincode [IndentToBlock [string cat\
        [CreateInstRefSymbol $targetclass $instref]\
        "$instref = $targetref ;\n"\
        "if ($where) \{\n"\
    ]]
    PushBlock
    append chaincode [IndentToBlock\
        "mrt_InstSetAddInstance(&$set, $instref) ;\n"]

    set depth [expr {[GetBlock] - $startlevel}]
    for {set i 0} {$i < $depth} {incr i} {
        PopBlock
        append chaincode [IndentToBlock "\}\n"]
    }

    set targetclassDesc [GetClassDescriptor $domain $targetclass]
    append result [IndentToBlock [string cat\
        [linecomment "instset $set selectRelatedWhere $instref [list $where]\
                $startref [list $args]"]\
        [CreateInstSetSymbol $targetclass $set]\
        "mrt_InstSetInitialize(&$set, &$targetclassDesc) ;\n"]]
    append result $chaincode

    return $result
}
----

==== Instance Set Union

*****
`%<instset` _resultsetvar_ `union` _instsetvar1_ _instsetvar2_ _?...?_ `>%`

instsetvarN::
    The name of a ``C'' variable which holds an instance set.

The `union` subcommand generates ``C'' statements that
computes the set union of the _instsetvarN_ instance sets placing
the result in _resultsetvar_.
The _instsetvarN_ instance sets must contain instances of the same class.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetUnion {opset set1 set2 args} {
    tailcall InstanceSetOperation union mrt_InstSetUnion $opset $set1 $set2\
            {*}$args
}
----

==== Instance Set Intersection

*****
`%<instset` _resultsetvar_ `intersect` _instsetvar1_ _instsetvar2_ _?...?_ `>%`

instsetvarN::
    The name of a ``C'' variable which holds an instance set.

The `intersect` subcommand generates ``C'' statements that
computes the set intersection of the _instsetvarN_ instance sets placing
the result in _resultsetvar_.
The _instsetvarN_ instance sets must contain instances of the same class.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetIntersect {opset set1 set2 args} {
    tailcall InstanceSetOperation intersect mrt_InstSetIntersect $opset\
            $set1 $set2 {*}$args
}
----

We can factor the basic set operation code generation into a common procedure.

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetOperation {label op opset set1 set2 args} {
    variable domain

    set sym1 [CheckInstSetSymbol $set1]
    set className [dict get $sym1 Class]
    CheckInstSetSymbol $set2 Class $className

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [linecomment "instset $opset $label $set1 [list $args]"]\
        [CreateInstSetSymbol $className $opset]\
        "mrt_InstSetInitialize(&$opset, &$classDesc) ;\n"\
        "$op\(&$set1, &$set2, &$opset\) ;\n"
    foreach set $args {
        CheckInstSetSymbol $set Class $className
        append result "$op\(&$opset, &$set, &$opset\) ;\n"
    }
    return [IndentToBlock $result]
}
----

==== Instance Set Difference

*****
`%<instset` _resultsetvar_ `minus` _instsetvar1_ _instsetvar2_ `>%`

instsetvarN::
    The name of a ``C'' variable which holds an instance set.

The `minus` subcommand generates ``C'' statements that
computes the set difference of the _instsetvar1_ and _instvarset2_
(in that order) placing the result in _resultsetvar_.
The _instsetvarN_ instance sets must contain instances of the same class.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc InstanceSetMinus {diffset set1 set2} {
    variable domain

    set sym1 [CheckInstSetSymbol $set1]
    set className [dict get $sym1 Class]
    set sym2 [CheckInstSetSymbol $set2 Class $className]

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [linecomment "instset $diffset minus $set1 $set2"]\
        [CreateInstSetSymbol $className $diffset]\
        "mrt_InstSetInitialize(&$diffset, &$classDesc) ;\n"\
        "mrt_InstSetMinus(&$set1, &$set2, &$diffset) ;\n"
    return [IndentToBlock $result]
}
----

=== Class Commands

For each class in a domain,
the code generator creates a macro command that has the same name
as the class.
For example,
if a domain contains a class named, *WashingMachine*,
the there will be an embedded macro command named, `WashingMachine`,
which can be invoked as:

*****
`%<WashingMachine` `subcommand` ?_arg1 arg2 ..._? `>%`
*****

where `subcommand` is a class model level operation command.

In this section we describe the embedded macro commands that
are available for each class.

==== Synchronous Instance Creation

*****
`%<` _class_ `create` _instref_ _?attr1 value1 att2 value2 ...?_ `>%`

_class_::
    The name of a domain class for which an instance is synchronously created.
instref::
    The name of a variable into which a reference to the newly created
    class instance is placed.
attrN / valueN::
    A set of attribute name / attribute values which are used to set the
    attribute values of the newly created instance.

The `create` subcommand for a class creates ``C'' statements to
synchronously create a new instance of the class.
A reference to the instance is placed in the variable called, _instref_.
If _instref_ has not been previously declared, it is declared
automatically.
The attributes of the newly created instance are set to the values given
by the _attrN / valueN_ pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the `create` subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
If _class_ has an associated state model,
then the newly created instance is placed in the default initial state
that was defined for the state model.
No state activity is executed since the instance creation is done
synchronously.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassCreate {className instref args} {
    variable domain

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [linecomment "$className create $instref [list $args]"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_CreateInstance(&$classDesc, MRT_StateCode_IG) ;\n"\
        [AssignComponentValues $className $instref $args]

    return [IndentToBlock $result]
}
----


[source,tcl]
----
<<generation support commands>>=
proc AssignComponentValues {className instref suppliedvalues} {
    variable domain
    set result {}

    set popcomps [GetPopComponents $className]
    # puts [relformat $popcomps popcomps]
    relation foreach popcomp $popcomps {
        relation assign $popcomp
        switch -exact -- $Type {
        association {
            if {![dict exists $suppliedvalues $Name]} {
                error "no value supplied for association reference, \"$Name\""
            } else {
                set assocrefvar [dict get $suppliedvalues $Name]
            }
            set refclass [pipe {
                AssociationReference findById Domain $Domain Class $Class\
                        Name $Name |
                findRelated % ~R90 R32 ~R33 |
                readAttribute % Class
            } {} |%]
            CheckInstRefSymbol $assocrefvar Class $refclass

            set relDesc [GetRelationshipDescriptor $Domain $Name]
            append result "mrt_CreateSimpleLinks($relDesc, $instref,\
                    $assocrefvar) ;\n"
        }
        associator {
            if {![dict exists $suppliedvalues $Name]} {
                error "no value supplied for associator reference, \"$Name\""
            } else {
                set atorrefs [dict get $suppliedvalues $Name]
            }
            set atorclass [pipe {
                AssociatorReference findById Domain $Domain Class $Class\
                        Name $Name |
                findRelated % ~R93
            } {} |%]
            set srcclass [pipe {
                findRelated $atorclass R42 ~R34 |
                readAttribute % Class
            } {} |%]
            set trgclass [pipe {
                findRelated $atorclass R42 ~R35 |
                readAttribute % Class
            } {} |%]

            # Reflexive case
            if {$srcclass eq $trgclass} {
                if {[dict exists $atorrefs backward]} {
                    set srcinstref [dict get $atorrefs backward]
                } else {
                    error "for reflexive associator references, expected\
                        \"backward\" reference: got \"$atorrefs\""
                }
                if {[dict exists $atorrefs forward]} {
                    set trginstref [dict get $atorrefs forward]
                } else {
                    error "for reflexive associator references, expected\
                        \"forward\" reference: got \"$atorrefs\""
                }
            } else {
                if {[dict exists $atorrefs $srcclass]} {
                    set srcinstref [dict get $atorrefs $srcclass]
                } else {
                    error "for associator references, expected\
                        \"$srcclass\" reference: got \"$atorrefs\""
                }
                if {[dict exists $atorrefs $trgclass]} {
                    set trginstref [dict get $atorrefs $trgclass]
                } else {
                    error "for associator references, expected\
                        \"$trgclass\" reference: got \"$atorrefs\""
                }
            }
            CheckInstRefSymbol $srcinstref Class $srcclass
            CheckInstRefSymbol $trginstref Class $trgclass

            set relDesc [GetRelationshipDescriptor $Domain $Name]
            append result "mrt_CreateAssociatorLinks($relDesc, $instref,\
                    $srcinstref, $trginstref) ;\n"
        }
        superclass {
            if {![dict exists $suppliedvalues $Name]} {
                error "no value supplied for superclass reference, \"$Name\""
            } else {
                set superrefvar [dict get $suppliedvalues $Name]
            }
            set superref [pipe {
                SuperclassReference findById Domain $Domain Class $Class\
                        Name $Name |
                findRelated % ~R91 {~R47 ReferringSubclass} R37 ~R36
            } {} |%]
            if {[isNotEmptyRef $superref]} {
                CheckInstRefSymbol $superrefvar\
                        Class [readAttribute $superref Class]

                set relDesc [GetRelationshipDescriptor $Domain $Name]
                append result "mrt_CreateSimpleLinks($relDesc, $instref,\
                        $superrefvar) ;\n"
            }
        }
        attribute {
            if {![dict exists $suppliedvalues $Name]} {
                set defvalueref [DefaultValue findById Domain $Domain\
                        Class $Class Attribute $Name]
                if {[isEmptyRef $defvalueref]} {
                    error "attribute, \"$Name\", has no supplied value and\
                        no default value"
                }
                set attrValue [readAttribute $defvalueref Value]
            } else {
                set attrValue [dict get $suppliedvalues $Name]
            }
            set attrref [Attribute findById Domain $Domain Class $Class\
                    Name $Name]
            assignAttribute $attrref {DataType datatype}
            append result [GenValueAssignment $domain $instref->$Name\
                    $attrValue $datatype]
        }
        }
        dict unset suppliedvalues $Name
    }

    if {[dict size $suppliedvalues] != 0} {
        error "class, $Class, has no attribute(s) named,\
            \"[join [dict keys $suppliedvalues] {, }]\""
    }

    return $result
}

proc GetPopComponents {className} {
    variable domain

    set popcomps [PopulatedComponent findWhere\
            {$Domain eq $domain && $Class eq $className}]
    set typedcomps [pipe {
        findRelated $popcomps {~R21 Reference} {~R23 AssociationReference} |
        deRef % |
        relation extend % artup Type string {"association"}
    } {} |%]

    set typedcomps [pipe {
        findRelated $popcomps {~R21 Reference} {~R23 AssociatorReference} |
        deRef % |
        relation extend % artup Type string {"associator"} |
        relation union $typedcomps %
    } {} |%]

    set typedcomps [pipe {
        findRelated $popcomps {~R21 Reference} {~R23 SuperclassReference} |
        deRef % |
        relation extend % artup Type string {"superclass"} |
        relation union $typedcomps %
    } {} |%]

    set typedcomps [pipe {
        findRelated $popcomps {~R21 Attribute} {~R29 IndependentAttribute} |
        deRef % |
        relation extend % artup Type string {"attribute"} |
        relation union $typedcomps %
    } {} |%]
    # puts [relformat $typedcomps typedcomps]

    return $typedcomps
}

proc GetRelationshipDescriptor {domain name} {
    set relnum [pipe {
        Relationship findById Domain $domain Name $name |
        readAttribute ~ Number
    }]
    return &${domain}__RSHIPS\[$relnum\]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-26.0 {
    Generated code file instance creation
} -setup {
    validateutils genMiccaFile codegen26 {
        domain codegen26 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx color 30 temp 22>%
                printf("%d\n", %<instance newx attr color>%) ;
            }
        }
        population codegen26 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen26.c
    testConditions\
        {[validateutils matchLines codegen26.c {
        struct X *newx ;
        newx = mrt_CreateInstance(&codegen26__CLASSES[0], MRT_StateCode_IG) ;
        newx->color = 30 ;
        newx->temp = 22 ;
        }]}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.1 {
    Generated code file instance creation -- bad arguments to create
} -setup {
    makeFile {} codegen26_1.h
    makeFile {} codegen26_1.c
    micca configure {
        domain codegen26_1 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx 30>% // need name / value pairs
            }
        }
        population codegen26_1 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.2 {
    Generated code file instance creation -- missing attribute
} -setup {
    makeFile {} codegen26_2.h
    makeFile {} codegen26_2.c
    micca configure {
        domain codegen26_2 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx>% // missing attribute, temp
            }
        }
        population codegen26_2 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.3 {
    Generated code file instance creation -- extra attribute
} -setup {
    makeFile {} codegen26_3.h
    makeFile {} codegen26_3.c
    micca configure {
        domain codegen26_3 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx temp 20 size 30>% // no attribute, size
            }
        }
        population codegen26_3 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.4 {
    Generated code file instance creation with string
} -setup {
    # makeFile {} codegen26_4.h
    # makeFile {} codegen26_4.c
    micca configure {
        domain codegen26_4 {
            class X {
                attribute color {char[32]} -default {"red"}
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx color {"blue"} temp 22>%
                printf("%s\n", %<instance newx attr color>%) ;
                char *newcolor = "yellow" ;
                %<X create newx color newcolor temp 10>%
            }
        }
        population codegen26_4 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {strncpy} codegen26_4.c]] == 2}
} -result {1}
----
endif::showtests[]

==== Synchronous Instance Creation in a Given State

*****
`%<` _class_ `createin` _instref_ _state_ _?attr1 value1 att2 value2 ...?_ `>%`

_class_::
    The name of a domain class for which an instance is synchronously created.
instref::
    The name of a variable into which a reference to the newly created
    class instance is placed.
state::
    The name of the state into which the newly created instance is placed.
attrN / valueN::
    A set of attribute name / attribute values which are used to set the
    attribute values of the newly created instance.

The `createin` subcommand for a class generates ``C'' statements to
synchronously create a new instance of the class in a given state.
This subcommand is defined only for classes that have a state model.
A reference to the instance is placed in the variable called, _instref_.
If _instref_ has not been previously declared, it is declared
automatically.
The attributes of the newly created instance are set to the values given
by the _attrN / valueN_ pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the `createin` subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
The instance will start in the _state_ state and *no* activity is executed
since the instance creation is done synchronously.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassCreateIn {className instref state args} {
    variable domain
    set statenum [GetStateNumber $domain $className $state]
    set classDesc [GetClassDescriptor $domain $className]

    append result\
        [linecomment "$className create $instref [list $args]"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_CreateInstance(&$classDesc, $statenum) ;\n"\
        [AssignComponentValues $className $instref $args]

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc GetStateNumber {domain className state} {
    set stateRef [StatePlace findById Domain $domain Model $className\
            Name $state]
    if {[isEmptyRef $stateRef]} {
        error "class, $className, has no state named, $state"
    }
    return [readAttribute $stateRef Number]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-27.0 {
    Generated code file instance creation in a given state
} -setup {
    # makeFile {} codegen27.h
    # makeFile {} codegen27.c
    micca configure {
        domain codegen27 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    state s2 {} {
                        printf("in s2\n") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createin newx s2 color 30>%
                printf("%d\n", %<instance newx attr color>%) ;
            }
        }
        population codegen27 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_CreateInstance} codegen27.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-27.1 {
    Generated code file instance creation in a given state -- bad state
} -setup {
    makeFile {} codegen27_1.h
    makeFile {} codegen27_1.c
    micca configure {
        domain codegen27_1 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    state s2 {} {
                        printf("in s2\n") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createin newx s3>%
                printf("%d\n", %<instance newx attr color>%) ;
            }
        }
        population codegen27_1 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----
endif::showtests[]

==== Asynchronous Instance Creation

*****
`%<` _class_ `createasync` _event_ \{ _?eparams?_ \} _?attr1 value1 att2 value2 ...?_ `>%`

_class_::
    The name of a domain class for which an instance is asynchronously created.
event::
    The name of the creation event that is to be signaled to the
    newly created class instance.
eparams::
    A set of parameter name / value pairs that are the parameters of the
    creation event.
    If there are no parameters, is it sufficent to use the empty
    list ( \{} ) as the command argument.
attrN / valueN::
    A set of attribute name / attribute values which are used to set the
    attribute values of the newly created instance.

The `createasync` subcommand for a class generates ``C'' statements to
asynchronously create a new instance of the class by signaling _event_
to it.
Any parameters of the creation event are given by name / value pairs
specified as the _eparams_ list.
The attributes of the newly created instance are set to the values given
by the _attrN / valueN_ pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the `createasync` subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
This command only defined for classes that have a state model for which
creation events have been specified.
The instance is created and placed in it creation state awaiting delivery
of _event_, whereupon it will transition and execute a state activity.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassCreateAsync {className event eventparams args} {
    variable domain

    if {[llength $eventparams] % 2 != 0} {
        error "event parameters must be given as name / value pairs, got:\
            \"$eventparams\""
    }
    set eventRef [Event findById Domain $domain Model $className Event $event]
    if {[isEmptyRef $eventRef]} {
        error "class, $className, has no event named, $event"
    }
    set eventNum [readAttribute $eventRef Number]

    append result\
        [linecomment "$className createasync $event [list $eventparams]\
            [list $args]"]

    set psig [findRelated $eventRef R69]
    set params [FindParamsFromSig $psig]
    if {[relation isnotempty $params]} {
        set required [relation list $params Name]
        set supplied [dict keys $eventparams]
        if {![::struct::set equal $required $supplied]} {
            error "event, $event, requires parameters,\
                \"[join $required {, }]\", got:\
                \"[join $supplied {, }]\""
        }

        set eparamsname ${domain}_${className}_${event}__EPARAMS
        set paramvar [CreateTempSymbol Ctype "struct *$eparamsname"\
            Type EventParams Class $className]

        append result\
            "struct $eparamsname $paramvar = \{\n"
        relation foreach param $params -ascending Position {
            relation assign $param Name
            append result "    .$Name = [dict get $eventparams $Name],\n"
        }
        append result "\} ;\n"

        set paramptr &$paramvar
        set paramsize sizeof($paramvar)
    } else {
        set paramptr NULL
        set paramsize 0
    }

    set sourceinst [expr {[LookUpSymbol self] eq {} ? "NULL" : "self"}]

    lassign [CreateTempRefSymbol $className] reftype refvar
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    append result\
        "$reftype$refvar = mrt_CreateAsync(&$classDesc, $eventNum,\
            $paramptr, $paramsize, $sourceinst) ;\n"\
        [AssignComponentValues $className $refvar $args]

    return [IndentToBlock $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-28.0 {
    asynchronous instance creation
} -setup {
    validateutils genMiccaFile codegen28 {
        domain codegen28 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {a int} {
                        printf("in s1 with %d\n", a) ;
                        (void)self ;
                    }
                    state s2 {b char} {
                        printf("in s2 with %c\n", b) ;
                        (void)self ;
                    }
                    transition @ - e3 -> s1
                    transition @ - e4 -> s2
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createasync e3 {a 20} color 30>%
            }
        }
        population codegen28 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen28.c
    validateutils matchLines codegen28.c {
        struct codegen28_X_e3__EPARAMS t__T1 = {
            .a = 20,
        } ;
        struct X *t__T2 = mrt_CreateAsync(&codegen28__CLASSES[0], 2, &t__T1, sizeof(t__T1), NULL) ;
        t__T2->color = 30 ;
    }
} -result {1}
----
endif::showtests[]

==== Iterating Over Class Instances

*****
`%<` _class_ `foreachInstance` _instref_ `>%`
_Loop Body_
`%<end>%`

_class_::
    The name of a domain class.
instref::
    The name of a variable into which a reference to a class instance is placed.

The `foreachInstance` subcommand for a class generates ``C'' statements
to visit the instances of _class_.
For each allocated instance of _class_,
a reference to the instance is assigned to the _instref_ variable
and _Loop Body_ is executed.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassForeachInstance {className instref} {
    variable domain

    set iter [CreateTempSymbol Ctype {MRT_InstIterator}\
            Type InstanceIterator Class $className]

    set startlevel [GetBlock]

    set classDesc [GetClassDescriptor $domain $className]
    set result [IndentToBlock [string cat\
        [linecomment "$className foreachInstance $instref"]\
        "MRT_InstIterator $iter ;\n"\
        "for (mrt_InstIteratorStart(&$iter, &$classDesc) ;\
            mrt_InstIteratorMore(&$iter) ;\
            mrt_InstIteratorNext(&$iter)) \{\n"\
    ]]
    PushBlock
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstIteratorGet(&$iter) ;\n"\
    ]]

    PushContext ClassForeachInstance $startlevel

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-29.0 {
    Iterate over non-union subclass
} -setup {
    validateutils genMiccaFile codegen29 {
        domain codegen29 {
            class X {
                attribute color int -default 20
            }

            domainop void printcolors {} {
                %<X foreachInstance xref>%
                    printf("%d\n", %<instance xref attr color>%) ;
                %<end>%
            }
        }
        population codegen29 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen29.c
    validateutils matchLines codegen29.c {
        MRT_InstIterator t__T1 ;
        for (mrt_InstIteratorStart(&t__T1, &codegen29__CLASSES[0]) ; mrt_InstIteratorMore(&t__T1) ; mrt_InstIteratorNext(&t__T1)) {
            struct X *xref ;
            xref = mrt_InstIteratorGet(&t__T1) ;
            printf("%d\n", xref->color) ;
        }
    }
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-25.0 {
    Iterate over union subclass
} -setup {
    validateutils genMiccaFile codegen25 {
        domain codegen25 {
            class A {}
            class B {}
            class X {
                attribute color int -default 20
                attribute temp int -default 40
                attribute size int -default 50

            }
            generalization R1 -union A B X

            class Y {
                attribute sign bool -default true
                attribute cost int -default 10

                statemodel {
                    state s1 {} {
                        (void)self ;
                        %<Z foreachInstance zref>%
                            printf("%d\n", %<instance zref attr plus>%) ;
                        %<end>%
                    }
                    transition s1 - e1 -> s1
                }
            }
            class Z {
                attribute magnitude bool -default false
                attribute plus int -default 42
            }

            generalization R2 -union X Y Z
        }
        population codegen25 {
            class A {
                instance a1
                instance a2
                instance a3
                instance a4
            }
            class B {
                instance b1 R1 a1
            }
            class X {
                instance x1 R1 a2
                instance x2 R1 a3
                instance x3 R1 a4
            }
            class Y {
                instance y1 R2 x1
            }
            class Z {
                instance z1 R2 x2
                instance z2 R2 x3
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen25.c
    validateutils matchLines codegen25.c {
        MRT_InstIterator t__T1 ;
        for (mrt_InstIteratorStart(&t__T1, &codegen25__CLASSES[4]) ; mrt_InstIteratorMore(&t__T1) ; mrt_InstIteratorNext(&t__T1)) {
            struct Z *zref ;
            zref = mrt_InstIteratorGet(&t__T1) ;
            printf("%d\n", zref->plus) ;
        }
    }
} -result {1}
----
endif::showtests[]

==== Conditional Iteration Over Class Instances

*****
`%<` _class_ `foreachWhere` _instref_ _clause_`>%`
_Loop Body_
`%<end>%`

_class_::
    The name of a domain class.
instref::
    The name of a variable into which a reference to a class instance is placed.
where::
    ``C'' code statements that can be evaluated to yield a boolean value.

The `foreachWhere` subcommand for a class generates ``C'' statements
to visit conditionally the instances of _class_.
For each allocated instance of _class_,
a reference to the instance is assigned to the _instref_ variable
and _clause_ is evaluated.
If _clause_ evaluates to non-zero, then _Loop Body_ is executed.
Otherwise, _Loop Body_ is skipped.
*****

[source,tcl]
----
<<generation support commands>>=
proc ClassForeachWhere {className instref where} {
    variable domain

    set startlevel [GetBlock]

    set classDesc [GetClassDescriptor $domain $className]
    set iter [CreateTempSymbol Ctype {MRT_InstIterator}\
            Type InstanceIterator Class $className]
    set result [IndentToBlock [string cat\
        [linecomment "$className foreachWhere $instref [list $where]"]\
        "MRT_InstIterator $iter ;\n"\
        "for (mrt_InstIteratorStart(&$iter, &$classDesc) ;\
            mrt_InstIteratorMore(&$iter) ;\
            mrt_InstIteratorNext(&$iter)) \{\n"\
    ]]
    PushBlock
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstIteratorGet(&$iter) ;\n"\
        "if ($where) \{\n"\
    ]]
    PushBlock

    PushContext ClassForeachWhere $startlevel

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-53.0 {
    Iterate over class instances based on where clause
} -setup {
    validateutils genMiccaFile codegen53 {
        domain codegen53 {
            class X {
                attribute id unsigned
                attribute color int -default 20

                classop {struct X *} findById {id unsigned} {
                    %<X foreachWhere xref {xref->id == id}>%
                        return xref ;
                    %<end>%
                    return NULL ;
                }
            }
        }
        population codegen53 {
            class X {
                instance x1 id 100 color 30
                instance x2 id 101
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen53.c
    validateutils matchLines codegen53.c {
        MRT_InstIterator t__T1 ;
        for (mrt_InstIteratorStart(&t__T1, &codegen53__CLASSES[0]) ; mrt_InstIteratorMore(&t__T1) ; mrt_InstIteratorNext(&t__T1)) {
            struct X *xref ;
            xref = mrt_InstIteratorGet(&t__T1) ;
            if (xref->id == id) {
                return xref ;
            }
        }
    }
} -result {1}
----
endif::showtests[]

==== Searching Class Instances

*****
`%<` _class_ `findWhere` _instref_ _clause_`>%`

_class_::
    The name of a domain class.
instref::
    The name of a variable into which a reference to a class instance is placed.
where::
    ``C'' code statements that can be evaluated to yield a boolean value.

The `findWhere` subcommand for a class generates ``C'' statements
to search the instances of _class_.
A reference to the first allocated instance of _class_ for which
_clause_ evaluates to `true` is assigned to the
_instref_ variable.
If _clause_ never evaluates to `true` then _instref_ will have the
value of `NULL`.
*****

[source,tcl]
----
<<generation support commands>>=
proc ClassFindWhere {className instref where} {
    variable domain

    set startlevel [GetBlock]

    set classDesc [GetClassDescriptor $domain $className]
    set iter [CreateTempSymbol Ctype {MRT_InstIterator}\
            Type InstanceIterator Class $className]
    set result [IndentToBlock [string cat\
        [linecomment "$className findWhere $instref [list $where]"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = NULL ;\n"\
        "MRT_InstIterator $iter ;\n"\
        "for (mrt_InstIteratorStart(&$iter, &$classDesc) ;\
            mrt_InstIteratorMore(&$iter) ;\
            mrt_InstIteratorNext(&$iter)) \{\n"\
    ]]
    PushBlock
    append result [IndentToBlock [string cat\
        "$instref = mrt_InstIteratorGet(&$iter) ;\n"\
        "if ($where) \{\n"\
    ]]

    PushBlock
    append result [IndentToBlock [string cat\
        "break ;\n"\
    ]]
    PopBlock
    append result [IndentToBlock "\}\n"]
    PopBlock
    append result [IndentToBlock [string cat\
        "\}\n"\
        "$instref = mrt_InstIteratorMore(&$iter) ? $instref : NULL ;\n"\
    ]]

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-56.0 {
    Search class instances
} -setup {
    validateutils genMiccaFile codegen56 {
        domain codegen56 {
            class X {
                attribute id unsigned
                attribute color int -default 20

                classop {struct X *} findById {id unsigned} {
                    %<X findWhere xref {xref->id == id}>%
                    return xref ;
                }
            }
        }
        population codegen56 {
            class X {
                instance x1 id 100 color 30
                instance x2 id 101
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen56.c
    validateutils matchLines codegen56.c {
        struct X *xref ;
        xref = NULL ;
        MRT_InstIterator t__T1 ;
        for (mrt_InstIteratorStart(&t__T1, &codegen56__CLASSES[0]) ; mrt_InstIteratorMore(&t__T1) ; mrt_InstIteratorNext(&t__T1)) {
            xref = mrt_InstIteratorGet(&t__T1) ;
            if (xref->id == id) {
                break ;
            }
        }
        xref = mrt_InstIteratorMore(&t__T1) ? xref : NULL ;
    }
} -result {1}
----
endif::showtests[]

==== Conditionally Selecting Class Instances

*****
`%<` _class_ `selectWhere` _instref_ _clause_ _instset_`>%`

_class_::
    The name of a domain class.
instref::
    The name of a variable into which a reference to a class instance is placed.
where::
    ``C'' code statements that can be evaluated to yield a boolean value.
instset::
    The name of a variable which will contain an instance set.

The `selectWhere` subcommand for a class generates ``C'' statements
to conditionally add instances of _class_ to an instance set.
For each allocated instance of _class_,
a reference to the instance is assigned to the _instref_ variable
and _clause_ is evaluated.
If _clause_ evaluates to non-zero,
then the instance is added to the set being accumulated in
the _instset_ variable.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassSelectWhere {className instref where instset} {
    variable domain
    set result [IndentToBlock\
        [linecomment "$className selectWhere $instref [list $where] $instset"]\
    ]

    set startlevel [GetBlock]

    set classDesc [GetClassDescriptor $domain $className]
    append result [IndentToBlock [string cat\
        [CreateInstSetSymbol $className $instset]\
        "mrt_InstSetInitialize(&$instset, &$classDesc) ;\n"]\
    ]

    set iter [CreateTempSymbol Ctype {MRT_InstIterator}\
            Type InstanceIterator Class $className]
    append result [IndentToBlock [string cat\
        "MRT_InstIterator $iter ;\n"\
        "for (mrt_InstIteratorStart(&$iter, &$classDesc) ;\
            mrt_InstIteratorMore(&$iter) ;\
            mrt_InstIteratorNext(&$iter)) \{\n"\
    ]]
    PushBlock

    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstIteratorGet(&$iter) ;\n"\
        "if ($where) \{\n"\
    ]]
    PushBlock

    append result [IndentToBlock\
        "mrt_InstSetAddInstance(&$instset, $instref) ;\n"\
    ]

    set depth [expr {[GetBlock] - $startlevel}]
    for {set i 0} {$i < $depth} {incr i} {
        PopBlock
        append result [IndentToBlock "\}\n"]
    }

    return $result
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-52.0 {
    Generate instance set from class instances.
} -setup {
    validateutils genMiccaFile codegen52 {
        domain codegen52 {
            class X {
                attribute color int -default 20
            }

            domainop void printcolors {} {
                %<X selectWhere xref {xref->color != 20} xset>%
            }
        }
        population codegen52 {
            class X {
                instance x1 color 30
                instance x2
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen52.c
    validateutils matchLines codegen52.c {
        MRT_InstSet xset ;
        mrt_InstSetInitialize(&xset, &codegen52__CLASSES[0]) ;
        MRT_InstIterator t__T1 ;
        for (mrt_InstIteratorStart(&t__T1, &codegen52__CLASSES[0]) ; mrt_InstIteratorMore(&t__T1) ; mrt_InstIteratorNext(&t__T1)) {
            struct X *xref ;
            xref = mrt_InstIteratorGet(&t__T1) ;
            if (xref->color != 20) {
                mrt_InstSetAddInstance(&xset, xref) ;
            }
        }
    }
} -result {1}
----
endif::showtests[]

==== Declaring Instance Reference Variables

*****
`%<` _class_ `instref` _varname_ `>%`

_class_::
    The name of a domain class.
varname::
    The name of a variable which will be declared as an instance reference
    to an instance of _class_.

The `instref` subcommand for a class generates ``C'' statements
declare _varname_ to be a variable whose type is suitable to hold
an instance reference to instances of _class_.
*****

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassInstanceReference {className varName} {
    return [IndentToBlock [string cat\
        [linecomment "$className instref $varName"]\
        "[CreateInstRefSymbol $className $varName]"\
        "$varName = NULL ;\n"\
    ]]
}
----

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassIdToRef {className instid instref} {
    variable domain

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstanceReference(&$classDesc, $instid) ;\n"
    return [IndentToBlock $result] ;
}
----

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassFindByName {className instName instref} {
    variable domain
    set instRef [ClassInstance findById Domain $domain Class $className\
        Instance $instName]
    if {[isEmptyRef $instRef]} {
        error "class, $className, has no instance named, $instName"
    }
    set classDesc [GetClassDescriptor $domain $className]
    set instNum [readAttribute $instRef Number]
    append result\
        [linecomment "$className findByName $instName $instref"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstanceReference(&$classDesc, $instNum) ;\n"
    return [IndentToBlock $result]
}
----

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassOperation {className opName args} {
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set opRef [Operation findWhere {$Domain eq $domain && $Class eq $className\
        && $Name eq $opName && !$IsInstance}]
    if {[isEmptyRef $opRef]} {
        error "unknown class operation, $opName, for class, $className"
    }

    set provided [dict keys $args]
    set params [deRef [findRelated $opRef ~R4]]
    set required [relation list $params Name -ascending Number]
    ValidateParams $opName $provided $required

    set pset {}
    foreach pname $required {
        append pset "[dict get $args $pname], "
    }
    set pset [string trimright $pset {, }]

    return "${className}_$opName\($pset\)"
}
----

[source,tcl]
.Implementation
----
<<generation support commands>>=
proc ClassInstanceSet {className varName} {
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    return [IndentToBlock [string cat\
        [linecomment "$className instSet $varName"]\
        [CreateInstSetSymbol $className $varName]\
        "mrt_InstSetInitialize(&$varName, &$classDesc) ;\n"\
    ]]
}
----

=== Relationship Commands

Similar to classes,
each relationship in the domain model will have an embedded macro command
of the same name as the relationship.
Further, relationship have an embedded macro command for the
reverse direction, _i.e._ a relationship `R42` will have two commands,
`R42` and `~R42`.

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleSwap {relName sourceref targetref} {
    variable domain
    set relRef [SimpleAssociation findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R31 R30] Number]
    set rship &${domain}__RSHIPS\[$relNum\]

    set sourceClass [readAttribute [findRelated $relRef ~R32] Class]
    CheckInstRefSymbol $sourceref Class $sourceClass

    set targetClass [readAttribute [findRelated $relRef ~R33] Class]
    CheckInstRefSymbol $targetref Class $targetClass

    return [IndentToBlock [string cat\
        [linecomment "$relName swap $sourceref $targetref"]\
        "mrt_CreateSimpleLinks\($rship, $sourceref, $targetref\) ;\n"\
    ]]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-30.0 {
    Create simple association
} -setup {
    validateutils genMiccaFile codegen30 {
        domain codegen30 {
            class X {}
            class Y {}

            association R1 X 0..1--1 Y

            domainop void makePair {} {
                %<Y create yref>%
                %<X create xref R1 yref>%
            }
        }
        population codegen30 {
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen30.c
    validateutils matchLines codegen30.c {
        // Y create yref {}
        struct Y *yref ;
        yref = mrt_CreateInstance(&codegen30__CLASSES[1], MRT_StateCode_IG) ;
        // X create xref {R1 yref}
        struct X *xref ;
        xref = mrt_CreateInstance(&codegen30__CLASSES[0], MRT_StateCode_IG) ;
        mrt_CreateSimpleLinks(&codegen30__RSHIPS[0], xref, yref) ;
    }
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc RelClassSwap {relName assocref partref} {
    variable domain
    set relRef [ClassBasedAssociation findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R31 R30] Number]
    set rship &${domain}__RSHIPS\[$relNum\]

    set assocClass [readAttribute [findRelated $relRef ~R42] Class]
    set assocsym [CheckInstRefSymbol $assocref Class $assocClass]

    set sourceClass [readAttribute [findRelated $relRef ~R34] Class]
    set targetClass [readAttribute [findRelated $relRef ~R35] Class]
    set partClass [dict get [LookUpSymbol $partref] Class]
    if {$partClass ne $sourceClass && $partClass ne $targetClass} {
        error "$partref is a reference to an instance of class, $partClass,\
            which does not participate in relationship, $relName"
    }

    return [IndentToBlock [string cat\
        [linecomment "$relName swap $assocref $partref"]\
        "mrt_CreateSimpleLinks\($rship, $assocref, $partref\) ;\n"\
    ]]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-31.0 {
    Create class based association
} -setup {
    validateutils genMiccaFile codegen31 {
        domain codegen31 {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 0..*--0..* Y

            domainop void makePair {} {
                %<X create xref>%
                %<Y create yref>%
                %<A create aref R1 {X xref Y yref}>%
            }
        }
        population codegen31 {
            class A {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen31.c
    validateutils matchLines codegen31.c {
        // X create xref {}
        struct X *xref ;
        xref = mrt_CreateInstance(&codegen31__CLASSES[1], MRT_StateCode_IG) ;
        // Y create yref {}
        struct Y *yref ;
        yref = mrt_CreateInstance(&codegen31__CLASSES[2], MRT_StateCode_IG) ;
        // A create aref {R1 {X xref Y yref}}
        struct A *aref ;
        aref = mrt_CreateInstance(&codegen31__CLASSES[0], MRT_StateCode_IG) ;
        mrt_CreateAssociatorLinks(&codegen31__RSHIPS[0], aref, xref, yref) ;
    }
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-32.0 {
    Create reference super class instance
} -setup {
    validateutils genMiccaFile codegen32 {
        domain codegen32 {
            class S {}
            class X {}
            class Y {}

            generalization R1 S X Y

            domainop void makePair {} {
                %<S create s1>%
                %<X create x1 R1 s1>%
            }
        }
        population codegen32 {
            class S {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen32.c
    validateutils matchLines codegen32.c {
        // X create x1 {R1 s1}
        struct X *x1 ;
        x1 = mrt_CreateInstance(&codegen32__CLASSES[1], MRT_StateCode_IG) ;
        mrt_CreateSimpleLinks(&codegen32__RSHIPS[0], x1, s1) ;
    }
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenReclassify {relName superref subclass subref args} {
    set result [linecomment "$relName reclassify $superref $subclass $subref"]

    variable domain
    set relRef [ReferenceGeneralization findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R43 R30] Number]

    set supername [readAttribute [findRelated $relRef ~R36] Class]
    CheckInstRefSymbol $superref Class $supername
    CheckSubClassName $subclass [findRelated $relRef ~R37]

    set classDesc [GetClassDescriptor $domain $subclass]
    append result\
        [CreateInstRefSymbol $subclass $subref]\
        "$subref = mrt_Reclassify\(&${domain}__RSHIPS\[$relNum\], $superref, "\
        "&$classDesc\) ;\n"

    lappend args $relName $superref
    append result [AssignComponentValues $subclass $subref $args]

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc CheckSubClassName {subclass subRefs} {
    set subclassnames [pipe {
        deRef $subRefs |
        relation list ~ Class
    }]
    if {$subclass ni $subclassnames} {
        error "bad subclass, $subclass, should be one of:\
                [join $subclassnames {, }]"
    }
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-33.0 {
    Reclassify reference generalization
} -setup {
    validateutils genMiccaFile codegen33 {
        domain codegen33 {
            class S {}
            class X {}
            class Y {
                attribute color int
            }

            generalization R1 S X Y

            domainop void makePair {} {
                %<S create s1>%
                %<X create x1 R1 s1>%
                %<R1 reclassify s1 Y y1 color 20>%
            }
        }
        population codegen33 {
            class S {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen33.c
    validateutils matchLines codegen33.c {
        // R1 reclassify s1 Y y1
        struct Y *y1 ;
        y1 = mrt_Reclassify(&codegen33__RSHIPS[0], s1, &codegen33__CLASSES[2]) ;
        mrt_CreateSimpleLinks(&codegen33__RSHIPS[0], y1, s1) ;
        y1->color = 20 ;
    }
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc RelUnionGenReclassify {relName superref newClassName subref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName reclassify $superref $newClassName $subref"]]\
        [ReclassifyUnionGen $relName $superref $newClassName $subref]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelUnionGenReclassify {relName superref subclass subref args} {
    set result [linecomment "$relName reclassify $superref $subclass $subref"]

    variable domain
    set relRef [UnionGeneralization findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R43 R30] Number]

    set supername [readAttribute [findRelated $relRef ~R44] Class]
    CheckInstRefSymbol $superref Class $supername
    CheckSubClassName $subclass [findRelated $relRef ~R45]

    set classDesc [GetClassDescriptor $domain $subclass]
    append result\
        [CreateInstRefSymbol $subclass $subref]\
        "$subref = mrt_Reclassify\(&${domain}__RSHIPS\[$relNum\], $superref, "\
        "&$classDesc\) ;\n"

    lappend args $relName $superref
    append result [AssignComponentValues $subclass $subref $args]

    return [IndentToBlock $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-34.0 {
    Reclassify union generalization
} -setup {
    validateutils genMiccaFile codegen34 {
        domain codegen34 {
            class S {}
            class X {}
            class Y {
                attribute color int
            }

            generalization R1 -union S X Y

            domainop void makePair {} {
                %<S create s1>%
                %<R1 reclassify s1 Y y1 color 30>%
            }
        }
        population codegen34 {
            class S {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen34.c
    validateutils matchLines codegen34.c {
        // R1 reclassify s1 Y y1
        struct Y *y1 ;
        y1 = mrt_Reclassify(&codegen34__RSHIPS[0], s1, &codegen34__CLASSES[2]) ;
        y1->color = 30 ;
    }
} -result {1}
----
endif::showtests[]

=== Assigner Commands

[source,tcl]
----
<<generation support commands>>=
proc SingleAssignerSignal {relName event args} {
    set reftype "struct $relName *"
    set instref [CreateTempSymbol Ctype $reftype Type Reference Class $relName]

    append result\
        [linecomment "$relName signal $event [list $args]"]\
        "$reftype$instref = &${relName}__POOL\[0\] ;\n"

    return [string cat\
        [IndentToBlock $result]\
        [InstanceSignal $instref $event {*}$args]\
    ]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-35.0 {
    Signal a single assigner
} -setup {
    # makeFile {} codegen35.h
    # makeFile {} codegen35.c
    micca configure {
        domain codegen35 {
            class clerk {}
            class client {}
            class service {}
            association R1 -associator service clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }

            domainop void clerkready {} {
                %<R1 signal clerkReady>%
            }
        }
        population codegen35 {
            class clerk {
                instance clerk1
            }
            class client {
                instance client1
            }
            class service {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_PostEvent} codegen35.c]] == 1}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<generation support commands>>=
proc MultiAssignerCreate {relName instref idinst} {
    variable domain

    set maRef [MultipleAssigner findWhere {$Domain eq $domain &&\
            $Association eq $relName}]
    set idClass [readAttribute $maRef Class]
    CheckInstRefSymbol $idinst Class $idClass

    set assignerClass ${domain}__ASSIGNERS\[[GetClassProperty $relName Number]\]
    append result\
        [linecomment "$relName create $instref $idinst"]\
        [CreateInstRefSymbol $relName $instref]\
        "$instref = mrt_CreateInstance(&$assignerClass, MRT_StateCode_IG) ;\n"\
        "$instref->idinstance = $idinst ;\n"

    return [IndentToBlock $result]
}
----

ifdef::showtests[]
[source,tcl]
----
<<generate command tests>>=
test codegen-47.0 {
    Create a multi assigner
} -setup {
    # makeFile {} codegen47.h
    # makeFile {} codegen47.c
    micca configure {
        domain codegen47 {
            class clerk {}
            class client {}
            class service {}
            class department {
                attribute name {char[32]}
            }

            association R1 -associator service clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            domainop void newDept {name {char const *}} {
                %<department create deptref name name>%
                %<R1 create r1ref deptref>%
            }
        }
        population codegen47 {
            class department {
                allocate 4
            }
            class clerk {
                allocate 3
            }
            class service {
                allocate 9
            }
            class client {
                allocate 3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1__POOL} codegen47.c]] == 4}
} -result {1}
----
endif::showtests[]

== Helper Commands

[source,tcl]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }
    namespace import ::micca::@Config@::Helpers::typeCheck

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,tcl]
----
<<generation helper commands>>=
proc banner {} {
    set marker [string repeat - 70]
    string cat\
        "/*\n"\
        " * $marker\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * $marker\n"\
        " */\n"
}
----

[source,tcl]
----
<<generation helper commands>>=
proc comment {args} {
    set result "/*\n"
    foreach c $args {
        append result [::textutil::adjust::indent\
            [::textutil::adjust::adjust $c] { * }]\n
    }
    append result " */\n"

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc linecomment {text} {
    set result {}
    foreach line [split $text \n] {
        append result "// $line\n"
    }
    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc blockcomment {block} {
    return [textutil::adjust::indent [textutil::adjust::undent\
            [string trim $block \n]] {// }]\n
}
----

[source,tcl]
----
<<generation helper commands>>=
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

[source,tcl]
----
<<generation helper commands>>=
proc GenInstanceAddress {domainName className instName} {
    set path {}
    set usubRef [UnionSubclass findWhere {$Domain eq $domainName &&\
        $Class eq $className}]
    if {[isNotEmptyRef $usubRef]} {
        # puts [relformat [deRef $usubRef] usubRef]
        while {[isNotEmptyRef $usubRef]} {
            assignAttribute $usubRef {Relationship rship} {Class subName}
            set path .$rship.${subName}$path

            set usuperRef [findRelated $usubRef R45 ~R44]
            set superClass [readAttribute $usuperRef Class]

            set usubRef [pipe {
                deRef $usuperRef |
                relation semijoin ~ $::micca::UnionSubclass\
                    -using {Domain Domain Class Class} |
                ::rosea::Helpers::ToRef ::micca::UnionSubclass ~
            }]
            # puts [relformat [deRef $usubRef] usubRef]
        }

        # puts "path = \"$path\""
        set storageClass $superClass
    } else {
        set storageClass $className
    }
    set instNumber [readAttribute\
            [ClassInstance findById Domain $domainName Class $className\
                Instance $instName]\
        Number]
    return &${storageClass}__POOL\[$instNumber\]$path
}
----

/////

ifdef::showtests[]
[source,tcl]
<<generate command tests>>=
----
test codegen-@.0 {
    asynchronous instance creation
} -setup {
    validateutils genMiccaFile codegen@ {
        domain codegen@ {
        }
        population codegen@ {
        }
    }
} -cleanup {
    cleanupDomain
    validateutils forgetFiles
} -body {
    validateutils compileFiles codegen@.c
    validateutils matchLines codegen@.c {
    }
} -result {1}
----
endif::showtests[]


    validateutils genMiccaFile codegen@ {

    validateutils forgetFiles

    validateutils compileFiles codegen@.c
    validateutils matchLines codegen@.c {
    }


*****
`%<instance` _instvar_ `SSS` `>%`

instvar::
    The name of a ``C'' variable containing an instance reference
    which is to be signaled.

The `instvar` subccommand generates a ``C'' expression
for an identifier which corresponds to the instance reference of _instvar_.
*****


/////
