// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time translates model level actions into ``C'' level
execution.
The run time can be compiled separately and is data driven.
The details of how a domain behaves is completely determined by the
data values supplied to the run time and the state activities and
domain operations supplied as ``C'' code.

Code generation consist of two major pieces:

* Generating initialized ``C'' variables of the type required by the run time.
* Generating ``C'' code for state activities and domain operations to
facilitate the interface to the run time.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,c]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,c]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
One is required to define things in specific orders to satisfy the
compiler.
One way to accomplish this is to use a template.
The template is orgainized in the order required by the compiler
and contains embedded commands.
When expanded the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from _tcllib_.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,c]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

[source,c]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: generate header files>>
    <<miccaGenerate: generate code files>>

    rename expand {} ; # <1>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return
}
----
<1> The template expander creates a new command so we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation errors}
----

[source,c]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror fail\
]
set options [dict merge $options $arglist]
----

[source,c]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand setbrackets %< >%
expand errmode [dict get $options expanderror]
----

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,c]
----
<<miccaGenerate: verify domains are populated>>=
set pops [pipe {
    Domain findAll |
    deRef ~ |
    relation eliminate ~ Interface Prologue Epilogue |
    relation rename ~ Name Domain |
    ralutil::rvajoin ~ $::micca::Population Populations 
}]

set badops [relation restrictwith $pops {[relation cardinality $Populations] != 1}]
relation foreach badop $badops {
    relation assign $badpop Populations
    set card [relation cardinality $Populations]
    set msg [string cat "For domain, \"$Domain\", "\
        [expr {$card == 0 ?\
            "no population is given" :\
            "$card populations are given"}]\
        ": expected exactly one population for the domain"
    log::error $msg
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

== Header Files

[source,c]
----
<<miccaGenerate: generate header files>>=
expand evalcmd "namespace eval [namespace current]::GenHeader"
----

[source,c]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

[source,c]
----
<<generation data>>=
set headerTemplate [string cat\
    %<banner>%\
    "#ifndef %<headerFileGuard>%\n"\
    "#define %<headerFileGuard>%\n"\
    %<interface>%\
    "#include <stddef.h>\n"\
    "#include <stdint.h>\n"\
    "#include <stdbool.h>\n"\
    %<typeAliases>%\
    %<domainOpDeclarations>%\
    %<portalIds>%\
    "#endif /* %<headerFileGuard>% */"\
]
----

[source,c]
----
<<miccaGenerate: generate header files>>=
forAllRefs domainRef [Domain findAll] {
    namespace upvar GenHeader\
        domain domain\
        interface interface

    assignAttribute $domainRef\
        {Name domain}\
        {Interface interface}

    variable headerTemplate

    set hchan [::open $domain.h w]
    try {
        puts $hchan [expand expand $headerTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $hchan
    }

    unset domain interface
}
----

[source,c]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return "_[string toupper [string trim $domain]]_H_"
}
----

[source,c]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    set result {}
    if {$interface ne {}} {
        append result\
            [comment "Domain Interface Contents"]\
            [indentCode [string trim $interface \n] 0]
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    makeFile {} header1.h
    makeFile {} header1.c
    micca configure {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population test header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {stdio} header1.h]
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc typeAliases {} {
    variable domain
    set aliases [pipe {
        TypeAlias findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ TypeName
    }]
    set doRefs [pipe {
        DomainOperation findWhere {$Domain eq $domain &&\
                $ReturnDataType in $aliases} |
        findRelated % R5 ~R7
    } {} |%]
    set dopRefs [pipe {
        DomainOperationParameter findWhere {$Domain eq $domain &&\
                $DataType in $aliases} |
        findRelated % R6 R5 ~R7
    } {} |%]

    set taRefs [refUnion $doRefs $dopRefs]
    set result {}
    if {[isNotEmptyRef $taRefs]} {
        append result [comment "Type Aliases"]
        forAllRefs taRef $taRefs {
            assignAttribute $taRef TypeName TypeDefinition
            append result\
                "typedef "\
                [typeCheck composeDeclaration $TypeDefinition $TypeName]\
                " \;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    makeFile {} header2.h
    makeFile {} header2.c
    micca configure {
        domain header2 {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population test header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {typedef} header2.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    set result {}
    if {[isNotEmptyRef $opRefs]} {
        append result [comment "External Declarations for Domain Operations"]

        forAllRefs opRef $opRefs {
            assignAttribute $opRef
            if {$Comment ne {}} {
                append result [comment $Comment]
            }
            append result "extern $ReturnDataType " $Domain _ $Name \(

            set params [pipe {
                findRelated $opRef ~R6 |
                deRef % |
                relation list % DataType -ascending Number |
                join % {, }
            } {} |%]
            append result $params "\) ;\n"
        }
    }
    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-3.0 {
    Generated header file domain operations
} -setup {
    makeFile {} header3.h
    makeFile {} header3.c
    micca configure {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population test header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {extern int header3_op[0-9]} header3.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    set result [comment "Numeric encoding of classes, attributes and\
            instances used by the portal functions"]
    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        assignAttribute $classRef
        append result [comment "Class: $Name"]
        set classid [string toupper ${Domain}_${Name}_CLASSID]
        append result "#define $classid $Number\n"

        set attrRefs [findRelated $classRef ~R20 {~R21 Attribute}]
        set attrNumber -1
        relation foreach attr [deRef $attrRefs] -ascending Name {
            relation assign $attr {Name attrName}
            set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
            append result "#define $attrid [incr attrNumber]\n"
        }

        set instRefs [findRelated $classRef ~R20 ~R103]
        relation foreach inst [deRef $instRefs] -ascending Number {
            relation assign $inst Instance {Number InstNumber}
            set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
            append result "#define $instid $InstNumber\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    makeFile {} header4.h
    makeFile {} header4.c
    micca configure {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population test header4 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {CLASSID} header4.h]
} -result {2}
----

== Generating Code Files

[source,c]
----
<<miccaGenerate: generate code files>>=
expand evalcmd "namespace eval [namespace current]::GenCode"
----

[source,c]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation code data>>
    <<generation code commands>>
}
----

[source,c]
----
<<generation data>>=
set codeTemplate [string cat\
    %<banner>%\
    %<prologue>%\
    %<domainInclude>%\
    "#include \"micca_rt.h\"\n"\
    %<forwardClassDeclarations>%\
    %<classDefinitions>%\
    %<epilogue>%\
]
----

[source,c]
----
<<miccaGenerate: generate code files>>=
forAllRefs domainRef [Domain findAll] {
    namespace upvar GenCode\
        domain domain\
        prologue prologue\
        epilogue epilogue

    assignAttribute $domainRef\
        {Name domain}\
        {Prologue prologue}\
        {Epilogue epilogue}

    variable codeTemplate

    PrepareDomainProperties $domain

    set cchan [::open $domain.c w]
    try {
        puts $cchan [expand expand $codeTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $cchan
    }
}
----

[source,c]
----
<<generation helper commands>>=
proc PrepareDomainProperties {domain} {
    variable ClassProperties

    # Need to handle missing class populations.
    # Not all classes will have a ClassPopulation instance.
    set classRefs [Class findWhere {$Domain eq $domain}]
    set allocs [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} |
        deRef % |
        relation project % Class Allocation |
        relation rename % Class Name
    } {} |%]

    set ClassProperties [pipe {
        deRef $classRefs |
        relation project ~ Name |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"} |
        ralutil::rvajoin ~ $allocs Allocations |
        relation extend ~ atup Allocation int {
            [relation isempty [tuple extract $atup Allocations]] ?\
            0 : [relation extract [tuple extract $atup Allocations] Allocation]
        } |
        relation eliminate ~ Allocations
    }]

    variable AssocProperties

    set AssocProperties [pipe {
        Association findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Association |
        ralutil::rvajoin ~ [deRef [StaticAssociation findAll]] Populations |
        relation extend ~ atup IsStatic boolean {
            [relation isnotempty [tuple extract $atup Populations]]} |
        relation project ~ Association IsStatic |
        relation rename ~ Association Name
    }]

    return
}

proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}

proc GetAssociationProperty {assoc prop} {
    variable AssocProperties
    set aprop [relation restrictwith $AssocProperties {$Name eq $assoc}]
    if {[relation isnotempty $aprop]} {
        return [relation extract $aprop $prop]
    }

    error "unknown property, \"$prop\", for association, \"$assoc\""
}
----

[source,c]
----
<<generation code commands>>=
proc prologue {} {
    variable prologue

    set result {}
    if {$prologue ne {}} {
        append result\
            [comment "Domain Prologue Begin"]\
            [indentCode [string trim $prologue \n] 0]\
            [comment "Domain Prologue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc epilogue {} {
    variable epilogue

    set result {}
    if {$epilogue ne {}} {
        append result\
            [comment "Domain Epilogue Begin"]\
            [indentCode [string trim $epilogue \n] 0]\
            [comment "Domain Epilogue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,c]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    # makeFile {} codegen1.h
    # makeFile {} codegen1.c
    micca configure {
        domain codegen1 {
            prologue {#include mySpecial.h}
            prologue {#include theSpecial.h}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population test codegen1 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {Special} codegen1.c]
} -result {2}
----

[source,c]
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc classDefinitions {} {
    variable domain

    set result [comment "Class structure definitions"]

    set subs [deRef [UnionSubclass findWhere {$Domain eq $domain}]]
    set supers [deRef [UnionSuperclass findWhere {$Domain eq $domain}]]
    set ultimates [pipe {
        relation semiminus $subs $supers -using {Domain Domain Class Class} |
        ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
    }]
    append result [DefineUnionSubclassStructures $ultimates]

    set classRefs [Class findWhere {$Domain eq $domain}]
    set remaining [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation semiminus $subs ~ -using {Domain Domain Class Name} |
        ::rosea::Helpers::ToRef ::micca::Class ~
    }]

    forAllRefs classRef $remaining {
        append result [DefineClassStructure $classRef]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc DefineUnionSubclassStructures {superRefs} {
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs R44 ~R45]
    forAllRefs subRef $subRefs {
        set newsupers [pipe {
            deRef $subRef |
            relation semijoin ~ $::micca::UnionSuperclass\
                -using {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
        }]

        append result [DefineUnionSubclassStructures $newsupers]

        append result [DefineClassStructure [findRelated $subRef R47 R40 R41]]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc DefineClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__ ;\n"

    set compRefs [findRelated $classRef ~R20]

    # Attributes first
    forAllRefs attrRef [findRelated $compRefs {~R21 Attribute}] {
        assignAttribute $attrRef {Name attrName} DataType
        append result "    $DataType $attrName ;\n"
    }

    # References second
    set refRefs [findRelated $compRefs {~R21 Reference}]

    # Superclass References
    forAllRefs superRef [findRelated $refRefs {~R23 SuperclassReference}] {
        assignAttribute $superRef {Name attrName}

        set superDecl [pipe {
            findRelated $superRef ~R91 R37 ~R36 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        append result "    $superDecl$attrName ;\n"
    }

    # Subclass References
    forAllRefs subRef [findRelated $refRefs {~R23 SubclassReference}] {
        assignAttribute $subRef {Name attrName}
        append result "    MRT_SuperclassRef $attrName ;\n"
    }

    # Associator Reference
    forAllRefs atorRef [findRelated $refRefs {~R23 AssociatorReference}] {
        assignAttribute $atorRef {Name attrName}

        set aclassRef [findRelated $atorRef ~R93]
        set sourceDecl [pipe {
            findRelated $aclassRef R42 ~R34 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        set targetDecl [pipe {
            findRelated $aclassRef R42 ~R35 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]

        append result\
            "    struct \{\n"\
            "        ${targetDecl}forward ;\n"\
            "        ${sourceDecl}backward ;\n"\
            "    \} $attrName ;\n"
    }

    # Association Reference
    forAllRefs assocRef [findRelated $refRefs {~R23 AssociationReference}] {
        assignAttribute $assocRef {Name attrName}

        set apcRefs [findRelated $assocRef ~R25 R90]
        set napcRefs [refMultiplicity $apcRefs]
        if {$napcRefs == 1} {
            set srcRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $srcRef]} {
                set refedRef [findRelated $srcRef R32 ~R33]
                append result [GenDirectionalReference $attrName\
                        {*}[readAttribute $refedRef Relationship Class] false]
            } else {
                set srcRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                if {[isNotEmptyRef $srcRef]} {
                    set refing [findRelated $srcRef R33 ~R32]
                    append result\
                        [GenDirectionalReference $attrName\
                            {*}[readAttribute $refedRef\
                                Relationship Class Multiplicity]]
                } else {
                    set srcRef [findRelated $apcRefs {~R38 SourceClass}]
                    if {[isNotEmptyRef $srcRef]} {
                        set assoc [findRelated $srcRef R34 ~R42]
                        set target [findRelated $srcRef R34 ~R35]
                        append result\
                            [GenDirectionalReference $attrName\
                                {*}[readAttribute $assoc Relationship Class]\
                                [readAttribute $target Multiplicity]]
                    } else {
                        set trgRef [findRelated $apcRefs {~R38 TargetClass}]
                        if {[isNotEmptyRef $trgRef]} {
                            set assoc [findRelated $trgRef R35 ~R42]
                            set source [findRelated $trgRef R35 ~R34]
                            append result\
                                [GenDirectionalReference $attrName\
                                    {*}[readAttribute $assoc Relationship Class]\
                                    [readAttribute $source Multiplicity]]
                        } else {
                            error "cannot find association participant type\
                                across R38"
                        }
                    }
                }
            }
        } elseif {$napcRefs == 2} {
            # do reflexive case
            append result "    struct \{\n"

            set refingRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $refingRef]} {
                # simple association
                set refedRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                append result "    " [GenDirectionalReference forward\
                    {*}[readAttribute $refedRef Relationship Class] false]
                append result "    " [GenDirectionalReference backward\
                    {*}[readAttribute $refingRef Relationship Class Multiplicity]]
            } else {
                set sourceRef [findRelated $apcRefs {~R38 SourceClass}]
                if {[isNotEmptyRef $sourceRef]} {
                    set targetRef [findRelated $apcRefs {~R38 TargetClass}]
                    set assocRef [findRelated $sourceRef R34 ~R42]
                    append result [GenDirectionalReference forward\
                        {*}[readAttribute $assocRef Relationship Class]\
                        [readAttribute $targetRef Multiplicity] 8]
                    append result [GenDirectionalReference backward\
                        {*}[readAttribute $assocRef Relationship Class]\
                        [readAttribute $sourceRef Multiplicity] 8]

                } else {
                    error "cannot resolve reflexive association"
                }
            }
            append result "    \} $attrName ;\n"
        } else {
            error "unexpected number of directional references, \"$napcRefs\""
        }
    }

    # Subclass container
    # Union supertypes will contain a supclass container.
    forAllRefs contRef [findRelated $compRefs {~R21 SubclassContainer}] {
        assignAttribute $contRef {Name attrName}

        set subRefs [findRelated $contRef ~R96 R44 ~R45]
        append result "    union \{\n"
        foreach subName [relation list [deRef $subRefs] Class] {
            append result "        "\
                "[GetClassProperty $subName Declaration] $subName ;\n"
        }
        append result "    \} $attrName ;\n"
    }

    # Target links
    # link pointers in classes that are referred to by classes with
    # link references.
    # Start with associator classes. They will have link containers if
    # either source or target is multiple and non-static
    set atorRef [findRelated $classRef {~R41 ClassRole} {~R40 AssociatorClass}]
    if {[isNotEmptyRef $atorRef]} {
        set sourceRef [findRelatedWhere $atorRef {R42 ~R34} {$Multiplicity}]
        if {[isNotEmptyRef $sourceRef]} {
            assignAttribute $sourceRef Class Relationship
            if {![GetAssociationProperty $Relationship IsStatic]} {
                append result "    "\
                    "MRT_LinkRef ${Relationship}_forward ;\n"
            }
        }
        set targetRef [findRelatedWhere $atorRef {R42 ~R35} {$Multiplicity}]
        if {[isNotEmptyRef $targetRef]} {
            assignAttribute $targetRef Class Relationship
            if {![GetAssociationProperty $Relationship IsStatic]} {
                append result "    "\
                    "MRT_LinkRef ${Relationship}_backward ;\n"
            }
        }
    }

    # Now simple referring classes, multiple and non-static
    set srcRef [findRelatedWhere $classRef {
        {~R41 ClassRole}
        {~R40 AssociationParticipantClass}
        {~R38 SimpleReferringClass}} {$Multiplicity}]
    if {[isNotEmptyRef $srcRef]} {
        assignAttribute $srcRef Class Relationship
        if {![GetAssociationProperty $Relationship IsStatic]} {
            append result "    MRT_LinkRef ${Relationship}_links ;\n"
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc GenDirectionalReference {name assocName reftoClass isMultiple {indent 4}} {
    set leader {    }
    if {$isMultiple} {
        if {[GetAssociationProperty $assocName IsStatic]} {
            append result\
                "struct \{\n"\
                $leader "unsigned count ;\n"\
                $leader "[GetClassProperty $reftoClass Reference]\
                        const *references;\n"\
                "\} $name ;\n"
        } else {
            set result "MRT_LinkRef $name ;\n"
        }
    } else {
        set result "[GetClassProperty $reftoClass Reference]$name ;\n"
    }

    return [indentCode $result $indent]
}
----

[source,c]
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    # makeFile {} codegen2.h
    # makeFile {} codegen2.c
    micca configure {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population test codegen2 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {MRT_SuperclassRef} codegen2.c]] == 1}\
        {[llength [fileutil::grep {struct super \*R1} codegen2.c]] == 2}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associative class references
} -setup {
    # makeFile {} codegen3.h
    # makeFile {} codegen3.c
    micca configure {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population test codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 fred1
                instance x2 R1 fred2
            }
            class Y {
                instance y1 R1 fred1
                instance y2 R1 fred2
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen3.c]] == 3}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-4.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen4.h
    # makeFile {} codegen4.c
    micca configure {
        domain codegen4 {
            class X {}
            association R1 X 0..1--0..1 X
        }
        population test codegen4 {
            class X {
                instance x1 R1 {forward x2 backward {}}
                instance x2 R1 {forward {} backward x1}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen4.c]] == 1}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-5.0 {
    Generated code file reflexive associative class references
} -setup {
    # makeFile {} codegen5.h
    # makeFile {} codegen5.c
    micca configure {
        domain codegen5 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population test codegen5 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a1
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen5.c]] == 2}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-6.0 {
    Generated code file union generalization
} -setup {
    # makeFile {} codegen6.h
    # makeFile {} codegen6.c
    micca configure {
        domain codegen6 {
            class super {}
            class sub1 {
                attribute color int -default 10
            }
            class sub2 {
                attribute temp int -default 20
            }
            generalization R1 -union super sub1 sub2

            class sub3 {
                attribute degree int -default 30
            }
            class sub4 {
                attribute yaw int -default 40
            }

            generalization R2 -union sub1 sub3 sub4

            class sub5 {
                attribute degree int -default 30
            }
            class sub6 {
                attribute degree int -default 30
            }

            generalization R3 -union sub1 sub5 sub6
        }
        population test codegen6 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R2 {sub3 s3} R3 {sub5 s5}
            }
            class sub2 {
                instance s2
            }
            class sub3 {
                instance s3
            }
            class sub5 {
                instance s5
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen6.c]] == 1}\
        {[llength [fileutil::grep {R2} codegen6.c]] == 1}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-7.0 {
    Generated code file associative class references -- non static
} -setup {
    # makeFile {} codegen7.h
    # makeFile {} codegen7.c
    micca configure {
        domain codegen7 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population test codegen7 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 fred1
                instance x2 R1 fred2
            }
            class Y {
                instance y1 R1 fred1
                instance y2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen7.c]] == 5}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-8.0 {
    Generated code file reflexive associative class references -- non static
} -setup {
    # makeFile {} codegen8.h
    # makeFile {} codegen8.c
    micca configure {
        domain codegen8 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population test codegen8 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen8.c]] == 4}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-9.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen9.h
    # makeFile {} codegen9.c
    micca configure {
        domain codegen9 {
            class X {}
            association R1 X 0..*--0..1 X
        }
        population test codegen9 {
            class X {
                instance x1 R1 {forward x2 backward {x1 x3}}
                instance x2 R1 {forward x3 backward {x1 x2}}
                instance x3 R1 {forward x1 backward {x2 x3}}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen9.c]] == 2}
} -result {1}
----


== Helper Commands

[source,c]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,c]
----
<<generation helper commands>>=
proc banner {} {
    string cat\
        "/*\n"\
        " * [string repeat - 70]\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * [string repeat - 70]\n"\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc comment {c} {
    string cat\
        "/*\n"\
        [::textutil::adjust::indent [::textutil::adjust::adjust $c] " * "]\n\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
# Remove extraneous blanks from the beginning of lines of code
# if so requested by the options.
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

== Interfacing Domain Code to the Run Time

Interfacing Domain Code to the Run Time
