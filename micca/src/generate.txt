// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time translates model level actions into ``C'' level
execution.
The run time can be compiled separately and is data driven.
The details of how a domain behaves is completely determined by the
data values supplied to the run time and the state activities and
domain operations supplied as ``C'' code.

Code generation consist of two major pieces:

* Generating initialized ``C'' variables of the type required by the run time.
* Generating ``C'' code for state activities and domain operations to
facilitate the interface to the run time.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,c]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,c]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
One is required to define things in specific orders to satisfy the
compiler.
One way to accomplish this is to use a template.
The template is orgainized in the order required by the compiler
and contains embedded commands.
When expanded the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from _tcllib_.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,c]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

[source,c]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: generate header files>>
    <<miccaGenerate: generate code files>>

    rename expand {} ; # <1>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return
}
----
<1> The template expander creates a new command so we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation errors}
----

[source,c]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror fail\
]
set options [dict merge $options $arglist]
----

[source,c]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand setbrackets %< >%
expand errmode [dict get $options expanderror]
----

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,c]
----
<<miccaGenerate: verify domains are populated>>=
set pops [pipe {
    Domain findAll |
    deRef ~ |
    relation eliminate ~ Interface Prologue Epilogue |
    relation rename ~ Name Domain |
    ralutil::rvajoin ~ $::micca::Population Populations 
}]

set badops [relation restrictwith $pops {[relation cardinality $Populations] != 1}]
relation foreach badop $badops {
    relation assign $badpop Populations
    set card [relation cardinality $Populations]
    set msg [string cat "For domain, \"$Domain\", "\
        [expr {$card == 0 ?\
            "no population is given" :\
            "$card populations are given"}]\
        ": expected exactly one population for the domain"
    log::error $msg
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

== Header Files

[source,c]
----
<<miccaGenerate: generate header files>>=
expand evalcmd "namespace eval [namespace current]::GenHeader"
----

[source,c]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

[source,c]
----
<<generation data>>=
set headerTemplate [string cat\
    %<banner>%\
    "#ifndef %<headerFileGuard>%\n"\
    "#define %<headerFileGuard>%\n"\
    %<interface>%\
    "#include <stddef.h>\n"\
    "#include <stdint.h>\n"\
    "#include <stdbool.h>\n"\
    %<typeAliases>%\
    %<domainOpDeclarations>%\
    %<portalIds>%\
    "#endif /* %<headerFileGuard>% */"\
]
----

[source,c]
----
<<miccaGenerate: generate header files>>=
forAllRefs domainRef [Domain findAll] {
    namespace upvar GenHeader\
        domain domain\
        interface interface

    assignAttribute $domainRef\
        {Name domain}\
        {Interface interface}

    variable headerTemplate

    set hchan [::open $domain.h w]
    try {
        puts $hchan [expand expand $headerTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $hchan
    }

    unset domain interface
}
----

[source,c]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return "_[string toupper [string trim $domain]]_H_"
}
----

[source,c]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    set result {}
    if {$interface ne {}} {
        append result\
            [comment "Domain Interface Contents"]\
            [indentCode [string trim $interface \n] 0]
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    makeFile {} header1.h
    makeFile {} header1.c
    micca configure {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population test header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {stdio} header1.h]
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc typeAliases {} {
    variable domain
    set aliases [pipe {
        TypeAlias findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ TypeName
    }]
    set doRefs [pipe {
        DomainOperation findWhere {$Domain eq $domain &&\
                $ReturnDataType in $aliases} |
        findRelated % R5 ~R7
    } {} |%]
    set dopRefs [pipe {
        DomainOperationParameter findWhere {$Domain eq $domain &&\
                $DataType in $aliases} |
        findRelated % R6 R5 ~R7
    } {} |%]

    set taRefs [refUnion $doRefs $dopRefs]
    set result {}
    if {[isNotEmptyRef $taRefs]} {
        append result [comment "Type Aliases"]
        forAllRefs taRef $taRefs {
            assignAttribute $taRef TypeName TypeDefinition
            append result\
                "typedef "\
                [typeCheck composeDeclaration $TypeDefinition $TypeName]\
                " \;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    makeFile {} header2.h
    makeFile {} header2.c
    micca configure {
        domain header2 {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population test header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {typedef} header2.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    set result {}
    if {[isNotEmptyRef $opRefs]} {
        append result [comment "External Declarations for Domain Operations"]

        forAllRefs opRef $opRefs {
            assignAttribute $opRef
            if {$Comment ne {}} {
                append result [comment $Comment]
            }
            append result "extern $ReturnDataType " $Domain _ $Name \(

            set params [pipe {
                findRelated $opRef ~R6 |
                deRef % |
                relation list % DataType -ascending Number |
                join % {, }
            } {} |%]
            append result $params "\) ;\n"
        }
    }
    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-3.0 {
    Generated header file domain operations
} -setup {
    makeFile {} header3.h
    makeFile {} header3.c
    micca configure {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population test header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {extern int header3_op[0-9]} header3.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    set result [comment "Numeric encoding of classes, attributes and\
            instances used by the portal functions"]
    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        assignAttribute $classRef
        append result [comment "Class: $Name"]
        set classid [string toupper ${Domain}_${Name}_CLASSID]
        append result "#define $classid $Number\n"

        set attrRefs [findRelated $classRef ~R20 {~R21 Attribute}]
        set attrNumber -1
        relation foreach attr [deRef $attrRefs] -ascending Name {
            relation assign $attr {Name attrName}
            set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
            append result "#define $attrid [incr attrNumber]\n"
        }

        set instRefs [findRelated $classRef ~R20 ~R103]
        relation foreach inst [deRef $instRefs] -ascending Number {
            relation assign $inst Instance {Number InstNumber}
            set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
            append result "#define $instid $InstNumber\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    makeFile {} header4.h
    makeFile {} header4.c
    micca configure {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population test header4 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {CLASSID} header4.h]
} -result {2}
----

== Generating Code Files

[source,c]
----
<<miccaGenerate: generate code files>>=
expand evalcmd "namespace eval [namespace current]::GenCode"
----

[source,c]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation code data>>
    <<generation code commands>>
}
----

[source,c]
----
<<generation data>>=
set codeTemplate [string cat\
    %<banner>%\
    %<prologue>%\
    %<domainInclude>%\
    "#include micca_rt.h\n"\
    %<forwardClassDeclarations>%\
    %<classDefinitions>%\
    %<epilogue>%\
]
----

[source,c]
----
<<miccaGenerate: generate code files>>=
forAllRefs domainRef [Domain findAll] {
    namespace upvar GenCode\
        domain domain\
        prologue prologue\
        epilogue epilogue

    assignAttribute $domainRef\
        {Name domain}\
        {Prologue prologue}\
        {Epilogue epilogue}

    variable codeTemplate

    PrepareClassProperties $domain

    set cchan [::open $domain.c w]
    try {
        puts $cchan [expand expand $codeTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $cchan
    }
}
----

[source,c]
----
<<generation helper commands>>=
proc PrepareClassProperties {domain} {
    variable ClassProperties

    set cpops [pipe {
        Class findWhere {$Domain eq $domain} |
        findRelated % R104 {~R101 ElementPopulation} {~R105 ClassPopulation}
    } {} |%]

    set spops [pipe {
        findRelated $cpops {~R109 StaticClassPopulation} |
        deRef % |
        relation extend % stup\
            Declaration string {"struct [tuple extract $stup Class]"}\
            Reference string {"struct [tuple extract $stup Class]\
                [expr {[tuple extract $stup IsConstant] ? "const" : {}}] *"}\
            Allocation int 0 |
        relation project % Class IsConstant Declaration Reference Allocation |
        relation rename % Class Name
    } {} |%]

    set dpops [pipe {
        findRelated $cpops {~R109 DynamicClassPopulation} |
        deRef % |
        relation extend % stup\
            IsConstant boolean {"false"}\
            Declaration string {"struct [tuple extract $stup Class]"}\
            Reference string {"struct [tuple extract $stup Class] *"} |
        relation project % Class IsConstant Declaration Reference Allocation |
        relation rename % Class Name
    } {} |%]

    set ClassProperties [relation union $spops $dpops]
    return
}

proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}
----

[source,c]
----
<<generation code commands>>=
proc prologue {} {
    variable prologue

    set result {}
    if {$prologue ne {}} {
        append result\
            [comment "Domain Prologue Begin"]\
            [indentCode [string trim $prologue \n] 0]\
            [comment "Domain Prologue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc epilogue {} {
    variable epilogue

    set result {}
    if {$epilogue ne {}} {
        append result\
            [comment "Domain Epilogue Begin"]\
            [indentCode [string trim $epilogue \n] 0]\
            [comment "Domain Epilogue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,c]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    # makeFile {} codegen1.h
    # makeFile {} codegen1.c
    micca configure {
        domain codegen1 {
            prologue {#include mySpecial.h}
            prologue {#include theSpecial.h}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population test codegen1 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {Special} codegen1.c]
} -result {2}
----

[source,c]
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc classDefinitions {} {
    variable domain

    set result [comment "Class structure definitions"]
    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        append result [DefineClassStructure $classRef]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc DefineClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__ ;\n"

    set compRefs [findRelated $classRef ~R20]

    # Attributes first
    forAllRefs attrRef [findRelated $compRefs {~R21 Attribute}] {
        assignAttribute $attrRef {Name attrName} DataType
        append result "    $DataType $attrName ;\n"
    }

    # References second
    set refRefs [findRelated $compRefs {~R21 Reference}]

    # Superclass References
    forAllRefs superRef [findRelated $refRefs {~R23 SuperclassReference}] {
        assignAttribute $superRef {Name attrName}

        set superDecl [pipe {
            findRelated $superRef ~R91 R37 ~R36 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        append result "    $superDecl$attrName ;\n"
    }

    # Subclass References
    forAllRefs subRef [findRelated $refRefs {~R23 SubclassReference}] {
        assignAttribute $subRef {Name attrName}
        append result "    MRT_SuperclassRef $attrName ;\n"
    }

    # Associator Reference
    forAllRefs atorRef [findRelated $refRefs {~R23 AssociatorReference}] {
        assignAttribute $atorRef {Name attrName}

        set aclassRef [findRelated $atorRef ~R93]
        set sourceDecl [pipe {
            findRelated $aclassRef R42 ~R34 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        set targetDecl [pipe {
            findRelated $aclassRef R42 ~R35 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]

        append result\
            "    struct \{\n"\
            "        ${targetDecl}forward ;\n"\
            "        ${sourceDecl}backward ;\n"\
            "    \} $attrName ;\n"
    }

    # Association Reference
    forAllRefs assocRef [findRelated $refRefs {~R23 AssociationReference}] {
        assignAttribute $assocRef {Name attrName}

        set apcRefs [findRelated $assocRef ~R25 R90]
        set napcRefs [refMultiplicity $apcRefs]
        if {$napcRefs == 1} {
            set srcRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $srcRef]} {
                set refedClass [pipe {
                    findRelated $srcRef R32 ~R33 |
                    readAttribute % Class
                } {} |%]
                append result\
                    [GenDirectionalReference $attrName $refedClass false]
            } else {
                set srcRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                if {[isNotEmptyRef $srcRef]} {
                    set refing [findRelated $srcRef R33 ~R32]
                    append result\
                        [GenDirectionalReference $attrName\
                            {*}[readAttribute $refing Class Multiplicity]]
                } else {
                    set srcRef [findRelated $apcRefs {~R38 SourceClass}]
                    if {[isNotEmptyRef $srcRef]} {
                        set assoc [findRelated $srcRef R34 ~R42]
                        set target [findRelated $srcRef R34 ~R35]
                        append result\
                            [GenDirectionalReference $attrName\
                                [readAttribute $assoc Class]\
                                [readAttribute $target Multiplicity]]
                    } else {
                        set trgRef [findRelated $apcRefs {~R38 TargetClass}]
                        if {[isNotEmptyRef $trgRef]} {
                            set assoc [findRelated $trgRef R35 ~R42]
                            set source [findRelated $trgRef R35 ~R34]
                            append result\
                                [GenDirectionalReference $attrName\
                                    [readAttribute $assoc Class]\
                                    [readAttribute $source Multiplicity]]
                        } else {
                            error "cannot find association participant type\
                                across R38"
                        }
                    }
                }
            }
        } elseif {$ndirRefs == 2} {
            # HERE -- do reflexive case
            set dirDecl [pipe {
                deRef $dirRefs |
                relation list ~ Name |
                GetClassProperty ~ Reference
            }]
            append result\
                "    struct \{\n"\
                "        ${dirDecl}forward ;\n"\
                "        ${dirDecl}backward ;\n"\
                "    \} $attrName ;\n"
        } else {
            error "unexpected number of directional references, \"$ndirRefs\""
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc GenDirectionalReference {name reftoClass isMultiple} {
    if {$isMultiple} {
        if {[GetClassProperty $reftoClass IsConstant]} {
            set result "    MRT_ArrayRef $name ;\n"
        } else {
            set result "    MRT_LinkRef $name ;\n"
        }
    } else {
        set result "    [GetClassProperty $reftoClass Reference]$name ;\n"
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    # makeFile {} codegen2.h
    # makeFile {} codegen2.c
    micca configure {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population test codegen2 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {MRT_SuperclassRef} codegen2.c]] == 1}\
        {[llength [fileutil::grep {struct super \*R1} codegen2.c]] == 2}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associative class references
} -setup {
    # makeFile {} codegen3.h
    # makeFile {} codegen3.c
    micca configure {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population test codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 fred1
                instance x2 R1 fred2
            }
            class Y {
                instance y1 R1 fred1
                instance y2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen3.c]] == 3}
} -result {1}
----
    

== Helper Commands

[source,c]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,c]
----
<<generation helper commands>>=
proc banner {} {
    string cat\
        "/*\n"\
        " * [string repeat - 70]\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * [string repeat - 70]\n"\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc comment {c} {
    string cat\
        "/*\n"\
        [::textutil::adjust::indent [::textutil::adjust::adjust $c] " * "]\n\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
# Remove extraneous blanks from the beginning of lines of code
# if so requested by the options.
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

== Interfacing Domain Code to the Run Time

Interfacing Domain Code to the Run Time
