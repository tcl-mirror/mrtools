// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain implementation.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time provides functions to map model level actions
onto the target platform.

The remaining component is to generate ``C'' code
Code generation consist of two major pieces:

* Generating initialized ``C'' variables that supply the data values
that are required by the run time.
* Generating ``C'' code for state activities and domain operations to
facilitate interfacing to the run time code.

`Micca` does not compile an action language into the target ``C'' for
state activities.
Rather,
it passes along the ``C'' code provided for the activities wrapped up
as functions.
However,
to insulate the user supplied ``C'' code from the details of
the run time function interfaces and the data structures used,
`micca` performs an additional level of macro expansion on the
state activities and operations code.
Thus the supplied ``C'' code contains embedded macros and these are expanded
to support interfacing to the run time and performing other
model level activities.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,tcl]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,tcl]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation support namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
Generally,
one is required to declare symbols before they are defined.
The ordering has to be quite precise.
One way to accomplish this is to use a template.
The template is orgainized in the order required by the compiler
and contains embedded commands.
When expanded,
the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from `tcllib`.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,tcl]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

Because we are using a template expansion technique to generate the code
files,
the implementation of code generation has the flavor of a report generator.
Commands imbedded in the template make queries on the populated
platform model and emit a _report_ of the query, which in this case
is a set of ``C'' language statements.
Although the reports generated are intended to be consumed by a compiler
rather than a human,
the design of the generator is very similar to generating reports
from a database.
In this case the database is the platform model and the reports are ``C'' code.

(((micca,Gen,miccaGenerate)))
[source,tcl]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: generate files>>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation error(s)}
----

We set up options for the generation in a dictionary.
The default values are given and can be overridden by those passed in.

[source,tcl]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror     fail\
    stubexternalops false\
]
set options [dict merge $options $arglist]
----

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,tcl]
----
<<miccaGenerate: verify domains are populated>>=
set badpops [pipe {
    Population findAll |
    findUnrelated ~ R100
}]

forAllRefs badpop $badpops {
    set domainName [readAttribute $badpop Name]
    log::error "for domain, \"$domainName\", no population is given"
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

The `expander` package creates a command that, when invoked with a
template, performs the expansion.
Here we set up that command and specify some options to it.

[source,tcl]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand setbrackets %< >% ; # <1>
expand errmode [dict get $options expanderror]
----
<1> The default way to embed commands in the template is with
the conventional Tcl brackets ([ ]).
Those characters are inconvenient in ``C'' so we use bracket strings
that create less interference.

[source,tcl]
----
<<miccaGenerate: generate files>>=
variable headerTemplate
variable codeTemplate

try {
    forAllRefs domainRef [Domain findAll] {
        namespace upvar GenHeader\
            domain domain\
            interface interface
        namespace upvar GenSupport\
            domain thisdomain

        assignAttribute $domainRef\
            {Name domain}\
            {Interface interface}
        set thisdomain $domain

        PrepareDomainProperties $domain

        expand evalcmd "namespace eval [namespace current]::GenHeader"
        set hchan [::open $domain.h w]
        try {
            puts $hchan [expand expand $headerTemplate]
        } on error {result opts} {
            # puts $::errorInfo
            return -options $opts $result
        } finally {
            chan close $hchan
        }

        unset domain interface

        namespace upvar GenCode\
            domain domain\
            prologue prologue\
            epilogue epilogue

        assignAttribute $domainRef\
            {Name domain}\
            {Prologue prologue}\
            {Epilogue epilogue}

        CreateActivityCommands $domain

        expand evalcmd "namespace eval [namespace current]::GenCode"
        set cchan [::open $domain.c w]
        try {
            puts $cchan [expand expand $codeTemplate]
        } on error {result opts} {
            puts $::errorInfo
            return -options $opts $result
        } finally {
            chan close $cchan
            namespace delete GenActivity
        }
    }
} finally {
    rename expand {} ; # <1>
}
----
<1> The template expander creates a new command and we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

=== Common Domain Queries

There are a number of queries about the properties of domains that
common and frequent enough to warrant factoring the queries into a
more convenient form.

We start by accumulating some common properties of a domain.
We will store these properties in a relation values that are held in
an ordinary namespace variables

(((micca,Helper,PrepareDomainProperties)))
[source,tcl]
----
<<generation helper commands>>=
proc PrepareDomainProperties {domain} {
    variable ClassProperties

    # Need to handle missing class populations.
    # Not all classes will have a ClassPopulation instance.
    set classRefs [Class findWhere {$Domain eq $domain}]
    set allocs [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} |
        deRef % |
        relation project % Class Allocation |
        relation rename % Class Name
    } {} |%]

    set insts [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation project % Class Number |
        relation rename % Class Name
    } {} |%]

    set sassigners [pipe {
        SingleAssigner findWhere {$Domain eq $domain} |
        deRef ~ |
        relation project ~ Association |
        relation rename ~ Association Name |
        relation tag ~ Number -ascending Name |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            StorageVariable string {"[tuple extract $stup Name]__POOL"}\
            Allocation int {0}\
            InitialInstance int {1}\
            TotalInstance int {1}
    }]
    set massigners [pipe {
        MultipleAssigner findWhere {$Domain eq $domain} |
        deRef ~ |
        relation tag ~ AssignerNumber -ascending Association |
        ralutil::rvajoin ~ $::micca::MultipleAssignerInstance Instances |
        ralutil::rvajoin ~ $::micca::ClassInstance Allocations |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Association]"}\
            Reference string {"struct [tuple extract $stup Association] *"}\
            StorageVariable string {"[tuple extract $stup Association]__POOL"}\
            Allocation int\
                {[relation cardinality [tuple extract $stup Allocations]]}\
            InitialInstance int\
                {[relation cardinality [tuple extract $stup Instances]]}\
            TotalInstance int\
                {[relation cardinality [tuple extract $stup Allocations]] +\
                [relation cardinality [tuple extract $stup Instances]]} |
            relation eliminate ~ Domain Class Allocations Instances |
            relation rename ~ Association Name AssignerNumber Number
    }]
    # puts [relformat $massigners massigners]

    set ClassProperties [pipe {
        deRef $classRefs |
        relation project ~ Name Number |
        relation rename ~ Number ClassNumber |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            StorageVariable string {"[tuple extract $stup Name]__POOL"} |
        ralutil::rvajoin ~ $allocs Allocations |
        relation extend ~ atup Allocation int {
            [relation isempty [tuple extract $atup Allocations]] ?\
            0 : [relation extract [tuple extract $atup Allocations] Allocation]
        } |
        relation eliminate ~ Allocations |
        ralutil::rvajoin ~ $insts Instances |
        relation extend ~ itup\
            InitialInstance int {
                [relation cardinality [tuple extract $itup Instances]]} \
            TotalInstance int {
                [relation cardinality [tuple extract $itup Instances]] +
                [tuple extract $itup Allocation]} |
        relation eliminate ~ Instances |
        relation rename ~ ClassNumber Number |
        relation union ~ $sassigners $massigners
    }]
    # puts [relformat $ClassProperties ClassProperties]


    set aprops [pipe {
        Association findWhere {$Domain eq $domain} |
        deRef ~ |
        relation join ~ $::micca::Relationship |
        relation eliminate ~ Domain
    }]
    set gprops [pipe {
        Generalization findWhere {$Domain eq $domain} |
        deRef ~ |
        relation join ~ $::micca::Relationship |
        relation eliminate ~ Domain |
        relation extend ~ gtup IsStatic boolean {"false"}
    }]

    variable RelationshipProperties [relation union $aprops $gprops]

    return
}
----

We need some procedures to access the properties.

(((micca,Helper,GetClassProperty)))
[source,tcl]
----
<<generation helper commands>>=
proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}
----

(((micca,Helper,GetRelationshipProperty)))
[source,tcl]
----
<<generation helper commands>>=
proc GetRelationshipProperty {rel prop} {
    variable RelationshipProperties
    set rprops [relation restrictwith $RelationshipProperties {$Name eq $rel}]
    if {[relation isnotempty $rprops]} {
        return [relation extract $rprops $prop]
    }

    error "unknown property, \"$prop\", for relationship, \"$rel\""
}
----

(((micca,Helper,GetClassDescriptor)))
[source,tcl]
----
<<generation helper commands>>=
proc GetClassDescriptor {domain className} {
    return ${domain}__CLASSES\[[GetClassProperty $className Number]\]
}
----

== Header Files

The header file generated for a domain contains interfacing information.
The header file is included in the generated ``C'' code file and,
typically, is included by bridge code that is
mapping the dependencies of one domain onto another.

Following our usual pattern,
we will execute the header generation commands from the template in
a child namespace to avoid any name conflicts.

The `GenHeader` namespace is a child of `::micca::@Gen@` and follows
our usual pattern of imports, command path and contents.

[source,tcl]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

The template for the header file is shown below.
Each embedded command is then shown in the following sections.

[source,tcl]
----
<<generation data>>=
set headerTemplate [textutil::adjust::undent {
    %<banner>%
    #ifndef %<headerFileGuard>%
    #define %<headerFileGuard>%
    %<interface>%
    #include <stddef.h>
    #include <stdint.h>
    #include <stdbool.h>
    %<interfaceTypeAliases>%
    %<domainOpDeclarations>%
    %<externalOpDeclarations>%
    %<eventParamDeclarations>%
    %<portalIds>%
    %<portalDeclaration>%
    #endif /* %<headerFileGuard>% */
}]
----

The generation of the header files is accomplished by iterating
over all the domains and placing the output of the template
expansion into a file.
We use some variables to provide context to the embedded expansion commands.

The commands embedded in the template all follow a similar pattern.
The return values of the commands are placed in the output of the
template expansion.

=== Header File Guard

The generated header file includes definitions of preprocessor symbols
to prevent the header file from being included multiple times.

(((micca,Header Generation,headerFileGuard)))
[source,tcl]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return [string toupper [string trim $domain]]_H_
}
----

=== Domain Interface

Arbitrary code may be placed in the generated header file by
invoking the `interface` command as part of the domain configuration.
The text provided during configuration is simply passed into the
generated header file.

(((micca,Header Generation,interface)))
[source,tcl]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    return [string cat\
        [comment "Domain Interface Contents"]\
        [textutil::adjust::undent [string trim $interface \n]]\
    ]
}
----

[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    makeFile {} header1.h
    makeFile {} header1.c
    micca configure {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {stdio} header1.h]
} -result {1}
----

=== Type Aliases

The domain configuration can contain type aliases.
Normally,
the type alias information is placed in the generated code file.
However, if a type alias name is used in a context where it would be
exposed outside of the domain,
_e.g._ as a parameter to a domain operation,
then the type alias definition is placed in the generated header file.
There are three circumstances where a type is needed external to the domain:

. As the return type or parameter type of a domain operation.
. As the return type or parameter type of an external operation.
. As an argument to an event (as events can be signaled by bridge operations).

We will have need to compute the type aliases needed by the interface
more than once, so we factor the code into a procedure.

(((micca,Helper,FindInterfaceTypeAliases)))
[source,tcl]
----
<<generation helper commands>>=
proc FindInterfaceTypeAliases {domain} {
    set domRef [Domain findWhere {$Name eq $domain}]

    <<FindInterfaceTypeAliases:: find type alias names>>
    <<FindInterfaceTypeAliases:: find aliases in domain operations>>
    <<FindInterfaceTypeAliases:: find aliases in external operations>>
    <<FindInterfaceTypeAliases:: find aliases in events>>
    <<FindInterfaceTypeAliases:: union the combination>>

    return $aliasRefs
}
----

[source,tcl]
----
<<FindInterfaceTypeAliases:: find type alias names>>=
set aliasNames [pipe {
    findRelated $domRef ~R7 |
    deRef % |
    relation list % TypeName
} {} |%]
----

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in domain operations>>=
set doRefs [pipe {
    findRelatedWhere $domRef ~R5 {$ReturnDataType in $aliasNames} |
    findRelated % R5 ~R7
} {} |%]
set dopRefs [pipe {
    findRelatedWhere $domRef {~R5 ~R6} {$DataType in $aliasNames} |
    findRelated % R6 R5 ~R7
} {} |%]
----

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in external operations>>=
set eoRefs [pipe {
    findRelatedWhere $domRef ~R10 {$ReturnDataType in $aliasNames} |
    findRelated % R10 ~R7
} {} |%]
set eopRefs [pipe {
    findRelatedWhere $domRef {~R10 ~R11} {$DataType in $aliasNames} |
    findRelated % R11 R10 ~R7
} {} |%]
----

[source,tcl]
----
<<FindInterfaceTypeAliases:: find aliases in events>>=
set argRefs [pipe {
    Argument findWhere {$Domain eq $domain && $DataType in $aliasNames} |
    deRef ~ |
    relation semijoin ~ $::micca::TypeAlias\
            -using {Domain Domain DataType TypeName} |
    ::rosea::Helpers::ToRef ::micca::TypeAlias ~
}]
----

[source,tcl]
----
<<FindInterfaceTypeAliases:: union the combination>>=
set aliasRefs [refUnion $doRefs $dopRefs]
set aliasRefs [refUnion $aliasRefs $eoRefs]
set aliasRefs [refUnion $aliasRefs $eopRefs]
set aliasRefs [refUnion $aliasRefs $argRefs]
----

The implementation of the `interfaceTypeAliases` iterates over the
type aliases that are used in the domain interfaces and emits the
corresponding ``C'' `typedef` statement.

(((micca,Header Generation,interfaceTypeAliases)))
[source,tcl]
----
<<generation header commands>>=
proc interfaceTypeAliases {} {
    variable domain
    append result [comment "Type Aliases"]
    forAllRefs taRef [FindInterfaceTypeAliases $domain] {
        assignAttribute $taRef TypeName TypeDefinition
        append result\
            "typedef "\
            [typeCheck composeDeclaration $TypeDefinition $TypeName]\
            " \;\n"
    }

    return $result
}
----

[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    makeFile {} header2.h
    makeFile {} header2.c
    micca configure {
        domain header2 {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {typedef} header2.h]
} -result {2}
----

=== Domain Operation Declarations

``C'' language programs tend to be composed of _declarations_ and
_definitions_.
A declaration makes symbol names and types known to the compile.
A definition associates specific data or code statements to a symbol.
Header files contain a lot of declarations.
Here we start with declarations for the domain operations.
Domain operations are just ordinary ``C'' functions but are given
external scope.

There are several different operations defined in the platform model.
Since they use the same attribute names,
it is possible to factor the generation of declaration code into
a common procedure.
What we need to know is are instance references to the operation
and the name of the relationship used to find the parameters of
the operation.

(((micca,Helper,GenOperationDeclarations)))
[source,tcl]
----
<<generation helper commands>>=
proc GenOperationDeclarations {opRefs paramRel {suffix {}}} {
    set result {}

    set params [deRef [findRelated $opRefs $paramRel]]
    set ops [pipe {
        deRef $opRefs |
        relation rename ~ Name Operation |
        relation join ~ $params |
        relation group ~ Parameters Name Number DataType
    }]

    relation foreach op $ops {
        relation assign $op
        if {$Comment ne {}} {
            append result [comment [string trim $Comment \n]]
        }
        append result\
            "extern $ReturnDataType "\
            $Domain _ $Operation $suffix \(\
            [join [relation list $Parameters DataType] {, }]\
            "\) ;\n"
    }

    return $result
}
----

Given a procedure to emit the operation declaration,
then the template expansion for the domain operations just invokes
the common code with the correct references and relationship name.

(((micca,Header Generation,domainOpDeclarations)))
[source,tcl]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    return [string cat\
        [comment "Domain Operations External Declarations"]\
        [GenOperationDeclarations $opRefs ~R6]\
    ]
}
----

[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-3.0 {
    Domain operation declarations in header file
} -setup {
    makeFile {} header3.h
    makeFile {} header3.c
    micca configure {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {extern int header3_op[0-9]} header3.h]
} -result {2}
----

=== External Operation Declarations

The declarations for external operations follows the same pattern as
for domain operations.

(((micca,Header Generation,externalOpDeclarations)))
[source,tcl]
----
<<generation header commands>>=
proc externalOpDeclarations {} {
    variable domain
    set opRefs [ExternalOperation findWhere {$Domain eq $domain}]

    return [string cat\
        [comment "External Operations Declarations"]\
        [GenOperationDeclarations $opRefs ~R11 __EOP]\
    ]
}
----

=== Portal Function Constants

The runtime code provides a set of functions that allow bridge code
to tunnel simple model level operations, such a signaling an event,
into a domain.
The functions require integer constants that encode identifiers
for the various entities that can be accessed via the portal.
Those constants are placed in the generated header file.

We generate information on three aspects of the domain:

. Classes
. Transitioning events
. Polymorphic events

(((micca,Header Generation,portalIds)))
[source,tcl]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    <<portalIds:: generate class information>>
    <<portalIds:: generate event information>>
    <<portalIds:: generate polymorphic event information>>

    return $result
}
----

For classes,
we generate encodings for the class itself,
its attributes and its initial instances.

[source,tcl]
----
<<portalIds:: generate class information>>=
append result [comment "Numeric encoding of classes, attributes and\
        instances used by the portal functions"]
set classRefs [Class findWhere {$Domain eq $domain}]
append result "#define [string toupper ${domain}_CLASSCOUNT]\
        [refMultiplicity $classRefs]\n"
forAllRefs classRef $classRefs {
    assignAttribute $classRef
    <<portalIds:: generate class encodings>>
    <<portalIds:: generate attribute encodings>>
    <<portalIds:: generate instance encodings>>
}
----

Each class was given a unique number within the domain when
the platform model was populated.
This is the basis for the class id encodings.

[source,tcl]
----
<<portalIds:: generate class encodings>>=
append result [comment "Class: $Name"]
set classid [string toupper ${Domain}_${Name}_CLASSID]
append result "#define $classid $Number\n"
----

Attributes are encoded in alphabetical order.
Note that the portal does not allow access to relationships or
the pointer values that are used to navigate a relationship.

[source,tcl]
----
<<portalIds:: generate attribute encodings>>=
set attrRefs [findRelated $classRef ~R20 {~R25 PopulatedComponent}\
        {~R21 Attribute}]
append result "#define [string toupper ${Domain}_${Name}_ATTRCOUNT]\
        [refMultiplicity $attrRefs]\n"
set attrNumber -1
relation foreach attr [deRef $attrRefs] -ascending Name {
    relation assign $attr {Name attrName}
    set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
    append result "#define $attrid [incr attrNumber]\n"
}
----

We generate encodings for instances that are part of the initial
instance population.

[source,tcl]
----
<<portalIds:: generate instance encodings>>=
set instRefs [findRelated $classRef ~R20 ~R103]
append result "#define [string toupper ${Domain}_${Name}_INSTCOUNT]\
        [GetClassProperty $Name TotalInstance]\n"
forAllRefs inst $instRefs {
    assignAttribute $inst Instance {Number InstNumber}
    set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
    append result "#define $instid $InstNumber\n"
}
----

[source,tcl]
----
<<portalIds:: generate event information>>=
append result [comment "Numeric encoding of event numbers\
        used by the portal functions"]
set tevents [pipe {
    TransitioningEvent findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Domain |
    relation group ~ Events Event Number
}]
relation foreach tevent $tevents -ascending Model {
    relation assign $tevent
    append result [comment "Class: $Model"]
    append result "#define [string toupper ${domain}_${Model}_EVENTCOUNT]\
        [relation cardinality $Events]\n"
    relation foreach event $Events -ascending Number {
        relation assign $event
        append result "#define\
            [string toupper ${domain}_${Model}_${Event}_EVENT] $Number\n"
    }
}
----

[source,tcl]
----
<<portalIds:: generate polymorphic event information>>=
append result [comment "Numeric encoding of polymorphic event numbers\
        used by the portal functions"]
set pevents [pipe {
    DeferredEvent findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Domain |
    relation group ~ Events Event Number
}]
relation foreach pevent $pevents -ascending Model {
    relation assign $pevent
    append result [comment "Class: $Model"]
    append result "#define [string toupper ${domain}_${Model}_POLYEVENTCOUNT]\
        [relation cardinality $Events]\n"
    relation foreach event $Events -ascending Number {
        relation assign $event
        append result "#define\
            [string toupper ${domain}_${Model}_${Event}_POLYEVENT] $Number\n"
    }
}
----

[source,tcl]
.Tests
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    makeFile {} header4.h
    makeFile {} header4.c
    micca configure {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population header4 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {CLASSID} header4.h]
} -result {2}
----

=== Portal Data Structure Declaration

The portal functions require a data structure and we must emit the
declaration of that data structure.

(((micca,Header Generation,portalDeclaration)))
[source,tcl]
----
<<generation header commands>>=
proc portalDeclaration {} {
    variable domain
    append result\
        [comment "Domain Portal Declaration"]\
        "extern MRT_DomainPortal ${domain}__PORTAL ;\n"
}
----

== Generating Code Files

In this section we describe the code used to generate the domain
code file.
We follow the pattern established for the header file.
A namespace is used to prevent any naming conflicts for the
template expansion commands.

[source,tcl]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    namespace import [namespace parent]::expand
    namespace import [namespace parent]::GenSupport::ExpandActivity

    <<generation code data>>
    <<generation code commands>>
}
----

The template for code generation is much more complicated.
In the code file we will find it necessary to emit many forward
declaration in addition to the required definitions.
For example,
it is necessary to emit forward declarations for all instance operations
since we do not know in which activity it might be invoked.

[source,tcl]
----
<<generation data>>=
set codeTemplate [textutil::adjust::undent {
    %<banner>%
    #include "micca_rt.h"
    #ifdef MRT_INSTRUMENT
        #ifndef MRT_INSTRUMENT_ENTRY
            #define MRT_INSTRUMENT_ENTRY\
            printf("%s: %s %d\n", __func__, __FILE__, __LINE__) ;
        #endif /* MRT_INSTRUMENT_ENTRY */
    #else
        #define MRT_INSTRUMENT_ENTRY
    #endif /* MRT_INSTRUMENT */
    %<domainInclude>%
    %<prologueDeclarations>%
    %<implementationTypeAliases>%
    %<forwardClassDeclarations>%
    %<forwardRelationshipDeclaration>%
    %<classDeclarations>%
    %<assignerDeclarations>%
    %<stateParamDeclarations>%
    %<operationDeclarations>%
    %<ctorDeclarations>%
    %<dtorDeclarations>%
    %<activityDeclarations>%
    %<storageDeclarations>%
    %<nameDefinitions>%
    %<iabDefinitions>%
    %<edbDefinitions>%
    %<pdbDefinitions>%
    %<classDefinitions>%
    %<assignerDefinitions>%
    %<relationshipDefinitions>%
    %<classInstanceDefinitions>%
    %<assignerInstanceDefinitions>%
    %<operationDefinitions>%
    %<ctorDefinitions>%
    %<dtorDefinitions>%
    %<activityDefinitions>%
    %<domainCtorDefinition>%
    %<domainOpDefinitions>%
    %<externalOpDefinitions>%
    %<portalDefinition>%
    %<epilogueDeclarations>%
}]
----

In the following sections, we show the procedures that are
invoked as part of the code template expansion.

=== Including the Domain Header File

(((micca,Code Generation,domainInclude)))
[source,tcl]
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,tcl]
----
<<generation code commands>>=
proc prologueDeclarations {} {
    variable prologue

    return [string cat\
        [comment "Domain Prologue"]\
        [textutil::adjust::undent [string trim $prologue \n]]\
    ]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    makeFile {} codegen1.h
    makeFile {} codegen1.c
    micca configure {
        domain codegen1 {
            prologue {#include mySpecial.h}
            prologue {#include theSpecial.h}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population codegen1 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {Special} codegen1.c]
} -result {2}
----

// HERE do something about all the copy / paste code between here and
// interfaceTypeAliases

[source,tcl]
----
<<generation code commands>>=
proc implementationTypeAliases {} {
    variable domain
    set domRef [Domain findWhere {$Name eq $domain}]
    set aliasRefs [refMinus [findRelated $domRef ~R7]\
            [FindInterfaceTypeAliases $domain]]
    append result [comment "Type Aliases"]
    forAllRefs taRef $aliasRefs {
        assignAttribute $taRef TypeName TypeDefinition
        append result\
            "typedef "\
            [typeCheck composeDeclaration $TypeDefinition $TypeName]\
            " \;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc forwardRelationshipDeclaration {} {
    variable domain
    return [string cat\
        [comment "Relationship descriptors forward declaration"]\
        "static MRT_Relationship const ${domain}__RSHIPS\[\] ;\n"\
    ]
}
----

[source,tcl]
----
<<generation code commands>>=
proc classDeclarations {} {
    variable domain

    set result [comment "Class structure declarations"]

    set ultimates [pipe {
        FindUltimateSuperclasses $domain |
        findRelated % {~R48 UnionSuperclass}
    } {} |%]
    append result [DeclareUnionSubclassStructures $ultimates]

    set remaining [FindNonUnionSubclasses $domain]
    forAllRefs classRef $remaining {
        append result [DeclareClassStructure $classRef]
    }

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc FindNonUnionSubclasses {domain} {
    set usubs [UnionSubclass findWhere {$Domain eq $domain}]
    return [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation semiminus [deRef $usubs] ~ -using {Domain Domain Class Name} |
        ::rosea::Helpers::ToRef ::micca::Class ~
    }]
}
----

[source,tcl]
----
<<generation code commands>>=
proc DeclareUnionSubclassStructures {superRefs} {
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs R44 ~R45]
    forAllRefs subRef $subRefs {
        set newsupers [pipe {
            deRef $subRef |
            relation semijoin ~ $::micca::UnionSuperclass\
                -using {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
        }]

        append result [DeclareUnionSubclassStructures $newsupers]

        append result [DeclareClassStructure [findRelated $subRef R47 R40 R41]]
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc DeclareClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__INST ;\n"

    set compRefs [findRelated $classRef ~R20]

    # Attributes first
    forAllRefs attrRef [findRelated $compRefs {~R25 PopulatedComponent}\
            {~R21 Attribute}] {
        assignAttribute $attrRef {Name attrName} DataType Dimension
        append result "    $DataType $attrName"
        if {$Dimension > 0} {
            append result "\[$Dimension\]"
        }
        append result " ;\n"
    }

    # References second
    set refRefs [findRelated $compRefs {~R25 PopulatedComponent}\
            {~R21 Reference}]

    # Superclass References
    forAllRefs superRef [findRelated $refRefs {~R23 SuperclassReference}\
            ~R91 {~R47 ReferringSubclass} R37 ~R36] {
        assignAttribute $superRef {Relationship attrName} {Class className}
        append result "    [GetClassProperty $className Reference]$attrName ;\n"
    }

    # Associator Reference
    forAllRefs atorRef [findRelated $refRefs {~R23 AssociatorReference}\
            ~R93 R42] {
        assignAttribute $atorRef {Name attrName}

        set sourceDecl [pipe {
            findRelated $atorRef ~R34 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        set targetDecl [pipe {
            findRelated $atorRef ~R35 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]

        append result\
            "    struct \{\n"\
            "        ${targetDecl}forward ;\n"\
            "        ${sourceDecl}backward ;\n"\
            "    \} $attrName ;\n"
    }

    # Association Reference
    forAllRefs assocRef [findRelated $refRefs {~R23 AssociationReference}\
            ~R90 R32 ~R33] {
        assignAttribute $assocRef {Relationship attrName} {Class className}
        append result "    [GetClassProperty $className Reference]$attrName ;\n"
    }

    set genRefs [findRelated $compRefs {~R25 GeneratedComponent}]

    # Subclass References
    forAllRefs subRef [findRelated $genRefs {~R24 SubclassReference}] {
        assignAttribute $subRef {Name attrName}
        append result "    void *$attrName ;\n"
    }

    # Subclass container
    # Union supertypes will contain a superclass container.
    forAllRefs contRef [findRelated $genRefs {~R24 SubclassContainer}] {
        assignAttribute $contRef {Name attrName}

        set subRefs [findRelated $contRef ~R96 R44 ~R45]
        append result "    union \{\n"
        foreach subName [relation list [deRef $subRefs] Class] {
            append result "        "\
                "[GetClassProperty $subName Declaration] $subName ;\n"
        }
        append result "    \} $attrName ;\n"
    }

    # Link Containers
    forAllRefs linkRef [findRelated $genRefs {~R24 LinkContainer}] {
        append result "    MRT_LinkRef [readAttribute $linkRef Name] ;\n"
    }

    # Complementary References
    forAllRefs complRef [findRelated $genRefs {~R24 ComplementaryReference}] {
        set singRef [findRelated $complRef {~R26 SingularReference} R26]
        if {[isNotEmptyRef $singRef]} {
            append result [SingularReferenceMember $singRef]
            continue
        }

        set arrayRef [findRelated $complRef {~R26 ArrayReference} R26]
        if {[isNotEmptyRef $arrayRef]} {
            append result [ArrayReferenceMember $arrayRef]
            continue
        }

        set linkRef [findRelated $complRef {~R26 LinkReference} R26]
        if {[isNotEmptyRef $linkRef]} {
            append result [LinkReferenceMember $linkRef]
            continue
        }
    }

    append result "\} ;\n"
}
----

[source,tcl]
----
<<generation helper commands>>=
proc SingularReferenceMember {singRef} {
    set attrName [readAttribute $singRef Name]
    set refedClass [FindReferencedClass $singRef]
    return "    [GetClassProperty $refedClass Reference]$attrName ;\n"
}
----

[source,tcl]
----
<<generation helper commands>>=
proc ArrayReferenceMember {arrayRef} {
    set attrName [readAttribute $arrayRef Name]
    set classref [GetClassProperty [FindReferencedClass $arrayRef] Reference]
    return [indentCode [string cat\
        "struct \{\n" [indentCode [string cat\
            "${classref}const *links ;\n"\
            "unsigned count ;\n"]]\
        "\} $attrName ;\n"]]
}
----

[source,tcl]
----
<<generation helper commands>>=
proc LinkReferenceMember {linkRef} {
    set attrName [readAttribute $linkRef Name]
    return "    MRT_LinkRef $attrName ;\n"
}
----

[source,tcl]
----
<<generation helper commands>>=
proc FindReferencedClass {compRef} {
    set destRef [findRelated $compRef {~R28 BackwardReference} ~R94]

    # backward, simple
    set refing [findRelated $destRef {~R38 SimpleReferencedClass} R33 ~R32]
    if {[isNotEmptyRef $refing]} {
        set refedClass [readAttribute $refing Class]
    } else {
        # backward, target
        set src [findRelated $destRef {~R38 TargetClass} R35 ~R42]
        if {[isNotEmptyRef $src]} {
            set refedClass [readAttribute $src Class]
        } else {
            # forward, source
            set trg [findRelated $compRef {~R28 ForwardReference} ~R95 R34 ~R42]
            if {[isNotEmptyRef $trg]} {
                set refedClass [readAttribute $trg Class]
            }
        }
    }
    return $refedClass
}
----

[source,tcl]
----
<<generation code commands>>=
proc assignerDeclarations {} {
    variable domain
    set result {}

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    append result [comment "Single Assigner Structure Declarations"]

    forAllRefs assigner $singles {
        assignAttribute $assigner
        append result\
            "struct $Association \{\n"\
            "    MRT_Instance base__INST ;\n"\
            "\} ;\n"
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    append result [comment "Multiple Assigner Structure Declarations"]

    forAllRefs assigner $multis {
        assignAttribute $assigner
        append result\
            "struct $Association \{\n"\
            "    MRT_Instance base__INST ;\n"\
            "    [GetClassProperty $Class Reference] idinstance ;\n"\
            "\} ;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    # makeFile {} codegen2.h
    # makeFile {} codegen2.c
    micca configure {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population codegen2 {
            class super {
                instance fred1
                instance fred2
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {struct super \*R1} codegen2.c]] == 2}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associative class references
} -setup {
    # makeFile {} codegen3.h
    # makeFile {} codegen3.c
    micca configure {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -static -associator A X 0..*--0..* Y
        }
        population codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen3.c]] == 27}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-20.0 {
    Generated code file associative class references
} -setup {
    # makeFile {} codegen20.h
    # makeFile {} codegen20.c
    micca configure {
        domain codegen20 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..1--0..1 Y
        }
        population codegen20 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen20.c]] == 19}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-4.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen4.h
    # makeFile {} codegen4.c
    micca configure {
        domain codegen4 {
            class X {}
            association R1 X 0..1--0..1 X
        }
        population codegen4 {
            class X {
                instance x1 R1 x2
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen4.c]] == 12}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-5.0 {
    Generated code file reflexive associative class references
} -setup {
    # makeFile {} codegen5.h
    # makeFile {} codegen5.c
    micca configure {
        domain codegen5 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen5 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen5.c]] == 37}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-21.0 {
    Generated code file reflexive associative class references -- static
} -setup {
    # makeFile {} codegen21.h
    # makeFile {} codegen21.c
    micca configure {
        domain codegen21 {
            class A {}
            class X {}
            association R1 -static -associator A X 0..*--0..* X
        }
        population codegen21 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen21.c]] == 21}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-6.0 {
    Generated code file union generalization
} -setup {
    # makeFile {} codegen6.h
    # makeFile {} codegen6.c
    micca configure {
        domain codegen6 {
            class super {}
            class sub1 {
                attribute color int -default 10
            }
            class sub2 {
                attribute temp int -default 20
            }
            generalization R1 -union super sub1 sub2

            class sub3 {
                attribute degree int -default 30
            }
            class sub4 {
                attribute yaw int -default 40
            }

            generalization R2 -union sub1 sub3 sub4

            class sub5 {
                attribute degree int -default 30
            }
            class sub6 {
                attribute degree int -default 30
            }

            generalization R3 -union sub1 sub5 sub6

            class X {}
            association R4 X 1--1 sub5
        }
        population codegen6 {
            class super {
                instance fred1
                instance fred2
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
            class sub3 {
                instance s3 R2 s1
            }
            class sub5 {
                instance s5 R3 s1
            }
            class X {
                instance x1 R4 s5
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen6.c]] == 13}\
        {[llength [fileutil::grep {R2} codegen6.c]] == 11}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-7.0 {
    Generated code file associative class references -- non static
} -setup {
    # makeFile {} codegen7.h
    # makeFile {} codegen7.c
    micca configure {
        domain codegen7 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population codegen7 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x1 Y y2}
                instance a4 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen7.c]] == 48}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-8.0 {
    Generated code file reflexive associative class references -- non static
} -setup {
    # makeFile {} codegen8.h
    # makeFile {} codegen8.c
    micca configure {
        domain codegen8 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen8 {
            class A {
                instance a12 R1 {forward x2 backward x1}
                instance a13 R1 {forward x3 backward x1}
                instance a23 R1 {forward x3 backward x2}
                instance a24 R1 {forward x4 backward x2}
                instance a34 R1 {forward x4 backward x3}
                instance a41 R1 {forward x1 backward x4}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen8.c]] == 72}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-9.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen9.h
    # makeFile {} codegen9.c
    micca configure {
        domain codegen9 {
            class X {}
            association R1 X 0..*--0..1 X
        }
        population codegen9 {
            class X {
                instance x1 R1 x2
                instance x2 R1 x3
                instance x3 R1 x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {LINKS} codegen9.c]] == 13}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-22.0 {
    Generate a single assigner
} -setup {
    # makeFile {} codegen22.h
    # makeFile {} codegen22.c
    micca configure {
        domain codegen22 {
            class clerk {}
            class client {}
            association R1 clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
        }
        population codegen22 {
            class clerk {
                allocate 2
            }
            class client {
                allocate 3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1__POOL} codegen22.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-23.0 {
    Generate a multi assigner
} -setup {
    # makeFile {} codegen23.h
    # makeFile {} codegen23.c
    micca configure {
        domain codegen23 {
            class clerk {}
            class client {}
            association R1 clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {}
            association R2 department 1..*--1 clerk
        }
        population codegen23 {
            class department {
                instance mens R2 fred
                instance children R2 fred
                instance womens R2 alice
                instance sports R2 biff
            }
            class clerk {
                instance fred
                instance alice
                instance biff
            }
            class client {
                allocate 3
            }
            assigner R1 {
                instance mens mens
                instance children children
                instance womens womens
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1__POOL} codegen23.c]] == 5}
} -result {1}
----

[source,tcl]
----
<<generation header commands>>=
proc eventParamDeclarations {} {
    variable domain
    set result {}

    set tevents [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        findRelated ~ R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    append result [comment "Transition Event Parameter Structure\
            Declarations"]
    relation foreach tevent $tevents -ascending Model {
        relation assign $tevent
        relation foreach event $Events {
            relation assign $event
            append result\
                "struct ${domain}_${Model}_${Event}__EPARAMS \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
        }
    }

    set pevents [pipe {
        PolymorphicEvent findWhere {$Domain eq $domain} |
        findRelated ~ R81 R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    append result [comment "Polymorphic Event Parameter Structure\
            Declarations"]
    relation foreach tevent $pevents -ascending Model {
        relation assign $tevent
        relation foreach event $Events {
            relation assign $event
            append result\
                "struct ${domain}_${Model}_${Event}__PEPARAMS \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc stateParamDeclarations {} {
    variable domain
    set result {}

    set stateargs [pipe {
        State findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name State |
        relation join $::micca::ParameterSignature $::micca::Parameter\
                $::micca::Argument |
        relation project ~ Model State Name Position DataType |
        relation group ~ Params Name Position DataType
    }]

    if {[relation isnotempty $stateargs]} {
        append result [comment "State Parameter Structure Declarations"]
        relation foreach statearg $stateargs -ascending {Model State} {
            relation assign $statearg
            append result "struct ${Model}_${State}__SPARAMS \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-10.0 {
    Generated event parameter structures
} -setup {
    # makeFile {} codegen10.h
    # makeFile {} codegen10.c
    micca configure {
        domain codegen10 {
            typealias MyCount int
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            class super {
                polymorphic e1 f MyCount g {char *}
                polymorphic e2
            }
            class sub1 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            class sub2 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            generalization R1 super sub1 sub2
        }
        population codegen10 {
            class X {
                instance x1 color 30
            }
            class super {
                instance sup1
                instance sup2
            }
            class sub1 {
                instance s1 R1 sup1
            }
            class sub2 {
                instance s2 R1 sup2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {__EPARAMS} codegen10.h]] == 3}\
        {[llength [fileutil::grep {__PEPARAMS} codegen10.h]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation code commands>>=
proc operationDeclarations {} {
    variable domain
    set result {}

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Operation Forward Declarations"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "static $ReturnDataType ${Class}_$Operation\("

            if {[relation isempty $Parameters]} {
                append result void
            } else {
                append result [join\
                    [relation list $Parameters DataType -ascending Number] {, }]
            }

            append result "\) ;\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-11.0 {
    Generated code file with class operations
} -setup {
    # makeFile {} codegen11.h
    # makeFile {} codegen11.c
    micca configure {
        domain codegen11 {
            class X {
                attribute color int -default 20

                classop int count {} {
                    return 42 ;
                }

                instop void addColor {amount int} {
                    self->color += amount ;
                }
            }
        }
        population codegen11 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X_count} codegen11.c]] == 2}\
        {[llength [fileutil::grep {X_addColor} codegen11.c]] == 2}
} -result {1}
----

[source,tcl]
----
<<generation code commands>>=
proc ctorDeclarations {} {
    variable domain
    set result {}

    set ctors [Constructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $ctors]} {
        append result [comment "Class Constructor Forward Declarations"]
        forAllRefs ctor $ctors {
            assignAttribute $ctor {Class className}
            append result\
                "static void ${className}__CTOR\(void *const) ;\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc dtorDeclarations {} {
    variable domain
    set result {}

    set dtors [Destructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $dtors]} {
        append result [comment "Class Destructor Forward Declarations"]
        forAllRefs dtor $dtors {
            assignAttribute $dtor {Class className}
            append result\
                "static void ${className}__DTOR\(void *const) ;\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc activityDeclarations {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && [string trim $Activity] ne {}} |
        deRef ~ |
        relation eliminate ~ Domain Activity IsTerminal PSigID |
        relation group ~ States Name
    }]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Forward Declarations"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            relation foreach state $States {
                relation assign $state
                append result "static void ${Model}_${Name}__ACTIVITY\("\
                    "void *const s__SELF, "\
                    "void const *const p__PARAMS) ;\n"
            }
        }
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc storageDeclarations {} {
    variable domain
    set result {}

    set cpops [pipe {
        FindNonUnionSubclasses $domain |
        findRelated % R104 {~R101 ElementPopulation} {~R105 ClassPopulation}
    } {} |%]

    if {[isNotEmptyRef $cpops]} {
        append result [comment "Class Instance Storage Forward Declarations"]
        forAllRefs cpop $cpops {
            assignAttribute $cpop {Allocation allocation} {Class className}
            set insts [refMultiplicity [findRelated $cpop ~R102]]
            set total [expr {$allocation + $insts}]
            append result "static struct $className "\
                [GetClassProperty $className StorageVariable]\
                "\[[GetClassProperty $className TotalInstance]\] ;\n"
        }
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        set total [refMultiplicity [findRelated $multi R54 ~R20 ~R103]]
        assignAttribute $multi Association
        append result "static struct ${Association}\
            ${Association}__POOL\[$total\] ;\n"
    }

    return $result
}
----

Put out all the naming information.

[source,tcl]
----
<<generation code commands>>=
proc nameDefinitions {} {
    variable domain
    append result\
        [comment "Domain Naming Definitions"]\
        "#ifndef MRT_NO_NAMES\n"

    set storageType "static char const"

    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        set className [readAttribute $classRef Name]
        append result "$storageType ${className}__NAME\[\] = \"$className\" ;\n"
    }

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    forAllRefs relRef $relRefs {
        set relName [readAttribute $relRef Name]
        append result "$storageType ${relName}__NAME\[\] = \"$relName\" ;\n"
    }

    set stateRefs [StatePlace findWhere {$Domain eq $domain}]
    forAllRefs stateRef $stateRefs {
        assignAttribute $stateRef {Model modelName} {Name stateName}
        set namevar [expr {$stateName eq "@" ? "AT" : $stateName}]
        append result "$storageType ${modelName}_${namevar}__SNAME\[\] =\
                \"$stateName\" ;\n"
    }

    set eventRefs [Event findWhere {$Domain eq $domain}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Model modelName} {Event eventName}
        append result "$storageType ${modelName}_${eventName}__ENAME\[\] =\
                \"$eventName\" ;\n"
    }

    set maRefs [MultipleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $maRefs]} {
        append result "$storageType multi_assigner_attribute__NAME\[\] =\
                \"idinstance\" ;\n"
    }

    append result "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc iabDefinitions {} {
    variable domain
    set result [comment "Instance Allocation Block Definitions"]

    forAllRefs classRef [FindNonUnionSubclasses $domain] {
        append result [DefineIABMembers $classRef false]
    }

    set unionRefs [pipe {
        UnionSubclass findWhere {$Domain eq $domain} |
        findRelated ~ R47 R40 R41
    }]
    forAllRefs classRef $unionRefs {
        append result [DefineIABMembers $classRef true]
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        set total [refMultiplicity [findRelated $multi R54 ~R20 ~R103]]
        set initial [refMultiplicity [findRelated $multi ~R106]]

        assignAttribute $multi
        append result\
            "static MRT_iab ${Association}__IAB = \{\n"\
            "    .storageStart = &${Association}__POOL\[0\],\n"\
            "    .storageFinish = &${Association}__POOL\[$total\],\n"\
            "    .storageLast = &${Association}__POOL\[[expr {$total - 1}]\],\n"\
            "    .alloc = [expr {$initial + 1}],\n"\
            "    .instanceSize = sizeof\(struct ${Association}\),\n"\
            "    .construct = NULL,\n"\
            "    .destruct = NULL,\n"\
            "    .linkCount = 0,\n"\
            "    .linkOffsets = NULL\n"\
            "\} ;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc DefineIABMembers {classRef isUnionSubclass} {
    assignAttribute $classRef {Name className}

    set linkRefs [findRelated $classRef ~R20 {~R25 GeneratedComponent}\
        {~R24 ComplementaryReference} {~R26 LinkReference}]
    if {[isEmptyRef $linkRefs]} {
        set linkOffsets NULL
    } else {
        set linkOffsets ${className}__LINKS
        append result\
            "static MRT_AttrOffset const $linkOffsets\[\] = \{\n"
        set linkMembers [relation list [deRef $linkRefs] Name]
        foreach linkMember $linkMembers {
            append result\
                "    "\
                "offsetof\([GetClassProperty $className Declaration],\
                $linkMember\),\n"
        }
        append result "\} ;\n"
    }

    append result\
        "static MRT_iab ${className}__IAB = \{\n"

    if {$isUnionSubclass} {
        append result\
            "    .storageStart = NULL,\n"\
            "    .storageFinish = NULL,\n"\
            "    .storageLast = NULL,\n"
    } else {
        set nelements [GetClassProperty $className TotalInstance]
        append result\
            "    .storageStart = &${className}__POOL\[0\],\n"\
            "    .storageFinish = &${className}__POOL\[$nelements\],\n"\
            "    .storageLast = &${className}__POOL\[[expr {$nelements - 1}]\],\n"
    }
    set ctor [pipe {
        findRelated $classRef ~R8 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__CTOR"}
    } {} |%]
    set dtor [pipe {
        findRelated $classRef ~R9 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__DTOR"}
    } {} |%]
    append result\
        "    .alloc = [expr {[GetClassProperty $className InitialInstance]\
                    + 1}],\n"\
        "    .instanceSize = sizeof\([GetClassProperty $className Declaration]\),\n"\
        "    .construct = $ctor,\n"\
        "    .destruct = $dtor,\n"\
        "    .linkCount = [refMultiplicity $linkRefs],\n"\
        "    .linkOffsets = $linkOffsets\n"\
        "\} ;\n"

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc edbDefinitions {} {
    variable domain
    set result [comment "Event Dispatch Block Definitions"]

    upvar #0 ::micca::@Gen@::options options

    forAllRefs smodel [StateModel findWhere {$Domain eq $domain}] {
        assignAttribute $smodel {Model className}

        append result [GenerateTransitionTable $smodel]
        append result [GenerateActivityTable $smodel]
        set termstates [GenerateTerminalStates $smodel result]

        append result [GenerateModelNames $smodel]

        append result "static MRT_edb const ${className}__EDB = \{\n"

        set stateRefs [findRelated $smodel ~R55]
        set cstateRef [findRelated $smodel ~R56]
        append result\
            "    .stateCount = [expr {[refMultiplicity $stateRefs] +\
                [refMultiplicity $cstateRef]}],\n"

        set eventRefs [findRelated $smodel ~R87]
        append result\
            "    .eventCount = [refMultiplicity $eventRefs],\n"\
            "    .initialState = [readAttribute [findRelated $smodel R58 R57]\
                        Number],\n"
        set crstate [expr {[isNotEmptyRef $cstateRef] ?\
            [readAttribute [findRelated $cstateRef R57] Number] :\
            "MRT_StateCode_IG"}]
        append result\
            "    .creationState = $crstate,\n"\
            "    .transitionTable = ${className}__TTAB,\n"\
            "    .activityTable = ${className}__ATAB,\n"\
            "    .terminalStates = $termstates,\n"

        append result\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .stateNames = ${className}__SNAMES,\n"\
            "    .eventNames = ${className}__ENAMES,\n"\
            "        #endif /* MRT_NO_NAMES */\n"

        append result\
            "\} ;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateTransitionTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        findRelated $smodel ~R55 |
        deRef % |
        relation rename % Name State |
        relation eliminate % Activity IsTerminal PSigID
    } {} |%]
    set cstate [pipe {
        findRelated $smodel ~R56 |
        deRef % |
        relation rename % Name State
    } {} |%]
    set states [relation union $states $cstate]
    # puts [relformat $states states]

    set events [pipe {
        findRelated $smodel ~R87 |
        deRef %
    } {} |%]
    # puts [relformat $events events]

    set alltrans [pipe {
        relation eliminate $events Number |
        relation join $states ~
    }]
    # puts [relformat $alltrans alltrans]

    set statetrans [pipe {
        StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation eliminate ~ ASigID
    }]
    # puts [relformat $statetrans statetrans]
    set nontrans [pipe {
        Non-StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ TransRule NewState
    }]
    # puts [relformat $nontrans nontrans]

    set deftrans [pipe {
        TransitionPlace findAll |
        deRef ~ |
        relation minus $alltrans ~ |
        relation join ~ [deRef [StateModel findAll]] |
        relation eliminate ~ InitialState |
        relation rename ~ DefaultTrans NewState |
        relation update ~ dttup {[tuple extract $dttup State] eq "@"} {
                tuple update $dttup NewState CH}
    }]
    # puts [relformat $deftrans deftrans]

    set ntstates [pipe {
        TransitionRule findAll |
        deRef ~ |
        relation rename ~ Name State |
        relation extend ~ nttup\
            Domain string {$domain}\
            Model string {$className}\
            StateNumber string {"MRT_StateCode_[tuple extract $nttup State]"}
    }]
    # puts [relformat $ntstates ntstates]

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ Name State Number StateNumber |
        relation union ~ $ntstates
    }]
    # puts [relformat $places places]
    set transitions [pipe {
        relation union $statetrans $nontrans $deftrans |
        relation join ~ $places\
            -using {Domain Domain Model Model NewState State} |
        relation rename ~ StateNumber NewStateNumber |
        relation join ~ $places $events |
        relation eliminate ~ Domain Model
    }]
    # puts [relformat $transitions transitions]

    set result "static MRT_StateCode const ${className}__TTAB\[\] = \{\n"
    relation foreach transition $transitions -ascending {StateNumber Number} {
        relation assign $transition
        append result "    $NewStateNumber, // $State - $Event -> $NewState\n"
    }
    append result "\} ;\n"

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-12.0 {
    Generated code file with state model
} -setup {
    # makeFile {} codegen12.h
    # makeFile {} codegen12.c
    micca configure {
        domain codegen12 {
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {} {
                        printf("In s1\n") ;
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                    }
                    transition s2 - e1 -> IG
                    transition s2 - e2 -> s3

                    state s3 {} {
                    }
                    transition s3 - e3 -> s1

                    terminal s3
                }
            }
        }
        population codegen12 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X__TTAB} codegen12.c]] == 2}\
        {[llength [fileutil::grep {X__ATAB} codegen12.c]] == 2}
} -result {1}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateActivityTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set result "static MRT_PtrActivityFunction const ${className}__ATAB\[\] = \{\n"

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name Activity
            if {[string trim $Activity] eq {}} {
                append result "    NULL, // $Name\n"
            } else {
                append result "    ${className}_${Name}__ACTIVITY, // $Name\n"
            }
        } else {
            set cstate [relation semijoin $place $::micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    NULL, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateTerminalStates {smodel resultVar} {
    set tstates [findRelatedWhere $smodel ~R55 {$IsTerminal}]
    if {[isEmptyRef $tstates]} {
        return NULL
    }
    upvar 1 $resultVar result
    variable domain
    assignAttribute $smodel {Model className}
    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static bool const ${className}__TSTATES\[\] = \{\n"
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name IsTerminal
            append result "    "\
                [expr {$IsTerminal ? "true" : "false"}]\
                ", // $Name\n"
        } else {
            set cstate [relation semijoin $place $::micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    false, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
    return ${className}__TSTATES
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenerateModelNames {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result\
        "#ifndef MRT_NO_NAMES\n"\
        "static char const * const ${className}__SNAMES\[\] = \{\n"

    relation foreach state $states -ascending Number {
        relation assign $state Name
        set Name [string map {@ AT} $Name]
        append result "    ${className}_${Name}__SNAME,\n"
    }
    append result "\} ;\n"

    set events [pipe {
        TransitioningEvent findWhere\
                {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static char const * const ${className}__ENAMES\[\] = \{\n"
    relation foreach event $events -ascending Number {
        relation assign $event Event
        append result "    ${className}_${Event}__ENAME,\n"
    }
    append result\
        "\} ;\n"\
        "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc pdbDefinitions {} {
    variable domain

    set enames {}
    set rnames {}
    set pmaps {}
    set gdbs {}
    set pdbs {}

    set deRefs [DeferredEvent findWhere {$Domain eq $domain}]
    set superRefs [findRelated $deRefs ~R86]
    if {[isEmptyRef $superRefs]} {
        return
    }

    set deferred [pipe {
        findRelated $superRefs {R86 DeferralPath} |
        deRef ~ |
        relation join ~ $::micca::DeferredEvent |
        relation eliminate ~ Domain Role |
        relation rename ~ Model Superclass Number SuperNumber
    }]
    # puts [relformat $deferred deferred]

    set nonlocals [pipe {
        Non-LocalEvent findWhere {$Domain eq $domain} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Number RelNumber
    } {} |%]
    # puts [relformat $nonlocals nonlocals]

    set polys [pipe {
        relation join $nonlocals $::micca::DeferredEvent |
        relation extend ~ ptup Type string {"mrtPolymorphicEvent"}
    }]
    # puts [relformat $polys polys]

    set trans [pipe {
        relation join $nonlocals $::micca::TransitioningEvent |
        relation extend ~ ptup Type string {"mrtTransitionEvent"}
    }]
    # puts [relformat $trans trans]

    set supers [pipe {
        relation union $polys $trans |
        relation eliminate ~ Domain Role |
        relation join ~ $deferred |
        relation group ~ EventMap Event SuperNumber Number Type |
        relation group ~ SubMap Model EventMap |
        relation group ~ Generalizations Relationship RelNumber SubMap
    }]
    # puts [relformat $supers supers]

    relation foreach super $supers {
        relation assign $super

        set gdbvar ${Superclass}__GDBS
        append gdbs "static MRT_gdb $gdbvar\[\] = \{\n"

        set rnamesvar ${Superclass}__RNAMES
        append rnames "static char const *const $rnamesvar\[\] = \{\n"

        relation foreach gen $Generalizations -ascending Relationship {
            relation assign $gen

            append rnames "    ${Relationship}__NAME,\n"

            set pmapvar ${Superclass}_${Relationship}__PMAP
            append pmaps "static MRT_PolyEventMap const $pmapvar\[\] = \{\n"

            relation foreach submap $SubMap -ascending Model {
                relation assign $submap
                relation foreach eventmap $EventMap {
                    relation assign $eventmap
                    append pmaps\
                        "    "\
                        "\{.event = $Number, .eventType = $Type\},"\
                        "// $Event for $Model\n"
                }
            }
            append pmaps "\} ;\n"

            append gdbs\
                "    \{\n"\
                "        .relship = &${domain}__RSHIPS\[$RelNumber\],\n"\
                "        .eventMap = $pmapvar,\n"\
                "    \},\n"
        }
        append rnames "\} ;\n"
        append gdbs "\} ;\n"

        set enamesvar ${Superclass}__PENAMES
        append enames "static char const *const $enamesvar\[\] = \{\n"
        relation foreach eventmap $EventMap {
            relation assign $eventmap Event
            append enames "    ${Superclass}_${Event}__ENAME,\n"
        }
        append enames "\} ;\n"

        append pdbs\
            "static MRT_pdb const ${Superclass}__PDB = \{\n"\
            "    .eventCount = [relation cardinality $SubMap],\n"\
            "    .genCount = [relation cardinality $Generalizations],\n"\
            "    .genDispatch = $gdbvar,\n"\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .eventNames = $enamesvar,\n"\
            "    .genNames = $rnamesvar,\n"\
            "        #endif /* MRT_NO_NAMES */\n"\
            "\} ;\n"
    }


    append result\
        [comment "Polymorphic Event Dispatch Block Definitions"]\
        "#ifndef MRT_NO_NAMES\n"\
        $enames $rnames\
        "#endif /* MRT_NO_NAMES */\n"\
        $pmaps $gdbs $pdbs

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-13.0 {
    polymorphic events -- inject polymorphic event mid-level
} -setup {
    # makeFile {} codegen13.h
    # makeFile {} codegen13.c
    micca configure {
        domain codegen13 {
            class S {
                polymorphic e1
                polymorphic e2
                polymorphic a1
            }
            class X {
                polymorphic a3
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    transition s1 - a1 ->  s1
                }
            }
            class Y {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - a1 -> s1
                }
            }
            generalization R1 -union S X Y

            class F {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - f1 -> s1
                    transition s2 - a1 -> s2
                }
            }
            class G {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - g1 -> s1
                    transition s2 - a1 -> s2
                }
            }

            generalization R3 -union S F G

            class A {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            class B {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            generalization R2 -union X A B
        }
        population codegen13 {
            class S {
                instance s1
                instance s2
                instance s3
            }
            class X {
                instance x1 R1 s1
                instance x2 R1 s3
            }
            class Y {
                instance y1 R1 s2
            }
            class A {
                instance a1 R2 x1
            }
            class B {
                instance b1 R2 x2
            }
            class F {
                instance f1 R3 s1
                instance f2 R3 s2
            }
            class G {
                instance g1 R3 s3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-14.0 {
    Generated code file simple references -- non static
} -setup {
    # makeFile {} codegen14.h
    # makeFile {} codegen14.c
    micca configure {
        domain codegen14 {
            class X {}
            class Y {}
            association R1 X 1..*--1 Y
        }
        population codegen14 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen14.c]] == 22}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-15.0 {
    Generated code file simple references -- static
} -setup {
    # makeFile {} codegen15.h
    # makeFile {} codegen15.c
    micca configure {
        domain codegen15 {
            class X {}
            class Y {}
            association R1 -static X 1..*--1 Y
        }
        population codegen15 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen15.c]] == 10}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-16.0 {
    many to 1 associative relationship
} -setup {
    # makeFile {} codegen16.h
    # makeFile {} codegen16.c
    micca configure {
        domain codegen16 {
            class A {
            }
            class X {
            }
            class Y {
            }

            association R1 -associator A X 1..*--0..1 Y
        }

        population codegen16 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x3 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {}
----

[source,tcl]
----
<<generation code commands>>=
proc classDefinitions {} {
    variable domain
    set front [comment "Class Description Definitions"]

    set classRefs [Class findWhere {$Domain eq $domain}]

    set classinrel [pipe {
        findRelated $classRefs {~R41 ClassRole} |
        deRef % |
        relation eliminate % Role
    } {} |%]
    set assocrels [pipe {
        relation join $classinrel $::micca::Association -using\
            {Domain Domain Relationship Name} |
        relation eliminate ~ IsStatic
    }]
    set genrels [relation join $classinrel $::micca::Generalization\
            -using {Domain Domain Relationship Name}]

    set rels [pipe {
        relation union $assocrels $genrels |
        relation join ~ $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename ~ Class Name Number RelNumber
    }]
    # puts [relformat $rels rels]

    set attrs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Attribute} |
        deRef % |
        relation rename % Name Attribute Class Name
    } {} |%]
    # puts [relformat $attrs attrs]

    set usubs [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 Subclass}\
            {~R47 UnionSubclass} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number SuperNumber |
        relation eliminate % Role Relationship
    } {} |%]
    # puts [relformat $usubs usubs]

    set classes [pipe {
        deRef $classRefs |
        relation extend ~ ctup IAB string {"&[tuple extract $ctup Name]__IAB"} |
        ralutil::rvajoin ~\
            [relation rename $::micca::StateModel Model Name] SModel |
        relation extend ~ etup EDB string {
            [relation cardinality [tuple extract $etup SModel]] == 0 ?\
            "NULL" : "&[tuple extract $etup Name]__EDB"} |
        ralutil::rvajoin ~\
            [relation rename $::micca::DeferredEvent Model Name Number EvtNum]\
                PEvents |
        relation extend ~ ptup PDB string {
            [relation cardinality [tuple extract $ptup PEvents]] == 0 ?\
            "NULL" : "&[tuple extract $ptup Name]__PDB"} |
        relation eliminate ~ SModel PEvents |
        ralutil::rvajoin ~ $rels Relationships |
        relation extend ~ rtup\
            relCount int {
                [relation cardinality [tuple extract $rtup Relationships]]}\
            classRels string {
                [relation cardinality [tuple extract $rtup Relationships]] == 0 ?\
                "NULL" : "[tuple extract $rtup Name]__CRELS"} |
        ralutil::rvajoin ~ $attrs Attributes |
        relation extend ~ atup\
            attrCount int {
                [relation cardinality [tuple extract $atup Attributes]]}\
            classAttrs string {
                [relation cardinality [tuple extract $atup Attributes]] == 0 ?\
                "NULL" : "[tuple extract $atup Name]__CATTRS"} |
        ralutil::rvajoin ~ $usubs UnionSubs |
        relation extend ~ utup\
            containment string {
                [relation cardinality [tuple extract $utup UnionSubs]] == 0 ?\
                "NULL" :\
                "&${domain}__RSHIPS\[[relation extract\
                    [tuple extract $utup UnionSubs]\
                    SuperNumber]\].relInfo.unionGeneralization.superclass"} |
        relation eliminate ~ Domain

    }]
    # puts [relformat $classes classes]

    append result "static MRT_Class const\
            ${domain}__CLASSES\[[relation cardinality $classes]\] = \{\n"

    set relrefs {}
    set attrrefs {}
    relation foreach class $classes {
        relation assign $class

        if {[relation isnotempty $Relationships]} {
            append relrefs\
                "static MRT_Relationship const *const\
                    ${Name}__CRELS\[\] = \{\n"

            relation foreach rel $Relationships {
                relation assign $rel
                append relrefs\
                    "    &${domain}__RSHIPS\[$RelNumber\], // $Relationship\n"
            }

            append relrefs "\} ;\n"
        }

        if {[relation isnotempty $Attributes]} {
            append attrrefs\
                "static MRT_Attribute const ${Name}__CATTRS\["\
                [relation cardinality $Attributes]\
                "\] = \{\n"

            relation foreach attr $Attributes -ascending Attribute {
                relation assign $attr
                set offset "offsetof([GetClassProperty $Name Declaration],\
                        $Attribute)"
                set size "sizeof($DataType"
                if {$Dimension > 0} {
                    append size "\[$Dimension\]"
                }
                append size )
                append attrrefs\
                    "    \{\n"\
                    "        .offset = $offset,\n"\
                    "        .size = $size,\n"\
                    "            #ifndef MRT_NO_NAMES\n"\
                    "        .name = \"$Attribute\"\n"\
                    "            #endif /* MRT_NO_NAMES */\n"\
                    "    \},\n"
            }

            append attrrefs "\} ;\n"
        }

        append result\
            "    \[$Number\] = \{\n"\
            "        .iab = $IAB,\n"\
            "        .edb = $EDB,\n"\
            "        .pdb = $PDB,\n"\
            "        .relCount = $relCount,\n"\
            "        .classRels = $classRels,\n"\
            "        .attrCount = $attrCount,\n"\
            "        .classAttrs = $classAttrs,\n"\
            "        .instCount = [GetClassProperty $Name TotalInstance],\n"\
            "        .containment = $containment,\n"\
            "            #ifndef MRT_NO_NAMES\n"\
            "        .name = ${Name}__NAME\n"\
            "            #endif /* MRT_NO_NAMES */\n"\
            "    \},\n"
    }

    append result "\} ;\n"

    return [string cat $front $relrefs $attrrefs $result]
}
----

[source,tcl]
----
<<generation code commands>>=
proc assignerDefinitions {} {
    variable domain

    append result [comment "Single Assigner Class Description Definitions"]
    set assignerRefs [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $assignerRefs {
        assignAttribute $assigner
        append result\
            "static MRT_Class const ${Association}__CLASS = \{\n"\
            "    .iab = NULL,\n"\
            "    .edb = &${Association}__EDB,\n"\
            "    .pdb = NULL,\n"\
            "    .relCount = 0,\n"\
            "    .classRels = NULL,\n"\
            "    .attrCount = 0,\n"\
            "    .classAttrs = NULL,\n"\
            "    .instCount = 1,\n"\
            "    .containment = NULL,\n"\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .name = ${Association}__NAME,\n"\
            "        #endif /* MRT_NO_NAMES */\n"\
            "\} ;\n"
    }

    append result [comment "Multiple Assigner Class Description Definitions"]
    set assignerRefs [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $assignerRefs {
        assignAttribute $assigner
        append result\
            "static MRT_Attribute const ${Association}__CATTRS\[1\] = \{\n"\
            "    \{\n"\
            "        .offset = offsetof(struct $Association, idinstance),\n"\
            "        .size = sizeof([GetClassProperty $Class Reference]),\n"\
            "            #ifndef MRT_NO_NAMES\n"\
            "        .name = multi_assigner_attribute__NAME\n"\
            "            #endif /* MRT_NO_NAMES */\n"\
            "    \}\n"\
            "\} ;\n"

        set instRefs [findRelated $assigner ~R106]
        append result\
            "static MRT_Class const ${Association}__CLASS = \{\n"\
            "    .iab = &${Association}__IAB,\n"\
            "    .edb = &${Association}__EDB,\n"\
            "    .pdb = NULL,\n"\
            "    .relCount = 0,\n"\
            "    .classRels = NULL,\n"\
            "    .attrCount = 1,\n"\
            "    .classAttrs = ${Association}__CATTRS,\n"\
            "    .instCount = [refMultiplicity $instRefs],\n"\
            "    .containment = NULL,\n"\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .name = ${Association}__NAME,\n"\
            "        #endif /* MRT_NO_NAMES */\n"\
            "\} ;\n"
    }

    return $result
}
----

----
<<generation code commands>>=
proc relationshipDefinitions {} {
    variable domain
    set subroles {}

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    if {[isEmptyRef $relRefs]} {
        return
    }
    append result "static MRT_Relationship const\
        ${domain}__RSHIPS\[[refMultiplicity $relRefs]\] = \{\n"

    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    forAllRefs relRef $relRefs {
        assignAttribute $relRef {Name relName} Number
        append result "$indent\[$Number\] = \{ // $relName\n"

        # Simple Association
        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 SimpleAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set sourceRef [findRelated $typeRef ~R32]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R40 R41] Number]

            set targetRef [findRelated $typeRef ~R33]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set tMult false
            set stype mrtSingular
            set slink 0

            set tcomp [findRelated $targetRef R38 R94 R28]
            lassign [FindRelOffsets $tcomp] ttype tlink

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    $relName)"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    [readAttribute $tcomp Name])"

            append result\
                "$indent2.relType = mrtSimpleAssoc,\n"\
                "$indent2.relInfo.simpleAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\}\n"

            append result\
                "$indent2\},\n"\
                "${indent3}#ifndef MRT_NO_NAMES\n"\
                "$indent2.name = ${relName}__NAME\n"\
                "${indent3}#endif /* MRT_NO_NAMES */\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 ClassBasedAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set sourceRef [findRelated $typeRef ~R34]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R40 R41] Number]

            set targetRef [findRelated $typeRef ~R35]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}\
                {Multiplicity tMult}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set asstorRef [findRelated $typeRef ~R42]
            assignAttribute $asstorRef {Class aClass}
            set aNum [readAttribute [findRelated $asstorRef R40 R41] Number]

            set scomp [findRelated $sourceRef R95 R28]
            lassign [FindRelOffsets $scomp] stype slink

            set tcomp [findRelated $targetRef R38 R94 R28]
            lassign [FindRelOffsets $tcomp] ttype tlink

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    [readAttribute $scomp Name])"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    [readAttribute $tcomp Name])"

            append result\
                "$indent2.relType = mrtClassAssoc,\n"\
                "$indent2.relInfo.classAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink,\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\},\n"

            set aClassDecl [GetClassProperty $aClass Declaration]
            set aClassForw "offsetof($aClassDecl, ${relName}.forward)"
            set aClassBack "offsetof($aClassDecl, ${relName}.backward)"
            append result\
                "$indent3.associator = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$aNum\], // $aClass\n"\
                "$indent4.forwardOffset = $aClassForw,\n"\
                "$indent4.backwardOffset = $aClassBack,\n"\
                "$indent3\}\n"

            append result\
                "$indent2\},\n"\
                "${indent3}#ifndef MRT_NO_NAMES\n"\
                "$indent2.name = ${relName}__NAME\n"\
                "${indent3}#endif /* MRT_NO_NAMES */\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 ReferenceGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R36]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R48 R40 R41] Number]

            set subRefs [findRelated $typeRef ~R37]
            set subClasses [findRelated $subRefs R47 R40 R41]

            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"}\
                    storageOffset string {
                        "offsetof([GetClassProperty\
                            [tuple extract $stup Class] Declaration],\
                            $relName)"} |
                relation project ~ Class classDesc storageOffset
            }]

            append subroles "static struct mrtrefsubclassrole const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs -ascending Class {
                relation assign $sub
                append subroles\
                    "    \{\n"\
                    "        .classDesc = $classDesc,\n"\
                    "        .storageOffset = $storageOffset\n"\
                    "    \},\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtRefGeneralization,\n"\
                "$indent2.relInfo.refGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\},\n"\
                "${indent3}#ifndef MRT_NO_NAMES\n"\
                "$indent2.name = ${relName}__NAME\n"\
                "${indent3}#endif /* MRT_NO_NAMES */\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 UnionGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R44]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R48 R40 R41] Number]
            set subRefs [findRelated $typeRef ~R45]
            set subClasses [findRelated $subRefs R47 R40 R41]
            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"} |
                relation project ~ Class classDesc
            }]

            append subroles "static MRT_Class const * const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs -ascending Class {
                relation assign $sub
                append subroles "    $classDesc\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtUnionGeneralization,\n"\
                "$indent2.relInfo.unionGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\},\n"\
                "${indent3}#ifndef MRT_NO_NAMES\n"\
                "$indent2.name = ${relName}__NAME\n"\
                "${indent3}#endif /* MRT_NO_NAMES */\n"\
                "$indent\},\n"
            continue
        }
    }

    append result "\} ;\n"

    return [string cat\
        [comment "Relationship Description Definitions"]\
        $subroles\
        $result\
    ]
}
----

[source,tcl]
----
<<generation helper commands>>=
proc FindRelOffsets {complRef} {
    set typeRef [findRelated $complRef {~R26 SingularReference}]
    set offset 0
    if {[isNotEmptyRef $typeRef]} {
        set type mrtSingular
    } else {
        set typeRef [findRelated $complRef {~R26 ArrayReference}]
        if {[isNotEmptyRef $typeRef]} {
            set type mrtArray
        } else {
            set typeRef [findRelated $complRef {~R26 LinkReference}]
            set type mrtLinkedList
            assignAttribute [findRelated $typeRef ~R27]\
                {Class lClass} {Name lcomp}
            set offset "offsetof([GetClassProperty $lClass Declaration], $lcomp)"
        }
    }
    return [list $type $offset]
}
----

[source,tcl]
----
<<generation code commands>>=
proc MapToCardinality {cond mult} {
    if {$cond && !$mult} {
        return mrtAtMostOne
    } elseif {!$cond && !$mult} {
        return mrtExactlyOne
    } elseif {$cond && $mult} {
        return mrtZeroOrMore
    } elseif {!$cond && $mult} {
        return mrtOneOrMore
    }
}
----

[source,tcl]
----
<<generation code commands>>=
proc classInstanceDefinitions {} {
    variable domain
    variable staticMultiRefs {}

    set classRefs [FindNonUnionSubclasses $domain]
    set classpops [FindClassPopulation $classRefs]

    set result [comment "Instance Pool Definitions"]
    relation foreach classpop $classpops -ascending ClassNumber {
        relation assign $classpop

        append result\
            "static struct $Class "\
            [GetClassProperty $Class StorageVariable]\
            "\[[GetClassProperty $Class TotalInstance]\] = \{\n"

        relation foreach inst $Instances -ascending InstNumber {
            append result [GenInstanceInitializers $Class $ClassNumber $inst]
        }

        append result "\} ;\n"
    }

    if {$staticMultiRefs ne {}} {
        set staticMultiRefs [string cat\
            [comment "Static Reference Definitions"] $staticMultiRefs]
    }
    return [string cat $staticMultiRefs $result]
}
----

[source,tcl]
----
<<generation code commands>>=
proc FindClassPopulation {classRefs} {
    set classes [pipe {
        deRef $classRefs |
        relation rename ~ Name Class Number ClassNumber
    }]

    set compRefs [findRelated $classRefs ~R20]

    # Populated Components
    set popCompRefs [findRelated $compRefs {~R25 PopulatedComponent}]

    # Attribute Components
    set attrs [pipe {
        findRelated $popCompRefs {~R21 Attribute} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $attrs attrs]

    # Reference Components
    # For the populated reference components we will go ahead and
    # compute the class to which the reference is made.
    set refCompRefs [findRelated $popCompRefs {~R21 Reference}]

    # Superclass Reference Component
    set screfs [findRelated $refCompRefs {~R23 SuperclassReference}]
    set refedsuper [pipe {
        findRelated $screfs ~R91 {~R47 ReferringSubclass} R37 ~R36 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class SuperClass Relationship Component
    } {} |%]
    set superrefs [pipe {
        deRef $screfs |
        relation rename ~ Name Component |
        relation join ~ $refedsuper
    }]
    # puts [relformat $superrefs superrefs]

    # Associator Reference Components
    set arrefs [findRelated $refCompRefs {~R23 AssociatorReference}]
    set cbainfo [pipe {
        findRelated $arrefs ~R93 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class AssociatorClass |
        relation join % $::micca::SourceClass |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class SourceClass |
        relation join % $::micca::TargetClass |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class TargetClass AssociatorClass Class\
                Relationship Component
    } {} |%]
    set atorrefs [pipe {
        deRef $arrefs |
        relation rename ~ Name Component |
        relation join ~ $cbainfo
    }]
    # puts [relformat $atorrefs atorrefs]

    # Association Reference Components
    set asrrefs [findRelated $refCompRefs {~R23 AssociationReference}]
    set srcinfo [pipe {
        findRelated $asrrefs ~R90 R32 ~R33 |
        deRef % |
        relation eliminate % Role Conditionality |
        relation rename % Class ReferencedClass Relationship Component
    } {} |%]
    set assocrefs [pipe {
        deRef $asrrefs |
        relation rename ~ Name Component |
        relation join ~ $srcinfo
    }]
    # puts [relformat $assocrefs assocrefs]

    # Generated components
    set genCompRefs [findRelated $compRefs {~R25 GeneratedComponent}]

    # Subclass Reference Components
    set subrefs [pipe {
        findRelated $genCompRefs {~R24 SubclassReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $subrefs subrefs]

    # Subclass Container
    set subconts [pipe {
        findRelated $genCompRefs {~R24 SubclassContainer} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $subconts subconts]

    # Link Container
    set linkconts [pipe {
        findRelated $genCompRefs {~R24 LinkContainer} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $linkconts linkconts]

    # Complementary Reference
    set complRefs [findRelated $genCompRefs {~R24 ComplementaryReference}]

    # Singular Reference
    set singRefs [pipe {
        findRelated $complRefs {~R26 SingularReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $singRefs singRefs]

    # Array Reference
    set arrayRefs [pipe {
        findRelated $complRefs {~R26 ArrayReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $arrayRefs arrayRefs]

    # Link Reference
    set linkRefs [pipe {
        findRelated $complRefs {~R26 LinkReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $linkRefs linkRefs]

    set classpops [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation rename % Number InstNumber |
        relation join % $classes $::micca::ClassComponentValue |
        ralutil::rvajoin % $attrs Attributes |
        ralutil::rvajoin % $superrefs SuperRefs |
        ralutil::rvajoin % $atorrefs AssociatorRefs |
        ralutil::rvajoin % $assocrefs AssociationRefs |
        ralutil::rvajoin % $subrefs SubRefs |
        ralutil::rvajoin % $subconts SubclassContainers |
        ralutil::rvajoin % $linkconts LinkContainers |
        ralutil::rvajoin % $singRefs SingularRefs |
        ralutil::rvajoin % $arrayRefs ArrayRefs |
        ralutil::rvajoin % $linkRefs LinkRefs |
        relation group % Components Component Value Attributes SuperRefs\
            AssociatorRefs AssociationRefs SubRefs SubclassContainers\
            LinkContainers SingularRefs ArrayRefs LinkRefs |
        relation group % Instances Instance InstNumber Components |
        relation eliminate % Domain
    } {} |%]
    # puts [relformat $classpops classpops]

    return $classpops
}
----

[source,tcl]
----
<<generation code commands>>=
proc GenInstanceInitializers {className classNumber inst} {
    variable domain
    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    relation assign $inst

    set sp [pipe {
        StateModel findById Domain $domain Model $className |
        findRelated ~ R58 R57
    }]
    set initstate [expr {[isNotEmptyRef $sp] ?\
        [readAttribute $sp Number] : "MRT_StateCode_IG"}]

    append result\
        "$indent\{\n"\
        "$indent2.base__INST = \{\n"\
        "$indent3.classDesc = &${domain}__CLASSES\[$classNumber\],\n"\
        "$indent3.alloc = [expr {$InstNumber + 1}],\n"\
        "$indent3.currentState = $initstate,\n"\
        "$indent3.refCount = 0,\n"\
        "${indent4}#ifndef MRT_NO_NAMES\n"\
        "$indent3.name = \"$Instance\"\n"\
        "${indent4}#endif /* MRT_NO_NAMES */\n"\
        " $indent2\},\n"

    relation foreach comp $Components {
        relation assign $comp
        if {[relation isnotempty $Attributes]} {
            append result "$indent2.$Component = $Value,\n"
            continue
        }

        if {[relation isnotempty $SuperRefs]} {
            set superclass [relation extract $SuperRefs SuperClass]
            append result\
                "$indent2.$Component = "\
                [GenInstanceAddress $domain $superclass $Value],\n
            continue
        }

        if {[relation isnotempty $AssociatorRefs]} {
            relation assign $AssociatorRefs
            # the painful reflexive case again!
            if {$SourceClass eq $TargetClass} {
                # N.B. the inversion. the target instance is the
                # one referenced in the forward direction
                set sinstname [dict get $Value backward]
                set tinstname [dict get $Value forward]
            } else {
                set sinstname [dict get $Value $SourceClass]
                set tinstname [dict get $Value $TargetClass]
            }
            set sourceaddr [GenInstanceAddress $domain $SourceClass\
                $sinstname]
            set targetaddr [GenInstanceAddress $domain $TargetClass\
                $tinstname]

            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.forward = $targetaddr,\n"\
                "$indent3.backward = $sourceaddr\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $AssociationRefs]} {
            set refvalue [expr {$Value eq "@nil@" ?\
                "NULL" : [GenInstanceAddress $domain\
                    [relation extract $AssociationRefs ReferencedClass]\
                    $Value]}]
            append result "$indent2.$Component = $refvalue,\n"
            continue
        }

        if {[relation isnotempty $SubRefs]} {
            lassign $Value subclass subinstname
            set subinstaddr [GenInstanceAddress $domain $subclass $subinstname]
            append result "$indent2.$Component = $subinstaddr,\n"
            continue
        }

        if {[relation isnotempty $SubclassContainers]} {
            lassign $Value subclass subinst

            set subRef [Class findWhere {$Domain eq $domain &&\
                $Name eq $subclass}]
            set subpops [FindClassPopulation $subRef]
            # puts [relformat $subpops subpops]

            relation assign $subpops {Class subclassName}\
                {ClassNumber subclassNumber} {Instances subInstances}
            set instpop [relation restrictwith $subInstances\
                {$Instance eq $subinst}]

            append result\
                "$indent2.$Component.$subclass = "\
                [string trimleft [indentCode [GenInstanceInitializers\
                    $subclassName $subclassNumber $instpop] 8]]
            continue
        }

        if {[relation isnotempty $LinkContainers]} {
            lassign [dict get $Value next] nclass ninst ncomp
            set nextaddr [GenInstanceAddress $domain $nclass $ninst]
            lassign [dict get $Value prev] pclass pinst pcomp
            set prevaddr [GenInstanceAddress $domain $pclass $pinst]
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $nextaddr.$ncomp,\n"\
                "$indent3.prev = $prevaddr.$pcomp\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $SingularRefs]} {
            if {$Value eq "@nil@"} {
                set refaddr NULL
            } else {
                lassign $Value refclass refinst
                set refaddr [GenInstanceAddress $domain $refclass $refinst]
            }
            append result "$indent2.$Component = $refaddr,\n"
            continue
        }

        if {[relation isnotempty $ArrayRefs]} {
            if {$Value eq "@nil@"} {
                set refcount 0
                set refaddr NULL
            } else {
                lassign $Value refclass refinsts
                set refcount [llength $refinsts]
                set refaddr ${Component}_${className}_${InstNumber}

                # Build reference array
                variable staticMultiRefs
                append staticMultiRefs\
                    "static [GetClassProperty $refclass Reference]\
                        const $refaddr\[$refcount\] = \{\n"
                foreach inst $refinsts {
                    append staticMultiRefs\
                        "$indent[GenInstanceAddress $domain $refclass $inst],\n"
                }
                append staticMultiRefs "\} ;\n"
            }
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.links = $refaddr,\n"\
                "$indent3.count = $refcount\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $LinkRefs]} {
            lassign [dict get $Value next] nclass ninst ncomp
            set nextaddr [GenInstanceAddress $domain $nclass $ninst]
            lassign [dict get $Value prev] pclass pinst pcomp
            set prevaddr [GenInstanceAddress $domain $pclass $pinst]
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $nextaddr.$ncomp,\n"\
                "$indent3.prev = $prevaddr.$pcomp\n"\
                "$indent2\},\n"
            continue
        }
    }

    append result "$indent\},\n"

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc assignerInstanceDefinitions {} {
    variable domain
    set result {}

    append result [comment "Single Assigner Structure Declarations"]
    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    forAllRefs assigner $singles {
        set initstate [pipe {
            findRelated $assigner R53 R50 R58 R57 |
            readAttribute ~ Number
        }]
        assignAttribute $assigner
        append result\
            "static struct $Association ${Association}__POOL\[1\] = \{\n"\
            "    \{\n"\
            "        .base__INST = \{\n"\
            "            .classDesc = &${Association}__CLASS,\n"\
            "            .alloc = 1,\n"\
            "            .currentState = $initstate,\n"\
            "            .refCount = 0,\n"\
            "                #ifndef MRT_NO_NAMES\n"\
            "            .name = ${Association}__NAME\n"\
            "                #endif /* MRT_NO_NAMES */\n"\
            "        \}\n"\
            "    \}\n"\
            "\} ;\n"
    }

    append result [comment "Multiple Assigner Structure Declarations"]
    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        assignAttribute $multi {Association assoc}
        set initstate [pipe {
            findRelated $multi R53 R50 R58 R57 |
            readAttribute ~ Number
        }]
        set multiinsts [findRelated $multi ~R106]
        set totalinsts [refMultiplicity [findRelated $multi R54 ~R20 ~R103]]

        append result "static struct $assoc\
                ${assoc}__POOL\[$totalinsts\] = \{\n"
        forAllRefs assigner $multiinsts {
            assignAttribute $assigner
            set allocnum 0
            append result\
                "    \[$Number\] = \{\n"\
                "        .base__INST = \{\n"\
                "            .classDesc = &${Association}__CLASS,\n"\
                "            .alloc = [incr allocnum],\n"\
                "            .currentState = $initstate,\n"\
                "            .refCount = 0,\n"\
                "                #ifndef MRT_NO_NAMES\n"\
                "            .name = \"$Instance\"\n"\
                "                #endif /* MRT_NO_NAMES */\n"\
                "        \},\n"\
                "        .idinstance = [GenInstanceAddress $domain $IdClass\
                        $IdInstance]\n"\
                "    \},\n"\
        }
        append result "\} ;\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc operationDefinitions {} {
    variable domain

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    set result [comment "Operation Definitions"]
    relation foreach op $ops {
        relation assign $op
        append result\
            "static $ReturnDataType\n${Class}_$Operation"

        if {[relation isempty $Parameters]} {
            append result "\(void\)\n"
            set syms [relation create {
                Name string Ctype string Type string Class string
            }]
        } else {
            set pdecls {}
            relation foreach param $Parameters -ascending Number {
                relation assign $param
                append pdecls\
                    [typeCheck composeDeclaration $DataType $Name]\
                    ,\n
            }
            set pdecls [string trimright $pdecls ",\n"]\)\n
            append result\
                "\(\n"\
                [indentCode $pdecls]

            set syms [pipe {
                relation project $Parameters Name DataType |
                relation rename ~ DataType Ctype |
                relation extend ~ stup\
                    Type string {"Parameter"}\
                    Class string {$Class} |
                relation update ~ utup {
                    [tuple extract $utup Name] eq "self"} {
                    tuple update $utup Type Reference
                }
            }]
        }

        append result\
            [blockcomment $Body]\
            "\{\n"\
            "    MRT_INSTRUMENT_ENTRY\n"\
            [ExpandActivity $Body $syms]\
            "\}\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc ctorDefinitions {} {
    return [TorDefinitions Constructor]
}
----

[source,tcl]
----
<<generation code commands>>=
proc dtorDefinitions {} {
    return [TorDefinitions Destructor]
}
----

[source,tcl]
----
<<generation code commands>>=
proc TorDefinitions {which} {
    variable domain
    set suffixmap [dict create\
        Constructor CTOR\
        Destructor DTOR\
    ]
    set result {}

    set tors [$which findWhere {$Domain eq $domain}]

    if {[isNotEmptyRef $tors]} {
        append result [comment "$which Definitions"]
        forAllRefs tor $tors {
            assignAttribute $tor

            set selfdecl [GetClassProperty $Class Reference]const
            set syms [relation create {
                Name string Ctype string Type string Class string
            } [list Name self Ctype $selfdecl Type Reference Class $Class]]
            append result\
                "static void\n${Class}__[dict get $suffixmap $which]\(\n"\
                "    void *const s__SELF\)\n"\
                [blockcomment $Body]\
                "\{\n"\
                [string cat\
                    "    MRT_INSTRUMENT_ENTRY\n"\
                    "    $selfdecl self = s__SELF ;\n"\
                    [ExpandActivity $Body $syms]\
                ]\
                "\}\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-17.0 {
    Generated code file with constructor and destructor
} -setup {
    # makeFile {} codegen17.h
    # makeFile {} codegen17.c
    micca configure {
        domain codegen17 {
            domainop void initialize {} {
                codegen17__INIT() ;
            }

            class X {
                attribute color int -default 20

                constructor {
                    self->color += 20 ;
                }
                destructor {
                    self->color -= 20 ;
                }
            }
        }
        population codegen17 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {CTOR} codegen17.c]] == 4}\
        {[llength [fileutil::grep {DTOR} codegen17.c]] == 3}
} -result {1}
----

[source,tcl]
----
<<generation code commands>>=
proc activityDefinitions {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && [string trim $Activity] ne {}} |
        deRef ~ |
        relation eliminate ~ Domain IsTerminal |
        relation group ~ States Name Activity PSigID
    }]
    # puts [relformat $classes classes]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Definitions"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            append result "#define MRT_CLASSNAME \"$Model\"\n"
            relation foreach state $States {
                relation assign $state
                set selfdecl [GetClassProperty $Model Reference]const
                append result\
                    "static void\n${Model}_${Name}__ACTIVITY\(\n"\
                    "    void *const s__SELF,\n"\
                    "    void const *const p__PARAMS)\n"\
                    [blockcomment $Activity]\
                    "\{\n"\
                    "        #define MRT_STATENAME \"$Name\"\n"\
                    "    MRT_INSTRUMENT_ENTRY\n"\
                    "    $selfdecl self = s__SELF ;\n"
                if {$PSigID ne {}} {
                    set signame ${Model}_${Name}__SPARAMS
                    append result\
                        "    struct $signame const *const pp__PARAMS = p__PARAMS ;\n"
                    set params [pipe {
                        ParameterSignature findById Domain $domain PSigID $PSigID |
                        FindParamsFromSig ~
                    }]
                    relation foreach param $params -ascending Position {
                        relation assign $param {Name pname} Declaration
                        append result "    $Declaration = pp__PARAMS->$pname ;\n"
                    }

                    set syms [pipe {
                        relation project $params Name Declaration |
                        relation rename ~ Declaration Ctype |
                        relation extend ~ stup\
                            Type string {"Parameter"}\
                            Class string {$Model}
                    }]
                } else {
                    set syms [relation create {
                        Name string Ctype string Type string Class string
                    }]
                }
                set syms [relation insert $syms [list Name self Ctype $selfdecl\
                        Type Reference Class $Model]]

                append result [ExpandActivity $Activity $syms]

                append result\
                    "        #undef MRT_STATENAME\n"\
                    "\}\n"
            }
            append result "#undef MRT_CLASSNAME\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc FindParamsFromSig {psigRef} {
    return [pipe {
        findRelated $psigRef ~R79 |
        deRef % |
        relation join % $::micca::Argument |
        relation extend % ptup Declaration string {\
            [typeCheck composeDeclaration\
                [tuple extract $ptup DataType]\
                [tuple extract $ptup Name]]}
    } {} |%]
}
----

[source,tcl]
----
<<generation code commands>>=
proc domainCtorDefinition {} {
    variable domain
    set result {}

    set ctorinsts [pipe {
        Constructor findWhere {$Domain eq $domain} |
        deRef ~ |
        relation eliminate ~ Body |
        relation join ~ $::micca::ClassInstance |
        relation group ~ Instances Instance Number
    }]

    if {[relation isnotempty $ctorinsts]} {
        append result [comment "Definition of Function to Construct\
            Initial Instances"]
        relation foreach ctorinst $ctorinsts {
            relation assign $ctorinst
            relation foreach instance $Instances -ascending Number {
                relation assign $instance
                append invocations\
                    "${Class}__CTOR\("\
                    [GenInstanceAddress $domain $Class $Instance]\
                    "\) ;\n"
            }
        }
        append result\
            "static void\n${domain}__INIT\(void\)\n"\
            "\{\n"\
            [indentCode $invocations]\
            "\}\n"
    }

    return $result
}
----

[source,tcl]
----
<<generation code commands>>=
proc domainOpDefinitions {} {
    variable domain
    set result {}

    set ops [pipe {
        DomainOperation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::DomainOperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Domain Operation Definitions"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "$ReturnDataType\n${domain}_${Operation}"

            if {[relation isempty $Parameters]} {
                set decl "\(void\)\n"
                append result $decl
                set syms [relation create {
                    Name string Ctype string Type string Class string
                }]
            } else {
                set pdecls {}
                relation foreach param $Parameters -ascending Number {
                    relation assign $param
                    append pdecls\
                        [typeCheck composeDeclaration $DataType $Name]\
                        ,\n
                }
                set pdecls [string trimright $pdecls ",\n"]\)\n
                set decl [string cat\
                    "\(\n"\
                    [indentCode $pdecls]\
                ]
                append result $decl
                set syms [pipe {
                    relation project $Parameters Name DataType |
                    relation rename ~ DataType Ctype |
                    relation extend ~ stup\
                        Type string {"Parameter"}\
                        Class string {{}}
                }]
            }

            append result\
                [blockcomment $Body]\
                "\{\n"\
                "    MRT_INSTRUMENT_ENTRY\n"\
                [ExpandActivity $Body $syms]\
                "\}\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-18.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -setup {
    # makeFile {} codegen18.h
    # makeFile {} codegen18.c
    micca configure {
        domain codegen18 {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }

            class X {
                attribute color int -default 10
            }
        }
        population codegen18 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {codegen18_color} codegen18.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation code commands>>=
proc externalOpDefinitions {} {
    upvar #0 [namespace parent]::options options
    if {![dict get $options stubexternalops]} {
        return
    }

    variable domain
    set result {}

    set ops [pipe {
        ExternalOperation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::ExternalOperationParameter Parameters
    }]

    append result [comment "External Operation Stub Definitions"]
    relation foreach op $ops {
        relation assign $op
        append result\
            "$ReturnDataType\n${domain}_${Operation}__EOP"

        if {[relation isempty $Parameters]} {
            append result "\(void\)\n"
            set syms [relation create {
                Name string Ctype string Type string Class string
            }]
        } else {
            set pdecls {}
            relation foreach param $Parameters -ascending Number {
                relation assign $param
                append pdecls\
                    [typeCheck composeDeclaration $DataType $Name]\
                    ,\n
            }
            set pdecls [string trimright $pdecls ",\n"]\)\n
            append result\
                "\(\n"\
                [indentCode $pdecls]
            set syms [pipe {
                relation project $Parameters Name DataType |
                relation rename ~ DataType Ctype |
                relation extend ~ stup\
                    Type string {"Parameter"}\
                    Class string {{}}
            }]
        }

        append result\
            [blockcomment $Body]\
            "\{\n"\
            [ExpandActivity $Body $syms]\
            "\}\n"
    }

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-19.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -setup {
    # makeFile {} codegen19.h
    # makeFile {} codegen19.c
    micca configure {
        domain codegen19 {
            externalop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }

            class X {
                attribute color int -default 10
            }
        }
        population codegen19 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate stubexternalops true
    testConditions\
        {[llength [fileutil::grep {codegen19_color__EOP} codegen19.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation code commands>>=
proc portalDefinition {} {
    variable domain

    set classRefs [Class findWhere {$Domain eq $domain}]
    append result\
        [comment "Domain Portal Definition"]\
        "MRT_DomainPortal ${domain}__PORTAL = \{\n"\
        "    .classCount = [refMultiplicity $classRefs],\n"\
        "    .classes = ${domain}__CLASSES,\n"\
        "        #ifndef MRT_NO_NAMES\n"\
        "    .name = \"$domain\"\n"\
        "        #endif /* MRT_NO_NAMES */\n"\
        "\} ;\n"
}
----

[source,tcl]
----
<<generation code commands>>=
proc epilogueDeclarations {} {
    variable epilogue

    return [string cat\
        [comment "Domain Epilogue"]\
        [indentCode [string trim $epilogue \n] 0]\
    ]
}
----

== Generating Activity Code

In this section we discuss the macro commands that are available
to a translator for easing the burden of translating model level
execution into the required ``C'' code.
The ``C'' code supplied by the user for state activities and other
operations can contain embedded macros which are further expanded
by the code generator.
The macros are simple commands with arguments that are enclosed
in the special delimiters *%<* and *>%*.
For example,
the macro to access the *Color* attribute of an instance could be written
as:

*****
ColorType c = %<instance self attribute Color>% ;
*****

The code generator would then expand the commands contained between the
*%<* and *>%* delimiters and replace the embedded macro with the
value of the *Color* attribute of the instance referenced by the
value of the *self* variable..
This is a very simple case, but even here the code generator
performs a number of significant checks in an attempt to discover
errors before code is sent to the compiler.
In this case, the code generator insures that the value of *self* is
a reference to a class instance and that class contains an attribute
named *Color*.

There are many of these macro commands.
State activities are then a mix of ``C'' code and macros to accomplish
the purpose of the activity.
Since the code generator has access to the populated platform model,
it performs many consistency checks that would otherwise result in
compiler errors.
Discovering error earlier makes them much easier to correct since
the mapping of compiler errors back to the source becomes more difficult
since there is a level of translation in between.

=== Expanding the Activities Macros

[source,tcl]
----
<<generation support namespace>>=
namespace eval GenSupport {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar

    namespace export ExpandActivity

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }
    upvar #0 ::micca::@Gen@::errcount errcount

    textutil::expander actexpand
    actexpand setbrackets %< >%
    actexpand evalcmd "namespace eval [namespace parent]::GenActivity"
    actexpand errmode fail
    actexpand textcmd [namespace current]::ProcessCodeLines

    <<generation support data>>
    <<generation support commands>>
}
----

=== Creating the Macro Commands

[source,tcl]
----
<<generation commands>>=
proc CreateActivityCommands {domain} {
    namespace eval GenActivity {
        logger::initNamespace [namespace current]
    }

    set currns [namespace current]
    set actns ${currns}::GenActivity
    set suppns ${currns}::GenSupport

    <<CreateActivityCommands: classes>>
    <<CreateActivityCommands: relationships>>
    <<CreateActivityCommands: instances>>
    <<CreateActivityCommands: instance sets>>

    interp alias {} external {} ${suppns}::InvokeExternalOp
    interp alias {} end {} ${suppns}::End
}
----

[source,tcl]
----
<<CreateActivityCommands: classes>>=
set usubnames [pipe {
    UnionSubclass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation list ~ Class
}]
----

[source,tcl]
----
<<CreateActivityCommands: classes>>=
set classInfo [pipe {
    Class findWhere {$Domain eq $domain} |
    deRef ~ |
    ralutil::rvajoin ~ [relation rename $::micca::StateModel Model Name]\
        StateModels |
    relation extend ~ itup HasStateModel boolean {
        [relation isnotempty [tuple extract $itup StateModels]]} |
    ralutil::rvajoin ~\
        [relation rename $::micca::CreationState Name State Model Name]\
        CreationStates |
    relation extend ~ ctup HasCreationState boolean {
        [relation isnotempty [tuple extract $ctup CreationStates]]} |
    relation project ~ Name HasStateModel HasCreationState
}]

set cmdmap [dict create]
relation foreach info $classInfo {
    relation assign $info
    set cmdmap [dict create\
        foreachInstance [list ${suppns}::ClassForeachInstance $Name]\
        instref [list ${suppns}::ClassInstanceReference $Name]\
        reference [list ${suppns}::ClassIdToRef $Name]\
        instset [list ${suppns}::ClassInstanceSet $Name]\
        findByName [list ${suppns}::ClassFindByName $Name]\
        operation [list ${suppns}::ClassOperation $Name]\
    ]
    if {$Name ni $usubnames} {
        dict set cmdmap create [list ${suppns}::ClassCreate $Name]
        if {$HasStateModel} {
            dict set cmdmap createin [list ${suppns}::ClassCreateIn $Name]
        }
        if {$HasCreationState} {
            dict set cmdmap createasync [list ${suppns}::ClassCreateAsync $Name]
        }
    }
    namespace ensemble create\
        -command ${actns}::$Name\
        -map $cmdmap
}
----

[source,tcl]
----
<<CreateActivityCommands: relationships>>=
set relRefs [Relationship findWhere {$Domain eq $domain}]

set assocs [findRelatedWhere $relRefs {{~R30 Association}} {!$IsStatic}]

set simpassocs [findRelated $assocs {~R31 SimpleAssociation}]
forAllRefs simpassoc $simpassocs {
    set simpname [readAttribute $simpassoc Name]
    set cmdmap [dict create\
        relate [list ${suppns}::RelSimpleRelateForw $simpname]\
        unrelate [list ${suppns}::RelSimpleUnrelateForw $simpname]\
    ]
    set assigner [findRelated $simpassoc R31 ~R52]
    if {[isNotEmptyRef $assigner]} {
        if {[isNotEmptyRef [findRelated $assigner {~R53 SingleAssigner}]]} {
            dict set cmdmap signal\
                [list ${suppns}::SingleAssignerSignal $simpname]
        } else {
            dict set cmdmap signal [list ${suppns}::InstanceSignal $simpname]
            dict set cmdmap create [list ${suppns}::MultiAssignerCreate $simpname]
        }
    }
    namespace ensemble create\
        -command ${actns}::$simpname\
        -map $cmdmap

    set cmdmap [dict create\
        relate [list ${suppns}::RelSimpleRelateBack $simpname]\
        unrelate [list ${suppns}::RelSimpleUnrelateBack $simpname]\
    ]
    namespace ensemble create\
        -command ${actns}::~$simpname\
        -map $cmdmap
}

set classassocs [findRelated $assocs {~R31 ClassBasedAssociation}]
foreach cbname [relation list [deRef $classassocs] Name] {
    set cmdmap [dict create\
        relate [list ${suppns}::RelClassRelateForw $cbname]\
        unrelate [list ${suppns}::RelClassUnrelateForw $cbname]\
    ]
    set assigner [findRelated $classassocs R31 ~R52]
    if {[isNotEmptyRef $assigner]} {
        if {[isNotEmptyRef [findRelated $assigner {~R53 SingleAssigner}]]} {
            dict set cmdmap signal\
                [list ${suppns}::SingleAssignerSignal $simpname]
        } else {
            dict set cmdmap signal [list ${suppns}::InstanceSignal $simpname]
            dict set cmdmap create [list ${suppns}::MultiAssignerCreate $simpname]
        }
    }
    namespace ensemble create\
        -command ${actns}::$cbname\
        -map $cmdmap

    set cmdmap [dict create\
        relate [list ${suppns}::RelClassRelateBack $cbname]\
        unrelate [list ${suppns}::RelClassUnrelateBack $cbname]\
    ]
    namespace ensemble create\
        -command ${actns}::~$cbname\
        -map $cmdmap
}

set gens [findRelated $relRefs {~R30 Generalization}]

set refgens [findRelated $gens {~R43 ReferenceGeneralization}]
foreach rgname [relation list [deRef $refgens] Name] {
    set cmdmap [dict create\
        relate [list ${suppns}::RelRefGenRelateForw $rgname]\
        unrelate [list ${suppns}::RelRefGenUnrelateForw $rgname]\
        reclassify [list ${suppns}::RelRefGenReclassify $rgname]\
    ]
    namespace ensemble create\
        -command ${actns}::$rgname\
        -map $cmdmap

    set cmdmap [dict create\
        relate [list ${suppns}::RelRefGenRelateBack $rgname]\
        unrelate [list ${suppns}::RelRefGenUnrelateBack $rgname]\
    ]
    namespace ensemble create\
        -command ${actns}::~$rgname\
        -map $cmdmap
}

set uniongens [findRelated $gens {~R43 UnionGeneralization}]
foreach ugname [relation list [deRef $uniongens] Name] {
    namespace ensemble create\
        -command ${actns}::$ugname\
        -map [dict create\
            reclassify [list ${suppns}::RelUnionGenReclassify $ugname]\
        ]
}
----

[source,tcl]
----
<<CreateActivityCommands: instances>>=
set cmdmap [dict create\
    attribute ${suppns}::InstanceAttribute\
    signal ${suppns}::InstanceSignal\
    delaysignal ${suppns}::InstanceDelaySignal\
    canceldelayed ${suppns}::InstanceCancelSignal\
    delayremaining ${suppns}::InstanceRemainingTime\
    delete ${suppns}::InstanceDelete\
    operation ${suppns}::InstanceOperation\
    foreachRelated ${suppns}::InstanceForeachRelated\
    findOneRelated ${suppns}::InstanceFindOneRelated\
    instid [list ${suppns}::InstanceRefToId]\
]
namespace ensemble create\
    -command ${actns}::instance\
    -parameters instref\
    -map $cmdmap
----

[source,tcl]
----
<<CreateActivityCommands: instance sets>>=
set cmdmap [dict create\
    foreachSelected ${suppns}::InstanceSetForeachSelected\
    empty ${suppns}::InstanceSetEmpty\
    notempty ${suppns}::InstanceSetNotEmpty\
    equal ${suppns}::InstanceSetEqual\
    notequal ${suppns}::InstanceSetNotEqual\
    add ${suppns}::InstanceSetAdd\
    union ${suppns}::InstanceSetUnion\
    intersect ${suppns}::InstanceSetIntersect\
    minus ${suppns}::InstanceSetMinus\
]
namespace ensemble create\
    -command ${actns}::instset\
    -parameters instset\
    -map $cmdmap
----

=== Symbol Table

[source,tcl]
----
<<generation support data>>=
relvar create Symbol {
    Name string
    Block int
    Ctype string
    Type string
    Class string
} {Name Block}
----

[source,tcl]
----
<<generation support commands>>=
proc LookUpSymbol {name} {
    variable block
    set sym [pipe {
        relvar set Symbol |
        relation restrictwith ~ {$Name eq $name}
    }]
    if {[relation isempty $sym]} {
        return
    }
    if {[relation cardinality $sym] > 1} {
        set sym [pipe {
            relation tag $sym BlockOrder -descending Block |
            relation restrictwith ~ {$BlockOrder == 0} |
            relation elminate ~ BlockOrder
        }]
    }
    return [pipe {
        relation eliminate $sym Block |
        relation tuple ~ |
        tuple get ~
    }]
}

proc InsertSymbol {args} {
    try {
        variable block
        lappend args Block $block
        set sym [relvar insert Symbol $args]
        return [tuple get [relation tuple $sym]]
    } trap {RAL relvar insert DUPLICATE_TUPLE*} {result} {
        error "duplicate symbol, [dict get $args Name], $result"
    } on error {result opts} {
        return -options $opts $result
    }
}

proc DeleteSymbol {name} {
    return [relvar delete Symbol symtup {[tuple extract $symtup Name] eq $name}]
}

proc CreateTempSymbol {args} {
    variable symcounter
    set name t__T[incr symcounter]
    InsertSymbol Name $name {*}$args
    return $name
}

proc CreateTempRefSymbol {className} {
    set reftype [GetClassProperty $className Reference]
    set symName [CreateTempSymbol Ctype $reftype Type Reference Class $className]
    return [list $reftype $symName]
}

proc CheckSymbol {name args} {
    set sym [LookUpSymbol $name]
    if {$sym eq {}} {
        error "unknown symbol, $name"
    }
    if {[llength $args] != 0} {
        CheckSymProperties $sym {*}$args
    }
    return $sym
}

proc CheckSymProperties {sym args} {
    foreach {prop value} $args {
        if {[dict get $sym $prop] ne $value} {
            error "for variable, [dict get $sym Name], expected $prop to be,\
                    $value: got [dict get $sym $prop] instead"
        }
    }
    return
}

proc CreateInstRefSymbol {className varName} {
    set sym [LookUpSymbol $varName]
    if {$sym ne {}} {
        CheckSymProperties $sym Class $className Type Reference
        return
    }
    set creftype [GetClassProperty $className Reference]
    InsertSymbol Name $varName Ctype $creftype Type Reference Class $className
    return "$creftype$varName ;\n"
}

proc CheckInstRefSymbol {varName args} {
    tailcall CheckSymbol $varName Type Reference {*}$args
}

proc CreateInstSetSymbol {className varName} {
    set sym [LookUpSymbol $varName]
    if {$sym ne {}} {
        CheckSymProperties $sym Class $className Type InstanceSet
        return
    }
    set ctype MRT_InstSet
    InsertSymbol Name $varName Ctype $ctype Type InstanceSet Class $className
    return "$ctype $varName ;\n"
}

proc CheckInstSetSymbol {varName args} {
    tailcall CheckSymbol $varName Type InstanceSet {*}$args
}

proc ProcessCodeLines {text} {
    variable block

    # puts "text = \"$text\""
    set newlines [list]

    foreach line [split $text \n] {
        if {[string is space $line]} {
            if {[llength $newlines] != 0 && [lindex $newlines end] ne {}} {
                lappend newlines {}
            }
        } else {
            if {[string first \} $line] != -1} {
                incr block -1
            }
            if {[regsub -- {\A\s{4,}} $line {} newline] != 0} {
                set line [string repeat { } [expr {$block * 4}]]$newline
            }
            lappend newlines $line
            if {[string first \{ $line] != -1} {
                incr block
            }
        }
    }
    set newtext [join $newlines \n]
    # puts "newtext = \"$newtext\""

    return $newtext
}
----

[source,tcl]
----
<<generation support commands>>=
proc PushContext {context args} {
    actexpand cpush $context
    foreach {var value} $args {
        actexpand cset $var $value
    }
}

proc PopContext {context args} {
    foreach varname $args {
        upvar 1 $varname cvar
        set cvar [actexpand cget $varname]
    }
    return [actexpand cpop $context]
}

proc IndentToBlock {code} {
    variable block
    # indent seems to swallow a trailing new line
    return [::textutil::adjust::indent $code\
        [string repeat { } [expr {$block * 4}]]]\n
}

proc PushBlock {{by 1}} {
    variable block
    incr block $by
}

proc PopBlock {{by -1}} {
    variable block
    relvar delete Symbol stup {[tuple extract $stup Block] == $block}
    incr block $by
}

proc GetBlock {} {
    variable block
    return $block
}
----

=== Template Expansion of Activity Code

[source,tcl]
----
<<generation support commands>>=
proc ExpandActivity {body parameters} {
    # parameters is a relation value with heading:
    # Name string Ctype string Type string Class string

    variable block 1
    try {
        foreach param [relation body $parameters] {
            InsertSymbol {*}$param
        }
        return [actexpand expand $body]
    } on error {result} {
        # puts $::errorInfo
        log::error $result
        variable errcount
        incr errcount
        set msg [pipe {
            split $result \n |
            lrange ~ 1 2 |
            string map [list \" {}] ~ |
            join ~
        }]
        return "#error \"$msg\""
    } finally {
        relvar set Symbol [relation emptyof [relvar set Symbol]]
    }
}
----

[source,tcl]
----
<<generation support commands>>=
proc End {} {
    set result {}

    set context [actexpand cname]
    switch -exact -- $context {
        InstanceSetForeachSelected -
        InstanceForeachRelated -
        ClassForeachInstance {
            set result [PopContext $context depth]
            for {set i 0} {$i < $depth} {incr i} {
                PopBlock
                append result [IndentToBlock "\}\n"]
            }
        }
        default {
            error "unknown context, \"$context\""
        }
    }
    append result [IndentToBlock [linecomment end]]

    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc InvokeExternalOp {opName args} {
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set opRef [ExternalOperation findWhere {$Domain eq $domain &&\
            $Name eq $opName}]
    if {[isEmptyRef $opRef]} {
        error "unknown external operation, $opName, for domain, $domain"
    }

    append result "${domain}_${opName}__EOP\("
    set pset {}
    set paramRefs [findRelated $opRef ~R11]
    relation foreach param [deRef $paramRefs] -ascending Number {
        relation assign $param
        if {![dict exists $args $Name]} {
            error "no value given for the $Name parameter"
        }
        append pset "[dict get $args $Name], "
    }
    set pset [string trimright $pset {, }]

    append result $pset "\) ;"
    return [IndentToBlock $result]
}
----

=== Instance Commands

[source,tcl]
----
<<generation support commands>>=
proc InstanceAttribute {instref attr} {
    variable domain

    set sym [CheckInstRefSymbol $instref]
    set attrRef [Attribute findById Domain $domain Class [dict get $sym Class]\
            Name $attr]
    if {[isEmptyRef $attrRef]} {
        error "instance reference, $instref, refers to an instance of\
            class, [dict get $sym Class], which does not have an attribute\
            named, $attr"
    }
    return "$instref->$attr"
}
----

[source,tcl]
----
<<generation support commands>>=
proc ParseAttrVars {instref attrvars} {
    variable domain

    set sym [CheckInstRefSymbol $instref]
    set className [dict get $sym Class]

    if {[llength $attrvars] == 0} {
        # look up the attributes of the class
        set attrs [pipe {
            Attribute findWhere {$Domain eq $domain && $Class eq $className} |
            deRef ~ |
            relation project ~ Name DataType
        }]
        set attrNames [relation list $attrs Name -ascending Name]
        set varNames $attrNames
        set dataTypes [relation list $attrs DataType -ascending Name]
    } else {
        set attrNames [list]
        set varNames [list]
        foreach attrvar $attrvars {
            set l [llength $attrvar]
            if {$l < 1 || $l > 2} {
                error "bad format for attribute name /variable name pair,\
                        \"$attrvar\""
            }
            set attrName [lindex $attrvar 0]
            set attrRef [Attribute findById Domain $domain Class $className\
                Name $attrName]
            if {[isEmptyRef $attrRef]} {
                error "class, $className, does not have an attribute named,\
                    \"$attrName\""
            }
            lappend attrNames $attrName
            lappend dataTypes [readAttribute $attrRef DataType]
            if {$l == 1} {
                set varName $attrName
            } elseif {$l == 2} {
                set varName [lindex $attrvar 1]
                if {[::struct::set contains $varNames $varName]} {
                    error "duplicate variable name, \"$varName\""
                }
            }
            lappend varNames $varName
        }
    }
    return [list $attrNames $varNames $dataTypes]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceDelete {instref} {
    CheckInstRefSymbol $instref
    append result\
        [linecomment "instance $instref delete"]\
        "mrt_DeleteInstance($instref) ;\n"
    DeleteSymbol $instref
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceOperation {instref opName args} {
    set instsym [CheckInstRefSymbol $instref]
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set className [dict get $instsym Class]
    set opRef [Operation findWhere {$Domain eq $domain && $Class eq $className\
        && $Name eq $opName && $IsInstance}]
    if {[isEmptyRef $opRef]} {
        error "unknown instance operation, $opName, for class, $className"
    }

    dict set args self $instref
    append result "${className}_$opName\("
    set pset {}
    set paramRefs [findRelated $opRef ~R4]
    relation foreach param [deRef $paramRefs] -ascending Number {
        relation assign $param
        if {![dict exists $args $Name]} {
            error "no value given for the $Name parameter"
        }
        append pset "[dict get $args $Name], "
    }
    set pset [string trimright $pset {, }]

    append result $pset "\)"
    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceForeachRelated {instref startref args} {
    variable domain

    set startsym [CheckInstRefSymbol $startref]
    set startClass [dict get $startsym Class]
    set startlevel [GetBlock]
    set result [IndentToBlock\
        [linecomment "instance $instref foreachRelated $startref $args"]\
    ]

    foreach relspec $args {
        set relinfo [LookUpRelationship $relspec]
        while {[llength $relinfo] != 0} {
            # puts "relinfo = \"$relinfo\""
            set relinfo [lassign $relinfo sourceclass targetclass reftype cond\
                comp]
            switch -exact -- $reftype {
                reference {
                    if {$startClass ne $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            $sourceclass to $targetclass, got, $startClass,\
                            as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass]\
                        targettype targetref
                    set refcode "$targettype$targetref = $startref->$comp ;\
                    // $relspec \n"
                    if {$cond} {
                        append refcode "if ($targetref != NULL) \{\n"
                        append result [IndentToBlock $refcode]
                        PushBlock
                    } else {
                        append result [IndentToBlock $refcode]
                    }
                }
                array {
                    if {$startClass ne $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            $sourceclass to $targetclass, got, $startClass,\
                            as the traversal start"
                    }
                    set itervar [CreateTempSymbol\
                        Ctype "struct $targetclass *const *"\
                        Type "ReferenceArray" Class $targetclass]
                    set cntvar [CreateTempSymbol Ctype size_t Type ArrayCounter\
                        Class $targetclass]
                    set refcode\
                        "struct $targetclass *const *$itervar =\
                            $startref->$comp.links ; // $relspec\n"
                    append refcode\
                        "for (size_t $cntvar = $startref->$comp.count ;\
                            $cntvar != 0 ; $cntvar--, $itervar++) \{"
                    append result [IndentToBlock $refcode]
                    PushBlock
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref = *$itervar ;"]
                }
                linked {
                    if {$startClass ne $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            $sourceclass to $targetclass, got, $startClass,\
                            as the traversal start"
                    }
                    set itervar [CreateTempSymbol Ctype "MRT_LinkRef *"\
                        Type "ReferenceLink" Class $targetclass]
                    lassign $comp termcomp linkcomp
                    append result [IndentToBlock\
                        "for (MRT_LinkRef *$itervar =\
                            mrtLinkRefBegin(&$startref->$termcomp) ;\
                            $itervar != mrtLinkRefEnd(&$startref->$termcomp) ;)\
                            \{\n"]
                    PushBlock
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock [string cat\
                        "$targettype$targetref =\
                            ($targettype)((uintptr_t)$itervar -\
                            offsetof(struct $targetclass, $linkcomp)) ;\n"\
                        "$itervar = $itervar->next ;\n"\
                    ]]
                }
                reftosuper {
                    if {$startClass ni $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            \"[join $sourceclass {, }]\", to $targetclass,\
                            got, $startClass, as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref = $startref->$comp ;\
                        // $relspec \n"]
                }
                reftosub {
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    set subnum [GetClassProperty $targetclass Number]
                    set refcode\
                        "$targettype$targetref = $startref->$comp ;\
                            // $relspec\n"
                    append refcode\
                        "if ($targetref->base__INST.classDesc ==\
                        &${domain}__CLASSES\[$subnum\]) \{\n"
                    append result [IndentToBlock $refcode]
                    PushBlock
                }
                uniontosuper {
                    if {$startClass ni $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            \"[join $sourceclass {, }]\", to $targetclass,\
                            got, $startClass, as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref =\
                        ($targettype)((uintptr_t)$startref -\
                        offsetof(struct $targetclass, $comp.$startClass)) ;\
                        // $relspec \n"]
                }
                uniontosub {
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    set subnum [GetClassProperty $targetclass Number]
                    set refcode\
                        "$targettype$targetref = &$startref->$comp.$targetclass ;\
                            // $relspec\n"
                    append refcode\
                        "if ($targetref->base__INST.classDesc ==\
                        &${domain}__CLASSES\[$subnum\]) \{\n"
                    append result [IndentToBlock $refcode]
                    PushBlock
                }
            }
            set startClass $targetclass
            set startref $targetref
        }
    }
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $targetclass $instref]\
        "$instref = $targetref ;\n"]]

    PushContext InstanceForeachRelated depth [expr {[GetBlock] - $startlevel}]

    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc LookUpRelationship {relspec} {
    variable domain

    lassign $relspec relname destclass
    if {[string index $relname 0] eq "~"} {
        set dir back
        set relname [string range $relname 1 end]
    } else {
        set dir forw
    }

    set relRef [Relationship findById Domain $domain Name $relname]
    set assocRef [findRelated $relRef {~R30 Association}]
    if {[isNotEmptyRef $assocRef]} {
        set isstatic [readAttribute $assocRef IsStatic]
        set sassocRef [findRelated $assocRef {~R31 SimpleAssociation}]
        if {[isNotEmptyRef $sassocRef]} {
            if {$destclass ne {}} {
                error "simple association, $relname, cannot have a\
                    destination specifier"
            }
            assignAttribute [findRelated $sassocRef ~R32]\
                {Class srcclass} {Conditionality srccond} {Multiplicity srcmult}
            assignAttribute [findRelated $sassocRef ~R33]\
                {Class trgclass} {Conditionality trgcond}
            if {$dir eq "forw"} {
               return [list $srcclass $trgclass reference $trgcond $relname]
            } else {
                if {!$srcmult} {
                    set type reference
                    set comp ${relname}__BACK
                } else {
                    if {$isstatic} {
                        set type array
                        set comp ${relname}__BACK
                    } else {
                        set type linked
                        set comp [list ${relname}__BACK ${relname}__BLINKS]
                    }
                }
                return [list $trgclass $srcclass $type $srccond $comp]
            }
        } else {
            set cassocRef [findRelated $assocRef {~R31 ClassBasedAssociation}]
            assignAttribute [findRelated $cassocRef ~R34]\
                {Class srcclass} {Conditionality srccond} {Multiplicity srcmult}
            assignAttribute [findRelated $cassocRef ~R35]\
                {Class trgclass} {Conditionality trgcond} {Multiplicity trgmult}
            assignAttribute [findRelated $cassocRef ~R42]\
                {Class assocclass}
            if {!$trgmult} {
                set srctype reference
                set srccomp ${relname}__FORW
            } else {
                if {$isstatic} {
                    set srctype array
                    set srccomp ${relname}__FORW
                } else {
                    set srctype linked
                    set srccomp [list ${relname}__FORW ${relname}__FLINKS]
                }
            }
            if {!$srcmult} {
                set trgtype reference
                set trgcomp ${relname}__BACK
            } else {
                if {$isstatic} {
                    set trgtype array
                    set trgcomp ${relname}__BACK
                } else {
                    set trgtype linked
                    set trgcomp [list ${relname}__BACK ${relname}__BLINKS]
                }
            }
            if {$destclass eq {}} {
                if {$dir eq "forw"} {
                    return [list\
                        $srcclass $assocclass $srctype $trgcond $srccomp\
                        $assocclass $trgclass reference false\
                        ${relname}.forward\
                    ]
                } else {
                    return [list\
                        $trgclass $assocclass $trgtype $srccond $trgcomp\
                        $assocclass $srcclass reference false\
                        ${relname}.backward\
                    ]
                }
            } else {
                if {$destclass eq $assocclass} {
                    if {$dir eq "forw"} {
                        return [list $srcclass $assocclass $srctype $trgcond\
                            $srccomp]
                    } else {
                        return [list $trgclass $assocclass $trgtype $srccond\
                            $trgcomp]
                    }
                } elseif {$destclass eq $trgclass} {
                    if {$dir eq "forw"} {
                        return [list $assocclass $trgclass reference false\
                            ${relname}.forward]
                    } else {
                        error "navigating forward from $assocclass arrives at\
                            $trgclass: got $destclass"
                    }
                } elseif {$destclass eq $srcclass} {
                    if {$dir eq "back"} {
                        return [list $assocclass $srcclass reference false\
                            ${relname}.backward]
                    } else {
                        error "navigating backward from $assocclass arrives at\
                            $srcclass: got $destclass"
                    }
                } else {
                    error "$destclass does not participate in $relname"
                }
            }
        }
    } else {
        set genRef [findRelated $relRef {~R30 Generalization}]
        set refGenRef [findRelated $genRef {~R43 ReferenceGeneralization}]
        if {[isNotEmptyRef $refGenRef]} {
            set super [readAttribute [findRelated $refGenRef ~R36] Class]
            set subs [findRelated $refGenRef ~R37]
            set subnames [relation list [deRef $subs] Class]
            if {$dir eq "forw"} {
                if {$destclass ne {}} {
                    error "generalization, $relname, cannot have a\
                        destination specifier when traversing to the superclass"
                }
                return [list $subnames $super reftosuper false $relname]
            } else {
                if {$destclass eq {}} {
                    error "generalization, $relname, must specify a\
                        destination when traversing to a subclass"
                } elseif {$destclass ni $subnames} {
                    error "generalization, $relname, cannot traverse to\
                        class, $destclass: should be one of:\
                        \"[join $subnames {, }]\""
                }
                return [list $super $destclass reftosub false $relname]
            }
        } else {
            set uGenRef [findRelated $genRef {~R43 UnionGeneralization}]
            set super [readAttribute [findRelated $uGenRef ~R44] Class]
            set subs [findRelated $uGenRef ~R45]
            set subnames [relation list [deRef $subs] Class]
            if {$dir eq "forw"} {
                if {$destclass ne {}} {
                    error "generalization, $relname, cannot have a\
                        destination specifier when traversing to the superclass"
                }
                return [list $subnames $super uniontosuper false $relname]
            } else {
                if {$destclass eq {}} {
                    error "generalization, $relname, must specify a\
                        destination when traversing to a subclass"
                } elseif {$destclass ni $subnames} {
                    error "generalization, $relname, cannot traverse to\
                        class, $destclass: should be one of:\
                        \"[join $subnames {, }]\""
                }
                return [list $super $destclass uniontosub false $relname]
            }
        }
    }
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-36.0 {
    Navigate simple association -- singular
} -setup {
    # makeFile {} codegen36.h
    # makeFile {} codegen36.c
    micca configure {
        domain codegen36 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 20
            }
            association R2 Z 0..1--1 Y

            domainop void findys {} {
                %<X foreachInstance xs>%
                    %<instance z foreachRelated xs R1 ~R2>%
                        printf("z.value = %d\n",
                            %<instance z attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen36 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1} codegen36.c]] == 1}\
        {[llength [fileutil::grep {->R2__BACK} codegen36.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-37.0 {
    Navigate simple association -- multiple static
} -setup {
    # makeFile {} codegen37.h
    # makeFile {} codegen37.c
    micca configure {
        domain codegen37 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 20
            }
            association R2 -static Z 0..*--1 Y

            domainop void findys {} {
                %<X foreachInstance xs>%
                    %<instance z foreachRelated xs R1 ~R2>%
                        printf("z.value = %d\n",
                            %<instance z attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen37 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1} codegen37.c]] == 1}\
        {[llength [fileutil::grep {->R2__BACK} codegen37.c]] == 2}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-38.0 {
    Navigate simple association -- multiple dynamic
} -setup {
    # makeFile {} codegen38.h
    # makeFile {} codegen38.c
    micca configure {
        domain codegen38 {
            class X {}
            class Y {}
            association R1 X 1--1 Y

            class Z {
                attribute value int -default 20
            }
            association R2 -dynamic Z 0..*--1 Y

            domainop void findys {} {
                %<X foreachInstance xs>%
                    %<instance z foreachRelated xs R1 ~R2>%
                        printf("z.value = %d\n",
                            %<instance z attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen38 {
            class X {
                instance x1 R1 y1
            }
            class Y {
                instance y1
            }
            class Z {
                instance z1 R2 y1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1} codegen38.c]] == 1}\
        {[llength [fileutil::grep {->R2__BACK} codegen38.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-43.0 {
    Navigate class based association -- singular
} -setup {
    # makeFile {} codegen43.h
    # makeFile {} codegen43.c
    micca configure {
        domain codegen43 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -associator A X 1--1 Y

            domainop void findys {} {
                %<X foreachInstance xs>%
                    %<instance y foreachRelated xs R1>%
                        printf("y.value = %d\n", %<instance y attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen43 {
            class A {
                instance a1 R1 {X x1 Y y1}
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1.forward} codegen43.c]] == 1}\
        {[llength [fileutil::grep {->R1__FORW} codegen43.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-44.0 {
    Navigate class based association -- singular, stop at associator
} -setup {
    # makeFile {} codegen44.h
    # makeFile {} codegen44.c
    micca configure {
        domain codegen44 {
            class A {
                attribute value int -default 40
            }
            class X {}
            class Y {}
            association R1 -associator A X 1--1 Y

            domainop void findys {} {
                %<X foreachInstance xs>%
                    %<instance a foreachRelated xs {R1 A}>%
                        printf("a.value = %d\n", %<instance a attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen44 {
            class A {
                instance a1 R1 {X x1 Y y1}
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1__FORW} codegen44.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-45.0 {
    Navigate class based association -- multiple, static
} -setup {
    # makeFile {} codegen45.h
    # makeFile {} codegen45.c
    micca configure {
        domain codegen45 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -static -associator A X 1..*--1 Y

            domainop void findys {} {
                %<X foreachInstance xs>%
                    %<instance y foreachRelated xs R1>%
                        printf("y.value = %d\n", %<instance y attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen45 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1.forward} codegen45.c]] == 1}\
        {[llength [fileutil::grep {->R1__FORW} codegen45.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-46.0 {
    Navigate class based association -- multiple, static
} -setup {
    # makeFile {} codegen46.h
    # makeFile {} codegen46.c
    micca configure {
        domain codegen46 {
            class A {}
            class X {}
            class Y {
                attribute value int -default 40
            }
            association R1 -associator A X 1..*--1..* Y

            domainop void findys {} {
                %<X foreachInstance xs>%
                    %<instance y foreachRelated xs R1>%
                        printf("y.value = %d\n", %<instance y attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen46 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1.forward} codegen46.c]] == 1}\
        {[llength [fileutil::grep {->R1__FORW} codegen46.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-39.0 {
    Navigate reference generalization from subclass to superclass
} -setup {
    # makeFile {} codegen39.h
    # makeFile {} codegen39.c
    micca configure {
        domain codegen39 {
            class S {
                attribute value int -default 20
            }
            class Y {}
            class Z {}
            generalization R1 -reference S Y Z

            domainop void findss {} {
                %<Y foreachInstance ys>%
                    %<instance s foreachRelated ys R1>%
                        printf("s.value = %d\n",
                            %<instance s attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen39 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1} codegen39.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-40.0 {
    Navigate union generalization from subclass to superclass
} -setup {
    # makeFile {} codegen40.h
    # makeFile {} codegen40.c
    micca configure {
        domain codegen40 {
            class S {
                attribute value int -default 20
            }
            class Y {}
            class Z {}
            generalization R1 -union S Y Z

            domainop void findss {} {
                %<Y foreachInstance ys>%
                    %<instance s foreachRelated ys R1>%
                        printf("s.value = %d\n",
                            %<instance s attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen40 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {offsetof} codegen40.c]] == 3}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-41.0 {
    Navigate reference generalization from superclass to subclass
} -setup {
    # makeFile {} codegen41.h
    # makeFile {} codegen41.c
    micca configure {
        domain codegen41 {
            class S {}
            class Y {
                attribute value int -default 20
            }
            class Z {}
            generalization R1 -reference S Y Z

            domainop void findss {} {
                %<S foreachInstance ss>%
                    %<instance y foreachRelated ss {~R1 Y}>%
                        printf("y.value = %d\n",
                            %<instance y attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen41 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1} codegen41.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-42.0 {
    Navigate reference generalization from superclass to subclass
} -setup {
    # makeFile {} codegen42.h
    # makeFile {} codegen42.c
    micca configure {
        domain codegen42 {
            class S {}
            class Y {
                attribute value int -default 20
            }
            class Z {}
            generalization R1 -union S Y Z

            domainop void findss {} {
                %<S foreachInstance ss>%
                    %<instance y foreachRelated ss {~R1 Y}>%
                        printf("y.value = %d\n",
                            %<instance y attribute value>%) ;
                    %<end>%
                %<end>%
            }
        }
        population codegen42 {
            class S {
                instance s1
            }
            class Y {
                instance y1 R1 s1
            }
            class Z {
                allocate 1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->R1} codegen42.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceFindOneRelated {instref startref args} {
    variable domain

    set startsym [CheckInstRefSymbol $startref]
    set startClass [dict get $startsym Class]
    set heading [IndentToBlock\
        [linecomment "instance $instref findOneRelated $startref $args"]\
    ]
    set startlevel [GetBlock]
    set isCond false

    foreach relspec $args {
        set relinfo [LookUpRelationship $relspec]
        while {[llength $relinfo] != 0} {
            # puts "relinfo = \"$relinfo\""
            set relinfo [lassign $relinfo sourceclass targetclass reftype cond\
                comp]
            switch -exact -- $reftype {
                reference {
                    if {$startClass ne $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            $sourceclass to $targetclass, got, $startClass,\
                            as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass]\
                        targettype targetref
                    set refcode "$targettype$targetref = $startref->$comp ;\
                    // $relspec \n"
                    if {$cond} {
                        set isCond true
                        append refcode "if ($targetref != NULL) \{\n"
                        append result [IndentToBlock $refcode]
                        PushBlock
                    } else {
                        append result [IndentToBlock $refcode]
                    }
                }
                array -
                linked {
                    error "relationship, [lindex $relspec 0], is\
                        multiple from $sourceclass to $targetclass"
                }
                reftosuper {
                    if {$startClass ni $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            \"[join $sourceclass {, }]\", to $targetclass,\
                            got, $startClass, as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref = $startref->$comp ;\
                        // $relspec \n"]
                }
                reftosub {
                    set isCond true
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    set subnum [GetClassProperty $targetclass Number]
                    set refcode\
                        "$targettype$targetref = $startref->$comp ;\
                            // $relspec\n"
                    append refcode\
                        "if ($targetref->base__INST.classDesc ==\
                        &${domain}__CLASSES\[$subnum\]) \{\n"
                    append result [IndentToBlock $refcode]
                    PushBlock
                }
                uniontosuper {
                    if {$startClass ni $sourceclass} {
                        error "relationship, [lindex $relspec 0], is from\
                            \"[join $sourceclass {, }]\", to $targetclass,\
                            got, $startClass, as the traversal start"
                    }
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    append result [IndentToBlock\
                        "$targettype$targetref =\
                        ($targettype)((uintptr_t)$startref -\
                        offsetof(struct $targetclass, $comp.$startClass)) ;\
                        // $relspec \n"]
                }
                uniontosub {
                    set isCond true
                    lassign [CreateTempRefSymbol $targetclass] targettype\
                            targetref
                    set subnum [GetClassProperty $targetclass Number]
                    set refcode\
                        "$targettype$targetref = &$startref->$comp.$targetclass ;\
                            // $relspec\n"
                    append refcode\
                        "if ($targetref->base__INST.classDesc ==\
                        &${domain}__CLASSES\[$subnum\]) \{\n"
                    append result [IndentToBlock $refcode]
                    PushBlock
                }
            }
            set startClass $targetclass
            set startref $targetref
        }
    }
    append result [IndentToBlock "$instref = $targetref ;\n"]

    for {set i [expr {[GetBlock] - $startlevel}]} {$i > 0} {incr i -1} {
        PopBlock
        append result [IndentToBlock "\}\n"]
    }
    append heading [IndentToBlock [CreateInstRefSymbol $targetclass $instref]]
    if {$isCond} {
        append heading [IndentToBlock "$instref = NULL ;\n"]
    }

    return [string cat $heading $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSignal {instref event args} {
    append result [linecomment "instance $instref signal $event [list $args]"]
    lassign [InstanceNewECB $instref $event $args] ecbvar ecbcode
    append result $ecbcode "mrt_PostEvent($ecbvar) ;\n"
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceDelaySignal {instref time event args} {
    append result [linecomment "instance $instref delaysignal $time\
            $event [list $args]"]
    lassign [InstanceNewECB $instref $event $args] ecbvar ecbcode
    append result $ecbcode "mrt_PostDelayedEvent($ecbvar, $time) ;\n"
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceCancelSignal {instref event {sourceref {}}} {
    variable domain

    append result [linecomment "instance $instref canceldelayed $event\
        [list $sourceref]"]
    set target [CheckInstRefSymbol $instref]
    set eventNum [FindEventNumber [dict get $target Class] $event]
    if {$sourceref ne {}} {
        CheckInstRefSymbol $sourceref
        set sourceinst $sourceref
    } else {
        set sourceinst NULL
    }
    append result\
        "mrt_CancelDelayedEvent($eventNum, $instref, $sourceinst) ;\n"
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceRemainingTime {instref event {sourceref {}}} {
    variable domain

    set target [CheckInstRefSymbol $instref]
    set eventNum [FindEventNumber [dict get $target Class] $event]
    if {$sourceref ne {}} {
        CheckInstRefSymbol $sourceref
        set sourceinst $sourceref
    } else {
        set sourceinst NULL
    }
    return "mrt_RemainingDelayTime($eventNum, $instref, $sourceinst)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceRefToId {instref} {
    CheckInstRefSymbol $instref
    return "mrt_InstanceIndex($instref)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceNewECB {instref event arglist} {
    variable domain

    if {[llength $arglist] % 2 != 0} {
        error "event parameters must be given as name / value pairs, got:\
            \"$arglist\""
    }
    set target [CheckInstRefSymbol $instref]

    dict with target {
        set eventRef [Event findById Domain $domain Model $Class Event $event]
        if {[isEmptyRef $eventRef]} {
            error "event, $event, is not a known event for class, $Class"
        }

        set transRef [findRelated $eventRef {~R80 TransitioningEvent}]
        if {[isNotEmptyRef $transRef]} {
            assignAttribute $transRef {Number eventNum}
            set eventType mrtTransitionEvent
        } else {
            set deferredRef [findRelated $eventRef {~R80 DeferredEvent}]
            assignAttribute $deferredRef {Number eventNum}
            set eventType mrtPolymorphicEvent
        }

        set psig [findRelated $eventRef R69]
        set params [FindParamsFromSig $psig]
        set required [relation list $params Name]
        set supplied [dict keys $arglist]
        if {![::struct::set equal $required $supplied]} {
            error "event, $event, requires parameters,\
                \"[join $required {, }]\", got:\
                \"[join $supplied {, }]\""
        }

        set result {}
        set sourceinst [expr {[LookUpSymbol self] eq {} ? "NULL" : "self"}]
        set ecbvar [CreateTempSymbol Ctype {MRT_ecb *} Type ECB Class $Class]
        append result "MRT_ecb *$ecbvar = mrt_NewEvent($eventNum,\
            $eventType, $instref, $sourceinst) ;\n"
        if {[relation isnotempty $params]} {
            set eparamsname ${domain}_${Class}_${event}__EPARAMS
            set ptrparams [CreateTempSymbol Ctype "struct *$eparamsname"\
                Type EventParams Class $Class]
            append result\
                "struct $eparamsname *const $ptrparams =\n"\
                "    (struct $eparamsname *)$ecbvar->eventParameters ;\n"
            relation foreach param $params -ascending Position {
                relation assign $param Name
                append result "$ptrparams->$Name = [dict get $arglist $Name] ;\n"
            }
        }
    }
    return [list $ecbvar $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc FindEventNumber {class event} {
    variable domain
    set eventRef [Event findById Domain $domain Model $class Event $event]
    if {[isEmptyRef $eventRef]} {
        error "event, $event, is not a known event for class, $Class"
    }

    set transRef [findRelated $eventRef {~R80 TransitioningEvent}]
    if {[isNotEmptyRef $transRef]} {
        return [readAttribute $transRef Number]
    } else {
        set deferredRef [findRelated $eventRef {~R80 DeferredEvent}]
        return [readAttribute $deferredRef Number]
    }
}
----

=== Instance Set Commands

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetForeachSelected {set inst} {
    set setsym [CheckInstSetSymbol $set]

    set startlevel [GetBlock]
    set iter [CreateTempSymbol Ctype MRT_InstSetIterator Type SetIterator\
            Class [dict get $setsym Class]]
    append result [IndentToBlock [string cat\
        "MRT_InstSetIterator $iter ;\n"\
        "for (mrt_InstSetIterBegin(&$set, &$iter) ;\
        mrt_InstSetIterMore(&$iter) ; mrt_InstSetIterNext(&$iter)) \{\n"\
    ]]
    PushBlock

    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol [dict get $setsym Class] $inst]\
        "$inst = mrt_InstSetIterGet(&$iter) ;\n"\
    ]]

    PushContext InstanceSetForeachSelected\
            depth [expr {[GetBlock] - $startlevel}]

    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetEmpty {set} {
    CheckInstSetSymbol $set
    return "mrt_InstSetEmpty(&$set)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetNotEmpty {set} {
    return ![InstanceSetEmpty $set]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetEqual {set1 set2} {
    set sym1 [CheckInstSetSymbol $set1]
    CheckInstSetSymbol $set2 Class [dict get $sym1 Class]
    return "mrt_InstSetEqual(&$set1, &$set2)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetNotEqual {set1 set2} {
    return ![InstanceSetEqual $set1 $set2]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetAdd {set inst} {
    set setsym [CheckInstSetSymbol $set]
    set instsym [CheckInstRefSymbol $inst Class [dict get $setsym Class]]
    return [IndentToBlock [string cat\
        [linecomment "instset $set add $inst"]\
        "mrt_InstSetAddInstance(&$set, $inst) ;\n"\
    ]]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetUnion {opset set1 set2 args} {
    tailcall InstanceSetOperation union mrt_InstSetUnion $opset $set1 $set2\
            {*}$args
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetIntersect {opset set1 set2 args} {
    tailcall InstanceSetOperation intersect mrt_InstSetIntersect $opset\
            $set1 $set2 {*}$args
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetOperation {label op opset set1 set2 args} {
    variable domain

    set sym1 [CheckInstSetSymbol $set1]
    set className [dict get $sym1 Class]
    CheckInstSetSymbol $set2 Class $className

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [linecomment "instset $opset $label $set1 $args"]\
        [CreateInstSetSymbol $className $opset]\
        "mrt_InstSetInitialize(&$opset, &$classDesc) ;\n"\
        "$op\(&$set1, &$set2, &$opset\) ;\n"
    foreach set $args {
        CheckInstSetSymbol $set Class $className
        append result "$op\(&$opset, &$set, &$opset\) ;\n"
    }
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc InstanceSetMinus {diffset set1 set2} {
    variable domain

    set sym1 [CheckInstSetSymbol $set1]
    set className [dict get $sym1 Class]
    set sym2 [CheckInstSetSymbol $set2 Class $className]

    set classDesc [GetClassDescriptor $domain $className]
    append result\
        [linecomment "instset $diffset minus $set1 $set2"]\
        [CreateInstSetSymbol $className $diffset]\
        "mrt_InstSetInitialize(&$diffset, &$classDesc) ;\n"\
        "mrt_InstSetMinus(&$set1, &$set2, &$diffset) ;\n"
    return [IndentToBlock $result]
}
----

=== Class Commands

[source,tcl]
----
<<generation support commands>>=
proc ClassCreate {className instref args} {
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    set attrvalues [GetAttrInitialValues $className $args]

    append result\
        [linecomment "$className create $instref $args"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_CreateInstance(&$classDesc, MRT_StateCode_IG) ;\n"\
        [AssignAttributeValues $className $instref $attrvalues]

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc AssignAttributeValues {className instref attrvalues} {
    variable domain
    set result {}
    foreach {attrName attrValue} $attrvalues {
        set attrRef [Attribute findById Domain $domain Class $className\
            Name $attrName]
        lassign [readAttribute $attrRef DataType Dimension] type dim
        if {$dim > 0} {
            # Got a matrix, see if it is a string
            if {$type eq "char"} {
                set maxchars [expr {$dim - 1}]
                append result\
                    "strncpy($instref->$attrName, $attrValue, $maxchars) ;\n"\
                    "$instref->$attrName\[$maxchars\] = '\\0' ;\n"
            } else {
                append result "memcpy($instref->$attrName, $attrValue,\
                    sizeof($instref->$attrName)) ;\n"
            }
        } else {
            append result "$instref->$attrName = $attrValue ;\n"
        }
    }
    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc GetAttrInitialValues {className attrvalues} {
    if {[llength $attrvalues] % 2 != 0} {
        error "attribute names / values must be given in pairs,\
            got: \"$attrvalues\""
    }
    set required [FindRequiredAttributes $className]
    set defaulted [FindDefaultedAttributes $className]
    set supplied [dict keys $attrvalues]

    set missing [::struct::set difference $required $supplied]
    if {![::struct::set empty $missing]} {
        error "values for attributes, \"[join $missing {, }]\", must be\
            provided"
    }
    set all [::struct::set union $required [dict keys $defaulted]]
    set extra [::struct::set difference $supplied $all]
    if {![::struct::set empty $extra]} {
        error "class, $className, has no attribute(s) named,\
            \"[join $extra {, }]\""
    }

    return [dict merge $defaulted $attrvalues]
}
----

[source,tcl]
----
<<generation support commands>>=
proc FindRequiredAttributes {className} {
    variable domain
    set attrRefs [Attribute findWhere\
        {$Domain eq $domain && $Class eq $className}]
    set defRefs [findRelated $attrRefs ~R22 R22]
    return [pipe {
        refMinus $attrRefs $defRefs |
        deRef ~ |
        relation list ~ Name
    }]
}

proc FindDefaultedAttributes {className} {
    variable domain
    return [pipe {
        DefaultValue findWhere {$Domain eq $domain && $Class eq $className} |
        deRef ~ |
        relation dict ~ Attribute Value
    }]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.0 {
    Generated code file instance creation
} -setup {
    # makeFile {} codegen26.h
    # makeFile {} codegen26.c
    micca configure {
        domain codegen26 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx color 30 temp 22>%
                printf("%d\n", %<instance newx attribute color>%) ;
            }
        }
        population codegen26 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_CreateInstance} codegen26.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.1 {
    Generated code file instance creation -- bad arguments to create
} -setup {
    makeFile {} codegen26_1.h
    makeFile {} codegen26_1.c
    micca configure {
        domain codegen26_1 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx 30>% // need name / value pairs
            }
        }
        population codegen26_1 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.2 {
    Generated code file instance creation -- missing attribute
} -setup {
    makeFile {} codegen26_2.h
    makeFile {} codegen26_2.c
    micca configure {
        domain codegen26_2 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx>% // missing attribute, temp
            }
        }
        population codegen26_2 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.3 {
    Generated code file instance creation -- extra attribute
} -setup {
    makeFile {} codegen26_3.h
    makeFile {} codegen26_3.c
    micca configure {
        domain codegen26_3 {
            class X {
                attribute color int -default 20
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx temp 20 size 30>% // no attribute, size
            }
        }
        population codegen26_3 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generate command tests>>=
test codegen-26.4 {
    Generated code file instance creation with string
} -setup {
    # makeFile {} codegen26_4.h
    # makeFile {} codegen26_4.c
    micca configure {
        domain codegen26_4 {
            class X {
                attribute color char -dimension 32 -default {"red"}
                attribute temp int
            }
            domainop void newX {} {
                %<X create newx color {"blue"} temp 22>%
                printf("%s\n", %<instance newx attribute color>%) ;
                char *newcolor = "yellow" ;
                %<X create newx color newcolor temp 10>%
            }
        }
        population codegen26_4 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {strncpy} codegen26_4.c]] == 2}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassCreateIn {className instref state args} {
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    set statenum [GetStateNumber $domain $className $state]
    set attrvalues [GetAttrInitialValues $className $args]

    append result\
        [linecomment "$className createin $instref $state $args"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_CreateInstance(&$classDesc, $statenum) ;\n"\
        [AssignAttributeValues $className $instref $attrvalues]

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc GetStateNumber {domain className state} {
    set stateRef [StatePlace findById Domain $domain Model $className\
            Name $state]
    if {[isEmptyRef $stateRef]} {
        error "class, $className, has no state named, $state"
    }
    return [readAttribute $stateRef Number]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-27.0 {
    Generated code file instance creation in a given state
} -setup {
    # makeFile {} codegen27.h
    # makeFile {} codegen27.c
    micca configure {
        domain codegen27 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    state s2 {} {
                        printf("in s2\n") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createin newx s2 color 30>%
                printf("%d\n", %<instance newx attribute color>%) ;
            }
        }
        population codegen27 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_CreateInstance} codegen27.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-27.1 {
    Generated code file instance creation in a given state -- bad state
} -setup {
    makeFile {} codegen27_1.h
    makeFile {} codegen27_1.c
    micca configure {
        domain codegen27_1 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {} {
                        printf("in s1\n") ;
                    }
                    state s2 {} {
                        printf("in s2\n") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createin newx s3>%
                printf("%d\n", %<instance newx attribute color>%) ;
            }
        }
        population codegen27_1 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {encountered 1 code generation error(s)} -returnCodes error
----

[source,tcl]
----
<<generation support commands>>=
proc ClassCreateAsync {className event eventparams args} {
    variable domain

    if {[llength $eventparams] % 2 != 0} {
        error "event parameters must be given as name / value pairs, got:\
            \"$eventparams\""
    }
    set eventRef [TransitioningEvent findById Domain $domain Model $className\
            Event $event]
    if {[isEmptyRef $eventRef]} {
        error "class, $className, has no event named, $event"
    }
    set eventNum [readAttribute $eventRef Number]

    append result\
        [linecomment "$className createasync $event [list $eventparams]\
            [list $args]"]

    set psig [findRelated $eventRef R80 R69]
    set params [FindParamsFromSig $psig]
    if {[relation isnotempty $params]} {
        set required [relation list $params Name]
        set supplied [dict keys $eventparams]
        if {![::struct::set equal $required $supplied]} {
            error "event, $event, requires parameters,\
                \"[join $required {, }]\", got:\
                \"[join $supplied {, }]\""
        }

        set eparamsname ${domain}_${className}_${event}__EPARAMS
        set paramvar [CreateTempSymbol Ctype "struct *$eparamsname"\
            Type EventParams Class $className]

        append result\
            "struct $eparamsname $paramvar = \{\n"
        relation foreach param $params -ascending Position {
            relation assign $param Name
            append result "    .$Name = [dict get $eventparams $Name],\n"
        }
        append result "\} ;\n"

        set paramptr &$paramvar
        set paramsize sizeof($paramvar)
    } else {
        set paramptr = NULL ;
        set paramsize = 0 ;
    }

    set sourceinst [expr {[LookUpSymbol self] eq {} ? "NULL" : "self"}]

    lassign [CreateTempRefSymbol $className] reftype refvar
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    set attrvalues [GetAttrInitialValues $className $args]
    append result\
        "$reftype$refvar = mrt_CreateAsync(&$classDesc, $eventNum,\
            $paramptr, $paramsize, $sourceinst) ;\n"\
        [AssignAttributeValues $className $refvar $attrvalues]

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-28.0 {
    asynchronous instance creation
} -setup {
    # makeFile {} codegen28.h
    # makeFile {} codegen28.c
    micca configure {
        domain codegen28 {
            class X {
                attribute color int -default 20
            }

            class X {
                statemodel {
                    state s1 {a int} {
                        printf("in s1 with %d\n", a) ;
                    }
                    state s2 {b char} {
                        printf("in s2 with %c\n", b) ;
                    }
                    transition @ - e3 -> s1
                    transition @ - e4 -> s2
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            domainop void newX {} {
                %<X createasync e3 {a 20} color 30>%
            }
        }
        population codegen28 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_CreateAsync} codegen28.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassForeachInstance {className instref} {
    variable domain

    set iter [CreateTempSymbol Ctype {MRT_InstanceIterator}\
            Type InstanceIterator Class $className]
    set iab [CreateTempSymbol Ctype {MRT_iab *} Type IAB Class $className]

    set startlevel [GetBlock]

    set classDesc [GetClassDescriptor $domain $className]
    set result [IndentToBlock [string cat\
        [linecomment "$className foreachInstance $instref"]\
        "MRT_InstanceIterator $iter ;\n"\
        "for (mrt_InstIteratorStart(&$iter, &$classDesc) ;\
            mrt_InstIteratorMore(&$iter) ;\
            mrt_InstIteratorNext(&$iter)) \{\n"\
    ]]
    PushBlock
    append result [IndentToBlock [string cat\
        [CreateInstRefSymbol $className $instref]\
        "$instref = mrt_InstIteratorGet(&$iter) ;\n"\
    ]]

    PushContext ClassForeachInstance depth [expr {[GetBlock] - $startlevel}]

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-29.0 {
    Iterate over non-union subclass
} -setup {
    # makeFile {} codegen29.h
    # makeFile {} codegen29.c
    micca configure {
        domain codegen29 {
            class X {
                attribute color int -default 20
            }

            domainop void printcolors {} {
                %<X foreachInstance xref>%
                    printf("%d\n", %<instance xref attribute color>%) ;
                %<end>%
            }
        }
        population codegen29 {
            class X {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {xref->color} codegen29.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassInstanceReference {className varName} {
    return [IndentToBlock [string cat\
        [linecomment "$className instRef $varName"]\
        "[CreateInstRefSymbol $className $varName]"\
    ]]
}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassIdToRef {className instid} {
    CheckSymbol $instid Ctype MRT_InstId
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    return "mrt_InstanceIndex($classDesc, $instid)"
}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassFindByName {className instName instref} {
    variable domain
    set instRef [ClassInstance findById Domain $domain Class $className\
        Instance $instName]
    if {[isEmptyRef $instRef]} {
        error "class, $className, has not instance named, $instName"
    }
    set instNum [readAttribute $instRef Number]
    append result\
        [linecomment "$className findByName $instName $instref"]\
        [CreateInstRefSymbol $className $instref]\
        "$instref = &${className}__POOL\[$instNum\] ;\n"\
        "assert($instref->base__INST.alloc > 0) ;\n"
    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-25.0 {
    Iterate over union subclass
} -setup {
    # makeFile {} codegen25.h
    # makeFile {} codegen25.c
    micca configure {
        domain codegen25 {
            class A {}
            class B {}
            class X {
                attribute color int -default 20
                attribute temp int -default 40
                attribute size int -default 50

            }
            generalization R1 -union A B X

            class Y {
                attribute sign bool -default true
                attribute cost int -default 10

                statemodel {
                    state s1 {} {
                        %<Z foreachInstance zref>%
                            printf("%d\n", %<instance zref attribute plus>%) ;
                        %<end>%
                    }
                    transition s1 - e1 -> s1
                }
            }
            class Z {
                attribute magnitude bool -default false
                attribute plus int -default 42
            }

            generalization R2 -union X Y Z
        }
        population codegen25 {
            class A {
                instance a1
                instance a2
                instance a3
                instance a4
            }
            class B {
                instance b1 R1 a1
            }
            class X {
                instance x1 R1 a2
                instance x2 R1 a3
                instance x3 R1 a4
            }
            class Y {
                instance y1 R2 x1
            }
            class Z {
                instance z1 R2 x2
                instance z2 R2 x3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {struct Z} codegen25.c]] == 7}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassOperation {className opName args} {
    if {[llength $args] % 2 != 0} {
        error "operation parameters must be given as name / value pairs"
    }
    variable domain

    set opRef [Operation findWhere {$Domain eq $domain && $Class eq $className\
        && $Name eq $opName && !$IsInstance}]
    if {[isEmptyRef $opRef]} {
        error "unknown class operation, $opName, for class, $className"
    }

    append result "${className}_$opName\("
    set pset {}
    set paramRefs [findRelated $opRef ~R4]
    relation foreach param [deRef $paramRefs] -ascending Number {
        relation assign $param
        if {![dict exists $args $Name]} {
            error "no value given for the $Name parameter"
        }
        append pset "[dict get $args $Name], "
    }
    set pset [string trimright $pset {, }]

    append result $pset "\)"
    return $result
}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassInstanceSet {className varName} {
    variable domain
    set classDesc [GetClassDescriptor $domain $className]
    return [IndentToBlock [string cat\
        [linecomment "$className instSet $varName"]\
        [CreateInstSetSymbol $className $varName]\
        "mrt_InstSetInitialize(&$varName, &$classDesc) ;\n"\
    ]]
}
----

=== Relationship Commands

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleRelateForw {relName source target} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $source $target"]]\
        [SimpleAssocLinkage $relName $source $target mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleRelateBack {relName target source} {
    return [string cat [IndentToBlock\
        [linecomment "~$relName relate $target $source"]]\
        [SimpleAssocLinkage $relName $source $target mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleUnrelateForw {relName source target} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $source $target"]]\
        [SimpleAssocLinkage $relName $source $target mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelSimpleUnrelateBack {relName target source} {
    return [string cat [IndentToBlock\
        [linecomment "~$relName unrelate $source $target"]]\
        [SimpleAssocLinkage $relName $source $target mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc SimpleAssocLinkage {relName sourceref targetref opname} {
    variable domain
    set relRef [SimpleAssociation findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R31 R30] Number]
    set rship &${domain}__RSHIPS\[$relNum\]

    set sourceClass [readAttribute [findRelated $relRef ~R32] Class]
    CheckInstRefSymbol $sourceref Class $sourceClass

    set targetClass [readAttribute [findRelated $relRef ~R33] Class]
    CheckInstRefSymbol $targetref Class $targetClass

    return [IndentToBlock "$opname\($rship, $sourceref, $targetref\) ;\n"]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-30.0 {
    Relate and unrelate simple association
} -setup {
    # makeFile {} codegen30.h
    # makeFile {} codegen30.c
    micca configure {
        domain codegen30 {
            class X {}
            class Y {}

            association R1 X 0..1--0..1 Y

            domainop void makePair {} {
                %<X create xref>%
                %<Y create yref>%
                %<~R1 relate yref xref>%
            }

            domainop void breakPair {} {
                %<X foreachInstance xref>%
                    %<Y foreachInstance yref>%
                        %<R1 unrelate xref yref>%
                    %<end>%
                %<end>%
            }
        }
        population codegen30 {
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Relate} codegen30.c]] == 1}\
        {[llength [fileutil::grep {mrt_Unrelate} codegen30.c]] == 1}
} -result {1}
----

// HERE
// Improve this interface to take advantage of automatically creating
// the associator class instance.
// proc arguments should be:
// proc RelClassRelate {relName oneref otherref {assocref {}} args}
// If the assocref is empty, then create an instance using args as the
// attribute values. Otherwise, use the named reference and args must
// be empty.

[source,tcl]
----
<<generation support commands>>=
proc RelClassRelateForw {relName source target assoc} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $source $target $assoc"]]\
        [ClassAssocLinkage $relName $source $target $assoc mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelClassRelateBack {relName target source assoc} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $target $source $assoc"]]\
        [ClassAssocLinkage $relName $source $target $assoc mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelClassUnrelateForw {relName source target assoc} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $source $target $assoc"]]\
        [ClassAssocLinkage $relName $source $target $assoc mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelClassUnrelateBack {relName target source assoc} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $target $source $assoc"]]\
        [ClassAssocLinkage $relName $source $target $assoc mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc ClassAssocLinkage {relName sourceref targetref assocref opname} {
    variable domain
    set relRef [ClassBasedAssociation findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R31 R30] Number]
    set rship &${domain}__RSHIPS\[$relNum\]

    set sourceClass [readAttribute [findRelated $relRef ~R34] Class]
    CheckInstRefSymbol $sourceref Class $sourceClass

    set targetClass [readAttribute [findRelated $relRef ~R35] Class]
    CheckInstRefSymbol $targetref Class $targetClass

    set assocClass [readAttribute [findRelated $relRef ~R42] Class]
    set assocsym [CheckInstRefSymbol $assocref Class $assocClass]

    return [IndentToBlock "$opname\($rship, $sourceref, $targetref, $assocref\) ;\n"]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-31.0 {
    Relate and unrelate class based association
} -setup {
    # makeFile {} codegen31.h
    # makeFile {} codegen31.c
    micca configure {
        domain codegen31 {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 0..*--0..* Y

            domainop void makePair {} {
                %<X create xref>%
                %<Y create yref>%
                %<A create aref>%
                %<~R1 relate yref xref aref>%
                %<R1 unrelate xref yref aref>%
            }
        }
        population codegen31 {
            class A {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Relate} codegen31.c]] == 1}\
        {[llength [fileutil::grep {mrt_Unrelate} codegen31.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenRelateForw {relName subref superref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $subref $superref"]]\
        [RefGenLinkage $relName $subref $superref mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenRelateBack {relName superref subref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName relate $superref $subref"]]\
        [RefGenLinkage $relName $subref $superref mrt_Relate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenUnrelateForw {relName subref superref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $subref $superref"]]\
        [RefGenLinkage $relName $subref $superref mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenUnrelateBack {relName superref subref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName unrelate $superref $subref"]]\
        [RefGenLinkage $relName $subref $superref mrt_Unrelate]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RefGenLinkage {relName source target opname} {
    variable domain
    set relRef [ReferenceGeneralization findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R43 R30] Number]
    set rship &${domain}__RSHIPS\[$relNum\]

    set superClass [readAttribute [findRelated $relRef ~R36] Class]
    CheckInstRefSymbol $target Class $superClass

    set subsym [CheckInstRefSymbol $source]
    set subrefs [findRelated $relRef ~R37]
    set subclasses [relation list [deRef $subrefs] Class]
    if {[dict get $subsym Class] ni $subclasses} {
        error "expected $source to be a reference to one of,\
            \"[join $subclasses {, }]\", got: [dict get $subsym Class]"
    }

    return [IndentToBlock "$opname\($rship, $source, $target\) ;\n"]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-32.0 {
    Relate and unrelate reference generalization
} -setup {
    # makeFile {} codegen32.h
    # makeFile {} codegen32.c
    micca configure {
        domain codegen32 {
            class S {}
            class X {}
            class Y {}

            generalization R1 S X Y

            domainop void makePair {} {
                %<X create x1>%
                %<S create s1>%
                %<~R1 relate s1 x1>%
                %<R1 unrelate x1 s1>%
            }
        }
        population codegen32 {
            class S {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Relate} codegen32.c]] == 1}\
        {[llength [fileutil::grep {mrt_Unrelate} codegen32.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc RelRefGenReclassify {relName superref subclass subref args} {
    set result [linecomment "$relName reclassify $superref $subclass $subref"]

    variable domain
    set relRef [ReferenceGeneralization findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R43 R30] Number]

    set supername [readAttribute [findRelated $relRef ~R36] Class]
    CheckSuperClassReference $supername $superref
    CheckSubClassName $subclass [findRelated $relRef ~R37]

    set classDesc &${domain}__CLASSES\[[GetClassProperty $subclass Number]\]
    append result\
        [CreateInstRefSymbol $subclass $subref]\
        "$subref = mrt_Reclassify\(&${domain}__RSHIPS\[$relNum\], $superref, "\
        "$classDesc\) ;\n"

    set attrvalues [GetAttrInitialValues $subclass $args]
    foreach {attrName attrValue} $attrvalues {
        append result "$subref->$attrName = $attrValue ;\n"
    }

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generation support commands>>=
proc CheckSuperClassReference {supername superref} {
    set supersym [CheckSymbol $superref]
    if {[dict get $supersym Type] ne "Reference"} {
        error "variable, $superref, is not an instance reference"
    }
    if {$supername ne [dict get $supersym Class]} {
        error "$superref refers to an instance of class,\
            [dict get $supersym Class], but $supername is the super class\
            for $relName"
    }
}
----

[source,tcl]
----
<<generation support commands>>=
proc CheckSubClassName {subclass subRefs} {
    set subclassnames [pipe {
        deRef $subRefs |
        relation list ~ Class
    }]
    if {$subclass ni $subclassnames} {
        error "bad subclass, $subclass, should be one of:\
                [join $subclassnames {, }]"
    }
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-33.0 {
    Reclassify reference generalization
} -setup {
    # makeFile {} codegen33.h
    # makeFile {} codegen33.c
    micca configure {
        domain codegen33 {
            class S {}
            class X {}
            class Y {
                attribute color int
            }

            generalization R1 S X Y

            domainop void makePair {} {
                %<X create x1>%
                %<S create s1>%
                %<~R1 relate s1 x1>%
                %<R1 reclassify s1 Y y1 color 20>%
            }
        }
        population codegen33 {
            class S {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Reclassify} codegen33.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc RelUnionGenReclassify {relName superref newClassName subref} {
    return [string cat [IndentToBlock\
        [linecomment "$relName reclassify $superref $newClassName $subref"]]\
        [ReclassifyUnionGen $relName $superref $newClassName $subref]\
    ]
}
----

[source,tcl]
----
<<generation support commands>>=
proc RelUnionGenReclassify {relName superref subclass subref args} {
    set result [linecomment "$relName reclassify $superref $subclass $subref"]

    variable domain
    set relRef [UnionGeneralization findById Domain $domain Name $relName]
    set relNum [readAttribute [findRelated $relRef R43 R30] Number]

    set supername [readAttribute [findRelated $relRef ~R44] Class]
    CheckSuperClassReference $supername $superref
    CheckSubClassName $subclass [findRelated $relRef ~R45]

    set classDesc &${domain}__CLASSES\[[GetClassProperty $subclass Number]\]
    append result\
        [CreateInstRefSymbol $subclass $subref]\
        "$subref = mrt_Reclassify\(&${domain}__RSHIPS\[$relNum\], $superref, "\
        "$classDesc\) ;\n"

    set attrvalues [GetAttrInitialValues $subclass $args]
    foreach {attrName attrValue} $attrvalues {
        append result "$subref->$attrName = $attrValue ;\n"
    }

    return [IndentToBlock $result]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-34.0 {
    Reclassify union generalization
} -setup {
    # makeFile {} codegen34.h
    # makeFile {} codegen34.c
    micca configure {
        domain codegen34 {
            class S {}
            class X {}
            class Y {
                attribute color int
            }

            generalization R1 -union S X Y

            domainop void makePair {} {
                %<S create s1>%
                %<R1 reclassify s1 Y y1 color 30>%
            }
        }
        population codegen34 {
            class S {
                allocate 4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_Reclassify} codegen34.c]] == 1}
} -result {1}
----

=== Assigner Commands

[source,tcl]
----
<<generation support commands>>=
proc SingleAssignerSignal {relName event args} {
    set reftype "struct $relName *"
    set instref [CreateTempSymbol Ctype $reftype Type Reference Class $relName]

    append result\
        [linecomment "$relName signal $event [list $args]"]\
        "$reftype$instref = &${relName}__POOL\[0\] ;\n"

    return [string cat\
        [IndentToBlock $result]\
        [InstanceSignal $instref $event {*}$args]\
    ]
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-35.0 {
    Signal a single assigner
} -setup {
    # makeFile {} codegen35.h
    # makeFile {} codegen35.c
    micca configure {
        domain codegen35 {
            class clerk {}
            class client {}
            association R1 clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }

            domainop void clerkready {} {
                %<R1 signal clerkReady>%
            }
        }
        population codegen35 {
            # HERE -- if R1 is missing, gens an error -- shouldn't
            class clerk {
                instance clerk1
            }
            class client {
                instance client1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {mrt_PostEvent} codegen35.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generation support commands>>=
proc MultiAssignerCreate {relName instref idinst} {
# HERE
# class structure is in ${relName}__CLASS
# create/verify instref as a reference to the correct class structure
# verify idinst class matches the id class for the assigner
# invoke mrt_CreateInstance
# assign idinst to the "idinstance" attribute
}
----

== Helper Commands

[source,tcl]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }
    namespace import ::micca::@Config@::Helpers::typeCheck

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,tcl]
----
<<generation helper commands>>=
proc banner {} {
    set marker [string repeat - 70]
    string cat\
        "/*\n"\
        " * $marker\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * $marker\n"\
        " */\n"
}
----

[source,tcl]
----
<<generation helper commands>>=
proc comment {args} {
    set result "/*\n"
    foreach c $args {
        append result [::textutil::adjust::indent\
            [::textutil::adjust::adjust $c] { * }]\n
    }
    append result " */\n"

    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc linecomment {args} {
    set result {}
    foreach line $args {
        append result "// $line\n"
    }
    return $result
}
----

[source,tcl]
----
<<generation helper commands>>=
proc blockcomment {block} {
    return [textutil::adjust::indent [textutil::adjust::undent\
            [string trim $block \n]] {// }]\n
}
----

[source,tcl]
----
<<generation helper commands>>=
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

[source,tcl]
----
<<generation helper commands>>=
proc GenInstanceAddress {domainName className instName} {
    set path {}
    set usubRef [UnionSubclass findWhere {$Domain eq $domainName &&\
        $Class eq $className}]
    if {[isNotEmptyRef $usubRef]} {
        # puts [relformat [deRef $usubRef] usubRef]
        while {[isNotEmptyRef $usubRef]} {
            assignAttribute $usubRef {Relationship rship} {Class subName}
            set path .$rship.${subName}$path

            set usuperRef [findRelated $usubRef R45 ~R44]
            set superClass [readAttribute $usuperRef Class]

            set usubRef [pipe {
                deRef $usuperRef |
                relation semijoin ~ $::micca::UnionSubclass\
                    -using {Domain Domain Class Class} |
                ::rosea::Helpers::ToRef ::micca::UnionSubclass ~
            }]
            # puts [relformat [deRef $usubRef] usubRef]
        }

        # puts "path = \"$path\""
        set storageClass $superClass
    } else {
        set storageClass $className
    }
    set instNumber [readAttribute\
            [ClassInstance findById Domain $domainName Class $className\
                Instance $instName]\
        Number]
    return &${storageClass}__POOL\[$instNumber\]$path
}
----
