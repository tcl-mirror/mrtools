// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain implementation.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time translates model level actions into ``C'' level
execution.
The run time can be compiled separately and is data driven.
The details of how a domain behaves is completely determined by the
data values supplied to the run time and the state activities and
domain operations supplied as ``C'' code.

Code generation consist of two major pieces:

* Generating initialized ``C'' variables of the type required by the run time.
* Generating ``C'' code for state activities and domain operations to
facilitate interfacing to the run time code.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,c]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,c]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation activity namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
Generally,
one is required to declare symbols before they are defined.
The ordering has to be quite precise.
One way to accomplish this is to use a template.
The template is orgainized in the order required by the compiler
and contains embedded commands.
When expanded,
the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from `tcllib`.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,c]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

Because we are using a template expansion technique to generate the code
files,
the implementation of code generation has the flavor of a report generator.
Commands imbedded in the template make queries on the populated
platform model and emit a _report_ of the query, which in this case
is a set of ``C'' language statements.
Although the reports generated are intended to be consumed by a compiler
rather than a human,
the design of the generator is very similar to generating reports
from a database.
In this case the database is the platform model and the reports are ``C'' code.

[source,c]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: generate header files>>
    <<miccaGenerate: generate code files>>

    rename expand {} ; # <1>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return
}
----
<1> The template expander creates a new command and we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation errors}
----

We set up options for the generation in a dictionary.
The default values are given and can be overridden by those passed in.

[source,c]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror     fail\
    stubexternalops false\
]
set options [dict merge $options $arglist]
----

The `textutil::expander` package creates a command that does all the
expansion work.

[source,c]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand setbrackets %< >% ; # <1>
expand errmode [dict get $options expanderror]
----
<1> The default way to embed commands in the template is with
the conventional Tcl brackets ([ ]).
Those characters are inconvenient in ``C'' so we use bracket strings
that create less interference.

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,c]
----
<<miccaGenerate: verify domains are populated>>=
set badpops [pipe {
    Population findAll |
    findUnrelated ~ R100
}]

forAllRefs badpop $badpops {
    set domainName [readAttribute $badpop Name]
    log::error "for domain, \"$domainName\", no population is given"
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

== Header Files

The header file generated for a domain contains interfacing information.
The header file is included in the generated ``C'' code file and,
typically, is included by bridge code that is
mapping the dependencies of one domain onto another.

Following our usual pattern,
we will execute the header generation commands from the template in
a child namespace to avoid any name conflicts.

[source,c]
----
<<miccaGenerate: generate header files>>=
expand evalcmd "namespace eval [namespace current]::GenHeader"
----

The `GenHeader` namespace is a child of `::micca::@Gen@` and follows
our usual pattern of imports, command path and contents.

[source,c]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

The template for the header file is shown below.
Each embedded command is then shown in the following sections.

[source,c]
----
<<generation data>>=
set headerTemplate [string cat\
    %<banner>%\
    "#ifndef %<headerFileGuard>%\n"\
    "#define %<headerFileGuard>%\n"\
    %<interface>%\
    "#include <stddef.h>\n"\
    "#include <stdint.h>\n"\
    "#include <stdbool.h>\n"\
    %<typeAliases>%\
    %<domainOpDeclarations>%\
    %<externalOpDeclarations>%\
    %<eventParamDeclarations>%\
    %<portalIds>%\
    "#endif /* %<headerFileGuard>% */"\
]
----

The generation of the header files is accomplished by iterating
over all the domains and placing the output of the template
expansion into a file.
We use some variables to provide context to the embedded expansion commands.

[source,c]
----
<<miccaGenerate: generate header files>>=
variable headerTemplate

forAllRefs domainRef [Domain findAll] {
    namespace upvar GenHeader\
        domain domain\
        interface interface
    namespace upvar GenActivity\
        domain thisdomain

    assignAttribute $domainRef\
        {Name domain}\
        {Interface interface}
    set thisdomain $domain

    set hchan [::open $domain.h w]
    try {
        puts $hchan [expand expand $headerTemplate]
    } on error {result opts} {
        # puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $hchan
    }

    unset domain interface
}
----

The commands embedded in the template all follow a similar pattern.
The return values of the commands are placed in the output of the
template expansion.

=== Header File Guard

The generated header file includes definitions of preprocessor symbols
to prevent the header file from being included multiple times.

[source,c]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return [string toupper [string trim $domain]]_H_
}
----

=== Domain Interface

The contents of the domain interface values is placed first in the
generated header.

[source,c]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    set result {}
    if {$interface ne {}} {
        append result\
            [comment "Domain Interface Contents"]\
            [indentCode [string trim $interface \n] 0]
    }

    return $result
}
----

[float]
==== Tests

[source,c]
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    makeFile {} header1.h
    makeFile {} header1.c
    micca configure {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {stdio} header1.h]
} -result {1}
----

=== Type Aliases

The domain configuration can contain type aliases.
Normally,
the type alias information is placed in the generated code file.
However, if a type alias name is used in a context where it would be
exposed outside of the domain,
_e.g._ as a parameter to a domain operation,
then the type alias definition is placed in the generated header file.
There are three circumstances where a type is needed external to the domain:

. As the return type or parameter type of a domain operation.
. As the return type or parameter type of an external operation.
. As an argument to an event (as events can be tunneled into the domain).

[source,c]
----
<<generation header commands>>=
proc typeAliases {} {
    variable domain

    set domRef [Domain findWhere {$Name eq $domain}]
    set aliases [pipe {
        findRelated $domRef ~R7 |
        deRef % |
        relation list % TypeName
    } {} |%]
    # Domain operations
    set doRefs [pipe {
        findRelatedWhere $domRef ~R5 {$ReturnDataType in $aliases} |
        findRelated % R5 ~R7
    } {} |%]
    set dopRefs [pipe {
        findRelatedWhere $domRef {~R5 ~R6} {$DataType in $aliases} |
        findRelated % R6 R5 ~R7
    } {} |%]
    # External operations
    set eoRefs [pipe {
        findRelatedWhere $domRef ~R10 {$ReturnDataType in $aliases} |
        findRelated % R10 ~R7
    } {} |%]
    set eopRefs [pipe {
        findRelatedWhere $domRef {~R10 ~R11} {$DataType in $aliases} |
        findRelated % R11 R10 ~R7
    } {} |%]
    # Event arguments
    set argRefs [pipe {
        Argument findWhere {$Domain eq $domain && $DataType in $aliases} |
        deRef ~ |
        relation semijoin ~ $::micca::TypeAlias\
                -using {Domain Domain DataType TypeName} |
        ::rosea::Helpers::ToRef ::micca::TypeAlias ~
    }]

    # Union all the different refs together.
    set taRefs [refUnion $doRefs $dopRefs]
    set taRefs [refUnion $taRefs $eoRefs]
    set taRefs [refUnion $taRefs $eopRefs]
    set taRefs [refUnion $taRefs $argRefs]
    set result {}
    if {[isNotEmptyRef $taRefs]} {
        append result [comment "Type Aliases"]
        forAllRefs taRef $taRefs {
            assignAttribute $taRef TypeName TypeDefinition
            append result\
                "typedef "\
                [typeCheck composeDeclaration $TypeDefinition $TypeName]\
                " \;\n"
        }
    }

    return $result
}
----

[float]
==== Tests

[source,c]
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    makeFile {} header2.h
    makeFile {} header2.c
    micca configure {
        domain header2 {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {typedef} header2.h]
} -result {2}
----

=== Domain Operation Declarations

``C'' language programs tend to be composed of _declarations_ and
_definitions_.
A declaration makes symbol names and types known to the compile.
A definition associates allocates specific data or code statements
to a symbol.
Header files contain a lot of declarations.
Here we start with declarations for the domain operations.
Domain operations are just ordinary ``C'' functions but are given
external scope.

[source,c]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    set result {}
    if {[isNotEmptyRef $opRefs]} {
        append result\
            [comment "Domain Operations External Declarations"]\
            [GenOperationDeclarations $opRefs ~R6]
    }
    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc GenOperationDeclarations {opRefs paramRel} {
    set result {}

    set params [deRef [findRelated $opRefs $paramRel]]
    set ops [pipe {
        deRef $opRefs |
        relation rename ~ Name Operation |
        relation join ~ $params |
        relation group ~ Parameters Name Number DataType
    }]

    relation foreach op $ops {
        relation assign $op
        if {$Comment ne {}} {
            append result [comment $Comment]
        }
        append result\
            "extern $ReturnDataType "\
            $Domain _ $Operation \(\
            [join [relation list $Parameters DataType] {, }]\
            "\) ;\n"
    }

    return $result
}
----

[float]
==== Tests

[source,c]
----
<<generate command tests>>=
test headergen-3.0 {
    Generated header file domain operations
} -setup {
    makeFile {} header3.h
    makeFile {} header3.c
    micca configure {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {extern int header3_op[0-9]} header3.h]
} -result {2}
----

=== External Operation Declarations

The declarations for external operations follows the same pattern as
for domain operations.

[source,c]
----
<<generation header commands>>=
proc externalOpDeclarations {} {
    variable domain
    set opRefs [ExternalOperation findWhere {$Domain eq $domain}]

    set result {}
    if {[isNotEmptyRef $opRefs]} {
        append result\
            [comment "External Operations Declarations"]\
            [GenOperationDeclarations $opRefs ~R11]
    }
    return $result
}
----

=== Portal Function Constants

The runtime code provides a set of functions that allow bridge code
to tunnel simple model level operations, such a signaling an event,
into a domain.
The functions require integer constants that encode identifiers
for the various entities that can be accessed via the portal.
Those constants are placed in the generated header file.

We generate information on three aspects of the domain:
classes, transitioning events and polymorphic events.

[source,c]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain
    set result {}

    <<portalIds:: generate class information>>
    <<portalIds:: generate event information>>
    <<portalIds:: generate polymorphic event information>>

    return $result
}
----

For classes,
we generate encodings for the class itself,
its attributes and its initial instances.

[source,c]
----
<<portalIds:: generate class information>>=
append result [comment "Numeric encoding of classes, attributes and\
        instances used by the portal functions"]
set classRefs [Class findWhere {$Domain eq $domain}]
append result "#define [string toupper ${domain}_CLASSCOUNT]\
        [refMultiplicity $classRefs]\n"
forAllRefs classRef $classRefs {
    assignAttribute $classRef
    <<portalIds:: generate class encodings>>
    <<portalIds:: generate attribute encodings>>
    <<portalIds:: generate instance encodings>>
}
----

Each class was given a unique number within the domain when
the platform model was populated.
This is the basis for the class id encodings.

[source,c]
----
<<portalIds:: generate class encodings>>=
append result [comment "Class: $Name"]
set classid [string toupper ${Domain}_${Name}_CLASSID]
append result "#define $classid $Number\n"
----

Attributes are encoded in alphabetical order.
Note that the portal does not allow access to relationships.

[source,c]
----
<<portalIds:: generate attribute encodings>>=
set attrRefs [findRelated $classRef ~R20 {~R25 PopulatedComponent}\
        {~R21 Attribute}]
append result "#define [string toupper ${Domain}_${Name}_ATTRCOUNT]\
        [refMultiplicity $attrRefs]\n"
set attrNumber -1
relation foreach attr [deRef $attrRefs] -ascending Name {
    relation assign $attr {Name attrName}
    set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
    append result "#define $attrid [incr attrNumber]\n"
}
----

We generate encodings for instances that are part of the initial
instance population.

[source,c]
----
<<portalIds:: generate instance encodings>>=
set instRefs [findRelated $classRef ~R20 ~R103]
append result "#define [string toupper ${Domain}_${Name}_INSTCOUNT]\
        [refMultiplicity $instRefs]\n"
forAllRefs inst $instRefs {
    assignAttribute $inst Instance {Number InstNumber}
    set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
    append result "#define $instid $InstNumber\n"
}
----

[source,c]
----
<<portalIds:: generate event information>>=
append result [comment "Numeric encoding of event numbers\
        used by the portal functions"]
set tevents [pipe {
    TransitioningEvent findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Domain |
    relation group ~ Events Event Number
}]
relation foreach tevent $tevents -ascending Model {
    relation assign $tevent
    append result [comment "Class: $Model"]
    append result "#define [string toupper ${domain}_${Model}_EVENTCOUNT]\
        [relation cardinality $Events]\n"
    relation foreach event $Events -ascending Number {
        relation assign $event
        append result "#define\
            [string toupper ${domain}_${Model}_${Event}_EVENT] $Number\n"
    }
}
----

[source,c]
----
<<portalIds:: generate polymorphic event information>>=
append result [comment "Numeric encoding of polymorphic event numbers\
        used by the portal functions"]
set pevents [pipe {
    DeferredEvent findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Domain |
    relation group ~ Events Event Number
}]
relation foreach pevent $pevents -ascending Model {
    relation assign $pevent
    append result [comment "Class: $Model"]
    append result "#define [string toupper ${domain}_${Model}_POLYEVENTCOUNT]\
        [relation cardinality $Events]\n"
    relation foreach event $Events -ascending Number {
        relation assign $event
        append result "#define\
            [string toupper ${domain}_${Model}_${Event}_POLYEVENT] $Number\n"
    }
}
----

[source,c]
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    makeFile {} header4.h
    makeFile {} header4.c
    micca configure {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population header4 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {CLASSID} header4.h]
} -result {2}
----

== Generating Code Files

[source,c]
----
<<miccaGenerate: generate code files>>=
expand evalcmd "namespace eval [namespace current]::GenCode"
----

[source,c]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    namespace import [namespace parent]::expand
    namespace import [namespace parent]::GenActivity::ExpandActivity

    <<generation code data>>
    <<generation code commands>>
}
----

[source,c]
----
<<generation data>>=
set codeTemplate [string cat\
    %<banner>%\
    %<prologue>%\
    "#include \"micca_rt.h\"\n"\
    "#ifdef MRT_INSTRUMENT\n"\
    "    #ifndef MRT_INSTRUMENT_ENTRY\n"\
    "        #define MRT_INSTRUMENT_ENTRY\
            printf(\"%s: %s %d\\n\", __func__, __FILE__, __LINE__) ;\n"\
    "    #endif /* MRT_INSTRUMENT_ENTRY */\n"\
    "#else\n"\
    "    #define MRT_INSTRUMENT_ENTRY\n"\
    "#endif /* MRT_INSTRUMENT */\n"\
    %<domainInclude>%\
    %<forwardClassDeclarations>%\
    %<forwardRelationshipDeclaration>%\
    %<classDeclarations>%\
    %<assignerDeclarations>%\
    %<stateParamDeclarations>%\
    %<operationDeclarations>%\
    %<ctorDeclarations>%\
    %<dtorDeclarations>%\
    %<activityDeclarations>%\
    %<storageDeclarations>%\
    %<nameDefinitions>%\
    %<iabDefinitions>%\
    %<edbDefinitions>%\
    %<pdbDefinitions>%\
    %<classDefinitions>%\
    %<assignerDefinitions>%\
    %<relationshipDefinitions>%\
    %<classInstanceDefinitions>%\
    %<assignerInstanceDefinitions>%\
    %<operationDefinitions>%\
    %<ctorDefinitions>%\
    %<dtorDefinitions>%\
    %<activityDefinitions>%\
    %<domainCtorDefinition>%\
    %<domainOpDefinitions>%\
    %<externalOpDefinitions>%\
    %<epilogue>%\
]
----

[source,c]
----
<<miccaGenerate: generate code files>>=
variable codeTemplate

forAllRefs domainRef [Domain findAll] {
    namespace upvar GenCode\
        domain domain\
        prologue prologue\
        epilogue epilogue

    assignAttribute $domainRef\
        {Name domain}\
        {Prologue prologue}\
        {Epilogue epilogue}

    PrepareDomainProperties $domain

    set cchan [::open $domain.c w]
    try {
        puts $cchan [expand expand $codeTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $cchan
    }
}
----

[source,c]
----
<<generation helper commands>>=
proc PrepareDomainProperties {domain} {
    variable ClassProperties

    # Need to handle missing class populations.
    # Not all classes will have a ClassPopulation instance.
    set classRefs [Class findWhere {$Domain eq $domain}]
    set allocs [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} |
        deRef % |
        relation project % Class Allocation |
        relation rename % Class Name
    } {} |%]

    set insts [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation project % Class Number |
        relation rename % Class Name
    } {} |%]

    set sassigners [pipe {
        SingleAssigner findWhere {$Domain eq $domain} |
        deRef ~ |
        relation project ~ Association |
        relation rename ~ Association Name |
        relation tag ~ Number -ascending Name |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            StorageVariable string {"[tuple extract $stup Name]__POOL"}\
            Allocation int {0}\
            InitialInstance int {1}\
            TotalInstance int {1}
    }]
    set massigners [pipe {
        MultipleAssigner findWhere {$Domain eq $domain} |
        deRef ~ |
        relation tag ~ AssignerNumber -ascending Association |
        ralutil::rvajoin ~ $::micca::MultipleAssignerInstance Instances |
        ralutil::rvajoin ~ $::micca::ClassInstance Allocations |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Association]"}\
            Reference string {"struct [tuple extract $stup Association] *"}\
            StorageVariable string {"[tuple extract $stup Association]__POOL"}\
            Allocation int\
                {[relation cardinality [tuple extract $stup Allocations]]}\
            InitialInstance int\
                {[relation cardinality [tuple extract $stup Instances]]}\
            TotalInstance int\
                {[relation cardinality [tuple extract $stup Allocations]] +\
                [relation cardinality [tuple extract $stup Instances]]} |
            relation eliminate ~ Domain Class Allocations Instances |
            relation rename ~ Association Name AssignerNumber Number
    }]
    # puts [relformat $massigners massigners]

    set ClassProperties [pipe {
        deRef $classRefs |
        relation project ~ Name Number |
        relation rename ~ Number ClassNumber |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            StorageVariable string {"[tuple extract $stup Name]__POOL"} |
        ralutil::rvajoin ~ $allocs Allocations |
        relation extend ~ atup Allocation int {
            [relation isempty [tuple extract $atup Allocations]] ?\
            0 : [relation extract [tuple extract $atup Allocations] Allocation]
        } |
        relation eliminate ~ Allocations |
        ralutil::rvajoin ~ $insts Instances |
        relation extend ~ itup\
            InitialInstance int {
                [relation cardinality [tuple extract $itup Instances]]} \
            TotalInstance int {
                [relation cardinality [tuple extract $itup Instances]] +
                [tuple extract $itup Allocation]} |
        relation eliminate ~ Instances |
        relation rename ~ ClassNumber Number |
        relation union ~ $sassigners $massigners
    }]
    # puts [relformat $ClassProperties ClassProperties]

    variable AssocProperties

    set AssocProperties [pipe {
        Association findWhere {$Domain eq $domain} |
        deRef ~ |
        relation eliminate ~ Domain
    }]

    return
}

proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}

proc GetAssociationProperty {assoc prop} {
    variable AssocProperties
    set aprop [relation restrictwith $AssocProperties {$Name eq $assoc}]
    if {[relation isnotempty $aprop]} {
        return [relation extract $aprop $prop]
    }

    error "unknown property, \"$prop\", for association, \"$assoc\""
}
----

[source,c]
----
<<generation code commands>>=
proc prologue {} {
    variable prologue

    set result {}
    if {$prologue ne {}} {
        append result\
            [comment "Domain Prologue Begin"]\
            [indentCode [string trim $prologue \n] 0]\
            [comment "Domain Prologue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,c]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    makeFile {} codegen1.h
    makeFile {} codegen1.c
    micca configure {
        domain codegen1 {
            prologue {#include mySpecial.h}
            prologue {#include theSpecial.h}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population codegen1 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {Special} codegen1.c]
} -result {2}
----

[source,c]
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc forwardRelationshipDeclaration {} {
    variable domain
    return "static MRT_Relationship const\
            ${domain}__RSHIPS\[\] ; // forward reference\n"
}
----

[source,c]
----
<<generation code commands>>=
proc classDeclarations {} {
    variable domain

    set result [comment "Class structure declarations"]

    set ultimates [pipe {
        FindUltimateSuperclasses $domain |
        findRelated % {~R48 UnionSuperclass}
    } {} |%]
    append result [DeclareUnionSubclassStructures $ultimates]

    set remaining [FindNonUnionSubclasses $domain]
    forAllRefs classRef $remaining {
        append result [DeclareClassStructure $classRef]
    }

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc FindNonUnionSubclasses {domain} {
    set usubs [UnionSubclass findWhere {$Domain eq $domain}]
    return [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation semiminus [deRef $usubs] ~ -using {Domain Domain Class Name} |
        ::rosea::Helpers::ToRef ::micca::Class ~
    }]
}
----

[source,c]
----
<<generation code commands>>=
proc DeclareUnionSubclassStructures {superRefs} {
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs R44 ~R45]
    forAllRefs subRef $subRefs {
        set newsupers [pipe {
            deRef $subRef |
            relation semijoin ~ $::micca::UnionSuperclass\
                -using {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
        }]

        append result [DeclareUnionSubclassStructures $newsupers]

        append result [DeclareClassStructure [findRelated $subRef R47 R40 R41]]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc DeclareClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__INST ;\n"

    set compRefs [findRelated $classRef ~R20]

    # Attributes first
    forAllRefs attrRef [findRelated $compRefs {~R25 PopulatedComponent}\
            {~R21 Attribute}] {
        assignAttribute $attrRef {Name attrName} DataType
        append result "    $DataType $attrName ;\n"
    }

    # References second
    set refRefs [findRelated $compRefs {~R25 PopulatedComponent}\
            {~R21 Reference}]

    # Superclass References
    forAllRefs superRef [findRelated $refRefs {~R23 SuperclassReference}\
            ~R91 {~R47 ReferringSubclass} R37 ~R36] {
        assignAttribute $superRef {Relationship attrName} {Class className}
        append result "    [GetClassProperty $className Reference]$attrName ;\n"
    }

    # Associator Reference
    forAllRefs atorRef [findRelated $refRefs {~R23 AssociatorReference}\
            ~R93 R42] {
        assignAttribute $atorRef {Name attrName}

        set sourceDecl [pipe {
            findRelated $atorRef ~R34 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        set targetDecl [pipe {
            findRelated $atorRef ~R35 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]

        append result\
            "    struct \{\n"\
            "        ${targetDecl}forward ;\n"\
            "        ${sourceDecl}backward ;\n"\
            "    \} $attrName ;\n"
    }

    # Association Reference
    forAllRefs assocRef [findRelated $refRefs {~R23 AssociationReference}\
            ~R90 R32 ~R33] {
        assignAttribute $assocRef {Relationship attrName} {Class className}
        append result "    [GetClassProperty $className Reference]$attrName ;\n"
    }

    set genRefs [findRelated $compRefs {~R25 GeneratedComponent}]

    # Subclass References
    forAllRefs subRef [findRelated $genRefs {~R24 SubclassReference}] {
        assignAttribute $subRef {Name attrName}
        append result "    MRT_Instance *$attrName ;\n"
    }

    # Subclass container
    # Union supertypes will contain a superclass container.
    forAllRefs contRef [findRelated $genRefs {~R24 SubclassContainer}] {
        assignAttribute $contRef {Name attrName}

        set subRefs [findRelated $contRef ~R96 R44 ~R45]
        append result "    union \{\n"
        foreach subName [relation list [deRef $subRefs] Class] {
            append result "        "\
                "[GetClassProperty $subName Declaration] $subName ;\n"
        }
        append result "    \} $attrName ;\n"
    }

    # Link Containers
    forAllRefs linkRef [findRelated $genRefs {~R24 LinkContainer}] {
        append result "    MRT_LinkRef [readAttribute $linkRef Name] ;\n"
    }

    # Complementary References
    forAllRefs complRef [findRelated $genRefs {~R24 ComplementaryReference}] {
        set singRef [findRelated $complRef {~R26 SingularReference} R26]
        if {[isNotEmptyRef $singRef]} {
            append result [SingularReferenceMember $singRef]
            continue
        }

        set arrayRef [findRelated $complRef {~R26 ArrayReference} R26]
        if {[isNotEmptyRef $arrayRef]} {
            append result [ArrayReferenceMember $arrayRef]
            continue
        }

        set linkRef [findRelated $complRef {~R26 LinkReference} R26]
        if {[isNotEmptyRef $linkRef]} {
            append result [LinkReferenceMember $linkRef]
            continue
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc SingularReferenceMember {singRef} {
    set attrName [readAttribute $singRef Name]
    set refedClass [FindReferencedClass $singRef]
    return "    [GetClassProperty $refedClass Reference]$attrName ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc ArrayReferenceMember {arrayRef} {
    set attrName [readAttribute $arrayRef Name]
    set classref [GetClassProperty [FindReferencedClass $arrayRef] Reference]
    return [indentCode [string cat\
        "struct \{\n" [indentCode [string cat\
            "${classref}const *links ;\n"\
            "unsigned count ;\n"]]\
        "\} $attrName ;\n"]]
}
----

[source,c]
----
<<generation helper commands>>=
proc LinkReferenceMember {linkRef} {
    set attrName [readAttribute $linkRef Name]
    return "    MRT_LinkRef $attrName ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc FindReferencedClass {compRef} {
    set destRef [findRelated $compRef {~R28 BackwardReference} ~R94]

    # backward, simple
    set refing [findRelated $destRef {~R38 SimpleReferencedClass} R33 ~R32]
    if {[isNotEmptyRef $refing]} {
        set refedClass [readAttribute $refing Class]
    } else {
        # backward, target
        set src [findRelated $destRef {~R38 TargetClass} R35 ~R42]
        if {[isNotEmptyRef $src]} {
            set refedClass [readAttribute $src Class]
        } else {
            # forward, source
            set trg [findRelated $compRef {~R28 ForwardReference} ~R95 R34 ~R42]
            if {[isNotEmptyRef $trg]} {
                set refedClass [readAttribute $trg Class]
            }
        }
    }
    return $refedClass
}
----

[source,c]
----
<<generation code commands>>=
proc assignerDeclarations {} {
    variable domain
    set result {}

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $singles]} {
        append result [comment "Single Assigner Structure Declarations"]

        forAllRefs assigner $singles {
            assignAttribute $assigner
            append result\
                "struct $Association \{\n"\
                "    MRT_Instance base__INST ;\n"\
                "\} ;\n"
        }
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $multis]} {
        append result [comment "Multiple Assigner Structure Declarations"]

        forAllRefs assigner $multis {
            assignAttribute $assigner
            append result\
                "struct $Association \{\n"\
                "    MRT_Instance base__INST ;\n"\
                "    [GetClassProperty $Class Reference] idinstance ;\n"\
                "\} ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    # makeFile {} codegen2.h
    # makeFile {} codegen2.c
    micca configure {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population codegen2 {
            class super {
                instance fred1
                instance fred2
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {MRT_Instance} codegen2.c]] == 6}\
        {[llength [fileutil::grep {struct super \*R1} codegen2.c]] == 2}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associative class references
} -setup {
    # makeFile {} codegen3.h
    # makeFile {} codegen3.c
    micca configure {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -static -associator A X 0..*--0..* Y
        }
        population codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen3.c]] == 23}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-20.0 {
    Generated code file associative class references
} -setup {
    # makeFile {} codegen20.h
    # makeFile {} codegen20.c
    micca configure {
        domain codegen20 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..1--0..1 Y
        }
        population codegen20 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen20.c]] == 18}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-4.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen4.h
    # makeFile {} codegen4.c
    micca configure {
        domain codegen4 {
            class X {}
            association R1 X 0..1--0..1 X
        }
        population codegen4 {
            class X {
                instance x1 R1 x2
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen4.c]] == 11}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-5.0 {
    Generated code file reflexive associative class references
} -setup {
    # makeFile {} codegen5.h
    # makeFile {} codegen5.c
    micca configure {
        domain codegen5 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen5 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen5.c]] == 36}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-21.0 {
    Generated code file reflexive associative class references -- static
} -setup {
    # makeFile {} codegen21.h
    # makeFile {} codegen21.c
    micca configure {
        domain codegen21 {
            class A {}
            class X {}
            association R1 -static -associator A X 0..*--0..* X
        }
        population codegen21 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen21.c]] == 18}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-6.0 {
    Generated code file union generalization
} -setup {
    # makeFile {} codegen6.h
    # makeFile {} codegen6.c
    micca configure {
        domain codegen6 {
            class super {}
            class sub1 {
                attribute color int -default 10
            }
            class sub2 {
                attribute temp int -default 20
            }
            generalization R1 -union super sub1 sub2

            class sub3 {
                attribute degree int -default 30
            }
            class sub4 {
                attribute yaw int -default 40
            }

            generalization R2 -union sub1 sub3 sub4

            class sub5 {
                attribute degree int -default 30
            }
            class sub6 {
                attribute degree int -default 30
            }

            generalization R3 -union sub1 sub5 sub6

            class X {}
            association R4 X 1--1 sub5
        }
        population codegen6 {
            class super {
                instance fred1
                instance fred2
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
            class sub3 {
                instance s3 R2 s1
            }
            class sub5 {
                instance s5 R3 s1
            }
            class X {
                instance x1 R4 s5
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen6.c]] == 9}\
        {[llength [fileutil::grep {R2} codegen6.c]] == 7}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-7.0 {
    Generated code file associative class references -- non static
} -setup {
    # makeFile {} codegen7.h
    # makeFile {} codegen7.c
    micca configure {
        domain codegen7 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population codegen7 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x1 Y y2}
                instance a4 R1 {X x2 Y y1}
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen7.c]] == 47}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-8.0 {
    Generated code file reflexive associative class references -- non static
} -setup {
    # makeFile {} codegen8.h
    # makeFile {} codegen8.c
    micca configure {
        domain codegen8 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population codegen8 {
            class A {
                instance a12 R1 {forward x2 backward x1}
                instance a13 R1 {forward x3 backward x1}
                instance a23 R1 {forward x3 backward x2}
                instance a24 R1 {forward x4 backward x2}
                instance a34 R1 {forward x4 backward x3}
                instance a41 R1 {forward x1 backward x4}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen8.c]] == 71}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-9.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen9.h
    # makeFile {} codegen9.c
    micca configure {
        domain codegen9 {
            class X {}
            association R1 X 0..*--0..1 X
        }
        population codegen9 {
            class X {
                instance x1 R1 x2
                instance x2 R1 x3
                instance x3 R1 x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {LINKS} codegen9.c]] == 13}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-22.0 {
    Generate a single assigner
} -setup {
    # makeFile {} codegen22.h
    # makeFile {} codegen22.c
    micca configure {
        domain codegen22 {
            class clerk {}
            class client {}
            association R1 clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
        }
        population codegen22 {
            class clerk {
                allocate 2
            }
            class client {
                allocate 3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1__POOL} codegen22.c]] == 1}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-23.0 {
    Generate a multi assigner
} -setup {
    # makeFile {} codegen23.h
    # makeFile {} codegen23.c
    micca configure {
        domain codegen23 {
            class clerk {}
            class client {}
            association R1 clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {}
            association R2 department 1..*--1 clerk
        }
        population codegen23 {
            class department {
                instance mens R2 fred
                instance children R2 fred
                instance womens R2 alice
                instance sports R2 biff
            }
            class clerk {
                instance fred
                instance alice
                instance biff
            }
            class client {
                allocate 3
            }
            assigner R1 {
                instance mens mens
                instance children children
                instance womens womens
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1__POOL} codegen23.c]] == 5}
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc eventParamDeclarations {} {
    variable domain
    set result {}

    set tevents [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        findRelated ~ R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    if {[relation isnotempty $tevents]} {
        append result [comment "Transition Event Parameter Structure\
                Declarations"]
        relation foreach tevent $tevents -ascending Model {
            relation assign $tevent
            relation foreach event $Events {
                relation assign $event
                append result\
                    "struct ${domain}_${Model}_${Event}__EPARAMS \{\n"
                relation foreach param $Params -ascending Position {
                    relation assign $param DataType Name
                    append result\
                        "    [typeCheck composeDeclaration $DataType $Name] ;\n"
                }
                append result "\} ;\n"
            }
        }
    }

    set pevents [pipe {
        PolymorphicEvent findWhere {$Domain eq $domain} |
        findRelated ~ R81 R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    if {[relation isnotempty $pevents]} {
        append result [comment "Polymorphic Event Parameter Structure\
                Declarations"]
        relation foreach tevent $pevents -ascending Model {
            relation assign $tevent
            relation foreach event $Events {
                relation assign $event
                append result\
                    "struct ${domain}_${Model}_${Event}__PEPARAMS \{\n"
                relation foreach param $Params -ascending Position {
                    relation assign $param DataType Name
                    append result\
                        "    [typeCheck composeDeclaration $DataType $Name] ;\n"
                }
                append result "\} ;\n"
            }
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc stateParamDeclarations {} {
    variable domain
    set result {}

    set stateargs [pipe {
        State findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name State |
        relation join $::micca::ParameterSignature $::micca::Parameter\
                $::micca::Argument |
        relation project ~ Model State Name Position DataType |
        relation group ~ Params Name Position DataType
    }]

    if {[relation isnotempty $stateargs]} {
        append result [comment "State Parameter Structure Declarations"]
        relation foreach statearg $stateargs -ascending {Model State} {
            relation assign $statearg
            append result "struct ${Model}_${State}__SPARAMS \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-10.0 {
    Generated event parameter structures
} -setup {
    # makeFile {} codegen10.h
    # makeFile {} codegen10.c
    micca configure {
        domain codegen10 {
            typealias MyCount int
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            class super {
                polymorphic e1 f MyCount g {char *}
                polymorphic e2
            }
            class sub1 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            class sub2 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }

                    state s2 {} {
                        printf("in s2\n") ;
                    }

                    transition s1 -> e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - e1 -> s1
                }
            }
            generalization R1 super sub1 sub2
        }
        population codegen10 {
            class X {
                instance x1 color 30
            }
            class super {
                instance sup1
                instance sup2
            }
            class sub1 {
                instance s1 R1 sup1
            }
            class sub2 {
                instance s2 R1 sup2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {__EPARAMS} codegen10.h]] == 3}\
        {[llength [fileutil::grep {__PEPARAMS} codegen10.h]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc operationDeclarations {} {
    variable domain
    set result {}

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Operation Forward Declarations"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "static $ReturnDataType ${Class}_$Operation\("

            if {[relation isempty $Parameters]} {
                append result void
            } else {
                append result [join\
                    [relation list $Parameters DataType -ascending Number] {, }]
            }

            append result "\) ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-11.0 {
    Generated code file with class operations
} -setup {
    # makeFile {} codegen11.h
    # makeFile {} codegen11.c
    micca configure {
        domain codegen11 {
            class X {
                attribute color int -default 20

                classop int count {} {
                    return 42 ;
                }

                instop void addColor {amount int} {
                    self->color += amount ;
                }
            }
        }
        population codegen11 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X_count} codegen11.c]] == 2}\
        {[llength [fileutil::grep {X_addColor} codegen11.c]] == 2}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc ctorDeclarations {} {
    variable domain
    set result {}

    set ctors [Constructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $ctors]} {
        append result [comment "Class Constructor Forward Declarations"]
        forAllRefs ctor $ctors {
            assignAttribute $ctor {Class className}
            append result\
                "static void ${className}__CTOR\(void *const) ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc dtorDeclarations {} {
    variable domain
    set result {}

    set dtors [Destructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $dtors]} {
        append result [comment "Class Destructor Forward Declarations"]
        forAllRefs dtor $dtors {
            assignAttribute $dtor {Class className}
            append result\
                "static void ${className}__DTOR\(void *const) ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc activityDeclarations {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && $Activity ne {}} |
        deRef ~ |
        relation eliminate ~ Domain Activity IsTerminal PSigID |
        relation group ~ States Name
    }]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Forward Declarations"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            relation foreach state $States {
                relation assign $state
                append result "static void ${Model}_${Name}__ACTIVITY\("\
                    "void *const s__SELF, "\
                    "void const *const p__PARAMS) ;\n"
            }
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc storageDeclarations {} {
    variable domain
    set result {}

    set cpops [pipe {
        FindNonUnionSubclasses $domain |
        findRelated % R104 {~R101 ElementPopulation} {~R105 ClassPopulation}
    } {} |%]

    if {[isNotEmptyRef $cpops]} {
        append result [comment "Class Instance Storage Forward Declarations"]
        forAllRefs cpop $cpops {
            assignAttribute $cpop {Allocation allocation} {Class className}
            set insts [refMultiplicity [findRelated $cpop ~R102]]
            set total [expr {$allocation + $insts}]
            append result "static struct $className "\
                [GetClassProperty $className StorageVariable]\
                "\[[GetClassProperty $className TotalInstance]\] ;\n"
        }
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        set total [refMultiplicity [findRelated $multi R54 ~R20 ~R103]]
        assignAttribute $multi Association
        append result "static struct ${Association}\
            ${Association}__POOL\[$total\] ;\n"
    }

    return $result
}
----

Put out all the naming information.

[source,c]
----
<<generation code commands>>=
proc nameDefinitions {} {
    variable domain
    append result\
        [comment "Domain Naming Definitions"]\
        "#ifndef MRT_NO_NAMES\n"

    set storageType "static char const"

    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        set className [readAttribute $classRef Name]
        append result "$storageType ${className}__NAME\[\] = \"$className\" ;\n"
    }

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    forAllRefs relRef $relRefs {
        set relName [readAttribute $relRef Name]
        append result "$storageType ${relName}__NAME\[\] = \"$relName\" ;\n"
    }

    set stateRefs [State findWhere {$Domain eq $domain}]
    forAllRefs stateRef $stateRefs {
        assignAttribute $stateRef {Model modelName} {Name stateName}
        append result "$storageType ${modelName}_${stateName}__SNAME\[\] =\
                \"$stateName\" ;\n"
    }

    set eventRefs [Event findWhere {$Domain eq $domain}]
    forAllRefs eventRef $eventRefs {
        assignAttribute $eventRef {Model modelName} {Event eventName}
        append result "$storageType ${modelName}_${eventName}__ENAME\[\] =\
                \"$eventName\" ;\n"
    }

    append result "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc iabDefinitions {} {
    variable domain
    set result [comment "Instance Allocation Block Definitions"]

    forAllRefs classRef [FindNonUnionSubclasses $domain] {
        append result [DefineIABMembers $classRef false]
    }

    set unionRefs [pipe {
        UnionSubclass findWhere {$Domain eq $domain} |
        findRelated ~ R47 R40 R41
    }]
    forAllRefs classRef $unionRefs {
        append result [DefineIABMembers $classRef true]
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    forAllRefs multi $multis {
        set total [refMultiplicity [findRelated $multi R54 ~R20 ~R103]]
        set initial [refMultiplicity [findRelated $multi ~R106]]

        assignAttribute $multi
        append result\
            "static MRT_iab ${Association}__IAB = \{\n"\
            "    .storageStart = &${Association}__POOL\[0\],\n"\
            "    .storageFinish = &${Association}__POOL\[$total\],\n"\
            "    .storageLast = &${Association}__POOL\[[expr {$total - 1}]\],\n"\
            "    .alloc = [expr {$initial + 1}],\n"\
            "    .instanceSize = sizeof\(struct ${Association}\),\n"\
            "    .construct = NULL,\n"\
            "    .destruct = NULL,\n"\
            "    .linkCount = 0,\n"\
            "    .linkOffsets = NULL\n"\
            "\} ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc DefineIABMembers {classRef isUnionSubclass} {
    assignAttribute $classRef {Name className}

    set linkRefs [findRelated $classRef ~R20 {~R25 GeneratedComponent}\
        {~R24 ComplementaryReference} {~R26 LinkReference}]
    if {[isEmptyRef $linkRefs]} {
        set linkOffsets NULL
    } else {
        set linkOffsets ${className}__LINKS
        append result\
            "static MRT_AttrOffset const $linkOffsets\[\] = \{\n"
        set linkMembers [relation list [deRef $linkRefs] Name]
        foreach linkMember $linkMembers {
            append result\
                "    "\
                "offsetof\([GetClassProperty $className Declaration],\
                $linkMember\),\n"
        }
        append result "\} ;\n"
    }

    append result\
        "static MRT_iab ${className}__IAB = \{\n"

    if {$isUnionSubclass} {
        append result\
            "    .storageStart = NULL,\n"\
            "    .storageFinish = NULL,\n"\
            "    .storageLast = NULL,\n"
    } else {
        set nelements [GetClassProperty $className TotalInstance]
        append result\
            "    .storageStart = &${className}__POOL\[0\],\n"\
            "    .storageFinish = &${className}__POOL\[$nelements\],\n"\
            "    .storageLast = &${className}__POOL\[[expr {$nelements - 1}]\],\n"
    }
    set ctor [pipe {
        findRelated $classRef ~R8 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__CTOR"}
    } {} |%]
    set dtor [pipe {
        findRelated $classRef ~R9 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__DTOR"}
    } {} |%]
    append result\
        "    .alloc = [expr {[GetClassProperty $className InitialInstance]\
                    + 1}],\n"\
        "    .instanceSize = sizeof\([GetClassProperty $className Declaration]\),\n"\
        "    .construct = $ctor,\n"\
        "    .destruct = $dtor,\n"\
        "    .linkCount = [refMultiplicity $linkRefs],\n"\
        "    .linkOffsets = $linkOffsets\n"\
        "\} ;\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc edbDefinitions {} {
    variable domain
    set result [comment "Event Dispatch Block Definitions"]

    upvar #0 ::micca::@Gen@::options options

    forAllRefs smodel [StateModel findWhere {$Domain eq $domain}] {
        assignAttribute $smodel {Model className}

        append result [GenerateTransitionTable $smodel]
        append result [GenerateActivityTable $smodel]
        set termstates [GenerateTerminalStates $smodel result]

        append result [GenerateModelNames $smodel]

        append result "static MRT_edb const ${className}__EDB = \{\n"

        set stateRefs [findRelated $smodel ~R55]
        set cstateRef [findRelated $smodel ~R56]
        append result\
            "    .stateCount = [expr {[refMultiplicity $stateRefs] +\
                [refMultiplicity $cstateRef]}],\n"

        set eventRefs [findRelated $smodel ~R87]
        append result\
            "    .eventCount = [refMultiplicity $eventRefs],\n"\
            "    .initialState = [readAttribute [findRelated $smodel R58 R57]\
                        Number],\n"
        set crstate [expr {[isNotEmptyRef $cstateRef] ?\
            [readAttribute [findRelated R57] Number] : "MRT_StateCode_IG"}]
        append result\
            "    .creationState = $crstate,\n"\
            "    .transitionTable = ${className}__TTAB,\n"\
            "    .activityTable = ${className}__ATAB,\n"\
            "    .terminalStates = $termstates,\n"

        append result\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .stateNames = ${className}__SNAMES,\n"\
            "    .eventNames = ${className}__ENAMES,\n"\
            "        #endif /* MRT_NO_NAMES */\n"

        append result\
            "\} ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateTransitionTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        findRelated $smodel ~R55 |
        deRef % |
        relation rename % Name State |
        relation eliminate % Activity IsTerminal PSigID
    } {} |%]
    set cstate [pipe {
        findRelated $smodel ~R56 |
        deRef % |
        relation rename % Name State
    } {} |%]
    set states [relation union $states $cstate]
    # puts [relformat $states states]

    set events [pipe {
        findRelated $smodel ~R87 |
        deRef %
    } {} |%]
    # puts [relformat $events events]

    set alltrans [pipe {
        relation eliminate $events Number |
        relation join $states ~
    }]
    # puts [relformat $alltrans alltrans]

    set statetrans [pipe {
        StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation eliminate ~ ASigID
    }]
    # puts [relformat $statetrans statetrans]
    set nontrans [pipe {
        Non-StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ TransRule NewState
    }]
    # puts [relformat $nontrans nontrans]

    set deftrans [pipe {
        TransitionPlace findAll |
        deRef ~ |
        relation minus $alltrans ~ |
        relation join ~ [deRef [StateModel findAll]] |
        relation eliminate ~ InitialState |
        relation rename ~ DefaultTrans NewState |
        relation update ~ dttup {[tuple extract $dttup State] eq "@"} {
                tuple update $dttup NewState CH}
    }]
    # puts [relformat $deftrans deftrans]

    set ntstates [pipe {
        TransitionRule findAll |
        deRef ~ |
        relation rename ~ Name State |
        relation extend ~ nttup\
            Domain string {$domain}\
            Model string {$className}\
            StateNumber string {"MRT_StateCode_[tuple extract $nttup State]"}
    }]
    # puts [relformat $ntstates ntstates]

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ Name State Number StateNumber |
        relation union ~ $ntstates
    }]
    # puts [relformat $places places]
    set transitions [pipe {
        relation union $statetrans $nontrans $deftrans |
        relation join ~ $places\
            -using {Domain Domain Model Model NewState State} |
        relation rename ~ StateNumber NewStateNumber |
        relation join ~ $places $events |
        relation eliminate ~ Domain Model
    }]
    # puts [relformat $transitions transitions]

    set result "static MRT_StateCode const ${className}__TTAB\[\] = \{\n"
    relation foreach transition $transitions -ascending {StateNumber Number} {
        relation assign $transition
        append result "    $NewStateNumber, // $State - $Event -> $NewState\n"
    }
    append result "\} ;\n"

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-12.0 {
    Generated code file with state model
} -setup {
    # makeFile {} codegen12.h
    # makeFile {} codegen12.c
    micca configure {
        domain codegen12 {
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {} {
                        printf("In s1\n") ;
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                    }
                    transition s2 - e1 -> IG
                    transition s2 - e2 -> s3

                    state s3 {} {
                    }
                    transition s3 - e3 -> s1

                    terminal s3
                }
            }
        }
        population codegen12 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X__TTAB} codegen12.c]] == 2}\
        {[llength [fileutil::grep {X__ATAB} codegen12.c]] == 2}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc GenerateActivityTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set result "static MRT_PtrActivityFunction const ${className}__ATAB\[\] = \{\n"

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name Activity
            if {$Activity eq {}} {
                append result "    NULL, // $Name\n"
            } else {
                append result "    ${className}_${Name}__ACTIVITY, // $Name\n"
            }
        } else {
            set cstate [relation semijoin $place $::Micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    NULL, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateTerminalStates {smodel resultVar} {
    set tstates [findRelatedWhere $smodel ~R55 {$IsTerminal}]
    if {[isEmptyRef $tstates]} {
        return NULL
    }
    upvar 1 $resultVar result
    variable domain
    assignAttribute $smodel {Model className}
    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static bool const ${className}__TSTATES\[\] = \{\n"
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name IsTerminal
            append result "    "\
                [expr {$IsTerminal ? "true" : "false"}]\
                ", // $Name\n"
        } else {
            set cstate [relation semijoin $place $::Micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    false, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
    return ${className}__TSTATES
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateModelNames {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result\
        "#ifndef MRT_NO_NAMES\n"\
        "static char const * const ${className}__SNAMES\[\] = \{\n"

    relation foreach state $states -ascending Number {
        relation assign $state Name
        append result "    ${className}_${Name}__SNAME,\n"
    }
    append result "\} ;\n"

    set events [pipe {
        TransitioningEvent findWhere\
                {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static char const * const ${className}__ENAMES\[\] = \{\n"
    relation foreach event $events -ascending Number {
        relation assign $event Event
        append result "    ${className}_${Event}__ENAME,\n"
    }
    append result\
        "\} ;\n"\
        "#endif /* MRT_NO_NAMES */\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc pdbDefinitions {} {
    variable domain

    set enames {}
    set rnames {}
    set pmaps {}
    set gdbs {}
    set pdbs {}

    set superRefs [pipe {
        DeferredEvent findWhere {$Domain eq $domain} |
        findRelated % ~R86
    } {} |%]
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs\
            {~R48 ReferencedSuperclass} R36 ~R37 R47]
    if {[isNotEmptyRef $subRefs]} {
        set supertype mrtPolyReference
    } else {
        set subRefs [findRelated $superRefs\
                {~R48 UnionSuperclass} R44 ~R45 R47]
        set supertype mrtPolyUnion
    }

    set deferred [pipe {
        findRelated $superRefs {R86 DeferralPath} |
        deRef ~ |
        relation join ~ $::micca::DeferredEvent |
        relation eliminate ~ Domain Role |
        relation extend ~ gtup SuperType string {$supertype} |
        relation rename ~ Model Superclass Number SuperNumber
    }]
    # puts [relformat $deferred deferred]

    set nonlocals [pipe {
        findRelated $subRefs ~R85 |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Number RelNumber
    } {} |%]
    # puts [relformat $nonlocals nonlocals]

    set polys [pipe {
        relation join $nonlocals $::micca::DeferredEvent |
        relation extend ~ ptup Type string {"mrtPolymorphicEvent"}
    }]
    # puts [relformat $polys polys]

    set trans [pipe {
        relation join $nonlocals $::micca::TransitioningEvent |
        relation extend ~ ptup Type string {"mrtTransitionEvent"}
    }]
    # puts [relformat $trans trans]

    set supers [pipe {
        relation union $polys $trans |
        relation eliminate ~ Domain Role |
        relation join ~ $deferred |
        relation group ~ EventMap Event SuperNumber Number Type |
        relation group ~ SubMap Model EventMap |
        relation group ~ Generalizations Relationship RelNumber SuperType SubMap
    }]
    # puts [relformat $supers supers]

    relation foreach super $supers {
        relation assign $super

        set gdbvar ${Superclass}__GDBS
        append gdbs "static MRT_gdb $gdbvar\[\] = \{\n"

        set rnamesvar ${Superclass}__RNAMES
        append rnames "static char const *const $rnamesvar\[\] = \{\n"

        relation foreach gen $Generalizations -ascending Relationship {
            relation assign $gen

            append rnames "    ${Relationship}__NAME,\n"

            set pmapvar ${Superclass}_${Relationship}__PMAP
            append pmaps "static MRT_PolyEventMap const $pmapvar\[\] = \{\n"

            relation foreach submap $SubMap -ascending Model {
                relation assign $submap
                relation foreach eventmap $EventMap {
                    relation assign $eventmap
                    append pmaps\
                        "    "\
                        "\{.event = $Number, .eventType = $Type\},"\
                        "// $Event for $Model\n"
                }
            }
            append pmaps "\} ;\n"

            append gdbs\
                "    \{\n"\
                "        .relship = &${domain}__RSHIPS\[$RelNumber\],\n"\
                "        .eventMap = $pmapvar,\n"\
                "    \},\n"
        }
        append rnames "\} ;\n"
        append gdbs "\} ;\n"

        set enamesvar ${Superclass}__PENAMES
        append enames "static char const *const $enamesvar\[\] = \{\n"
        relation foreach eventmap $EventMap {
            relation assign $eventmap Event
            append enames "    ${Superclass}_${Event}__ENAME,\n"
        }
        append enames "\} ;\n"

        append pdbs\
            "static MRT_pdb const ${Superclass}__PDB = \{\n"\
            "    .eventCount = [relation cardinality $SubMap],\n"\
            "    .genCount = [relation cardinality $Generalizations],\n"\
            "    .genDispatch = $gdbvar,\n"\
            "        #ifndef MRT_NO_NAMES\n"\
            "    .eventNames = $enamesvar,\n"\
            "    .genNames = $rnamesvar,\n"\
            "        #endif /* MRT_NO_NAMES */\n"\
            "\} ;\n"
    }


    append result\
        [comment "Polymorphic Event Dispatch Block Definitions"]\
        "#ifndef MRT_NO_NAMES\n"\
        $enames $rnames\
        "#endif /* MRT_NO_NAMES */\n"\
        $pmaps $gdbs $pdbs

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-13.0 {
    polymorphic events -- inject polymorphic event mid-level
} -setup {
    # makeFile {} codegen13.h
    # makeFile {} codegen13.c
    micca configure {
        domain codegen13 {
            class S {
                polymorphic e1
                polymorphic e2
                polymorphic a1
            }
            class X {
                polymorphic a3
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    transition s1 - a1 ->  s1
                }
            }
            class Y {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - a1 -> s1
                }
            }
            generalization R1 -union S X Y

            class F {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - f1 -> s1
                    transition s2 - a1 -> s2
                }
            }
            class G {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    transition s2 - g1 -> s1
                    transition s2 - a1 -> s2
                }
            }

            generalization R3 -union S F G

            class A {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            class B {
                attribute color int -default 20
                statemodel {
                    state s1 {} {
                        puts("in s1") ;
                    }
                    state s2 {} {
                        puts("in s2") ;
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - a3 -> s2
                    transition s1 - a10 -> s2
                }
            }
            generalization R2 -union X A B
        }
        population codegen13 {
            class S {
                instance s1
                instance s2
                instance s3
            }
            class X {
                instance x1 R1 s1
                instance x2 R1 s3
            }
            class Y {
                instance y1 R1 s2
            }
            class A {
                instance a1 R2 x1
            }
            class B {
                instance b1 R2 x2
            }
            class F {
                instance f1 R3 s1
                instance f2 R3 s2
            }
            class G {
                instance g1 R3 s3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {}
----

[source,c]
----
<<generate command tests>>=
test codegen-14.0 {
    Generated code file simple references -- non static
} -setup {
    # makeFile {} codegen14.h
    # makeFile {} codegen14.c
    micca configure {
        domain codegen14 {
            class X {}
            class Y {}
            association R1 X 1..*--1 Y
        }
        population codegen14 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen14.c]] == 21}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-15.0 {
    Generated code file simple references -- static
} -setup {
    # makeFile {} codegen15.h
    # makeFile {} codegen15.c
    micca configure {
        domain codegen15 {
            class X {}
            class Y {}
            association R1 -static X 1..*--1 Y
        }
        population codegen15 {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
                instance x3 R1 y1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen15.c]] == 9}
} -result {1}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-16.0 {
    many to 1 associative relationship
} -setup {
    # makeFile {} codegen16.h
    # makeFile {} codegen16.c
    micca configure {
        domain codegen16 {
            class A {
            }
            class X {
            }
            class Y {
            }

            association R1 -associator A X 1..*--0..1 Y
        }

        population codegen16 {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
                instance a3 R1 {X x3 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
} -result {}
----

[source,c]
----
<<generation code commands>>=
proc classDefinitions {} {
    variable domain
    set front [comment "Class Description Definitions"]

    set classRefs [Class findWhere {$Domain eq $domain}]

    set rels [pipe {
        findRelated $classRefs {~R41 ClassRole} |
        deRef % |
        relation eliminate % Role |
        relation join % $::micca::Association -using\
            {Domain Domain Relationship Name} |
        relation restrictwith % {!$IsStatic} |
        relation eliminate % IsStatic |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number RelNumber
    } {} |%]
    # puts [relformat $rels rels]

    set attrs [pipe {
        findRelated $classRefs ~R20 {~R25 PopulatedComponent} {~R21 Attribute} |
        deRef % |
        relation rename % Name Attribute Class Name
    } {} |%]
    # puts [relformat $attrs attrs]

    set usubs [pipe {
        findRelated $classRefs {~R41 ClassRole} {~R40 Subclass}\
            {~R47 UnionSubclass} |
        deRef % |
        relation join % $::micca::Relationship\
            -using {Domain Domain Relationship Name} |
        relation rename % Class Name Number SuperNumber |
        relation eliminate % Role Relationship
    } {} |%]
    # puts [relformat $usubs usubs]

    set classes [pipe {
        deRef $classRefs |
        relation extend ~ ctup IAB string {"&[tuple extract $ctup Name]__IAB"} |
        ralutil::rvajoin ~\
            [relation rename $::micca::StateModel Model Name] SModel |
        relation extend ~ etup EDB string {
            [relation cardinality [tuple extract $etup SModel]] == 0 ?\
            "NULL" : "&[tuple extract $etup Name]__EDB"} |
        ralutil::rvajoin ~\
            [relation rename $::micca::DeferredEvent Model Name] PEvents |
        relation extend ~ ptup PDB string {
            [relation cardinality [tuple extract $ptup PEvents]] == 0 ?\
            "NULL" : "&[tuple extract $ptup Name]__PDB"} |
        relation eliminate ~ SModel PEvents |
        ralutil::rvajoin ~ $rels Relationships |
        relation extend ~ rtup\
            relCount int {
                [relation cardinality [tuple extract $rtup Relationships]]}\
            classRels string {
                [relation cardinality [tuple extract $rtup Relationships]] == 0 ?\
                "NULL" : "[tuple extract $rtup Name]__CRELS"} |
        ralutil::rvajoin ~ $attrs Attributes |
        relation extend ~ atup\
            attrCount int {
                [relation cardinality [tuple extract $atup Attributes]]}\
            classAttrs string {
                [relation cardinality [tuple extract $atup Attributes]] == 0 ?\
                "NULL" : "[tuple extract $atup Name]__CATTRS"} |
        ralutil::rvajoin ~ $usubs UnionSubs |
        relation extend ~ utup\
            containment string {
                [relation cardinality [tuple extract $utup UnionSubs]] == 0 ?\
                "NULL" :\
                "&${domain}__RSHIPS\[[relation extract\
                    [tuple extract $utup UnionSubs]\
                    SuperNumber]\].relInfo.unionGeneralization.superclass"} |
        relation eliminate ~ Domain

    }]
    # puts [relformat $classes classes]

    append result "static MRT_Class const\
            ${domain}__CLASSES\[[relation cardinality $classes]\] = \{\n"

    set relrefs {}
    set attrrefs {}
    relation foreach class $classes {
        relation assign $class

        if {[relation isnotempty $Relationships]} {
            append relrefs\
                "static MRT_Relationship const *const\
                    ${Name}__CRELS\[\] = \{\n"

            relation foreach rel $Relationships {
                relation assign $rel
                append relrefs\
                    "    &${domain}__RSHIPS\[$RelNumber\], // $Relationship\n"
            }

            append relrefs "\} ;\n"
        }

        if {[relation isnotempty $Attributes]} {
            append attrrefs\
                "static MRT_Attribute const ${Name}__CATTRS\[\] = \{\n"

            relation foreach attr $Attributes -ascending Attribute {
                relation assign $attr
                set offset "offsetof([GetClassProperty $Name Declaration],\
                        $Attribute)"
                append attrrefs\
                    "    \{\n"\
                    "        .offset = $offset,\n"\
                    "        .size = sizeof($DataType),\n"\
                    "            #ifndef MRT_NO_NAMES\n"\
                    "        .name = \"$Attribute\"\n"\
                    "            #endif /* MRT_NO_NAMES */\n"\
                    "    \},\n"
            }

            append attrrefs "\} ;\n"
        }

        append result\
            "    \[$Number\] = \{\n"\
            "        .iab = $IAB,\n"\
            "        .edb = $EDB,\n"\
            "        .pdb = $PDB,\n"\
            "        .relCount = $relCount,\n"\
            "        .classRels = $classRels,\n"\
            "        .attrCount = $attrCount,\n"\
            "        .classAttrs = $classAttrs,\n"\
            "        .instCount = [GetClassProperty $Name TotalInstance],\n"\
            "        .containment = $containment,\n"\
            "            #ifndef MRT_NO_NAMES\n"\
            "        .name = ${Name}__NAME\n"\
            "            #endif /* MRT_NO_NAMES */\n"\
            "    \},\n"
    }

    append result "\} ;\n"

    return [string cat $front $relrefs $attrrefs $result]
}
----

[source,c]
----
<<generation code commands>>=
proc assignerDefinitions {} {
    variable domain
    set result {}

    set assignerRefs [SingleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $assignerRefs]} {
        append result [comment "Single Assigner Description Definitions"]
        forAllRefs assigner $assignerRefs {
            assignAttribute $assigner
            append result\
                "static MRT_Class const ${Association}__CLASS = \{\n"\
                "    .iab = NULL,\n"\
                "    .edb = &${Association}__EDB,\n"\
                "    .pdb = NULL,\n"\
                "    .relCount = 0,\n"\
                "    .classRels = NULL,\n"\
                "    .attrCount = 0,\n"\
                "    .classAttrs = NULL,\n"\
                "    .instCount = 1,\n"\
                "    .containment = NULL,\n"\
                "        #ifndef MRT_NO_NAMES\n"\
                "    .name = ${Association}__NAME,\n"\
                "        #endif /* MRT_NO_NAMES */\n"\
                "\} ;\n"
        }
    }

    set assignerRefs [MultipleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $assignerRefs]} {
        append result [comment "Multiple Assigner Description Definitions"]
        forAllRefs assigner $assignerRefs {
            assignAttribute $assigner
            set instRefs [findRelated $assigner ~R106]
            append result\
                "static MRT_Class const ${Association}__CLASS = \{\n"\
                "    .iab = &${Association}__IAB,\n"\
                "    .edb = &${Association}__EDB,\n"\
                "    .pdb = NULL,\n"\
                "    .relCount = 0,\n"\
                "    .classRels = NULL,\n"\
                "    .attrCount = 0,\n"\
                "    .classAttrs = NULL,\n"\
                "    .instCount = [refMultiplicity $instRefs],\n"\
                "    .containment = NULL,\n"\
                "        #ifndef MRT_NO_NAMES\n"\
                "    .name = ${Association}__NAME,\n"\
                "        #endif /* MRT_NO_NAMES */\n"\
                "\} ;\n"
        }
    }

    return $result
}
----

----
<<generation code commands>>=
proc relationshipDefinitions {} {
    variable domain
    set subroles {}

    set relRefs [Relationship findWhere {$Domain eq $domain}]
    if {[isEmptyRef $relRefs]} {
        return
    }
    append result "static MRT_Relationship const\
        ${domain}__RSHIPS\[[refMultiplicity $relRefs]\] = \{\n"

    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    forAllRefs relRef $relRefs {
        assignAttribute $relRef {Name relName} Number
        append result "$indent\[$Number\] = \{ // $relName\n"

        # Simple Association
        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 SimpleAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set sourceRef [findRelated $typeRef ~R32]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R40 R41] Number]

            set targetRef [findRelated $typeRef ~R33]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set tMult false
            set stype mrtSingular
            set slink 0

            set tcomp [findRelated $targetRef R38 R94 R28]
            lassign [FindRelOffsets $tcomp] ttype tlink

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    $relName)"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    [readAttribute $tcomp Name])"

            append result\
                "$indent2.relType = mrtSimpleAssoc,\n"\
                "$indent2.relInfo.simpleAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\}\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Association} {~R31 ClassBasedAssociation}]
        if {[isNotEmptyRef $typeRef]} {
            set sourceRef [findRelated $typeRef ~R34]
            assignAttribute $sourceRef {Class sClass} {Conditionality sCond}\
                {Multiplicity sMult}
            set sNum [readAttribute [findRelated $sourceRef R40 R41] Number]

            set targetRef [findRelated $typeRef ~R35]
            assignAttribute $targetRef {Class tClass} {Conditionality tCond}\
                {Multiplicity tMult}
            set tNum [readAttribute [findRelated $targetRef R38 R40 R41] Number]

            set asstorRef [findRelated $typeRef ~R42]
            assignAttribute $asstorRef {Class aClass}
            set aNum [readAttribute [findRelated $asstorRef R40 R41] Number]

            set scomp [findRelated $sourceRef R95 R28]
            lassign [FindRelOffsets $scomp] stype slink

            set tcomp [findRelated $targetRef R38 R94 R28]
            lassign [FindRelOffsets $tcomp] ttype tlink

            set sstore "offsetof([GetClassProperty $sClass Declaration],\
                    [readAttribute $scomp Name])"
            set tstore "offsetof([GetClassProperty $tClass Declaration],\
                    [readAttribute $tcomp Name])"

            append result\
                "$indent2.relType = mrtClassAssoc,\n"\
                "$indent2.relInfo.classAssociation = \{\n"

            append result\
                "$indent3.source = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$sNum\], // $sClass\n"\
                "$indent4.cardinality = [MapToCardinality $tCond $tMult],\n"\
                "$indent4.storageType = $stype,\n"\
                "$indent4.storageOffset = $sstore,\n"\
                "$indent4.linkOffset = $slink,\n"\
                "$indent3\},\n"

            append result\
                "$indent3.target = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$tNum\], // $tClass\n"\
                "$indent4.cardinality = [MapToCardinality $sCond $sMult],\n"\
                "$indent4.storageType = $ttype,\n"\
                "$indent4.storageOffset = $tstore,\n"\
                "$indent4.linkOffset = $tlink\n"\
                "$indent3\},\n"

            set aClassDecl [GetClassProperty $aClass Declaration]
            set aClassForw "offsetof($aClassDecl, ${relName}.forward)"
            set aClassBack "offsetof($aClassDecl, ${relName}.backward)"
            append result\
                "$indent3.associator = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$aNum\], // $aClass\n"\
                "$indent4.forwardOffset = $aClassForw,\n"\
                "$indent4.backwardOffset = $aClassBack,\n"\
                "$indent3\}\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 ReferenceGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R36]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R48 R40 R41] Number]

            set subRefs [findRelated $typeRef ~R37]
            set subClasses [findRelated $subRefs R47 R40 R41]

            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"}\
                    storageOffset string {
                        "offsetof([GetClassProperty\
                            [tuple extract $stup Class] Declaration],\
                            $relName)"} |
                relation project ~ Class classDesc storageOffset
            }]

            append subroles "static struct mrtrefsubclassrole const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs -ascending Class {
                relation assign $sub
                append subroles\
                    "    \{\n"\
                    "        .classDesc = $classDesc,\n"\
                    "        .storageOffset = $storageOffset\n"\
                    "    \},\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtRefGeneralization,\n"\
                "$indent2.relInfo.refGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }

        set typeRef [findRelated $relRef\
                {~R30 Generalization} {~R43 UnionGeneralization}]
        if {[isNotEmptyRef $typeRef]} {
            set superRef [findRelated $typeRef ~R44]
            assignAttribute $superRef {Class superClass}
            set supNum [readAttribute [findRelated $superRef R48 R40 R41] Number]
            set subRefs [findRelated $typeRef ~R45]
            set subClasses [findRelated $subRefs R47 R40 R41]
            set subs [pipe {
                deRef $subRefs |
                relation join ~ [deRef $subClasses]\
                    -using {Domain Domain Class Name} |
                relation extend ~ stup\
                    classDesc string {
                        "&${domain}__CLASSES\[[tuple extract $stup Number]\],\
                        // [tuple extract $stup Class]"} |
                relation project ~ Class classDesc
            }]

            append subroles "static MRT_Class const * const\
                    ${relName}__SROLES\[[refMultiplicity $subRefs]\] = \{\n"
            relation foreach sub $subs -ascending Class {
                relation assign $sub
                append subroles "    $classDesc\n"
            }
            append subroles "\} ;\n"

            append result\
                "$indent2.relType = mrtUnionGeneralization,\n"\
                "$indent2.relInfo.unionGeneralization = \{\n"

            append result\
                "$indent3.superclass = \{\n"\
                "$indent4.classDesc = &${domain}__CLASSES\[$supNum\], // $superClass\n"\
                "$indent4.storageOffset =\
                    offsetof([GetClassProperty $superClass Declaration],\
                    $relName)\n"\
                "$indent3\},\n"

            append result\
                "$indent3.subclassCount = [refMultiplicity $subRefs],\n"\
                "$indent3.subclasses = ${relName}__SROLES\n"

            append result\
                "$indent2\}\n"\
                "$indent\},\n"
            continue
        }
    }

    append result "\} ;\n"

    return [string cat\
        [comment "Relationship Description Definitions"]\
        $subroles\
        $result\
    ]
}
----

[source,c]
----
<<generation helper commands>>=
proc FindRelOffsets {complRef} {
    set typeRef [findRelated $complRef {~R26 SingularReference}]
    set offset 0
    if {[isNotEmptyRef $typeRef]} {
        set type mrtSingular
    } else {
        set typeRef [findRelated $complRef {~R26 ArrayReference}]
        if {[isNotEmptyRef $typeRef]} {
            set type mrtArray
        } else {
            set typeRef [findRelated $complRef {~R26 LinkReference}]
            set type mrtLinkedList
            assignAttribute [findRelated $typeRef ~R27]\
                {Class lClass} {Name lcomp}
            set offset "offsetof([GetClassProperty $lClass Declaration], $lcomp)"
        }
    }
    return [list $type $offset]
}
----

[source,c]
----
<<generation code commands>>=
proc MapToCardinality {cond mult} {
    if {$cond && !$mult} {
        return mrtAtMostOne
    } elseif {!$cond && !$mult} {
        return mrtExactlyOne
    } elseif {$cond && $mult} {
        return mrtZeroOrMore
    } elseif {!$cond && $mult} {
        return mrtOneOrMore
    }
}
----

[source,c]
----
<<generation code commands>>=
proc classInstanceDefinitions {} {
    variable domain
    variable staticMultiRefs {}

    set classRefs [FindNonUnionSubclasses $domain]
    set classpops [FindClassPopulation $classRefs]

    set result [comment "Instance Pool Definitions"]
    relation foreach classpop $classpops -ascending ClassNumber {
        relation assign $classpop

        append result\
            "static struct $Class "\
            [GetClassProperty $Class StorageVariable]\
            "\[[GetClassProperty $Class TotalInstance]\] = \{\n"

        relation foreach inst $Instances -ascending InstNumber {
            append result [GenInstanceInitializers $Class $ClassNumber $inst]
        }

        append result "\} ;\n"
    }

    if {$staticMultiRefs ne {}} {
        set staticMultiRefs [string cat\
            [comment "Static Reference Definitions"] $staticMultiRefs]
    }
    return [string cat $staticMultiRefs $result]
}
----

[source,c]
----
<<generation code commands>>=
proc FindClassPopulation {classRefs} {
    set classes [pipe {
        deRef $classRefs |
        relation rename ~ Name Class Number ClassNumber
    }]

    set compRefs [findRelated $classRefs ~R20]

    # Populated Components
    set popCompRefs [findRelated $compRefs {~R25 PopulatedComponent}]

    # Attribute Components
    set attrs [pipe {
        findRelated $popCompRefs {~R21 Attribute} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $attrs attrs]

    # Reference Components
    # For the populated reference components we will go ahead and
    # compute the class to which the reference is made.
    set refCompRefs [findRelated $popCompRefs {~R21 Reference}]

    # Superclass Reference Component
    set screfs [findRelated $refCompRefs {~R23 SuperclassReference}]
    set refedsuper [pipe {
        findRelated $screfs ~R91 {~R47 ReferringSubclass} R37 ~R36 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class SuperClass Relationship Component
    } {} |%]
    set superrefs [pipe {
        deRef $screfs |
        relation rename ~ Name Component |
        relation join ~ $refedsuper
    }]
    # puts [relformat $superrefs superrefs]

    # Associator Reference Components
    set arrefs [findRelated $refCompRefs {~R23 AssociatorReference}]
    set cbainfo [pipe {
        findRelated $arrefs ~R93 |
        deRef % |
        relation eliminate % Role |
        relation rename % Class AssociatorClass |
        relation join % $::micca::SourceClass |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class SourceClass |
        relation join % $::micca::TargetClass |
        relation eliminate % Role Conditionality Multiplicity |
        relation rename % Class TargetClass AssociatorClass Class\
                Relationship Component
    } {} |%]
    set atorrefs [pipe {
        deRef $arrefs |
        relation rename ~ Name Component |
        relation join ~ $cbainfo
    }]
    # puts [relformat $atorrefs atorrefs]

    # Association Reference Components
    set asrrefs [findRelated $refCompRefs {~R23 AssociationReference}]
    set srcinfo [pipe {
        findRelated $asrrefs ~R90 R32 ~R33 |
        deRef % |
        relation eliminate % Role Conditionality |
        relation rename % Class ReferencedClass Relationship Component
    } {} |%]
    set assocrefs [pipe {
        deRef $asrrefs |
        relation rename ~ Name Component |
        relation join ~ $srcinfo
    }]
    # puts [relformat $assocrefs assocrefs]

    # Generated components
    set genCompRefs [findRelated $compRefs {~R25 GeneratedComponent}]

    # Subclass Reference Components
    set subrefs [pipe {
        findRelated $genCompRefs {~R24 SubclassReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $subrefs subrefs]

    # Subclass Container
    set subconts [pipe {
        findRelated $genCompRefs {~R24 SubclassContainer} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $subconts subconts]

    # Link Container
    set linkconts [pipe {
        findRelated $genCompRefs {~R24 LinkContainer} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $linkconts linkconts]

    # Complementary Reference
    set complRefs [findRelated $genCompRefs {~R24 ComplementaryReference}]

    # Singular Reference
    set singRefs [pipe {
        findRelated $complRefs {~R26 SingularReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $singRefs singRefs]

    # Array Reference
    set arrayRefs [pipe {
        findRelated $complRefs {~R26 ArrayReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $arrayRefs arrayRefs]

    # Link Reference
    set linkRefs [pipe {
        findRelated $complRefs {~R26 LinkReference} |
        deRef % |
        relation rename % Name Component
    } {} |%]
    # puts [relformat $linkRefs linkRefs]

    set classpops [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation rename % Number InstNumber |
        relation join % $classes $::micca::ClassComponentValue |
        ralutil::rvajoin % $attrs Attributes |
        ralutil::rvajoin % $superrefs SuperRefs |
        ralutil::rvajoin % $atorrefs AssociatorRefs |
        ralutil::rvajoin % $assocrefs AssociationRefs |
        ralutil::rvajoin % $subrefs SubRefs |
        ralutil::rvajoin % $subconts SubclassContainers |
        ralutil::rvajoin % $linkconts LinkContainers |
        ralutil::rvajoin % $singRefs SingularRefs |
        ralutil::rvajoin % $arrayRefs ArrayRefs |
        ralutil::rvajoin % $linkRefs LinkRefs |
        relation group % Components Component Value Attributes SuperRefs\
            AssociatorRefs AssociationRefs SubRefs SubclassContainers\
            LinkContainers SingularRefs ArrayRefs LinkRefs |
        relation group % Instances Instance InstNumber Components |
        relation eliminate % Domain
    } {} |%]
    # puts [relformat $classpops classpops]

    return $classpops
}
----

[source,c]
----
<<generation code commands>>=
proc GenInstanceInitializers {className classNumber inst} {
    variable domain
    set indent [string repeat { } 4]
    set indent2 [string repeat $indent 2]
    set indent3 [string repeat $indent 3]
    set indent4 [string repeat $indent 4]

    relation assign $inst

    set sp [pipe {
        StateModel findById Domain $domain Model $className |
        findRelated ~ R58 R57
    }]
    set initstate [expr {[isNotEmptyRef $sp] ?\
        [readAttribute $sp Number] : "MRT_StateCode_IG"}]

    append result\
        "$indent\{\n"\
        "$indent2.base__INST = \{\n"\
        "$indent3.classDesc = &${domain}__CLASSES\[$classNumber\],\n"\
        "$indent3.alloc = [expr {$InstNumber + 1}],\n"\
        "$indent3.currentState = $initstate,\n"\
        "$indent3.refCount = 0,\n"\
        "${indent4}#ifndef MRT_NO_NAMES\n"\
        "$indent3.name = \"$Instance\"\n"\
        "${indent4}#endif /* MRT_NO_NAMES */\n"\
        " $indent2\},\n"

    relation foreach comp $Components {
        relation assign $comp
        if {[relation isnotempty $Attributes]} {
            append result "$indent2.$Component  = $Value,\n"
            continue
        }

        if {[relation isnotempty $SuperRefs]} {
            set superclass [relation extract $SuperRefs SuperClass]
            append result\
                "$indent2.$Component = "\
                [GenInstanceAddress $domain $superclass $Value],\n
            continue
        }

        if {[relation isnotempty $AssociatorRefs]} {
            relation assign $AssociatorRefs
            # the painful reflexive case again!
            if {$SourceClass eq $TargetClass} {
                # N.B. the inversion. the target instance is the
                # one referenced in the forward direction
                set sinstname [dict get $Value backward]
                set tinstname [dict get $Value forward]
            } else {
                set sinstname [dict get $Value $SourceClass]
                set tinstname [dict get $Value $TargetClass]
            }
            set sourceaddr [GenInstanceAddress $domain $SourceClass\
                $sinstname]
            set targetaddr [GenInstanceAddress $domain $TargetClass\
                $tinstname]

            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.forward = $targetaddr,\n"\
                "$indent3.backward = $sourceaddr\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $AssociationRefs]} {
            set refvalue [expr {$Value eq "@nil@" ?\
                "NULL" : [GenInstanceAddress $domain\
                    [relation extract $AssociationRefs ReferencedClass]\
                    $Value]}]
            append result "$indent2.$Component = $refvalue,\n"
            continue
        }

        if {[relation isnotempty $SubRefs]} {
            lassign $Value subclass subinstname
            set subinstaddr [GenInstanceAddress $domain $subclass $subinstname]
            append result "$indent2.$Component = (MRT_Instance *)$subinstaddr,\n"
            continue
        }

        if {[relation isnotempty $SubclassContainers]} {
            lassign $Value subclass subinst

            set subRef [Class findWhere {$Domain eq $domain &&\
                $Name eq $subclass}]
            set subpops [FindClassPopulation $subRef]
            # puts [relformat $subpops subpops]

            relation assign $subpops {Class subclassName}\
                {ClassNumber subclassNumber} {Instances subInstances}
            set instpop [relation restrictwith $subInstances\
                {$Instance eq $subinst}]

            append result\
                "$indent2.$Component.$subclass = "\
                [string trimleft [indentCode [GenInstanceInitializers\
                    $subclassName $subclassNumber $instpop] 8]]
            continue
        }

        if {[relation isnotempty $LinkContainers]} {
            lassign [dict get $Value next] nclass ninst ncomp
            set nextaddr [GenInstanceAddress $domain $nclass $ninst]
            lassign [dict get $Value prev] pclass pinst pcomp
            set prevaddr [GenInstanceAddress $domain $pclass $pinst]
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $nextaddr.$ncomp,\n"\
                "$indent3.prev = $prevaddr.$pcomp\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $SingularRefs]} {
            if {$Value eq "@nil@"} {
                set refaddr NULL
            } else {
                lassign $Value refclass refinst
                set refaddr [GenInstanceAddress $domain $refclass $refinst]
            }
            append result "$indent2.$Component = $refaddr,\n"
            continue
        }

        if {[relation isnotempty $ArrayRefs]} {
            if {$Value eq "@nil@"} {
                set refcount 0
                set refaddr NULL
            } else {
                lassign $Value refclass refinsts
                set refcount [llength $refinsts]
                set refaddr ${Component}_${className}_${InstNumber}

                # Build reference array
                variable staticMultiRefs
                append staticMultiRefs\
                    "static [GetClassProperty $refclass Reference]\
                        const $refaddr\[$refcount\] = \{\n"
                foreach inst $refinsts {
                    append staticMultiRefs\
                        "$indent[GenInstanceAddress $domain $refclass $inst],\n"
                }
                append staticMultiRefs "\} ;\n"
            }
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.links = $refaddr,\n"\
                "$indent3.count = $refcount\n"\
                "$indent2\},\n"
            continue
        }

        if {[relation isnotempty $LinkRefs]} {
            lassign [dict get $Value next] nclass ninst ncomp
            set nextaddr [GenInstanceAddress $domain $nclass $ninst]
            lassign [dict get $Value prev] pclass pinst pcomp
            set prevaddr [GenInstanceAddress $domain $pclass $pinst]
            append result\
                "$indent2.$Component = \{\n"\
                "$indent3.next = $nextaddr.$ncomp,\n"\
                "$indent3.prev = $prevaddr.$pcomp\n"\
                "$indent2\},\n"
            continue
        }
    }

    append result "$indent\},\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc assignerInstanceDefinitions {} {
    variable domain
    set result {}

    set singles [SingleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $singles]} {
        append result [comment "Single Assigner Structure Declarations"]

        forAllRefs assigner $singles {
            set initstate [pipe {
                findRelated $assigner R53 R50 R58 R57 |
                readAttribute ~ Number
            }]
            assignAttribute $assigner
            append result\
                "static struct $Association ${Association}__POOL\[1\] = \{\n"\
                "    \{\n"\
                "        .base__INST = \{\n"\
                "            .classDesc = &${Association}__CLASS,\n"\
                "            .alloc = 1,\n"\
                "            .currentState = $initstate,\n"\
                "            .refCount = 0,\n"\
                "                #ifndef MRT_NO_NAMES\n"\
                "            .name = ${Association}__NAME\n"\
                "                #endif /* MRT_NO_NAMES */\n"\
                "        \}\n"\
                "    \}\n"\
                "\} ;\n"
        }
    }

    set multis [MultipleAssigner findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $multis]} {
        append result [comment "Multiple Assigner Structure Declarations"]
        forAllRefs multi $multis {
            assignAttribute $multi {Association assoc}
            set initstate [pipe {
                findRelated $multi R53 R50 R58 R57 |
                readAttribute ~ Number
            }]
            set multiinsts [findRelated $multi ~R106]
            set totalinsts [refMultiplicity [findRelated $multi R54 ~R20 ~R103]]

            append result "static struct $assoc\
                    ${assoc}__POOL\[$totalinsts\] = \{\n"
            forAllRefs assigner $multiinsts {
                assignAttribute $assigner
                set allocnum 0
                append result\
                    "    \[$Number\] = \{\n"\
                    "        .base__INST = \{\n"\
                    "            .classDesc = &${Association}__CLASS,\n"\
                    "            .alloc = [incr allocnum],\n"\
                    "            .currentState = $initstate,\n"\
                    "            .refCount = 0,\n"\
                    "                #ifndef MRT_NO_NAMES\n"\
                    "            .name = \"$Instance\"\n"\
                    "                #endif /* MRT_NO_NAMES */\n"\
                    "        \},\n"\
                    "        .idinstance = [GenInstanceAddress $domain $IdClass\
                            $IdInstance]\n"\
                    "    \},\n"\
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc operationDefinitions {} {
    variable domain
    set result {}

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Operation Definitions"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "static $ReturnDataType\n${Class}_$Operation"

            if {[relation isempty $Parameters]} {
                append result "\(void\)\n"
            } else {
                relation foreach param $Parameters -ascending Number {
                    relation assign $param
                    append pdecls\
                        [typeCheck composeDeclaration $DataType $Name]\
                        ,\n
                }
                set pdecls [string trimright $pdecls ",\n"]\)\n
                append result\
                    "\(\n"\
                    [indentCode $pdecls]
            }

            # HERE --- need to template expand the code
            append result\
                "\{\n"\
                [indentCode $Body]\
                "\}\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc ctorDefinitions {} {
    return [TorDefinitions Constructor]
}
----

[source,c]
----
<<generation code commands>>=
proc dtorDefinitions {} {
    return [TorDefinitions Destructor]
}
----

[source,c]
----
<<generation code commands>>=
proc TorDefinitions {which} {
    variable domain
    set suffixmap [dict create\
        Constructor CTOR\
        Destructor DTOR\
    ]
    set result {}

    set tors [$which findWhere {$Domain eq $domain}]

    if {[isNotEmptyRef $tors]} {
        append result [comment "$which Definitions"]
        forAllRefs tor $tors {
            assignAttribute $tor
            # HERE --- need to template expand the code
            append result\
                "static void\n${Class}__[dict get $suffixmap $which]\(\n"\
                "    void *const s__SELF\)\n"\
                "\{\n"\
                [indentCode [string cat\
                    "[GetClassProperty $Class Reference]const self = s__SELF ;\n"\
                    $Body]]\
                "\}\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-17.0 {
    Generated code file with constructor and destructor
} -setup {
    # makeFile {} codegen17.h
    # makeFile {} codegen17.c
    micca configure {
        domain codegen17 {
            domainop void initialize {} {
                codegen17__INIT() ;
            }

            class X {
                attribute color int -default 20

                constructor {
                    self->color += 20 ;
                }
                destructor {
                    self->color -= 20 ;
                }
            }
        }
        population codegen17 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {CTOR} codegen17.c]] == 4}\
        {[llength [fileutil::grep {DTOR} codegen17.c]] == 3}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc activityDefinitions {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && $Activity ne {}} |
        deRef ~ |
        relation eliminate ~ Domain IsTerminal |
        relation group ~ States Name Activity PSigID
    }]
    # puts [relformat $classes classes]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Definitions"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            append result "#define MRT_CLASSNAME \"$Model\"\n"
            relation foreach state $States {
                relation assign $state
                append result\
                    "static void ${Model}_${Name}__ACTIVITY\(\n"\
                    "    void *const s__SELF,\n"\
                    "    void const *const p__PARAMS)\n"\
                    "\{\n"\
                    "        #define MRT_STATENAME \"$Name\"\n"\
                    "    MRT_INSTRUMENT_ENTRY\n"\
                    "    [GetClassProperty $Model Reference] const self = s__SELF ;\n"
                if {$PSigID ne {}} {
                    set signame ${Model}_${Name}__SPARAMS
                    append result\
                        "    struct $signame const *const pp__PARAMS = p__PARAMS ;\n"
                    set params [pipe {
                        ParameterSignature findById Domain $domain PSigID $PSigID |
                        FindParamsFromSig ~
                    }]
                    relation foreach param $params -ascending Position {
                        relation assign $param {Name pname} Declaration
                        append result "    $Declaration = pp__PARAMS->$pname ;\n"
                    }
                }
                append result [ExpandActivity $Model $Activity true]

                append result \n\
                    "        #undef MRT_STATENAME\n"\
                    "\}\n"
            }
            append result "#undef MRT_CLASSNAME\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc FindParamsFromSig {psigRef} {
    return [pipe {
        findRelated $psigRef ~R79 |
        deRef % |
        relation join % $::micca::Argument |
        relation extend % ptup Declaration string {\
            [typeCheck composeDeclaration\
                [tuple extract $ptup DataType]\
                [tuple extract $ptup Name]]}
    } {} |%]
}
----

[source,c]
----
<<generation code commands>>=
proc domainCtorDefinition {} {
    variable domain
    set result {}

    set ctorinsts [pipe {
        Constructor findWhere {$Domain eq $domain} |
        deRef ~ |
        relation eliminate ~ Body |
        relation join ~ $::micca::ClassInstance |
        relation group ~ Instances Instance Number
    }]

    if {[relation isnotempty $ctorinsts]} {
        append result [comment "Definition of Function to Construct\
            Initial Instances"]
        relation foreach ctorinst $ctorinsts {
            relation assign $ctorinst
            relation foreach instance $Instances -ascending Number {
                relation assign $instance
                append invocations\
                    "${Class}__CTOR\("\
                    [GenInstanceAddress $domain $Class $Instance]\
                    "\) ;\n"
            }
        }
        append result\
            "static void\n${domain}__INIT\(void\)\n"\
            "\{\n"\
            [indentCode $invocations]\
            "\}\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc domainOpDefinitions {} {
    variable domain
    set result {}

    set ops [pipe {
        DomainOperation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::DomainOperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Domain Operation Definitions"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "$ReturnDataType\n${domain}_$Operation"

            if {[relation isempty $Parameters]} {
                append result "\(void\)\n"
            } else {
                relation foreach param $Parameters -ascending Number {
                    relation assign $param
                    append pdecls\
                        [typeCheck composeDeclaration $DataType $Name]\
                        ,\n
                }
                set pdecls [string trimright $pdecls ",\n"]\)\n
                append result\
                    "\(\n"\
                    [indentCode $pdecls]
            }

            # HERE --- need to template expand the code
            append result\
                "\{\n"\
                [indentCode $Body]\
                "\}\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-18.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -setup {
    # makeFile {} codegen18.h
    # makeFile {} codegen18.c
    micca configure {
        domain codegen18 {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }

            class X {
                attribute color int -default 10
            }
        }
        population codegen18 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {codegen18_color} codegen18.c]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc externalOpDefinitions {} {
    upvar #0 [namespace parent]::options options
    if {![dict get $options stubexternalops]} {
        return
    }

    variable domain
    set result {}

    set ops [pipe {
        ExternalOperation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::ExternalOperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "External Operation Stub Definitions"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "$ReturnDataType\n${domain}_${Operation}__EOP"

            if {[relation isempty $Parameters]} {
                append result "\(void\)\n"
            } else {
                relation foreach param $Parameters -ascending Number {
                    relation assign $param
                    append pdecls\
                        [typeCheck composeDeclaration $DataType $Name]\
                        ,\n
                }
                set pdecls [string trimright $pdecls ",\n"]\)\n
                append result\
                    "\(\n"\
                    [indentCode $pdecls]
            }

            # HERE --- need to template expand the code
            append result\
                "\{\n"\
                [indentCode $Body]\
                "\}\n"
        }
    }

    return $result
}
----

[source,tcl]
----
<<generate command tests>>=
test codegen-19.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -setup {
    # makeFile {} codegen19.h
    # makeFile {} codegen19.c
    micca configure {
        domain codegen19 {
            externalop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }

            class X {
                attribute color int -default 10
            }
        }
        population codegen19 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate stubexternalops true
    testConditions\
        {[llength [fileutil::grep {codegen19_color__EOP} codegen19.c]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc epilogue {} {
    variable epilogue

    set result {}
    if {$epilogue ne {}} {
        append result\
            [comment "Domain Epilogue Begin"]\
            [indentCode [string trim $epilogue \n] 0]\
            [comment "Domain Epilogue End"]
    }

    return $result
}
----

== Helper Commands

[source,c]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }
    namespace import ::micca::@Config@::Helpers::typeCheck

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,c]
----
<<generation helper commands>>=
proc banner {} {
    string cat\
        "/*\n"\
        " * [string repeat - 70]\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * [string repeat - 70]\n"\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc comment {args} {
    set result "/*\n"

    foreach c $args {
        append result\
            [::textutil::adjust::indent [::textutil::adjust::adjust $c] " * "]\n
    }

    append result " */\n"

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

[source,c]
----
<<generation helper commands>>=
proc GenInstanceAddress {domainName className instName} {
    set path {}
    set usubRef [UnionSubclass findWhere {$Domain eq $domainName &&\
        $Class eq $className}]
    if {[isNotEmptyRef $usubRef]} {
        # puts [relformat [deRef $usubRef] usubRef]
        while {[isNotEmptyRef $usubRef]} {
            assignAttribute $usubRef {Relationship rship} {Class subName}
            set path .$rship.${subName}$path

            set usuperRef [findRelated $usubRef R45 ~R44]
            set superClass [readAttribute $usuperRef Class]

            set usubRef [pipe {
                deRef $usuperRef |
                relation semijoin ~ $::micca::UnionSubclass\
                    -using {Domain Domain Class Class} |
                ::rosea::Helpers::ToRef ::micca::UnionSubclass ~
            }]
            # puts [relformat [deRef $usubRef] usubRef]
        }

        # puts "path = \"$path\""
        set storageClass $superClass
    } else {
        set storageClass $className
    }
    set instNumber [readAttribute\
            [ClassInstance findById Domain $domainName Class $className\
                Instance $instName]\
        Number]
    return &${storageClass}__POOL\[$instNumber\]$path
}
----

== Interfacing Domain Code to the Run Time

Interfacing Domain Code to the Run Time

[source,c]
----
<<generation activity namespace>>=
namespace eval GenActivity {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar

    namespace export ExpandActivity

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }
    upvar #0 ::micca::@Gen@::errcount errcount

    textutil::expander actexpand
    actexpand setbrackets %< >%
    actexpand evalcmd "namespace eval [namespace current]"
    actexpand errmode fail
    actexpand textcmd ProcessCodeLines

    <<generation activity data>>
    <<generation activity commands>>
}
----

=== Symbol Table

[source,c]
----
<<generation activity data>>=
relvar create Symbol {
    Name string
    Ctype string
    Type string
    Class string
} Name
----

[source,c]
----
<<generation activity commands>>=
proc LookUpSymbol {name} {
    set sym [relvar restrictone Symbol Name $name]
    return [expr {[relation isempty $sym] ?\
        {} : [tuple get [relation tuple $sym]]}]
}

proc CheckSymbol {name} {
    set sym [LookUpSymbol $name]
    if {$sym eq {}} {
        log::error "unknown symbol, $name"
        variable errcount
        incr errcount
    }
    return $sym
}

proc InsertSymbol {args} {
    relvar insert Symbol $args
}

proc CreateTempSymbol {args} {
    variable symcounter
    set name t__T[incr symcounter]
    InsertSymbol Name $name {*}$args
    return $name
}

proc CreateTempRefSymbol {className} {
    set reftype [GetClassProperty $className Reference]
    set symName [CreateTempSymbol Ctype $reftype Type Reference Class $className]
    return [list $reftype $symName]
}

proc DeleteSymbol {name} {
    return [relvar deleteone Symbol Name $name]
}

proc ProcessCodeLines {text} {
    variable block

    # puts "text = \"$text\""
    set newlines [list]

    foreach line [split $text \n] {
        if {[string is space $line]} {
            if {[llength $newlines] != 0 && [lindex $newlines end] ne {}} {
                lappend newlines {}
            }
        } else {
            if {[string first "\}" $line] != -1} {
                incr block -1
            }
            if {[regsub -- {\A\s+} $line {} newline] != 0} {
                set line [string repeat { } [expr {$block * 4}]]$newline
            }
            if {[string first "\{" $line] != -1} {
                incr block 1
            }
            lappend newlines $line
        }
    }
    set newtext [join $newlines \n]
    # puts "newtext = \"$newtext\""

    return $newtext
}
----

[source,c]
----
<<generation activity commands>>=
proc ExpandActivity {class body hasSelf} {
    try {
        if {$hasSelf} {
            InsertSymbol Name self Ctype [GetClassProperty $class Reference]\
                Type Reference Class $class
        }
        variable block 0
        return [textutil::adjust::indent [actexpand expand $body] "    "]
    } on error {} {
        puts $::errorInfo
    } finally {
        relvar set Symbol [relation emptyof [relvar set Symbol]]
    }
}
----

[source,c]
----
<<generation activity commands>>=
proc instAttribute {instref attr} {
    variable domain

    set sym [CheckSymbol $instref]
    if {$sym eq {}} {
        return
    }
    set attrRef [Attribute findById Domain $domain Class [dict get $sym Class]\
            Name $attr]
    if {[isEmptyRef $attrRef]} {
        error "instance reference, $instref, refers to an instance of\
            class, [dict get $sym Class], which does not have an attribute\
            named, $attr"
    }
    return "$instref->$attr"
}
----

[source,c]
----
<<generation activity commands>>=
proc withInstAttribute {instref args} {
    variable domain

    lassign [ParseAttrVars $instref $args] attrNames varNames dataTypes

    set result "\{ /* %<[info level 0]>% */\n"
    PushBlock

    foreach attr $attrNames var $varNames type $dataTypes {
        set varDecl [typeCheck composeDeclaration $type $var]
        append setup "$varDecl = $instref->$attr ;\n"
    }
    append result [IndentToBlock $setup]

    PushContext withAttribute\
        instref $instref\
        attrNames $attrNames\
        varNames $varNames


    return $result
}
----

[source,c]
----
<<generation activity commands>>=
proc ParseAttrVars {instref attrvars} {
    variable domain

    set sym [CheckSymbol $instref]
    if {$sym eq {}} {
        return
    }
    set className [dict get $sym Class]

    if {[llength $attrvars] == 0} {
        # look up the attributes of the class
        set attrs [pipe {
            Attribute findWhere {$Domain eq $domain && $Class eq $className} |
            deRef ~ |
            relation project ~ Name DataType
        }]
        set attrNames [relation list $attrs Name -ascending Name]
        set varNames $attrNames
        set dataTypes [relation list $attrs DataType -ascending Name]
    } else {
        set attrNames [list]
        set varNames [list]
        foreach attrvar $attrvars {
            set l [llength $attrvar]
            if {$l < 1 || $l > 2} {
                error "bad format for attribute name /variable name pair,\
                        \"$attrvar\""
            }
            set attrName [lindex $attrvar 0]
            set attrRef [Attribute findById Domain $domain Class $className\
                Name $attrName]
            if {[isEmptyRef $attrRef]} {
                error "class, $className, does not have an attribute named,\
                    \"$attrName\""
            }
            lappend attrNames $attrName
            lappend dataTypes [readAttribute $attrRef DataType]
            if {$l == 1} {
                set varName $attrName
            } elseif {$l == 2} {
                set varName [lindex $attrvar 1]
                if {[::struct::set contains $varNames $varName]} {
                    error "duplicate variable name, \"$varName\""
                }
            }
            lappend varNames $varName
        }
    }
    return [list $attrNames $varNames $dataTypes]
}
----

[source,c]
----
<<generation activity commands>>=
proc assignInstAttribute {instref args} {
    variable domain

    lassign [ParseAttrVars $instref $args] attrNames varNames dataTypes

    set result "/* %<[info level 0]>% */\n"

    foreach attr $attrNames var $varNames type $dataTypes {
        set varDecl [typeCheck composeDeclaration $type $var]
        append result "$varDecl = $instref->$attr ;\n"
    }

    return [IndentToBlock $result]
}
----

[source,c]
----
<<generation activity commands>>=
proc PushContext {context args} {
    actexpand cpush $context
    foreach {var value} $args {
        actexpand cset $var $value
    }
}

proc PopContext {context args} {
    foreach varname $args {
        upvar 1 $varname cvar
        set cvar [actexpand cget $varname]
    }
    return [actexpand cpop $context]
}

proc IndentToBlock {code} {
    variable block
    # indent seems to swallow a trailing new line
    return [::textutil::adjust::indent $code\
        [string repeat { } [expr {$block * 4}]]]\n
}

proc PushBlock {{by 1}} {
    variable block
    incr block $by
}

proc PopBlock {{by -1}} {
    variable block
    incr block $by
}

proc GetBlock {} {
    variable block
    return $block
}
----

[source,c]
----
<<generation activity commands>>=
proc end {} {
    set result {}

    set context [actexpand cname]
    switch -exact -- $context {
        withAttribute {
            set result [PopContext $context instref attrNames varNames]
            foreach attr $attrNames var $varNames {
                append update "$instref->$attr = $var ;\n"
            }
            append result [IndentToBlock $update]
            PopBlock
            append result "\} /* %<[info level 0]>% */\n"
        }
        ForEachClassInstance -
        ForEachUnionSubClassInstance {
            set result [PopContext $context depth]
            for {set i 0} {$i < $depth} {incr i} {
                PopBlock
                append result [IndentToBlock "\}\n"]
            }
            append result "/* %<[info level 0]>% */\n"
        }
        default {
            error "unknown context, \"$context\""
        }
    }

    return $result
}
----

[source,c]
----
<<generation activity commands>>=
proc InstRefDeclOfClass {className varName} {
    set ref [GetClassProperty $className Reference]
    InsertSymbol Name $varName Ctype $ref Type Reference Class $className
    return "$ref$varName"
}
----

[source,c]
----
<<generation activity commands>>=
proc ForEachClassInstance {className instref} {
    variable domain

    set sym [LookUpSymbol $instref]
    if {$sym ne {}} {
        error "instance reference variable, \"$instref\", already exists"
    }
    set result "/* %<[info level 0]>% */\n"

    set instrefDecl [InstRefDeclOfClass $className $instref]
    set iab [CreateTempSymbol Ctype {MRT_iab *} Type IAB Class $className]
    set iter [CreateTempSymbol Ctype {void *} Type Pointer Class $className]
    set classnum [GetClassProperty $className Number]

    set startlevel [GetBlock]

    append result\
        "MRT_iab *const $iab = ${domain}__CLASSES\[$classnum\].iab ;\n"\
        "for (void *$iter = $iab->storageStart ; "\
        "$iter < $iab->storageFinish ;\n"\
        "        $iter = (void *)((uintptr_t)$iter + $iab->instanceSize)) "\
        "\{\n"
    PushBlock

    append result [IndentToBlock [string cat\
        "$instrefDecl = $iter ;\n"\
        "if ($instref->base__INST.alloc > 0) \{\n"\
    ]]
    PushBlock

    PushContext ForEachClassInstance depth [expr {[GetBlock] - $startlevel}]

    return $result
}
----

Union subclasses require a different strategy.
Since they do not have their storage pool,
we must iterate over the storage of the ultimate union superclass,
traverse the relationship down to the subclass and verify that the
subclass is of the correct type.

[source,c]
----
<<generation activity commands>>=
proc ForEachUnionSubClassInstance {className instref} {
    variable domain

    set sym [LookUpSymbol $instref]
    if {$sym ne {}} {
        error "instance reference variable, \"$instref\", already exists"
    }
    set result "/* %<[info level 0]>% */\n"

    set relpath [FindUnionSuperPath $className]

    set relpath [lassign $relpath superName relName subName]
    set supernum [GetClassProperty $superName Number]
    set iab [CreateTempSymbol Ctype {MRT_iab *} Type IAB Class $superName]
    set iter [CreateTempSymbol Ctype {void *} Type Pointer Class $superName]

    set startlevel [GetBlock]

    append result\
        "MRT_iab *const $iab = ${domain}__CLASSES\[$supernum\].iab ;\n"\
        "for (void *$iter = $iab->storageStart ; "\
        "$iter < $iab->storageFinish ;\n"\
        "        $iter = (void *)((uintptr_t)$iter + $iab->instanceSize)) "\
        "\{\n"
    PushBlock

    lassign [CreateTempRefSymbol $superName] superType superVar
    lassign [CreateTempRefSymbol $subName] subType subVar
    set subDesc &${domain}__CLASSES\[[GetClassProperty $subName Number]\]

    append result [IndentToBlock [string cat\
        "$superType$superVar = $iter ;\n"\
        "if ($superVar->base__INST.alloc > 0) \{\n"
    ]]
    PushBlock

    append result [IndentToBlock [string cat\
        "$subType$subVar = &$superVar->$relName.$subName ;\n"\
        "if ($subVar->base__INST.classDesc == $subDesc &&\n"\
        "        $subVar->base__INST.alloc > 0) \{\n"
    ]]
    PushBlock

    foreach {superName relName subName} $relpath {
        set prevSubVar $subVar
        lassign [CreateTempRefSymbol $superName] superType superVar
        lassign [CreateTempRefSymbol $subName] subType subVar
        set subDesc &${domain}__CLASSES\[[GetClassProperty $subName Number]\]
        append result [IndentToBlock [string cat\
            "$subType$subVar = &$prevSubVar->$relName.$subName ;\n"\
            "if ($subVar->base__INST.classDesc == $subDesc &&\n"\
            "        $subVar->base__INST.alloc > 0) \{\n"
        ]]
        PushBlock
    }
    set refDecl [InstRefDeclOfClass $subName $instref]
    append result [IndentToBlock "$refDecl = $subVar ;\n"]

    PushContext ForEachUnionSubClassInstance\
        depth [expr {[GetBlock] - $startlevel}]

    return $result
}
----

Find the path upward from a union subclass to its ultimate superclass.
Path is returned in the order of ultimate superclass downward
and consists of triples of superclass name, relationship, subclass name.

[source,c]
----
<<generation activity commands>>=
proc FindUnionSuperPath {className} {
    variable domain
    set subclassRef [UnionSubclass findWhere {$Domain eq $domain &&\
        $Class eq $className}]
    set path {}
    while {[isNotEmptyRef $subclassRef]} {
        assignAttribute $subclassRef {Relationship relName} {Class subName}
        set superclassRef [findRelated $subclassRef R45 ~R44]
        assignAttribute $superclassRef {Class superName}
        set path [linsert $path 0 $superName $relName $subName]
        set subclassRef [pipe {
            deRef $superclassRef |
            relation semijoin ~ $::micca::UnionSubclass -using\
                {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSubclass ~
        }]
    }
    return $path
}
----

[source,c]
----
<<generation activity commands>>=
proc delete {instref} {
    set sym [CheckSymbol $instref]
    if {$sym eq {}} {
        return
    }
    return mrt_DeleteInstance($instref)
}
----

[source,c]
----
<<generation activity commands>>=
proc signal {instref event args} {
    variable domain
    variable errcount

    if {[llength $args] % 2 != 0} {
        log::error "event parameters must be given as name / value pairs, got:\
            \"$args\""
        incr errcount
        return
    }
    set target [CheckSymbol $instref]
    if {$target eq {}} {
        return
    }

    dict with target {
        set eventRef [Event findById Domain $domain Model $Class Event $event]
        if {[isEmptyRef $eventRef]} {
            log::error "event, $event, is not a known event for class, $Class"
            incr errcount
            return
        }

        set transRef [findRelated $eventRef {~R80 TransitioningEvent}]
        if {[isNotEmptyRef $transRef]} {
            assignAttribute $transRef {Number eventNum}
            set eventType mrtTransitionEvent
        } else {
            set deferredRef [findRelated $eventRef {~R80 DeferredEvent}
            assignAttribute $deferredRef {Number eventNum}
            set eventType mrtPolymorphicEvent
        }

        set psig [findRelated $eventRef R69]
        set params [FindParamsFromSig $psig]
        set required [relation list $params Name]
        set supplied [dict keys $args]
        if {![::struct::set equal $required $supplied]} {
            log::error "event, $event, requires parameters,\
                \"[join $required {, }]\", got:\
                \"[join $supplied {, }]\""
            incr errcount
            return
        }

        set result {}
        set sourceinst [expr {[LookUpSymbol self] eq {} ? "NULL" : "self"}]
        set ecbvar [CreateTempSymbol Ctype {MRT_ecb *} Type ECB Class $Class]
        append result "MRT_ecb *$ecbvar = mrt_NewEvent($eventNum,\
            $eventType, $instref, $sourceinst) ;\n"
        if {[relation isnotempty $params]} {
            set eparamsname ${domain}_${Class}_${event}__EPARAMS
            set ptrparams [CreateTempSymbol Ctype "struct *$eparamsname"\
                Type EventParams Class $Class]
            append result\
                "struct $eparamsname *const $ptrparams =\n"\
                "    (struct $eparamsname *)$ecbvar->eventParameters ;\n"
            relation foreach param $params -ascending Position {
                relation assign $param Name
                append result "$ptrparams->$Name = [dict get $args $Name] ;\n"
            }
        }
        append result "mrt_PostEvent($ecbvar) ;\n"
    }
    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-24.0 {
    Generated code file with state model
} -setup {
    # makeFile {} codegen24.h
    # makeFile {} codegen24.c
    micca configure {
        domain codegen24 {
            class X {
                attribute color int -default 20
                attribute temp int -default 40
                attribute size int -default 50

                statemodel {
                    state s1 {a int} {
                        printf("color = %d\n", %<instAttribute self color>%) ;
                        %<signal self e1 a 20>%
                        %<withInstAttribute self>%
                            color += 10 ;
                            temp += 20 ;
                            size -= 2 ;
                        %<end>%
                        %<withInstAttribute self {temp t} {size s}>%
                            t -= 20 ;
                            s += 2 ;
                        %<end>%
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                    state s2 {} {
                        %<ForEachClassInstance Y ys>%
                            if (%<instAttribute ys sign>%) {
                                %<assignInstAttribute ys cost>%
                                cost *= 100 ;
                                printf("%d\n", cost) ;
                            }
                        %<end>%
                    }
                    transition s2 - e1 -> s1
                }
            }
            class Y {
                attribute sign bool -default true
                attribute cost int -default 10
            }
        }
        population codegen24 {
            class X {
                instance x1
            }
            class Y {
                instance y1
                instance y2 sign false
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {self->color} codegen24.c]] == 3}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-25.0 {
    Generated code file union subclasses
} -setup {
    # makeFile {} codegen25.h
    # makeFile {} codegen25.c
    micca configure {
        domain codegen25 {
            class A {}
            class B {}
            class X {
                attribute color int -default 20
                attribute temp int -default 40
                attribute size int -default 50

            }
            generalization R1 -union A B X

            class Y {
                attribute sign bool -default true
                attribute cost int -default 10

                statemodel {
                    state s1 {} {
                        %<ForEachUnionSubClassInstance Z zref>%
                            printf("%d\n", %<instAttribute zref plus>%) ;
                        %<end>%
                    }
                    transition s1 - e1 -> s1
                }
            }
            class Z {
                attribute magnitude bool -default false
                attribute plus int -default 42
            }

            generalization R2 -union X Y Z
        }
        population codegen25 {
            class A {
                instance a1
                instance a2
                instance a3
                instance a4
            }
            class B {
                instance b1 R1 a1
            }
            class X {
                instance x1 R1 a2
                instance x2 R1 a3
                instance x3 R1 a4
            }
            class Y {
                instance y1 R2 x1
            }
            class Z {
                instance z1 R2 x2
                instance z2 R2 x3
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {->base__INST} codegen25.c]] == 5}
} -result {1}
----
