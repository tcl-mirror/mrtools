// vim:set syntax=asciidoc:

= Generating ``C'' Code

[partintro]
.Generating ``C'' Code
--
In the previous part of the book,
we described the ``C'' code that forms the run time support
for `micca` translated domains.
In this part,
we show how ``C'' code is generated to implement the domain.
--

== Introduction

This is the fourth and final major section of the `micca` translation
scheme.
We have already seen the platform specific model and how it captures
the properties of a domain.
The `micca` domain specific language is used to populate the platform
model.
The `micca` run time translates model level actions into ``C'' level
execution.
The run time can be compiled separately and is data driven.
The details of how a domain behaves is completely determined by the
data values supplied to the run time and the state activities and
domain operations supplied as ``C'' code.

Code generation consist of two major pieces:

* Generating initialized ``C'' variables of the type required by the run time.
* Generating ``C'' code for state activities and domain operations to
facilitate interfacing to the run time code.

In the next section we discuss generating the data required by the run time.
Afterward, we describe generating ``C'' code to help interface
user supplied state activity code to the run time.

=== Generating a Domain

One of the domain operations provide by `micca` is a generate command.
The usual workflow is to configure a domain, populate the domain and then
generate the code files.

[source,c]
----
<<micca configuration>>=
operation generate {args} {
    return [@Gen@::miccaGenerate $args]
}
----

Since `micca` is a `rosea` based application,
we will perform the code generation in a child namespace to prevent
any possible name collisions.
This follows the same pattern we used for the configuration command.

[source,c]
----
<<generation commands namespace>>=
namespace eval @Gen@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    <<generation helpers namespace>>
    <<generation header namespace>>
    <<generation code namespace>>

    namespace path {
        ::micca
        ::micca::@Config@::Helpers
        ::micca::@Gen@::Helpers
        ::rosea::InstCmds
    }

    <<generation data>>
    <<generation commands>>
}
----

== Generating Run Time Data

`Micca` creates two ``C'' files for each domain.
The first is a header file that contains interfacing information
for the domain.
The second is a code file that contains all the run time data and
``C'' code for the domain.

A ``C'' compiler requires a large amount of type information in a
specific order.
One is required to define things in specific orders to satisfy the
compiler.
One way to accomplish this is to use a template.
The template is orgainized in the order required by the compiler
and contains embedded commands.
When expanded the commands embedded in the template query the
platform model and produce ``C'' code output.

Most languages have template expansion libraries and Tcl is no different.
We will use the `textutil::expander` package from _tcllib_.
We will also have use for creating nicely adjusted text blocks,
typically as comments, and will be using `textutil::adjust` for that purpose.

[source,c]
----
<<required packages>>=
package require textutil::expander
package require textutil::adjust
----

[source,c]
----
<<generation commands>>=
proc miccaGenerate {arglist} {
    variable errcount 0

    <<miccaGenerate: parse command line arguments>>
    <<miccaGenerate: set up template expansion>>
    <<miccaGenerate: verify domains are populated>>
    <<miccaGenerate: generate header files>>
    <<miccaGenerate: generate code files>>

    rename expand {} ; # <1>

    if {$errcount > 0} {
        tailcall DeclError GENERATE_ERRORS $errcount
    }
    return
}
----
<1> The template expander creates a new command so we need to delete it
so that there won't be any conflict the next time `micccaGenerate` is
invoked.

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
GENERATE_ERRORS     {encountered %d code generation errors}
----

[source,c]
----
<<miccaGenerate: parse command line arguments>>=
variable options
set options [dict create\
    expanderror     fail\
    nonames         false\
]
set options [dict merge $options $arglist]
----

[source,c]
----
<<miccaGenerate: set up template expansion>>=
textutil::expander expand
expand setbrackets %< >%
expand errmode [dict get $options expanderror]
----

We will insist that each domain have exactly one population for it.
This is accomplished by finding all the populations associated with
the domains and looking for those where there is not exactly one
population given for the domain.

[source,c]
----
<<miccaGenerate: verify domains are populated>>=
set pops [pipe {
    Domain findAll |
    deRef ~ |
    relation eliminate ~ Interface Prologue Epilogue |
    relation rename ~ Name Domain |
    ralutil::rvajoin ~ $::micca::Population Populations 
}]

set badops [relation restrictwith $pops {[relation cardinality $Populations] != 1}]
relation foreach badop $badops {
    relation assign $badpop Populations
    set card [relation cardinality $Populations]
    set msg [string cat "For domain, \"$Domain\", "\
        [expr {$card == 0 ?\
            "no population is given" :\
            "$card populations are given"}]\
        ": expected exactly one population for the domain"
    log::error $msg
    incr errcount
}

if {$errcount > 0} {
    tailcall DeclError GENERATE_ERRORS $errcount
}
----

== Header Files

[source,c]
----
<<miccaGenerate: generate header files>>=
expand evalcmd "namespace eval [namespace current]::GenHeader"
----

[source,c]
----
<<generation header namespace>>=
namespace eval GenHeader {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation header data>>
    <<generation header commands>>
}
----

[source,c]
----
<<generation data>>=
set headerTemplate [string cat\
    %<banner>%\
    "#ifndef %<headerFileGuard>%\n"\
    "#define %<headerFileGuard>%\n"\
    %<interface>%\
    "#include <stddef.h>\n"\
    "#include <stdint.h>\n"\
    "#include <stdbool.h>\n"\
    %<typeAliases>%\
    %<domainOpDeclarations>%\
    %<eventParamDeclarations>%\
    %<portalIds>%\
    "#endif /* %<headerFileGuard>% */"\
]
----

[source,c]
----
<<miccaGenerate: generate header files>>=
forAllRefs domainRef [Domain findAll] {
    namespace upvar GenHeader\
        domain domain\
        interface interface

    assignAttribute $domainRef\
        {Name domain}\
        {Interface interface}

    variable headerTemplate

    set hchan [::open $domain.h w]
    try {
        puts $hchan [expand expand $headerTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $hchan
    }

    unset domain interface
}
----

[source,c]
----
<<generation header commands>>=
proc headerFileGuard {} {
    variable domain
    return [string toupper [string trim $domain]]_H_
}
----

[source,c]
----
<<generation header commands>>=
proc interface {} {
    variable interface

    set result {}
    if {$interface ne {}} {
        append result\
            [comment "Domain Interface Contents"]\
            [indentCode [string trim $interface \n] 0]
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-1.0 {
    Generated header file with interface info
} -setup {
    makeFile {} header1.h
    makeFile {} header1.c
    micca configure {
        domain header1 {
            interface {#include <stdio.h>}

            class c1 {
                attribute color int -default 20
            }
        }
        population test header1 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {stdio} header1.h]
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc typeAliases {} {
    variable domain
    set aliases [pipe {
        TypeAlias findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ TypeName
    }]
    set doRefs [pipe {
        DomainOperation findWhere {$Domain eq $domain &&\
                $ReturnDataType in $aliases} |
        findRelated % R5 ~R7
    } {} |%]
    set dopRefs [pipe {
        DomainOperationParameter findWhere {$Domain eq $domain &&\
                $DataType in $aliases} |
        findRelated % R6 R5 ~R7
    } {} |%]
    set argRefs [pipe {
        Argument findWhere {$Domain eq $domain && $DataType in $aliases} |
        deRef ~ |
        relation semijoin ~ $::micca::TypeAlias\
                -using {Domain Domain DataType TypeName} |
        ::rosea::Helpers::ToRef ::micca::TypeAlias ~
    }]

    set taRefs [refUnion $doRefs $dopRefs]
    set taRefs [refUnion $taRefs $argRefs]
    set result {}
    if {[isNotEmptyRef $taRefs]} {
        append result [comment "Type Aliases"]
        forAllRefs taRef $taRefs {
            assignAttribute $taRef TypeName TypeDefinition
            append result\
                "typedef "\
                [typeCheck composeDeclaration $TypeDefinition $TypeName]\
                " \;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-2.0 {
    Generated header file with external type alias
} -setup {
    makeFile {} header2.h
    makeFile {} header2.c
    micca configure {
        domain header2 {
            typealias gCount uint64_t
            typealias pCount uint32_t

            domainop gCount countAll {a int} {
                return 27 ;
            }

            domainop int countSome {b pCount} {
                return 42 ;
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population test header2 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {typedef} header2.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc domainOpDeclarations {} {
    variable domain
    set opRefs [DomainOperation findWhere {$Domain eq $domain}]

    set result {}
    if {[isNotEmptyRef $opRefs]} {
        append result [comment "External Declarations for Domain Operations"]

        forAllRefs opRef $opRefs {
            assignAttribute $opRef
            if {$Comment ne {}} {
                append result [comment $Comment]
            }
            append result "extern $ReturnDataType " $Domain _ $Name \(

            set params [pipe {
                findRelated $opRef ~R6 |
                deRef % |
                relation list % DataType -ascending Number |
                join % {, }
            } {} |%]
            append result $params "\) ;\n"
        }
    }
    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-3.0 {
    Generated header file domain operations
} -setup {
    makeFile {} header3.h
    makeFile {} header3.c
    micca configure {
        domain header3 {
            domainop int op1 {a int b char} {
                printf ("%d %c\n", a, b) ;
            } {
                two parameters
            }
            domainop int op2 {a {char *} b {uint8_t *}} {
                printf ("%s %s\n", a, b) ;
            } {
                pointer type parameters
            }
            class c1 {
                attribute color int -default 20
            }
        }
        population test header3 {
            class c1 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {extern int header3_op[0-9]} header3.h]
} -result {2}
----

[source,c]
----
<<generation header commands>>=
proc portalIds {} {
    variable domain

    set result [comment "Numeric encoding of classes, attributes and\
            instances used by the portal functions"]
    set classRefs [Class findWhere {$Domain eq $domain}]
    forAllRefs classRef $classRefs {
        assignAttribute $classRef
        append result [comment "Class: $Name"]
        set classid [string toupper ${Domain}_${Name}_CLASSID]
        append result "#define $classid $Number\n"

        set attrRefs [findRelated $classRef ~R20 {~R21 Attribute}]
        set attrNumber -1
        relation foreach attr [deRef $attrRefs] -ascending Name {
            relation assign $attr {Name attrName}
            set attrid [string toupper ${Domain}_${Name}_${attrName}_ATTRID]
            append result "#define $attrid [incr attrNumber]\n"
        }

        set instRefs [findRelated $classRef ~R20 ~R103]
        relation foreach inst [deRef $instRefs] -ascending Number {
            relation assign $inst Instance {Number InstNumber}
            set instid [string toupper ${Domain}_${Name}_${Instance}_INSTID]
            append result "#define $instid $InstNumber\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test headergen-4.0 {
    Generated header file with portal constants
} -setup {
    makeFile {} header4.h
    makeFile {} header4.c
    micca configure {
        domain header4 {
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population test header4 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {CLASSID} header4.h]
} -result {2}
----

== Generating Code Files

[source,c]
----
<<miccaGenerate: generate code files>>=
expand evalcmd "namespace eval [namespace current]::GenCode"
----

[source,c]
----
<<generation code namespace>>=
namespace eval GenCode {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::micca::@Gen@::Helpers
        ::micca::@Config@::Helpers
        ::rosea::InstCmds
    }

    <<generation code data>>
    <<generation code commands>>
}
----

[source,c]
----
<<generation data>>=
set codeTemplate [string cat\
    %<banner>%\
    %<prologue>%\
    %<domainInclude>%\
    "#include \"micca_rt.h\"\n"\
    %<forwardClassDeclarations>%\
    %<classDeclarations>%\
    %<stateParamDeclarations>%\
    %<operationDeclarations>%\
    %<ctorDeclarations>%\
    %<dtorDeclarations>%\
    %<activityDeclarations>%\
    %<storageDeclarations>%\
    %<iabDefinitions>%\
    %<edbDefinitions>%\
    %<pdbDefinitions>%\
    %<relationshipDefinitions>%\
    %<epilogue>%\
]
----

[source,c]
----
<<miccaGenerate: generate code files>>=
forAllRefs domainRef [Domain findAll] {
    namespace upvar GenCode\
        domain domain\
        prologue prologue\
        epilogue epilogue

    assignAttribute $domainRef\
        {Name domain}\
        {Prologue prologue}\
        {Epilogue epilogue}

    variable codeTemplate

    PrepareDomainProperties $domain

    set cchan [::open $domain.c w]
    try {
        puts $cchan [expand expand $codeTemplate]
    } on error {result opts} {
        puts $::errorInfo
        return -options $opts $result
    } finally {
        chan close $cchan
    }
}
----

[source,c]
----
<<generation helper commands>>=
proc PrepareDomainProperties {domain} {
    variable ClassProperties

    # Need to handle missing class populations.
    # Not all classes will have a ClassPopulation instance.
    set classRefs [Class findWhere {$Domain eq $domain}]
    set allocs [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} |
        deRef % |
        relation project % Class Allocation |
        relation rename % Class Name
    } {} |%]

    set insts [pipe {
        findRelated $classRefs R104 {~R101 ElementPopulation}\
            {~R105 ClassPopulation} ~R102 |
        deRef % |
        relation project % Class Number |
        relation rename % Class Name
    } {} |%]

    set ClassProperties [pipe {
        deRef $classRefs |
        relation project ~ Name |
        relation extend ~ stup\
            Declaration string {"struct [tuple extract $stup Name]"}\
            Reference string {"struct [tuple extract $stup Name] *"}\
            StorageVariable string {"struct [tuple extract $stup Name]\
                [tuple extract $stup Name]__POOL"} |
        ralutil::rvajoin ~ $allocs Allocations |
        relation extend ~ atup Allocation int {
            [relation isempty [tuple extract $atup Allocations]] ?\
            0 : [relation extract [tuple extract $atup Allocations] Allocation]
        } |
        relation eliminate ~ Allocations |
        ralutil::rvajoin ~ $insts Instances |
        relation extend ~ itup\
            InitialInstance int {
                [relation cardinality [tuple extract $itup Instances]]} \
            TotalInstance int {
                [relation cardinality [tuple extract $itup Instances]] +
                [tuple extract $itup Allocation]} |
        relation eliminate ~ Instances
    }]

    variable AssocProperties

    set AssocProperties [pipe {
        Association findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Association |
        ralutil::rvajoin ~ [deRef [StaticAssociation findAll]] Populations |
        relation extend ~ atup IsStatic boolean {
            [relation isnotempty [tuple extract $atup Populations]]} |
        relation project ~ Association IsStatic |
        relation rename ~ Association Name
    }]

    return
}

proc JoinToClassProperties {proprel} {
    variable ClassProperties
    set ClassProperties [relation join $ClassProperties $proprel]
}

proc GetClassProperty {class prop} {
    variable ClassProperties
    set cprop [relation restrictwith $ClassProperties {$Name eq $class}]
    if {[relation isnotempty $cprop]} {
        return [relation extract $cprop $prop]
    }

    error "unknown property, \"$prop\", for class, \"$class\""
}

proc GetAssociationProperty {assoc prop} {
    variable AssocProperties
    set aprop [relation restrictwith $AssocProperties {$Name eq $assoc}]
    if {[relation isnotempty $aprop]} {
        return [relation extract $aprop $prop]
    }

    error "unknown property, \"$prop\", for association, \"$assoc\""
}
----

[source,c]
----
<<generation code commands>>=
proc prologue {} {
    variable prologue

    set result {}
    if {$prologue ne {}} {
        append result\
            [comment "Domain Prologue Begin"]\
            [indentCode [string trim $prologue \n] 0]\
            [comment "Domain Prologue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc epilogue {} {
    variable epilogue

    set result {}
    if {$epilogue ne {}} {
        append result\
            [comment "Domain Epilogue Begin"]\
            [indentCode [string trim $epilogue \n] 0]\
            [comment "Domain Epilogue End"]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc domainInclude {} {
    variable domain

    return "#include \"$domain.h\"\n"
}
----

[source,c]
----
<<generate command tests>>=
test codegen-1.0 {
    Generated code file with prologue and epilogue
} -setup {
    makeFile {} codegen1.h
    makeFile {} codegen1.c
    micca configure {
        domain codegen1 {
            prologue {#include mySpecial.h}
            prologue {#include theSpecial.h}
            epilogue {
                static int count(
                    int a)
                {
                    return a + 1 ;
                }
            }
            class c1 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
            class c2 {
                attribute color int -default 10
                attribute temp double -default 2.0
            }
        }
        population test codegen1 {
            class c1 {
                instance fred1
            }
            class c2 {
                instance fred1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    llength [fileutil::grep {Special} codegen1.c]
} -result {2}
----

[source,c]
----
<<generation code commands>>=
proc forwardClassDeclarations {} {
    variable domain

    set classNames [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation list ~ Name -ascending Number
    }]
    set result [comment "Class structure forward declarations"]
    foreach className $classNames {
        append result "struct $className ;\n"
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc classDeclarations {} {
    variable domain

    variable linkMemberNames [dict create]

    set result [comment "Class structure declarations"]

    set ultimates [pipe {
        FindUltimateSuperclasses $domain |
        findRelated % {~R46 UnionSuperclass}
    } {} |%]
    append result [DeclareUnionSubclassStructures $ultimates]

    set remaining [FindNonUnionSubclasses $domain]
    forAllRefs classRef $remaining {
        append result [DeclareClassStructure $classRef]
    }

    JoinToClassProperties [relation fromdict $linkMemberNames\
        Name string LinkMembers list]

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc FindNonUnionSubclasses {domain} {
    set usubs [UnionSubclass findWhere {$Domain eq $domain}]
    return [pipe {
        Class findWhere {$Domain eq $domain} |
        deRef ~ |
        relation semiminus [deRef $usubs] ~ -using {Domain Domain Class Name} |
        ::rosea::Helpers::ToRef ::micca::Class ~
    }]
}
----

[source,c]
----
<<generation code commands>>=
proc DeclareUnionSubclassStructures {superRefs} {
    if {[isEmptyRef $superRefs]} {
        return
    }

    set subRefs [findRelated $superRefs R44 ~R45]
    forAllRefs subRef $subRefs {
        set newsupers [pipe {
            deRef $subRef |
            relation semijoin ~ $::micca::UnionSuperclass\
                -using {Domain Domain Class Class} |
            ::rosea::Helpers::ToRef ::micca::UnionSuperclass ~
        }]

        append result [DeclareUnionSubclassStructures $newsupers]

        append result [DeclareClassStructure [findRelated $subRef R47 R40 R41]]
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc DeclareClassStructure {classRef} {
    assignAttribute $classRef {Name className}

    append result\
        "struct $className \{\n"\
        "    MRT_Instance base__INST ;\n"

    set compRefs [findRelated $classRef ~R20]

    # Attributes first
    forAllRefs attrRef [findRelated $compRefs {~R21 Attribute}] {
        assignAttribute $attrRef {Name attrName} DataType
        append result "    $DataType $attrName ;\n"
    }

    # References second
    set refRefs [findRelated $compRefs {~R21 Reference}]

    # Superclass References
    forAllRefs superRef [findRelated $refRefs {~R23 SuperclassReference}] {
        assignAttribute $superRef {Name attrName}

        set superDecl [pipe {
            findRelated $superRef ~R91 R37 ~R36 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        append result "    $superDecl$attrName ;\n"
    }

    # Subclass References
    forAllRefs subRef [findRelated $refRefs {~R23 SubclassReference}] {
        assignAttribute $subRef {Name attrName}
        append result "    MRT_SuperclassRef $attrName ;\n"
    }

    # Associator Reference
    forAllRefs atorRef [findRelated $refRefs {~R23 AssociatorReference}] {
        assignAttribute $atorRef {Name attrName}

        set aclassRef [findRelated $atorRef ~R93]
        set sourceDecl [pipe {
            findRelated $aclassRef R42 ~R34 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]
        set targetDecl [pipe {
            findRelated $aclassRef R42 ~R35 |
            readAttribute % Class |
            GetClassProperty % Reference
        } {} |%]

        append result\
            "    struct \{\n"\
            "        ${targetDecl}forward ;\n"\
            "        ${sourceDecl}backward ;\n"\
            "    \} $attrName ;\n"
    }

    # Association Reference
    forAllRefs assocRef [findRelated $refRefs {~R23 AssociationReference}] {
        assignAttribute $assocRef {Name attrName}

        set apcRefs [findRelated $assocRef ~R25 R90]
        set napcRefs [refMultiplicity $apcRefs]
        if {$napcRefs == 1} {
            set srcRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $srcRef]} {
                set refedRef [findRelated $srcRef R32 ~R33]
                append result [GenDirectionalReference $attrName\
                        {*}[readAttribute $refedRef Relationship Class] false]
            } else {
                set srcRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                if {[isNotEmptyRef $srcRef]} {
                    set refing [findRelated $srcRef R33 ~R32]
                    append result\
                        [GenDirectionalReference $attrName\
                            {*}[readAttribute $refedRef\
                                Relationship Class Multiplicity]]
                } else {
                    set srcRef [findRelated $apcRefs {~R38 SourceClass}]
                    if {[isNotEmptyRef $srcRef]} {
                        set assoc [findRelated $srcRef R34 ~R42]
                        set target [findRelated $srcRef R34 ~R35]
                        append result\
                            [GenDirectionalReference $attrName\
                                {*}[readAttribute $assoc Relationship Class]\
                                [readAttribute $target Multiplicity]]
                    } else {
                        set trgRef [findRelated $apcRefs {~R38 TargetClass}]
                        if {[isNotEmptyRef $trgRef]} {
                            set assoc [findRelated $trgRef R35 ~R42]
                            set source [findRelated $trgRef R35 ~R34]
                            append result\
                                [GenDirectionalReference $attrName\
                                    {*}[readAttribute $assoc Relationship Class]\
                                    [readAttribute $source Multiplicity]]
                        } else {
                            error "cannot find association participant type\
                                across R38"
                        }
                    }
                }
            }
        } elseif {$napcRefs == 2} {
            # do reflexive case
            append result "    struct \{\n"

            set refingRef [findRelated $apcRefs {~R38 SimpleReferringClass}]
            if {[isNotEmptyRef $refingRef]} {
                # simple association
                set refedRef [findRelated $apcRefs {~R38 SimpleReferencedClass}]
                append result "    " [GenDirectionalReference forward\
                    {*}[readAttribute $refedRef Relationship Class] false]
                append result "    " [GenDirectionalReference backward\
                    {*}[readAttribute $refingRef Relationship Class Multiplicity]]
            } else {
                set sourceRef [findRelated $apcRefs {~R38 SourceClass}]
                if {[isNotEmptyRef $sourceRef]} {
                    set targetRef [findRelated $apcRefs {~R38 TargetClass}]
                    set assocRef [findRelated $sourceRef R34 ~R42]
                    append result [GenDirectionalReference forward\
                        {*}[readAttribute $assocRef Relationship Class]\
                        [readAttribute $targetRef Multiplicity] 8]
                    append result [GenDirectionalReference backward\
                        {*}[readAttribute $assocRef Relationship Class]\
                        [readAttribute $sourceRef Multiplicity] 8]

                } else {
                    error "cannot resolve reflexive association"
                }
            }
            append result "    \} $attrName ;\n"
        } else {
            error "unexpected number of directional references, \"$napcRefs\""
        }
    }

    # Subclass container
    # Union supertypes will contain a supclass container.
    forAllRefs contRef [findRelated $compRefs {~R21 SubclassContainer}] {
        assignAttribute $contRef {Name attrName}

        set subRefs [findRelated $contRef ~R96 R44 ~R45]
        append result "    union \{\n"
        foreach subName [relation list [deRef $subRefs] Class] {
            append result "        "\
                "[GetClassProperty $subName Declaration] $subName ;\n"
        }
        append result "    \} $attrName ;\n"
    }

    # Target links
    # link pointers in classes that are referred to by classes with
    # link references.
    # Start with associator classes. They will have link containers if
    # either source or target is multiple and non-static
    variable linkMemberNames
    dict set linkMemberNames $className [list]
    set atorRef [findRelated $classRef {~R41 ClassRole} {~R40 AssociatorClass}]
    if {[isNotEmptyRef $atorRef]} {
        set sourceRef [findRelatedWhere $atorRef {R42 ~R34} {$Multiplicity}]
        if {[isNotEmptyRef $sourceRef]} {
            assignAttribute $sourceRef Relationship
            if {![GetAssociationProperty $Relationship IsStatic]} {
                append result "    "\
                    "MRT_LinkRef ${Relationship}_forward ;\n"
                dict lappend linkMemberNames $className ${Relationship}_forward
            }
        }
        set targetRef [findRelatedWhere $atorRef {R42 ~R35} {$Multiplicity}]
        if {[isNotEmptyRef $targetRef]} {
            assignAttribute $targetRef Relationship
            if {![GetAssociationProperty $Relationship IsStatic]} {
                append result "    "\
                    "MRT_LinkRef ${Relationship}_backward ;\n"
                dict lappend linkMemberNames $className ${Relationship}_backward
            }
        }
    }

    # Now simple referring classes, multiple and non-static
    set srcRef [findRelatedWhere $classRef {
        {~R41 ClassRole}
        {~R40 AssociationParticipantClass}
        {~R38 SimpleReferringClass}} {$Multiplicity}]
    if {[isNotEmptyRef $srcRef]} {
        assignAttribute $srcRef Relationship
        if {![GetAssociationProperty $Relationship IsStatic]} {
            append result "    MRT_LinkRef ${Relationship}_links ;\n"
            dict lappend linkMemberNames $className ${Relationship}_links
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc GenDirectionalReference {name assocName reftoClass isMultiple {indent 4}} {
    if {$isMultiple} {
        if {[GetAssociationProperty $assocName IsStatic]} {
            append members\
                "unsigned count ;\n"\
                "[GetClassProperty $reftoClass Reference] const *references ;\n"
            append result\
                "struct \{\n"\
                [indentCode $members $indent]\
                "\} $name ;\n"
        } else {
            set result "MRT_LinkRef $name ;\n"
        }
    } else {
        set result "[GetClassProperty $reftoClass Reference]$name ;\n"
    }

    return [indentCode $result $indent]
}
----

[source,c]
----
<<generate command tests>>=
test codegen-2.0 {
    Generated code file supertype and subtype references
} -setup {
    makeFile {} codegen2.h
    makeFile {} codegen2.c
    micca configure {
        domain codegen2 {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }
        population test codegen2 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R1 fred1
            }
            class sub2 {
                instance s2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {MRT_SuperclassRef} codegen2.c]] == 1}\
        {[llength [fileutil::grep {struct super \*R1} codegen2.c]] == 2}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-3.0 {
    Generated code file associative class references
} -setup {
    makeFile {} codegen3.h
    makeFile {} codegen3.c
    micca configure {
        domain codegen3 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population test codegen3 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 fred1
                instance x2 R1 fred2
            }
            class Y {
                instance y1 R1 fred1
                instance y2 R1 fred2
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen3.c]] == 3}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-4.0 {
    Generated code file reflexive class references
} -setup {
    makeFile {} codegen4.h
    makeFile {} codegen4.c
    micca configure {
        domain codegen4 {
            class X {}
            association R1 X 0..1--0..1 X
        }
        population test codegen4 {
            class X {
                instance x1 R1 {forward x2 backward {}}
                instance x2 R1 {forward {} backward x1}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen4.c]] == 1}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-5.0 {
    Generated code file reflexive associative class references
} -setup {
    makeFile {} codegen5.h
    makeFile {} codegen5.c
    micca configure {
        domain codegen5 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population test codegen5 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a1
            }
            static R1
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen5.c]] == 2}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-6.0 {
    Generated code file union generalization
} -setup {
    # makeFile {} codegen6.h
    # makeFile {} codegen6.c
    micca configure {
        domain codegen6 {
            class super {}
            class sub1 {
                attribute color int -default 10
            }
            class sub2 {
                attribute temp int -default 20
            }
            generalization R1 -union super sub1 sub2

            class sub3 {
                attribute degree int -default 30
            }
            class sub4 {
                attribute yaw int -default 40
            }

            generalization R2 -union sub1 sub3 sub4

            class sub5 {
                attribute degree int -default 30
            }
            class sub6 {
                attribute degree int -default 30
            }

            generalization R3 -union sub1 sub5 sub6
        }
        population test codegen6 {
            class super {
                instance fred1 R1 {sub1 s1}
                instance fred2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R2 {sub3 s3} R3 {sub5 s5}
            }
            class sub2 {
                instance s2
            }
            class sub3 {
                instance s3
            }
            class sub5 {
                instance s5
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1} codegen6.c]] == 1}\
        {[llength [fileutil::grep {R2} codegen6.c]] == 1}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-7.0 {
    Generated code file associative class references -- non static
} -setup {
    # makeFile {} codegen7.h
    # makeFile {} codegen7.c
    micca configure {
        domain codegen7 {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..*--0..* Y
        }
        population test codegen7 {
            class A {
                instance fred1 R1 {X x1 Y y1}
                instance fred2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 fred1
                instance x2 R1 fred2
            }
            class Y {
                instance y1 R1 fred1
                instance y2 R1 fred2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen7.c]] == 3}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-8.0 {
    Generated code file reflexive associative class references -- non static
} -setup {
    # makeFile {} codegen8.h
    # makeFile {} codegen8.c
    micca configure {
        domain codegen8 {
            class A {}
            class X {}
            association R1 -associator A X 0..*--0..* X
        }
        population test codegen8 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_} codegen8.c]] == 3}
} -result {1}
----

[source,c]
----
<<generate command tests>>=
test codegen-9.0 {
    Generated code file reflexive class references
} -setup {
    # makeFile {} codegen9.h
    # makeFile {} codegen9.c
    micca configure {
        domain codegen9 {
            class X {}
            association R1 X 0..*--0..1 X
        }
        population test codegen9 {
            class X {
                instance x1 R1 {forward x2 backward {x1 x3}}
                instance x2 R1 {forward x3 backward {x1 x2}}
                instance x3 R1 {forward x1 backward {x2 x3}}
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {R1_links} codegen9.c]] == 2}
} -result {1}
----

[source,c]
----
<<generation header commands>>=
proc eventParamDeclarations {} {
    variable domain
    set result {}

    set tevents [pipe {
        TransitioningEvent findWhere {$Domain eq $domain} |
        findRelated ~ R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    if {[relation isnotempty $tevents]} {
        append result [comment "Transition Event Parameter Structure\
                Declarations"]
        relation foreach tevent $tevents -ascending Model {
            relation assign $tevent
            relation foreach event $Events {
                relation assign $event
                append result\
                    "struct ${domain}_${Model}_${Event}_EventParams \{\n"
                relation foreach param $Params -ascending Position {
                    relation assign $param DataType Name
                    append result\
                        "    [typeCheck composeDeclaration $DataType $Name] ;\n"
                }
                append result "\} ;\n"
            }
        }
    }

    set pevents [pipe {
        PolymorphicEvent findWhere {$Domain eq $domain} |
        findRelated ~ R81 R80 |
        deRef ~ |
        relation join $::micca::ParameterSignature |
        relation eliminate ~ ASigID |
        relation join ~ $::micca::Parameter $::micca::Argument |
        relation project ~ Model Event Name Position DataType |
        relation group ~ Params Name Position DataType |
        relation group ~ Events Event Params
    }]
    if {[relation isnotempty $pevents]} {
        append result [comment "Polymorphic Event Parameter Structure\
                Declarations"]
        relation foreach tevent $pevents -ascending Model {
            relation assign $tevent
            relation foreach event $Events {
                relation assign $event
                append result\
                    "struct ${domain}_${Model}_${Event}_PolyEventParams \{\n"
                relation foreach param $Params -ascending Position {
                    relation assign $param DataType Name
                    append result\
                        "    [typeCheck composeDeclaration $DataType $Name] ;\n"
                }
                append result "\} ;\n"
            }
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc stateParamDeclarations {} {
    variable domain
    set result {}

    set stateargs [pipe {
        State findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name State |
        relation join $::micca::ParameterSignature $::micca::Parameter\
                $::micca::Argument |
        relation project ~ Model State Name Position DataType |
        relation group ~ Params Name Position DataType
    }]

    if {[relation isnotempty $stateargs]} {
        append result [comment "State Parameter Structure Declarations"]
        relation foreach statearg $stateargs -ascending {Model State} {
            relation assign $statearg
            append result "struct ${Model}_${State}_StateParams \{\n"
            relation foreach param $Params -ascending Position {
                relation assign $param DataType Name
                append result\
                    "    [typeCheck composeDeclaration $DataType $Name] ;\n"
            }
            append result "\} ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-10.0 {
    Generated event parameter structures
} -setup {
    # makeFile {} codegen10.h
    # makeFile {} codegen10.c
    micca configure {
        domain codegen10 {
            typealias MyCount int
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            class super {
                polymorphic e1 f MyCount g {char *}
            }
            class sub1 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            class sub2 {
                statemodel {
                    state s1 {a MyCount b {char *}} {
                        printf("%d %s\n", a, b) ;
                    }
                    transition s1 -> e1 -> s1
                }
            }
            generalization R1 super sub1 sub2
        }
        population test codegen10 {
            class X {
                instance x1 color 30
            }
            class super {
                instance sup1 R1 {sub1 s1}
                instance sup2 R1 {sub2 s2}
            }
            class sub1 {
                instance s1 R1 sup1
            }
            class sub2 {
                instance s2 R1 sup2
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {_EventParams} codegen10.h]] == 3}\
        {[llength [fileutil::grep {_PolyEventParams} codegen10.h]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc operationDeclarations {} {
    variable domain
    set result {}

    set ops [pipe {
        Operation findWhere {$Domain eq $domain} |
        deRef ~ |
        relation rename ~ Name Operation |
        ralutil::rvajoin ~ $::micca::OperationParameter Parameters
    }]

    if {[relation isnotempty $ops]} {
        append result [comment "Class Operations Forward Declarations"]
        relation foreach op $ops {
            relation assign $op
            append result\
                "static $ReturnDataType ${Class}_$Operation\("

            if {[relation isempty $Parameters]} {
                append result void
            } else {
                append result [join\
                    [relation list $Parameters DataType -ascending Number] {, }]
            }

            append result "\) ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-11.0 {
    Generated code file with class operations
} -setup {
    # makeFile {} codegen11.h
    # makeFile {} codegen11.c
    micca configure {
        domain codegen11 {
            class X {
                attribute color int -default 20

                classop int count {} {
                    return 42 ;
                }

                instop void addColor {amount int} {
                    self->color += amount
                }
            }
        }
        population test codegen11 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X_count} codegen11.c]] == 1}\
        {[llength [fileutil::grep {X_addColor} codegen11.c]] == 1}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc ctorDeclarations {} {
    variable domain
    set result {}

    set ctors [Constructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $ctors]} {
        append result [comment "Class Constructor Forward Declarations"]
        forAllRefs ctor $ctors {
            assignAttribute $ctor {Class className}
            append result\
                "static void ${className}__CTOR\("\
                [GetClassProperty $className Reference]\
                "\) ; \n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc dtorDeclarations {} {
    variable domain
    set result {}

    set dtors [Destructor findWhere {$Domain eq $domain}]
    if {[isNotEmptyRef $dtors]} {
        append result [comment "Class Destructor Forward Declarations"]
        forAllRefs dtor $dtors {
            assignAttribute $dtor {Class className}
            append result\
                "static void ${className}__DTOR\("\
                [GetClassProperty $className Reference]\
                "\) ; \n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc activityDeclarations {} {
    variable domain
    set result {}

    set classes [pipe {
        State findWhere {$Domain eq $domain && $Activity ne {}} |
        deRef ~ |
        relation eliminate ~ Domain Activity IsTerminal PSigID |
        relation group ~ States Name
    }]

    if {[relation isnotempty $classes]} {
        append result [comment "State Activities Forward Declarations"]

        relation foreach class $classes -ascending Model {
            relation assign $class
            relation foreach state $States {
                relation assign $state
                append result "static void ${Model}_${Name}__ACTIVITY\("\
                    "void *const s__, "\
                    "void const *const p__) ;\n"
            }
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc storageDeclarations {} {
    variable domain
    set result {}

    set cpops [pipe {
        FindNonUnionSubclasses $domain |
        findRelated % R104 {~R101 ElementPopulation} {~R105 ClassPopulation}
    } {} |%]

    if {[isNotEmptyRef $cpops]} {
        append result [comment "Class Instance Storage Forward Declarations"]
        forAllRefs cpop $cpops {
            assignAttribute $cpop {Allocation allocation} {Class className}
            set insts [refMultiplicity [findRelated $cpop ~R102]]
            set total [expr {$allocation + $insts}]
            append result "static "\
                [GetClassProperty $className StorageVariable]\
                "\[[GetClassProperty $className TotalInstance]\] ;\n"
        }
    }

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc iabDefinitions {} {
    variable domain
    set result [comment "Instance Allocation Block Definitions"]

    forAllRefs classRef [FindNonUnionSubclasses $domain] {
        append result [DefineIABMembers $classRef false]
    }

    set unionRefs [pipe {
        UnionSubclass findWhere {$Domain eq $domain} |
        findRelated ~ R47 R40 R41
    }]
    forAllRefs classRef $unionRefs {
        append result [DefineIABMembers $classRef true]
    }

    return $result
}
----

[source,c]
----
<<generation helper commands>>=
proc DefineIABMembers {classRef isUnionSubclass} {
    assignAttribute $classRef {Name className}

    set linkMembers [GetClassProperty $className LinkMembers]
    set linkCount [llength $linkMembers]
    if {$linkCount == 0} {
        set linkOffsets NULL
    } else {
        set linkOffsets ${className}__LINKS
        append result\
            "static MRT_AttrOffset const $linkOffsets\[\] = \{"
        foreach linkMember $linkMembers {
            append result "offsetof\([GetClassProperty $className Declaration],\
                $linkMember\), "
        }
        append result "\} ;\n"
    }

    append result\
        "static MRT_iab const ${className}__IAB = \{\n"

    if {$isUnionSubclass} {
        append result\
            "    .storageStart = NULL,\n"\
            "    .storageFinish = NULL,\n"\
            "    .storageLast = NULL,\n"
    } else {
        set nelements [GetClassProperty $className TotalInstance]
        append result\
            "    .storageStart = &${className}__POOL\[0\],\n"\
            "    .storageFinish = &${className}__POOL\[$nelements\],\n"\
            "    .storageLast = &${className}__POOL\[[expr {$nelements - 1}]\],\n"
    }
    set ctor [pipe {
        findRelated $classRef ~R8 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__CTOR"}
    } {} |%]
    set dtor [pipe {
        findRelated $classRef ~R9 |
        expr {[isEmptyRef %] ? "NULL" : "[readAttribute % Class]__DTOR"}
    } {} |%]
    append result\
        "    .alloc = [expr {[GetClassProperty $className InitialInstance]\
                    + 1}],\n"\
        "    .instanceSize = sizeof\([GetClassProperty $className Declaration]\),\n"\
        "    .construct = $ctor,\n"\
        "    .destruct = $dtor,\n"\
        "    .linkCount = $linkCount,\n"\
        "    .linkOffsets = $linkOffsets\n"\
        "\} ;\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc edbDefinitions {} {
    variable domain
    set result [comment "Event Dispatch Block Definitions"]

    upvar #0 ::micca::@Gen@::options options

    forAllRefs smodel [StateModel findWhere {$Domain eq $domain}] {
        assignAttribute $smodel {Model className}

        append result [GenerateTransitionTable $smodel]
        append result [GenerateActivityTable $smodel]
        set termstates [GenerateTerminalStates $smodel result]

        if {![dict get $options nonames]} {
            append result [GenerateModelNames $smodel]
        }

        append result "static MRT_edb const ${className}__EDB = \{\n"

        set stateRefs [findRelated $smodel ~R55]
        set cstateRef [findRelated $smodel ~R56]
        append result\
            "    .stateCount = [expr {[refMultiplicity $stateRefs] +\
                [refMultiplicity $cstateRef]}],\n"

        set eventRefs [findRelated $smodel ~R87]
        append result\
            "    .eventCount = [refMultiplicity $eventRefs],\n"\
            "    .initialState = [readAttribute [findRelated $smodel R58 R57]\
                        Number],\n"
        set crstate [expr {[isNotEmptyRef $cstateRef] ?\
            [readAttribute [findRelated R57] Number] : "MRT_StateCode_IG"}]
        append result\
            "    .creationState = $crstate,\n"\
            "    .transitionTable = ${className}__TTAB,\n"\
            "    .activityTable = ${className}__ATAB,\n"\
            "    .terminalStates = $termstates,\n"

        if {![dict get $options nonames]} {
            append result\
                "    .stateNames = ${className}__SNAMES,\n"\
                "    .eventNames = ${className}__ENAMES,\n"
        }

        append result\
            "\} ;\n"
    }

    return $result
}
----

typedef struct mrteventdispatchblock {
    MRT_DispatchCount stateCount ;
    MRT_DispatchCount eventCount ;
    MRT_StateCode initialState ;
    MRT_StateCode creationState ;
    MRT_StateCode const *transitionTable ;
    PtrActivityFunction const *activityTable ;
    bool const *terminalStates ;

#       ifndef MRT_NO_NAMES
    char const *const *stateNames ;
    char const *const *eventNames ;
#       endif /* MRT_NO_NAMES */
} MRT_edb ;


[source,c]
----
<<generation code commands>>=
proc GenerateTransitionTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        findRelated $smodel ~R55 |
        deRef % |
        relation rename % Name State |
        relation eliminate % Activity IsTerminal PSigID
    } {} |%]
    set cstate [pipe {
        findRelated $smodel ~R56 |
        deRef % |
        relation rename % Name State
    } {} |%]
    set states [relation union $states $cstate]
    # puts [relformat $states states]

    set events [pipe {
        findRelated $smodel ~R87 |
        deRef %
    } {} |%]
    # puts [relformat $events events]

    set alltrans [relation join $states $events]
    # puts [relformat $alltrans alltrans]

    set statetrans [pipe {
        StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation eliminate ~ ASigID
    }]
    # puts [relformat $statetrans statetrans]
    set nontrans [pipe {
        Non-StateTransition findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ TransRule NewState
    }]
    # puts [relformat $nontrans nontrans]

    set deftrans [pipe {
        TransitionPlace findAll |
        deRef ~ |
        relation minus $alltrans ~ |
        relation join ~ [deRef [StateModel findAll]] |
        relation eliminate ~ InitialState |
        relation rename ~ DefaultTrans NewState |
        relation update ~ dttup {[tuple extract $dttup State] eq "@"} {
                tuple update $dttup NewState CH}
    }]
    # puts [relformat $deftrans deftrans]

    set ntstates [pipe {
        TransitionRule findAll |
        deRef ~ |
        relation rename ~ Name State |
        relation extend ~ nttup\
            Domain string {$domain}\
            Model string {$className}\
            StateNumber string {"MRT_StateCode_[tuple extract $nttup State]"}
    }]
    # puts [relformat $ntstates ntstates]

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation rename ~ Name State Number StateNumber |
        relation union ~ $ntstates
    }]
    # puts [relformat $places places]
    set transitions [pipe {
        relation union $statetrans $nontrans $deftrans |
        relation join ~ $places\
            -using {Domain Domain Model Model NewState State} |
        relation rename ~ StateNumber NewStateNumber |
        relation join ~ $places |
        relation tag ~ EventNumber -ascending Event |
        relation eliminate ~ Domain Model
    }]
    # puts [relformat $transitions transitions]

    set result "static MRT_StateCode const ${className}__TTAB\[\] = \{\n"
    relation foreach transition $transitions\
            -ascending {StateNumber EventNumber} {
        relation assign $transition
        append result "    $NewStateNumber, // $State - $Event -> $NewState\n"
    }
    append result "\} ;\n"

    return $result
}
----

[source,c]
----
<<generate command tests>>=
test codegen-12.0 {
    Generated code file with state model
} -setup {
    # makeFile {} codegen12.h
    # makeFile {} codegen12.c
    micca configure {
        domain codegen12 {
            class X {
                attribute color int -default 20

                statemodel {
                    state s1 {} {
                        printf("In s1\n") ;
                    }
                    transition s1 - e1 -> s2

                    state s2 {} {
                    }
                    transition s2 - e1 -> IG
                    transition s2 - e2 -> s3

                    state s3 {} {
                    }
                    transition s3 - e3 -> s1

                    terminal s3
                }
            }
        }
        population test codegen12 {
            class X {
                instance x1
            }
        }
    }
} -cleanup {
    cleanupDomain
} -body {
    micca generate
    testConditions\
        {[llength [fileutil::grep {X__TTAB} codegen12.c]] == 2}\
        {[llength [fileutil::grep {X__ATAB} codegen12.c]] == 2}
} -result {1}
----

[source,c]
----
<<generation code commands>>=
proc GenerateActivityTable {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set result "static PtrActivityFunction const ${className}__ATAB\[\] = \{\n"

    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name Activity
            if {$Activity eq {}} {
                append result "    NULL, // $Name\n"
            } else {
                append result "    ${className}_${Name}__ACTIVITY, // $Name\n"
            }
        } else {
            set cstate [relation semijoin $place $::Micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    NULL, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateTerminalStates {smodel resultVar} {
    set tstates [findRelatedWhere $smodel ~R55 {$IsTerminal}]
    if {[isEmptyRef $tstates]} {
        return NULL
    }
    upvar 1 $resultVar result
    variable domain
    assignAttribute $smodel {Model className}
    set places [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static bool const ${className}__TSTATES\[\] = \{\n"
    relation foreach place $places -ascending Number {
        set state [relation semijoin $place $::micca::State]
        if {[relation isnotempty $state]} {
            relation assign $state Name IsTerminal
            append result "    "\
                [expr {$IsTerminal ? "true" : "false"}]\
                ", // $Name\n"
        } else {
            set cstate [relation semijoin $place $::Micca::CreationState]
            if {[relation isnotempty $cstate]} {
                append result "    false, // [relation extract $cstate Name]\n"
            }
        }
    }

    append result "\} ;\n"
    return ${className}__TSTATES
}
----

[source,c]
----
<<generation code commands>>=
proc GenerateModelNames {smodel} {
    variable domain
    assignAttribute $smodel {Model className}

    set states [pipe {
        StatePlace findWhere {$Domain eq $domain && $Model eq $className} |
        deRef ~
    }]

    append result "static char const * const ${className}__SNAMES\[\] = \{\n"
    relation foreach state $states -ascending Number {
        relation assign $state Name
        append result "    \"$Name\",\n"
    }
    append result "\} ;\n"

    set events [pipe {
        TransitioningEvent findWhere\
                {$Domain eq $domain && $Model eq $className} |
        deRef ~ |
        relation tag ~ Number -ascending Event
    }]

    append result "static char const * const ${className}__ENAMES\[\] = \{\n"
    relation foreach event $events -ascending Number {
        relation assign $event Event
        append result "    \"$Event\",\n"
    }
    append result "\} ;\n"

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc pdbDefinitions {} {
    variable domain
    set result [comment "Polymorphic Event Dispatch Block Definitions"]

    return $result
}
----

[source,c]
----
<<generation code commands>>=
proc relationshipDefinitions {} {
    variable domain
    set result [comment "Relationship Description Definitions"]

    return $result
}
----

== Helper Commands

[source,c]
----
<<generation helpers namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>

    namespace path {
        ::micca
        ::rosea::InstCmds
    }

    <<generation helper data>>
    <<generation helper commands>>
}
----

[source,c]
----
<<generation helper commands>>=
proc banner {} {
    string cat\
        "/*\n"\
        " * [string repeat - 70]\n"\
        " * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.\n"\
        " * Created by: $::argv0 $::argv\n"\
        " * Created on: [clock format [clock seconds]]\n"\
        " * This is micca version $::micca::version\n"\
        " * [string repeat - 70]\n"\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
proc comment {c} {
    string cat\
        "/*\n"\
        [::textutil::adjust::indent [::textutil::adjust::adjust $c] " * "]\n\
        " */\n"
}
----

[source,c]
----
<<generation helper commands>>=
# Remove extraneous blanks from the beginning of lines of code
# if so requested by the options.
proc indentCode {code {indent 4}} {
    return [textutil::adjust::indent [textutil::adjust::undent $code]\
            [string repeat { } $indent]]\n
}
----

== Interfacing Domain Code to the Run Time

Interfacing Domain Code to the Run Time
