// vim:set syntax=asciidoc:

= Runtime Support

[partintro]
.Runtime Support
--
In the previous part of the book,
we described the domain specific language (DSL) that is used to
describe a domain to `micca`.
From that description,
code is generated and the generated code targets the run time
environment that is explained in this part of the book.

When translating an executable model,
parts of the model can be mapped directly onto the implementation language.
For example in a `micca` translation,
class instances are referred to using a ``C'' pointer to the instance
memory.
This allows attribute access by simple indirection on the pointer,
_e.g._ for a state activity, `self->Temp = 27`, can be used to update the
`Temp` attribute of the instance.

Other aspects of mapping model execution to the implementation are not
directly supported in the implementation language.
Perhaps the best example is execution of a state model.
There is no intrinsic support for state machines in the ``C'' language.
To dispatch events to state machines requires that we write additional
``C'' code to implement the execution rules of Moore state machines.
We will gather that code into ``C'' functions and the functions will require
data that must be structured in a particular way.

This part of the book is primarily concerned with showing those functions
and data structures.
Taken together,
they define the details of how execution happens in a `micca` translated
domain.
We have purposely chosen a simple scheme of execution, namely,
single threaded and event driven with callbacks to handle the specific
computations.
This choice enables this translation scheme to be used in small,
embedded, ``bare metal'' computing technology.
We will also produce a flavor of the run time that can execute in a POSIX
environment.
This will allow us to target POSIX,
if that is appropriate to the application,
and also to use POSIX as a simulation environment for testing an embedded
system.
This turns out to be very useful since debugging and other facilities
tend to be much richer in the POSIX world than in the bare metal embedded
world.

Once we know how to interface to the run time code,
we can show the code generation that takes the platform model data and
converts it to ``C'' code.
That is the subject of the next part of the book.
--

== Introduction

To start,
we want to enumerate the characteristics of `micca` run time architecture.

* The implementation language is ``C''.
* All data is held in primary memory.
* All classes and other resources are allocated fixed size memory pools
whose size is known at compile time. There is no use of a system heap
by the run time code.
* The address in memory of a class instance serves as an architecturally
generated identifier for the instance and we use that identifier execlusively
in the interfaces of the run time code.
* Execution is single threaded. There is no notion of _task_ or _process_
or _thread_ as those terms are usually defined for computer operating systems.
There is no notion of processor context, context switching or process
preemption.
* The only support for asynchronous execution is that of an interrupt.
Facilities are provided to allow interrupt service code to synchronize
to the running background.
There is no notion of semiphores, condition variables or any other
mutual exclusion locking scheme other than that required for interrupts.
* The execution pattern is event driven with callbacks that run to completion
and perform the required computation.
Given the single threaded nature of sequencing execution,
callbacks that run for longer than the desired response latency time of the
system can be problematic.
This scheme is targeted at applications that are _reactive_ in nature,
sensing external stimulus and responding to that stimulus,
and _not_ long-running computationally intensive transformations.
The execution scheme is very similar to that used for most graphical
user interface applications.
* There is no notion of event priority.
Events are dispatched in the order they are signaled.
There is, however, a notion of thread of control and threads of control
have an implicit relationship with transactions on the domain data.
* Referential integrity is enforced at the end of each thread of control.
This implies that any changes in the stored data for relationships is
verified against the constraints implied by the relationship
conditionality and multiplicity.
* Some of the constructs for the run time depend upon the target processor.
We will show three implementations, namely, the ARM V7-M architecture,
the TI MSP430 architecture and the POSIX architecture.

As we have said before,
this execution scheme is _not_ intended for all applications.
The computational demands of some applications are such that the
single threaded, event driven, callback nature is simply inappropriate
and another execution scheme should be used.
However,
for a large class of applications,
this scheme works very well and has many advantages in terms of simplicity
and the lack of shared state information between concurrent execution
threads.

== The Main Program

In ``C'',
execution begins with the function called, `main`.
`Micca` does _not_ provide this function.
Each system will have to construct a custom `main` function.
The goals of this function are to perform any required initialization
and then to enter the event loop.
Below we show an outline of what a `main` function would do.
The only hard and fast requirements are that `mrt_Initialize` must be called
before any run time facilities are used and `mrt_EventLoop` must
be invoked to cause the system to run.

[source,c]
----
int
main(void)
{
    /*
     * Hardware and other low level system initialization is usually done
     * first.
     */

    /*
     * Initialize the run time code itself.
     */
    mrt_Initialize() ;

    /*
     * Initialize domains, bridges and any other code that might require access
     * to the facilities of the run time code. Typically, each domain in the
     * system would have an "init()" domain operation and these can be invoked
     * here. Sometimes domain interactions are such that a second round of
     * initialization is required.  Bridges between domains may also require
     * that the initialization for a domain be done before the bridge can be
     * initialized.  Since the run time initialization has been done by this
     * point, domains may generate events and do other model level activities.
     * Regardless of how the initialization is accomplished, it is system
     * specific and, unfortunately, only temporally cohesive.
     */

    /*
     * Entering the event loop causes the system to dispatch events.
     */
    mrt_EventLoop() ;
}
----

=== Event Loop

To a first approximation,
the run time event loop is an infinite loop.
Most applications will enter the event loop after their initialization
phase and remain there forever.
However,
testing and other considerations mean that at times we will want to exit the
event loop to gain control of the program.

(((micca,Run Time,mrt_EventLoop)))
[source,c]
----
<<mrt external interfaces>>=
extern void mrt_EventLoop(void) ;

<<mrt external functions>>=
void
mrt_EventLoop(void)
{
    for (exitEventLoop = false ; !exitEventLoop ;
            exitEventLoop = false) {

        if (!mrt_ProcessOneEvent()) {
            mrt_Wait() ;
        }
    }
}
----

As we see,
the flow of control loops,
processing one event at a time as long as it has not been requested to exit the
loop.

Exiting the event loop is controlled by a simple boolean variable.

(((micca,Run Time,exitEventLoop)))
[source,c]
----
<<mrt static data>>=
static bool exitEventLoop ;
----

Rather than expose the variable directly,
we provide a function to set it.
The usual usage for this function is in test code where the main
test application will enter the event loop and some state activity
will execute `mrt_SyncEventLoop()` to return control back to the test
application.
There are other uses.
For example, if the system detects a catastrophic situation,
it may want to exit the event loop and allow the subsequent code to
gracefully bring down the system or force the system to reset.
The exact details are system specific,
but this provides the means to gain control of the run time execution
for exceptional situations.

(((micca,Run Time,mrt_SyncEventLoop)))
[source,c]
----
<<mrt external interfaces>>=
extern bool mrt_SyncEventLoop() ;

<<mrt external functions>>=
bool
mrt_SyncEventLoop(void)
{
    bool exitControl = exitEventLoop ;
    exitEventLoop = true ;
    return exitControl ;
}
----

=== Process a Single Event

A public interface is also provided to process a single event.
This is used by the event loop but can also be invoked on it own.
This is _not_ the recommended mechanism of running a `micca` based
applications, but sometimes it is necessary.
Again,
testing is sometimes best accomplished by letting a test program
control event by event dispatch.
Another use case involves situations where `micca` generated domains
must be integrated with legacy code.
The legacy code will probably have its own execution loop and
we will have to dispatch `micca` events under control of the legacy
execution scheme.
This is not an ideal situation,
but when migrating an older system to a `micca` translated system
a transition period is unavoidable.
We provide the ability to micro-manage the event dispatch with the full
realization that the facility will be abused by some projects.

(((micca,Run Time,mtr_ProcessOneEvent)))
[source,c]
----
<<mrt external interfaces>>=
extern bool mrt_ProcessOneEvent(void) ;

<<mrt external functions>>=
bool
mrt_ProcessOneEvent(void)
{
    <<EventLoop: background sync>>

    return dispatchOneEvent() ;
}
----

The return value for `mrt_ProcessOneEvent` indictes if an event
was actually dispatched.
A return value of `false` indicates that there is no additional work
that needs to be done at this time.

We will discuss the internal logic of processing an event later.
For now, we make two points.

. If interrupts have occurred,
we deal with their background synchronization first and completely.
The exact process to synchronize between interrupts and the background
is processor architecture dependent.
. Only one event is dispatched after synchronizing with interrupts.
Because we deal with all the interrupts before dispatching a single event,
interrupt synchronization has an effective higher priority than event dispatch.

== Managing Data

Before we discuss the details of how execution is sequenced,
we will show how data is managed by the run time.
Execution sequencing is directed at class instances and it will be
helpful to understand how instances are stored before we get to
discussing how they are operated upon.

The run time provides functions to support the basic lifetime of
instances.
We need to be able to:

* Create instances synchronously as part of an activity.
* Create instances asynchronously as part of a event dispatch.
* Delete instances synchronously as part of an activity.
* Delete instances asynchronously when the instance enters a terminal state.

=== Instance Data

The structure of the instances of each class is, in general, different.
However from the point of view of the run time,
instances can be treated the same.
The view of a class instance by the run time is shown below.

[source,c]
----
<<mrt interface data types>>=
typedef struct mrtinstance {
    struct mrtclass const *instClass ;
    AllocStatus alloc ;
    MRT_StateCode currentState ;
} MRT_Instance ;
----

`instClass`::
    A pointer to a class data structure. The class data structure contains
    information that is common to all instances of the class.
`alloc`::
    A value that shows the allocation status of the memory for the instance.
    A value of 0, means the instance memory is not in use and can allocated
    to a new instance.
    A negative value means the memory has been reserved but is not in active
    use.
    A positive value means the memory has been reserved and the instances
    is in active use.
`currentState`::
    For those class that have a state model,
    the `currentState` member holds a small integer number indicating the
    current state in which the instance resides.
    A value of -1 is used to show that the class does not have a state model.

The code generation will facilitate this view of an arbitrary instance
by inserting this structure as the first element of the ``C'' structure
that is generated for each class.
In this manner a pointer to an arbitrary class can be cast to a
pointer to a `MRT_Instance` with impunity.

[source,c]
----
<<mrt interface simple types>>=
typedef short int AllocStatus ;
----

A class instance is mapped onto the element of a ``C'' array.
The size of the array is fixed at compile time.
The `alloc` member of the instance structure is used to keep track of the
status of the array elements as instances are created and deleted at run time.
We will also use this member to track _event in flight_ errors.
We will discuss this more below,
but we need a way to insure that events that have been signaled are not
delivered to instances that have been deleted.

[source,c]
----
<<mrt interface simple types>>=
typedef int8_t MRT_StateCode ;
----

The data type for the `currentState` member is just a small integer.
By specifying 8 bits we limit the number of states of a state model to 127.
That is an enormous number of states for a class state model.
We use negative state numbers to indicate the non-transitioning actions
that may occur when an event is dispatched.

[source,c]
----
<<mrt constants>>=
#define MRT_StateCode_IG    (-1)
#define MRT_StateCode_CH    (-2)
----

=== Class Data

All the behavior of data management and execution sequencing is
completely determined by the values contained in the data structures
supplied to the various functions of the mechanisms.
This is different from some software architecture mechanisms that
use _ad hoc_ generated code from a model compiler to implement
some capabilities.

Since the behavior of all instances of a given class is the same,
each class that requires data management or has execution behavior has a data
structure that contains all the class invariant information.

[source,c]
----
<<mrt interface data types>>=
typedef struct mrtclass {
    struct installocblock *iab ;
    struct objectdispatchblock const *odb ;
    struct polydispatchblock const *pdb ;
} MRT_Class ;
----

`iab`::
    A pointer to an instance allocation block.
    The IAB is used to dynamically allocation class instances.
    For class populations that are static,
    this value is set to `NULL`.
`odb`::
    A pointer to an object dispatch block.
    The ODB is used to dispatch events to a state machine.
    For classes that do not have a state model,
    this value is set to `NULL`.
`pdb`::
    A pointer to a polymorphic dispatch block.
    The PDB is used to dispatch polymorphic events.
    For classes that have no polymorphic events,
    this value is set to `NULL`.

In the next section,
the instance allocation block is described as we continue to define
how data is managed by the run time.
Later, we describe the object dispatch block and polymorphic dispatch
block when we discuss event dispatch.

=== Instance Allocation

There are three ways to create an instance:

. Create an instance as part of an initial instance population.
. Create an instance synchronously to the execution of some activity by invoking
a function.
. Create an instance asynchronously to the execution of some activity by sending
an event.

Creating initial instances is handled during code generation using the
population data specified when the domain is configured.
In this section we are going to discuss synchronous instance creation.
This is instance creation by a direct function invocation and when
the function returns the instance is ready and available.
Later we will discuss asynchronous instance creation which is instance
creation by generating an event.

Instance creation and deletion also supports a very simplified notion of
construction and destruction for the instances.
This is no where near as complicated or full featured as something in C++.
Constructors and destructors take no arguments other than a pointer to the
instance.

[source,c]
----
<<mrt interface data types>>=
typedef void (*InstCtor)(MRT_Instance *) ;
typedef void (*InstDtor)(MRT_Instance *) ;
----

Constructors and destructors are primarily useful for when the instance has a
more complicated data structure as an attribute,
as might be the case if the attribute data type is user defined.
If you need to do complicated construction of instances,
the preferred method is to do that with an instance based operation
or as part of a state activity for an asynchronously created instance.

The instances of a class are contained in a single array variable
which serves as the memory pool for the instances.
To support managing a pool of class instances,
an *Instance Allocation Block*, or *IAB* for short,
data structure is used to keep track of the memory pool.
What we need is a data structure that can find the bounds of the pool.

[source,c]
----
<<mrt interface data types>>=
typedef struct installocblock {
    void *storageStart ;
    void *storageFinish ;
    void *storageLast ;
    AllocStatus allocCounter ;
    size_t instanceSize ;
    InstCtor construct ;
    InstDtor destruct ;
} MRT_InstAllocBlock ;
----

`storageStart`::
    A pointer to the beginning of the memory where the instance storage
    pool is located.
    This is the array allocated to hold the instances of a class.
`storageFinish`::
    A pointer to one element beyond the end of the instance storage pool
    for the class.
    This pointer may not be dereferenced, of course, but provides the
    boundary marker for the end of the pool.
`storageLast`::
    A pointer to the instance that was last allocated. This is used as
    the starting point for allocating the next instance.
`allocCounter`::
    The next value of the allocation counter to be assigned to a newly
    allocated instance.
`instanceSize`::
    The number of bytes of memory occupied by an instance.
`construct`::
    A pointer to a constructor function. If there is no constructor defined
    for the class, then the value of this member may be set to `NULL`.
`destruct`::
    A pointer to a destructor function. If there is no destructor defined
    for the class, then the value of this member may be set to `NULL`.

The underlying allocation algorithm is a simple linear search starting
at the last location that was allocated.

[source,c]
----
<<mrt forward references>>=
static MRT_Instance *mrtInstFindSlot(MRT_Class const *instClass) ;
----

[source,c]
----
<<mrt static functions>>=
static MRT_Instance *
mrtInstFindSlot(
    MRT_Class const *instClass)
{
    assert(instClass != NULL) ;
    MRT_InstAllocBlock *iab = instClass->iab ;
    if (iab == NULL) {
        return NULL ;
    }
    assert(iab->storageLast < iab->storageFinish) ;
    /*
     * Search for an empty slot in the pool. Start at the next location after
     * where we last allocated an instance.
     */
    MRT_Instance *inst ;
    for (inst = mrtInstNext(iab, iab->storageLast) ;
            inst->alloc != 0 && inst != iab->storageLast ;
            inst = mrtInstNext(iab, inst)) {
        // Empty
    }
    /*
     * Check if we ended up on a slot that is not allocated.
     */
    if (inst->alloc != 0) {
        return NULL ; // <1>
    }

    return inst ;

}
----
<1> If we wrap all the way around to where we started and still did not
find an instance storage element whose `alloc` member was zero,
the we have run out of space!
That condition is indicated by returning `NULL`.

Finding the next element in the instance storage array involves
performing the pointer arithmetic modulo the size of the array.
Since the pool is allocated in a contiguous block of memory,
we must wrap around the iterator when it passes the end of the
storage pool.
That is accomplished with the `mrtInstNext()` function.

[source,c]
----
<<mrt forward references>>=
static inline void *mrtInstNext(MRT_InstAllocBlock *iab, void *ptr) ;
----

[source,c]
----
<<mrt static functions>>=
static inline 
void *
mrtInstNext(
    MRT_InstAllocBlock *iab,
    void *ptr)
{
    ptr = (void *)((uintptr_t)ptr + iab->instanceSize) ; // <1>
    if (ptr >= iab->storageFinish) { // <2>
        ptr = iab->storageStart ;
    }
    return ptr ;
}
----
<1> Since the size of instance varies from class to class,
we must take over scaling the pointer arithmetic by the size of the
instance.
<2> Perform the modulus wrap around if we cross over the boundary of
the storage array.

=== Creating an Instance

The function, `mrt_CreateInstance`, is used to synchronously
create an instance of a class.

[source,c]
----
<<mrt external interfaces>>=
extern MRT_Instance *
mrt_CreateInstance(
    MRT_Class const *instClass,
    MRT_StateCode initialState) ;
----

`instClass`::
    A pointer to the class data for the instance to be created.
`initialState`::
    The state number into which the instance will be placed.
    For classes that do not have an associated state model this argument
    is ignored.

[source,c]
----
<<mrt external functions>>=
MRT_Instance *
mrt_CreateInstance(
    MRT_Class const *instClass,
    MRT_StateCode initialState)
{
    assert(instClass != NULL) ;

#       ifndef NDEBUG
    if (instClass->odb) {
        assert(initialState < instClass->odb->stateCount) ;
    }
#       endif /* NDEBUG */

    /*
     * Search for an empty slot in the pool.
     */
    MRT_Instance *inst = mrtInstFindSlot(instClass) ;
    if (inst == NULL) {
        mrtFatalError(mrtNoInstSlot, instClass) ;
    }
    /*
     * Record where we left off for the next allocation attempt.
     */
    MRT_InstAllocBlock *iab = instClass->iab ;
    iab->storageLast = inst ;
    /*
     * Start with a zeroed out memory space.
     */
    memset(inst, 0, iab->instanceSize) ;
    inst->instClass = instClass ;
    /*
     * Mark the slot as in use.
     */
    inst->alloc = mrtIncrAllocCounter(iab) ;
    inst->currentState = instClass->odb ? initialState : MRT_StateCode_IG ; // <1>
    /*
     * Run the constructor if there is one.
     */
    if (iab->construct) {
        iab->construct(inst) ;
    }
    return inst ;
}
----
<1> If a class does not have a state model, then we ignore the
value passed in to the function and set the current state to ignored.
This is a convenient value for such a situation.

One other important point here.
There is a counter in the IAB that is incremented each time an
instance is allocated and this value is used in the `alloc`
member of the instance.
This is another part of the strategy to detect an
_event in flight_ error.
This is described further below.
The effect of running this counter is that every instance gets a
different `alloc` member value (modulo the size of the counter variable)
The increment has one little catch.
The counter is signed and we use the positive and negative values
differently.
Here we want to make sure the value remains positive.


[source,c]
----
<<mrt forward references>>=
static inline AllocStatus mrtIncrAllocCounter(MRT_InstAllocBlock *iab) ;
----

[source,c]
----
<<mrt static functions>>=
static inline 
AllocStatus
mrtIncrAllocCounter(
    MRT_InstAllocBlock *iab)
{
    /*
     * Catch any overflow
     */
    if (++iab->allocCounter < 0) {
        iab->allocCounter = 1 ;
    }
    return iab->allocCounter ;
}
----

=== Deleting an Instance

The function, `mrt_DeleteInst`, is used to synchronously
destroy an instance.

[source,c]
----
<<mrt external interfaces>>=
extern void mrt_DeleteInst(MRT_Instance *inst) ;
----

`inst`::
    A pointer to an instance to be destroyed.

Just as there was a distinction between synchronous and asynchronous
instance creation,
there is a similar distinction for destruction.
Asynchronous destruction happens as a result of an instance entering
an _terminal_ state and that is discussed further below.
Here we are dealing with synchronous destruction of an instance.

[source,c]
----
<<mrt external functions>>=
void
mrt_DeleteInst(
    MRT_Instance *inst)
{
    MRT_InstAllocBlock *iab = inst->instClass->iab ;
    assert(iab != NULL) ;
    /*
     * Run the destructor, if there is one.
     */
    if (iab->destruct) {
        iab->destruct(inst) ;
    }
    /*
     * Mark the slot as free.
     */
    inst->alloc = 0 ;
}
----

Deleting an instance is a very simple matter indeed.
If there is a destructor, it is run.
The slot is free when its `alloc` member has a value of 0.
But beware,
for designs that have complicated relationships among the classes,
instance deletion can be very complicated, requiring much care
that the interdependencies among classes are properly preserved.
That work is not done here!
It is the responsibility of the analysis model to take any actions
necessary to delete an instance and have the data integrity preserved.

== Managing Execution

In this section we discuss the rules and policies associated
with managing the sequencing of execution.
There are two means available to an application to control the
sequencing of execution.

* Invoke an ordinary function.
* Generate an event to the instance of a class.

Not much needs to be said about invoking functions.
Computation transfers to the entry point and runs until the function
is complete, transferring control back to next statement of the caller.
Typically, such functions are organized into those that are associated
with the domain as whole, a particular class or instances of a class.
Such organization may be helpful to the programmer,
but since they are directly supported by the implementation language,
the `micca` run time does not get involved in mediating them.

Where the run time does get involved is for those computation that must leave
off at some point,
waiting for some other action in the system or the external environment,
and then resume execution maintaining the past history.
This type of execution is implemented as a state machine.

=== State Machine Rules

Each class that has lifecycle behavior may have a state model associated
with it and each instance of that class will have a state variable.
The run time supports a Moore type state model.

In the Moore formulation of state models,
action code is associated with states and is executed
upon entry into a state.
This is distinguished from the Mealy formulation where
actions are associated with the transitions and are executed
upon exiting a state.
Much writing and discussion has been wasted attempting to
justify one type of state model over another.
What we know is they are computationally equivalent,
_i.e._ we can prove that there is no problem that you can solve
with a Moore machine that cannot also be solved with a Mealy
machine and _vice versa_.
Whether your application is easier to describe with one type rather
than the other is something that you alone may decide.
Moore machines are the traditional formulation for Executable UML
and they have the simplest implementation structures.
What we specifically reject here is any use of hierarchical state
models.
They are unnecessary and add complication that is not welcome.
The power of computation in Executable UML is derived from the
interaction of simple state machines each of which is tied to the
lifecycle of a particular class.
If you have some state model that is large and complicated where
you think some other kind of higher order structure is needed,
the usual reason is that you have multiple classes masquerading as one
and further refinement of your analysis is necessary.
That is not usually a welcome answer to the problem,
because if the analyst had been able to conceive of a better solution,
he/she would probably already have done so.

Generally, state actions affect other computations in the domain
by updating instance attribute values or by generating events to
other instances.
The important distinction here is that the application code of the
state actions does not deal with actually dispatching the events
nor does it control which event is dispatched next.

=== Event Generation

There are three types of events:

. Transition events that cause transitions in state machines.
. Polymorphic events that are mapped at runtime across a generalization
hierarchy.
. Creations events that support asynchronous instance creation.

Creation events are transition events that are also associated with
an instance creation.
Our strategy for creation events is to create the instance in an inactive
state before queuing the event that will activate the instance and
cause a transition.
We will have need to distinguish between transition events and
polymorphic events and an enumeration will do that.

[source,c]
----
<<mrt interface simple types>>=
typedef enum {
    MRT_TransitionEvent,
    MRT_PolymorphicEvent
} MRT_EventType ;
----

The process of generating an event involves the following steps:
. Obtain an *Event Control Block* (ECB) from the free pool of ECB's.
. Set the values of the fields in the ECB.
. Queue the ECB for later dispatch.

=== Event Control Block

The Event Control Block (ECB) is the primary data structure for generating and
dispatching events.

[source,c]
----
<<mrt interface data types>>=
typedef struct mrtecb {
    struct mrtecb *next ;
    struct mrtecb *prev ;
    MRT_EventCode eventNumber ;
    AllocStatus alloc ;
    MRT_EventType eventType ;
    MRT_Instance targetInst ;
    MRT_Instance sourceInst ;
    MRT_DelayTime delay ;
    alignas(uint64_t) MRT_EventParamType eventParameters ;
} MRT_Ecb ;
----

`next`, `prev`::
    Event queuing is done by doubly linked lists
    and the links are allocated as part of the ECB as the `next` and
    `prev` members.
`eventNumber`::
    The event number.
    Events are also encoded as small zero based sequential integers
    that are unique only within the class to which they are associated.
    Event numbers are ultimately used as an array index.
`alloc`::
    The `alloc` member is yet another part of _event in flight_ detection.
    We will discuss that more below when we discuss event dispatch.
    For now, this member of the ECB holds the value of the allocation
    counter for the instance that is the target of the event.
    So when an event is generated, a copy of the current value of
    the `alloc` member of the instance is stored in the ECB.
`eventType`::
    The `eventType` member describes which of the two
    types of events this ECB is being used for.
`targetInst`::
    A pointer to the instance that is to receive the event.
`sourceInst`::
    A pointer to the instance that is the signaler of the event.
    If the event is generated outside the context of an instance
    (_e.g._ in an domain operation), then this member value is set to `NULL`.
    The `srcInst` member also serves an important role in enforcing the rules
    for delayed events.
    More on that later.
`delay`::
    The number of milliseconds to delay before the event is posted.
`eventParameters`::
    Storage for any parameter values passed along with the event.


Event codes are captured by small integer values.

[source,c]
----
<<mrt interface simple types>>=
typedef uint8_t MRT_EventCode ;
typedef unsigned long int MRT_DelayTime ;
----

Note that there is no notion of priority contained in the ECB.
Some software architectures queue events in a priority order.
That is not supported here.
Frankly, if you need event priorities to make your system work,
then you need to revisit your design or look for a software architecture
that supports multiple threads of execution.

=== Event Parameter Storage

We need to discuss events that carry parametric data and how that will happen.
In this formulation of state machines,
events may carry additional parameters.
Space has to be allocated for that data.
The more difficult issue is to deal with the type of the parameter data.
There are a couple of solutions, neither of which is very satisfying.
We could collect all the parameters from all the state machines
in the system and create a giant union.
This would properly allocate the amount of parameter storage required
and provide a type safe manner to deal with that data.
Unfortunately, the parameters to states are scattered in very many
places in a system and gathering them together is a difficult
undertaking.

Here we take the view of providing some generic parameter fields
with a fixed amount of memory and letting state actions
cast that memory into the appropriate type.
Needless to say, this can also be a source of errors, but is
much easier to manage.
This choice makes sense for many systems.
The number of states that use parametric data is usually small and using a
fixed size works better than might be expected.
The important point here is that events can carry data with them.
Many state machine formulations don't support this
and it is very difficult to correctly manage memory lifetime
without it.
It is one of those things that you might not use very often but
it is difficult to do without when you need it.

We fix the amount of memory used for event parameter storage,
allowing it to be overridden by the compiler command.

[source,c]
----
<<mrt constants>>=
#ifndef MRT_ECB_PARAM_SIZE
#   define MRT_ECB_PARAM_SIZE  16
#endif /* MRT_ECB_PARAM_SIZE */
----

[source,c]
----
<<mrt interface simple types>>=
typedef char MRT_EventParamType[MRT_ECB_PARAM_SIZE] ;
----

State actions may use the fields in the above union,
or cast the whole thing to a type they like better.
It is necessary that the code that generates the
event and the code that consumes the event
have the same idea of how the data will be treated.

== Foreground / Background Synchronization

[source,c]
----
<<EventLoop: background sync>>=
#   ifndef __ARM_ARCH_7M__
while (invokeOneSyncFunc()) {
    ; /* empty */
}
#   endif
----

=== Dispatching Synchronization Functions

[source,c]
----
<<mrt sync components interface>>=
static inline bool invokeOneSyncFunction(void) ;

<<mrt sync components>>=
static inline bool
invokeOneSyncFunction(void)
{
    bool didOne ;

    FgSyncBlock blk = syncQueueGet() ;
    if (blk != NULL && blk->function != NULL) {
        blk->function(&blk->params) ;
        didOne = true ;
    } else {
        didOne = false ;
    }

    return didOne ;
}
----

[source,c]
----
<<ARM 7M components>>=
void
PendSV_Handler(void)
{
    for (FgSyncBlock *blk = syncQueueGet() ; blk != NULL ; blk = syncQueueGet()) {
        if (blk->function) {
            blk->function(&blk->params) ;
        }
    }
}
----

== Error Handling

Until now we have glossed over the subject of how to handle errors
in the software mechanisms.
In XUML,
the domains assume a perfect architecture in the sense that
no formal mechanism is provided to signal architectural errors back to
the application domains.
This makes sense because the application models are meant to be implementation
independent and able to be run on a variety of underlying mechanisms.
However,
an error policy, in much the same terms as data and execution policies,
must be put into place.
The details of the error handling policy will vary between
software architectures, so it is important to state them clearly.
For the `micca` run time, the following principles guide error handling.

* To that extent possible, the mechanisms operations should not report
errors back to the application.
For implementation languages that do not support exception handling,
the usual technique of returning error codes is not very effective.
Either by accident or sloth, many error codes are not checked.
Even then the error code is checked, there is little recovery
recourse for the application.
For example,
it does little good to know that we are unable to generate an
event because we do not have sufficient ECB resources when there
is nothing a state action can do to free up the required resources.
* 
Errors that result from exhausted resources or analysis errors
detected at run time are *fatal*.
Exactly how fatal errors are acted upon is platform dependent and may
result in terminating a program or completely resetting the system.
Regardless of the consequence of a fatal error, the assumption is
that the program can no longer continue to run.

With these principles in mind, we define a set of error conditions
that are detected by the mechanism.
All these conditions are fatal and are handled by invoking a fatal
error handler.

[source,c]
----
<<mrt interface simple types>>=
typedef enum {
    mrtCantHappen = 1,
    mrtEventInFlight,
    mrtNoECB,
    mrtNoInstSlot,
    mrtSyncOverflow,

#       ifdef POSIX
    mrtTimerOpFailed,
    mrtSignalOpFailed,
    mrtSelectWaitFailed,
#       endif /* POSIX */
} MRT_ErrorCode ;
----

We will need a string representation of the error codes to
make human readable messages.

[source,c]
----
<<mrt static data>>=
static char const * const errMsgs[] = {
    "no error",     /* place holder */
    "can't happen transition: %p: %u - %u -> CH\n",
    "event in flight error: %p -> %p %u\n",
    "no available Event Control Blocks\n",
    "no available instance slots: %p\n",
    "synchronization queue overflow\n",

#       ifdef POSIX
    "interval timer operation failed: %s\n",
    "signal operation failed: %s\n",
    "blocking on pselect() failed: %s\n",
#       endif /* POSIX */
} ;
----

Everywhere else the mechanisms operations have been crafted to
avoid error possibilities.
For example, as discussed in delayed event generation,
we interpret the attempt to generate a duplicate delayed event
as wishing to cancel the existing one and instantiate a new one.
This semantic interpretation avoids generating an error and avoids
all the additional code require in state actions that generate
delayed events.

Exactly how fatal errors are handled will depend upon the specifics
of how the platform handles errors.
We define an interface for a fatal error handler.

[source,c]
----
<<mrt interface data types>>=
typedef void (*MRT_FatalErrHandler)(MRT_ErrorCode, char const *, va_list) ;
----

The interface is patterned after `vprintf`,
giving a format string and a pointer to a variable length argument list.

[source,c]
----
<<mrt forward references>>=
static void
mrtDefaultFatalErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list ap) ;
----

The system provides a default fatal error handler.
Assuming that standard I/O is included, we print a message to the
standard error.

[source,c]
----
<<mrt static functions>>=
static void
mrtDefaultFatalErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list ap)
{
    vfprintf(stderr, errMsgs[errNum], ap) ;
}
----

A pointer to the fatal error handler is initialized with the default one.

[source,c]
----
<<mrt static data>>=
static MRT_FatalErrHandler mrtErrHandler = mrtDefaultFatalErrorHandler ;
----

Because fatal error handling is usually so platform specific and
because of the need to test fatal error paths,
we provide the ability to delegate the consequence of the
fatal error.

[source,c]
----
<<mrt external interfaces>>=
extern MRT_FatalErrHandler
mrt_SetFatalErrHandler(
    MRT_FatalErrHandler newHandler) ;
----

[source,c]
----
<<mrt external functions>>=
MRT_FatalErrHandler
mrt_SetFatalErrHandler(
    MRT_FatalErrHandler newHandler)
{
    MRT_FatalErrHandler prevHandler = mrtErrHandler ;
    if (newHandler) {
        mrtErrHandler = newHandler ;
    }
    return prevHandler ;
}
----

The mechanisms internally call `mrtFatalError`.
This function is presented next.

[source,c]
----
<<mrt static functions>>=
static void
mrtFatalError(
    MRT_ErrorCode errNum,
    ...)
{
    va_list ap ;
    /*
     * All hope is lost here. Make sure we don't
     * execute any asynchronous code.
     */
    // beginCriticalSection() ;

    assert(mrtErrHandler != NULL) ;
    assert(errNum < COUNTOF(errMsgs)) ;

    va_start(ap, errNum) ;
    mrtErrHandler(errNum, errMsgs[errNum], ap) ;
    /*
     *  If the handler does return, we insist that all errors
     *  are fatal. So we abort().
     */
    abort() ;
}
----

As we see in the code,
we insist that there is an error handler.
There is always the default one and a different handler can be specified
if necessary.
Finally,
`abort()` is called should the error handler return.

== Avoiding Fatalities

In this error handling strategy,
every mechanism detected error is fatal.
Although the details of the processing for fatal errors can be delegated,
in most systems of the class we consider here,
fatal errors usually result in a system reset.
Under the vast majority of circumstances,
that is the desired behavior.
However,
there are some particular circumstances where causing a fatal
error is not the desired behavior.

Consider the case where some external stimulus results in an event
being generated.
If the stimulus occurs more frequently than events can be processed,
then the mechanisms will run out of event control blocks causing a
fatal error.
As an example,
consider the arrival of a communications packet.
If somewhere during the processing of the packet an event is generated,
then if packets arrive too fast a fatal error can be generated.
In effect it would provide a means for an external stimulus to cause the
system to crash.
Certainly for the case of a communications packet,
the preferred behavior would be to drop the packet and let higher level
protocol deal with the necessary retries, etc.
It is then necessary to be able to determine if generating an event
would be successful.

In this section we describe functions that can be used to avoid mechanisms
requests that would exhaust an underlying resource and therefore
cause a fatal system error.
It should be emphasized that these functions are *not*
intended for ordinary or casual use.
Under the vast majority of circumstances,
such as when one state machine generates an event to another state
machine,
event generation and other such activities should continue to assume
that there are no resources that can be consumed.
System analysis and testing should then determine the appropriate sizing
for the various resource pools.
The capability described in this section is to handle unusual and
extraordinary circumstances where hardware failure or failure to
abide by communications protocols could force the system into a
fatal error situation.

Note also that the alternative provided here causes the external stimulus
that would cause the fatal error condition effectively to be ignored.
For some system requirements that is not an acceptable solution.
For example,
consider a digital input line that is used to generate an interrupt
and that interrupt signals an external condition monitored by hardware,
say the maximum extent of motion of physical robot arm.
If this interrupt arrives at a very fast rate,
one might conclude the hardware has failed.
Ignoring the interrupt might do little other than mask a problem that should
cause a fatal error condition and potentially reset the system.
The conclusion is that providing a means of avoiding fatal error conditions
is not intented to serve as an overall error handling policy.
Careful analysis and consideration is still required.
If an interrupt arrives faster than expected and,
because of what the interrupt represents, it cannot be ignored,
that fact and the response to it must be deduced by the interrupt service
code (_e.g._ by determining the interrupt frequency) and actions
appropriate to the system must be taken.
It can be a difficult problem to solve and the functions provided here
are too generic to be of much help.

There are three internal mechanisms resources that can be exhausted.
* Class instances can be dynamically created and each class has its own instance
pool.
* Event control blocks are used for generating and dispatching state machine
events.
* The foreground / background synchronization queue has a fixed number
of slots and excessive synchronization requests from interrupt service
routines can fill the queue.

=== Checking for Available Instance Space

[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_InstanceAvailable(
    MRT_Class const *instClass) ;
----

`instClass`::
    A pointer to the class data for which the space check is made.

[source,c]
----
<<mrt external functions>>=
bool
mrt_InstanceAvailable(
    MRT_Class const *instClass)
{
    assert(instClass != NULL) ;

    /*
     * Search for an empty slot in the pool.
     */
    return mrtInstFindSlot(instClass) != NULL ;
}
----

=== Checking for Event Blocks

[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_EventAvailable(void) ;
----

[source,c]
----
<<mrt external functions>>=
bool
mrt_EventAvailable(void)
{
    return !eventQueueEmpty(&freeEventQueue) ;
}
----

== Code Organization

[source,c]
----
<<mrt_interface.h>>=
/*
<<copyright info>>
*/

#ifndef MRT_INTERFACE_H_
#define MRT_INTERFACE_H_

/*
 * Standard Includes
 */
<<standard includes>>

/*
 * Constants
 */
<<mrt constants>>

/*
 * Data Types
 */
<<mrt interface simple types>>
<<mrt interface data types>>

/*
 * External Functions
 */
<<mrt external interfaces>>

#endif /* MRT_INTERFACE_H_ */
----

[source,c]
----
<<standard includes>>=
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdalign.h>
----

[source,c]
----
<<common includes>>=
#include <string.h>
#include <assert.h>
#include "mrt_interface.h"
----

[source,c]
----
<<mrt_arm7m.c>>=
/*
<<copyright info>>
*/

<<common includes>>
----

[source,c]
----
<<mrt_msp430.c>>=
/*
<<copyright info>>
*/

<<common includes>>
----

[source,c]
----
<<mrt_posix.c>>=
/*
<<copyright info>>
*/

<<common includes>>

#ifndef COUNTOF
#define COUNTOF(a)  (sizeof(a) / sizeof(a[0]))
#endif /* COUNTOF */

/*
 * Data Types
 */
<<mrt implementation simple types>>
<<mrt implementation data types>>

/*
 * Forward References
 */
<<mrt forward references>>

/*
 * Static Data
 */
<<mrt static data>>

/*
 * Static Functions
 */
<<mrt static functions>>

/*
 * External Functions
 */
<<mrt external functions>>
----
