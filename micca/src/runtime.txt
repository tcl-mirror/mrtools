// vim:set syntax=asciidoc:

= Runtime Support

[partintro]
.Runtime Support
--
In the previous part of the book,
we described the domain specific language (DSL) that is used to
describe a domain to `micca`.
From that description,
code is generated and the generated code targets the run-time
environment that is explained in this part of the book.

When translating an executable model,
parts of the model can be mapped directly onto the implementation language.
For example in a `micca` translation,
class instances are referred to using a ``C'' pointer to the instance
memory.
This allows attribute access by simple indirection on the pointer,
_e.g._ for a state activity, `self->Temp = 27`, can be used to update the
`Temp` attribute of the instance.

Other aspects of mapping model execution to the implementation are not
directly supported in the implementation language.
Consider the execution of a state model.
There is no intrinsic support for state machines in the ``C'' language.
To dispatch events to state machines requires that we write additional
``C'' code to implement the execution rules of Moore state machines.
We will gather that code into ``C'' functions and the functions will require
data that must be structured in a particular way.

This part of the book is primarily concerned with showing the functions
and data structures required to map model execution rules onto the
implementation.
Taken together,
they define the details of how execution happens in a `micca` translated
domain.
We have purposely chosen a simple scheme of execution, namely,
single threaded and event driven with callbacks to handle the domain specific
computations.
This choice enables this translation scheme to be used in small,
embedded, ``bare metal'' computing technology.
We will also produce a flavor of the run-time that can execute in a POSIX
environment.
This will allow us to target POSIX,
if that is appropriate to the application,
and also to use POSIX as a simulation environment for testing an embedded
system.
This turns out to be very useful since debugging and other facilities
tend to be much richer in the POSIX world than in the bare metal embedded
world.

Once we know how the functions and data structures of the run-time code
operate,
we can show the code generation that takes the platform model data and
converts it to ``C'' code.
That is the subject of the next part of the book.
--

== Introduction to the Micca Run Time

To start,
we enumerate the characteristics of the
computing technology targeted by the `micca` run-time.

* The implementation language is ``C''.
* All data is held in primary memory and no automatic persistence
of data to external storage is provided.
* All classes and other resources are allocated fixed size memory pools
whose size is known at compile time.
The run time code does not perform any dynamic memory allocation from
a system heap (_e.g._ no calls to `malloc`).
* The address in memory of a class instance serves as an architecturally
generated identifier for the instance and we use that identifier exclusively
in the interfaces of the run-time code.
* No other constraints on the identification of class instances is provided,
particularly, no enforcement of uniqueness based on attribute values is
provided by the run-time.
Translations are strongly encouraged to provide such enforcement,
especially when the identifying attribute values are obtained from
outside of a domain.
* The only support for asynchronous execution is that of an interrupt.
Facilities are provided to allow interrupt service code to synchronize
to the running background.
There is no notion of semaphores, condition variables or any other
mutual exclusion locking scheme other than that required to prevent
interrupts from executing during small critical sections of code
involving a single data structure.
* Background execution is single threaded.
There is no notion of _task_ or _process_ or _thread_ as those terms are
usually defined for computer operating systems.
There is no notion of processor context, context switching or process
preemption.
All execution is run-to-completion except as preempted by interrupts.
* The execution pattern is event driven with callbacks that run to completion
and perform the required computation.
Given the single threaded nature of sequencing execution,
callbacks that run for longer than the desired response latency time of the
system can be problematic.
This scheme is targeted at applications that are _reactive_ in nature,
sensing external stimulus and responding to that stimulus,
and _not_ long-running computationally intensive transformations.
The execution scheme is very similar to that used for most graphical
user interface applications.
* There is no notion of event priority.
Events are dispatched in the order they are signaledfootnote:[With the
exception that self directed events are dispatched before
non-self directed ones.
However, this is one of the prescribed execution rules of state models.].
* Events are dispatched within the context of a _thread of control_.
Threads of control have an direct correllation with transactions on the domain
data.
* Referential integrity is enforced at the end of each data transaction.
This implies that any changes in the stored data for relationships is
verified against the constraints implied by the relationship
conditionality and multiplicity.
Referential integrity is evaluated whenever there has been any change
in class instances or relationship instances during a thread of control.
* Some of the constructs for the run-time depend upon the target processor.
We will show three implementations, namely, the ARM(R) V7-M architecture,
the TI(R) MSP430 architecture and the POSIX architecture.

As we have said before,
this execution scheme is _not_ intended for all applications.
The computational demands of some applications are such that the
single threaded, event driven, callback nature is simply inappropriate
and another execution scheme should be used.
However,
for a large class of applications,
this scheme works very well and has many advantages in terms of simplicity
of the implementation
and the lack of shared information between concurrent execution threads.

=== Limitation of the Run Time

Although `micca` supplies everything needed to sequence execution and
manage model data,
there are several other components of a target platform that are *not*
supplied by `micca`.
Notably:

* Exception handling is very system specific.
The details of how processor exceptions are handled must be supplied by
the project.
The run-time provides the means to synchronize between exceptions and the
background processing but nothing else.
* The run-time requires access to some type of timing resource.
The interface to the timing resource is well defined but
projects will have to supply code to manipulate the timing resource.
Typically in an embedded context, a hardware timer is used.
For a POSIX environment,
code is included to time delayed event dispatch using `SIGALRM`.
* No support is provided to obtain the current time of day.
Many embedded platforms have no timing facilities.
If time of day is important to your project,
then hardware should provide some battery backed up time of day
clock hardware or you will have to provide some timing resource
from which the time of day can be deduced.
* Access to hardware can require significant effort to implement.
Projects are strongly encouraged *not* to access hardware directly
from domain models.
Direct hardware access limits the ability of the model to be run
in a different environment for simulation and debugging.
Rather, a well defined hardware access layer should be put into place
and external operations defined by the domain models expressing
their hardware access dependencies.
Then bridging code may be created to map from the external operations
of the domain to the hardware access layer.
This scheme is *not* supplied by `micca` and projects will have to
create the hardware access to provide a complete target platform.
* The `micca` run-time provides simple linear iteration techniques for
access to class instances and to navigate relationships.
These simple techniques work well in many circumstances,
but when the number of class instances is large other types of searching
will be desired.
`Micca` does not supply any techniques for hashing, binary searches,
creating and maintaining indices or
any of the many other ways that a class instance may be located.
If these techniques are required for a particular domain,
projects will have to supply their own code to accomplish it.
Such code is not difficult to use in the `micca` environment since
you have direct access to the code for the activities, but it
is not supplied.
`Micca` does guarantee the ordering of initial instances in the class storage
pool,
so often a binary search using the standard ``C'' library function, `bsearch`,
will suffice if initial instances are defined in a sorted order.

=== Conditional Compilation

The run-time support the following ``C'' preprocessor symbols:

[IMPORTANT]
It is important the code files for the run-time and all the domains that
constitute an application be compiled with the same set of preprocessor
symbol definitions.

`NDEBUG`::
    The run-time uses the standard `assert` macro and the assertions may
    be removed by defining this symbol.
`__ARM_ARCH`::
    Defining this symbol to be `7` compiles in the ARM Version 7 architecture
    specific code for executing sync requests from the foreground.
    This symbol is defined automatically by most compilers when compiling
    for armv7 architectures.
`MRT_NO_NAMES`::
    If defined, this symbol will exclude naming information about classes,
    relationships and other domain entities from being compiled in.
    For small memory systems,
    strings can consume a considerable amount of space and are usually
    only used during debugging.
`MRT_NO_TRACE`::
    Defining this symbol removes code from the run-time that traces
    event dispatch.
    Event dispatch tracing is important during testing and debugging but
    may be removed from the delivered system.
`MRT_NO_STDIO`::
    Defining this symbol insures that `stdio.h` is not included and
    no references are made to functions in the standard I/O library.
    This is useful for smaller embedded systems that cannot support
    the memory required by the standard I/O library.
`MRT_TRANSACTION_SIZE`::
    The value of this symbol sets the maximum number of relationships
    that can be modified during a data transaction.
    The default value is 64.
`MRT_EVENT_POOL_SIZE`::
    The value of this symbol sets the number event control blocks which
    are used for signaling events.
    The default value is 32.
    This number represents the maximum number of signaled events that
    may be _in flight_ at the same time.
`MRT_ECB_PARAM_SIZE`::
    This value of this symbol set the maximum number of bytes that can
    be occupied by event parameters or sync function parameters.
    The default value is 32.
`MRT_SYNC_QUEUE_SIZE`::
    The value of this symbol defines the maximum number of synchronization
    requests from the foreground processing that may be outstanding
    at the same time.
    The default value is 10.
    This symbol represent the number of interrupts that may occur during
    the execution of a state activity.
`MRT_INSTANCE_SET_SIZE`::
    The value of this symbol is the maximum number of instance references
    that may be held in an instance reference set.
    The default value is 128.
`MRT_INSTRUMENT`::
    Defining this symbol includes code to print the function name, file name
    and line number for all functions generated by the code generator.
    This information forms a trace of executed functions.
`MRT_INSTRUMENT_ENTRY`::
    Defining this symbol can override the code that is placed at the
    beginning of each generated function for instrumentation. By default
    when `MRT_INSTRUMENT` is defined the following code is placed at
    the entry of each generated function:
    +
......
    printf("%s: %s %d\n", __func__, __FILE__, __LINE__) ;
......
`MRT_DEBUG(...)`::
    The `MRT_DEBUG` macro has the same invocation interface as
    `printf()`.  If `MRT_INSTRUMENT` is defined, then `MRT_DEBUG`
    invocations will include the implied `printf` invocations.
    Otherwise, the implied `printf` invocations are removed from the code
    (_i.e._ `MRT_DEBUG` is defined as empty).
    If `MRT_INSTRUMENT` is defined, then the expansion of `MRT_DEBUG`
    may be overridden.

== The Main Program

In ``C'',
execution begins with the function called, `main`.
`Micca` *does not provide* this function.
Each application will have to construct a custom `main` function.
The goals of `main` are to perform any required initialization
and then to enter the event loop.
Below we show an outline of what a `main` function would do.

(((micca,Run Time Function,main)))
[source,c]
----
int
main(
    int argc,
    char *argv[])
{
    /*
     * Hardware and other low level system initialization is usually done
     * first.
     */

    /*
     * Initialize the run-time code itself.
     */
    mrt_Initialize() ;

    /*
     * Initialize domains, bridges and any other code that might require access
     * to the facilities of the run-time code. Typically, each domain in the
     * system would have an "init()" domain operation and these can be invoked
     * here. Sometimes domain interactions are such that a second round of
     * initialization is required.  Bridges between domains may also require
     * that the initialization for a domain be done before the bridge can be
     * initialized. Once mrt_Initialize() has been invoked, domains may
     * generate events and do other model level activities.  Regardless of how
     * the initialization is accomplished, it is system specific and,
     * unfortunately, only temporally cohesive.
     */

    /*
     * Entering the event loop causes the system to run.
     */
    mrt_EventLoop() ;

    /*
     * It is possible that domain activities can cause the main loop to exit.
     * Here we consider that successful. Other actions are possible and
     * especially if the event loop is exited as a result of some unrecoverable
     * system error.
     */
    return EXIT_SUCCESS ;
}
----

The only hard and fast requirements are that `mrt_Initialize` must be called
before any facilities of the run-time are used and `mrt_EventLoop` must
be invoked to cause the system to run.

(((micca,Run Time Function,mrt_Initialize)))

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_Initialize(void) ;
----

The `mrt_Initialize` function initializes the micca run-time.
This function should be called early in the initialization of a system
and must be invoked before using any run-time facilities such as
signaling an event.
*****

The implementation of `mrt_Initialize` is target platform specific.
So we postpone showing its code until later when we discuss how the
run-time is tailored to the supported target computing platforms.

=== Event Loop [[event-loop]]

The figure below shows a simplified diagram of
the flow of control in the event loop.

image::main-loop.pdf[title="Micca Run Time Event Loop"]

Processing is divided between the background and foreground.
Foreground processing happens as a result of an interruptfootnote:[In the
POSIX environment, signals serve the role of an interrupt].
A queue is used to synchronize between the two execution realms.
The background processing is single threaded.
We will discuss the internal logic of processing an event later.
For now, we make these points.

* If interrupts have occurred,
we deal with their background synchronization first and completely.
The exact manner used to synchronize between interrupts and the background
is processor architecture dependent.
* Only one event is dispatched after synchronizing with interrupts.
Because we invoke the synchronization functions requested by
all the interrupts before dispatching a single event,
interrupt synchronization has an effective higher priority than event dispatch.
* If the event queue becomes empty,
we check if any activity has requested that the event loop terminate.
If so, then flow continues to the remainder of the `main` program.
* If the event loop is not exited, the run-time
waits until there is further work to be done.
Note that any further work must arise from interrupt service and its
synchronization to the background.
Waiting is platform specific, but usually, for embedded systems,
involves going into a sleep or low power mode.
For the POSIX version of the run-time, the `pselect(2)` system call is used
to suspend the process awaiting either a signal or a change in status
of a file descriptor.

As we shall see below,
the above description of the event loop flow is somewhat simplified.
There is one additional concept for which we must account.
Events originating outside of an instance context executing an activity
start a new _thread of control_.
This includes events that originate from a domain operation,
a portal operation or are delayed events.
Delayed events (even if self directed) are considered to be delivered
by the run-time and hence outside of a state activity.

The thread of control terminates when the event that started it and
all the other events that arose from the starting event have been dispatched.
The event that starts a thread of control causes a transition that
runs a state activity.
That activity may signal other events, causing other transitions
which may signal yet more events.
At some point,
the tree of state activity invocations does not produce any further events.
When the entire set of events is dispatched, the thread of control ends.
When a thread of control ends,
the referential integrity of the data is checked.
There is a close association between a transaction on the domain
data and the bounds of the thread of control.
At the boundary of threads of control,
run-time evaluates requests to exit the event loop.
The event loop will not normally be exited until the end of
any ongoing thread of control

To keep the event dispatches that start a thread of control
separate from those that run during a thread of control,
the run-time keeps two queues.
We will see those queues in the code below,

*****
(((micca,Run Time Function,mrt_EventLoop)))
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_EventLoop(void) ;
----

The `mrt_EventLoop` function enters the micca run-time event loop
and dispatches events to cause the system to run.
Control remains in the event loop unless specifically requested to
exit via the `mrt_SyncToEventLoop` function.

[IMPORTANT]
The `mrt_EventLoop` function must not be called recursively, _i.e._
`mrt_EventLoop` is not to be invoked as part of an activity.
The system must remain in the event loop until properly exited.
Only after the event loop has been exited may it be re-entered.
*****

To a first approximation,
the event loop is an infinite loop.
Most applications will enter the event loop after their initialization
phase and remain there forever.

(((micca,Run Time Function,mrt_EventLoop)))
[source,c]
----
<<mrt external functions>>=
void
mrt_EventLoop(void)
{
    mrtExitEventLoop = false ;

    for (;;) {
        bool didtoc = mrtRunThreadOfControl() ; // <1>

        if (mrtExitEventLoop) {                 // <2>
            break ;
        } else if (!didtoc) {                   // <3>
            mrtWait() ;
        }
        /*
         * Else we ran a thread of control and weren't requested to exit
         * the event loop.
         */
    }
}
----
<1> Run one thread of control, recording whether there was any work done.
<2> Check if we have been requested to exit the event loop.
We do this first because it is possible that something took us out of
`mrtWait()` and requested to exit the event loop without actually
signaling an event (and so no thread of control actually ran).
For example, this happens when domains are run under a test harness.
<3> If no thread of control actually ran, then wait for something
in the outside world to wake us up.

As we see,
the flow of control loops, processing one thread of control at a time as long
as it has not been requested to exit the loop.

Testing and other considerations mean that we may want to exit the
event loop to gain control of the program.
Exiting the event loop is controlled by a boolean variable.

(((micca,Run Time Function,mrtExitEventLoop)))
[source,c]
----
<<mrt static data>>=
static bool mrtExitEventLoop ;
----

Rather than expose the variable directly,
we provide a function to set it.

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_SyncToEventLoop(void) ;
----

The `mrt_SyncToEventLoop` function will cause the event loop to exit
after completing any ongoing thread of control.
The function returns `false` if the event loop would not have exited and
`true` otherwise.
*****

One use case for this function is in test code where the main
test application will enter the event loop and some state activity
will execute `mrt_SyncToEventLoop()` to return control back to the test
application.
There are other uses.
For example, if the system detects a catastrophic situation,
it may want to exit the event loop and allow the subsequent code to
gracefully bring down the system or force the system to reset.
The exact details are system specific,
but this provides the means to gain control of the run-time execution
for exceptional situations.

(((micca,Run Time Function,mrt_SyncToEventLoop)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_SyncToEventLoop(void)
{
    bool exitControl = mrtExitEventLoop ;
    mrtExitEventLoop = true ;
    return exitControl ;
}
----

Again,
testing and some other situations are most easily handled
if we can dispatch all the events in a single thread of control,
waiting for the starting event to come along.

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_DispatchThreadOfControl(
    bool wait) ;
----

`wait`::
    If `wait` is `true`, and there is no thread of control event
    to dispatch, then the function blocks until one comes along
    and then runs the thread of control.

The `mrt_DispatchThreadOfControl` function attempts to run a single thread of
control and then returns to the caller a boolean value to indicate
if a thread of control was actually executed.
Any ongoing thread of control is finished and is not considered
in the return value.
If there are no queued events that would start a thread of control,
then the function waits until one is queued if the `wait`
argument is `true`  and then
runs the thread of control that results.
If `wait` is `false` and there is no thread of control ready to run,
then the function returns `false` immediately.
Since this function will wait for a thread of control event to arrive,
it can be useful to wait for a delayed event or an event
that arises from the external environment.
It is possible that a foreground / background synchronization could
occur that wakes up the processor but
did not start a thread of control.
In that case as well as when the `wait`
argument is `false`,
the function could return `false`.

[IMPORTANT]
The `mrt_DispatchThreadOfControl` function must not be called recursively,
_i.e._ `mrt_DispatchThreadOfControl` is not to be invoked as part of an
activity.
The system must remain in the event loop until properly exited.
Only after the event loop has been exited may it be re-entered.
*****

(((micca,Run Time Function,mrt_DispatchThreadOfControl)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_DispatchThreadOfControl(
    bool wait)
{
    bool rantoc = mrtRunThreadOfControl() ;
    if (!rantoc && wait) {
        mrtWait() ;
        rantoc = mrtRunThreadOfControl() ;
    }
    return rantoc ;
}
----

We also provide an interface to dispatch one event and then return
to the caller.

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_DispatchSingleEvent(void) ;
----

The `mrt_DispatchSingleEvent` function may be invoked to process a single
event and then returns to the caller.
The return value for `mrt_DispatchSingleEvent` indicates if an event
was actually dispatched.
A return value of `false` indicates that the event queue is empty.
This function ignores thread of control boundaries and so
will dispatch the first available event even if that event starts
a thread of control.

[IMPORTANT]
The function `mrt_DispatchSingleEvent` is not to be invoked while in the
event loop, _i.e._ `mrt_DispatchSingleEvent` is not to be invoked by
domain activities.
It is only valid to invoke this function if the program is not currently
running under the control of the event loop.
*****

This function can be used to control the dispatch of each event.
This is _not_ the recommended mechanism of running a `micca` based
application, but sometimes it is necessary.
Again,
testing is sometimes best accomplished by letting a test program
control event-by-event dispatch.
Another use case involves situations where `micca` generated domains
must be integrated with legacy code.
The legacy code will probably have its own execution loop and
we will have to dispatch `micca` events under control of the legacy
execution scheme.
This is not an ideal situation,
but when migrating an older system to a `micca` translated system
a transition period is unavoidable.
We provide the ability to micro-manage the event dispatch with the full
realization that the capablity will be abused by some projects.

(((micca,Run Time Function,mrt_DispatchSingleEvent)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_DispatchSingleEvent(void)
{
    bool didOne = mrtProcessOneEvent(&eventQueue) ;

    if (!didOne) {
        didOne = mrtProcessOneEvent(&tocEventQueue) ;
    }
    if (mrtEventQueueEmpty(&eventQueue)) {              // <1>
        mrtEndTransaction() ;
    }

    return didOne ;
}
----
<1> We must make sure to enforce referential integrity whenever
the thread of control is over as indicated by an empty event queue.

=== Processing a Thread of Control

Two functions provide the necessary operations to run a thread of control

To finish an thread of control it is only necessary to empty the
immediate event queue and perform the referential integrity checks
that are part of finishing a thread of control.

(((micca,Run Time Function,mrtFinisheThreadOfControl)))
[source,c]
----
<<mrt static functions>>=
static void
mrtFinishThreadOfControl(void)
{
    while (mrtProcessOneEvent(&eventQueue)) {
        // N.B. empty loop body
    }
    mrtEndTransaction() ;
}
----

To run a thread of control,
we take one event off the thread of control event queue and process it.
Then, we simply finish dispatching any events off of the immediate
event queue.

(((micca,Run Time Function,mrtRunThreadOfControl)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtRunThreadOfControl(void)
{
    mrtFinishThreadOfControl() ;                            // <1>

    bool startedtoc = mrtProcessOneEvent(&tocEventQueue) ;
    if (startedtoc) {
        mrtFinishThreadOfControl() ;
    }

    return startedtoc ;
}
----
<1> It is possible for events to be lingering in the imminent dispatch queue.

=== Processing a Single Event

Before each event is processed,
regardless of the queue from which it is taken,
all the synchronization functions must be invoked.

[source,c]
----
<<mrt forward references>>=
static bool mrtProcessOneEvent(MRT_EventQueue *queue) ;
----

[[processing-one-event]]
(((micca,Run Time Function,mtrProcessOneEvent)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtProcessOneEvent(
    MRT_EventQueue *queue)
{
        #if (!(defined(__ARM_ARCH) &&  __ARM_ARCH == 7))
    <<execute sync functions>>
        # endif /* <1> */

    return mrtDispatchEventFromQueue(queue) ;
}
----
<1> Note that the exact manner in which background synchronization
functions are executed is dependent upon the processor architecture.
We will discuss this later, but for now,
it is only important to remember that all requests for background
synchronization are executed before dispatching at most one event.

The code for `mrtDispatchEventFromQueue` is shown
<<dispatching-an-event-from-a-queue,later>>
when we discuss event dispatch.

== Managing Data

Before we discuss the details of how execution is sequenced,
we will show how data is managed by the run-time.
Execution sequencing is directed at class instances and it will be
helpful to understand how instances are stored before we get to
discussing how they are operated upon.

The run-time provides functions to support the basic lifetime of
instances.
We need to be able to:

* Create instances synchronously as part of an activity.
* Create instances asynchronously as part of a event dispatch.
* Delete instances synchronously as part of an activity.
* Delete instances asynchronously when the instance enters a final state.

=== Instance Data [[instance-data,Instance Data]]

For every class (and assigner),
the code generator will declare a ``C'' structure whose members contain
all the attributes and other elements of the class.
The structure of each class is, in general, different.
Each class can have different attributes and relationships and this
is reflected in members of the ``C'' structure that is used for each class.
From the point of view of the run-time and the operations provided by
the run-time,
instances can be treated the same.
The view of a class instance by the run-time is shown below.

(((micca,Run Time Data,MRT_Instance)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtinstance {
    struct mrtclass const *classDesc ;
    MRT_AllocStatus alloc ;
    MRT_StateCode currentState ;
    MRT_RefCount refCount ;

#       ifndef MRT_NO_NAMES
    char const *name ;
#       endif /* MRT_NO_NAMES */
} MRT_Instance ;
----

`classDesc`::
    A pointer to a <<class-data-structure,class data structure>>.
    The class data structure contains
    information that is common to all instances of the class.
`alloc`::
    A value that shows the allocation status of the memory for the instance.
    A value of 0, means the memory slot is not in use and can be allocated
    to a new instance.
    A negative value means the memory has been reserved but is not in active
    use as an instance.
    A positive value means the memory has been reserved and the instance
    is in active use.
`currentState`::
    For those classes that have a state model,
    the `currentState` member holds a small integer number indicating the
    current state in which the instance resides.
    A value of `MRT_StateCode_IG` (-1) is used to show that the class does not
    have a state model.
`refCount`::
    A counter value used to enforce referential integrity.
    At the end of a data transaction,
    this member is used as an accumulator of the number of times the
    instance is referenced in a relationship.
`name`::
    An instance may have a name that it was given during the intial instance
    population.
    For instances not defined as part of the initial instance population,
    this member is set to `NULL`.

The `micca` code generator will facilitate this view of an arbitrary instance
by inserting this structure as the first element of the ``C'' structure
that is generated for each class.
In this manner,
a pointer to an arbitrary class instance can be cast to a pointer to a
`MRT_Instance` with impunity.

(((micca,Run Time Data,MRT_AllocStatus)))
[source,c]
.Allocation Status Data Type
----
<<mrt internal simple types>>=
typedef int16_t MRT_AllocStatus ;
----

A class instance is nothing more than an element of a ``C'' array.
The size of the array, and consequently the maximum number of instances
of the class, is fixed at compile time.
The `alloc` member of the instance structure is used to keep track of the
status of the array elements as instances are created and deleted at run-time.
We will also use this member to track _event-in-flight_ errors.
We will discuss this more <<event-in-flight-error,below>>,
but we need a way to insure that events that have been signaled are not
delivered to instances that have been deleted.

(((micca,Run Time Data,MRT_StateCode)))
[source,c]
.Current State Data Type
----
<<mrt interface simple types>>=
typedef int8_t MRT_StateCode ;
----

The data type for the `currentState` member is just a small integer.
By specifying 8 bits we limit the number of states of a state model to 127.
That is an enormous number of states for a class state model.
We use negative state numbers to indicate the non-transitioning actions
that may occur when an event is dispatched.

(((micca,Run Time Constant,MRT_StateCode_IG)))
(((micca,Run Time Constant,MRT_StateCode_CH)))
[source,c]
----
<<mrt interface constants>>=
#define MRT_StateCode_IG    (-1)
<<mrt internal constants>>=
#define MRT_StateCode_CH    (-2)
----

We will also have need for a counter used in the enforcement of
referential integrity.

(((micca,Run Time Data,MRT_RefCount)))
[source,c]
.Reference Count Data Type
----
<<mrt internal simple types>>=
typedef uint8_t MRT_RefCount ;
----

=== Class Data

All the behavior of data management and execution sequencing is
completely determined by the values contained in the data structures
supplied to the various functions of the run-time.
This is distinct from some software architecture mechanisms that
use generated code from a model compiler to implement some capabilities.
Being completely data driven and separately compiled is a design goal of the
run-time.

Since the behavior of all instances of a given class is the same,
each class has a data structure that contains all the class invariant
information.

First, we consider class attributes.
We will have need to obtain attribute values in a generic way.
From the platform model,
we see that there are two types of attributes, independent and dependent.
We will need to encode that difference.

(((micca,Run Time Data,MRT_AttrType)))
[source,c]
.Attribute Type Data Type
----
<<mrt internal simple types>>=
typedef enum {
    mrtIndependentAttr,
    mrtDependentAttr
} MRT_AttrType ;
----

Dependent attributes are those computed by some formula.
The code generator will enclose the formula in a function that
we can invoke to obtain the attribute value.

(((micca,Run Time Data,MRT_AttrFormula)))
[source,c]
.Attribute Formula Data Type
----
<<mrt internal aggregate types>>=
typedef void MRT_AttrFormula(
    void const *const self,
    void *const pvalue,
    MRT_AttrSize vsize) ;
----

`self`::
    A pointer to the instance upon which the formula function is invoked.
`pvalue`::
    A pointer to the memory where the formula result is to be placed.
`vsize`::
    The number of bytes pointed to by `pvalue`.

Formula functions will be invoked with a pointer to the instance,
a pointer to where the result is to be stored and the size of the
result area in bytes.

The description of an attribute is then a discriminated union.

(((micca,Run Time Data,MRT_Attribute)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtattribute {
    MRT_AttrSize size ;
    MRT_AttrType type ;
    union {
        MRT_AttrOffset offset ;
        MRT_AttrFormula *formula ;
    } access ;

#       ifndef MRT_NO_NAMES
    char const *name ;
#       endif /* MRT_NO_NAMES */
} MRT_Attribute ;
----

`size`::
    The number of bytes of memory occupied by the attribute value.
`type`::
    The type of the attribute, independent or dependent.
`access`::
    A union whose value depends upon the value of the `type` member.
    `offset`;;
        For `mrtIndependentAttr` types, the `offset` member contains
        the offset in bytes from the beginning of the instance memory
        to the attribute.
    `formula`;;
        For `mrtDependentAttr` types, the `formula` member contains
        a pointer to a function that computes the value of the attribute.
`name`::
    The name of the attribute.

To manage all the aspects of class instances,
we need information on memory allocation, event dispatch, relationships
in which the instances participate and many other pieces of information.

[[class-data-structure]]
(((micca,Run Time Data,MRT_Class)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtclass {
    struct mrtinstallocblock *iab ;
    unsigned eventCount ;
    struct mrteventdispatchblock const *edb ;
    struct mrtpolydispatchblock const *pdb ;
    unsigned relCount ;
    struct mrtrelationship const * const *classRels ;
    unsigned attrCount ;
    MRT_Attribute const *classAttrs ;
    unsigned instCount ;
    struct mrtsuperclassrole const *containment ;

#       ifndef MRT_NO_NAMES
    char const *name ;
    char const *const *eventNames ;
#       endif /* MRT_NO_NAMES */
} MRT_Class ;
----

`iab`::
    A pointer to an instance allocation block (IAB).
    The IAB is used to dynamically allocation class instances.
`eventCount`::
    The total number of transitioning and polymorphic events to which
    the class responds.
`edb`::
    A pointer to an event dispatch block (EDB).
    The EDB is used to dispatch events to a state machine.
    For classes that do not have a state model,
    this value is set to `NULL`.
`pdb`::
    A pointer to a polymorphic dispatch block (PDB).
    The PDB is used to dispatch polymorphic events.
    For classes that have no polymorphic events,
    this value is set to `NULL`.
`relCount`::
    The number of relationships in which the class participates.
`classRels`::
    A pointer an array of relationship description pointers describing
    the relationships in which the class participates.
    The array has `relCount` elements.
`attrCount`::
    The number of attributes the class contains.
`classAttrs`::
    A pointer an array of descriptions for the attributes the class contains.
    The array has `attrCount` elements.
`instCount`::
    The number of instances of the class.
    This number represents the number of elements in the array that is
    used to store the class instances.
`containment`::
    For classes that are union subclasses, this member points to a descriptor
    for the immediate superclass in the generalization.
    For other classes, the value is `NULL`.
`name`::
    A pointer to a `NUL` terminated string containing the name of the class.
`eventNames`::
    A pointer to an array of character pointers to the names of the
    class events.
    This information is used in tracing event dispatch.

When generically describing classes,
the subclasses of union based generalizations pose a special situation.
All other class instances are stored in an array.
Union subclasses are stored in the structure of their related
superclass.
The essential information for a union subclass is the class of its
ultimate superclass and the offset from the beginning of the
superclass to where the instance is located.
Note that a union subclass can be subject to repeated generalization
of another union subclass.
The ultimate superclass is the class at the top of the generalization
hierarchy.

In the next section,
the instance allocation block is described as we continue to define
how data is managed by the run-time.
Later, we describe the event dispatch block and polymorphic dispatch
block when we discuss event dispatch.

=== Instance Allocation

There are three ways to create an instance:

. Create an instance as part of an initial instance population.
. Create an instance synchronously to the execution of some activity by invoking
a function.
. Create an instance asynchronously to the execution of some activity by sending
an event.

Creating initial instances is handled during code generation using the
population data specified when the domain is configured.
The code generator arranges for initial instance values to be inserted as
initializers of the class storage array.
In this section,
we are going to discuss synchronous instance creation.
This is instance creation by a direct function invocation and when
the function returns the instance is ready and available.
Later we will discuss asynchronous instance creation which is instance
creation by signaling an event.

=== Instance Allocation Block

The instances of a class are contained in a single array variable
which serves as the memory pool for the instances.
To support managing a pool of class instances,
an *Instance Allocation Block*, or *IAB* for short,
data structure is used to keep track of the memory pool.
What we need is a data structure that describes the properties of the
class instance memory pool.

[source,c]
----
<<mrt internal aggregate types>>=
typedef void (*MRT_InstCtor)(void *const) ;
typedef void (*MRT_InstDtor)(void *const) ;
----

(((micca,Run Time Data,MRT_iab)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtinstallocblock {
    void *storageStart ;
    void *storageFinish ;
    void *storageLast ;
    MRT_AllocStatus alloc ;
    size_t instanceSize ;
    MRT_InstCtor construct ;
    MRT_InstDtor destruct ;
    unsigned linkCount ;
    MRT_AttrOffset const *linkOffsets ;
} MRT_iab ;
----

`storageStart`::
    A pointer to the beginning of the memory where the instance storage
    pool is located.
    This is the array allocated to hold the instances of a class.
`storageFinish`::
    A pointer to one element beyond the end of the instance storage pool
    for the class.
    This pointer may not be dereferenced, of course, but provides the
    boundary marker for the end of the pool.
`storageLast`::
    A pointer to the instance that was last allocated. This is used as
    the starting point for allocating the next instance.
`alloc`::
    The next value of the allocation counter to be assigned to a newly
    allocated instance. This member is used to give a unique number
    (modulo the maximum value that can be held in the data type)
    to each allocation of the array element where an instance is stored.
    The number is used to diagnose run-time analysis errors.
`instanceSize`::
    The number of bytes of memory occupied by an instance.
`construct`::
    A pointer to a constructor function. If there is no constructor defined
    for the class, then the value of this member may be set to `NULL`.
`destruct`::
    A pointer to a destructor function. If there is no destructor defined
    for the class, then the value of this member may be set to `NULL`.
`linkCount`::
    The number of link pointer containers in the instance.
`linkOffsets`::
    A pointer to an array of offsets to the link pointer containers
    in an instance. The array contains `linkCount` elements.

Instance creation and deletion also supports a very simplified notion of
construction and destruction for the instances.
This is no where near as complicated or full featured as something in C++.
Constructors and destructors take no arguments but are implicitly supplied a
pointer to the instance when invoked.

Constructors and destructors are primarily useful for when the instance has a
more complicated data structure as an attribute,
as might be the case if the attribute data type is user defined.
If you need to do complicated construction of instances,
the preferred method is to do that with an instance based operation
or as part of a state activity for an asynchronously created instance.

=== Finding Instance Memory

Before we can create an instance,
we need to find memory for it.

*****
[source,c]
----
<<mrt forward references>>=
static MRT_Instance *
mrtFindInstSlot(
    MRT_iab *iab) ;
----

`iab`::
    A pointer to the instance allocation block for the class for
    which instance memory is to be allocated.

`mrtFindInstSlot` searchs for unused instance memory in the memory pool
described by `iab`.
It returns a pointer to the allocated memory if successful and
`NULL` if no memory is available in the class pool.
*****

The allocation algorithm is a simple linear search starting at the last
location that was allocated.

(((micca,Run Time Function,mrtFindInstSlot)))
[source,c]
----
<<mrt static functions>>=
static MRT_Instance *
mrtFindInstSlot(
    MRT_iab *iab)
{
    assert(iab != NULL) ;
    assert(iab->storageLast < iab->storageFinish) ;
    /*
     * Search for an empty slot in the pool. Start at the next location after
     * where we last allocated an instance.
     */
    MRT_Instance *inst ;
    for (inst = mrtNextInstSlot(iab, iab->storageLast) ;
            inst->alloc != 0 && inst != iab->storageLast ;
            inst = mrtNextInstSlot(iab, inst)) {
        /* Empty Body */
    }
    /*
     * Check if we ended up on a slot that is free.
     */
    return inst->alloc == 0 ? inst : NULL ; // <1>

}
----
<1> If we wrap all the way around to where we started and still did not
find an instance storage element whose `alloc` member was zero,
then we have run out of space!
That condition is indicated by returning `NULL`.

Finding the next element in the instance storage array involves
performing the pointer arithmetic modulo the size of the array.
Since the pool is allocated in a contiguous block of memory,
we must wrap around the iterator when it passes the end of the
storage pool.
That is accomplished with the `mrtNextInstSlot()` function.

*****
[source,c]
----
<<mrt forward references>>=
static inline void *mrtNextInstSlot(MRT_iab *iab, void *ptr) ;
----

The `mrtNextInstSlot` function returns the memory address of the next instance
after the one pointed to by `ptr` in the class instance pool described by
`iab`.
*****

(((micca,Run Time Function,mrtNextInstSlot)))
[source,c]
----
<<mrt static functions>>=
static inline void *
mrtNextInstSlot(
    MRT_iab *iab,
    void *ptr)
{
    ptr = (void *)((uintptr_t)ptr + iab->instanceSize) ; // <1>
    if (ptr >= iab->storageFinish) { // <2>
        ptr = iab->storageStart ;
    }
    return ptr ;
}
----
<1> Since the size of instance varies from class to class,
we must take over scaling the pointer arithmetic by the size of the
instance.
<2> Perform the wrap around if we cross over the boundary of
the storage array.

=== Instance Containment

For most classes,
the Instance Allocation Block describes everything needed about how
instances are stored.
However,
classes that are subclasses of a union generalization do not have
their own storage pool.
Union subclass instances are stored as part of the instance structure
of the containing superclass.
The containment may be several levels deep as a union subclass can be
the superclass for another union generalization.
The `MRT_Class` data structure contains the necessary information
to deal with this.
The following function forms the basis for
treating the union subclasses the same as other classes.

*****
[source,c]
----
<<mrt forward references>>=
static MRT_iab *
mrtGetStorageProperties(
    MRT_Class const *const classDesc,
    size_t *offsetptr) ;
----

`classDesc`::
    A pointer to the class data for which storage properties are computed.
`offsetptr`::
    A pointer to a location where the instance offset is returned.
    If not `NULL`, then 
    a value is returned via the pointer that is the offset in bytes from the
    beginning of an instance to where the class storage begins.

The `mrtGetStorageProperties` function returns a pointer to the IAB that
describes the storage containment for the class.
For non-union subclasses,
this is simply the IAB that describes the class storage pool.
For union subclasses,
the returned IAB will be for the ultimate superclass that contains the class
instances.
*****

(((micca,Run Time Function,mrtGetStorageProperties)))
[source,c]
----
<<mrt static functions>>=
static MRT_iab *
mrtGetStorageProperties(
    MRT_Class const *const classDesc,
    MRT_AttrOffset *offsetptr)
{
    assert(classDesc != NULL) ;
    MRT_iab *iab = classDesc->iab ;
    MRT_AttrOffset instanceOffset = 0 ; // <1>
    for (struct mrtsuperclassrole const *container = classDesc->containment ;
            container != NULL ;
            container = container->classDesc->containment) {// <2>
        instanceOffset += container->storageOffset ;
        iab = container->classDesc->iab ;
    }
    if (offsetptr) {// <3>
        *offsetptr = instanceOffset ;
    }

    return iab ;
}
----
<1> For non-union subclasses, the offset to the beginning of the
instance data is always zero.
Only union subclasses are stored with their superclass and will have
a non-zero offset.
<2> We iterate up the generalization hierarchy to find the ultimate
superclass that contains the class instances.
At each step of the iteration, we accumulate the relative offset of
each contained instance.
<3> The offset is returned only if requested.

We will also find occasion to want to compute the index into the
storage pool for a particular instance.
Storage pool indices make convenient identifiers of a class instance
outside of a domain.
Again we must allow that the instance may be a union subclass instance.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern MRT_InstId
mrt_InstanceIndex(
    void const *instance) ;
----

`instance`::
    A pointer to a class instance.

The `mrt_InstanceIndex` function returns the array index value of the instance
in its storage pool.
*****

(((micca,Run Time Function,mrt_InstanceIndex)))
[source,c]
----
<<mrt external functions>>=
MRT_InstId
mrt_InstanceIndex(
    void const *instance)
{
    MRT_Instance const *instref = instance ;
    assert(instref != NULL) ;
    assert(instref->classDesc != NULL) ;

    MRT_AttrOffset offset ;
    MRT_iab *iab = mrtGetStorageProperties(instref->classDesc, &offset) ;
    assert(instance >= iab->storageStart && instance < iab->storageFinish) ;
    MRT_InstId index = (((uintptr_t)instance - offset) -
            (uintptr_t)iab->storageStart) / iab->instanceSize ;     // <1>
    return index ;
}
----
<1> The `instanceSize` member of the IAB is the number of bytes occupied
by an instance.
For union subclasses, the IAB returned by `mrtGetStorageProperties` will
be for the enclosing supertype.
So we have to make sure and subtract off the offset to the subclass
before computing the index.
For non-union subclass instances, `offset` here will be zero.
Such are the complexities when taking over the pointer arithmetic
and it is necessary to be generic.

The inverse of finding the instance index is to convert such an index
into a reference to an instance.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void *
mrt_InstanceReference(
    MRT_Class const *const classDesc,
    MRT_InstId index) ;
----

`classDesc`::
    A pointer to the class description for the reference to be computed.
`index`::
    An array index into the class storage pool.
    If `index` out of bounds, then a fatal system error occurs.

The `mrt_InstanceReference` function returns
a pointer to the instance in the class storage pool for the
class described by `classDesc` and indexed by the value of `index`.
*****

(((micca,Run Time Function,mrt_InstanceReference)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_InstanceReference(
    MRT_Class const *const classDesc,
    MRT_InstId index)
{
    void *instance = mrtIndexToInstance(classDesc, index) ;     // <1>
    if (instance == NULL) {
        mrtUnallocSlotError(index, classDesc) ;
    }

    return instance ;
}
----
<1> First, compute the instance from the index.
Then we check if the instance is in use.
For external callers,
computing a reference that is not in use is a fatal error.

The common code used internally
to compute an instance reference from an index
doesn't test to see if the instance is in use.
Internal callers take on that responsibility and most frequently
it is not necessarily an error.

(((micca,Run Time Function,mrtIndexToInstance)))
[source,c]
----
<<mrt static functions>>=
static void *
mrtIndexToInstance(
    MRT_Class const *const classDesc,
    MRT_InstId index)
{
    assert(classDesc != NULL) ;
    MRT_AttrOffset offset ;
    MRT_iab *iab = mrtGetStorageProperties(classDesc, &offset) ;
    void *instance = (void *)((uintptr_t)iab->storageStart +
            (index * iab->instanceSize) + offset) ;
    if (instance >= iab->storageFinish) {                       // <1>
        mrtNoInstSlotError(classDesc) ;
    }

    return (((MRT_Instance *)instance)->alloc <= 0) ? NULL : instance ;
}
----
<1> It is a fatal error to index outside the bounds of the class
storage pool.

=== Creating an Instance

Creating an instance involves allocating memory to hold the instance.
Normally,
each class has its own pool of memory for its instance and the
IAB and functions shown previously are used to manage that memory.
However,
instances of union-based subclasses have their memory allocated internal
to the superclass instance.
This means finding memory for a union subclass instance is different
than finding memory for other classes.
For the union subclass case,
we must locate the correct place inside the instance memory for its
related superclass instance.
This difference is dealt with by using a separate function
to create union subclass instances.
Note there are two functions for each of the various types
of creation operations.

We first start with a description of synchronously creating a normal,
non-union-based instance.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void *
mrt_CreateInstance(
    MRT_Class const *const classDesc,
    MRT_StateCode initialState) ;
----

`classDesc`::
    A pointer to the class data for the instance to be created.
`initialState`::
    The state number into which the instance will be placed.
    For classes that do not have an associated state model this argument
    is ignored.
    For classes that do have an associated state model,
    the class will be created in the state given by `initialState`.
    If this argument is `MRT_StateCode_IG` or if the value given for
    `initialState` is not a valid state number for the class,
    then the instance is created in its default initial state.

`mrt_CreateInstance` allocates memory for an instance of the class
described by `classDesc` and places the instance in the state
given by `initialState`.
No state activity is run as part of synchronous instance creation.
*****

(((micca,Run Time Function,mrt_CreateInstance)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_CreateInstance(
    MRT_Class const *const classDesc,
    MRT_StateCode initialState)
{
    assert(classDesc != NULL) ;

    /*
     * Search for an empty slot in the pool.
     */
    MRT_iab *iab = classDesc->iab ;
    MRT_Instance *inst = mrtFindInstSlot(iab) ;
    if (inst == NULL) {
        mrtNoInstSlotError(classDesc) ;
    }
    /*
     * Record where we left off for the next allocation attempt.
     */
    iab->storageLast = inst ;
    /*
     * Initialize the memory for the instance.
     */
    mrtInitializeInstance(inst, classDesc, initialState) ;

    return inst ;
}
----

Union based subclasses pose special cases since the memory used to
hold an instance is _not_ allocated from a pool but rather is embedded
in the instance of a superclass.
A different function is required and additional parameters are used
to determine the memory location of the subclass instance.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void *
mrt_CreateUnionInstance(
    MRT_Class const *const classDesc,
    MRT_StateCode initialState,
    MRT_Relationship const *const genRel,
    void *super) ;
----

`classDesc`::
    A pointer to the class data for the instance to be created.
    The class described by `classDesc` must be a subclass of the
    relationship described by `genRel`.
`initialState`::
    The state number into which the instance will be placed.
    For classes that do not have an associated state model this argument
    is ignored.
    For classes that do have an associated state model,
    the class will be created in the state given by `initialState`.
    If this argument is `MRT_StateCode_IG` or if the value given for
    `initialState` is not a valid state number for the class,
    then the instance is created in its default initial state.
`genRel`::
    A pointer to a relationship description for the generalization
    in which the instance is a union-based subclass.
    The `relType` field of `genRel` must be `mrtUnionGeneralization`.
`super`::
    A pointer to the superclass instance where the subclass instance
    is to be created.
    `super` must be an instance of the superclass described by `genRel`.


`mrt_CreateUnionInstance` allocates memory for an instance of the union-based
subclass described by `classDesc` and places the instance in the state given by
`initialState`.
No state activity is run as part of synchronous instance creation.
The instance is created in place in the memory pointed to by `super`.
*****

The two additional parameters required by `mrt_CreateUnionInstance`
are need to provide the memory of the created instance (`super`) and
to determine the offset into that memory where the instance storage
is located (`genRel`).

(((micca,Run Time Function,mrt_CreateUnionInstance)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_CreateUnionInstance(
    MRT_Class const *const classDesc,
    MRT_StateCode initialState,
    MRT_Relationship const *const genRel,
    void *super)
{
    assert(classDesc != NULL) ;
    assert(genRel != NULL) ;
    assert(super != NULL) ;
    assert(genRel->relType == mrtUnionGeneralization) ;

    if (genRel->relType != mrtUnionGeneralization) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }
    MRT_UnionGeneralization const *const gen =
            &genRel->relInfo.unionGeneralization ;
    /*
     * Verify that the new subclass is actually a subclass of the
     * generalization.
     */
    mrtFindUnionGenSubclassCode(classDesc, gen->subclasses,
            gen->subclassCount) ;
    /*
     * Verify the super class instance is truly of the super class.
     */
    MRT_Instance *superInst = super ;
    if (superInst->classDesc != gen->superclass.classDesc) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }
    /*
     * Compute the location of the union subclass instance
     * within the superclass instance.
     */
    void *inst = (void *)((uintptr_t)super + gen->superclass.storageOffset) ;
    /*
     * Initialize the memory for the instance.
     */
    mrtInitializeInstance(inst, classDesc, initialState) ;

    return inst ;
}
----

==== Initializing Instance Memory

Once we have identified the memory for an instance,
we can make is ready to use.
This involves zeroing out the memory and then initialzing the
members of the `MRT_Instance` structure.
Any link list references must be initialized to empty and
the constructor is run if there is one.

(((micca,Run Time Function,mrtInitializeInstance)))
[source,c]
----
<<mrt static functions>>=
static void
mrtInitializeInstance(
    MRT_Instance *inst,
    MRT_Class const *const classDesc,
    MRT_StateCode initialState)
{
    assert(inst != NULL) ;
    assert(classDesc != NULL) ;

    MRT_iab *iab = classDesc->iab ;
    assert(iab != NULL) ;
    /*
     * Start with a zeroed out memory space.
     */
    memset(inst, 0, iab->instanceSize) ;                            // <1>
    inst->classDesc = classDesc ;
    /*
     * Mark the slot as in use.
     */
    inst->alloc = mrtIncrAllocCounter(iab) ;
    if (classDesc->edb != NULL) {
        assert(initialState < classDesc->edb->stateCount) ;

        inst->currentState = (initialState == MRT_StateCode_IG ||
            initialState >= classDesc->edb->stateCount) ?
                classDesc->edb->initialState : initialState ;       // <2>
    } else {
        inst->currentState = MRT_StateCode_IG ;                     // <3>
    }

    MRT_AttrOffset const *offsets = iab->linkOffsets ;              // <4>
    for (unsigned count = iab->linkCount ; count != 0 ; count--) {
        MRT_LinkRef *link = (MRT_LinkRef *)((uintptr_t) inst + *offsets++) ;
        mrtLinkRefInit(link) ;
    }
    /*
     * Run the constructor if there is one.
     */
    if (iab->construct) {
        iab->construct(inst) ;
    }
    mrtMarkRelationship(classDesc->classRels, classDesc->relCount) ; // <5>
}
----
<1> Setting the memory of the instance to zero is very important.
This insures that backward referencing pointers that are used in
relationships are `NULL` and we depend upon that fact in the
relationship linkage code.
<2> We use `MRT_StateCode_IG` as a special value to indicate that
we want the instance created in its default initial state.
We also protect against illegal values of the initial state and treat
them the same.
<3> If a class does not have a state model, then we ignore the
value passed in to the function and set the current state to ignored.
This is a convenient value for such a situation.
<4> If a class contains any linked list terminus used for relationship
navigation,
they must be initialized to show that the linked list is empty.
<5> Creating an instance means it must be evaluated for referential
integrity at the end of the data transaction.
This is discussed in the next chapter.

One other important point here.
There is a counter in the IAB that is incremented each time an
instance is allocated and this value is used in the `alloc`
member of the instance.
This is another part of the strategy to detect an
_event-in-flight_ error.
This is described further below.
The effect of running this counter is that every instance gets a
different `alloc` member value (modulo the size of the counter variable)
The increment has one little catch.
The counter is signed and the positive and negative values are used
differently.
Here, we make sure the value remains positive.

[source,c]
----
<<mrt forward references>>=
static inline MRT_AllocStatus mrtIncrAllocCounter(MRT_iab *iab) ;
----

(((micca,Run Time Function,mrtIncrAllocCounter)))
[source,c]
----
<<mrt static functions>>=
static inline MRT_AllocStatus
mrtIncrAllocCounter(
    MRT_iab *iab)
{
    /*
     * Catch any overflow
     */
    iab->alloc = (iab->alloc == INT16_MAX ? 1 : iab->alloc + 1) ;
    return iab->alloc ;
}
----

=== Deleting an Instance

The function, `mrt_DeleteInstance`, is used to synchronously
destroy an instance.
Note that union subclass instances are treated the same as other
class instances.
Returning the memory for an instance is accomplished by setting
the value of its `alloc` member to zero and this is the same
in both cases, regardless of the fact that union subclass instance
do not have their own memory pool.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_DeleteInstance(
    void *instref) ;
----

`instref`::
    A pointer to an instance to be destroyed.

The `mrt_DeleteInstance` function deletes the instance given by `instref`.
*****

Just as there was a distinction between synchronous and asynchronous
instance creation,
there is a similar distinction for destruction.
Asynchronous destruction happens as a result of an instance entering
an _final_ state and that is discussed further below.
Here we are dealing with synchronous destruction of an instance.

Deleting an instance also implies that when the class of the instance
has references to other instance to link relationships,
these linkages must also be deleted.

(((micca,Run Time Function,mrt_DeleteInstance)))
[source,c]
----
<<mrt external functions>>=
void
mrt_DeleteInstance(
    void *instref)
{
    MRT_Instance *inst = instref ;
    assert(inst != NULL) ;
    if (inst == NULL || inst->alloc <= 0) {         // <1>
        return ;
    }
    MRT_Class const *const classDesc = inst->classDesc ;
    assert(classDesc != NULL) ;
    MRT_iab *iab = classDesc->iab ;
    assert(iab != NULL) ;
    /*
     * Unlink the instance from its relationships.
     */
    mrtDeleteLinks(classDesc->classRels, classDesc->relCount, instref) ;
    /*
     * Run the destructor, if there is one.
     */
    if (iab->destruct) {
        iab->destruct(inst) ;
    }
    /*
     * Mark the slot as free.
     */
    inst->alloc = 0 ;
}
----
<1> Don't delete any instance that is unallocated or is awaiting
the delivery of a creation event.
In the later case, we would cause an event in flight error.
Since `mrt_CreateInstanceAsync` returns a reference to the
created instance, it is possible that something foolish
like a request to immediately delete it could happen.
Won't happen when using the embedded commands, but ...

Deleting an instance is a simple matter.
First, unlink the instance from its relationships.
If there is a destructor, it is run.
The slot is free when its `alloc` member has a value of 0.
But beware,
for designs that have complicated relationships among the classes,
instance deletion can be very complicated, requiring much care
that the interdependencies among classes are properly preserved.
That work is not done here!
It is the responsibility of the analysis model to take any actions
necessary to preserve data integrity when deleting an instance.

=== Iterating Over Class Instances

It is a common operation to iterate over the instances of a class.
This is done both in the internals of the run-time as well as by
domain activity code.
For example,
domain code has the need to search for instances meeting certain criteria
such as the value of an attribute.
For small instance populations,
that search can be implemented by iterating over the instances of the
class and making the comparison to the criteria.
Consequently,
the run-time provides a general means to iterate over the instances
of a class.

The interface to instance iteration follows familiar patterns of Start, More,
Next and Get.
We have designed the interface in this way to avoid having to
return `NULL` as a special value to indicate the end of the iteration.
First, we need a data structure to hold the information we need for
iteration.

(((micca,Run Time Data,MRT_InstIterator)))
[source,c]
----
<<mrt interface aggregate types>>=
struct mrtinstanceiterator ;
typedef struct mrtinstanceiterator MRT_InstIterator ;

<<mrt internal aggregate types>>=
struct mrtinstanceiterator {
    void *instance ;
    MRT_Class const *classDesc ;
    MRT_iab *iab ;
} ;
----

`instance`::
    A pointer to the memory of the next instance in the iteration.
`classDesc`::
    A pointer to the class descriptor across which the iteration occurs.
`iab`::
    A pointer to the Instance Allocation Block for the class across which
    the iteration is to be performed.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstIteratorStart(
    MRT_InstIterator *iter,
    MRT_Class const *const classDesc) ;
----

`iter`::
    A pointer to a class instance iterator that is used to record the
    state of the iteration.
`classDesc`::
    A pointer to the class description for the class across which the
    iteration will happen.

The `mrt_InstIteratorStart` function is called to initialize an
instance iterator to iterate over instances of the class described
by `classDesc`.
*****

(((micca,Run Time Function,mrt_InstIteratorStart)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstIteratorStart(
    MRT_InstIterator *iter,
    MRT_Class const *const classDesc)
{
    assert(iter != NULL) ;
    assert(classDesc != NULL) ;
    iter->classDesc = classDesc ;

    MRT_AttrOffset instanceOffset ;
    MRT_iab *iab = mrtGetStorageProperties(classDesc, &instanceOffset) ;
    assert(iab != NULL) ;

    iter->iab = iab ;
    iter->instance = (void *)((uintptr_t)iab->storageStart + instanceOffset) ;
    MRT_Instance *instref = iter->instance ;
    if (instref->alloc <= 0 || instref->classDesc != iter->classDesc) { // <1>
        mrt_InstIteratorNext(iter) ;
    }
    return ;
}
----
<1> The iterator is designed to check if the instance is actually in
use. Here we check the first instance and if it is not being used
advance the iterator onward.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern bool
mrt_InstIteratorMore(
    MRT_InstIterator *iter) ;
----

`iter`::
    A pointer to a class instance iterator.

The `mrt_InstIteratorMore` function returns a boolean value indicating
if there are addition class instances which have not been visited.
It returns `true` to indicate that the iterator references a
valid class instance and `false` otherwise.
*****

(((micca,Run Time Function,mrt_InstIteratorMore)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_InstIteratorMore(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance < iter->iab->storageFinish ;
}
----

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void *
mrt_InstIteratorGet(
    MRT_InstIterator *iter) ;
----

`iter`::
    A pointer to a class instance iterator.

The `mrt_InstIteratorGet` function returns a pointer to the class
instance that is currently being visited in the iteration.
It is not valid to invoke `mrt_InstIteratorGet` after the
`mrt_InstIteratorMore` function has returned `false`.
This function is analogous to dereferencing a pointer.
*****

(((micca,Run Time Function,mrt_InstIteratorGet)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_InstIteratorGet(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance ;
}
----

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstIteratorNext(
    MRT_InstIterator *iter) ;
----

`iter`::
    A pointer to a class instance iterator.

The `mrt_InstIteratorNext` function advances the class instance iterator
to the next valid class instance.
To be a valid class instance,
the instance memory slot must be allocated and in active use.
*****

(((micca,Run Time Function,mrt_InstIteratorNext)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstIteratorNext(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;

    MRT_iab *iab = iter->iab ;
    assert(iab != NULL) ;

    while (iter->instance < iab->storageFinish) { // <1>
        iter->instance = (void *)((uintptr_t)iter->instance + iab->instanceSize) ;
        MRT_Instance *instref = iter->instance ;
        if (instref->alloc > 0 && instref->classDesc == iter->classDesc) {// <2>
            break ;
        }
    }
    return ;
}
----
<1> Advancing the instance pointer to past the storage pool for the
class indicates that we have visited all the instances.
<2> It may seem strange to test that the class descriptor for the
instance matches that of the class we are iterating across.
However, we must handle the case of union based subtypes which can
be reclassified.
In that case,
we are iterating across all potential subclass and only want to stop on
the ones that match our original intent.

=== Instance Sets

Another common model level operation is to accumulate a set of
class instances.
Most action languages are based on the concept of _selecting_ a set
of class instances based on some criteria (_e.g._ matching some value
of an attribute) and then iterating over that set to perform an operation
on each instance.
When the operation is simple,
this construct can be translated into an interation over the class
instances performing the criteria test and operation together.
This is to say that just because the action language statement implies
determining the contents of an instance set does not mean that it must
necessarily be implemented that way.
For simple situations involving searching for a criteria and then
immediately performing some operation,
it is not necessary to accumulate a set first and then iterate over the set.

However,
there are times when obtaining a set is crucial and cannot be replaced
by simple iteration over the class instances.
For example,
iterating across a many-to-many association may result in visiting the same
destination instance multiple times.
If we are applying a non-idempotent operation to the destination instance,
the what we really need is the set of related instances so as not
to have duplicates.
For those cases the run-time provides an instance set concept.

The design of the instance set has the goal of making it reasonable
to allocate the sets as automatic variables on the stack.
One could design the instance set to be a list of instance reference
pointers.
Unfortunately, such sets would occupy a significant amount of space.
We want to be able to allocate instance sets as automatic variables
to avoid the complication of managing the lifetime of set variables.
Since our target environment is usually quite limited,
large automatic variables are to be avoided.

The chosen design uses a bit vector.
Since class instances are contained in an array,
the index of a class instance in the storage pool array can be used
as an index into a bit vector.
The bit vector design trades off more processing to build and access the
set, but makes many other set operations much easier.
For example, since instance sets do not contain duplicates,
the ability to arithmetically `OR` in a bit means we do not have to
make any explicit tests to avoid inserting duplicate instances in the set.

The following is the data structure for an instance set.

(((micca,Run Time Data,MRT_InstSet)))
[source,c]
----
<<mrt internal simple types>>=
typedef uint32_t MRT_SetWord ;

<<mrt interface aggregate types>>=
struct mrtinstanceset ;
typedef struct mrtinstanceset MRT_InstSet ;

<<mrt internal aggregate types>>=
struct mrtinstanceset {
    MRT_Class const *classDesc ;                                // <1>
    MRT_SetWord instvector[(MRT_INSTANCE_SET_SIZE + MRT_SETWORD_BITS - 1) /
            MRT_SETWORD_BITS] ;                                 // <2>
} ;

<<mrt internal constants>>=
#define MRT_SETWORD_BITS    (sizeof(MRT_SetWord) * 8)
----
<1> An instance set records instances of one particular class.
In other words, instance sets are typed to the class of instances they hold.
<2> The bit vector is allocated in `MRT_SetWord` words and we round up to
insure we have enough space for all the instances.

Like all the other memory allocations in the run-time,
we have to fix the maximum number of instance references that can be held
in the set.
By default we set that number to 128.

(((micca,Run Time Constant,MRT_INSTANCE_SET_SIZE)))
[source,c]
----
<<mrt interface constants>>=
#ifndef MRT_INSTANCE_SET_SIZE
#   define MRT_INSTANCE_SET_SIZE 128
#endif /* MRT_INSTANCE_SET_SIZE */
#if __STDC_VERSION__ >= 201112L
static_assert(MRT_INSTANCE_SET_SIZE > 0, "Instance set size must be > 0") ;
#endif /* __STDC_VERSION__ >= 201112L */
----

A function is provided to properly initalize an instance set variable.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstSetInitialize(
    MRT_InstSet *set,
    MRT_Class const *const classDesc) ;
----

`set`::
    A pointer to an instance set.
`classDesc`::
    A pointer to a class descriptor. The instance set will contain only
    instances of this class.

The `mrt_InstSetInitialize` function initialized the instance set
data structure pointed to by `set` to prepare it to accept instances
of the class described by `classDesc`.
*****

(((micca,Run Time Function,mrt_InstSetInitialize)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstSetInitialize(
    MRT_InstSet *set,
    MRT_Class const *const classDesc)
{
    assert(classDesc != NULL) ;
    set->classDesc = classDesc ;
    memset(set->instvector, 0, sizeof(set->instvector)) ;
}
----

The primary operation on instance sets is to add an instance.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstSetAddInstance(
    MRT_InstSet *set,
    void *instance) ;
----

`set`::
    A pointer to an instance set.
`instance`::
    A pointer to a class instance to be inserted into the set.

The `mrt_InstSetAddInstance` function inserts `instance` into the
instance set pointed to by `set`.
Attempts to add an instance already in the set are silently ignored.
Attempts to add an instance that is not of the same class for which
the set was initialized is also silently ignored.
*****

(((micca,Run Time Function,mrt_InstSetAddInstance)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstSetAddInstance(
    MRT_InstSet *set,
    void *instance)
{
    assert(instance != NULL) ;
    if (instance == NULL) {
        return ;
    }
    MRT_Instance *instref = instance ;

    assert(instref->classDesc == set->classDesc) ;
    if (instref->classDesc != set->classDesc) {         // <1>
        return ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCE_SET_SIZE) ;
    if (instid >= MRT_INSTANCE_SET_SIZE) {
        mrtFatalError(mrtInstSetOverflow, instid) ;
    }
    set->instvector[instid / MRT_SETWORD_BITS] |=
            (1 << (instid % MRT_SETWORD_BITS)) ;        // <2>
}
----
<1> Make sure we do not add instances of the wrong class.
Instance indices are only unique within a given class.
<2> This bit twiddling selects the correct bit in the correct word
of the bit vector.
The correct word is given by the quotient of the index and the
number of bits in a set vector word.
The correct bit offset within a word is given by the modulus.
We are using divide and modulus operations with the full expectation
that the compiler will recognize, at some level of optimization,
that `MRT_SETWORD_BITS` is a power of two and transform the divide and modulus
into bitwise operations.

We also need a means to remove an instance from the set.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstSetRemoveInstance(
    MRT_InstSet *set,
    void *instance) ;
----

`set`::
    A pointer to an instance set.
`instance`::
    A pointer to a class instance to be inserted into the set.

The `mrt_InstSetRemoveInstance` function removes `instance` from the
instance set pointed to by `set`.
Attempts to remove an instance that is not in the set are silently ignored.
*****

(((micca,Run Time Function,mrt_InstSetRemoveInstance)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstSetRemoveInstance(
    MRT_InstSet *set,
    void *instance)
{
    assert(instance != NULL) ;
    if (instance == NULL) {
        return ;
    }
    MRT_Instance *instref = instance ;

    assert(instref->classDesc == set->classDesc) ;
    if (instref->classDesc != set->classDesc) {
        return ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCE_SET_SIZE) ;
    if (instid >= MRT_INSTANCE_SET_SIZE) {
        mrtFatalError(mrtInstSetOverflow, instid) ;
    }
    set->instvector[instid / MRT_SETWORD_BITS] &=
            ~(1 << (instid % MRT_SETWORD_BITS)) ; // <1>
}
----
<1> More bit twiddling. The bitwise AND of the one's complement of a mask
clears in the result any bit that was set in the mask.

We also provide a test for membership in an instance set.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern bool
mrt_InstSetMember(
    MRT_InstSet *set,
    void *instance) ;
----

`set`::
    A pointer to an instance set.
`instance`::
    A pointer to a class instance to be tested for set membership.

The `mrt_InstSetMember` function determines if `instance` is a
member of the instance set pointed to by `set`.
The instance must be of the same class as that associated with `set`.
The function returns `true` is `instance` is in the set and
`false` otherwise.
*****

(((micca,Run Time Function,mrt_InstSetMember)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_InstSetMember(
    MRT_InstSet *set,
    void *instance)
{
    assert(instance != NULL) ;
    if (instance == NULL) {
        return false ;
    }
    MRT_Instance *instref = instance ;

    assert(instref->classDesc == set->classDesc) ;
    if (instref->classDesc != set->classDesc) {
        return false ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCE_SET_SIZE) ;
    if (instid >= MRT_INSTANCE_SET_SIZE) {
        mrtFatalError(mrtInstSetOverflow, instid) ;
    }
    MRT_SetWord w = set->instvector[instid / MRT_SETWORD_BITS] ;
    MRT_SetWord mask = (1 << (instid % MRT_SETWORD_BITS)) ;

    return (w & mask) != 0 ;
}
----

We also supply set operations, starting with determining if the
instance set is empty.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern bool
mrt_InstSetEmpty(
    MRT_InstSet *set) ;
----

`set`::
    A pointer to an instance set.

The `mrt_InstSetEmpty` returns `true` if the instance set pointed to by
`set` contains no elements and `false` otherwise.
*****

(((micca,Run Time Function,mrt_InstSetEmpty)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_InstSetEmpty(
    MRT_InstSet *set)
{
    assert(set != NULL) ;
    MRT_SetWord *pvect = set->instvector ;
    while (pvect < set->instvector + COUNTOF(set->instvector)) {
        if (*pvect++ != 0) {
            return false ;
        }
    }

    return true ;
}
----

A function to determine the number of members of the instance set is
provided

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern unsigned
mrt_InstSetCardinality(
    MRT_InstSet *set) ;
----

`set`::
    A pointer to an instance set.

The `mrt_InstSetCardinality` returns `true` if the instance set pointed to by
`set` contains no elements and `false` otherwise.
*****

(((micca,Run Time Function,mrt_InstSetCardinality)))
[source,c]
----
<<mrt external functions>>=
unsigned
mrt_InstSetCardinality(
    MRT_InstSet *set)
{
    assert(set != NULL) ;
    unsigned card = 0 ;
    for (MRT_SetWord *pvect = set->instvector ;
            pvect < set->instvector + COUNTOF(set->instvector) ; pvect++) {
        MRT_SetWord w = *pvect ;
        MRT_SetWord mask = 1 ;
        for (unsigned bit = MRT_SETWORD_BITS ; w != 0 && bit != 0 ; bit--) {
            if ((w & mask) != 0) {
                card++ ;
                w &= ~mask ; // <1>
            }
            mask <<= 1 ;
        }
    }

    return card ;
}
----
<1> Once we count the bit, we clear it. This allows us to short circuit
the loop if no other bits in the word are set.

A test for set equality is also supplied.

******
[source,c]
----
<<mrt internal external interfaces>>=
extern bool
mrt_InstSetEqual(
    MRT_InstSet *set1,
    MRT_InstSet *set2) ;
----

`set1`::
    A pointer to an instance set.
`set2`::
    A pointer to an instance set.

The `mrt_InstSetEqual` returns true if instance set `set1` is equal
to instance set `set2` and false otherwise.
If `set1` and `set2` refer to different instance set, then
false is returned.
******

(((micca,Run Time Function,mrt_InstSetEqual)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_InstSetEqual(
    MRT_InstSet *set1,
    MRT_InstSet *set2)
{
    assert(set1 != NULL) ;
    assert(set2 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2->classDesc != NULL) ;

    if (set1->classDesc != set2->classDesc) {
        return false ;
    }

    MRT_SetWord *src1 = set1->instvector ;
    MRT_SetWord *src2 = set2->instvector ;
    while (src1 < set1->instvector + COUNTOF(set1->instvector)) {
        if (*src1++ != *src2++) {
            return false ;
        }
    }

    return true ;
}
----

Basic set operations are also provided.
We start with the set union operation.

******
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstSetUnion(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result) ;
----

`set1`::
    A pointer to an instance set.
`set2`::
    A pointer to an instance set.
`result`::
    A pointer to an instance set where the result is placed.

The `mrt_InstSetUnion` function computes the set union of
`set1` and `set2` storing the result in the set pointed to by `result`.
If `set1` and `set2` do not refer to sets of the same class,
then the result set is the same set as `set1`.
******

(((micca,Run Time Function,mrt_InstSetUnion)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstSetUnion(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ | *src2++ ;
        }
    } else {
        memcpy(result->instvector, set1->instvector, sizeof(result->instvector)) ;
    }
}
----

******
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstSetIntersect(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result) ;
----

`set1`::
    A pointer to an instance set.
`set2`::
    A pointer to an instance set.
`result`::
    A pointer to an instance set where the result is placed.

The `mrt_InstSetIntersect` function computes the set intersection of
`set1` and `set2` storing the result in the set pointed to by `result`.
If `set1` and `set2` do not refer to sets of the same class,
then the returned set is the empty set of the same class as `set1`.
******

(((micca,Run Time Function,mrt_InstSetIntersect)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstSetIntersect(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ & *src2++ ;
        }
    } else {
        memset(result->instvector, 0, sizeof(result->instvector)) ;
    }
}
----

******
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstSetMinus(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result) ;
----

`set1`::
    A pointer to an instance set.
`set2`::
    A pointer to an instance set.
`result`::
    A pointer to an instance set where the result is placed.

The `mrt_InstSetMinus` function computes the set difference
of `set1` minus `set2` (order is significant in this case) storing
the result in the set pointed to by `result`.
If `set1` and `set2` do not refer to sets of the same class,
then the result set is the same as `set1`.
******

(((micca,Run Time Function,mrt_InstSetMinus)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstSetMinus(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ & ~*src2++ ;
        }
    } else {
        memcpy(result->instvector, set1->instvector, sizeof(result->instvector)) ;
    }
}
----

=== Iterating Over Instance Sets

Once we have computed an instance set,
we need some way to iterate over the resulting set.
Since we have chosen a bit vector representation of the set,
the iteration code is slightly more complicated as we must keep track
of which word and bit offset we are currently referring to.
Iterating over instance sets has one additional complication.
It is possible that a class instance referenced in an instance set
has been deleted in the time between when the instance set was accumulated
and the time when the iteration across the set occurs.
So,
iterating over instance set must also guard against an instance that,
although it may be a member of the set, has been deleted between the
time the set was constructed and the time that the iteration occurs.

First, we start with the iterator data structure.
This holds the state information we need to determine our place in the
set.

(((micca,Run Time Data,MRT_InstSetIterator)))
[source,c]
----
<<mrt interface aggregate types>>=
struct mrtinstsetiterator ;
typedef struct mrtinstsetiterator MRT_InstSetIterator ;

<<mrt internal aggregate types>>=
struct mrtinstsetiterator {
    MRT_InstSet *set ;
    void *instance ;
    MRT_SetWord *vectorloc ;
    unsigned bitoffset ;
} ;
----

`set`::
    A pointer to the instance set across which the iteration will occur.
`instance`::
    A pointer to the current instance of the iteration.
`vectorloc`::
    A pointer to the word within the instance set where the current instance
    is located.
`bitoffset`::
    The bit offset into the word pointed to by `vectorloc` that represents
    the current instance of the iteration.

The operations on the iteration follow our usual pattern of
Begin, More, Next and Get.

******
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstSetIterBegin(
    MRT_InstSet *set,
    MRT_InstSetIterator *iter) ;
----

`set`::
    A pointer to an instance set across which the iteration will occur.
`iter`::
    A pointer to an instance set iterator which will hold the state of the
    iteration.

The `mrt_InstSetIterBegin` initializes the set iterator pointed to
by `iter` in order to iterate across the instance set pointed to by `set`.
This function must be called first to prepare an iteration across an
instance set.
******

(((micca,Run Time Function,mrt_InstSetIterBegin)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstSetIterBegin(
    MRT_InstSet *set,
    MRT_InstSetIterator *iter)
{
    assert(set != NULL) ;
    assert(iter != NULL) ;

    iter->set = set ;
    iter->vectorloc = set->instvector ;
    iter->bitoffset = 0 ;
    if ((*iter->vectorloc & 1) == 0) { // <1>
        mrt_InstSetIterNext(iter) ;
    } else {
        iter->instance = mrtIndexToInstance(iter->set->classDesc, 0) ;
        if (iter->instance == NULL) { // <2>
            mrt_InstSetIterNext(iter) ;
        }
    }
}
----
<1> Check if the first instance belongs to the set. If not, we want to
advance the iterator until we have a valid set member.
<2> Check if the set instance is still actively being used. If not,
we want to advance the iterator to one that is.

******
[source,c]
----
<<mrt internal external interfaces>>=
extern bool
mrt_InstSetIterMore(
    MRT_InstSetIterator *iter) ;
----

`iter`::
    A pointer to an instance set iterator.

The `mrt_InstSetIterMore` function returns `true` if there are
more instances to visit in the instance set referenced by `iter` and
`false` otherwise.
******

(((micca,Run Time Function,mrt_InstSetIterMore)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_InstSetIterMore(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance != NULL ;
}
----

******
[source,c]
----
<<mrt internal external interfaces>>=
extern void *
mrt_InstSetIterGet(
    MRT_InstSetIterator *iter) ;
----

`iter`::
    A pointer to an instance set iterator.

The `mrt_InstSetIterGet` function obtains the current instance from the
instance set referenced by `iter`.
It is not valid to invoke this function after `mrt_InstSetIterMore`
returns `false`.
******

(((micca,Run Time Function,mrt_InstSetIterGet)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_InstSetIterGet(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    assert(iter->instance != NULL) ;
    return iter->instance ;
}
----

******
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_InstSetIterNext(
    MRT_InstSetIterator *iter) ;
----

`iter`::
    A pointer to an instance set iterator.

The `mrt_InstSetIterNext` function advances the set iterator pointed to by
`iter` to the next element of the set.
******

Advancing the iterator is a more complicated operation.
We must account for the word boundaries in the bit vector as well as
the number of bits in each of the vector words.
Finally, we must also make sure the next element of the set is still
a valid, allocated instance of the class.

(((micca,Run Time Function,mrt_InstSetIterNext)))
[source,c]
----
<<mrt external functions>>=
void
mrt_InstSetIterNext(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    
    iter->bitoffset++ ; //<1>
    if (iter->bitoffset >= MRT_SETWORD_BITS) {
        iter->vectorloc++ ;
        iter->bitoffset = 0 ;
    }
    while (iter->vectorloc <
            iter->set->instvector + COUNTOF(iter->set->instvector)) {
        if (*iter->vectorloc != 0) { // <2>
            MRT_SetWord mask = 1 << iter->bitoffset ;
            for ( ; iter->bitoffset < MRT_SETWORD_BITS ; iter->bitoffset++) {
                if ((*iter->vectorloc & mask) != 0) { // <3>
                    unsigned instindex =
                        (iter->vectorloc - iter->set->instvector) *
                        MRT_SETWORD_BITS + iter->bitoffset ; // <4>
                    void *instance = mrtIndexToInstance(iter->set->classDesc,
                            instindex) ;
                    if (instance != NULL) { // <5>
                        iter->instance = instance ;
                        return ;
                    }
                }
                mask <<= 1 ;
            }
        }
        iter->vectorloc++ ; // <6>
        iter->bitoffset = 0 ;
    }

    iter->instance = NULL ;
}
----
<1> Advance the iterator by one bit in the bit vector,
accounting for running off the end of the vector word.
<2> A simple test determines if we can skip the entire word of bits.
<3> Check if we have found a set bit in the bit vector.
This indicates that the corresponding instance is a member of the set.
<4> Compute the index of the instance in bit vector.
This is the same to the index of the instance in the storage array.
<5> Verify that the instance was not deleted between the time the
set was build and the time the iteration across the set happens.
<6> Advance to the next word of the bit vector.

== Managing Referential Integrity

When the target translation platform is based on a Relational Database
Management System (RDMS) or some other data architecture that
supports the relational model of data (_e.g._ `rosea` or TclRAL),
referential integrity checking comes with the underlying data management
facilities.
Such data management facilities constrain the values of data and
move much of the data integrity validation away from the runtime code.
Such is the motivation to use these facilities since they replace
application code with declarative specifications of validity.

When targeting static-typed languages such as ``C'',
translation platforms frequently do not offer any help in insuring
referential integrity of the data as the system runs.
Sometimes this limitation is understandable.
It takes more code and data space to deal with referential integrity.
For applications that do little dynamic instance creation or relationship
changes,
the risk that some code path results in a violation of
referential integrity is much less.
Nonetheless,
execution platforms that do not provide any referential integrity checks
impose a significant burden on the programmer and result in
systems that are potentially less reliable.

In `micca`,
we will support detection of referential integrity violations.
As we will see,
there is considerable complexity in achieving this goal.
To be clear,
this is what `micca` supports.

* Integrity constraints implied by the associations and generalizations
supplied in the configuration DSL will be checked at run-time.
* Violations of referential integrity will result in a fatal system error.
There is no support for rolling back data values to a known good state
or ignoring the error and proceeding anyway.
* Integrity constraints are checked at the end of transactions on the
data model.
The duration of the transaction is not under direct program control,
but there is an ongoing
transaction when a thread of control is executing.
A thread of control is defined to be the duration of the dispatch
of the set of events initiated by an event signaled from outside of a
state activity or by the delivery of a delayed event.
We discuss the thread of control concept in more detail below
when we deal with managing execution.

Because of our design choice to use the address of a class instance as
an identifier,
to manage referential integrity we need:

* Functions to create, delete and update reference pointers that implement
relationships.
* Data structures and values that encode the specifications of the
relationships from the platform model.
* Run-time code that, using the relationship specifications, evaluates
whether referential integrity was maintained.

In keeping with our goal that the run-time be completely data driven,
the code generator will supply the necessary information about all the
associations and generalizations in the domain.
This will allow us to manipulate the pointer values used in the relationships
and to check that the result does not violate any of the
multiplicity and conditionality constraints specified for the
relationship.

We will show how this is accomplished by:

. Showing the data structures used to describe relationships.
. Explaining how transactions work and how referential integrity is checked.
. Giving code to relate and unrelate instances in a relationship that
operates with the integrity check.

=== Describing Relationships

In this section we present the data structures that are supplied
by the `micca` code generator to describe the properties of a relationship.
You can think of these data structures as an implementation version
of the various classes in the platform model that deal with
class relationships.
The code generator takes data from the platform model population that
was created during domain configuration and generates
initialized ``C'' variables of the types described below.

From the <<relationship-subsystem,platform model>>,
we know that there are four different types of relationships.

(((micca,Run Time Data,MRT_RelType)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef enum {
    mrtSimpleAssoc,
    mrtClassAssoc,
    mrtRefGeneralization,
    mrtUnionGeneralization
} MRT_RelType ;
----

The combination of the conditionality and multiplicity of a relationship
can be encoded in four values.

(((micca,Run Time Data,MRT_Cardinality)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef enum {
    mrtAtMostOne = 0,
    mrtExactlyOne,
    mrtZeroOrMore,
    mrtOneOrMore
} MRT_Cardinality ;
----

There are also three different ways that pointer references are stored.

(((micca,Run Time Data,MRT_RefStorageType)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef enum {
    mrtSingular,
    mrtArray,
    mrtLinkedList
} MRT_RefStorageType ;
----

For singular references,
a single pointer member is allocated in the class structure.

For array reference storage,
the class structure member is a counted array of the type shown below:

(((micca,Run Time Data,MRT_ArrayRef)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtarrayref {
    MRT_Instance * const *links ;
    unsigned count ;
} MRT_ArrayRef ;
----

For linked list reference storage,
the referring class has a set of link pointers that serve as the
terminus for the linked list.
In addition,
the referenced class has a set of link pointers that enable it to
be linked into the list of instances headed by the referring class.

(((micca,Run Time Data,MRT_LinkRef)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtlinkref {
    struct mrtlinkref *next ;
    struct mrtlinkref *prev ;
} MRT_LinkRef ;
----

==== Association Participants

To characterize the role a participant class in an association plays,
the following data is needed.

(((micca,Run Time Data,MRT_AssocRole)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtassociationrole {
    MRT_Class const *classDesc ;
    MRT_Cardinality cardinality ;
    MRT_RefStorageType storageType ;
    MRT_AttrOffset storageOffset ;
    MRT_AttrOffset linkOffset ;
} MRT_AssociationRole ;
----

`classDesc`::
    A pointer to the class data for the participant.
`cardinality`::
    The encoding of the conditionality and multiplicity of the relationship.
    This encoding is from point of view of how many references to the
    participant that are made by the other participant in the relationship.
`storageType`::
    An encoding of the structure of how the reference pointers are stored.
`storageOffset`::
    The offset in bytes from the beginning of an instance to where the
    reference pointers for the relationship are stored.
`linkOffset`::
    For participants whose value of `storageType` is `mrtLinkedList`,
    this member gives the number of bytes from the beginning of the
    target participant instance where the linked list pointers are stored.
    For other values of `storageType` the value is ignored.

==== Simple Associations

Simple associations are made up of a source and target.
The forward direction of a simple association is from the source instance
to the target instance.

(((micca,Run Time Data,MRT_SimpleAssociation)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtsimpleassociation {
    MRT_AssociationRole source ;
    MRT_AssociationRole target ;
} MRT_SimpleAssociation ;
----

==== Class Based Associations

For class based associations,
there is another role played by the associator class.
Associator classes always have two singular references to the
participant classes.

(((micca,Run Time Data,MRT_AssociatorRole)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtassociatorrole {
    MRT_Class const *classDesc ;
    MRT_AttrOffset forwardOffset ;
    MRT_AttrOffset backwardOffset ;
    bool multiple ;
} MRT_AssociatorRole ;
----

`classDesc`::
    A pointer to the class data for the participant.
`forwardOffset`::
    The offset in bytes from the begining of an instance of the
    associator class to the forward reference pointer.
    The forward reference pointer refers to a class instance that
    serves as the target of the association.
`backwardOffset`::
    The offset in bytes from the begining of an instance of the
    associator class to the backward reference pointer.
    The backward reference pointer refers to a class instance that
    serves as the source of the association.
`multiple`::
    A boolean value that specifies if the same instances are allowed
    to be referenced by multiple association classes.

A class based association has descriptive information on all three
class roles.

(((micca,Run Time Data,MRT_ClassAssociation)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtclassassociation {
    MRT_AssociationRole source ;
    MRT_AssociationRole target ;
    MRT_AssociatorRole associator ;
} MRT_ClassAssociation ;
----

==== Superclasses in a Generalization

The information needed to describe a superclass in a generalization
is the same for both reference and union based generalizations.

(((micca,Run Time Data,MRT_SuperClassRole)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtsuperclassrole {
    MRT_Class const *classDesc ;
    MRT_AttrOffset storageOffset ;
} MRT_SuperClassRole ;
----

`classDesc`::
    A pointer to the class data for the participant.
`storageOffset`::
    The offset in bytes from the beginning of a superclass
    instance to where subclass information is stored.
    The information stored at `storageOffset` with either be a
    reference to the subclass instance (for reference based
    generalizations) or the union of the subclass structures in the
    generalization (for union based generalizations).

==== Reference Generalizations

For generalization relationships implemented by pointer references,
the superclass implements its reference to a subclass by holding a
simple pointer to the subclass instance.
It is possible for the superclass to determine the type of the
related subclass by simply following the reference to the subclass
and then examining the `classDesc` member of the instance.
data structure.

The information needed to describe the role of the subclass in a
reference generalization is:

(((micca,Run Time Data,MRT_RefSubClassRole)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtrefsubclassrole {
    MRT_Class const *classDesc ;
    MRT_AttrOffset storageOffset ;
} MRT_RefSubClassRole ;
----

`classDesc`::
    A pointer to the class data for the participant.
`storageOffset`::
    The offset in bytes from the beginning of a reference subclass
    instance to where the reference to its related superclass is stored.
    The structure member found at `storageOffset` from the beginning of
    the instance is a pointer to the superclass instance.

A reference generalization relationship can be described by its
superclass role information and the set of subclass roles for the
subclasses that participate in the generalization.
We store the subclass role set as a count and pointer to a corresponding
array.

(((micca,Run Time Data,MRT_RefGeneralization)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtrefgeneralization {
    MRT_SuperClassRole superclass ;
    unsigned subclassCount ;
    MRT_RefSubClassRole const *subclasses ;
} MRT_RefGeneralization ;
----

==== Union Generalizations

A union generalization results in subclass instances being held as a union in
the superclass instance structure.
From the superclass perspective,
the information needed to describe where the subclass is stored is
the same as for a reference supertype.
The only difference is that `storageOffset` is an offset to the
union holding the subclass rather than a reference pointer to a subclass.

Subclass instances held in union generalizations do not have a
pointer back to their related superclasses.
The related superclass can be determined by pointer arithmetic (_i.e._
subtracting the superclass `storageOffset` from the subclass instance pointer).
So the role information for a union subclass is nothing more than
a pointer to its class descriptor

Similar to the reference generalization,
the union generalization information consists of that for the
superclass an a set of subclass role information values.

(((micca,Run Time Data,MRT_UnionGeneralization)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtuniongeneralization {
    MRT_SuperClassRole superclass ;
    unsigned subclassCount ;
    MRT_Class const * const *subclasses ;
} MRT_UnionGeneralization ;
----

==== Relationship Properties

Finally,
the relationship data is held as a discriminated union.
There is a type field and a union of four structures for the
specific information required to describe each type of relationship.

(((micca,Run Time Data,MRT_Relationship)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtrelationship {
    MRT_RelType relType ;
    union {
        MRT_SimpleAssociation simpleAssociation ;
        MRT_ClassAssociation classAssociation ;
        MRT_RefGeneralization refGeneralization ;
        MRT_UnionGeneralization unionGeneralization ;
    } relInfo ;

#       ifndef MRT_NO_NAMES
    char const *name ;
#       endif /* MRT_NO_NAMES */
} MRT_Relationship ;
----

`relType`::
    A value to indicate the type of the relationship.
`relInfo`::
    A union of the various types of relationship information structures
    that describes the details of the relationship.
    The union must be interpreted according to the value of the `relType`
    member.
`name`::
    The name of the relationship.

=== Data Transactions

To check referential integrity,
it is necessary to introduce the concept of a transaction on the
domain data model.
The transaction concept is necessary because we must be able to defer
the integrity check until such time as the domain activities can insure
that the integrity constraints are met.
For example,
consider two classes in a one-to-one unconditional relationship.
If an instance of one class is created we do not want to check referential
integrity until the code has had an opportunity to create a corresponding
instance of the associated class.

The precise rules of data integrity are that each state activity must
leave the domain data in a consistent state or signal one or more events
that, when dispatched, will ultimately bring the domain data into a
consistent state.
The later phrase of this rule implies that there is a _thread of control_
which determines the boundary of when data consistency is checked.
We will describe how threads of control work later.
For now,
we are concerned with data transactions as a means of deciding when
data integrity is to be verified.

Each time a relationship is manipulated, by:

.. creating instances that participate in a relationship
.. deleting instances that participate in a relationship
.. updating references between participating instances
.. reclassifying subclass instances in a generalization

the relationship pointer references must be verified.
As described below,
the run-time provides functions to perform the relationship pointer
operations.
During a transaction,
we want to save a reference to the relationship information
for each relationship that is manipulated.
We save the affected relationships in the following structure.

[source,c]
----
<<mrt implementation aggregate types>>=
struct mrtTransaction {
    unsigned count ;
    MRT_Relationship const *relationships[MRT_TRANSACTION_SIZE] ;
} ;
----

Like all run-time resources,
the memory allocated to them is fixed at compile time.

(((micca,Run Time Constant,MRT_TRANSACTION_SIZE)))
[source,c]
----
<<mrt interface constants>>=
#ifndef MRT_TRANSACTION_SIZE
#   define MRT_TRANSACTION_SIZE 64
#endif /* MRT_TRANSACTION_SIZE */
----

We use a static variable to hold the transaction relationships.

(((micca,Run Time Data,mrtTransaction)))
[source,c]
----
<<mrt static data>>=
static struct mrtTransaction mrtTransaction ;
----

During a transaction,
run-time functions that either modify the relationship pointer storage
or change the number of active instances invoke
`mrtMarkRelationship` to save away the relationships that will need to
be checked at the end of the transaction.
This prevents us from having to check every relationship at the end
of every transaction.

The only complication in the marking algorithm is that we wish to
maintain the marked relationship descriptions as a set with no duplicates.
Modifying instances of relationships multiple times during the
transaction does not mean we need to evaluate the referential integrity
more than once.
We wish to save that computation and consequently will search the
marked relationships to eliminate any duplicate mark.

[source,c]
----
<<mrt forward references>>=
static void
mrtMarkRelationship(
    MRT_Relationship const *const *rel,
    unsigned relCount) ;
----

(((micca,Run Time Function,mrtMarkRelationship)))
[source,c]
----
<<mrt static functions>>=
static void
mrtMarkRelationship(
    MRT_Relationship const * const *rel,
    unsigned relCount)
{
    for ( ; relCount != 0 ; relCount--, rel++) {
        bool found = false ;
        MRT_Relationship const **marked = mrtTransaction.relationships ;
        for (unsigned markedCount = mrtTransaction.count ; markedCount != 0 ;
                markedCount--, marked++) { // <1>
            if (*marked == *rel) {
                found = true ;
                break ;
            }
        }

        if (!found) {
            if (mrtTransaction.count >= COUNTOF(mrtTransaction.relationships)) {
                mrtFatalError(mrtTransOverflow) ; // <2>
            }
            mrtTransaction.relationships[mrtTransaction.count++] = *rel ;
        }
    }
}
----
<1> First we iterate over the set of relationship description pointers
already marked to see if we can find a match to the one we are trying
to insert.
<2> Since we are about to insert a new relationship description,
we have to check for overflow.
As usual, exceeding resource limits is a fatal error.

At the end of a transaction,
we iterate across all the relationship descriptions that were
saved during the transaction and check the referential integrity
of the stored pointers.

(((micca,Run Time Function,mrtEndTransaction)))
[source,c]
----
<<mrt forward references>>=
static void mrtEndTransaction(void) ;

<<mrt static functions>>=
static void
mrtEndTransaction(void)
{
    MRT_Relationship const **rships = mrtTransaction.relationships ;
    for (unsigned count = 0 ; count < mrtTransaction.count ; count++, rships++) {
        MRT_Relationship const *rel = *rships ;

        if (!mrtCheckRelationship(rel)) {
            mrtTransaction.count -= count ;
            memmove(mrtTransaction.relationships, rships,
                mrtTransaction.count * sizeof(*rships)) ; // <1>
            mrtRefIntegrityError(rel) ;
        }
    }
    mrtTransaction.count = 0 ;
}
----
<1> We "shuffle up" the contents of the transaction relationships array
before giving up with a fatal error.
The reason for this is that it is possible to install a fatal error handler
that long jumps out of the event loop.
We don't want to remove the relationship that failed from the transaction list,
but all those that have passed the integrity check need to be discarded.
It is possible for a fatal error that has long jumped out of the event
loop to repair the damage and want to continue on.
This is certainly the case when we are testing the run-time code itself.
Test cases know what problem they have created and can correct it
so that subsequenct tests can proceed along.
However, the failed relationships will still be checked at the next
end of transaction time.
So we insure that any recovery of the integrity check happened correctly.

==== Verifying Referential Integrity

At the end of a transaction on the data model,
`mrtEndTransaction` iterates across the set of saved relationship
descriptors and checks the relationship to insure the data model
is in a consistent state.
The design approach is to use the `refCount` member of each instance
as a place to store how many times the instance is referred to by
the other participant in the relationship.
Knowing the cardinality of the relationship,
we can evaluate the `refCount` values to determine if referential integrity has
been maintained.

The overall steps are:

. Zero out the `refCount` member of all instances of both participating
classes.
. Using the relationship description information,
find the reference pointers in the class instance that refer to the
other participating class instances and increment the `refCount` member in
the other participating instance if its pointer is found.
This is done for both participants in the relationship.
. Evaluate the `refCount` value against what the cardinality of the
relationship requires.

This algorithm must be generic and capable of operating on any class instance.
This will mean that there will be a lot of pointer arithmetic using
offsets to structure members and other
type unsafe operationsfootnote:[By _type unsafe_ we mean that the operations
cannot be checked by the compiler to insure the type system isn't violated.
The code itself is still standard ``C'' with well defined behavior.]
happening in the code.
Sometimes ``C'' as a language is accused of being little more than a
high level assembler and it is those type unsafe facilities
that we must employ here to obtain a single body of code that can
operate on an arbitrary class instance.

[source,c]
----
<<mrt forward references>>=
static bool mrtCheckRelationship(MRT_Relationship const *rel) ;
----

The `mrtCheckRelationship` function returns a boolean value indicating
if the relationship described by `rel` has correct referential integrity.

Since there are four types of relationships in terms of how the
reference pointers are stored,
the function considers each type separately.

(((micca,Run Time Function,mrtCheckRelationship)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtCheckRelationship(
    MRT_Relationship const *rel)
{
    bool result = false ;

    switch (rel->relType) {
    case mrtSimpleAssoc: {
        <<mrtCheckRelationship: simple associations>>
    }
        break ;

    case mrtClassAssoc: {
        <<mrtCheckRelationship: class based associations>>
    }
        break ;

    case mrtRefGeneralization: {
        <<mrtCheckRelationship: reference generalizations>>
    }
        break ;

    case mrtUnionGeneralization: {
        <<mrtCheckRelationship: union generalizations>>
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }

    return result ;
}
----

For simple associations,
we zero out the `refCount` member.
The references between the class instances are tracked
and then the values of the `refCount` members are compared against
what the relationship requires.
We do this in two steps, first tracking from source to target and
then tracking from target to source.
The reason for dividing it this way is to avoid stomping on the
`refCount` in the case of a reflexive association.
Since there is only one `refCount` member, we have to zero it,
count the references and check the counts completely for one side
before doing the same for the other.
In a reflexive association, each side is the same class and so
the `refCount` member is actually the same memory location
for both sides.

[source,c]
----
<<mrtCheckRelationship: simple associations>>=
MRT_SimpleAssociation const *assoc = &rel->relInfo.simpleAssociation ;

MRT_Class const *const targetClass = assoc->target.classDesc ;
mrtZeroRefCounts(targetClass) ;                                     // <1>
mrtCountAssocRefs(&assoc->source, targetClass) ;                    // <2>

result = mrtCheckRefCounts(targetClass, assoc->target.cardinality) ;
if (!result) {
    break ;
}

MRT_Class const *const sourceClass = assoc->source.classDesc ;  // <3>
mrtZeroRefCounts(sourceClass) ;
mrtCountAssocRefs(&assoc->target, sourceClass) ;
result = mrtCheckRefCounts(sourceClass, assoc->source.cardinality) ;
----
<1> Start with the class that is the target of the association
navigation.
<2> Count in the target side for each source side that references it.
<3> Now flip it around and do the target to source traversal.

Class based associations are more complicated.
Recall that class based associations are treated in a decomposed manner
where each side is related to the associator class and the associator
class is unconditionally and singularly related to each participant.
So we will consider each side separately.

[source,c]
----
<<mrtCheckRelationship: class based associations>>=
MRT_ClassAssociation const *assoc = &rel->relInfo.classAssociation ;

result = mrtCheckAssociatorRefs(&assoc->associator) ; // <1>
if (!result) {
    break ;
}
/*
 * On the first side, we evaluate the references from the source class
 * to the associator class.
 */
MRT_Class const *const assocClass = assoc->associator.classDesc ;
MRT_Class const *const sourceClass = assoc->source.classDesc ;

mrtZeroRefCounts(sourceClass) ;
mrtCountSingularRefs(assocClass, assoc->associator.backwardOffset,
        sourceClass) ;

result = mrtCheckRefCounts(sourceClass, assoc->source.cardinality) ;
if (!result) {
    break ;
}

mrtZeroRefCounts(assocClass) ;
mrtCountClassAssocRefs(&assoc->source, assocClass) ;

result = mrtCheckRefCounts(assocClass, mrtExactlyOne) ;
if (!result) {
    break ;
}
/*
* If the first side is okay, then we can evaluate the references from
* the target class to the associator class.
*/
MRT_Class const *const targetClass = assoc->target.classDesc ;

mrtZeroRefCounts(targetClass) ;
mrtCountSingularRefs(assocClass, assoc->associator.forwardOffset,
        targetClass) ;

result = mrtCheckRefCounts(targetClass, assoc->target.cardinality) ;
if (!result) {
    break ;
}

mrtZeroRefCounts(assocClass) ;
mrtCountClassAssocRefs(&assoc->target, assocClass) ;
result = mrtCheckRefCounts(assocClass, mrtExactlyOne) ;
----
<1> We start by checking the singular references from the associator
class to the two participants.

Since a generalization represents a disjoint union between between the
superclass and the set of subclasses,
each superclass instance must be referenced exactly once from among all
the subclasses of the generalization.
Conversely,
each subclass must reference exactly one superclass instance.
This means we will have to iterate over the subclasses as we zero out
the `refCount` member and count the references.

[source,c]
----
<<mrtCheckRelationship: reference generalizations>>=
MRT_RefGeneralization const *gen = &rel->relInfo.refGeneralization ;

mrtZeroRefCounts(gen->superclass.classDesc) ;

MRT_RefSubClassRole const *subclass = gen->subclasses ;
for (unsigned subcount = gen->subclassCount ; subcount != 0 ;
        subcount--, subclass++) {
    mrtZeroRefCounts(subclass->classDesc) ;
}

mrtCountGenRefs(gen) ;

result = mrtCheckRefCounts(gen->superclass.classDesc, mrtExactlyOne) ;
subclass = gen->subclasses ;
for (unsigned subcount = gen->subclassCount ; subcount != 0 && result ;
        subcount--, subclass++) {
    result = mrtCheckRefCounts(subclass->classDesc, mrtExactlyOne) ;
}
----

When a generalization is stored in a union,
there are no reference pointers.
So we don't have to follow any pointers to get to the subclass.
Rather, the subclass in part of the superclass storage and
pointer arithmetic computes the address of the subclass instance.

[source,c]
----
<<mrtCheckRelationship: union generalizations>>=
MRT_UnionGeneralization const *gen = &rel->relInfo.unionGeneralization ;

mrtZeroRefCounts(gen->superclass.classDesc) ;
assert(gen->subclassCount != 0) ;
mrtZeroRefCounts(*gen->subclasses) ;                                    // <1>

mrtCountUnionRefs(gen) ;                                                // <2>

result = mrtCheckRefCounts(gen->superclass.classDesc, mrtExactlyOne) &&
        mrtCheckRefCounts(*gen->subclasses, mrtExactlyOne) ;            // <3>
----
<1> Since we know that the subclass storage is allocated as part of
the superclass instance, we only have to zero out the reference
counter for one of the subclasses.
This is because all the subclasses are at the same address and all
start with a `MRT_Instance` structure.
<2> We need a different counting strategy to account for the union storage.
<3> Again, since all the subclasses are stored in the same place
and all begin with a `MRT_Instance` structure, we only have to
count for one subclass.
Compare this to the reference case, where we have visit each subclass
instance and follow its reference back to the superclass instance

[float]
===== Zero Reference Counts

The first of the generic operations that must be performed on
class instances is to set the `refCount` member of the instance
structure to zero.

[source,c]
----
<<mrt forward references>>=
static void mrtZeroRefCounts(MRT_Class const *const classDesc) ;
----

The algorithm is simple.
We iterate over all the class instances and set the `refCount` member to
zero.

(((micca,Run Time Function,mrtZeroRefCounts)))
[source,c]
----
<<mrt static functions>>=
static void
mrtZeroRefCounts(
    MRT_Class const *const classDesc)
{
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, classDesc) ; mrt_InstIteratorMore(&iter) ;
            mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        instref->refCount = 0 ;
    }
}
----

[float]
===== Checking Reference Counts

The other operation that depends only upon accessing the `refCount` member
of an instance is to evaluate the value of `refCount` against what
the cardinality of the relationship.
There are four possible values of the cardinality.
One of the values, `mrtZeroOrMore`, implies that any value of
`refCount` is satisfactory since `refCount` is defined as an unsigned
quantity and must, necessarily, be greater than or equal to zero.

For the other three values of cardinality we define functions to
perform the comparison.

(((micca,Run Time Function,mrtCompareAtMostOne)))
(((micca,Run Time Function,mrtCompareExactlyOne)))
(((micca,Run Time Function,mrtCompareOneOrMore)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtCompareAtMostOne(
    unsigned refCount)
{
    return refCount <= 1 ;
}

static bool
mrtCompareExactlyOne(
    unsigned refCount)
{
    return refCount == 1 ;
}

static bool
mrtCompareOneOrMore(
    unsigned refCount)
{
    return refCount >= 1 ;
}
----

The reference counts are checked by iterating over the instances
and invoking the proper cardinality comparison function.
The first failure means we can stop.

[source,c]
----
<<mrt forward references>>=
static bool
mrtCheckRefCounts(MRT_Class const *const classDesc, MRT_Cardinality cardinality) ;
----

(((micca,Run Time Function,mrtCheckRefCounts)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtCheckRefCounts(
    MRT_Class const *const classDesc,
    MRT_Cardinality cardinality)
{
    if (cardinality == mrtZeroOrMore) { // <1>
        return true ;
    }

    static bool (*const compareFuncs[])(unsigned) = {
        [mrtAtMostOne] = mrtCompareAtMostOne,
        [mrtExactlyOne] = mrtCompareExactlyOne,
        [mrtZeroOrMore] = NULL, // <2>
        [mrtOneOrMore] = mrtCompareOneOrMore
    } ;

    assert(cardinality <= mrtOneOrMore) ;
    bool (*const compareCardinality)(unsigned) = compareFuncs[cardinality] ; // <3>

    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, classDesc) ; mrt_InstIteratorMore(&iter) ;
            mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        if (!compareCardinality(instref->refCount)) {
            return false ; // <4>
        }
    }

    return true ;
}
----
<1> Dispense with the always true case first. There is no reason
to iterate through the instances when the result is always true.
<2> We could omit this and it would be set to zero like any other
uninitialized static variable.
We include it to make clear that that we have accounted for all the cases
and have factored out the `mrtZeroOrMore` case above.
<3> Select the comparison function based on the encoded cardinality.
A small table of pointers to the comparison functions is handy to do this.
<4> We need not go past the first failure.

The singular references made by associator classes are special in the
sense that they should never be `NULL`.
Unrelating class based associations will set those references to `NULL` and
we need to make sure that either the associator instance was reused by
relating to other instances or it was deleted.

[source,c]
----
<<mrt forward references>>=
static bool
mrtCheckAssociatorRefs(MRT_AssociatorRole const *associator) ;
----

(((micca,Run Time Function,mrtCheckAssociatorRefs)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtCheckAssociatorRefs(
    MRT_AssociatorRole const *associator)
{
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, associator->classDesc) ;
            mrt_InstIteratorMore(&iter) ; mrt_InstIteratorNext(&iter)) {
        void *inst = mrt_InstIteratorGet(&iter) ;
        MRT_Instance *ref = *(MRT_Instance **)
                ((uintptr_t)inst + associator->forwardOffset) ;
        if (ref == NULL || ref->alloc <= 0) { // <1>
            return false ;
        }
        ref = *(MRT_Instance **)((uintptr_t)inst + associator->backwardOffset) ;
        if (ref == NULL || ref->alloc <= 0) {
            return false ;
        }
    }

    return true ;
}
----
<1> Reference pointers in an associator class must be non-NULL and must
point to an allocated instance.

==== Counting References

Of the four types of relationships,
three of them actually contain pointer values that refer to class instances.
The differences in the manner in which the three pointer references are
organized leads us have separate functions for each type.

First we consider counting the references in a simple association.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountAssocRefs(
    MRT_AssociationRole const *source,
    MRT_Class const *const targetClass) ;
----

The `mrtCountAssocRefs` function counts the number of times each
active instance of `source` refers to active instances of `targetClass`.

Counting references implies understanding how the reference pointers are
stored.
There are three ways that reference pointers are stored:
single pointer, counted arrays and linked lists.
We use the knowledge of offsets in the instance to
where the pointer values are stored to access target instances.

(((micca,Run Time Function,mrtCountAssocRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountAssocRefs(
    MRT_AssociationRole const *source,
    MRT_Class const *const targetClass)
{
    switch (source->storageType) {
    case mrtSingular:
        mrtCountSingularRefs(source->classDesc, source->storageOffset,
            targetClass) ;
        break ;

    case mrtArray:
        mrtCountArrayRefs(source->classDesc, source->storageOffset,
            targetClass) ;
        break ;

    case mrtLinkedList:
        mrtCountLinkedListRefs(source->classDesc, source->storageOffset,
                targetClass, source->linkOffset) ;
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
----

We will now show how the references stored in the three types are counted.
For singular references, the reference is a pointer to the related
class instance.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountSingularRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *const targetClass) ;
----

`sourceClass`::
    A pointer to the class description block for the class instances
    that make a singular reference to target instances.
`offset`::
    The offset in bytes from the beginning of source instances to
    where the pointer to the target instance is located.
`targetClass`::
    A pointer to the class description for the class instances
    to which the source instances refer.

The `mrtCountSingularRefs` functions iterates across all the active
`source` instances, accesses the pointer in the source instance
and increments the `refCount` member in the referenced target instance.

(((micca,Run Time Function,mrtCountSingularRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountSingularRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *const targetClass)
{
    MRT_iab *targetiab = mrtGetStorageProperties(targetClass, NULL) ;

    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&srciter) ;
        MRT_Instance *targetInst =
                *(MRT_Instance **)((uintptr_t)instref + offset) ;
        if ((void *)targetInst >= targetiab->storageStart &&
                (void *)targetInst < targetiab->storageFinish &&
                targetInst->alloc > 0) { // <1>
            targetInst->refCount = targetInst->refCount == UINT8_MAX ?
                    2 : targetInst->refCount + 1 ; // <2>
        }
    }
}
----
<1> Validate that the reference pointer value actually points into
target instance storage. This will eliminate any NULL values also.
Note we also insist that the target instance be active.
<2> We want to avoid the possibility of overflow of the reference counter.
It is only an unsigned 8-bit quantity.
Should it overflow, we could misinterpret the count.
If we are at its max value, then we set it back to 2.
Why 2? Zero and one are significant in this case and we know the values
has already passed two, so we resume our count from there.
Any value greater than 1 will yield the same conclusion about
the referential integrity.

For array references, the references are an array of pointers to the related
class instance.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountArrayRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *const targetClass) ;
----

`sourceClass`::
    A pointer to the class description block for the class instances
    that make an array reference to target instances.
`offset`::
    The offset in bytes from the beginning of source instances to
    where the pointer array to the target instance is located.
`targetClass`::
    A pointer to the class description for the class instances
    to which the source instances refer.

The `mrtCountArrayRefs` functions iterates across all the active
`source` instances, accesses the pointer in the source instance
and increments the `refCount` member in the referenced target instance.

(((micca,Run Time Function,mrtCountArrayRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountArrayRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *const targetClass)
{
    MRT_iab *targetiab = mrtGetStorageProperties(targetClass, NULL) ;

    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&srciter) ;
        MRT_ArrayRef *srcrefs =
                (MRT_ArrayRef *)((uintptr_t)instref + offset) ;
        MRT_Instance *const *iter = srcrefs->links ;
        for (unsigned count = srcrefs->count ; count != 0 ; count--, iter++) {
            MRT_Instance *targetInst = *iter ;
            if ((void *)targetInst >= targetiab->storageStart &&
                    (void *)targetInst < targetiab->storageFinish &&
                    targetInst->alloc > 0) {
                targetInst->refCount = targetInst->refCount == UINT8_MAX ?
                        2 : targetInst->refCount + 1 ;
            }
        }
    }
}
----

The structure of the linked list pointers makes counting them
a bit more complicated.
We must know the offset within the source instance where the link
list terminus is located.
Since the link pointers in the target are embedded somewhere in the target
instance structure,
we need to know the offset into the target instance that the links point to
in order recover a pointer to the beginning of the target instance..

[source,c]
----
<<mrt forward references>>=
static void
mrtCountLinkedListRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset refOffset,
    MRT_Class const *const targetClass,
    MRT_AttrOffset linkOffset) ;
----

`sourceClass`::
    A pointer to the class description for the class instances
    that make a linked reference to target instances.
`refOffset`::
    The offset in bytes from the beginning of source instances to
    where the linked list terminus is located.
`targetClass`::
    A pointer to the class description for the class instances
    to which the source instances refer.
`linkOffset`::
    The offset in bytes from the beginning of target instances to where
    the linked list pointers are located.

The `mrtCountLinkedListRefs` function iterates through the linked list
contained in the source instances to reference the target instances.
When a target instance is found, it's `refCount` member is incremented.

(((micca,Run Time Function,mrtCountLinkedListRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountLinkedListRefs(
    MRT_Class const *const sourceClass,
    MRT_AttrOffset refOffset,
    MRT_Class const *const targetClass,
    MRT_AttrOffset linkOffset)
{
    MRT_iab *targetiab = mrtGetStorageProperties(targetClass, NULL) ;
    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *srcInst = mrt_InstIteratorGet(&srciter) ;
        MRT_LinkRef *ref = (MRT_LinkRef *)((uintptr_t)srcInst + refOffset) ;
        for (MRT_LinkRef *trgIter = mrtLinkRefBegin(ref) ;
                !(trgIter == NULL || trgIter == mrtLinkRefEnd(ref)) ;   // <1>
                trgIter = trgIter->next) {
            MRT_Instance *targetInst =
                (MRT_Instance *)((uintptr_t)trgIter - linkOffset) ;     // <2>
            if ((void *)targetInst >= targetiab->storageStart &&
                    (void *)targetInst < targetiab->storageFinish &&
                    targetInst->alloc > 0) {
                targetInst->refCount = targetInst->refCount == UINT8_MAX ?
                        2 : targetInst->refCount + 1 ;
            }
        }
    }
}
----
<1> Guard against uninitialized link pointers as well as detect
the end of the linked list.
<2> The link pointers that form the linked list of target instances are
located `linkOffset` from the beginning of the target instance.
So we need to do some pointer arithmetic to get the pointer to the beginning
of the instance.
We have to do this computation because it may be the case that the target is on
several linked lists depending upon the relationships in which it participates.

Counting class based associations uses the basic counting primatives that
we have already seen.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountClassAssocRefs(
    MRT_AssociationRole const *participant,
    MRT_Class const *const assocClass) ;
----

To count class based associations,
we have to count the references from each participant to the associator
class.
References from the participant to the associator class can be of any type.
References from the associator class back to the participant are always
singular.

(((micca,Run Time Function,mrtCountClassAssocRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountClassAssocRefs(
    MRT_AssociationRole const *participant,
    MRT_Class const *const assocClass)
{
    switch (participant->storageType) {
    case mrtSingular:
        mrtCountSingularRefs(participant->classDesc, participant->storageOffset,
            assocClass) ;
        break ;

    case mrtArray:
        mrtCountArrayRefs(participant->classDesc, participant->storageOffset,
            assocClass) ;
        break ;

    case mrtLinkedList:
        mrtCountLinkedListRefs(participant->classDesc,
                participant->storageOffset, assocClass,
                participant->linkOffset) ;
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
----

In a reference type generalization,
all of the references are always singular.
However,
we must iterate across all the subclasses of the generalization in order to
count the references that the subclasses make back to the superclass.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountGenRefs(
    MRT_RefGeneralization const *gen) ;
----

(((micca,Run Time Function,mrtCountGenRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountGenRefs(
    MRT_RefGeneralization const *gen)
{
    MRT_Class const *const superClass = gen->superclass.classDesc ;
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, superClass) ;                 // <1>
            mrt_InstIteratorMore(&iter) ; mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        MRT_Instance *subInst = *(MRT_Instance **)
                ((uintptr_t)instref + gen->superclass.storageOffset) ;
        if (subInst != NULL) {
            MRT_Class const *const subClass = subInst->classDesc ;

            MRT_iab *subiab = mrtGetStorageProperties(subClass, NULL) ;
            if ((void *)subInst >= subiab->storageStart &&
                    (void *)subInst < subiab->storageFinish &&
                    subInst->alloc > 0) {
                subInst->refCount = subInst->refCount == UINT8_MAX ?
                        2 : subInst->refCount + 1 ;
            }
        }
    }

    MRT_RefSubClassRole const *subclass = gen->subclasses ;
    for (unsigned subcount = gen->subclassCount ; subcount != 0 ;   // <2>
            subcount--, subclass++) {
        mrtCountSingularRefs(subclass->classDesc, subclass->storageOffset,
                gen->superclass.classDesc) ;
    }
}
----
<1> Start by iterating over the instances of the superclass.
<2> The refernces from the subclass to the superclass is just an ordinary
singular pointer reference.
We already know how to count them.

For a union based generalization,
all the references are singular.
However, since the storage for the subclass instance is part of the
superclass instance storage,
we only have to iterate across the superclass instances to have
access to both reference counts.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountUnionRefs(
    MRT_UnionGeneralization const *gen) ;
----

(((micca,Run Time Function,mrtCountUnionRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountUnionRefs(
    MRT_UnionGeneralization const *gen)
{
    MRT_Class const *const superClass = gen->superclass.classDesc ;
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, superClass) ;
            mrt_InstIteratorMore(&iter) ; mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        instref->refCount = instref->refCount == UINT8_MAX ?            // <1>
                2 : instref->refCount + 1 ;

        MRT_Instance *subInst = (MRT_Instance *)
                ((uintptr_t)instref + gen->superclass.storageOffset) ;  // <2>
        if (subInst->alloc > 0) {                                       // <3>
            subInst->refCount = subInst->refCount == UINT8_MAX ?
                    2 : subInst->refCount + 1 ;
        }
    }
}
----
<1> Since the instance iterater skips any unallocated slots,
we can unconditionally update the reference counter of the superclass
instance.
<2> While we have a pointer to the superclass instance,
we can compute the pointer to the subclass instance.
<3> Here we must test that the subclass instance slot is actually in use.
If it is, then this constitutes a "reference" to the superclass instance.

=== Operations on Relationship Instances

Since the relationship descriptions have sufficient information
to manage referential integrity,
they also can be used to do the pointer manipulations required when
instances of the relationships are created or deleted.
It is important for the run-time to provide functions to perform these
operations since checking referential integrity depends upon
correct reference pointer manipulation.

Because we are using pointer values to manage instance identity and
referencesfootnote:[as opposed to attribute values if we were doing this
using relational concepts],
we need to be clear what operations must be performed for classes
that participate in relationships.

For class based associations:

* There is a one-to-one correspondence between instances of a class based
association and instances of the associator class itself.
* Because of this correspondence,
when an instance of an associator is created, the creation operation
must be supplied with instance references to the participating instances.
The run-time will make up the pointer references appropriately.
The participating instances must not already be part of the relationship.
This implies that the participating instances are newly created
or the run-time will unlink them from the association before creating
the new instance of the association.

* Conversely, deleting an instance of an associator class is sufficient
to delete an instance of the class based association itself.
* Deleting an instance of a class participating in a class based association
*does not* cause the corresponding instance (or instances) of the associator
to be deleted.
* An operation to swap a different instance of a participating class
must be provided.

For simple associations:

* There is a one-to-one correspondence between instances of the simple
association and instances of the class which has the _referring_ role.
* Because of this correspondence,
when an instance of the referring class is created, the creation operation
must be supplied with an instance reference to an instance of the
class which plays the _referenced_ role in the association.
* Conversely, deleting an instance of a referring class,
unlinks the references to the referenced class.
* Deleting an instance of a referenced class, _does not_ modify the
reference in the referring class.
* An operation to swap a different instance of a referenced class
must be provided.


For referenced based generalizations:

* When creating an instance of a subclass,
the creation operation must be supplied with an instance reference
to the superclass.
The implication is that object creation must be in superclass to subclass
order.
* Deleting an instance of the subclass, unlinks the references between
the subclass and superclass.
Deleting an instance of the superclass _does not_ modify the
reference in the subclass and the corresponding subclass instance is
not deleted.
* An operation to reclassify subclass is also provided. This is a short
hand for a delete / create sequence of a related subclass instance.

For union based generalizations:

* Subclass instances may not be directly created.
It is necessary to create the superclass and reclassify the subclass
instance to the desired subclass type.
This may need to be repeated down a hierarchy if multiple generalization
are defined.
Note this implies the creation order for union based generalization is also
from superclass to subclass order.
* Superclass or subclass instances may be deleted.
In this case, there are no pointer references to modify, but
referential integrity will be evaluated at the end of the data transaction.
* An operation to reclassify subclass is also provided. This is a short
hand for a delete / create sequence of a related subclass instance.

=== Creating Relationship Links

The first part of supplying the operations on relationships is to be
able to create the linkage between instances that refer to each other.
We split this into two different functions, one for simple linkage
and the other for associative linkage.
Simple linkage forms the pointer references between only two
participants in a relationship.
This occurs for:

.. simple associations that are only between two participants,
.. associative classes when linking to only one participant, _i.e._ during
a swap operation where one participant instance is being exchanged for
another and
.. reference based generalizations

Associative linkage must account for the role of an associator class
when linking together both participants in a class based association.
This occurs when an instance of an associator class is created.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_CreateSimpleLinks(
    MRT_Relationship const *const rel,
    void *const source,
    void *const target,
    bool isForward) ;
----

`rel`::
    A pointer to a relationship description for the relationship
    across which the relate operation is to happen.
`source`::
    A pointer to a class instance that serves the source role in the
    relationship.
`target`::
    A pointer to a class instance that serves the target role in the
    relationship.
`isForward`::
    A boolean to disambiguate the reflexive case. If `true`, then
    the link from `source` to `target` is in the forward direction.
    Otherwise, the link is to be made from `target` to `source`.
    This argument is ignored for relationships that are not
    reflexive class based associations.

This function is used to establish pointer links when instances which
have simple association are created as well as when simple or
class based association have their related instances "swapped".

For simple associations, `source` is an instance of the referring class
and `target` is an instance of the referenced class. The `isForward`
argument is ignored.
For class based associations, `source` is an instance of the
associator class and `target` is an instance of one of the participants.
If the asssociation is reflexive, then the `isForward`
argument determines if `target` is a target participant (true) or
as source participant (false) .
For reference generalizations,
`source` is an instance of a subclass and `target` is an instance
of the superclass.
Union based generalizations have no links.
*****

Since we have four different types of relationships (in terms of their
storage properties),
we consider each type as a separate case.

(((micca,Run Time Function,mrt_CreateSimpleLinks)))
[source,c]
----
<<mrt external functions>>=
void
mrt_CreateSimpleLinks(
    MRT_Relationship const *const rel,
    void *const source,
    void *const target,
    bool isForward)
{
    assert(rel != NULL) ;
    assert(source != NULL) ;
    assert(target != NULL) ;

    switch (rel->relType) {
    case mrtSimpleAssoc: {
        <<mrt_CreateSimpleLinks: link simple association>>
    }
        break ;

    case mrtClassAssoc: {
        <<mrt_CreateSimpleLinks: link class association>>
    }
        break ;

    case mrtRefGeneralization: {
        <<mrt_CreateSimpleLinks: link reference generalization>>
    }
        break ;

    case mrtUnionGeneralization:
        // There are no pointer linkages for a union generalization.
        // N.B. fall through

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }

    mrtMarkRelationship(&rel, 1) ;      // <1>
}
----
<1> Since we are create links, we must mark the relationship to
be evaluated at the end of the data transaction.

For simple associations,
we must establish two sets of pointer linkages.
From source to target is the primary referring direction.
This is always singular and unconditional and so represented by
a single pointer value.
From target to source is in the back link direction and
may be either singular or a linked list.

[source,c]
----
<<mrt_CreateSimpleLinks: link simple association>>=
MRT_SimpleAssociation const *const assoc = &rel->relInfo.simpleAssociation ;

MRT_Instance *srcInst = source ;
MRT_Instance *targetInst = target ;
if (assoc->source.classDesc != srcInst->classDesc ||
        assoc->target.classDesc != targetInst->classDesc) {
    mrtFatalError(mrtRelationshipLinkage) ;                             // <1>
}

void *currentTarget =
        *(void **)((uintptr_t)source + assoc->source.storageOffset) ;

if (currentTarget != target) {                                          // <2>
    if (currentTarget != NULL) {
        mrtUnlinkBackref(&assoc->target, source, currentTarget) ;       // <3>
    }
    mrtLink(&assoc->source, source, target) ;                           // <4>
    mrtLink(&assoc->target, target, source) ;
}
----
<1> Make sure that the relationship descriptive information matches
the classes of the instances we were handed.
<2> Just guard against the case where we are linking together what
is already linked.
Call it a big no op.
<3> We unlink any back references by the current target instance.
This in effect causes the the current target to be half unrelated.
<4> Create a link for each leg of the relationship -- from source to
target and then from target to source.

Since the core of what is going on here is linking the two instances,
let's look at what `mrtLink` does.
We will use this function several more times later on.

`MrtLink` creates one leg of a relationship
link from one instance ("from") to another ("to").
Like most of the access to relationship pointers we have already seen,
`mrtLink` does some unsafe pointer arithmetic to find the location in the
instance where references are stored.
Then, depending upon the type of reference storage,
updates the instance pointers.

(((micca,Run Time Function,mrtLink)))
[source,c]
----
<<mrt static functions>>=
static void
mrtLink(
    MRT_AssociationRole const *const fromRole,
    void *const fromInst,
    void *const toInst)
{
    void *linkStorage = (void *)((uintptr_t)fromInst + fromRole->storageOffset) ;
    switch (fromRole->storageType) {
    case mrtSingular: {
        void **toLink = linkStorage ;
        *toLink = toInst ;                                          // <1>
    }
        break ;

    case mrtArray:
        // can't link array types
        mrtFatalError(mrtStaticRelationship) ;
        break ;

    case mrtLinkedList: {
        MRT_LinkRef *toLinks =
                (MRT_LinkRef *)((uintptr_t)toInst + fromRole->linkOffset) ;
        if (toLinks->next != NULL && toLinks->prev != NULL) {
            mrtLinkRefRemove(toLinks) ;                             // <2>
        }

        MRT_LinkRef *fromList = linkStorage ;                       // <3>
        mrtLinkRefInsert(toLinks, fromList) ;
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
----
<1> For a singular pointer, 
overwriting the pointer value creates the link.
<2> If the "to" instances is already on a linked list somewhere,
then we unlink it before placing it on the new list.
We can do this since we do not need the list head to unlink an item from a
list.
<3> The terminus of the back link list is in the `fromInst` and is located
at the `storageOffset` within the instance.
The link pointers in the `toInst` are at the `linkOffset` within the
instance.
Note the offset into `toInst` is actually given in the association
description of the "from" instance.
This arrangement is convenient in other cases, despite the confusion
of using a from description to access something in the "to" instance.

For class based associations,
the `mrt_CreateSimpleLinks` function updates only one of the pointer
references, from the associator class to either the source or target
participant of the relationship.
The code is more complex here because we need to deal with
several circumstances:

* The `source` argument is always the associative class, but we must
  figure out whether the `target` is a source participant instance or a
  target participant instance.
* We have to handle the reflexive case where the two participant classes
  are the same and the `isForward` argument resolves the direction.
* We must make sure that we are not creating a duplicate instance of the
  association.
  Since instances of an associative relationship correspond one-to-one
  to instances of the associator class, we have to make sure that there
  are no other associator class instances which have the same
  source and target participant instances.
  This is logically the same as enforcing an identifying constraint on
  the associator class since the referential attributes of an
  associator class form an identifier.

[source,c]
----
<<mrt_CreateSimpleLinks: link class association>>=
MRT_ClassAssociation const *const cassoc = &rel->relInfo.classAssociation ;
MRT_AssociatorRole const *const arole = &cassoc->associator ;
MRT_AssociationRole const *const srole = &cassoc->source ;
MRT_AssociationRole const *const trole = &cassoc->target ;

void *const associator = source ; // Change the variable names to keep things clear
void *const dest = target ;
if (arole->classDesc != ((MRT_Instance *)associator)->classDesc) { // <1>
    mrtFatalError(mrtRelationshipLinkage) ;
}

MRT_AssociationRole const *destrole ;
MRT_AttrOffset assocOffset ;
void *srcInst ;
void *targetInst ;

if (srole->classDesc == trole->classDesc) {                         // <2>
    // reflexive case
    if (trole->classDesc != ((MRT_Instance *)dest)->classDesc) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }
    if (isForward) {                                                // <3>
        destrole = trole ;
        assocOffset = arole->forwardOffset ;
        srcInst = *(void **)((uintptr_t)associator + arole->backwardOffset) ;
        targetInst = dest ;
    } else {
        destrole = srole ;
        assocOffset = arole->backwardOffset ;
        srcInst = dest ;
        targetInst = *(void **)((uintptr_t)associator + arole->forwardOffset) ;
    }
} else {                                                            // <4>
    // non-reflexive case
    if (srole->classDesc == ((MRT_Instance *)dest)->classDesc) {
        // backward
        destrole = srole ;
        assocOffset = arole->backwardOffset ;
        srcInst = dest ;
        targetInst = *(void **)((uintptr_t)associator + arole->forwardOffset) ;
    } else if (trole->classDesc == ((MRT_Instance *)dest)->classDesc) {
        // forward
        destrole = trole ;
        assocOffset = arole->forwardOffset ;
        srcInst = *(void **)((uintptr_t)associator + arole->backwardOffset) ;
        targetInst = dest ;
    } else {
        mrtFatalError(mrtRelationshipLinkage) ;
    }
}

void **p_assocRef = (void **)((uintptr_t)associator + assocOffset) ;
if (*p_assocRef != NULL) {
    mrtUnlinkBackref(destrole, associator, *p_assocRef) ;            // <5>
    *p_assocRef = NULL ;
}

if (srcInst != NULL && targetInst != NULL && arole->multiple == false) {
    mrtCheckDupAssociator(rel, srcInst, targetInst) ;               // <6>
}

*p_assocRef = dest ;                                                 // <7>
mrtLink(destrole, dest, associator) ;
----
<1> When invoked on a class based association,
we insist that the "source" instance reference argument be an instance
reference to the associator class.
We introduce a new variable to prevent confusion of the `source`
argument with the fact that it is now assumed to be an instance
of the associator class.
<2> Check for the reflexive case.
<3> For the reflexive case, the `isForward` argument determines
the direction of the destination of the link.
<4> For the non-reflexive case we can determine the direction
since the classes of the two ends are different.
<5> Unlink the references between the associator and the destination, if any.
This is a necessary step before we check for a duplicated associator
instance.
If this is really just an update of an existing association, then be
must delete that association before testing that creating a new one
would be a duplicate.
Otherwise, link values laying around in the association class data
structure could be interpreted as being part of a duplicate instance.
<6> Check that we are not duplicating an instance of the association.
It is a fatal error to attempt to do so.
Note we check that the source and target actually have valid instance
pointers.
It is possible for the association class *not* to be linked to anything
(e.g. when it is first created)
and so the source and/or target instance pointers may be `NULL`.
<7> Link the leg from the associative class to one of the participant instances
and then in the opposite direction -- from the participant instance to the
associative class instance.

When relating reference generalizations,
the reference from the subclass to the superclass is singular and
unconditional.
The reference from the superclass to the subclass is also singular.

[source,c]
----
<<mrt_CreateSimpleLinks: link reference generalization>>=
MRT_RefGeneralization const *const gen = &rel->relInfo.refGeneralization ;

MRT_Class const *const subclassClass =
        ((MRT_Instance *)source)->classDesc ;                           // <1>
int subclassCode = mrtFindRefGenSubclassCode(subclassClass, gen->subclasses,
        gen->subclassCount) ;

MRT_Class const *const superclassClass =
        ((MRT_Instance *)target)->classDesc ;                           // <2>
if (gen->superclass.classDesc != superclassClass) {
    mrtFatalError(mrtRelationshipLinkage) ;
}

void **p_superRef = (void **)((uintptr_t)source +
        gen->subclasses[subclassCode].storageOffset) ;
*p_superRef = target ;

void **p_subRef = (void **)((uintptr_t)target + gen->superclass.storageOffset) ;
*p_subRef = source ;
----
<1> For reference generalizations,
the "source" instance reference must be one of the subclasses that
participates in the relationship.
The primary reference in a generalization is from subclass instance to
superclass instance.
<2> The "target" instance reference must then be to the superclass of the
generalization.

Finding the participating subclass of the generalization is a linear search
of the subclass roles in the relationship description.

(((micca,Run Time Function,mrtFindRefGenSubclassCode)))
[source,c]
----
<<mrt static functions>>=
static int
mrtFindRefGenSubclassCode(
    MRT_Class const *const subclassClass,
    MRT_RefSubClassRole const *subclasses,
    unsigned count)
{
    int subcode ;

    for (subcode = 0 ; subcode < count ; subcode++, subclasses++) {
        if (subclassClass == subclasses->classDesc) {
            return subcode ;
        }
    }

    mrtFatalError(mrtRelationshipLinkage) ;
}
----

=== Create Associator Links

Linking class based associations must account for the nature
of the associator class.
A class based association is treated as being decomposed into
two associations, one each between the participants and the associator
class.
The associator class has singular, unconditional references to each
participant.
The participants have back references to the associator whose type
depends upon multiplicity and the static nature of the association.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_CreateAssociatorLinks(
    MRT_Relationship const *rel,
    void *assoc,
    void *source,
    void *target) ;
----

`rel`::
    A pointer to a relationship description for the relationship
    across which the relate operation is to happen.
`assoc`::
    A pointer to a class instance that serves the associator role
    in the relationship.
`source`::
    A pointer to a class instance that serves the source role in the
    relationship.
`target`::
    A pointer to a class instance that serves the target role in the
    relationship.
*****

(((micca,Run Time Function,mrt_CreateAssociatorLinks)))
[source,c]
----
<<mrt external functions>>=
void
mrt_CreateAssociatorLinks(
    MRT_Relationship const *rel,
    void *assoc,
    void *source,
    void *target)
{
    assert(rel != NULL) ;
    assert(assoc != NULL) ;
    assert(source != NULL) ;
    assert(target != NULL) ;

    assert(rel->relType == mrtClassAssoc) ;
    if (rel->relType != mrtClassAssoc) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }

    MRT_ClassAssociation const *cassoc = &rel->relInfo.classAssociation ;
    MRT_AssociatorRole const *arole = &cassoc->associator ;

    assert(arole->classDesc == ((MRT_Instance *)assoc)->classDesc) ;
    if (arole->classDesc != ((MRT_Instance *)assoc)->classDesc) {
        mrtFatalError(mrtRelationshipLinkage) ;
    }

    if (!arole->multiple) {
        mrtCheckDupAssociator(rel, source, target) ;    // <1>
    }

    mrt_CreateSimpleLinks(rel, assoc, source, false) ;  // <2>
    mrt_CreateSimpleLinks(rel, assoc, target, true) ;
}
----
<1> Problem arises when source and target are already related to
each other through some other associator class instance. If that
is the case, then we violate the identity contraint on the
associator class and we would not have proper sets.
So we have to navigate from source to see if we can find target.
<2> In keeping with the concept that a class based assocation is
decomposed into two association legs, we need only create the links
for both sides.

To make sure that there are no duplicated association instances,
we must check that for any given pair of instances across a
class based association,
that we cannot traverse the association and find a match.
The strategy used by `mrtCheckDupAssociator` is to start at the
source instance and traverse the relationship in search of a
matching target instance.
This technique saves looking at all the associator class instances
and searching for both the source and target pointer values.
That code is easier to write, but will usually examine every instance
of the associator class (since finding a duplicate is a rare happening).
Each target instance linked to the source instance through
the associator class must be compared to the target instance which
is about to be set.
If a match is found, then this is an attempt to create a duplicate
instance of the association and a fatal error is declared.
The complication arises in that we have to traverse the association
using data found in the relationship description,
_i.e._ using descriptive meta data.
This means we have to perform all the pointer arithmetic ourselves.

The implementation considers the three cases that arise as a result
of the three different ways that pointer linkage is stored.
Of course, array storage used for static associations is not modified
and so results in a fatal error.

(((micca,Run Time Function,mrtCheckDupAssociator)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCheckDupAssociator(
    MRT_Relationship const *rel,
    void *source,
    void *target)
{
    assert(rel != NULL) ;
    assert(rel->relType == mrtClassAssoc) ;
    assert(source != NULL) ;
    assert(target != NULL) ;

    MRT_ClassAssociation const *cassoc = &rel->relInfo.classAssociation ;
    MRT_AssociatorRole const *arole = &cassoc->associator ;
    MRT_AssociationRole const *srole = &cassoc->source ;

    switch (srole->storageType) {
    case mrtSingular: {
        <<mrtCheckDupAssociator: singular reference>>
    }
        break ;
    case mrtArray:
        mrtFatalError(mrtStaticRelationship) ;
        break ;

    case mrtLinkedList: {
        <<mrtCheckDupAssociator: linked list reference>>
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
----

If the source instance has a singular back link to the associator
class instance there is only one possible target to which it is related.

[source,c]
----
<<mrtCheckDupAssociator: singular reference>>=
void *assocInst = *(void **)((uintptr_t)source + srole->storageOffset) ;
if (assocInst != NULL) {
    void *currentTarget =
            *(void **)((uintptr_t)assocInst + arole->forwardOffset) ;
    if (currentTarget == target) {
        mrtDupAssociatorError(rel) ;
    }
}
----

If the source instance has a linked list of back references to the
associator class instance,
then we have to set up an interation over the list to track down
the related targets.

[source,c]
----
<<mrtCheckDupAssociator: linked list reference>>=
MRT_LinkRef *linksList =
        (MRT_LinkRef *)((uintptr_t)source + srole->storageOffset) ;     // <1>
for (MRT_LinkRef *assocLink = mrtLinkRefBegin(linksList) ;
        !(assocLink == NULL || assocLink == mrtLinkRefEnd(linksList)) ;
        assocLink = assocLink->next) {
    assert(srole->linkOffset != 0) ;
    void *assocInst = (void *)((uintptr_t)assocLink - srole->linkOffset) ;// <2>
    void *currentTarget = *(void **)((uintptr_t)assocInst + arole->forwardOffset) ;
    if (currentTarget == target) {
        mrtDupAssociatorError(rel) ;
        break ;
    }
}
----
<1> The linked list terminus for the back links is in the source instance.
<2> Recover the pointer to the beginning of the associative instance by
subtracting off the offset to where the linked list pointers are stored.

=== Deleting Relationship Linkage

We must also provide a function to delete relationship linkage pointers.

*****
[source,c]
----
<<mrt forward references>>=
static void mrtDeleteLinks(MRT_Relationship const * const *classRels,
        unsigned relCount, void *inst) ;
----

`classRels`::
    A pointer to an array of relationships description pointers
    that describe the relationships in which `inst` is a participant.
`relCount`::
    The number of elements in the `classRels` array.
`inst`::
    A pointer to the class instance that is to be unlinked from its
    relationship.
*****

The implementation for deleting relationship links follows a similar
pattern as for creating them.
There are four distinct types of relationships and so we must consider
each one.

(((micca,Run Time Function,mrtDeleteLinks)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDeleteLinks(
    MRT_Relationship const * const *classRels,
    unsigned relCount,
    void *inst)
{
    assert(inst != NULL) ;
    /*
     * Mark the transaction since we are updating the reference pointers.
     */
    mrtMarkRelationship(classRels, relCount) ;

    MRT_Instance *instref = inst ;
    MRT_Class const *const instclass = instref->classDesc ;

    for ( ; relCount != 0 ; relCount--, classRels++) {
        struct mrtrelationship const * const rel = *classRels ;
        switch (rel->relType) {
        case mrtSimpleAssoc: {
            <<mrtDeleteLinks: unlink simple association>>
        }
            break ;

        case mrtClassAssoc: {
            <<mrtDeleteLinks: unlink class based association>>
        }
            break ;

        case mrtRefGeneralization: {
            <<mrtDeleteLinks: unlink reference generalization>>
        }
            break ;

        case mrtUnionGeneralization:
            // For a union generalization, there are no pointer links.
            break ;

        default:
            mrtFatalError(mrtRelationshipLinkage) ;
            break ;
        }
    }
}
----

To unrelate simple associations,
we must verify that the classes of the instance actually participate in the
association and the perform the pointer operations to unlink the instances.

[source,c]
----
<<mrtDeleteLinks: unlink simple association>>=
MRT_SimpleAssociation const *assoc = &rel->relInfo.simpleAssociation ;

if (instclass == assoc->source.classDesc) {
    <<mrtDeleteLinks: unlink simple forward>>
} else if (instclass == assoc->target.classDesc) {
    <<mrtDeleteLinks: unlink simple backward>>
} else {
    mrtFatalError(mrtRelationshipLinkage) ;
}
----

Unlinking a simple association in the forward direction implies that we
are unlinking the primary reference.
This primary reference is always singular and always non-NULL.
When we are unlinking the primary reference we will follow the reference
and try to unlink any back references.

[source,c]
----
<<mrtDeleteLinks: unlink simple forward>>=
MRT_AssociationRole const *sourceRole = &assoc->source ;

if (sourceRole->storageType == mrtSingular) {
    void **p_targetInst = (void **)
            ((uintptr_t)inst + sourceRole->storageOffset) ;
    MRT_Instance *targetInst = *p_targetInst ;
    *p_targetInst = NULL ; // <1>

    MRT_AssociationRole const *targetRole = &assoc->target ;
    if (targetInst != NULL && targetInst->alloc > 0 &&
            targetInst->classDesc == targetRole->classDesc) { // <2>
        mrtUnlinkBackref(targetRole, inst, targetInst) ;
    }
} else {
    // Simple forward association links are always singular.
    mrtFatalError(mrtRelationshipLinkage) ;
}
----
<1> Assigning `NULL` to the primary reference effectively unlinks
the target instance.
<2> We only want to attempt to unlink the back reference if the target instance
is still allocated and of the same class.
We accomodate the `NULL` case also, since this can arise
if the construction of the instance errored out because of a static
relationships.
Normally, instance don't just change their class out from under themselves.
However, union based subclass instances do.
Migrating a union subclass instance results in any back reference pointers
to the instance remaining valid, but the class of the instance now
occupying the memory has changed.
Union subclasses are somewhat painful.

The case of unlinking back references for a simple association,
occurs when the target instance is being deleted.
In this case,
we only delete the back references made by the target.
In particular we make no attempt to follow the source references
and delete the primary reference pointer.
If the referring instance is not later deleted,
then referential integrity checking will find a pointer to
an unallocated instance.
This will be caught in referential integrity checking.
we must be prepared for the fact that the back references are
already gone.
This is because it is possible to delete the referenced instance of
a simple association before deleting the referring instance.

[source,c]
----
<<mrtDeleteLinks: unlink simple backward>>=
MRT_AssociationRole const *targetRole = &assoc->target ;

void *linkStorage = (void *)((uintptr_t)inst + targetRole->storageOffset) ;
switch (targetRole->storageType) {
case mrtSingular: {
    void **p_sourceInst = linkStorage ;
    *p_sourceInst = NULL ;                                  // <1>
}
    break ;

case mrtLinkedList: {                                       // <2>
    MRT_LinkRef *sourceList = linkStorage ;                 // <3>
    assert(sourceList->next != NULL && sourceList->prev != NULL) ;
    for (MRT_LinkRef *iter = mrtLinkRefBegin(sourceList) ;
            iter != mrtLinkRefEnd(sourceList) ; ) {
        MRT_LinkRef *sourceInst = iter ;
        iter = iter->next ;                                 // <4>
        mrtLinkRefRemove(sourceInst) ;
    }
}
    break ;

case mrtArray: {
    MRT_ArrayRef * alinks = linkStorage ;                   // <5>
    if (alinks->links != NULL) {
        // Can't unlink array type linkages.
        mrtFatalError(mrtStaticRelationship) ;
    }
}
    break ;

default:
    mrtFatalError(mrtRelationshipLinkage) ;
    break ;
}
----
<1> For the singular pointer case we can just write `NULL` to the
back reference.
Even if it was already `NULL`, it won't matter.
The link is severed.
<2> In this case, the instance is being deleted and all of
its back links must be removed.
<3> This is the list of back links to source instances.
<4> Be careful to advance the iterator before deleting the item from the list.
<5> We allow attempting to unlink array backlinks as long as there
aren't really any backlinks.
This case can arise in creating instances that participate in static
relationships and then trying to delete them after catching the fatal
error.

In this function we are trying to delete a single back link from the "target"
to the "source".
This is the back link deletion associated with deleting the primary
reference pointer and we have tracked to a target instance.

[source,c]
----
<<mrt forward references>>=
static void
mrtUnlinkBackref(
    MRT_AssociationRole const *const targetRole,
    void *source,
    void *target) ;
----

(((micca,Run Time Function,mrtUnlinkBackref)))
[source,c]
----
<<mrt static functions>>=
static void
mrtUnlinkBackref(
    MRT_AssociationRole const *const targetRole,
    void *const source,
    void *const target)
{
    assert(source != NULL) ;
    assert(target != NULL) ;
    assert(targetRole != NULL) ;

    void *linkStorage =
            (void *)((uintptr_t)target + targetRole->storageOffset) ;
    switch (targetRole->storageType) {
    case mrtSingular: {
        void **p_sourceInst = linkStorage ;                             // <1>
        if (*p_sourceInst == source) {                                  // <2>
            *p_sourceInst = NULL ;
        }
    }
        break ;

    case mrtLinkedList: {
        MRT_LinkRef *srcblinks = (MRT_LinkRef *)
                ((uintptr_t)source + targetRole->linkOffset) ;          // <3>
        if (srcblinks->next != NULL && srcblinks->prev != NULL) {       // <4>
            MRT_LinkRef *targetList = linkStorage ;
            for (MRT_LinkRef *targetlink = mrtLinkRefBegin(targetList) ;
                    targetlink != mrtLinkRefEnd(targetList) ;
                    targetlink = targetlink->next) {
                if (targetlink == srcblinks) {
                    mrtLinkRefRemove(srcblinks) ;
                    break ;                                             // <5>
                }
            }
        }
    }
        break ;

    case mrtArray: {
        MRT_ArrayRef *alinks = linkStorage ;
        if (alinks->links != NULL) {                                    // <6>
            // Can't unlink array type linkages.
            mrtFatalError(mrtStaticRelationship) ;
        }
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
----
<1> The entity at the storageOffset is a simple pointer back to the
source instance.  Point to where the source reference is located
in the target instance.
<2> We only want to unlink the backref if it is actually pointing
back to the source.
<3> The source instance is linked onto a list whose list terminus is
contained in the target instance.
We must make sure the source instance is actually linked on the list
before we try to remove it from the list.
This means running the list to find the match.
We only need a pointer to the links member in the
source instance to remove it from the list (it is doubly linked).
The links are offset into the source instance by the `linkOffset` given in
the "target" role relationship descriptor.
<4> Check that the instance is actually linked on the list.
If the source has been deleted previously,
then it will have been removed from the list already.
<5> Once found and removed, we no longer need to iterate on the rest
of the list.
<6> It's alright to unlink a static relationships as long as there
were no links to begin with.

For class based associations,
we deal with the association in two steps, between each participant and
the associator class.

[source,c]
----
<<mrtDeleteLinks: unlink class based association>>=
MRT_ClassAssociation const *assoc = &rel->relInfo.classAssociation ;

if (instclass == assoc->associator.classDesc) {
    MRT_AssociatorRole const *assocRole = &assoc->associator ;
    MRT_AssociationRole const *sourceRole = &assoc->source ;
    MRT_AssociationRole const *targetRole = &assoc->target ;

    void **p_targetInst = (void **)
            ((uintptr_t)inst + assocRole->forwardOffset) ; // <1>
    MRT_Instance *targetInst = *p_targetInst ;
    *p_targetInst = NULL ;
    if (targetInst != NULL && targetInst->alloc > 0 &&
            targetInst->classDesc == targetRole->classDesc) {
        mrtUnlinkBackref(targetRole, inst, targetInst) ;
    }

    void **p_sourceInst = (void **)
            ((uintptr_t)inst + assocRole->backwardOffset) ;
    MRT_Instance *sourceInst = *p_sourceInst ;
    *p_sourceInst = NULL ;
    if (sourceInst != NULL && sourceInst->alloc > 0) {
        mrtUnlinkBackref(sourceRole, inst, sourceInst) ;
    }
}
----
<1> Start with the forward direction to the target.
Point to where the target reference is located in the associator instance.

For reference generalizations,
the references are singular pointers between the superclass and subclass
instances.
We must make sure the classes given actually participate in the
generalization.

[source,c]
----
<<mrtDeleteLinks: unlink reference generalization>>=
MRT_RefGeneralization const *gen = &rel->relInfo.refGeneralization ;

if (instclass != gen->superclass.classDesc) {
    // Instance is a subclass instance
    int subclassCode = mrtFindRefGenSubclassCode(instclass, gen->subclasses,
            gen->subclassCount) ;
    // Obtain the pointer to the superclass instance.
    void **p_superInst = (void **)
            ((uintptr_t)inst + gen->subclasses[subclassCode].storageOffset) ;
    MRT_Instance *superInst = *p_superInst ;
    *p_superInst = NULL ;
    assert(superInst != NULL) ;
    // NULL out the pointer in the superclass instance pointing to the subclass
    // instance.
    if (superInst != NULL && superInst->alloc > 0) {
        void **p_subInst = (void **)
                ((uintptr_t)superInst + gen->superclass.storageOffset) ;
        *p_subInst = NULL ;
    }
} else {
    // Instance is a superclass instance
    // NULL out the pointer to the subclass instance only,
    // i.e. only the back reference.
    void **p_subInst = (void **)((uintptr_t)inst + gen->superclass.storageOffset) ;
    *p_subInst = NULL ;
}
----

=== Reclassifying Subclasses

Generalization relationships represent a disjoint union of the
subclasses.
Because of this property,
we know that there is an unconditional relationship between a subclass
instance and a superclass instance and an unconditional relationship
between a superclass instance and a subclass instance from among all the
subclasses of the generalization.
This situation leads to the concept of a reclassify operation to allow
a related subclass instance to migrate from one subclass to another.
It is a powerful concept to model modal operations in a domain.
The run-time provides a function to accomplish the details.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void *
mrt_Reclassify(
    MRT_Relationship const *rel,
    void *sub,
    MRT_Class const *const newSubclass) ;
----

`rel`::
    A pointer to a relationship description for the relationship
    across which the reclassify operation is to happen.
`sub`::
    A pointer to a class instance that is to be reclassified.
`newSubclass`::
    A pointer to the class description to which the currently related
    subclass instance is to be reclassified.

The `mrt_Reclassify` function migrates the class of the `sub` instance
along the `rel` generalization to be of the new class, `newSubclass`.
Conceptually,
reclassification implies that the `sub` instance
is unrelated and deleted and a new instance of `newSubclass` is created
and related to the superclass instance to which `sub` was previously
related.

The return value of the function is an instance pointer to the newly
created subclass instance.
*****

Since we support two different ways to store subclass instances,
the reclassification considers each type separately.

(((micca,Run Time Function,mrt_Reclassify)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_Reclassify(
    MRT_Relationship const *rel,
    void *sub,
    MRT_Class const *const newSubclass)
{
    assert(rel != NULL) ;
    assert(newSubclass != NULL) ;

    MRT_Instance *currentSubInst = sub ;
    assert(currentSubInst != NULL) ;
    assert(currentSubInst->alloc > 0) ;

    void *newSubInst = NULL ;

    if (rel->relType == mrtRefGeneralization) {
        <<mrt_Reclassify: reclassify reference generalization>>
    } else if (rel->relType == mrtUnionGeneralization) {
        <<mrt_Reclassify: reclassify union generalization>>
    } else {
        mrtFatalError(mrtRelationshipLinkage) ;
    }

    return newSubInst ;
}
----

For reference type generalizations,
we must perform the complete delete / create sequence.

[source,c]
----
<<mrt_Reclassify: reclassify reference generalization>>=
MRT_RefGeneralization const *const gen = &rel->relInfo.refGeneralization ;

/*
 * Verify the subclass instance is an instance of that class that
 * is part of the relationship.
 */
int subclassCode = mrtFindRefGenSubclassCode(currentSubInst->classDesc,
        gen->subclasses, gen->subclassCount) ;
/*
 * Fetch the superclass instance via the reference in the subclass instance.
 */
MRT_Instance *super = *(MRT_Instance **)((uintptr_t)sub +
        gen->subclasses[subclassCode].storageOffset) ;
/*
 * Check that the subclass instance is related to a superclass that is
 * the correct one for the relationship.
 */
if (gen->superclass.classDesc != super->classDesc) {
    mrtFatalError(mrtRelationshipLinkage) ;
}
/*
 * Verify that the new subclass is indeed a subclass of the relationship.
 * We don't care about the subtype code and are only using
 * mrtFindRefGenSubclassCode() to validate the new requested subclass.
 */
mrtFindRefGenSubclassCode(newSubclass, gen->subclasses, gen->subclassCount) ;
/*
 * Delete the old subclass instance.  Deleting will cause the subclass
 * instance to be unlinked from the generalization.
 */
mrt_DeleteInstance(sub) ;
/*
 * Create a new instance of the new subclass.
 */
newSubInst = mrt_CreateInstance(newSubclass, MRT_StateCode_IG) ;
/*
 * Create the links to the super class instance.
 */
mrt_CreateSimpleLinks(rel, newSubInst, super, true) ;
----

For generalizations implemented as unions,
the reclassification sequence is much simpler.
There is no need to delete and create a new instance of the new
subclass.
We need only transform the currently related instance into the new
subclass.

[source,c]
----
<<mrt_Reclassify: reclassify union generalization>>=
MRT_UnionGeneralization const *const gen = &rel->relInfo.unionGeneralization ;
/*
 * Verify the subclass instance is an instance of that class that
 * is part of the relationship. We don't need the subclass code.
 */
MRT_Class const *const subClass = currentSubInst->classDesc ;
mrtFindUnionGenSubclassCode(subClass, gen->subclasses, gen->subclassCount) ;
/*
 * Compute the pointer to the superclass instance.
 */
MRT_Instance *super = (MRT_Instance *)((uintptr_t)currentSubInst -
        gen->superclass.storageOffset) ;
/*
 * Check that the subclass instance is related to a superclass that is
 * the correct one for the relationship.
 */
if (gen->superclass.classDesc != super->classDesc) {
    mrtFatalError(mrtRelationshipLinkage) ;
}
/*
 * Check that the new subclass is one that is part of this generalization.
 * We don't actually need the subclass code itself.
 */
mrtFindUnionGenSubclassCode(newSubclass, gen->subclasses, gen->subclassCount) ;
/*
 * Clean up any relationship pointers in the currently related instance.
 */
mrtDeleteLinks(subClass->classRels, subClass->relCount, currentSubInst) ;
/*
 * The new instance occupies the same memory as the old one.
 */
newSubInst = currentSubInst ;
/*
 * Set up the memory for the subclass instance according to the new subclass.
 */
mrtInitializeInstance(newSubInst, newSubclass, MRT_StateCode_IG) ;
----

This function is the counterpart for finding a subclass among the
subclasses for a union generalization.

(((micca,Run Time Function,mrtFindUnionGenSubclassCode)))
[source,c]
----
<<mrt static functions>>=
static int
mrtFindUnionGenSubclassCode(
    MRT_Class const *const subclassClass,
    MRT_Class const *const *subclasses,
    unsigned count)
{
    int subcode ;

    for (subcode = 0 ; subcode < count ; subcode++, subclasses++) {
        if (subclassClass == *subclasses) {
            return subcode ;
        }
    }

    mrtFatalError(mrtRelationshipLinkage) ;
}
----

== Managing Execution

In this section,
we discuss the rules and policies for managing execution sequencing.
There are two means available to domain activities to control the
sequencing of execution.

* Invoke an ordinary function.
* Generate an event to the instance of a class.

Not much needs to be said about invoking functions.
Control is transferred to the entry point and runs until the function
is complete, transferring control back to next statement of the caller.
Typically, such functions are organized into those that are associated
with the domain as whole, a particular class or the instances of a class.
Such organization may be helpful to the programmer,
but since they are directly supported by the implementation language,
the `micca` run-time does not get involved in mediating them.

The run-time does get involved with those computations that must leave
off at some point,
waiting for some other action in the system or the external environment,
and then resume execution maintaining the past history.
This type of execution is implemented as a state machine.

=== State Machine Rules

Each class that has lifecycle behavior may have a state model associated
with it and each instance of that class will have a state variable
that allows it to execute as an state machine independent of the
other instances of the class.
The run-time supports a Moore type state model.

In the Moore formulation of state models,
activity code is associated with states and is executed
upon entry into a state.
This is distinguished from the Mealy formulation where
actions are associated with the transitions and are executed
upon exiting a state.
Much writing and discussion has been wasted attempting to
justify one type of state model over another.
What we know is they are computationally equivalent,
_i.e._ we can prove that there is no problem that you can solve
with a Moore machine that cannot also be solved with a Mealy
machine and _vice versa_.
Whether your application is easier to describe with one type rather
than the other is something that you alone may decide.
Moore machines are the traditional formulation for Executable UML
and they have the simplest implementation structures.
What we specifically reject here is any use of hierarchical state
models.
They are unnecessary and add complication that is not welcome.
The power of computation in Executable UML is derived from the
interaction of simple state machines each of which is tied to the
lifecycle of a particular class.
If you have some state model that is large and complicated where
you think some other kind of higher order structure is needed,
the usual reason is that you have multiple classes masquerading as one
and further refinement of your analysis is necessary.
That is not usually a welcome answer to the situation,
because if the analyst had been able to conceive of a better solution,
he/she would probably have done so already.
When state models are used to describe the lifecycle behavior of
a well defined class (and not sets of classes or the domain as whole)
there is no need for more complicated state execution schemes
such as hierarchies.

Generally, state activities affect other computations in the domain
by updating instance attribute values or by generating events to
other instances.
The important distinction here is that the application code of the
state activities does not deal with actually dispatching the events
nor does it control which event is dispatched next.

=== Event Types

There are three types of events:

. Transition events that cause transitions in state machines.
. Polymorphic events that are mapped at runtime across a generalization
hierarchy to transition events.
. Creations events that support asynchronous instance creation.

Creation events are transition events that are also associated with
an instance creation.
Our strategy for creation events is to create the instance in an inactive
state before queuing the event that will activate the instance and
cause a transition.
We will have need to distinguish between the various event types
and use an enumeration to accomplish that.

(((micca,Run Time Data,MRT_EventType)))
[source,c]
----
<<mrt internal simple types>>=
typedef enum {
    mrtTransitionEvent,
    mrtPolymorphicEvent,
    mrtCreationEvent
} MRT_EventType ;
----

The process of signaling an event involves the following steps:

. Obtain an *Event Control Block* (ECB) from the free pool of ECB's.
. Set the values of the fields in the ECB.
. Queue the ECB for later dispatch.

=== Event Control Block

The Event Control Block (ECB) is the primary data structure for signaling and
dispatching events.

(((micca,Run Time Data,MRT_ecb)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtecb {
    struct mrtecb *next ;
    struct mrtecb *prev ;
    MRT_EventCode eventNumber ;
    MRT_AllocStatus alloc ;
    MRT_Instance *targetInst ;
    MRT_Instance *sourceInst ;
    MRT_DelayTime delay ;
    alignas(max_align_t) MRT_EventParams eventParameters ;
} MRT_ecb ;
----

`next`, `prev`::
    Event queuing is done by doubly linked lists
    and the links are allocated as part of the ECB as the `next` and
    `prev` members.
`eventNumber`::
    The event number.
    Events are also encoded as small zero based sequential integers
    that are unique only within the class to which they are associated.
    Event numbers are ultimately used as an array index.
`alloc`::
    The `alloc` member is yet another part of _event-in-flight_ detection.
    We will discuss that more <<event-in-flight-error,below>>
    when we discuss event dispatch.
    For now, this member of the ECB holds the value of the allocation
    counter for the instance that is the target of the event.
    So when an event is generated, a copy of the current value of
    the `alloc` member of the instance is stored in the ECB.
`targetInst`::
    A pointer to the instance that is to receive the event.
`sourceInst`::
    A pointer to the instance that is the signaler of the event.
    If the event is generated outside the context of an instance
    (_e.g._ in an domain operation), then this member value is set to `NULL`.
    The `sourceInst` member also serves an important role in enforcing the rules
    for delayed events.
    More on that later.
`delay`::
    The number of milliseconds to delay before the event is posted.
`eventParameters`::
    Storage for any parameter values passed along with the event.
    We discuss event parameter data storage <<event-parameter-storage, below>>.


Event codes are captured by small integer values.

(((micca,Run Time Data,MRT_EventCode)))
[source,c]
----
<<mrt interface simple types>>=
typedef uint8_t MRT_EventCode ;
----

Delay times are in milliseconds and we wish to have a wide dynamic
range of times.

(((micca,Run Time Data,MRT_DelayTime)))
[source,c]
----
<<mrt interface simple types>>=
typedef uint32_t MRT_DelayTime ;
----

Note that there is no notion of priority contained in the ECB.
Some software architectures queue events in a priority order.
That is not supported here.
Frankly, if you need event priorities to make your system work,
then you need to revisit your design or look for a software architecture
that supports multiple threads of execution.

Like all the other data structures, there is a storage pool for ECB's
and we define a size for it here that can be overridden
on the compiler command line.
Sizing the pool for ECB's can be difficult.
It must be worst case allocation as running out of ECB's
is a fatal system error.
The pool must be sized to account for the maximum number of
events that can be in flight at the same time.
This includes delayed events, since they can be considered to be
slow flying events.

(((micca,Run Time Constant,MRT_EVENT_POOL_SIZE)))
[source,c]
----
<<mrt interface constants>>=
#ifndef MRT_EVENT_POOL_SIZE
#   define MRT_EVENT_POOL_SIZE 32
#endif /* MRT_EVENT_POOL_SIZE */
----

We must allocate the memory for the ECB storage.
As usual, storage is just an array of structures.

[source,c]
----
<<mrt static data>>=
static MRT_ecb mrtECBPool[MRT_EVENT_POOL_SIZE] ;
----

=== Event Parameter Storage [[event-parameter-storage]]

We need to design how events that carry parameteric data will operate.
In this formulation of state machines,
events may carry additional parameters.
Space has to be allocated for that data.
The difficulty is that the parameter data must be given a type.
There are a couple of solutions, neither of which is very satisfying.
We could collect all the parameters from all the state machines
in the system and create a giant union.
This would properly allocate the amount of parameter storage required
and provide a type safe manner to deal with that data.
Unfortunately, the parameters to states are scattered in very many
places in a system and gathering them together is a difficult
undertaking.

Here we take the approach of providing a fixed amount of memory and letting
state activities cast that memory into the appropriate type.
Needless to say, this can also be a source of errors, but is
much easier to manage.
This choice makes sense for many systems.
The number of states that use parametric data is usually small and using a
fixed size works better than might be expected upon first consideration.
The important point here is that events can carry data with them.
Many state machine formulations don't support this
and it is very difficult to correctly manage memory lifetime
without it.
It is one of those things that you might not use very often but
it is difficult to do without when you need it.

We fix the amount of memory used for event parameter storage,
allowing it to be overridden by the defining the appropriate macro.

(((micca,Run Time Constant,MRT_ECB_PARAM_SIZE)))
[source,c]
----
<<mrt interface constants>>=
#ifndef MRT_ECB_PARAM_SIZE
#   define MRT_ECB_PARAM_SIZE  32
#endif /* MRT_ECB_PARAM_SIZE */
----

(((micca,Run Time Data,MRT_EventParams)))
[source,c]
----
<<mrt interface simple types>>=
typedef char MRT_EventParams[MRT_ECB_PARAM_SIZE] ;
----

The platform model has been very careful to insure the type signatures
of events and state activities.
When signaling an event,
the code generator will generate code to insert event parameters into
the data area using the signature associated with the event.
In the state activity,
the parameters will be moved into local variables according to the
signature of the state activity.

Note that the parameters are passed by value but care must be taken when
passing pointer references to data (_e.g._ `NUL` terminated strings passed as
pointers). The run-time does nothing to manage the life time of the
storage when values are passed by reference.

=== Event Queues

In this run-time architecture,
we do asynchronous event dispatch from an event queue.
This is one of the simplest ways to insure that we meet the
requirement for state activities to run to completion.
Since a queue is used,
as a state activity executes and potentially signals other events,
we know those events will not be dispatched until after the state activity
completes.
Therefore,
there is no danger of a long complicated chain of event dispatching cycling
back around to alter the state of the instance or potentially modify some data
value that the state activity accesses after generating the event.
The guaranteed of run-to-completion for state activity execution is very
important.
We now examine the code that performs the queueing.

To serve as the head of the linked lists,
we define an event queue structure that just contains the
`next` and `prev` pointers.

(((micca,Run Time Data,MRT_EventQueue)))
[source,c]
----
<<mrt implementation aggregate types>>=
typedef struct mrteventqueue {
    MRT_ecb *next ;
    MRT_ecb *prev ;
} MRT_EventQueue ;
----

There are four queues that are used to manage events.

[source,c]
----
<<mrt static data>>=
static MRT_EventQueue eventQueue ;
static MRT_EventQueue tocEventQueue ;
static MRT_EventQueue delayedEventQueue ;
static MRT_EventQueue freeEventQueue ;
----

The `eventQueue` queue holds events waiting for immediate dispatch.
The events in this queue are those signaled as part of an
ongoing thread of control.
The `tocEventQueue` queue holds events that start a new thread of
control.
Typically,
those are events generated outside of a domain or delayed events finally
being delivered.
The `delayedEventQueue` queue holds events that are
to be delivered by the run-time at some future time.
Finally, the `freeEventQueue` queue holds those ECB's
that are not currently begin used.
From the data structures and the semantics of the queuing,
a given ECB can be on at most one of the queues at any time.
Most of the time each ECB is on exactly one of the queues,
but there are short times when an ECB is not in any queue and a pointer
to the ECB is held in a local variable.

The operations that are performed on event queues are associated with
adding and removing elements.
This code is very conventional and I'm sure you seen it or
something very much like it many times before.

(((micca,Run Time Function,mrtEventQueueBegin)))
[source,c]
----
<<mrt implementation static inlines>>=
static inline MRT_ecb *
mrtEventQueueBegin(
    MRT_EventQueue *queue)
{
    return queue->next ;
}
----

(((micca,Run Time Function,mrtEventQueueEnd)))
[source,c]
----
<<mrt implementation static inlines>>=
static inline MRT_ecb *
mrtEventQueueEnd(
    MRT_EventQueue *queue)
{
    return (MRT_ecb *)queue ;
}
----

(((micca,Run Time Function,mrtEventQueueEmpty)))
[source,c]
----
<<mrt implementation static inlines>>=
static inline bool
mrtEventQueueEmpty(
    MRT_EventQueue *queue)
{
    return queue->next == (MRT_ecb *)queue ;
}
----

(((micca,Run Time Function,mrtEventQueueInsert)))
[source,c]
----
<<mrt implementation static inlines>>=
static inline void
mrtEventQueueInsert(
    MRT_ecb *item,
    MRT_ecb *at)
{
    item->prev = at->prev ;
    item->next = at ;
    at->prev->next = item ;
    at->prev = item ;
}
----

(((micca,Run Time Function,mrtEventQueueRemove)))
[source,c]
----
<<mrt implementation static inlines>>=
static inline void
mrtEventQueueRemove(
    MRT_ecb *item)
{
    item->prev->next = item->next ;
    item->next->prev = item->prev ;
    item->prev = item->next = NULL ; // <1>
}
----
<1> Although it is not strictly necessary to NULL out the pointers when
an item is removed from the queue,
we do depend upon this to know that an item has been removed
from a list and can be placed into a different list.

Since we have a pool of ECB's,
we need some operations to manage the pool.
We start with initialization.
This places all the ECB's in the pool onto the free event queue.

(((micca,Run Time Function,mrtECBPoolInit)))
[source,c]
----
<<mrt static functions>>=
static void
mrtECBPoolInit(void)
{
    assert(MRT_EVENT_POOL_SIZE >= 1) ;
    /*
     * Initialize the queue terminus structures.
     */
    eventQueue.next = eventQueue.prev = (MRT_ecb *)&eventQueue ;
    tocEventQueue.next = tocEventQueue.prev = (MRT_ecb *)&tocEventQueue ;
    delayedEventQueue.next = delayedEventQueue.prev = (MRT_ecb *)&delayedEventQueue ;
    freeEventQueue.next = freeEventQueue.prev = (MRT_ecb *)&freeEventQueue ;
    /*
     * Place all the event control blocks on the free event
     * queue.  Allocation occurs from there.
     */
    for (MRT_ecb *ecb = mrtECBPool ;
            ecb < mrtECBPool + MRT_EVENT_POOL_SIZE ; ecb++) {
        mrtEventQueueInsert(ecb, (MRT_ecb *)&freeEventQueue) ;
    }
}
----

Event allocation is just removing an ECB from the free list.
_N.B._ that running out of Event Control Blocks is fatal.

(((micca,Run Time Function,mrtECBalloc)))
[source,c]
----
<<mrt static functions>>=
static inline MRT_ecb *
mrtECBalloc(void)
{
    if (mrtEventQueueEmpty(&freeEventQueue)) {
        mrtFatalError(mrtNoECB) ;
    }

    MRT_ecb *ecb = freeEventQueue.next ;
    mrtEventQueueRemove(ecb) ;
    memset(ecb, 0, sizeof(*ecb)) ; // <1>
    return ecb ;
}
----
<1> We zero out the ECB. Although not strictly necessary,
it is convenient for debugging, especially when there are event
parameters involved.

(((micca,Run Time Function,mrtECBfree)))
[source,c]
----
<<mrt static functions>>=
static inline void
mrtECBfree(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;

    mrtEventQueueInsert(ecb, mrtEventQueueEnd(&freeEventQueue)) ;
}
----

We will have need to find particular events in a queue.
Events are identified by the source of the event, the target of the event
and the number of the event.

(((micca,Run Time Function,mrtFindEvent)))
[source,c]
----
<<mrt static functions>>=
static MRT_ecb *
mrtFindEvent(
    MRT_EventQueue *queue,
    MRT_Instance *sourceInst,
    MRT_Instance *targetInst,
    MRT_EventCode event)
{
    /*
     * Simple iteration through the list of events in the queue.
     */
    for (MRT_ecb *iter = mrtEventQueueBegin(queue) ;
            iter != mrtEventQueueEnd(queue) ;
            iter = iter->next) {
        if (iter->sourceInst == sourceInst && iter->targetInst == targetInst &&
                iter->eventNumber == event) {
            return iter ;
        }
    }
    return NULL ;
}
----

=== Event Signaling

Signaling an event is a very common operation for a state activity.
In this section,
we describe the code to accomplish event signaling.

==== Obtaining An ECB

As we mentioned previously,
before an event can be signaled, we must obtain and fill in an ECB.
We start our description with a function that does just that.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern MRT_ecb *
mrt_NewEvent(
    MRT_EventCode event,
    void *target,
    void *source) ;
----

`event`::
    The numerical code for the event.
`target`::
    A pointer to the instance that is to receive the event.
`source`::
    A pointer to the instance that is sending the event.
    If the event is being sent outside of the context of a class instance,
    then this argument should be set to `NULL`.

The `mrt_NewEvent` function allocates an ECB structure,
fills in the elements and returns the newly minted ECB.
*****

(((micca,Run Time Function,mrt_NewEvent)))
[source,c]
----
<<mrt external functions>>=
MRT_ecb *
mrt_NewEvent(
    MRT_EventCode event,
    void *target,
    void *source)
{
    MRT_Instance *targetInst = target ;
    MRT_Instance *sourceInst = source ;

    assert(targetInst != NULL) ;
    assert(targetInst->alloc != 0) ;
    assert(event < targetInst->classDesc->eventCount) ;

    MRT_ecb *ecb = mrtECBalloc() ;

    ecb->eventNumber = event ;
    ecb->alloc = targetInst->alloc ;    // <1>
    ecb->targetInst = targetInst ;
    ecb->sourceInst = sourceInst ;
    ecb->delay = 0 ;                    // <2>

    return ecb ;
}
----
<1> Note that we initialize the ECB `alloc` member from the
target instance. This is an essential part of detecting _event in flight_
errors.
<2> Delayed event signaling will overwrite the zero with the requested
delay time.
Most frequently, we are performing immediate signaling.

==== Posting an Event

Once you have obtained an ECB initialized for an event,
then you need to fill in any event parameter data.
Frequently, there are no parameters for an event.
Then the ECB is ready to be placed on a queue.
There is a distinction between events an instance sends to itself and those
that an instance sends to a different instance.
Self directed events are placed on the front of the event queue
so that they are dispatched in preference to the non-self directed events.
This is one of the fundamental state machine dispatch rules.
Posting an event involves determining the correct place in the queue
for the ECB.
The decision is made based on the ECB values.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_PostEvent(
    MRT_ecb *ecb) ;
----

`ecb`::
    A pointer to an Event Control Block (ECB) that is to be queued
    for dispatch.

The `mrt_PostEvent` function queues the ECB pointed to by `ecb` to
an appropriate event queue.
*****

(((micca,Run Time Function,mrt_PostEvent)))
[source,c]
----
<<mrt external functions>>=
void
mrt_PostEvent(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;
    assert(ecb->targetInst != NULL) ;

        /*
         * The location in some event queue where the ECB will be inserted.
         */
    MRT_ecb *qloc ;

    if (ecb->sourceInst == NULL) {                              // <1>
        qloc = mrtEventQueueEnd(&tocEventQueue) ;
    } else if (ecb->sourceInst != ecb->targetInst) {            // <2>
        qloc = mrtEventQueueEnd(&eventQueue) ;
    } else {                                                    // <3>
        for (qloc = mrtEventQueueBegin(&eventQueue) ;
                qloc != mrtEventQueueEnd(&eventQueue) &&
                    qloc->sourceInst == qloc->targetInst ;
                qloc = qloc->next) {
            // N.B. -- empty loop
        }
    }

    mrtEventQueueInsert(ecb, qloc) ;
}
----
<1> All events that are signaled outside of a state activity start a
new thread of control.
So, the event is queued to the end of the thread of control event queue.
<2> Ordinary transitioning events directed between distinct instances
are queued to the end of the event queue.
<3> Self directed events are queued to the front of the event queue,
but we have to find the appropriate location.
That location is the first event in the queue that is not self directed.
The loop preserves the order of event dispatch in the highly unlikely
(but not technically illegal) case that a state activity signals multiple
self directed events.

==== One Step Event Signaling

For the case where the event has no parameters
or the parameters have already been marshalled into a parameter block,
a single function can create the event and post it.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_SignalEvent(
    MRT_EventCode event,
    void *targetInst,
    void *sourceInst,
    void const *eventparams,
    size_t paramsize) ;
----

`event`::
    The numerical code for the event.
`targetInst`::
    A pointer to the instance that is to receive the event.
`sourceInst`::
    A pointer to the instance that is sending the event.
    If the event is being sent outside of the context of a class instance,
    then this argument should be set to `NULL`.
`eventparams`::
    A pointer to the event parameters for the event.
    If the event requires no additional parameters, then this argument
    is passed as `NULL`.
`paramsize`::
    The number of bytes of event parameter data pointed to by `eventparams`.
    If the event requires no additional parameters, then this argument
    is passed as `0`.
*****

[source,c]
----
<<mrt external functions>>=
void
mrt_SignalEvent(
    MRT_EventCode event,
    void *targetInst,
    void *sourceInst,
    void const *eventparams,
    size_t paramsize)
{
    MRT_ecb *ecb = mrt_NewEvent(event, targetInst, sourceInst) ;

    if (eventparams != NULL) {
        assert(paramsize <= sizeof(ecb->eventParameters)) ;
        size_t toCopy = paramsize <= sizeof(ecb->eventParameters) ?
                paramsize : sizeof(ecb->eventParameters) ;
        memcpy(ecb->eventParameters, eventparams, toCopy) ;
    }

    mrt_PostEvent(ecb) ;
}
----

=== Asynchronous Instance Creation

As we mentioned earlier,
asynchronous instance creation is accomplished by a combination of
creating an instance and then sending it an event.
The transition caused by the event then causes a state activity to be
executed.
The creation is asynchronous in the sense that after an activity
requests an asynchronous creation, the return from the request is
immediate, but the instance does not come into existance until its
creation event is dispatched.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void *
mrt_CreateInstanceAsync(
    MRT_Class const *const targetClass,
    MRT_EventCode event,
    void const *eventparams,
    size_t paramsize,
    void *sourceInst) ;
----

`targetClass`::
    A pointer to the class description for the instance that is to
    be created.
`event`::
    The number of the event to signal to the newly created instance.
`eventparams`::
    A pointer to the event parameters for the creation event.
`paramsize`::
    The number of bytes of event parameter data pointed to by `eventparams`.
`sourceInst`::
    A pointer to the class instance that is the source of the creation
    event. If the creation event is signaled outside of a state activity,
    then this value should be `NULL`.

The `mrt_CreateInstanceAsync` function asynchronously creates an instance of the
class described by `targetClass` and arranges for `event` to be
signaled to the new instance.
Note the event parameters must be provided.
After the function returns,
the instance has been created in an inactive state and the event
has been posted.
The return value is the pointer to the newly created instance and
can be used to initialize the values of attribute of the instance.
*****

(((micca,Run Time Function,mrt_CreateInstanceAsync)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_CreateInstanceAsync(
    MRT_Class const *const targetClass,
    MRT_EventCode event,
    void const *eventparams,
    size_t paramsize,
    void *sourceInst)
{
    assert(targetClass != NULL) ;
    assert(targetClass->edb != NULL) ;
    assert(targetClass->edb->creationState >= 0) ;
    assert(event < targetClass->edb->eventCount) ;

    MRT_Instance *targetInst = mrt_CreateInstance(targetClass,
            targetClass->edb->creationState) ;                  // <1>
    targetInst->alloc = -targetInst->alloc ;                    // <2>

    mrt_SignalEvent(event, targetInst, sourceInst, eventparams, paramsize) ;

    return targetInst ;
}
----
<1> We want the instance created in the pseudo-initial state.
<2> The `alloc` member is made negative for instances that are awaiting
the dispatch of a creation event.
Effectively the negative `alloc` value signals that the memory is reserved
but the instance is not yet active.
During event dispatch, this value will be turned back into a positive one.
Note that the effect here is to use one of the instance slots as a
temporary buffer to hold the attribute values for the instance until
the creation event is dispatched.
This temporary usage must be accounted for when defining the number
of instance memory slots for a class.

As we have already seen,
subclass instances stored as a union require separate treatment.
The following function is the asynchronous counterpart to
`mrt_CreateUnionInstance`.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void *
mrt_CreateUnionInstanceAsync(
    MRT_Class const *const targetClass,
    MRT_EventCode event,
    void const *eventparams,
    size_t paramsize,
    void *sourceInst,
    MRT_Relationship const *const genRel,
    void *super) ;
----

`targetClass`::
    A pointer to the class description for the instance that is to
    be created.
    The class described by `classDesc` must be a subclass of the
    relationship described by `genRel`.
`event`::
    The number of the event to signal to the newly created instance.
`eventparams`::
    A pointer to the event parameters for the creation event.
`paramsize`::
    The number of bytes of event parameter data pointed to by `eventparams`.
`sourceInst`::
    A pointer to the class instance that is the source of the creation
    event. If the creation event is signaled outside of a state activity,
    then this value should be `NULL`.
`genRel`::
    A pointer to a relationship description for the generalization
    in which the instance is a union-based subclass.
    The `relType` field of `genRel` must be `mrtUnionGeneralization`.
`super`::
    A pointer to the superclass instance where the subclass instance
    is to be created.
    `super` must be an instance of the superclass described by `genRel`.

The `mrt_CreateUnionInstanceAsync` function asynchronously creates an instance
of the union-based subclass described by `targetClass`
and arranges for `event` to be signaled to the new instance.
Note the event parameters must be provided.
After the function returns,
the instance has been created in an inactive state and the event
has been posted.
The return value is the pointer to the newly created instance and
can be used to initialize the values of attribute of the instance.
*****

Like the `mrt_CreateUnionInstance` function,
the main change here is that the memory for the instance is located in
the space allocated for its related superclass instance.


(((micca,Run Time Function,mrt_CreateUnionInstanceAsync)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_CreateUnionInstanceAsync(
    MRT_Class const *const targetClass,
    MRT_EventCode event,
    void const *eventparams,
    size_t paramsize,
    void *sourceInst,
    MRT_Relationship const *const genRel,
    void *super)
{
    assert(targetClass != NULL) ;
    assert(targetClass->edb != NULL) ;
    assert(targetClass->edb->creationState >= 0) ;
    assert(event < targetClass->edb->eventCount) ;

    MRT_Instance *targetInst = mrt_CreateUnionInstance(targetClass,
            targetClass->edb->creationState, genRel, super) ;
    targetInst->alloc = -targetInst->alloc ;                            // <1>

    mrt_SignalEvent(event, targetInst, sourceInst, eventparams, paramsize) ;

    return targetInst ;
}
----
<1> As with non-union classes, we mark the instance as allocated but
not active. When the creation event is dispatched, the allocation status
is changed to indicate the instance is active.

=== Delayed Events

The concept of a delayed event is to request the run-time to post
an event at some time in the future.
This implies that the run-time has access to some type of timing
facility by which it can know that a given amount of time has elapsed
and this implies that the run-time will hold on to the ECB until
that future time has arrived.
We also interpret delayed events as being signaled from outside
of an instance context.
So, all delayed events start a new thread of control when they are
dispatched.

There is one significant XUML rule associated with delayed events.
There can be only one outstanding delayed event of a given event
type between any sending / receiving pair of instances
(which may be the same instance).
This is another way of stating that delayed events are identified by
their event name (or numerical encoding), the target instance
and the source instance.
There are a number of ways to interpret an attempt to generate
what amounts to a duplicate delayed event.
It could be considered an error, but that is inconvenient
and goes against the grain of our attempts to minimize run-time errors.
So the run-time regards an attempt to generate a delayed event
of the same name between the same sending and receiving pair as
a request to cancel the original event and create the new one
at its newly given time.
This turns out to be very convenient in practice, eliminating the
need to perform checks.
Cancelling and reinstating a new event turns out to be what is
desired in most circumstances.

To understand the implementation of delayed events,
it is necessary to understand the way the delayed event queue
is maintained.
The run-time has a delayed event queue where ECB's are placed awaiting
to be posted.
In servicing the delayed events,
we are particularly trying to avoid doing any periodic computation.
For example, we could treat the delayed event queue as a simple list
and wake up periodically and run down the list decrementing time values
and checking if any events have expired.
Such a scheme is easy to implement, but in highly embedded and power
sensitive application,
periodic activity of this type is wasteful and deemed inappropriate.

In this implementation, we keep the delayed event queue in time relative
order.
This design meets two important criteria; only a single source of timing
is used and there is no periodic execution activity.
The cost of meeting these criteria is the price paid
to find the appropriate place in the delayed event queue when a
delayed event is requested.

There is sometimes a temptation for analysts to try to use delayed
events for precise timing control over external interactions.
For example,
you could conceive of using delayed events as a means of generating
a pulse width modulated (PWM) square wave to control a motor.
Delayed events are generally *not* suitable for high speed, high precision
timing such as that required by motor control.
Since we are using only a single timing resource that is shared
in the system,
we are not able to achieve the precise jitter free timing that would be
needed for a PWM.
Most microcontrollers have many timing resources available in hardware
and they should be used for functions that require high precision.
What delayed events are most useful for is time outs for interactions
in the millisecond to minutes range and for those functions
where some jitter in the timing is acceptable (_e.g._ blinking an LED).
The delayed event time is only guaranteed to be the minimum amount
of time that is to elapse before the event is delivered.

There are three functions supplied for dealing with delayed events:

. Post a delayed event.
. Cancel a delayed event.
. Query the remaining time for a delayed event.

The unit of time for delayed events is milliseconds.

==== Posting A Delayed Event

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_PostDelayedEvent(
    MRT_ecb *ecb,
    MRT_DelayTime time) ;
----

`ecb`::
    A pointer to an Event Control Block (ECB) that is to be queued
    for dispatch.
`time`::
    The minimum number of milliseconds of time that must elapse before
    the event given by `ecb` is posted for dispatch.

The `mrt_PostDelayedEvent` function requests that the event given by
`ecb` be dispatched no sooner than `time` milliseconds from now.
The value of the `time` argument may be 0,
in which case the event is posted for dispatch immediately.
All delayed events start a new thread of control.
Any request to post a delayed event of the same event number that
already exists for some sending / receiving pair of instances results
in the first event being canceled and a the event being posted at the
given delay time.
*****

(((micca,Run Time Function,mrt_PostDelayedEvent)))
[source,c]
----
<<mrt external functions>>=
void
mrt_PostDelayedEvent(
    MRT_ecb *ecb,
    MRT_DelayTime time)
{
    assert(ecb != NULL) ;

    mrtStopDelayedQueueTiming() ;                                   // <1>
    mrtRemoveDelayedEvent(ecb->sourceInst, ecb->targetInst,
            ecb->eventNumber) ;

    MRT_ecb *qloc ;
    if (time != 0) {                                                // <2>
        ecb->delay = mrtMsecToTicks(time) ;
        for (qloc = mrtEventQueueBegin(&delayedEventQueue) ;
                qloc != mrtEventQueueEnd(&delayedEventQueue) ;
                qloc = qloc->next) {
            if (ecb->delay < qloc->delay) {                         // <3>
                qloc->delay -= ecb->delay ;                         // <4>
                break ;
            } else {
                ecb->delay -= qloc->delay ;
            }
        }
        // <5>
    } else {
        qloc = mrtEventQueueEnd(&tocEventQueue) ;                   // <6>
    }
    mrtEventQueueInsert(ecb, qloc) ;
    mrtStartDelayedQueueTiming() ;                                  // <7>
}
----
<1> The timing queue must be stopped so we may examine it safely.
<2> Insert the event if a non-zero delay was requested.
We walk down the queue to find the correct slot.  That slot is the
first place in the queue where our delay value is less than the delay
value at that place in the queue.  As we walk the queue, we subtract
the delay value of each entry we pass since that entry will have
expired before the one being inserted.
<3> By keeping this comparison to be strictly less than, we preserve
the order of event dispatch to match that of event generation.
<4> We are going to insert before the entry pointed to by `iter`.
Therefore, we need to decrease its delay value by the amount of
time that will have elapsed after the entry we are about to
insert expires.
<5> At this point we have found our place in the queue.
Either we are between entries or this delay was longer than the cumulative
delays of all the ECB's in the queue. Insert the ECB.
<6> All delayed events start a new thread of control,
even those which have a zero delay time.
<7> Start the timer to expire for the first event on the queue.

We see here the distinction between posting a delayed event and
the ordinary posting of an event.
For delayed events,
the event will end up on the delayed event queue or the thread of
control queue.
The determining factor is the delay time.
If the delay is zero, then the event goes to the thread of control
queue directly.
Otherwise, it is placed on the thread of control queue after the
delay time.
Delayed events never go to the ordinary event queue.

There are five main actions for inserting a delayed event.

. Convert the delay value from millisecond units to
units of `ticks`.
A tick is platform specific.
Computers sometimes don't typically keep time in conventional human units,
particularly small embedded systems as we are dealing with.
However, we would like to run the delayed event queue in system
specific units to avoid as much unnecessary conversion as we can.
This conversion will be described below for each supported platform.
. Stop the timing of the delayed event queue.
More on this later but the goal of stopping the delayed event
queue timing is to freeze the state of the queue so that we
may operate on it.
. Determine if there is already an event matching the one begin posted.
This enforces the rule about not having two delayed events of the
same type between the same sending / receiving pair.
If one is found then it is removed.
. Assured of no duplicates, the new event can be inserted into the timing
queue.
. Finally, the timing of the delayed queue is started.

==== One Step Delayed Event Signaling

Just as for non-delayed events,
delayed events without additional parameters or for which the parameters
have been marshalled into a parameter block,
a single function can both fill in an ECB and post it to the delayed event
queue.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_SignalDelayedEvent(
    MRT_DelayTime time,
    MRT_EventCode event,
    void *targetInst,
    void *sourceInst,
    void const *eventparams,
    size_t paramsize) ;
----

`time`::
    The minimum number of milliseconds of time that must elapse before
    the event is to be dispatched.
`event`::
    The numerical code for the event.
`targetInst`::
    A pointer to the instance that is to receive the event.
`sourceInst`::
    A pointer to the instance that is sending the event.
    If the event is being sent outside of the context of a class instance,
    then this argument should be set to `NULL`.
`eventparams`::
    A pointer to the event parameters for the event.
    If the event requires no additional parameters, then this argument
    is passed as `NULL`.
`paramsize`::
    The number of bytes of event parameter data pointed to by `eventparams`.
    If the event requires no additional parameters, then this argument
    is passed as `0`.
*****

[source,c]
----
<<mrt external functions>>=
void
mrt_SignalDelayedEvent(
    MRT_DelayTime time,
    MRT_EventCode event,
    void *targetInst,
    void *sourceInst,
    void const *eventparams,
    size_t paramsize)
{
    MRT_ecb *ecb = mrt_NewEvent(event, targetInst, sourceInst) ;

    if (eventparams != NULL) {
        assert(paramsize <= sizeof(ecb->eventParameters)) ;
        size_t toCopy = paramsize <= sizeof(ecb->eventParameters) ?
                paramsize : sizeof(ecb->eventParameters) ;
        memcpy(ecb->eventParameters, eventparams, toCopy) ;
    }

    mrt_PostDelayedEvent(ecb, time) ;
}
----

Since removing delayed events is something we do
when canceling a delayed event,
we factor out the code into a function.

(((micca,Run Time Function,mrtRemoveDelayedEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtRemoveDelayedEvent(
    MRT_Instance *sourceInst,
    MRT_Instance *targetInst,
    MRT_EventCode eventNumber)
{
    MRT_ecb *found = mrtFindEvent(&delayedEventQueue, sourceInst,
            targetInst, eventNumber) ;                                  // <1>
    if (found != NULL) {
        if (!(found->delay == MRT_DELAY_EXPIRED ||                      // <2>
            found->next == mrtEventQueueEnd(&delayedEventQueue))) {
            found->next->delay += found->delay ;
        }
    } else {
        found = mrtFindEvent(&tocEventQueue, sourceInst, targetInst,
                eventNumber) ;
    }
    if (found != NULL) {
        mrtEventQueueRemove(found) ;
        mrtECBfree(found) ;
    }
    // <3>
}
----
<1> If the event already exists, remove it.
First we search the delayed event queue. If we don't find the event
there, it could have already expired and it would then be on the
Thread of Control event queue. If we find it in either place, it
is a duplicate event and it is removed. This is in keeping with our
interpretation that a duplicate delayed event is a request to cancel
the first and create one with a new delay time.
<2> If event is not already expired and the event is not at the end of the
queue, all the delay from the removed entry is added onto the next
entry in the queue. This keeps insures that the time associated with
the deleted event is accounted for when subsequent events expire.
<3> If we get here and `found` is still `NULL`, then there was no
delayed event matching the source / target / event and we just do
nothing.

==== Canceling Delayed Events

Cancelling a delayed event is one of the more complicated delayed event
operations.
We must account for the various places where a delayed event may be queued.

A delayed event may be in one of two places:

. In the delayed event queue awaiting either waiting for its time to expire
or having already been marked as expired.
. In the thread of control event queue awaiting dispatch.

We will have more to say about event dispatch below,
but it is possible to try to cancel an event after its time has
expired but before it has been delivered to the target instance.
The mechanisms make the guarantee that after invoking
`mrt_EventDelayCancel`
the application can be assured that the event will *not* be
delivered until such time when it is posted again.
Note that it is possible to attempt to cancel a delayed event after
it has already been delivered.
This is not an error.
Unfortunately, the run-time code cannot turn time backwards.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern void
mrt_CancelDelayedEvent(
    MRT_EventCode event,
    void *target,
    void *source) ;
----

`event`::
    The number of the event.
`targetInst`::
    A pointer to the instance structure that is to receive the event.
`sourceInst`::
    A pointer to the instance structure that is sending the event.
    Events generated outside of a class instance set this argument to `NULL`.

The `mrt_CancelDelayedEvent` function cancels the delayed event
given by `event` and signaled from `source` to `target`.
After the return from this function the event is guaranteed not to be
delivered.
*****

(((micca,Run Time Function,mrt_CancelDelayedEvent)))
[source,c]
----
<<mrt external functions>>=
void
mrt_CancelDelayedEvent(
    MRT_EventCode event,
    void *target,
    void *source)
{
    assert(target != NULL) ;

    mrtStopDelayedQueueTiming() ;                           // <1>
    mrtRemoveDelayedEvent(source, target, event) ;
    mrtStartDelayedQueueTiming() ;
}
----
<1> As before, we must stop the delayed queue so we can
examine and manipulate it.
We can't have delayed queue operations go on while we are walking
and changing the queue contents.

Like all operations dealing with the delayed event queue,
we must first put the queue in a state that we
can examine it without asynchronous timing services
modifying its state.
Then we search the delayed event queue for the event to cancel.
The only complication in the implementation is the need to search the thread of
control event queue should the ECB have already been expired off of the delayed
queue.

==== Time Remaining for a Delayed Event

The last provided operation on delayed events is to query the amount
of time remaining for a particular delayed event.
Since we hold the delayed events in sorted order of time differences,
the task of determining the amount of remaining time involves
traversing the queue and summing the time increments of all the
events in front of the event of interest.
The only special case here is what to do if we don't find the
delayed event at all.
In that case, zero is returned.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern MRT_DelayTime
mrt_RemainingDelayTime(
    MRT_EventCode event,
    void *target,
    void *source) ;
----

`event`::
    The number of the event.
`targetInst`::
    A pointer to the instance structure that is to receive the event.
`sourceInst`::
    A pointer to the instance structure that is sending the event.
    Events generated outside of a class instance set this argument to `NULL`.

The `mrt_RemainingDelayTime` function returns the amount of time
remaining before the `event` is posted from `source` to `target`.
The remaining time will be 0 if the event has already been posted or
is such a delayed event does not exist.
A return value of 0 does _not_ imply that the event has already been
dispatched.
*****

The algorithm for computing the remaining time is to simply walk the
delayed event queue from the beginning, summing up the
set of time delays until we reach the ECB of delayed event.

(((micca,Run Time Function,mrt_RemainingDelayTime)))
[source,c]
----
<<mrt external functions>>=
MRT_DelayTime
mrt_RemainingDelayTime(
    MRT_EventCode event,
    void *target,
    void *source)
{
    MRT_Instance *targetInst = target ;
    MRT_Instance *sourceInst = source ;
    assert(targetInst != NULL) ;

    mrtStopDelayedQueueTiming() ;
    /*
     * Iterate through the delayed event time and sum all the delay times to
     * give the total amount of time remaining for the found event.
     */
    MRT_DelayTime remain = 0 ;
    MRT_ecb *iter ;
    MRT_ecb *endOfQueue = mrtEventQueueEnd(&delayedEventQueue) ;
    for (iter = mrtEventQueueBegin(&delayedEventQueue) ; iter != endOfQueue ;
            iter = iter->next) {
        remain += iter->delay ;
        if (iter->sourceInst == sourceInst && iter->targetInst == targetInst &&
                iter->eventNumber == event) {
            break ;
        }
    }
    mrtStartDelayedQueueTiming() ;
    /*
     * Return the amount of time remaining for the event.  If we didn't find
     * the event, the just return 0.
     */
    return iter == endOfQueue ? 0 : mrtTicksToMsec(remain) ;
}
----

Note that zero is returned if we did not find the event on the
delayed queue.
Returning zero does _not_ tell us if the event has already been
dispatched or might be still in flight on the event queue.

==== Expired Events in the Delayed Event Queue

When the delay time expires there are several ways to deal with the events
that need to be dispatched.
One approach would be simply to sync to the background and let code
run there to remove expired events from the delayed event queue
and restart the timer.
Such a design is subject to problematic, unpredictable timing skew.
After the timer source has expired and posted the synchronization request,
the background may not execute immediately.
Either a currently executing state activities or a previously queued
sync function would delay the transfer of expired events from the delayed
queue to the event queue.
If there if another delayed event to expire,
we would like to start the expiration timing without inserting some
unpredictable time in between.
Essentially, we would like to overlap the timing of the next delayed
event with the time it takes to complete the current activities and
execute the timer sync request.

This design chooses to mark the events in the delayed event queue as
expired and that provides a means of knowing which events in the delayed
queue are active.
The question then is how to signify that an event in the delayed event queue
has expired.
Since a delay value of 0 is meaningful, we use a delay value of
the maximum for a delay time as the expired marker.
We mark the `delay` member of the ECB with a special value to indicated that
it has expired but not yet been removed from the delayed event queue.
This allows us to keep track of the state of the ECB in the delayed
event queue and still find the next timer interval during the timer
interrupt service routine.

[source,c]
----
<<mrt implementation constants>>=
#define MRT_DELAY_EXPIRED  UINT32_MAX
----

The `mrtExpireDelayedEvents` function is run to traverse the delayed event
queue and mark any events that have a delay value of 0 as expired.
It is used both in the delayed event timer service as well as in the background
processing of the delayed event queue.
The return value is pointer to an ECB.
This will be `NULL` if there are no other events in the delayed queue that
require timing.
Otherwise,
the returned ECB pointer will reference the first unexpired,
non-zero delay event.
The semantics are a bit strained,
but the function is used for two distinct purposes.

[source,c]
----
<<mrt forward references>>=
static MRT_ecb *mrtExpireDelayedEvents(void) ;
----

(((micca,Run Time Function,mrtExpireDelayedEvents)))
[source,c]
----
<<mrt static functions>>=
static MRT_ecb *
mrtExpireDelayedEvents(void)
{
    /*
     * Iterate along the delayed event queue.
     */
    for (MRT_ecb *iter = mrtEventQueueBegin(&delayedEventQueue) ;
            iter != mrtEventQueueEnd(&delayedEventQueue) ;
            iter = iter->next) {
        if (iter->delay == 0) {
            /*
             * Mark all the events that have zero delay time as expired.
             */
            iter->delay = MRT_DELAY_EXPIRED ;
        } else if (iter->delay != MRT_DELAY_EXPIRED) {
            /*
             * Stop at the first non-zero delay time.  This marks the boundary
             * of events that need additional delay time.  The first such event
             * is the next amount of time to delay.
             */
            return iter ;
        }
        /*
         * else ... Skip any events that might already be expired.
         */
    }
    /*
     * We have run the queue without finding an unexpired event.
     */
    return NULL ;
}
----

The function below is then run in the background to re-queue the
expired events.

(((micca,Run Time Function,mrtTransferExpiredEvents)))
[source,c]
----
<<mrt static functions>>=
static void
mrtTransferExpiredEvents(void)
{
    /*
     * Iterate through the delayed event queue looking for those entries that
     * have been marked as expired.
     */
    for (MRT_ecb *iter = mrtEventQueueBegin(&delayedEventQueue) ;
            iter != mrtEventQueueEnd(&delayedEventQueue) &&
            iter->delay == MRT_DELAY_EXPIRED ; /* empty 3rd expression */) {
        /*
         * Advance the iterator here, because we are about to invalidate it by
         * removing the entry from the queue.
         */
        MRT_ecb *ecb = iter ;
        iter = iter->next ;
        /*
         * Remove the ECB from the delayed queue and insert it into the thread
         * of control event queue for dispatch.
         */
        mrtEventQueueRemove(ecb) ;
        mrtEventQueueInsert(ecb, mrtEventQueueEnd(&tocEventQueue)) ;
    }
}
----

The concept of starting the delayed event queue timing is
associated with starting the timing resource with the delay time of the
event on the front of the delayed queue.
We move the delay value from the head of the delayed event queue
into the timer and zero the delay member.

[source,c]
----
<<mrt forward references>>=
static void mrtStartDelayedQueueTiming(void) ;
----

(((micca,Run Time Function,mrtStartDelayedQueueTiming)))
[source,c]
----
<<mrt static functions>>=
static void
mrtStartDelayedQueueTiming(void)
{
    if (!mrtEventQueueEmpty(&delayedEventQueue)) {
        MRT_ecb *ecb = mrtEventQueueBegin(&delayedEventQueue) ;
        assert(ecb->delay != 0) ;
        mrtSysTimerStart(ecb->delay) ;
        ecb->delay = 0 ;
    }
}
----

An analogous operation is needed to stop the queue timing.
Any remaining time is set back into the first entry on the queue.
This puts the queue into a state where ECB's can be inserted,
deleted or summed to find the time remaining for an event.

[source,c]
----
<<mrt forward references>>=
static void mrtStopDelayedQueueTiming(void) ;
----

(((micca,Run Time Function,mrtStopDelayedQueueTiming)))
[source,c]
----
<<mrt static functions>>=
static void
mrtStopDelayedQueueTiming(void)
{
    /*
     * Avoid the whole thing if there is nothing in the delayed event queue.
     */
    if (!mrtEventQueueEmpty(&delayedEventQueue)) {
        /*
         * Stop the timer, obtaining the residual time.
         */
        MRT_DelayTime remain = mrtSysTimerStop() ;
        /*
         * There are two cases here. It is possible for the remaining time
         * returned from mrtSysTimerStop() to be zero. This can happen if the
         * physical timing resource (which might be running asynchronously to
         * the processor) happens to expire within a single tick as we are
         * stopping it.
         */
        if (remain == 0) {
            /*
             * Since the timer has expired we must mark any events with a zero
             * delay time value as expired and, since we are running in the
             * background here, transfer the expired events to be dispatched.
             */
            mrtExpireDelayedEvents() ;
            mrtTransferExpiredEvents() ;
            /*
             * At this point, either the delayed event queue is empty, or the
             * event at the head of the queue has a non-zero delay time.
             */
        } else {
            /*
             * It is possible that the timing resource expired and its
             * interrupt service ran just before we could get the timer
             * stopped. That would mean that there are expired events on the
             * delayed queue at this point and we need to transfer them off the
             * delayed queue to be dispatched.
             */
            mrtTransferExpiredEvents() ;
            /*
             * If any events expired, the delayed event queue might now be
             * empty. However, if the queue is not empty, we must make sure the
             * entry at the head preserves the remaining amount of time that
             * needs to elapse.
             */
            if (!mrtEventQueueEmpty(&delayedEventQueue)) {
                MRT_ecb *ecb = mrtEventQueueBegin(&delayedEventQueue) ;
                assert(ecb->delay == 0) ;
                ecb->delay = remain ;
            }
        }
    }
}
----

Conceptually, starting and stopping the queue timing moves the time value
of the first ECB on the delay queue into and out of the real timing
resource (whatever that may be).
So when the the delayed event queue timing is running,
at least the first ECB on the queue will have a zero delay time.
When it is stopped, we must insure that the first queued ECB has a non-zero
delay time.

There is a race condition between the background code executing
`mrtStopDelayedQueueTiming()` and
the timer services that may run asynchronously as an interrupt.
After the return from `mrtSysTimerStop()` the timer will have been stopped
and will not cause any interrupt.
However, at any time previous to that the timer interrupt might have gone off
and expired one or more events.
Although a sync function will have been posted,
it will *not* have had an opportunity to run.
So we must make sure to transfer any expired events to the event queue.
This insures that the event generation does not get out of order.

The other complication here is that we might stop the timer just the instant
before it expired.
In this case the underlying timer services might think that there is no
time left on the timer, but the timer interrupt did not actually occur.
This is the case where we just win the race as opposed to the previous
situation where we just lost the race.
So, just in case, we transfer any events on the delay queue that happen
to show zero delay times to the event queue.


The `mrt_TimerExpireService` function is provided
for the asynchronous timer execution to call that performs task of expiring
events and finding the next time that needs to be placed in the timer.

[source,c]
----
<<mrt external interfaces>>=
/*
 * Must be invoked from interrupt service level only!
 */
extern MRT_DelayTime
mrt_TimerExpireService(void) ;
----

(((micca,Run Time Function,mrt_TimerExpireService)))
[source,c]
----
<<mrt external functions>>=
MRT_DelayTime
mrt_TimerExpireService(void)
{
    /*
     * Sync to the background to request the expired events be transferred to
     * the event queue.
     */
    mrt_SyncRequest(mrtExpiredEventService) ;
    /*
     * Mark the delayed events as expired, returning a pointer to the first
     * unexpired event.
     */
    MRT_ecb *unexpired = mrtExpireDelayedEvents() ;
    MRT_DelayTime nextTime ;
    if (unexpired) {
        /*
         * If there is an unexpired event, then its delay time is the next time
         * to expire. We return that time and zero out the delay time.
         */
        assert(unexpired->delay != 0) ;
        nextTime = unexpired->delay ;
        unexpired->delay = 0 ;
    } else {
        /*
         * Otherwise, there is nothing else to time.
         */
        nextTime = 0 ;
    }

    return nextTime ;
}
----

. The function assumes it is called from interrupt service level,
_i.e._ it assumes that it may touch the delayed
event queue with impunity since it cannot be interrupted by other
code that might manipulate the state of those queues.
. The function returns the next time to expire.
The caller is responsible for placing that time into the
timer facility if it is non-zero.
If the returned time is zero,
then the timer facility is not currently needed and should
remain stopped.

Notice that the function `mrtExpiredEventService` is queued
as as sync function to perform the last step of moving
the expired events to the event queue.
The run-time uses its own internal facilities to post this
function as a sync function.
This insures that delayed event posting is no different than
any other interrupt synchronization and preserves the notion that the event
queues are not accessed by interrupt service code and therefore do
not need to be guarded by a critical section.

(((micca,Run Time Function,mrtExpiredEventService)))
[source,c]
----
<<mrt static functions>>=
static void
mrtExpiredEventService(
    MRT_SyncParams const *params) /* Not used */
{
    /*
     * Since the expired event queue is accessed here, we must make sure that
     * the timer interrupt does not go off.
     */
    mrtSysTimerMask() ; // <1>
    mrtTransferExpiredEvents() ;
    mrtSysTimerUnmask() ;
}
----
<1> We do have to guard the delayed event queue from any timer interrupt.

==== Timing Considerations

With timing being such a common activity in programming,
there are very many system specific situations that arise in
obtaining timing services on any particular platform.
When running on top of an operating system,
it will provide the necessary timing services.
Unfortunately, the interface to those services varies from OS to OS.
On bare metal platforms,
generally you will have to get timer peripherals and interrupts
involved.
We will do what we can here to factor away the essential logic
from the platform specific,
but note that getting delayed event services running on any particular
platform will require some additional work.

We will try to make as few assumptions about the available timing services
of the platform as we can.
Here are the constraints on the timing services:

* The is only a single source of timing.
    That timing source allows us to specify some time value to it
    and it will respond with some notification (_e.g._ an interrupt)
    when the given time has elapsed.
* It is possible to stop the timing and determine how much time
    remains before it expires.
* It is not acceptable to execute code periodically that does nothing.
    This is to account for battery powered devices that cannot afford to
    wake up and check a timing queue only to find out that there is nothing
    to do.
    Activity must be strictly event driven and that implies that
    we can get positive notification when a time period has elapsed.

=== Event Dispatch

Finally, we arrive at the point where we can discuss event dispatching.
Up until this time,
we have been concerned with signaling events,
_i.e._ queuing events to be delivered.
Now we examine the means by which events are delivered to target instances.

First,
we must clarify that despite the fact we have been discussing the
_event queue_ as if it were a single entity,
there are in fact two queues used for dispatching events.
The reason for two queues is that we need a way to determine the boundaries
of a _thread of control_.

All events that originate outside of a state activity or are the
result of a delayed event start a thread of control.
The thread of control ends when all the subsequent events that originate
from the event starting the thread of control have been dispatched
and any activities resulting from the event dispatch has been run.
A thread of control is an important concept because its boundaries
determine when the data model must be consistent and when we can
check the referential integrity.

So our strategy is to use one queue to hold events that start a
thread of control and another queue to hold the events that are awaiting
dispatch for the ongoing thread of control.
When the queue for the ongoing thread of control is empty,
then we can start a new thread of control by using events queued
to the thread of control queue.
When both queues are empty,
there is no work to be done and we must wait for subsequent
interactions of the system with the outside world.

==== Dispatching An Event From a Queue [[dispatching-an-event-from-a-queue]]

When the run-time needs to dispatch an event it invokes the
`mrtDispatchEventFromQueue` function.
This function takes as a parameter
the queue from which the event is to be dispatched.

(((micca,Run Time Function,mrtDispatchEventFromQueue)))
[source,c]
----
<<mrt forward references>>=
static bool mrtDispatchEventFromQueue(MRT_EventQueue *queue) ;

<<mrt static functions>>=
static bool
mrtDispatchEventFromQueue(
    MRT_EventQueue *queue)
{
    static MRT_ecb *ecb = NULL ;            // <1>

    if (ecb != NULL) {                      // <2>
        mrtECBfree(ecb) ;
        ecb = NULL ;
            #if (defined(__ARM_ARCH) &&  __ARM_ARCH == 7)
        __set_BASEPRI(0) ;
            #endif /* __ARM_ARCH */
    }

    if (!mrtEventQueueEmpty(queue)) {
        ecb = queue->next ;
        mrtEventQueueRemove(ecb) ;

            #if (defined(__ARM_ARCH) &&  __ARM_ARCH == 7)
        __set_BASEPRI(MRT_PENDSV_PRIORITY) ;// <3>
            #endif /* __ARM_ARCH */

        mrtDispatchEvent(ecb) ;             // <4>

            #if (defined(__ARM_ARCH) &&  __ARM_ARCH == 7)
        __set_BASEPRI(0) ;
            #endif /* __ARM_ARCH */

        mrtECBfree(ecb) ;
        ecb = NULL ;

        return true ;
    }

    return false ;
}
----
<1> There is a tricky complication in dispatching an event.
It is possible for the event dispatch to cause a fatal error.
It is also possible to override the fatal error handler to deal
with system specific issues.
The overridden fatal error handler can `longjmp` out of the run-time code.
Indeed this is the preferred way for testing code.
However, if this happens,
we could loose the ECB that caused the fatal error.
So, while we are dispatching the event,
the ECB is stored in a static variable and that static variable
is used to indicate the state of completion of the event dispatch.
<2> If the ECB is still around, we presume that we did _not_ complete
the function after the invocation of `mrtDispatchEvent`.
In that case we free our dangling ECB pointer.
All event dispatch comes through this function,
so a single pointer suffices to save the state of the last dispatch.
<3> This is part of the exception processing that is used in the ARM v7-M
platform and is explained below.
This call prevents any synchronization functions from being invoked.
<4> Invoking `mrtDispatchEvent` causes transitions in the state maching
and can potentially generate a fatal system error.

There are two distinct types of events: transitioning events and
polymorphic events.
The event types are distinct in that the numerical encoding of the
events is used in different ways.
In the <<platform-event-class,platform model>>,
all the events for a given state model must have distinct names.
The distinction in the platform model between Transitioning Event
and Deferred Event is the difference we now see between an ordinary
transition event and a polymorphic event.
The code generator will assign a unique integer to each event.
The set of transition events will be encoded sequentially
starting at 0 up to E - 1,
where E is the number of transitioning events in the state model.
Polymorphic events for the class are then encoded starting at E
up to E + P - 1, where P is the number of polymorphic events.
Note that only superclasses that have both polymorphic events
(either defined or inherited) and
a state model of its own will have both transition events and
polymorphic events defined for it.
However, all events have a unique name in the platform model
and a unique numerical encoding in the run-time.

Encoding the event number in this fashion makes it convenient to
identify an event for a class when, for example, it is in a delayed
event queue.
As we will see below,
at dispatch time, any polymorphic event numbers will have the number
of transition events for the class (E in the discussion above)
subtracted from their encoded number so that they can be used as an
array index into the data structures used for polymorphic event mapping.

There is a secondary usage of transition events for asynchronous
instance creation.
A transition event that is dispatched when the current state of the
instance is the pseudo-initial creation state is deemed a creation event.
We wish to treat creation events separately because of the
design strategy we have used to implement asynchronous instance creation.
The strategy creates the instance in the creation state, marks its
memory slot as allocated but inactive,
and queues a transition event.
When the event is dispatched, the instance memory slot must be marked 
active and a transition event dispatch happens.
By marking the instance as inactive, but allocated, we can make sure
the instance data is not accessed during the time between when it
was created and when the creation event is actually dispatched.
But, because there is additional processing to be done before a creation
event is dispatched as a transition event,
we have to be able to identify a transition event as being using
in an asynchronous instance creation context.

We provide separate functions to dispatch each event type.

[source,c]
----
<<mrt forward references>>=
static void mrtDispatchTransitionEvent(MRT_ecb *ecb) ;
static void mrtDispatchPolymorphicEvent(MRT_ecb *ecb) ;
static void mrtDispatchCreationEvent(MRT_ecb *ecb) ;
----

Once an event has been chosen for dispatch,
the logic to determine the type of the event and, therefore,
which dispatch function to invoke is shown below.

[source,c]
----
<<mrt forward references>>=
static void mrtDispatchEvent(MRT_ecb *ecb) ;
----

(((micca,Run Time Function,mrtDispatchEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDispatchEvent(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;

    MRT_Instance *targetInst = ecb->targetInst ;
    assert(targetInst != NULL) ;

    MRT_Class const *const classDesc = targetInst->classDesc ;
    assert(classDesc != NULL) ;

    MRT_edb const *const edb = classDesc->edb ;
    if (edb == NULL) {
        mrtDispatchPolymorphicEvent(ecb) ;                          // <1>
    } else {
        if (ecb->eventNumber < edb->eventCount) {                   // <2>
            if (targetInst->currentState == edb->creationState) {   // <3>
                mrtDispatchCreationEvent(ecb) ;
            } else {
                mrtDispatchTransitionEvent(ecb) ;
            }
        } else {
            assert(classDesc->pdb != NULL) ;
            assert(ecb->eventNumber - edb->eventCount <
                    classDesc->pdb->eventCount) ;
            mrtDispatchPolymorphicEvent(ecb) ;                      // <4>
        }
    }
}
----
<1> If there is no event dispatch block for the class, then
all the events of the class must be polymorphic.
<2> If a class has both transitioning events and polymorphic
events, the code generator insures that the
transitioning events are always numbered starting from 0.
<3> A creation events is just a transitioning event dispatched
when we are in the creation state.
<4> If a class has both transitioning events and polymorphic events,
the polymorphic events are numbered starting at the end of the
sequence for transitioning events.

Event typing is discovered by first determining if there are any
transition events.
If not, then we must have a polymorphic event (and consequently,
its numbering will have started at 0).
Otherwise,
if the event number falls in the range of transition events,
then it must be either an ordinary transition event or a transition
event used as a creation event.
Finally, for the case where there are both transition and polymorphic
events defined for the class,
events outside of the transition event range must be dispatched
as polymorphic events.

In the sections below,
we consider the dispatch of each particular event type.

==== Transition Event Dispatch

The most frequent event type to dispatch is that of a transitioning event to a
state machine.
We refer to these event types as, _transition_, only to distinguish them from
the more complicated and less frequent used polymorphic and creation event
types.

Dispatching an event in its simplest terms involves using the
current state of the instance and the event number contained in
an ECB as indices into the transition matrix.
The transition matrix is the same for all instances of a class.
The entry in the transition matrix is the new state to which a
transition is to be made.
There are a few additional rules needed to
account for _ignored_ and _can't happen_ events.

Ignored events (IG) cause no transition.
Events that are ignored can be thought of as an optimization
on the state transition graph.
Ignored events could be handled by adding a new state to which
the ignored event makes a transition and that new state
has all the other outbound transitions that the original state had.
Clearly, having the concept of ignored events saves much clutter
in the state transition graph.

When the analyst considers a transition to be a logical impossibility,
then it is declared as a can't happen (CH) event.
In the micca run-time,
a can't happen transition is treated as a fatal system error.
This is a policy decision of the architecture,
so *do not* assume that _can't happen_ means
_shouldn't happen_ or _has a low probability of happening_.
In this architecture, can't happen means absolutely impossible to
happen and if it does happen then there has been a tear in the
logic / space / time continuum and the only course available is to
give up and declare a fatal error.

The data structure used for transitioning event dispatch
is called an *Event Dispatch Block* (EDB).
The code generator supplies an EDB for each class (and assigner)
that has a state model.
Below we will see how all this ties together.
For now, we discuss the data structure and how it is used.

(((micca,Run Time Data,MRT_edb)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrteventdispatchblock {
    MRT_DispatchCount stateCount ;
    MRT_DispatchCount eventCount ;
    MRT_StateCode initialState ;
    MRT_StateCode creationState ;
    MRT_StateCode const *transitionTable ;
    MRT_PtrActivityFunction const *activityTable ;
    bool const *finalStates ;

#       ifndef MRT_NO_NAMES
    char const *const *stateNames ;
#       endif /* MRT_NO_NAMES */
} MRT_edb ;
----

`stateCount`::
    The number of states in the transition matrix.
`eventCount`::
    The number of events in the transition matrix.
`initialState`::
    The number of the state that is the default state when an
    instance is created synchronously.
`creationState`::
    The number of the state that is the default state when an
    instance is created asynchronously.
`transitionTable`::
    A pointer to the transition matrix.
`activityTable`::
    A pointer to the state activities.
`finalStates`::
    A pointer to a boolean array that determines if a state is a
    final state.
`stateNames`::
    A pointer to an array of character pointers to the names of the
    class states.
    This information is used in tracing event dispatch.

The dimensions of the state transition matrix are `stateCount` rows
by `eventCount` columns.
The counts are held as small integers.

(((micca,Run Time Data,MRT_DispatchCount)))
[source,c]
----
<<mrt internal simple types>>=
typedef uint8_t MRT_DispatchCount ;
----

The transition table is in state major order,
_i.e._ the current state is used to index conceptual rows and the event number
is used to index conceptual columns.
The dimensions of the transition table are captured in the EDB to allow run
time bounds checking during event dispatch.

The basic transition algorithm is to use the current state of an instance and
the event number of an event as the indices into the transition matrix.
The entry in the transition matrix is the new state.
Notice the very simple data structures required for Moore state machines.

The new state is used as an index into the `activityTable`.
The activity table is an array of function pointers to the activity associated
with each state.

(((micca,Run Time Data,MRT_ActivityFunction)))
[source,c]
----
<<mrt internal simple types>>=
typedef void MRT_ActivityFunction(void *const, void const *const) ;
typedef MRT_ActivityFunction *MRT_PtrActivityFunction ;
----

Since Moore state machines associate the activity with the state,
that code segment is supplied as a function matching the prototype above.
The first argument is a pointer to the instance receiving the event.
It is `void` typed and state activities are expected to recover
the correct type by casting the pointer to the be of the proper
class data structure.
The second argument is a pointer to the event parameters.
Again, the correct type is recovered in the state activity to match
the parameter signature of the activity.
Notice that assigning back into event parameters does not make any sense as the
parameter values are discarded after the state activity completes.

One other feature of the state machine dispatch rules regards final states.
A state may be marked as final and if so,
then the run-time will destroy the instance when the state activity is
completed.
The `finalStates` member points to an array, indexed by state number,
that specifies if a particular state is indeed a final state.
As is frequently the case, the class may have no final states.
In this case, `finalState` member may be set to `NULL` to
indicate this fact and save the storage of the final state booleans
(_i.e._ there is no need to have an array of `false` values).

(((micca,Run Time Function,mrtDispatchTransitionEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDispatchTransitionEvent(
    MRT_ecb *ecb)
{
    MRT_Instance *const targetInst = ecb->targetInst ;
    MRT_edb const *const edb = targetInst->classDesc->edb ;
    assert(edb != NULL) ;
    assert(edb->stateCount > targetInst->currentState) ;
    assert(edb->eventCount > ecb->eventNumber) ;
    /*
     * Check for the "event-in-flight" error. This occurs when an instance is
     * deleted while there is an event for that instance in the event queue.
     * For this architecture, such occurrences are considered as run-time
     * detected analysis errors.
     */
    if (targetInst->alloc != ecb->alloc) {
        mrtEventInFlightError(ecb->sourceInst, ecb->eventNumber, targetInst) ;
    }
    /*
     * Fetch the new state from the transition table.
     */
    MRT_StateCode newState = *(edb->transitionTable +
            targetInst->currentState * edb->eventCount + ecb->eventNumber) ;

#       ifndef MRT_NO_TRACE
    /*
     * Trace the transition.
     */
    mrtTraceTransitionEvent(ecb->eventNumber, ecb->sourceInst,
            ecb->targetInst, targetInst->currentState, newState) ;
#       endif /* MRT_NO_TRACE */

    /*
     * Check for a can't happen transition.
     */
    if (newState == MRT_StateCode_CH) {
        mrtCantHappenError(targetInst, targetInst->currentState,
                ecb->eventNumber) ;
    } else if (newState != MRT_StateCode_IG) {
        assert(newState < edb->stateCount) ;
        /*
         * We update the current state to reflect the transition before
         * executing the activity for the state.
         */
        targetInst->currentState = newState ;
        /*
         * Invoke the state activity if there is one.
         */
        MRT_PtrActivityFunction activity = edb->activityTable[newState] ;
        if (activity) {
            activity(targetInst, &ecb->eventParameters) ;
        }
        /*
         * Check if we have entered a final state. If so, the instance is
         * deleted.
         */
        if (edb->finalStates && edb->finalStates[newState]) {
            mrt_DeleteInstance(targetInst) ; // <1>
        }
    }
}
----
<1> This is where asynchronous instance deletion occurs.
If the state is designated as final,
then the run-time deletes the instance after its state activity completes.

The processing for dispatching a transition event follows directly from
the definitions.
After the check for an event-in-flight error,
we perform the indexing into the transition matrix.
The indexing expression results from the need to treat a linear
set of bytes as a two dimensional matrix.
We can't type it any differently since we have different sized
transition matrices for each different state model.
After obtaining the new state,
we must determine if we are actually going to make a transition
or if the event is to be ignored or considered a fatal error.
Assuming that we are transitioning,
then the associated state activity is found and executed.
Note that empty state activity may be dispensed with and a `NULL`
inserted into the action table.
After the action, we check if the instance entered a final state.

[[event-in-flight-error,event-in-flight error]]
We are finally in a position to explain the event-in-flight error
in detail.
Only one analysis error is detected at run-time,
the delivery of an event to an instance that has been deleted.
Because events are queued,
it is possible for an event to be generated for an instance and then
while the event is on the queue awaiting to be delivered,
the target instance is deleted by some other code executing.
For a single threaded architecture,
this is considered an analysis error.
Deliverying events to deleted instances should never happen!
The analytical model is responsible for insuring that instance deletion is
accomplished only after there are no events awaiting to be delivered.
However, it can happen and the run-time detects and catches this.

A significant difficulty arises in systems that use distinct memory pools
for the instances of each class.
If an instance is destroyed and another one created, they may very
well end up in exactly the same array slot and therefore have exactly
the same instance pointer value.
So, a pathological case where an event is generated for an instance,
the instance is deleted and then re-created while the event is queued
could end up delivering the event to the newly recreated instance.
Quite the wrong thing to do.

The strategy used here is to vary the number in the
`alloc` field of the instance each time it is allocated.
Then a copy of the `alloc` field is placed in the ECB
when the event is queued.
In effect,
the real identifier of an instance,
for event dispatch purposes,
is its pointer plus the value of the `alloc` field.
When dispatched, the values of the `alloc` fields in the
two structures must match or else the target instance has
been destroyed and re-created in the same memory slot.
Of course, the observant reader will have seen that in the case where
the target instance is destroyed and recreated 16,000 times while the event
is queued will result in the event being dispatched to the wrong
instance.
This is considered such a remote possibility as to be of no practical concern.

==== Polymorphic Event Dispatch

Polymorphic events in their full generality can be complex,
but they are based on a simple idea.
In fact, there is nothing going on in the dispatch of polymorphic events
that could not otherwise be handled in the state activity.
Strictly speaking,
polymorphic events must be considered an optimization,
but a very convenient and significant one.
Previously,
we have described the rules concerning polymorphic events.

When a polymorphic event is dispatched,
we must traverse the generalization from the superclass to the subclass
to determine the type of the subclass.
Conceptually, determining which subclass is related to a particular
instance of a superclass is not difficult.
There are two fundamental steps in dispatching a polymorphic event:

. Determining which subtype instance is currently related to a supertype
instance.
. Mapping the polymorphic event encoding in the supertype to an event encoding
in the subtype.

In order to accomplish the first step,
the run-time has know how the generalization relationship is stored in the
instances.
The run-time supports two different schemes of storing the generalization
relationship,
either as a pointer reference or as a union member of the superclass
structure.

Both relationship storage techniques have their uses and we will not
discuss the pros and cons of one choice over another here.
If the generalization relationship is stored as a reference,
then the superclass instances will contain an instance pointer to a subtype.
If the generalization relationship is stored as a union,
then the superclass structure will a member that is a union of the data types
of all the subtypes of the generalization hierarchy.

As we will see,
if we can locate where in the superclass instance structure
the subclass encoding and the subclass reference or union are located,
then we can determine the type of the subclass instance to which 
a particular superclass instance is related.
To do that we assume that the there is a data type that can hold
the byte offset from the beginning of the superclass instance structure
to the required information.
As you can probably imagine,
this will be a tricky piece of code since it must pick out
information from an arbitrary data structure in a generic fashion.

(((micca,Run Time Data,MRT_AttrOffset)))
[source,c]
----
<<mrt internal simple types>>=
typedef size_t MRT_AttrOffset ;
----

==== Polymorphic Event Mapping

We now turn our attention to the actual mapping of polymorphic events.
The mapping is analogous to the mapping of current state and event to
a new state for normal event dispatch.
For polymorphic events,
the mapping is from subclass code of the currently related subclass and
polymorphic event number to a new event.
The data structure required for this is given by:

(((micca,Run Time Data,MRT_gdb)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtgendispatchblock {
    struct mrtrelationship const *relship ;
    MRT_EventCode const *eventMap ;
} MRT_gdb ;
----

`relship`::
    A pointer to the relationship description for the relationship
    across which the polymorphic event will be dispatched.
`eventMap`::
    The `eventMap` member is a pointer to the mapping
    of polymorphic events for the generalization.
    This mapping is indexed in major order by subclass code and in
    minor order by polymorphic event number.

A key realization here is that as we are mapping along a generalization
relationship,
a given polymorphic event may be mapped into a normal event where it will be
consumed by the state machine of the class or it may be delegated further down
the hierarchy.
To be delegated further implies that a polymorphic event will be mapped
into yet another polymorphic event to be further mapped in a subsequent
dispatch.

Now we can tie it all together.
For a superclass class that has associated polymorphic events the code
generator supplies a Polymorphic Dispatch Block (PDB) to direct the run-time as
to how to perform the mapping of polymorphic events to transitioning events.

(((micca,Run Time Data,MRT_pdb)))
[source,c]
----
<<mrt internal aggregate types>>=
typedef struct mrtpolydispatchblock {
    MRT_DispatchCount eventCount ;
    MRT_DispatchCount genCount ;
    struct mrtgendispatchblock const *genDispatch ;

#       ifndef MRT_NO_NAMES
    char const *const *genNames ;
#       endif /* MRT_NO_NAMES */
} MRT_pdb ;
----

`eventCount`::
    The `eventCount` member holds the number of polymorphic
    events associated with the superclass.
    Like transition events, polymorphic events are encoded as zero based
    sequential integers so they may be used as array indices in the
    mapping process.
`genCount`::
    The `genCount` member holds the number of generalization
    that originate at the superclass class.
`genDispatch`::
    The `genDispatch` member holds a pointer to an array of
    Generalization Dispatch Blocks.
    The array contains `genCount` elements.
`genNames`::
    A pointer to an array of generalization relationship names.
    The array is of length, `genCount`.

Now we can give the code for polymorphic event dispatch.

(((micca,Run Time Function,mrtDispatchPolymorphicEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDispatchPolymorphicEvent(
    MRT_ecb *ecb)
{
    MRT_Instance *superInst = ecb->targetInst ;
    MRT_Class const *const superClassDesc = superInst->classDesc ;
    MRT_pdb const *const pdb = superClassDesc->pdb ;
    assert(pdb != NULL) ;
    assert(pdb->genCount > 0) ;
    /*
     * Check for the "event-in-flight" error. We must make sure the
     * superclass instance still exists.
     */
    if (superInst->alloc != ecb->alloc) {
        mrtEventInFlightError(ecb->sourceInst, ecb->eventNumber, superInst) ;
    }
    /*
     * Compute the base offset for polymorphic event numbering.  This base
     * offset will be used to turn the polymorphic event number into an array
     * index.
     */
    MRT_edb const *const edb = superClassDesc->edb ;
    MRT_EventCode eventOffset = edb == NULL ? 0 : edb->eventCount ;
    assert(ecb->eventNumber >= eventOffset) ;
    assert(ecb->eventNumber - eventOffset < pdb->eventCount) ;
    /*
     * Save the original event number.  We intend to reuse the same ECB for each
     * event we dispatch and will need this and the super class instance pointer
     * values should there be more than one generalization associated with this
     * superclass.
     */
    MRT_EventCode origEvent = ecb->eventNumber ;
    /*
     * For each generalization that originates at the superclass an event is
     * generated down that generalization to one of the subclasss.
     */
    MRT_gdb const *gdb = pdb->genDispatch ;
    for (unsigned gnum = 0 ; gnum < pdb->genCount ; gdb++, gnum++) {
        MRT_Relationship const *const rel = gdb->relship ;
        MRT_Instance *subInst ;
        int subclassCode ;

        /*
         * Find the target instance reference and the class of the target
         * instance. How we do this depends upon how the generalization is
         * stored in the superclass instance.
         */
        if (rel->relType == mrtRefGeneralization) {
            /*
             * When the generalization is implemented via a pointer, we need an
             * extra level of indirection to fetch the address of the subclass.
             */
            MRT_RefGeneralization const *gen = &rel->relInfo.refGeneralization ;
            subInst = *(MRT_Instance **)
                    ((uintptr_t)superInst + gen->superclass.storageOffset) ;
            assert(subInst != NULL) ;
            /*
             * We must also guard against the possibility that the subclass was
             * unrelated from the superclass before the polymorphic event was
             * dispatched.
             */
            if (subInst == NULL) {
                mrtFatalError(mrtRelationshipLinkage) ;
            }
            assert(subInst->classDesc != NULL) ;
            subclassCode = mrtFindRefGenSubclassCode(subInst->classDesc,
                    gen->subclasses, gen->subclassCount) ;
        } else if (rel->relType == mrtUnionGeneralization) {
            /*
             * When the generalization is implemented by a union, we need only
             * point to the address of the subclass since it is contained
             * within the superclass.
             */
            MRT_UnionGeneralization const *gen =
                    &rel->relInfo.unionGeneralization ;
            subInst = (MRT_Instance *)
                    ((uintptr_t)superInst + gen->superclass.storageOffset) ;
            assert(subInst->classDesc != NULL) ;
            subclassCode = mrtFindUnionGenSubclassCode(subInst->classDesc,
                    gen->subclasses, gen->subclassCount) ;
        } else {
            mrtFatalError(mrtRelationshipLinkage) ;
        }
        /*
         * Check that our subclass instance is indeed allocated and usable.  We
         * are trying to guard against the possiblity that the subclass
         * instance was deleted before the polymorphic event was delivered.
         */
        assert(subInst->alloc > 0) ;
        if (subInst->alloc <= 0) {
            mrtEventInFlightError(ecb->sourceInst, origEvent, subInst) ;
        }
        /*
         * Update the target and allocation status in the ECB to match
         * that of the subclass instance, which is where the event
         * is now directed.
         */
        ecb->targetInst = subInst ;
        ecb->alloc = subInst->alloc ;
        /*
         * Fetch the event number for the subclass from the polymorphic
         * mapping.  The class of the subclass related to the superclass
         * determines the mapped value for the event.  Note we must subtract
         * off any offset in the event encoding that was consumed by the
         * transition events.
         */
        ecb->eventNumber = *(gdb->eventMap + subclassCode * pdb->eventCount +
                origEvent - eventOffset) ;

#           ifndef MRT_NO_TRACE
        /*
         * Trace the transition.
         */
        mrtTracePolymorphicEvent(origEvent, ecb->sourceInst, superInst,
                subclassCode, gnum, ecb->eventNumber) ;
#           endif /* MRT_NO_TRACE */

        mrtDispatchEvent(ecb) ; // <1>
    }
}
----
<1> Since a polymorphic event may map to either another polymorphic event
or to a transition event, we will use the general dispatch function
to recursively dispatch the mapped event.

The code loops through all of the generalizations for which the `superInst`
is a superclass.
The vast majority of the time there is only one generalization.
The strategy used here is to reuse the ECB that was carrying the polymorphic
event as the ECB for the remapped events.
This saves allocating a new ECB and avoids any problem that there may not
be an ECB available at that time.
The mapping of a polymorphic event is a function of the superclass target
and the polymorphic event number.
So we hold them in local variables as we overwrite the necessary fields
in the ECB to hold the mapped event information.

The core of the algorithm is to determine the subclass code of the related
subclass instance and use that as the row index into the polymorphic event map
for the generalization.
The event number (appropriately offset by the number of transition events)
is then used as the column index to find the mapping entry.
That mapping entry contains a new event number.
The new target of the event is the currently related subclass instance.
As we have discussed,
this may be a stored as a pointer or may be a union member of the superclass
instance structure.
For the pointer case,
we fetch the pointer from its location in the superclass structure.
For the union case,
the location in the superclass structure is the
beginning of the union, _i.e._ we down cast to the subclass member.
We fill in the `alloc` field to enable the event in
flight detection just in case the mapped event causes a transition.
Finally the newly minted ECB is recursively dispatched and the
next generalization is considered.
Recursively dispatching the event preserves the order of delivery of
the events.
Note that when there are multiple generalization hierarchies for
the event,
the dispatch order is determined by the order the code generator
decides for generalization dispatch blocks.

==== Creation Event Dispatch

Fortunately, creation events are much simpler than polymorphic events.
Creation event dispatch fixes up the `alloc` field of the
target and the ECB before normal event dispatch.
No additional data structures are required.

(((micca,Run Time Function,mrtDispatchCreationEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDispatchCreationEvent(
    MRT_ecb *ecb)
{
#       ifndef MRT_NO_TRACE
    /*
     * Trace the transition.
     */
    mrtTraceCreationEvent(ecb->eventNumber, ecb->sourceInst, ecb->targetInst,
            ecb->targetInst->classDesc) ;
#       endif /* MRT_NO_TRACE */

    assert(ecb->alloc == ecb->targetInst->alloc) ;
    assert(ecb->alloc < 0) ;
    assert(ecb->targetInst->alloc < 0) ;
    assert(ecb->targetInst->currentState ==
        ecb->targetInst->classDesc->edb->creationState) ;

    ecb->alloc = ecb->targetInst->alloc = -ecb->targetInst->alloc ; // <1>
    mrtDispatchTransitionEvent(ecb) ;
}
----
<1> By negating the `alloc` value, we show that the instance is active.

== Bridging Domains

All but the simplest of systems will contain more that one domain.
A domain represents a coherent subject matter with its own set of rules
and policies.
Domains are also the unit of encapsulation and reuse.

Consider a simple example of a domain that controls a chemical reaction
vessel.
One aspect of synthesizing something in a reaction vessel
is controlling the temperature of the vessel.
Such systems typically delegate control to another domain so that
a Reaction Management domain would delegate setting and maintaining
the reaction vessel temperature to a Signal I/O domain.

From the point of view of Reaction Management, the reaction vessel has
heaters, coolers, pumps, valves and such things and it is its responsibility
to sequence the vessel operations to accomplish the synthesis.
Reaction Management does not know the details of what it is controlling.
It wants to set the vessel temperature to 57C and maintain it there
for some time period.
How that happens in terms of heaters, thermal load and other such
physical considerations is delegated.

From the point of view of Signal I/O,
it knows that it is controlling output actuators with input sensors
as feed back.
That output point number 57 corresponds to a reactor vessel is not in
its scope of concern.

The concept of a domain is very much related to the concept of
_separation of concerns_.
But that which is separated must be combined if we are to obtain a
useful system.
The difference in the semantic view points of domains must be
bridged by translating the assumptions and dependencies of one domain
into the services provided by other domains.

There are several approaches to bridging.
The most elegant approach is _implicit bridgeing_ which
is related to _aspect oriented programming_ concepts.
In this style of bridging,
we would use a separate means to describe how operations in one domain
would be mapped to side effects in another domain.
For example, we would want to be able to state that
when the state activity in the Reaction Management domain updates
the reactor vessel set point attribute we would want the temperature
to be transferred to output point number 57 of the Signal I/O domain.
The advantage of this type of bridging is that the individual domains are
not modified and the domain semantics are not disturbed.
The bridge interactions are defined outside of the domain itself.
It is then a code generator's task to generate the domain code so that
the bridge mapping is implemented.
The disadvantage of this type of bridging is that it is very difficult
to implement both the means to specify the domain interactions
and the code generator required to generate the bridging code.

Another approach to bridging is termed, _explicit bridging_.
In this form,
a domain makes explicit invocations to an _external entity_.
The invocations demonstrate the explicit requirements that the domain
delegates and the service it requires.
Bridges then map the external entity invocations to interactions
with other domains that provide the required service.
Explicit bridging is a workable technique but can lead to
a large number of domain operations being needed to service a client
domain's dependencies.
Often,
a client domain and service domain will have _counterpart classes_.
These are classes that represent different aspects of the same entity
but do so in the semantics of the individual domains.
In such cases,
model level operations in the client domain, _e.g._ updating an attribute
value, are bridged to a similar model operations in the service domain,
_e.g_ updating the counterpart class attribute with a scaled value.
If it is necessary to code a domain operation for each such model level
operation,
the service domain will be unnecessarily complicated and its reuse will
be limited since the details of how model level actions need to take place
will very much depend upon the context in which the service domain is used.

Making available the ability to do some model level operations such as
updating attributes or signaling events from outside of the domain
can make explicit bridging much easier and prevent cluttering the
external interfaces of service domains with domain operations specifically
built to support the use of the service domain in one particular system.
Doing so breaks the encapsulation of the domain,
albeit in a very controlled manner.

`Micca` takes the following view of bridging:

* Domain designs should provide domain operations for those computations that
cannot be accomplished by a single simple model level operation.
Operations such as navigating a relationship or other more complicated
activities of instance creation and relationship linkage require
processing code to accomplish and that code is best gathered in
a domain operation.
* The `micca` code generator provides the means to break encapsulation
of a domain for simple model level actions such as signaling an event
or reading a class instance attribute.
* A domain must be populated before it can be bridged.
If there is an initial instance population,
bridges usually must account for that.
If the population of instances for a class is static,
this will usually greatly simplify the bridge.
* Bridge operation code is manually coded to map the semantics of one
domain onto another and, in general, is specific to the use of
the bridged domains in a particular system and, therfore, _not_ reusable.
* Dynamic activity in one domain may have to be reflected in the bridge.
For example, instance creation in one domain may have to result in
creating an instance of a counterpart class in a service domain.
In such cases, the bridge itself may have to track the dynamics of the
two domains.

These consideration make domain bridging abstract and complicated.
Sadly, the methodological fundamentals of bridging seem to be lacking
and much of what is done to build systems from bridged domains smacks of
being _ad hoc_.
There is much more that could be said about bridging that space does not
allow for here.
Projects are cautioned that bridging domains can be a significant
activity for which plans need to be made.

In this section,
we discuss the facilities provided by `micca` to perform operations on a
domain from outside the domain itself.
These facilities are intended to be used by bridge operation code.
Conceptually,
`micca` builds a _portal_ into the domain and supplies a set of functions
that will reach through the portal and perform operations in the domain.
The set of operations that can be performed is very limited but is a useful
set for implementing bridge operations.

=== Portal Data Structures [[portal-data-structures,Portal Data Structures]]

The only externally scoped identifiers in the generated ``C'' code file
are those of the domain operations.
All other generated code contains identifiers that are file static in
scope.
This is done to prevent collisions and contention of names at link time.
As a result,
other translation units have no access to the internals of a domain
as was the design goal.

Since we intend to provide some operations on the internals of a domain
we need a way to identify the entities upon which we are operating.
Internally,
a `micca` generated domain uses pointers to refer to instances, class
descriptors and other essential data.
We do _not_ want to expose addresses of the internals of a domain
to the outside.
Since all class instances are really elements of the class storage array,
the index of an instance in the storage array serves as a convenient
external identifier.
The `micca` code generator will place a set of ``C'' preprocessor
definitions in the generated header file to numerically encode
the classes, instances and attributes.
It is these small integer numbers that will serve as identifiers outside of the
domain and which we will use as array indices (with appropriate bounds
checking) inside the domain.

(((micca,Run Time Data,MRT_ClassId)))
(((micca,Run Time Data,MRT_InstId)))
(((micca,Run Time Data,MRT_AttrId)))
(((micca,Run Time Data,MRT_AttrSize)))
(((micca,Run Time Data,MRT_AssignerId)))
[source,c]
----
<<mrt interface simple types>>=
typedef unsigned short MRT_ClassId ;
typedef unsigned short MRT_InstId ;
typedef unsigned short MRT_AttrId ;
typedef size_t MRT_AttrSize ;
typedef unsigned short MRT_AssignerId ;
----

To operate on the internals of a domain requires a data structure
that maps the numerically encoded identifiers to the internals
of domain.

(((micca,Portal Data,MRT_DomainPortal)))
[source,c]
----
<<mrt interface aggregate types>>=
struct mrtdomainportal ;
typedef struct mrtdomainportal MRT_DomainPortal ;

<<mrt internal aggregate types>>=
struct mrtdomainportal {
    unsigned classCount ;
    MRT_Class const *classes ;
    unsigned assignerCount ;
    MRT_Class const *assigners ;

#       ifndef MRT_NO_NAMES
    char const *name ;
#       endif /* MRT_NO_NAMES */
} ;
----

`classCount`::
    The number of classes in the domain.
`classes`::
    A pointer to an array of class descriptions for the domain.
    The array contains `classCount` elements.
`assignerCount`::
    The number of assigners in the domain.
`assigners`::
    A pointer to an array of class description for the assigners.
    The array contains `assignerCount` elements.
`name`::
    A pointer to a NUL terminated character array giving the name of the domain.

The domain portal is a collection of class descriptions
for the classes and assigners in the domain.
Note that relationships are not accessible via the portal.

For each domain,
the code generator will create an externally scoped variable of the
above type.
The name of the variable follows the form `<domain name>__PORTAL`,
_i.e._ the suffix `__PORTAL` is appended to the domain name.
This variable forms the _portal_ into the domain and below we
describe the operations on the domain that are available via the portal.

=== Portal Access Functions [[portal-access-functions,Portal Access Functions]]

In this section we describe the set of operations that are available
through the portal.

=== Portal Errors [[portal-errors,Portal Errors]]

All the portal access functions return an integer value.
Non-negative return values indicate success and return the requested
information.
Negative return values indicate errors as described below.

(((micca,Portal,Error Codes)))
[source,c]
----
<<mrt interface constants>>=
    // No such class.
#define MICCA_PORTAL_NO_CLASS       (-1)
    // No such instance.
#define MICCA_PORTAL_NO_INST        (-2)
    // No such attribute.
#define MICCA_PORTAL_NO_ATTR        (-3)
    // Instance slot is not in use.
#define MICCA_PORTAL_UNALLOC        (-4)
    // Class does not have a state model.
#define MICCA_PORTAL_NO_STATE_MODEL (-5)
    // No such event for the class.
#define MICCA_PORTAL_NO_EVENT       (-6)
    // No such state for the class.
#define MICCA_PORTAL_NO_STATE       (-7)
    // Class does not support dynamic instances.
#define MICCA_PORTAL_NO_DYNAMIC     (-8)
    // Operation not allowed on a dependent attribute.
#define MICCA_PORTAL_DEPENDENT_ATTR (-9)
    // Operation failed from insufficient space to transfer value.
#define MICCA_PORTAL_SIZE_ERROR     (-10)
----

It is useful to have a function to translate the error code number
into a canonical string for the error.

******
[source,c]
----
<<mrt external interfaces>>=
extern char const *
mrt_PortalErrorString(
    int portalErrorCode) ;
----

`portalErrorCode`::
    A negative or zero value as returned from a portal function.

The `mrt_PortalErrorString` function translates a portal error code
to a human readable string.
By special dispensation,
a value of zero for `portalErrorCode` is accepted and a string reference
is returned for it.
The value of `NULL` is returned for unknown error code values or
if the run time was compiled with the pre-processor macro, `MRT_NO_NAMES`,
defined.
******

(((micca,Portal Function,mrt_PortalErrorString)))
[source,c]
----
<<mrt external functions>>=
char const *
mrt_PortalErrorString(
    int portalErrorCode)
{
#       ifndef MRT_NO_NAMES

    static char const * const portalErrStrings[] = {
        "No error",                                     // <1>
        "No such class",
        "No such instance",
        "No such attribute",
        "Instance slot is not in use",
        "Class does not have a state model",
        "No such event for the class",
        "No such state for the class",
        "Class does not support dynamic instances",
        "Operation not allowed on a dependent attribute",
        "Operation failed from insufficient space to transfer value",
    } ;

    assert(portalErrorCode >= MICCA_PORTAL_SIZE_ERROR && portalErrorCode <= 0) ;

    if (portalErrorCode < MICCA_PORTAL_SIZE_ERROR || portalErrorCode > 0) {
        return NULL ;
    }

    return portalErrStrings[-portalErrorCode] ;         // <2>

#       else

    return NULL ;

#       endif /* MRT_NO_NAMES */
}
----
<1> We'll allow zero as an error code since it is used to indicate
success by several of the portal functions.
So we need a place for the success message in the string array.
<2> Negating the error code turns it into an index.
We have already validated the argument value so this is safe to do.

==== References to Attributes

Internally,
the portal access functions often need to find a class instance.
We have factored that into a static function.

(((micca,Portal Function,mrtPortalGetInstRef)))
[source,c]
----
<<mrt static functions>>=
static int
mrtPortalGetInstRef(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_Instance **ref)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const pclass = portal->classes + classId ;
    if (instId >= pclass->instCount) {
        return MICCA_PORTAL_NO_INST ;
    }

    void *instance = mrtIndexToInstance(pclass, instId) ;
    if (instance == NULL) {
        return MICCA_PORTAL_UNALLOC ;
    }

    if (ref) {
        *ref = instance ;
    }
    return 0 ;
}
----

There is one case where we expose some internal pointer information
and this is for attributes.
Attributes implemented as arrays don't pass well by value in ``C''.
Obtaining a reference to the attribute is often the best way to
deal with passing its value around.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalGetAttrRef(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void **pref,
    MRT_AttrSize *size) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`attrId`::
    The number of the attribute to be read. This number is generated by micca
    and placed in the domain header file.
`pref`::
    A pointer to a memory pointer where the attribute reference is placed.
    If this argument is `NULL` then no reference is returned.
`size`::
    A pointer to where the size of the attribute is placed.
    If this argument is `NULL` then no size information is returned.

`mrt_GetAttrRef` obtains a pointer to the storage location for an
attribute and the size of that storage location.
The return value is 0, if the attribute storage could be found.
Negative numbers indicate an error occurred.
*****

(((micca,Portal Function,mrt_PortalGetAttrRef)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalGetAttrRef(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void **pref,
    MRT_AttrSize *size)
{
    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const class = instref->classDesc ;
    assert(class != NULL) ;
    if (attrId >= class->attrCount) {
        return MICCA_PORTAL_NO_ATTR ;
    }

    MRT_Attribute const *attr = class->classAttrs + attrId ;
    if (attr->type != mrtIndependentAttr) {
        return MICCA_PORTAL_DEPENDENT_ATTR ;
    }

    if (pref) {
        *pref = (void *)((uintptr_t)instref + attr->access.offset) ;
    }
    if (size) {
        *size = attr->size ;
    }
    return 0 ;
}
----

==== Reading Attributes

Instance attribute values may be read through the portal.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalReadAttr(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void *dst,
    MRT_AttrSize dstSize) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`attrId`::
    The number of the attribute to be read. This number is generated by micca
    and placed in the domain header file.
`dst`::
    A pointer to memory where the attribute value is placed.
`dstSize`::
    The number of bytes pointed to by `dst`.

`mrt_PortalReadAttr` reads an attribute value from a domain.
No more than `dstSize` bytes will be placed in the memory pointed to by
`dst`.
If the return value is non-negative, then it represents the actual number of
bytes read.
Negative numbers indicate an error occurred.
*****

(((micca,Portal Function,mrt_PortalReadAttr)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalReadAttr(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void *dst,
    MRT_AttrSize dstSize)
{
    assert(dst != NULL) ;

    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const class = instref->classDesc ;
    if (attrId >= class->attrCount) {
        return MICCA_PORTAL_NO_ATTR ;
    }

    MRT_Attribute const *attr = class->classAttrs + attrId ;
    MRT_AttrSize srcSize = attr->size ;
    if (srcSize > dstSize) {
        return MICCA_PORTAL_SIZE_ERROR ;
    }

    if (attr->type == mrtIndependentAttr) {
        void *src = (void *)((uintptr_t)instref + attr->access.offset) ;
        memcpy(dst, src, srcSize) ;
    } else {
        attr->access.formula(instref, dst, srcSize) ;
    }
    return srcSize ;
}
----

==== Updating Attributes

Instance attribute values may be updated through the portal.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalUpdateAttr(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void const *src,
    MRT_AttrSize srcSize) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`attrId`::
    The number of the attribute to be updated.
    This number is generated by micca and placed in the domain header file.
`src`::
    A pointer to memory from where the attribute value is taken.
`srcSize`::
    The number of bytes pointed to by `src`.

`mrt_PortalUpdateAttr` updates an attribute value in a domain.
If the return value is non-negative,
then it represents the actual number of bytes copied into the attribute
storage location.
Negative numbers indicate an error occurred.
*****

(((micca,Portal Function,mrt_PortalUpdateAttr)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalUpdateAttr(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void const *src,
    MRT_AttrSize srcSize)
{
    assert(src != NULL) ;

    void *dst ;
    MRT_AttrSize dstSize ;

    int result = mrt_PortalGetAttrRef(portal, classId, instId, attrId, &dst,
            &dstSize) ;
    if (result != 0) {
        return result ;
    }

    if (srcSize > dstSize) {
        return MICCA_PORTAL_SIZE_ERROR ;
    }

    assert(dst != NULL) ;
    memcpy(dst, src, srcSize) ;
    return srcSize ;
}
----

==== Signaling Events

The portal allows signalling an event to a class instance.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalSignalEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`eventNumber`::
    The event number of the event to signal.
`eventParameters`::
    A pointer to the supplemental event parameters. This may be set to `NULL`
    if there are not parameters for the event.
`paramSize`::
    The number of bytes pointed to by `eventParameters`.

`mrt_PortalSignalEvent` signals an ordinary or polymorphic event to the given
instance.
The return value is 0 upon success.
Negative numbers indicate an error occurred.
*****

(((micca,Portal Function,mrt_PortalSignalEvent)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalSignalEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize)
{
    int result ;
    MRT_ecb *ecb ;

    result = mrtPortalNewECB(portal, classId, instId, eventNumber,
            eventParameters, paramSize, &ecb) ;
    if (result == 0) {
        mrt_PostEvent(ecb) ;
    }

    return result ;
}
----

Internally, we factor obtaining an ECB into its own function.

(((micca,Portal Function,mrtPortalNewECB)))
[source,c]
----
<<mrt static functions>>=
static int
mrtPortalNewECB(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize,
    MRT_ecb **ecbRef)
{
    assert(ecbRef != NULL) ;

    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const classDesc = instref->classDesc ;
    assert(classDesc != NULL) ;
    if (classDesc->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= classDesc->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    if (paramSize > sizeof(MRT_EventParams)) {
        return MICCA_PORTAL_SIZE_ERROR ;
    }

    MRT_ecb *ecb = mrt_NewEvent(eventNumber, instref, NULL) ;
    if (eventParameters != NULL) {
        memcpy(ecb->eventParameters, eventParameters, paramSize) ;
    }
    *ecbRef = ecb ;
    return 0 ;
}
----

==== Signaling Delayed Events

Signaling delayed events is similar to immediate events, but adds
a delay time argument.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalSignalDelayedEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize,
    MRT_DelayTime delay) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`eventNumber`::
    The event number of the event to signal.
`eventParameters`::
    A pointer to the supplemental event parameters. This may be set to `NULL`
    if there are not parameters for the event.
`paramSize`::
    The number of bytes pointed to by `eventParameters`.
`delay`::
    The minimum number of milliseconds to delay before the event is dispatched.

`mrt_PortalSignalDelayedEvent` signals an ordinary or polymorphic event
to the deliverd to an instance after a delay time.
The return value is 0 upon success.
Negative numbers indicate an error occurred.
*****

(((micca,Portal Function,mrt_PortalSignalDelayedEvent)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalSignalDelayedEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize,
    MRT_DelayTime delay)
{
    MRT_ecb *ecb ;
    int result = mrtPortalNewECB(portal, classId, instId, eventNumber,
            eventParameters, paramSize, &ecb) ;
    if (result == 0) {
        mrt_PostDelayedEvent(ecb, delay) ;
    }

    return result ;
}
----

==== Canceling Delayed Events

A delayed event may be cancelled.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalCancelDelayedEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`eventNumber`::
    The event number of the event to signal.

`mrt_PortalCancelDelayedEvent` cancels a delayed event.
The return value is 0 upon success.
Negative numbers indicate an error occurred.
*****

(((micca,Portal Function,mrt_PortalCancelDelayedEvent)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalCancelDelayedEvent(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber)
{
    MRT_Instance *instref ;

    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    assert(instref != NULL) ;
    MRT_Class const *const class = instref->classDesc ;
    assert(class != NULL) ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= class->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    mrt_CancelDelayedEvent(eventNumber, instref, NULL) ;
    return 0 ;
}
----

==== Remaining Delay Time

You may also request the time remaining for a delayed event.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalRemainingDelayTime(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_DelayTime *delayRef) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`eventNumber`::
    The event number of the event to query.
`delayRef`::
    A pointer to a location where the remaining delay time is placed.

The `mrt_PortalCancelDelayedEvent` function queries the amount
of time remaining before the event with `eventNumber` is dispatched
to the `instId` instance of class, `classId`.
The value is returned indirectly via the `delayRef` pointer.
The returned delay value is zero if the delay time has already elapsed
or if no matching delayed event could be found.
The return value of the function is zero if successful and
the value pointed to by `delayRef` is valid.
*****

(((micca,Portal Function,mrt_PortalRemainingDelayTime)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalRemainingDelayTime(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_DelayTime *delayRef)
{
    assert(delayRef != NULL) ;

    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const class = instref->classDesc ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= class->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    MRT_DelayTime delay = mrt_RemainingDelayTime(eventNumber, instref, NULL) ;
    if (delayRef) {
        *delayRef = delay ;
    }
    return 0 ;

}
----

==== Synchronous Instance Creation

****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalCreateInstance(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_StateCode initialState) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`initialState`::
    The number of the state into which the new created instance is placed.
    If the class given by `classId` has no state model,
    then `initialState` must be given as `MRT_StateCode_IG`.
    If the class given by `classId` has as state model,
    then if `initialState` is given as `MRT_StateCode_IG`,
    the instance will be placed in the default initial state as it
    was defined when the state model was configured.
    Otherwise, `initialState` must be a valid state number for the
    class and the new instance is created in that state.
    N.B. no state activity is executed in any case.
****

(((micca,Portal Function,mrt_PortalCreateInstance)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalCreateInstance(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_StateCode initialState)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->containment != NULL) {
        return MICCA_PORTAL_NO_DYNAMIC ;
    }

    if (initialState != MRT_StateCode_IG) {
        if (class->edb == NULL) {
            return MICCA_PORTAL_NO_STATE_MODEL ;
        }
        if (initialState <= MRT_StateCode_CH ||
                initialState >= class->edb->stateCount ||
                initialState == class->edb->creationState) {
            return MICCA_PORTAL_NO_STATE ;
        }
    }
    void *inst = mrt_CreateInstance(class, initialState) ;
    return mrt_InstanceIndex(inst) ;
}
----

==== Asynchronous Instance Creation

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalCreateInstanceAsync(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`eventNumber`::
    The number of the creation event.
`eventParameters`::
    A pointer to the parameters for the event. If the event has
    no supplemental parameters, this argument should be `NULL`.
`paramSize`::
    The number of bytes pointed to by `eventParameters`.

The `mrt_PortalCreateInstanceAsync` function sends `eventNumber` as a
creation event to the class given by `classId`.
Any parameters of the event are pointed to by `eventParameters`
and are `paramSize` bytes in length.
The newly created instance is placed in its pseudo-initial state and the
`eventNumber` event is signaled to it.
N.B. a transition occurs when the event is delivered resulting
in the execution of a state activity.
*****

(((micca,Portal Function,mrt_PortalCreateInstanceAsync)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalCreateInstanceAsync(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->containment != NULL) {                   // <1>
        return MICCA_PORTAL_NO_DYNAMIC ;
    }

    if (class->edb == NULL) {                           // <2>
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= class->edb->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    MRT_Instance *inst = mrt_CreateInstanceAsync(class,
            eventNumber, eventParameters, paramSize, NULL) ;
    return mrt_InstanceIndex(inst) ;
}
----
<1> Union subclass instances cannot be created asynchronously.
<2> Asynchronous creation requires an event dispatch block.

==== Deleting Instances

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalDeleteInstance(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.

The `mrt_PortalDeleteInstance` deletes the `instId` instance of
the `classId` class.
*****

(((micca,Portal Function,mrt_PortalDeleteInstance)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalDeleteInstance(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId)
{
    MRT_Instance *inst = NULL ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &inst) ;
    if (result == 0) {
        assert(inst != NULL) ;
        mrt_DeleteInstance(inst) ;
    }

    return result ;
}
----

==== Signaling Events To Assigners

The portal allows signalling an event to an assigner instance.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalSignalEventToAssigner(
    MRT_DomainPortal const *const portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`assignerId`::
    The number of the assigner. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
    Single assigners have only one instance and so `instId` must be 0 for
    them.
    Multiple assigners may have an `instId` value greater than 0.
`eventNumber`::
    The event number of the event to signal.
`eventParameters`::
    A pointer to the supplemental event parameters. This may be set to `NULL`
    if there are not parameters for the event.
`paramSize`::
    The number of bytes pointed to by `eventParameters`.

`mrt_PortalSignalEventAssigner` signals a transitioning event to the given
assigner instance.
Polymorphic and creation events cannot be signaled to an assigner.
The return value is 0 upon success.
Negative numbers indicate an error occurred.
*****

(((micca,Portal Function,mrt_PortalSignalEventToAssigner)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalSignalEventToAssigner(
    MRT_DomainPortal const *const portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    void const *eventParameters,
    size_t paramSize)
{
    MRT_Instance *instref = NULL ;
    int result = mrtPortalGetAssignerRef(portal, assignerId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    assert(instref != NULL) ;
    MRT_Class const *const asnClass = instref->classDesc ;
    MRT_edb const *edb = asnClass->edb ;
    assert(edb != NULL) ;
    if (eventNumber >= edb->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

    if (paramSize > sizeof(MRT_EventParams)) {
        return MICCA_PORTAL_SIZE_ERROR ;
    }

    MRT_ecb *ecb = mrt_NewEvent(eventNumber, instref, NULL) ;
    if (eventParameters != NULL) {
        memcpy(ecb->eventParameters, eventParameters, paramSize) ;
    }
    mrt_PostEvent(ecb) ;
    return 0 ;
}
----

Similar to obtaining an instance reference,
we factor out code to obtain a reference to an assigner.

(((micca,Portal Function,mrtPortalGetAssignerRef)))
[source,c]
----
<<mrt static functions>>=
static int
mrtPortalGetAssignerRef(
    MRT_DomainPortal const *const portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId,
    MRT_Instance **ref)
{
    assert(portal != NULL) ;

    if (assignerId >= portal->assignerCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const asnClass = portal->assigners + assignerId ;
    if (instId >= asnClass->instCount) {
        return MICCA_PORTAL_NO_INST ;
    }

    MRT_iab *iab = asnClass->iab ;
    assert(iab != NULL) ;
    MRT_Instance *instref = (MRT_Instance *)
            ((uintptr_t)iab->storageStart + iab->instanceSize * instId) ;
    if (instref->alloc <= 0) {
        return MICCA_PORTAL_UNALLOC ;
    }

    if (ref) {
        *ref = instref ;
    }
    return 0 ;
}
----

==== Obtaining Class Current State

The portal supports reading the current state of an instance of a class
having a state model.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalInstanceCurrentState(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.

The `mrt_PortalInstanceCurrentState` function returns the number of the
current state of the `instId` instance of `classId` class.
*****

(((micca,Portal Function,mrt_PortalInstanceCurrentState)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalInstanceCurrentState(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_InstId instId)
{
    MRT_Instance *instref ;
    int result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    MRT_Class const *const class = instref->classDesc ;
    assert(class != NULL) ;
    if (class->edb == NULL) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    return instref->currentState ;
}
----

==== Obtaining Assigner Current State

The portal supports reading the current state of an assigner of a class
having a state model.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalAssignerCurrentState(
    MRT_DomainPortal const *const portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`assignerId`::
    The number of the assigner. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the assigner instance.
    Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the assigner.

The `mrt_PortalAssignerCurrentState` function returns the number of the
current state of the `instId` instance of `assignerId` assigner.
*****

(((micca,Portal Function,mrt_PortalAssignerCurrentState)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalAssignerCurrentState(
    MRT_DomainPortal const *const portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId)
{
    MRT_Instance *instref = NULL ;
    int result = mrtPortalGetAssignerRef(portal, assignerId, instId, &instref) ;
    if (result != 0) {
        return result ;
    }

    assert(instref != NULL) ;
    return instref->currentState ;
}
----

=== Domain Introspection

For testing and other purposes,
it is useful to be able to inquire about the characteristics of a
domain at run-time.
The functions in this section expose other domain portal meta-information.

*****
[source,c]
----
<<mrt external interfaces>>=
extern char const *
mrt_PortalDomainName(
    MRT_DomainPortal const *const portal) ;
----

`portal`::
    A pointer to a domain portal data structure.

The `mrt_PortalDomainName` function returns a pointer to a `NUL` terminated
string giving the name of the
domain described by the portal data pointed to by `portal`.
If the domain was compiled with the preprocessor symbol `MRT_NO_NAMES`
defined, then the return value is `NULL`.
*****

(((micca,Portal Function,mrt_PortalDomainName)))
[source,c]
----
<<mrt external functions>>=
char const *
mrt_PortalDomainName(
    MRT_DomainPortal const *const portal)
{
    assert(portal != NULL) ;

#       ifndef MRT_NO_NAMES
    return portal->name ;
#       else
    return NULL ;
#       endif /* MRT_NO_NAMES */
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalDomainClassCount(
    MRT_DomainPortal const *const portal) ;
----

`portal`::
    A pointer to a domain portal data structure.

The function `mrt_PortalDomainClassCount` returns the number of classes
in the domain.
Classes may be identified to the other portal functions using integer
numbers ranging from 0 to the return value of `mrt_PortalDomainClassCount`
minus 1.
*****

(((micca,Portal Function,mrt_PortalDomainClassCount)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalDomainClassCount(
    MRT_DomainPortal const *const portal)
{
    assert(portal != NULL) ;

    return portal != NULL ? portal->classCount : 0 ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    char const ** const nameRef) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`nameRef`::
    A pointer to a character pointer where a reference to the class name
    is placed.

The `mrt_PortalClassName` function obtains the name of the _classId_
class in the domain described by _portal_.
The class name is returned via `nameRef` as a pointer to a `NUL`
terminated string.
If the domain was compiled with the preprocessor symbol
`MRT_NO_NAMES` defined, then the value placed in the
location pointed to by _nameRef_ is `NULL`.
If successful,
the return value of the function is zero.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalClassName)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    char const ** const nameRef)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

#       ifndef MRT_NO_NAMES
    MRT_Class const *const class = portal->classes + classId ;
    if (nameRef) {
        *nameRef = class->name ;
    }
#       else
    if (nameRef) {
        *nameRef = NULL ;
    }
#       endif /* MRT_NO_NAMES */

    return 0 ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassAttributeCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.

The `mrt_PortalClassAttributeCount` function returns the number of
attributes in the class identified by _classId_ in the domain described
by _portal_.
If successful,
the return value of the function is non-negative and represents the number
of attributes of the class.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalClassAttributeCount)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassAttributeCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    return class->attrCount ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassInstanceCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.

The `mrt_PortalClassInstanceCount` function returns the maximum number of
instances that may be created for the class identified by _classId_ in the
domain described by _portal_.
If successful,
the return value of the function is positive and represents the number
of instance storage slots for the class.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalClassInstanceCount)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassInstanceCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    return class->instCount ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassEventCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.

The `mrt_PortalClassEventCount` function returns the number of events in the
state model of the class identified by _classId_ in the domain described by
_portal_.
If successful,
the return value of the function is positive and represents the number
of events defined for the state model of the class.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalClassEventCount)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassEventCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    return class->eventCount ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassStateCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.

The `mrt_PortalClassStateCount` function returns the number of states in the
state model of the class identified by _classId_ in the domain described by
_portal_.
If successful,
the return value of the function is positive and represents the number
of states defined for the state model of the class.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalStateCount)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassStateCount(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    MRT_edb const *edb = class->edb ;
    assert(edb != NULL) ;

    return edb != NULL ? edb->stateCount : 0 ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassAttributeName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_AttrId attrId,
    char const ** const nameRef) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`attrId`::
    The number of the attribute. This number is generated by micca and placed in
    the domain header file.
`nameRef`::
    A pointer to a character pointer where a reference to the attribute name
    is placed.

The `mrt_PortalClassAttributeName` function obtains the name of the _attrId_
attribute in the _classId_ class in the domain described by _portal_.
A pointer to a `NUL` terminated string is placed in the object pointed to
by `nameRef`.
If the run-time code was compiled with `MRT_NO_NAMES` defined,
then the value placed in `nameRef` is `NULL`.
If successful,
the return value of the function is zero.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalClassAttributeName)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassAttributeName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_AttrId attrId,
    char const ** const nameRef)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (attrId >= class->attrCount) {
        return MICCA_PORTAL_NO_ATTR ;
    }

    if (nameRef) {
#           ifndef MRT_NO_NAMES
        *nameRef = class->classAttrs[attrId].name ;
#           else
        *nameRef = NULL ;
#           endif /* MRT_NO_NAMES */
    }

    return 0 ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassAttributeSize(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_AttrId attrId) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`attrId`::
    The number of the attribute. This number is generated by micca and placed in
    the domain header file.

The `mrt_PortalClassAttributeSize` function returns the number of bytes
occupied by the _attrId_ attribute in the _classId_ of the domain described by
_portal_.
If successful,
the return value of the function is positive and represents the number
of bytes of storage allocated to the attribute.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalClassAttributeSize)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassAttributeSize(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_AttrId attrId)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (attrId >= class->attrCount) {
        return MICCA_PORTAL_NO_ATTR ;
    }

    return class->classAttrs[attrId].size ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassEventName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_EventCode eventNumber,
    char const ** const nameRef) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`eventNumber`::
    The number of the event. This number is generated by micca and placed in
    the domain header file.
`nameRef`::
    A pointer to a character pointer where a reference to the event name
    is placed.

The `mrt_PortalClassEventName` function obtains the name of the _eventNumber_
event of the state model in the _classId_ class in the domain described by
_portal_.
A pointer to a `NUL` terminated string is placed in the object pointed to
by `nameRef`.
If the run-time code was compiled with `MRT_NO_NAMES` defined,
then the value placed in `nameRef` is `NULL`.
If successful,
the return value of the function is zero.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalClassEventName)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassEventName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_EventCode eventNumber,
    char const ** const nameRef)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    if (class->eventCount == 0) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (eventNumber >= class->eventCount) {
        return MICCA_PORTAL_NO_EVENT ;
    }

#       ifndef MRT_NO_NAMES
    char const *const *eventNames = class->eventNames ;
    if (eventNames != NULL && nameRef != NULL) {
        *nameRef = eventNames[eventNumber] ;
    }
#       else
    if (nameRef != NULL) {
        *nameRef = NULL ;
    }
#       endif /* MRT_NO_NAMES */

    return 0 ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassStateName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_StateCode stateCode,
    char const **nameRef) ;
----

`portal`::
    A pointer to a domain portal data structure.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`stateCode`::
    The number of the state. This number is generated by micca and placed in
    the domain header file.
`nameRef`::
    A pointer to a character pointer where a reference to the state name
    is placed.

The `mrt_PortalClassStateName` function obtains the name of the _stateCode_
state of the state model in the _classId_ class in the domain described by
_portal_.
A pointer to a `NUL` terminated string is placed in the object pointed to
by `nameRef`.
If the run-time code was compiled with `MRT_NO_NAMES` defined,
then the value placed in `nameRef` is `NULL`.
If successful,
the return value of the function is zero.
Upon failure,
the return value is one of the portal error codes.
*****

(((micca,Portal Function,mrt_PortalClassStateName)))
[source,c]
----
<<mrt external functions>>=
int
mrt_PortalClassStateName(
    MRT_DomainPortal const *const portal,
    MRT_ClassId classId,
    MRT_StateCode stateCode,
    char const **nameRef)
{
    assert(portal != NULL) ;

    if (classId >= portal->classCount) {
        return MICCA_PORTAL_NO_CLASS ;
    }

    MRT_Class const *const class = portal->classes + classId ;
    MRT_edb const *edb = class->edb ;
    if (edb == NULL) {
        return MICCA_PORTAL_NO_STATE_MODEL ;
    }

    if (stateCode < 0 || stateCode >= edb->stateCount) {
        return MICCA_PORTAL_NO_STATE ;
    }

    if (nameRef) {
#           ifndef MRT_NO_NAMES
        *nameRef = edb->stateNames[stateCode] ;
#           else
        *nameRef = NULL ;
#           endif /* MRT_NO_NAMES */
    }
    return 0 ;
}
----

== Asynchronous Execution

When the main loop was discussed,
we made a brief mention of asynchronous execution in the context
of executing synchronization functions.
It is now time to discuss how the run-time deals with asynchronous
execution.
First we discuss some background and then present the means used by
the run-time to synchronize the two execution contexts.

Until now, the discussion of data management and execution
sequencing have assumed that we have a single execution context.
However,
all modern computer architectures support the concept of an interrupt.
An interrupt signaled by some external hardware causes the processor
to stop executing and transfer control to a different section of code
so that immediate action can be taken on the cause of the interrupt.
After the external condition is handled,
execution usually resumes where it was interrupted.
The need for asynchronous execution was recognized early in computer
architecture design as interaction with the external environment is much
of what makes a computer a useful machine.

The exact details of how this happens is different for every computer
architecture.
Some computers offer very sophisticated schemes that include arbitrating
the priority of multiple competing interrupt sources.
Most offer only a single priority of interrupt processing or place the
burden of prioritization on the programmer or external hardware.
The `micca` run-time is intended for highly embedded systems and,
in such systems, achieving the low execution overhead is of great value.
So the model of asynchronous execution used by the run-time mirrors that which
is provided directly by the hardware architecture.
Techniques for having multiple, scheduled execution contexts are very
well known.
None of them is used here.
Here we are only interested in a very simple model of asynchronous execution
that closely mirrors what is provided by the computing hardware.
Amazingly, this is much less restrictive than might be first imagined.

Nesting interrupts is not forbidden, but is definitely not encouraged.
No restriction is put on what may happen at interrupt service.
This is usually a potential source of error in many systems.
Because the execution is asynchronous to domain model execution,
any access to the domain data structures from interrupt service
*must not* be attempted.
It is ultimately unsafe and results in horribly difficult to detect
timing windows being generated wherein things will mysteriously and
irreproducibly fail.

However, it is usually necessary for an interrupt to communicate
back to the domain models.
Usually, the interrupt signals some change of condition
in the environment that has been detected by the hardware.
The interrupt may not be able to do everything required to handle the situation
and frequently additional computation is required to resolve what has happened.
The run-time provides a way for an interrupt to request
synchronization with the running background.
This is accomplished by having the interrupt service code
perform a synchronization request.

*****
[source,c]
----
<<mrt external interfaces>>=
extern MRT_SyncParams *
mrt_SyncRequest(
    MRT_SyncFunc syncfunc) ;
----

`syncfunc`::
    A pointer to a synchronization function.

The `mrt_SyncRequest` function is called from interrupt service routines
to request that the synchronization function, `syncfunc`, be executed
in the background at the first safe opportunity.
The return value of the function is a pointer to a parameter area
where arguments to `syncfunc` may be placed which are then made available
when the function is invoked.
*****

The request is in the form of a function, with optional parameters,
that is to be executed at the first *safe* opportunity.
As we saw before,
the synchronization functions are executed in between state activities
to insure that the domain data are in a coherent state.

To implement deferring the sync function,
the run-time provides a sync queue where
requests for background synchronization execution are placed.
The queue is implemented in an array.
Like all resources in the run-time,
the storage required for the queue is fixed at compile time.

(((micca,Run Time Constant,MRT_SYNC_QUEUE_SIZE)))
[source,c]
----
<<mrt interface constants>>=
#ifndef MRT_SYNC_QUEUE_SIZE
#   define MRT_SYNC_QUEUE_SIZE 10
#endif /* MRT_SYNC_QUEUE_SIZE */
----

The number of queue entries can be sized appropriately for the system.
Generally, the number of queue slots must be sized to handle
any cluster of interrupts that go off at nearly the same time.

It is necessary to provide interrupts the ability to pass parameters
to the background sync functions.
This is often data that must be sampled coincident with the interrupt
in order to capture the correct external state.
To avoid problems with variable life times,
data is passed by value by placing it in a parameter area.

This is not a good strategy for passing a large amount of
data from the interrupt context to the background.
In those cases, it is necessary to manage memory between the
background and the interrupts.
No facilities are provided by the run-time to do this as it usually
must to be constructed _ad hoc_ to suit the particular needs of the
data transfer.
It is often sufficient to manage a memory pool in the background and use the
synchronization to the background to allow interrupt service to return memory
to the pool when it is no longer needed.
The archetypal example is communications buffers.
Background code can manage a buffer pool.
When outgoing messages are transmitted,
synchronization to the background can be used to return the buffer to
the pool.
Incoming messages can be placed in pre-queued buffers and when the message
is complete, synchronizing to the background passes buffer pointers
to be processed and returned to the pool.

=== Sync Function and Parameters

For our purposes here, it is only necessary to define some data structure
that can be used by the interrupt service code to place data that
will be delivered to the background function.
The same considerations that were discussed for
<<event-parameter-storage,event parameters>>
apply for sync function parameters.
So we use the same strategy and simply adopt the same data
structure for sync function parameters as for event parameters.

(((micca,Run Time Data,MRT_SyncParams)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef MRT_EventParams MRT_SyncParams ;
----

There is no meaningful return value of a sync function and they are
simply passed a pointer to their parameter data area.
The prototype for a sync function is as follows.

(((micca,Run Time Data,MRT_SyncFunc)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef void (*MRT_SyncFunc)(MRT_SyncParams const *) ;
----

=== Sync Queue

Each element of the sync queue is a pointer to the sync function
and a place where the interrupt service code may place the values
of the parameters.

(((micca,Run Time Data,MRT_SyncBlock)))
[source,c]
----
<<mrt implementation aggregate types>>=
typedef struct mrtsyncblock {
    MRT_SyncFunc function ;
    alignas(max_align_t) MRT_SyncParams params ;    // <1>
} MRT_SyncBlock ;
----
<1> _N.B._ the use of a `C11` alignment feature.

The sync queue is stored in an array and we use a couple of
pointers to keep track of the head and tail.

(((micca,Run Time Data,MRT_SyncQueue)))
[source,c]
----
<<mrt implementation aggregate types>>=
typedef struct mrtsyncqueue {
    MRT_SyncBlock *head ;
    MRT_SyncBlock *tail ;
} MRT_SyncQueue ;
----

Following our usual pattern,
we allocate storage for the sync queue entries as an array and
for the control structure that tracks the queue boundaries within
the sync queue entry array.

[source,c]
----
<<mrt static data>>=
static MRT_SyncBlock mrtSyncQueueStorage[MRT_SYNC_QUEUE_SIZE] ;
static MRT_SyncQueue mrtSyncQueue = {
    .head = mrtSyncQueueStorage,
    .tail = mrtSyncQueueStorage,
} ;
----

There are only three operations on the sync queue.
First we must be able to determine if the queue is empty.
Emptiness is determined when the queue head is equal to the queue tail.
For this type of queue operation,
the head is where the next entry is removed and the tail is where the
next entry is inserted.

[source,c]
----
<<mrt forward references>>=
static inline bool mrtSyncQueueEmpty(void) ;
----

(((micca,Run Time Function,mrtSyncQueueEmpty)))
[source,c]
----
<<mrt static functions>>=
static inline bool
mrtSyncQueueEmpty(void)
{
    return mrtSyncQueue.head == mrtSyncQueue.tail ;
}
----

We need to be able to add a sync function to the queue.
Since the sync queue is shared between the background and foreground,
the operations on the queue must be protected in a critical
section.

[source,c]
----
<<mrt forward references>>=
static MRT_SyncParams *mrtSyncQueuePut(MRT_SyncFunc f) ;
----

(((micca,Run Time Function,mrtSyncQueuePut)))
[source,c]
----
<<mrt static functions>>=
static MRT_SyncParams *
mrtSyncQueuePut(
    MRT_SyncFunc f)
{
    MRT_SyncParams *params = NULL ;

    mrtBeginCriticalSection() ;

    MRT_SyncBlock *tail = mrtSyncQueue.tail ;                        // <1>
    MRT_SyncBlock *newTail = tail + 1 ;
    if (newTail >= mrtSyncQueueStorage + COUNTOF(mrtSyncQueueStorage)) {
        newTail = mrtSyncQueueStorage ;
    }

    if (newTail != mrtSyncQueue.head) {                              // <2>
        mrtSyncQueue.tail = newTail ;
        tail->function = f ;
        params = &tail->params ;
    }

    mrtEndCriticalSection() ;

    return params ;
}
----
<1> The `tail` pointer points to the location where the next sync queue
function was placed.
Incrementing the tail pointer must account for wrapping around the array
boundary.
<2> Overflow is detected as the queue being in the state where the next
insertion location equals the head of the queue
(_i.e._ the next insertion would overwrite the sync block on the head of
the queue).
Note the sync queue tail pointer is not modified until after we are
assured there is no overflow.
This insures that should an overflow error happen, the queue is left in a
consistent state.

The consumer of the sync queue entries is the main loop.

[source,c]
----
<<mrt forward references>>=
static MRT_SyncBlock *mrtSyncQueueGet(void) ;
----

(((micca,Run Time Function,mrtSyncQueueGet)))
[source,c]
----
<<mrt static functions>>=
static MRT_SyncBlock *
mrtSyncQueueGet(void)
{
    MRT_SyncBlock *block = NULL ;

    mrtBeginCriticalSection() ;

    if (!mrtSyncQueueEmpty()) {
        block = mrtSyncQueue.head ;                                     // <1>
        if (++mrtSyncQueue.head >=
                mrtSyncQueueStorage + COUNTOF(mrtSyncQueueStorage)) {   // <2>
            mrtSyncQueue.head = mrtSyncQueueStorage ;
        }
    }

    mrtEndCriticalSection() ;

    return block ;
}
----
<1> The `head` pointer points to the next sync queue block to consider.
Fetch the current sync queue block and point to the next one.
<2> Wrap around the end of the array if we have advanced the `head` pointer
past the end of the storage array.

Since the main loop runs with interrupts enabled,
obtaining a sync queue entry must be done in a critical section.
We remove entries from the head of the queue.
Otherwise, the only complexity in the code is to account for
wrap around in the the array storage.

=== Dispatching Synchronization Functions

<<processing-one-event,Above>> we saw that
when an event is dispatched,
the `mrtProcessOneEvent` function is called.
This function performs the background synchronization
before dispatching a single event.
For all architectures except the ARM v7-M,
the following code is executed directly in the `mrt_ProcessOneEvent`
function.

[source,c]
----
<<execute sync functions>>=
while (mrtInvokeOneSyncFunction()) {
    ; /* empty loop body */
}
----

We execute in a loop, invoking one sync function until there are no
more queued up.
Note that no special considerations about interrupts appear here.

[source,c]
----
<<mrt forward references>>=
static inline bool mrtInvokeOneSyncFunction(void) ;
----

Invoking a sync function is a simple matter of pulling it off the
sync queue and passing a pointer to the parameters to it.
We return a value indicating if a function was called.

(((micca,Run Time Function,mrtInvokeOneSyncFunction)))
[source,c]
----
<<mrt static functions>>=
static inline bool
mrtInvokeOneSyncFunction(void)
{
    bool didInvoke = false ;
    do {
        MRT_SyncBlock const *block = mrtSyncQueueGet() ;

        if (block == NULL) {
            break ;                             // <1>
        }
        assert(block->function != NULL) ;       // <2>
        if (block->function != NULL) {
            block->function(&block->params) ;
            didInvoke = true ;
        }
    } while (!didInvoke) ;

    return didInvoke ;
}
----
<1> The value of `didInvoke` should always be false at this statement.
<2> There should be no `NULL` function pointers placed in the sync queue,
but should it happen, we just skip that entry and go on to consider
the next one.

=== Dispatching Synchronization Functions on ARM v7-M

It turns out we can do something a bit better for the ARM v7-M
architecture.
This processor's exception architecture is more sophisticated than
that found on most micro-controllers.
It allows for multiple priorities and includes exceptions specifically
designed for dealing with foreground / background interactions.

Interrupts and system exceptions can be given priorities and higher
priority exceptions can preempt lower priority ones.
We advocate a flat scheme, where interrupts run at the same priority
and do _not_ preempt each other.
The `micca` run-time does allow for differing priorities, but it is
strongly suggested that his only be used when absolutely necessary.

The `micca` run-time assumes that the priority of the *Pend SV*
(pend service) exception is the lowest priority.

[source,c]
----
<<arm7m constants>>=
#define MRT_PENDSV_PRIORITY     0xff
----

Exception priorities are encoded in an inverted fashion,
lower priority exceptions have a _higher_ priority exception numbers.

We use the *Pend SV* exception in the ARM v7-M processor to
execute the sync functions.
This exception is intended to be used by interrupt service to
``pend'' a service request.
We can execute the sync functions in the service handler and then there
is no burden to the event loop to test after each event dispatch
if any synchronization needs to be performed.
The processor will handle vectoring to this code when
requests are pending and,
by changing the base priority at which the processor runs,
we can may sure that state activities are not interrupted
by the service handler.

(((micca,ARM v7-M Function,PendSV_Handler)))
[source,c]
----
<<arm7m external functions>>=
#if (defined(__ARM_ARCH) &&  __ARM_ARCH == 7)
void
PendSV_Handler(void)
{
    <<execute sync functions>>
}
#endif /* __ARM_ARCH */
----

Note we are executing the same sync function dispatch code,
the difference is whether the processor exception architecture
starts the code or whether it is done directly by the event loop code.

The *Pend SV* prioritization scheme works by insuring that the Pend SV
exception priority is the lowest.
Normal interrupts and other exceptions preempt execution (except in
small critical sections).
Each time a sync function is queued,
the *Pend SV* exception is marked as pending.
This will cause the exception handler to be invoked and the sync function
to be removed from the queue and executed.
However, we *do not* want the *Pend SV* exception handler to run while
a state activity is running.
It is not safe to do so.
Sync functions are allowed to modify domain state.
To prevent this,
we set the base execution priority of the processor
to be the same as the *Pend SV* priority just before dispatching an event.
This allows exceptions of higher priority (_e.g._ interrupts) to run,
but does not allow the *Pend SV* exception handler to run (in order to
run the priority must be strictly greater than the base priority).
As soon as we are no longer executing a state activity,
we set the base priority to zero and then any exception may run.

So, once a sync function is queued and the *Pend SV* exception is set to
pending, then one of two things happens.

. No state activity was running so the processor invokes the *Pend SV*
handler immediately when the interrupt that queued the sync function exits.
. A state activity was running and resumes where it was preempted
by the interrupt.
When the state activity is done,
the base priority is lowered by the main event loop and the processor vectors
to the *Pend SV* handler as it is still pending.


== Event Dispatch Tracing

Debugging event driven, callback, state machine based applications can be
rather more complicated than conventional, linear flow code.
When class instances generate events to other instances and it can
be hard to determine the exact sequence of execution by simply
examining the source code.
Indeed, part of the intent here is to factor away from the application
the details of sequencing execution.
Setting a breakpoint in the action of a state is easy enough,
the difficulties arise when trying to determine where to set a breakpoint
to catch the results of the next event dispatch.
Given that many events will be flying around a given program,
it is very useful to be able to collect the set of event dispatches
in chronological order.

To help in debugging,
the run-time can be conditionally compiled to support tracing the event
dispatch.
After the code is properly compiled,
a pointer to a trace callback function may be registered and
then each event dispatched will result in the function being called
with the information about the dispatch.

It should be noted that dealing with trace information can be
very difficult.
For small embedded systems,
there may not be sufficient space to store the strings that give
names to states and events (the `MRT_NO_NAMES` macro can be defined
to remove the string information).
This means that only numbers are available to the tracing code
and there is substantial effort required to back
translate the numbers into strings that are meaningful to a human.

Because tracing also affects the performance of the run-time code,
it may also be excluded by defining the `MRT_NO_TRACE` macro.
Most projects will want to define both `MRT_NO_NAMES` and `MRT_NO_TRACE`
in code compiled for a release.
This, along with defining `NDEBUG`, will result in significantly less
initialized data space usage in the executables.

=== Trace Information

Since there are three types of events,
there are three distinct sets of information generated when
an event is dispatched.
There is information common to all events and information
specific to each event type.

(((micca,Run Time Data,MRT_TraceInfo)))
[source,c]
----
<<mrt interface trace aggregate types>>=
struct mrttraceinfo ;
typedef struct mrttraceinfo MRT_TraceInfo ;

<<mrt internal trace aggregate types>>=
struct mrttraceinfo {
    <<common trace fields>>
    union {
        <<transition trace fields>>
        <<polymorphic trace fields>>
        <<creation trace fields>>
    } info ;
} ;
----

==== Common Trace Data

[source,c]
----
<<common trace fields>>=
MRT_EventType eventType ;
MRT_EventCode eventNumber ;
MRT_Instance *sourceInst ;
MRT_Instance *targetInst ;
----

`eventType`::
    The type of the event that was dispatched.
`eventNumber`::
    The number of the event that was dispatched.
`sourceInst`::
    A pointer to the instance that was the source of the dispatched event.
`targetInst`::
    A pointer to the instance that was the target of the dispatched event.

==== Transition Event Trace Data

`transitionTrace`::
+
[source,c]
----
<<transition trace fields>>=
struct transitiontrace {
    MRT_StateCode currentState ;
    MRT_StateCode newState ;
} transitionTrace ;
----
`currentState`:::
    The current state of the instance before the event dispatch.
`newState`:::
    The new state entered as a result of the transition.

==== Polymorphic Event Trace Data

`polyTrace`::
+
[source,c]
----
<<polymorphic trace fields>>=
struct polytrace {
    MRT_SubclassCode subcode ;
    MRT_DispatchCount genNumber ;
    MRT_EventCode mappedEvent ;
} polyTrace ;
----
`subcode`:::
    The subclass code of the currently related instance.
`genNumber`:::
    The number of the generalization down which the event was dispatched.
`mappedNumber`:::
    The new event number to which the polymorphic event mapped.

The subclass type is encoded as a small integer value.
(((micca,Run Time Data,MRT_SubclassCode)))
[source,c]
----
<<mrt internal trace simple types>>=
typedef uint8_t MRT_SubclassCode ;
----

==== Creation Event Trace Data

`creationTrace`::
+
[source,c]
----
<<creation trace fields>>=
struct creationtrace {
    MRT_Class const *targetClass ;
} creationTrace ;
----
`targetClass`:::
    A pointer to the class structure for the target of the
    creation event.

=== Access to Trace Information

Event tracing information is passed out of the run-time by
having the application register a callback function.
That function takes a pointer to the trace information as its
argument.

(((micca,Run Time Data,MRT_TraceHandler)))
[source,c]
----
<<mrt interface trace aggregate types>>=
typedef void (*MRT_TraceHandler)(MRT_TraceInfo const *) ;
----

The function is registered with the run-time by invoking:

*****
[source,c]
----
<<mrt trace external interfaces>>=
extern MRT_TraceHandler
mrt_RegisterTraceHandler(
    MRT_TraceHandler handler) ;
----

`handler`::
    A pointer to a function that handles trace information.

The `mrt_RegisterTraceHandler` function is used to supply a
trace callback function.
Supplying a non-NULL value for _handler_ also enables tracing.
The return value of the the function is the
previous value of the callback.
Tracing can be turned off by invoking `mrt_RegisterTraceHandler` with `NULL`.

The trace handling function is invoked with a pointer to the trace
information for the event being dispatched.
The data pointed to by the argument is not valid after the
return from the trace handler function.
So handler functions must copy the trace data if they wish it to be
available after their return.
*****

The current value of the tracing function is stored in a static variable.

(((micca,Run Time Data,mrtTraceHandler)))
[source,c]
----
<<mrt trace static data>>=
static MRT_TraceHandler mrtTraceHandler ;
----

(((micca,Run Time Function,mrt_RegisterTraceHandler)))
[source,c]
----
<<mrt trace external functions>>=
MRT_TraceHandler
mrt_RegisterTraceHandler(
    MRT_TraceHandler handler)
{
    MRT_TraceHandler oldhandler = mrtTraceHandler ;
    mrtTraceHandler = handler ;
    return oldhandler ;
}
----

The implementation of registering a handler is simply to record the
function pointer in a variable.

For each type of event dispatch,
the run-time calls a specific function to determine if tracing
is enabled and to marshal the trace information into the proper
data structure.

(((micca,Run Time Function,mrtTraceTransitionEvent)))
[source,c]
----
<<mrt trace static functions>>=
static inline void
mrtTraceTransitionEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_StateCode currentState,
    MRT_StateCode newState)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace = {
            .eventType = mrtTransitionEvent,
            .eventNumber = event,
            .sourceInst = source,
            .targetInst = target,
            .info.transitionTrace = {
                .currentState = currentState,
                .newState = newState
            }
        } ;
        mrtTraceHandler(&trace) ;
    }
}
----

(((micca,Run Time Function,mrtTracePolymorphicEvent)))
[source,c]
----
<<mrt trace static functions>>=
static inline void
mrtTracePolymorphicEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_SubclassCode subclass,
    MRT_DispatchCount genNumber,
    MRT_EventCode newEvent)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace = {
            .eventType = mrtPolymorphicEvent,
            .eventNumber = event,
            .sourceInst = source,
            .targetInst = target,
            .info.polyTrace = {
                .subcode = subclass,
                .genNumber = genNumber,
                .mappedEvent = newEvent
            }
        } ;
        mrtTraceHandler(&trace) ;
    }
}
----

(((micca,Run Time Function,mrtTraceCreationEvent)))
[source,c]
----
<<mrt trace static functions>>=
static inline void
mrtTraceCreationEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_Class const *class)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace = {
            .eventType = mrtCreationEvent,
            .eventNumber = event,
            .sourceInst = source,
            .targetInst = target,
            .info.creationTrace = {
                .targetClass = class
            }
        } ;
        mrtTraceHandler(&trace) ;
    }
}
----

=== Obtaining Tracing Output

A default trace handler is supplied that simply prints the
trace information to the standard output using `printf`.
Two version are supplied. One for when strings are present and the other
for when they are not and only numbers can be printed.

(((micca,Run Time Function,mrtPrintTraceInfo)))
[source,c]
----
<<mrt trace static functions>>=
#ifndef MRT_NO_STDIO
#ifndef MRT_NO_NAMES
static void
mrtPrintTraceInfo(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
        char const *newStateName ;
        if (newState == MRT_StateCode_IG) {
            newStateName = "IG" ;
        } else if (newState == MRT_StateCode_CH) {
            newStateName = "CH" ;
        } else {
            newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.newState] ;
        }

        printf("%s: Transition: %s.%s - %s -> %s.%s: %s ==> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.currentState],
            newStateName) ;
    }
        break ;

    case mrtPolymorphicEvent: {
        MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
                genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
        MRT_Class const *subclass ;
        char const *subname = NULL ;
        if (rel->relType == mrtRefGeneralization) {
            subclass = rel->relInfo.refGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
            subname = subclass->name ;
        } else if (rel->relType == mrtUnionGeneralization) {
            subclass = rel->relInfo.unionGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode] ;
            subname = subclass->name ;
        } else {
            printf("%s: bad relationship type in polymorphic event, %d\n",
                mrtTimestamp(), rel->relType) ;
            break ;
        }
        printf("%s: Polymorphic: %s.%s - %s -> %s.%s: %s - %s -> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->pdb->genNames[
                traceInfo->info.polyTrace.genNumber],
            subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
            subname) ;
    }
        break ;

    case mrtCreationEvent:
        printf("%s: Creation: %s.%s - %s -> %s ==> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->info.creationTrace.targetClass->name,
            targetName) ;
        break ;

    default:
        printf("%s: Unknown trace event type, \"%u\"",
                mrtTimestamp(), traceInfo->eventType) ;
        break ;
    }
}
#   else  /* MRT_NO_NAMES is defined */
static void
mrtPrintTraceInfo(
    MRT_TraceInfo const *traceInfo)
{
    switch (traceInfo->eventType) {
    case mrtTransitionEvent:
        printf("%s: Transition: %p - %u -> %p: %u ==> %u\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->targetInst,
                traceInfo->info.transitionTrace.currentState,
                traceInfo->info.transitionTrace.newState) ;
        break ;

    case mrtPolymorphicEvent:
        printf("%s: Polymorphic: %p - %u -> %p: %u - %u -> %d\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->targetInst,traceInfo->info.polyTrace.genNumber,
                traceInfo->info.polyTrace.mappedEvent,
                traceInfo->info.polyTrace.subcode) ;
        break ;

    case mrtCreationEvent:
        printf("%s: Creation: %p - %u -> %p ==> %p\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->info.creationTrace.targetClass,
                traceInfo->targetInst) ;
        break ;

    default:
        printf("%s: Unknown trace event type, \"%u\"",
                mrtTimestamp(), traceInfo->eventType) ;
        break ;
    }
}
#endif /* MRT_NO_NAMES */
#endif /* MRT_NO_STDIO */
----

[source,c]
----
<<mrt forward references>>=
#ifndef MRT_NO_TRACE
static char const *mrtTimestamp(void) ;
#endif /* MRT_NO_TRACE */
----

=== Tracing Strategies

Clearly,
tracing can generate data at a rather high rate and can be
rather intrusive upon the execution of the system.
Several strategies may be used to deal with the trace data.
If possible,
all the trace data can be dumped in a raw form out a communications
interface and let some other program decode and display it.
That may still be too intrusive and sometimes it is best to
filter the trace data based on the target instance pointer value.
In this way you may trace the event dispatches on only a subset of
instances.
Several different filtering schemes, such as source instance or classes,
can be envisioned.

Another possibility is to store trace information in a memory
area in some sort of circular queue arrangement.
Then it is possible for the application to start and stop such tracing
and achieve ``logic analyzer'' type triggering functionality.
The trace information can then be extracted from memory and analyzed.

When running in a POSIX environment,
one can assume reasonable I/O facilities.
The POSIX version of the run-time includes default trace handling to
timestamp and print the trace data in human readable form.

You will also note that the trace information has no timing data associated
with it.
This type of data is so system specific that it is left to the
tracing callback to supply.
If you have a free running cycle counter in your system,
this can be a good indicator of relative time and the trace callback
function can add this to the data set supplied by the run-time.
Your system may also have source of clocked timing data that can also
be used as a timing reference.
In either case, augmenting the trace data with some sort of relative
time information is very valuable.

Tracing can also be used as a framework for testing.
If a domain is built to run in a testing framework where tracing is enabled,
then recording all the trace information allows one to determine
the amount of _transition_ coverage a test set causes.
The goal is to develop test sets that drive the domain with appropriate data so
that all state transitions are taken.
Tracing allows the recording of what transitions a given thread of control
causes.
Since in most well designed state machines,
state activity code is small and does not contain complicated or intricate
internal program flow,
causing all state activities to be executed is often close to complete
statement coverage.
As an added benefit,
state machines can be considered as directed graphs.
A depth first traversal of a directed graph can be be used to determine
a spanning tree for the graph.
Traversing a spanning tree for a graph insures that all nodes in the graph
are visited and the event sequence given by the spanning tree
can guide the generation of test set data and can help to minimize the
number of test cases required to ensure adequate coverage.

== Error Handling

Until now we have glossed over the subject of how to handle errors
in the `micca` run-time.
In XUML,
the domains assume a perfect architecture in the sense that
no formal mechanism is provided to signal architectural errors back to
the application domains.
This makes sense because the application models are meant to be implementation
independent and able to be run on a variety of underlying platforms.
However,
an error policy, in much the same terms as data and execution policies,
must be put into place.
The details of the error handling policy will vary between
software architectures, so it is important to state them clearly.
For the `micca` run-time, the following principles guide error handling.

* To that extent possible, the run-time operations should not report
errors back to the application.
For implementation languages that do not support exception handling,
the usual technique of returning error codes is not very effective.
Either by accident or sloth, many error codes are not checked.
Even when the error code is checked,
there is little recovery recourse for the application.
For example,
it does little good to know that we are unable to generate an
event because we do not have sufficient ECB resources when there
is nothing a state activity can do to free up the required resources.
* Errors that result from exhausted resources or analysis errors
detected at run-time are *fatal*.
Exactly how fatal errors are acted upon is platform dependent and may
result in terminating a program or completely resetting the system.
Regardless of the consequence of a fatal error, the assumption is
that the program can no longer continue to run.

With these principles in mind, we define a set of error conditions
that are detected by the run-time.
All these conditions are fatal and are handled by invoking a fatal
error handler.

(((micca,Run Time Data,MRT_ErrorCode)))
[source,c]
----
<<mrt interface simple types>>=
typedef enum {
    mrtCantHappen = 1,
    mrtEventInFlight,
    mrtNoECB,
    mrtNoInstSlot,
    mrtUnallocSlot,
    mrtSyncOverflow,
    mrtRefIntegrity,
    mrtTransOverflow,
    mrtInstSetOverflow,
    mrtStaticRelationship,
    mrtRelationshipLinkage,
    mrtDupAssociator,

#       ifdef _POSIX_C_SOURCE
    mrtTimerOpFailed,
    mrtSignalOpFailed,
    mrtSelectWaitFailed,
#       endif /* _POSIX_C_SOURCE */
} MRT_ErrorCode ;
----

We will need a string representation of the error codes to
make human readable messages.

(((micca,Run Time Data,mrtErrorMsgs)))
[source,c]
----
<<mrt static data>>=
static char const * const mrtErrorMsgs[] = {
    [0] = "no error",     /* place holder */
    [mrtNoECB] = "no available Event Control Blocks\n",
    [mrtSyncOverflow] = "synchronization queue overflow\n",
    [mrtTransOverflow] = "transaction markings overflow\n",
    [mrtInstSetOverflow] = "instance set overflow: instance number %u\n",
    [mrtStaticRelationship] = "attempt to modify static relationship\n",
    [mrtRelationshipLinkage] = "invalid instance linkage operation or value\n",

#       ifndef MRT_NO_NAMES
    [mrtCantHappen] = "can't happen transition: %s.%s: %s - %s -> CH\n",
    [mrtEventInFlight] = "event-in-flight error: %s.%s - %s -> %s.%s\n",
    [mrtNoInstSlot] = "no available instance slots: %s\n",
    [mrtUnallocSlot] = "unallocated instance slot: %u in class %s\n",
    [mrtRefIntegrity] = "referential integrity check failed: %s\n",
    [mrtDupAssociator] = "duplicate associator instance: %s\n",
#       else
    [mrtCantHappen] = "can't happen transition: %p: %u - %u -> CH\n",
    [mrtEventInFlight] = "event-in-flight error: %p - %u -> %p\n",
    [mrtNoInstSlot] = "no available instance slots: %p\n",
    [mrtUnallocSlot] = "unallocated instance slot: %u in class %p\n",
    [mrtRefIntegrity] = "referential integrity check failed: %p\n",
    [mrtDupAssociator] = "duplicate associator instance: %p\n",
#       endif /* MRT_NO_NAMES */

#       ifdef _POSIX_C_SOURCE
    [mrtTimerOpFailed] = "interval timer operation failed: %s\n",
    [mrtSignalOpFailed] = "signal operation failed: %s\n",
    [mrtSelectWaitFailed] = "blocking on pselect() failed: %s\n",
#       endif /* _POSIX_C_SOURCE */
} ;
----

For some of the error messages,
there are parameters which containing naming information.
Above we defined two versions of the format string for the error message.
When names are not present,
the best we can usually do is to print pointer addresses.
Below we define inline functions to handle the difference when
naming information is included and when it is not.
This allows us to have a single interface and avoid sprinkling
conditional compilation directives through the code.

(((micca,Run Time Function,mrtCantHappenError)))
[source,c]
----
<<mrt implementation static inlines>>=
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtCantHappenError(
    MRT_Instance *const targetInst,
    MRT_StateCode currentState,
    MRT_EventCode eventNumber)
{
    mrtFatalError(mrtCantHappen,
        targetInst->classDesc->name,
        targetInst->name ? targetInst->name : "?",
        targetInst->classDesc->edb->stateNames[currentState],
        targetInst->classDesc->eventNames[eventNumber]) ;
}

#else

noreturn static void inline
mrtCantHappenError(
    MRT_Instance *const targetInst,
    MRT_StateCode currentState,
    MRT_EventCode eventNumber)
{
    mrtFatalError(mrtCantHappen, targetInst, currentState, eventNumber) ;
}

#endif /* MRT_NO_NAMES */
----

(((micca,Run Time Function,mrtEventInFlightError)))
[source,c]
----
<<mrt implementation static inlines>>=
#ifndef MRT_NO_NAMES
noreturn static void inline
mrtEventInFlightError(
    MRT_Instance *const sourceInst,
    MRT_EventCode eventNumber,
    MRT_Instance *const targetInst)
{
    mrtFatalError(mrtEventInFlight,
            sourceInst ? sourceInst->classDesc->name : "?",
            sourceInst ? sourceInst->name : "?",
            targetInst->classDesc->eventNames[eventNumber],
            targetInst->classDesc->name,
            targetInst->name ? targetInst->name : "?") ;
}

#else

noreturn static void inline
mrtEventInFlightError(
    MRT_Instance *const sourceInst,
    MRT_EventCode eventNumber,
    MRT_Instance *const targetInst)
{
    mrtFatalError(mrtEventInFlight, sourceInst, eventNumber, targetInst) ;
}

#endif /* MRT_NO_NAMES */
----

(((micca,Run Time Function,mrtNoInstSlotError)))
[source,c]
----
<<mrt implementation static inlines>>=
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtNoInstSlotError(
    MRT_Class const *const classDesc)
{
    mrtFatalError(mrtNoInstSlot, classDesc->name) ;
}

#else

noreturn static void inline
mrtNoInstSlotError(
    MRT_Class const *const classDesc)
{
    mrtFatalError(mrtNoInstSlot, classDesc) ;
}

#endif /* MRT_NO_NAMES */
----

(((micca,Run Time Function,mrtUnallocSlotError)))
[source,c]
----
<<mrt implementation static inlines>>=
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtUnallocSlotError(
    MRT_InstId slot,
    MRT_Class const *const classDesc)
{
    mrtFatalError(mrtUnallocSlot, slot, classDesc->name) ;
}

#else

noreturn static void inline
mrtUnallocSlotError(
    MRT_InstId slot,
    MRT_Class const *const classDesc)
{
    mrtFatalError(mrtUnallocSlot, slot, classDesc) ;
}

#endif /* MRT_NO_NAMES */
----

(((micca,Run Time Function,mrtRefIntegrityError)))
[source,c]
----
<<mrt implementation static inlines>>=
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtRefIntegrityError(
    MRT_Relationship const *const rel)
{
    mrtFatalError(mrtRefIntegrity, rel->name) ;
}

#else

noreturn static void inline
mrtRefIntegrityError(
    MRT_Relationship const *const rel)
{
    mrtFatalError(mrtRefIntegrity, rel) ;
}

#endif /* MRT_NO_NAMES */
----

(((micca,Run Time Function,mrtDupAssociatorError)))
[source,c]
----
<<mrt implementation static inlines>>=
#ifndef MRT_NO_NAMES

noreturn static void inline
mrtDupAssociatorError(
    MRT_Relationship const *const rel)
{
    mrtFatalError(mrtDupAssociator, rel->name) ;
}

#else

noreturn static void inline
mrtDupAssociatorError(
    MRT_Relationship const *const rel)
{
    mrtFatalError(mrtDupAssociator, rel) ;
}

#endif /* MRT_NO_NAMES */
----

Everywhere else the run-time operations have been crafted to
avoid error possibilities.
For example, as discussed in delayed event generation,
we interpret the attempt to generate a duplicate delayed event
as wishing to cancel the existing one and instantiate a new one.
This semantic interpretation avoids generating an error and avoids
all the additional code require in state activities that generate
delayed events.

Exactly how fatal errors are handled will depend upon the specifics
of how the platform handles errors.
We define an interface for a fatal error handler.

(((micca,Run Time Data,MRT_FatalErrorHandler)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef void (*MRT_FatalErrorHandler)(MRT_ErrorCode, char const *, va_list) ;
----

The interface is patterned after `vprintf`,
giving a format string and a pointer to a variable length argument list.

[source,c]
----
<<mrt forward references>>=
static void
mrtDefaultFatalErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list ap) ;
----

The system provides a default fatal error handler,
a message is printed to the standard error stream.

(((micca,Run Time Function,mrtDefaultFatalErrorHandler)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDefaultFatalErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list ap)
{
#       ifndef MRT_NO_STDIO
    vfprintf(stderr, fmt, ap) ;
#       endif /* MRT_NO_STDIO */
}
----

A pointer to the fatal error handler is initialized with the default one.

(((micca,Run Time Data,mrtErrHandler)))
[source,c]
----
<<mrt static data>>=
static MRT_FatalErrorHandler mrtErrHandler = mrtDefaultFatalErrorHandler ;
----

Because fatal error handling is usually so platform specific and
because of the need to test fatal error paths,
we provide the ability to delegate the consequence of the
fatal error.

******
[source,c]
----
<<mrt external interfaces>>=
extern MRT_FatalErrorHandler
mrt_SetFatalErrorHandler(
    MRT_FatalErrorHandler newHandler) ;
----

`newHandler`::
    A pointer to a fatal error handler function.

The `MRT_FatalErrorHandler` function install `newHandler` as the
fatal error handler and return the previous error handler function pointer.
******

(((micca,Run Time Function,mrt_SetFatalErrorHandler)))
[source,c]
----
<<mrt external functions>>=
MRT_FatalErrorHandler
mrt_SetFatalErrorHandler(
    MRT_FatalErrorHandler newHandler)
{
    MRT_FatalErrorHandler prevHandler = mrtErrHandler ;
    if (newHandler) {
        mrtErrHandler = newHandler ;
    }
    return prevHandler ;
}
----

The run-time internally calls `mrtFatalError`.

[source,c]
----
<<mrt forward references>>=
noreturn static void
mrtFatalError(MRT_ErrorCode errNum, ...) ;
----

(((micca,Run Time Function,mrtFatalError)))
[source,c]
----
<<mrt static functions>>=
noreturn static void
mrtFatalError(
    MRT_ErrorCode errNum,
    ...)
{
    va_list ap ;

    assert(mrtErrHandler != NULL) ;
    assert(errNum < COUNTOF(mrtErrorMsgs)) ;

    va_start(ap, errNum) ;
    mrtErrHandler(errNum, mrtErrorMsgs[errNum], ap) ;
    va_end(ap) ;
    /*
     *  If the handler does return, we insist that all errors
     *  are fatal. So we abort().
     */
    abort() ;
}
----

As we see in the code,
we insist that there is an error handler.
There is always the default one and a different handler can be specified
if necessary.
Finally,
`abort()` is called should the error handler return.

== Avoiding Fatalities

In this error handling strategy,
every run-time detected error is fatal.
Although the details of the processing for fatal errors can be delegated,
in most systems of the class we consider here,
fatal errors usually result in a system reset.
Under the vast majority of circumstances,
that is the desired behavior.
However,
there are some particular circumstances where causing a fatal
error is not the desired behavior.

Consider the case where some external stimulus results in an event
being generated.
If the stimulus occurs more frequently than events can be processed,
then the run-time will run out of event control blocks causing a
fatal error.
As an example,
consider the arrival of a communications packet.
If somewhere during the processing of the packet an event is generated,
then if packets arrive too fast a fatal error can be generated.
In effect it would provide a means for an external stimulus to cause the
system to crash.
Certainly for the case of a communications packet,
the preferred behavior would be to drop the packet and let higher level
protocol deal with the necessary retries, etc.
It is then necessary to be able to determine if generating an event
would be successful.

In this section we describe functions that can be used to avoid run-time
requests that would exhaust an underlying resource and therefore
cause a fatal system error.
It should be emphasized that these functions are *not*
intended for ordinary or casual use.
Under the vast majority of circumstances,
such as when one state machine generates an event to another state
machine,
event generation and other such activities should continue to assume
that there are no resources that can be consumed.
System analysis and testing should then determine the appropriate sizing
for the various resource pools.
The capability described in this section is to handle unusual and
extraordinary circumstances where hardware failure or failure to
abide by communications protocols could force the system into a
fatal error situation.

Note also that the alternative provided here causes the external stimulus
that would cause the fatal error condition effectively to be ignored.
For some system requirements that is not an acceptable solution.
For example,
consider a digital input line that is used to generate an interrupt
and that interrupt signals an external condition monitored by hardware,
say the maximum extent of motion of physical robot arm.
If this interrupt arrives at a very fast rate,
one might conclude the hardware has failed.
Ignoring the interrupt might do little other than mask a problem that should
cause a fatal error condition and potentially reset the system.
The conclusion is that providing a means of avoiding fatal error conditions
is not intented to serve as an overall error handling policy.
Careful analysis and consideration is still required.
If an interrupt arrives faster than expected and,
because of what the interrupt represents, it cannot be ignored,
that fact and the response to it must be deduced by the interrupt service
code (_e.g._ by determining the interrupt frequency) and actions
appropriate to the system must be taken.
It can be a difficult problem to solve and the functions provided here
are too generic to be used indescrimately.

There are three internal run-time resources that can be exhausted.

* Class instances can be dynamically created and each class has its own instance
pool.
* Event control blocks are used for generating and dispatching state machine
events.
* The foreground / background synchronization queue has a fixed number
of slots and excessive synchronization requests from interrupt service
routines can fill the queue.

=== Checking for Available Instance Space

The `mrt_CanCreateInstance()` function provides a means determine if there
is space available to create a new instance of a class.

*****
[source,c]
----
<<mrt internal external interfaces>>=
extern bool
mrt_CanCreateInstance(
    MRT_Class const *const classDesc) ;
----

`classDesc`::
    A pointer to the class data for which the space check is made.

`mrt_CanCreateInstance` returns `true` if there at least one instance
of `classDesc` may be created without exhausting the memory pool
of instances for the class.
*****

(((micca,Run Time Function,mrt_CanCreateInstance)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_CanCreateInstance(
    MRT_Class const *const classDesc)
{
    assert(classDesc != NULL) ;

    /*
     * Search for an empty slot in the pool.
     */
    return mrtFindInstSlot(classDesc->iab) != NULL ;
}
----

=== Checking for Event Blocks

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_CanSignalEvent(void) ;
----

The `mrt_CanSignalEvent` function returns true if it is possible
to signal an event and _not_ cause a system error.
*****

(((micca,Run Time Function,mrt_CanSignalEvent)))
[source,c]
----
<<mrt external functions>>=
bool
mrt_CanSignalEvent(void)
{
    return !mrtEventQueueEmpty(&freeEventQueue) ;
}
----

=== Non-Fatal Background Synchronization

(((micca,Run Time Function,mrt_TrySyncRequest)))
*****
[source,c]
----
<<mrt external interfaces>>=
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc syncfunc) ;
----
`syncfunc`::
    A pointer to a synchronization function.

The `mrt_TrySyncRequest` function attempts to queue `syncfunc` as
a synchronization function.
The return value of the function is `NULL` if the attempt failed
because of lack of space in the sync queue.
Otherwise, the return value is non-NULL and points to space where
the parameters of `syncfunc` may be placed.
*****

=== Linked List Operations

The run-time supplies a set of linked list operations for use
in manipulating the lists of instance pointers used to realize and
navigate associations.
They are the usual circular, doubly linked list manipulations
and are presented here without little further comment.

(((micca,Run Time Function,mrtLinkRefBegin)))
[source,c]
----
<<mrt internal static inlines>>=
static inline MRT_LinkRef *
mrtLinkRefBegin(
    MRT_LinkRef const *list)
{
    return list->next ;
}
----

(((micca,Run Time Function,mrtLinkRefEnd)))
[source,c]
----
<<mrt internal static inlines>>=
static inline MRT_LinkRef *
mrtLinkRefEnd(
    MRT_LinkRef const *list)
{
    return (MRT_LinkRef *)list ;
}
----

(((micca,Run Time Function,mrtLinkRefEmpty)))
[source,c]
----
<<mrt internal static inlines>>=
static inline bool
mrtLinkRefEmpty(
    MRT_LinkRef const *list)
{
    return list->next == list ;
}
----

(((micca,Run Time Function,mrtLinkRefNotEmpty)))
[source,c]
----
<<mrt internal static inlines>>=
static inline bool
mrtLinkRefNotEmpty(
    MRT_LinkRef const *list)
{
    return list->next != list ;
}
----

Note that an empty list is one where the list terminus points back to itself.

(((micca,Run Time Function,mrtLinkRefInit)))
[source,c]
----
<<mrt implementation static inlines>>=
static inline void
mrtLinkRefInit(
    MRT_LinkRef *ref)
{
    ref->next = ref->prev = ref ;
}
----

Because the list is doubly linked,
we only have to have a pointer to the item to remove it.

(((micca,Run Time Function,mrtLinkRefRemove)))
[source,c]
----
<<mrt implementation static inlines>>=
static inline void
mrtLinkRefRemove(
    MRT_LinkRef *item)
{
    item->prev->next = item->next ;
    item->next->prev = item->prev ;
    item->next = item->prev = NULL ; // <1>
}
----
<1> We set the values of the `next` and `prev` members to `NULL` when
the item has been removed from a list.
This gives a handy test to determine if the item is in any list.
This is useful in some of the manipulations of linked lists of references
in order to maintain such lists as a set.

The insert function inserts an item before a given point in the list.
Since it is usually called with a list head as the insertion place,
the net effect is to place the item last in the list.

(((micca,Run Time Function,mrtLinkRefInsert)))
[source,c]
----
<<mrt implementation static inlines>>=
static inline void
mrtLinkRefInsert(
    MRT_LinkRef *item,
    MRT_LinkRef *at)
{
    if (item->next != NULL || item->prev != NULL) { // <1>
        mrtFatalError(mrtRelationshipLinkage) ;
    }
    item->prev = at->prev ;
    item->next = at ;
    at->prev->next = item ;
    at->prev = item ;
}
----
<1> We also test that they are `NULL` before inserting an item into a list
to insure that we are not inserting a duplicate.
Inserting an item that is already in another list destroys the pointer
structure of the list.

== POSIX Specific Code

At this point we have reached the end of the generic
code and must now begin to account for the platform differences
in the way timing and asynchronous execution is handled.
This software architecture can be run on a conventional POSIX platform.
This includes Linux, Mac OS X and even Cygwin.
The primary purpose of making the run-time function in a POSIX environment
is simulation.
Often, a domain can be executed for testing and simulation purposes on
a conventional computer more easily than in the target environment.
With I/O and disk storage, testing and tracing logic is often much easier.
It is also perfectly reasonable to implement an application using `micca` and
targeting a POSIX platform.

=== POSIX Critical Sections

We start with a discussion of how to implement a critical section in POSIX.
In POSIX,
a _signal_ is the means provided for asynchronous execution.
It is unfortunate that the same word, _signal_, is used in POSIX parlance
as we have used as the mechanism for causing state machine transitions.
Signals function in much the same way as interrupts do on a micro-controller.
Signals can interrupt the running process and then return to it after
they complete.
There are times when we must insure that execution is _not_
interrupted by asynchronous signal execution.
The functions in this section accomplish that.

The technique used is to maintain a signal mask of all the signals
that are under control of the run-time.

(((micca,Run Time POSIX Data,mrtSigMask)))
[source,c]
----
<<posix static data>>=
static sigset_t mrtSigMask ;
----

This signal mask can then be used to control signal execution as necessary.
Note that an application can call low level signal handling primitives
and manage subsets of signals outside of the run-time.
This is definitely discouraged as it is likely to introduce race
conditions in the run-time.
The proper behavior of the run-time depends upon it having knowledge
of the signals that are used by the application.
Many programs just use the default behavior for a signal, _e.g._
exiting the program on `SIGHUP`.
The run-time need not know about such default behavior, especially
if the behavior terminates the process.

To keep the run-time informed as to the signals an application uses,
they can register a signal function that will be
called when the signal is received.

*****
[source,c]
----
<<posix external interfaces>>=
typedef void (*MRT_SignalFunc)(int) ;

extern void
mrt_RegisterSignal(
    int sigNum,
    MRT_SignalFunc func) ;
----

`sigNum`::
    The number of the signal being registered.
`func`::
    A pointer to the function that is to be executed when the signal happens.

The function `mrt_RegisterSignal` registers the `func` function to
be called when `sigNum` is signaled to the process.
If `func` is `NULL`, then the signal's behavior is reset
to its default behavior.
*****

The implementation of `mrt_RegisterSignal` accounts for both registering
the signal action with the operating system and maintaining our
signal mask that is used in foreground / background synchronization.

(((micca,Run Time POSIX Function,MRT_RegisterSignal)))
[source,c]
----
<<posix external functions>>=
void
mrt_RegisterSignal(
    int sigNum,
    MRT_SignalFunc func)
{
    assert(sigNum > 0) ;

    struct sigaction action ;
    if (func) {
        action.sa_handler = func ;
        sigaddset(&mrtSigMask, sigNum) ;
    } else {
        action.sa_handler = SIG_DFL ;
        sigdelset(&mrtSigMask, sigNum) ;
    }
    sigfillset(&action.sa_mask) ;
    action.sa_flags = 0 ;

    int sigresult = sigaction(sigNum, &action, NULL) ;
    if (sigresult != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

We set up signal handlers to run uninterrupted by other signals.
This is accomplished by filling the `sa_mask` member of the
`sigaction` structure.
This is simplifies keeping track of what is going on.

Starting a critical section just means that we must block all the managed
signals.

(((micca,Run Time POSIX Function,mrtBeginCriticalSection)))
[source,c]
----
<<posix static functions>>=
static inline void
mrtBeginCriticalSection(void)
{
    if (sigprocmask(SIG_BLOCK, &mrtSigMask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

The end of a critical section is equally easily accomplished by unblocking
the managed signals.

(((micca,Run Time POSIX Function,mrtEndCriticalSection)))
[source,c]
----
<<posix static functions>>=
static inline void
mrtEndCriticalSection(void)
{
    if (sigprocmask(SIG_UNBLOCK, &mrtSigMask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

=== POSIX Timing Interfaces

In this section we present the timing interface for POSIX systems.
In this timing scheme,
the interval timer that measures real time
is used and notifications of elapsed time arrive via SIGALRM.

In an embedded system,
time is usually measured in units of clock ticks,
where the amount of real time represented by a clock tick will vary
from system to system.
It is useful then to run the delayed event queue in hardware device
units rather than a conventional time measure so that we may avoid
the conversion computation each time the delayed event queue timing
is started or stopped.

So, we introduce a couple of functions to convert between clock ticks
and milliseconds and _vice versa_.
Since the POSIX interface operates at a higher level, in the POSIX
case there is no transformation.
Note that there is a bit of data type slight of hand going on here.
We use the `MRT_DelayTime` type to hold values of milliseconds
and clock ticks.
In practice this is not a problem, but the type will have to be
chosen to account for the largest values held either of the uses
of the data type.

[source,c]
----
<<posix static functions>>=
static inline MRT_DelayTime
mrtMsecToTicks(
    MRT_DelayTime msec)
{
    return msec ;
}
----

[source,c]
----
<<posix static functions>>=
static inline MRT_DelayTime
mrtTicksToMsec(
    MRT_DelayTime ticks)
{
    return ticks ;
}
----

For the POSIX run-time,
masking the timer used for delayed events means that we must
block `SIGALRM`.

[source,c]
----
<<posix static functions>>=
static void
mrtSysTimerMask(void)
{
    /*
     * Make sure SIGALRM does not go off.
     */
    sigset_t mask ;
    sigemptyset(&mask) ;
    sigaddset(&mask, SIGALRM) ;
    if (sigprocmask(SIG_BLOCK, &mask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

The corresponding unmasking operation follows the same pattern.

[source,c]
----
<<posix static functions>>=
static void
mrtSysTimerUnmask(void)
{
    /*
     * Allow SIGALRM to notify us.
     */
    sigset_t mask ;
    sigemptyset(&mask) ;
    sigaddset(&mask, SIGALRM) ;
    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

To start a timer we supply the number of ticks we want to expire
before we are notified.

[source,c]
----
<<posix static functions>>=
static void
mrtSysTimerStart(
    MRT_DelayTime time)
{
    struct itimerval delayedEventTimer ;

    delayedEventTimer.it_interval.tv_sec = 0 ;
    delayedEventTimer.it_interval.tv_usec = 0 ;
    delayedEventTimer.it_value.tv_sec = time / 1000 ;
    delayedEventTimer.it_value.tv_usec = (time % 1000) * 1000 ;

    if (setitimer(ITIMER_REAL, &delayedEventTimer, NULL) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }
    mrtSysTimerUnmask() ;
}
----

The code initializes the *real* interval timer to use in servicing the
delayed event queue.
We set the `it_interval` member,
which represents the next value to be loaded into the timer,
to 0.
Then when the time given by the `it_value` member
expires the timer is stopped.
The system timer is specified in microseconds and our time value is in
milliseconds,
so some conversion must be performed.
Upon expiration, SIGALRM is generated.
Notice that we exit the function with SIGALRM unblocked.

Stopping the timer returns the amount of time that had not elapsed.

[source,c]
----
<<posix static functions>>=
static MRT_DelayTime
mrtSysTimerStop(void)
{
    mrtSysTimerMask() ;
    /*
     * Fetch the remaining time.
     */
    struct itimerval delayedEventTimer ;
    if (getitimer(ITIMER_REAL, &delayedEventTimer) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }
    /*
     * Convert the returned time into milliseconds.
     */
    MRT_DelayTime remain =
            delayedEventTimer.it_value.tv_sec * 1000 +
            delayedEventTimer.it_value.tv_usec / 1000 ;
    /*
     * Set the current timer value to zero to turn it off.
     */
    memset(&delayedEventTimer, 0, sizeof(delayedEventTimer)) ;
    if (setitimer(ITIMER_REAL, &delayedEventTimer, NULL) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }

    return remain ;
}
----

Stopping the timer must make sure that SIGALRM
does not expire during the process of getting things stopped.

We need a function to execute when `SIGALRM` goes off.
It must service the delayed event queue and then restart the
timer, if necessary.

[source,c]
----
<<posix static functions>>=
static void
mrtSysTimerExpire(
    int signum)
{
    MRT_DelayTime nextTime = mrt_TimerExpireService() ;
    if (nextTime != 0) {
        mrtSysTimerStart(nextTime) ;
    }
}
----

Since the timing services use `SIGALRM`, the signal registration function
is used to insure that `SIGALRM` is serviced.

[source,c]
----
<<posix static functions>>=
static void
mrtInitSysTimer(void)
{
    mrt_RegisterSignal(SIGALRM, mrtSysTimerExpire) ;
}
----

=== POSIX Async Execution Interface

The POSIX view of a process includes the notion of _signals_.
Signals are a form of asynchronous execution,
and reasonably correspond to the interrupts of a bare metal system.
As we have seen in the timer services above,
we can use signals to access a variety of services on a POSIX system.

In this section we fill out the asynchronous execution interfaces
using signals.
As we will see,
POSIX systems also require that you deal with their I/O interface in order to
properly handle execution sequencing.
For now, we present an interface that allows an application to
deal with the asynchronous aspects of signals.
As expected,
the interface allows an application to register a sync function
that will be executed at the first safe opportunity after the signal
has expired.

[source,c]
----
<<posix external functions>>=
MRT_SyncParams *
mrt_SyncRequest(
    MRT_SyncFunc f)
{
    MRT_SyncParams *params = mrtSyncQueuePut(f) ;
    if (params == NULL) {
        mrtFatalError(mrtSyncOverflow) ;
    }
    return params ;
}
----

The alternate interface is also easily implemented.

[source,c]
----
<<posix external functions>>=
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc f)
{
    return mrtSyncQueuePut(f) ;
}
----

=== POSIX I/O Interface

On POSIX platforms,
the run-time must also supply services to handle I/O.
The reason for this is that there are two means of awakening a sleeping
process, receiving a signal and servicing a I/O file
descriptor.footnote:[ There are other ways to integrate signals and I/O in
POSIX systems.  The use of a `pselect` based approach is a design decision.]
On bare metal systems,
I/O is frequently accomplished on an _ad hoc_ basis
and the single mechanism of the sync queue is usually sufficient.
However, POSIX makes a distinction between signals and I/O operations on
file descriptors and an interface needs to be provided to deal with
servicing file descriptors that require attention.

We model this interface after the one for signals.
The idea is that a set of callback functions can be registered
on a file descriptor for reading, writing or an exception.
When the condition is satisfied the callback is invoked.
So we must define an I/O callback function as:

(((micca,Run Time Data,MRT_FDServiceFunc)))
[source,c]
----
<<posix external interfaces>>=
typedef void (*MRT_FDServiceFunc)(int) ;
----

When the callback is invoked,
it is passed the value of the file descriptor that requires service.

The run-time provide two functions for I/O.
One registers the callbacks for a file descriptor and the other removes 
a file descriptor from consideration.

*****
[source,c]
----
<<posix external interfaces>>=
extern void
mrt_RegisterFDService(
    int fd,
    MRT_FDServiceFunc readService,
    MRT_FDServiceFunc writeService,
    MRT_FDServiceFunc exceptService) ;
----

`fd`::
    A file descriptor as returned from `open`, `socket`
    or any other system calls that create file descriptors.
`readService`::
    A pointer to a callback function that will be registered for the file
    descriptor and invoked when the file descriptor is readable
    or `NULL` if no callback is registered.
`writeService`::
    A pointer to a callback function that will be registered for the file
    descriptor and invoked when the file descriptor is writable
    or `NULL` if no callback is registered.
`exceptService`::
    A pointer to a callback function that will be registered for the file
    descriptor and invoked when the file descriptor is in an exception
    condition or `NULL` if no callback is registered.
    In practice, exception conditions are used only for reading
    OOB (out of bands) data on a TCP socket.
*****

The corresponding remove function has the following interface.

*****
[source,c]
----
<<posix external interfaces>>=
extern void
mrt_UnregisterFDService(
    int fd,
    bool rmRead,
    bool rmWrite,
    bool rmExcept) ;
----

`fd`::
    A file descriptor as returned from `open`, `socket`
    or any other system calls that create file descriptors.
`rmRead`::
    A boolean indicated whether or not the file descriptor should
    have its read callback unregistered.
`rmWrite`::
    A boolean indicated whether or not the file descriptor should
    have its write callback unregistered.
`rmExcept`::
    A boolean indicated whether or not the file descriptor should
    have its exception callback unregistered.
*****

The implementation of these two functions requires some internal
data structures to track the file descriptor sets.
File descriptor sets are handed to `pselect` to indicate how a process
is to be awakened for I/O servicing.

To track the callback functions we need a data structure.

(((micca,Run Time Data,MRT_FDServiceMap)))
[source,c]
----
<<posix implementation aggregate types>>=
typedef struct mrtfdservicemap {
    bool set ;
    MRT_FDServiceFunc read ;
    MRT_FDServiceFunc write ;
    MRT_FDServiceFunc except ;
} MRT_FDServiceMap ;
----

`set`::
    A boolean indicating whether or not the entry is in use.
`read`::
    A pointer to the read callback registered for the file descriptor
    or `NULL` if no callback is registered.
`write`::
    A pointer to the write callback registered for the file descriptor
    or `NULL` if no callback is registered.
`except`::
    A pointer to the exception callback registered for the file descriptor
    or `NULL` if no callback is registered.

Following our familiar pattern,
we define an array of mapping entries that defines a pool for storing
the entries that map file descriptor state to callbacks.
This array is indexed by file descriptor value.

[source,c]
----
<<posix static data>>=
static struct mrtfdservicemap mrtFDServicePool[FD_SETSIZE] ;
----

The value of `FD_SETSIZE` is determined by the system and is the
maximum number of file descriptors that can be in a `fd_set` given
to `select`.

One complication of using `pselect` as a means of registering intent
on multiple file descriptors is that you must keep track of the largest
value of a file descriptor in the set handed to `pselect`.
This is an argument to `pselect` (and `select`).
Fortunately, UNIX file descriptors operate in a rather predictable manner.
Each process has file descriptors 0, 1, and 2 open when the process is
started.
Creating a new file descriptor (_e.g._ by opening a file) will allocate
the next largest unused file descriptor number.
This rule applies to the three file descriptors opened by default for a process.
So, for example, closing file descriptor 2 and then opening a new file
will result in file descriptor 2 being reused.
All this makes tracking the maximum file descriptor number relatively easy.
We only need a single integer variable.

[source,c]
----
<<posix static data>>=
static int mrtMaxFD = -1 ;
----

Since `mrtMaxFD` holds the maximum value of the file descriptors
that have been registered, the value -1 indicates that there are no
registered file descriptors.

We need variables to hold the three sets of file descriptors needed
by `pselect`.

[source,c]
----
<<posix static data>>=
static fd_set mrtReadFDS ;
static fd_set mrtWriteFDS ;
static fd_set mrtExceptFDS ;
----

Finally, we can talk about the implementation of the I/O registration
functions.

[source,c]
----
<<posix external functions>>=
void
mrt_RegisterFDService(
    int fd,
    MRT_FDServiceFunc readService,
    MRT_FDServiceFunc writeService,
    MRT_FDServiceFunc exceptService)
{
    assert(fd >= 0 && fd < FD_SETSIZE) ;
    MRT_FDServiceMap *fds = mrtFDServicePool + fd ;

    fds->read = readService ;
    if (readService) {
        FD_SET(fd, &mrtReadFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtReadFDS) ;
    }

    fds->write = writeService ;
    if (writeService) {
        FD_SET(fd, &mrtWriteFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtWriteFDS) ;
    }

    fds->except = exceptService ;
    if (exceptService) {
        FD_SET(fd, &mrtExceptFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtExceptFDS) ;
    }

    if (fds->read == NULL && fds->write == NULL && fds-> except == NULL) {
        if (fds->set && fd >= mrtMaxFD) {
            --mrtMaxFD ;
        }
        fds->set = false ;
    } else if (fds->set && fd > mrtMaxFD) {
        mrtMaxFD = fd ;
    }
}
----

The function simply tests the various callback functions and if
they are not `NULL`,
then the file descriptor is added to the appropriate set.
As written,
`mrt_RegisterFDService` may be used to modify file descriptors already
registered.
The last bit of logic is there in case `mrt_RegisterFDService` is used
to effectively remove the file descriptor by supplying three `NULL`
callback function pointers.
We must also account for the maximum file descriptor value that
has been registered.

Unregistering a file descriptor from consideration is also straight forward.

[source,c]
----
<<posix external functions>>=
void
mrt_UnregisterFDService(
    int fd,
    bool rmRead,
    bool rmWrite,
    bool rmExcept)
{
    assert(fd >= 0 && fd < FD_SETSIZE) ;
    MRT_FDServiceMap *fds = mrtFDServicePool + fd ;

    if (rmRead) {
        fds->read = NULL ;
        FD_CLR(fd, &mrtReadFDS) ;
    }

    if (rmWrite) {
        fds->write = NULL ;
        FD_CLR(fd, &mrtWriteFDS) ;
    }

    if (rmExcept) {
        fds->except = NULL ;
        FD_CLR(fd, &mrtExceptFDS) ;
    }

    if (fds->read == NULL && fds->write == NULL && fds-> except == NULL &&
            fd >= mrtMaxFD) {
        mrtMaxFD = fd - 1 ;
    }
}
----

We also need something to initialize the file descriptor sets that we
are maintaining.

[source,c]
----
<<posix static functions>>=
static void
mrtInitFDService(void)
{
    FD_ZERO(&mrtReadFDS) ;
    FD_ZERO(&mrtWriteFDS) ;
    FD_ZERO(&mrtExceptFDS) ;
}
----

=== POSIX Suspending Execution

The main loop detects when there is nothing left to do and
suspends execution.
Here we present how that suspension happens for the POSIX version of the
run-time.

This design is based on using `pselect` to suspend a process until
either a signal occurs or a file descriptor requires service.
The `mrtWait` function is called by the main loop when there is no
work currently to be done.
It is invoked inside of a critical section.
This is an important entry condition for `mrtWait`.
In the POSIX case,
this means that `mrtWait` must be invoked with all the registered
signals blocked.
We then use `pselect` to atomically enable all signals and block the process.

[source,c]
----
<<posix static functions>>=
static void
mrtWait(void)
{
    mrtBeginCriticalSection() ;
    if (mrtSyncQueueEmpty()) {
        /*
         * Copy the file descriptor sets since "pselect" modifies them in place
         * upon return.
         */
        fd_set readfds ;
        memcpy(&readfds, &mrtReadFDS, sizeof(readfds)) ;
        fd_set writefds ;
        memcpy(&writefds, &mrtWriteFDS, sizeof(writefds)) ;
        fd_set exceptfds ;
        memcpy(&exceptfds, &mrtExceptFDS, sizeof(exceptfds)) ;
        /*
         * Allow all the signals during the select.
         */
        sigset_t mask ;
        sigemptyset(&mask) ;
        /*
         * "mrtMaxFD" holds the maximum value of any registered file
         * descriptor. We must add one to get the number of file descriptors
         * "pselect" is to consider.
         */
        int r = pselect(mrtMaxFD + 1, &readfds, &writefds,
                &exceptfds, NULL, &mask) ;
        if (r == -1) {
            if (errno != EINTR) {
                mrtFatalError(mrtSelectWaitFailed, strerror(errno)) ;
            }
            /*
             * Got a signal while waiting. We go back to the main loop on the
             * assumption that something has been placed in the sync queue.
             */
        } else {
            /*
             * Dispatch the service functions for the file descriptors.
             */
            MRT_FDServiceMap *s = mrtFDServicePool ;
            for (int fd = 0 ; r > 0 && fd <= mrtMaxFD ; fd++, s++) {
                /*
                 * Do exceptions first. This is only important for sockets, but
                 * without going first the OOB data processing won't work.
                 */
                if (FD_ISSET(fd, &exceptfds)) {
                    assert(s->except != NULL) ;
                    s->except(fd) ;
                    --r ;
                }
                if (FD_ISSET(fd, &readfds)) {
                    assert(s->read != NULL) ;
                    s->read(fd) ;
                    --r ;
                }
                if (FD_ISSET(fd, &writefds)) {
                    assert(s->write != NULL) ;
                    s->write(fd) ;
                    --r ;
                }
            }
        }
    }
    mrtEndCriticalSection() ;
}
----

By far, most of the work in `mrtWait` is to deal with the
file descriptor status changes.
The file descriptor sets
must be copied before being handed to `pselect` since it modifies
them in place.
After we determine that it was a file descriptor status change that
caused us to wake up,
we must go through and find all file descriptors that had a status
change and invoke the callback function.

The way that we are using `pselect` in this circumstance may seem
a bit backwards.
Upon entry to `mrtWait`,
we start a critical section where
the registered signals are blocked.
The signal mask given to `pselect` is empty, meaning that `pselect`
will allow all signals while the process sleeps.
Upon the return from `pselect` we will be back to the state where
the registered signals are blocked.
Thus we avoid the race condition where
we have determined that the sync queue is empty, but
asynchronous execution that might affect the
sync queue arrives before we can put the process to sleep.
This is exactly the type of race condition `pselect` is used to prevent.

It is also worth noting we do _not_ use any time out in the
`pselect` invocation.
All timing is done via delayed events, and they are signalled via
`SIGALRM` and managed on the delayed event queue as discussed before.

=== POSIX Tracing

Since we have ready access to time information on POSIX,
we can put together a convenience function to format the current
time of day into a timestamp.
The format of the timestamp makes it easy to sort based on the
string representation.

[source,c]
----
<<posix trace static functions>>=
static char const *
mrtTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "too big" ;
    }

    return timestamp ;
}
----

=== POSIX Initialization

Here we present the POSIX version of the required internal initialization.

(((micca,Run Time POSIX Function,mrtPlatformInit)))
[source,c]
----
<<posix static functions>>=
static inline void
mrtPlatformInit(void)
{
    sigemptyset(&mrtSigMask) ;
}
----

[source,c]
----
<<posix external functions>>=
void
mrt_Initialize(void)
{
    mrtPlatformInit() ;
    mrtECBPoolInit() ;
    mrtInitSysTimer() ;
    mrtInitFDService() ;
    setvbuf(stdout, NULL, _IOLBF, 0) ; // <1>
#       if !(defined(MRT_NO_TRACE) || defined(MRT_NO_STDIO))
    mrt_RegisterTraceHandler(mrtPrintTraceInfo) ; // <2>
#       endif /* !defined(MRT_NO_TRACE) && !defined(MRT_NO_STDIO) */
}
----
<1> Set up line buffering on stdout. This make sure we see output
even if we are piping the output to some other command.
<2> We always register a tracing function unless it is specifically
compiled out.

=== POSIX Include Files

We will need a number of POSIX specific include files.

[source,c]
----
<<posix includes>>=
#include <signal.h>
#include <errno.h>
#include <sys/select.h>
#include <sys/time.h>
#include <time.h>
----

=== POSIX Files

Here we present the two literate program roots for the run-time.
We adopt a naming convention for the chunk names with the understanding
that they will be renamed to ``micca_rt.h'' and ``micca_rt.c'' when
the files are created by tangling.

==== Run Time Header Header for POSIX

[source,c]
----
<<micca_rt_posix.h>>=
/*
<<edit warning>>
<<copyright info>>

<<version info>>
*/

#ifndef MICCA_RT_H_
#define MICCA_RT_H_

<<common header file definitions>>

<<posix external interfaces>>

#endif /* MICCA_RT_H_ */
----

==== Run Time Code File for POSIX

[source,c]
----
<<micca_rt_posix.c>>=
/*
<<edit warning>>
<<copyright info>>

<<version info>>
*/

#define _POSIX_C_SOURCE 200809L

#include "micca_rt.h"
#include "micca_rt_internal.h"
<<posix includes>>

/*
 * Constants
 */
<<mrt implementation constants>>

/*
 * Data Types
 */
<<mrt implementation simple types>>
<<mrt implementation aggregate types>>
<<posix implementation aggregate types>>

/*
 * Forward References
 */
<<mrt forward references>>
<<posix forward references>>

/*
 * Static Data
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static data>>
#   endif /* MRT_NO_TRACE */

<<mrt static data>>
<<posix static data>>

/*
 * Static Inline Functions
 */
<<mrt implementation static inlines>>

/*
 * Static Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static functions>>
<<posix trace static functions>>
#   endif /* MRT_NO_TRACE */

<<posix static functions>>
<<mrt static functions>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external functions>>
#   endif /* MRT_NO_TRACE */

<<posix external functions>>
<<mrt external functions>>
----

== ARM v7-M Specific Code

A version of the run-time code is also given for the ARMv7-M
architecture.
This is the processor architecture for the ARM^(R)^ Cortex-M series
of processors.

ARM processors are always a bit different from those provided by
a single manufacturer.
ARM only specifies the processor core and instruction set.
The chip delivered by a particular company usually consist of a
a system on a chip (SOC) that includes both the ARM core and a
set of SOC specific peripherals, such as timers and ADC's.
This means that some of the support for the ARMv7-M architecture is
generic and some is SOC specific.

We show run-time adaptations for two different ARM SOC's:

* The EFM32 Giant Gecko is available from
  http://www.silabs.com[Silicon Labs] and features an
  ARM Cortex-M3 core.
* The MSP432 is available from http://www.ti.com[Texas Instruments] and
  features an ARM Cortex-M4 core.

Controlling basic functions in the processor is generic and we present
generic code that is common to both chips.

The code to control vendor specific peripherals might be clumsy were it
not for the CMSIS initiative by ARMfootnote:[CMSIS involves many different
parts. Here we deal only with the core aspects of the CMSIS standard.].
Vendors supply ``C'' header files with the preferred naming conventions
for use on their chips.
This greatly simplifies being able to provide common core related code
and vendor specific code.

=== ARM v7-M Constants

[source,c]
----
<<arm7m constants>>=
#define MRT_MAX_CLOCK_TICKS     (UINT32_MAX - 1)
----

=== ARM v7-M Critical Sections

[source,c]
----
<<arm7m static functions>>=
static inline void
mrtBeginCriticalSection(void)
{
    __disable_irq() ;
}
----

[source,c]
----
<<arm7m static functions>>=
static inline void
mrtEndCriticalSection(void)
{
    __enable_irq() ;
}
----

=== ARM v7-M Async Execution Interface

When posting a sync function,
we must make sure no interrupt service is executed
and so put a critical section around the call to `mrtSyncQueuePut`

[source,c]
----
<<arm7m external functions>>=
MRT_SyncParams *
mrt_SyncRequest(
    MRT_SyncFunc f)
{
    MRT_SyncParams *params = mrtSyncQueuePut(f) ;
    if (params == NULL) {
        mrtFatalError(mrtSyncOverflow) ;
    }

#       if (defined(__ARM_ARCH) &&  __ARM_ARCH == 7)
    SCB->ICSR = SCB_ICSR_PENDSVSET_Msk ;                // <1>
#       endif /* __ARM_ARCH */

    return params ;
}
----
<1> Here is here the *Pend SV* exception is set to pending.

The alternate, non-fatal interface is also easily implemented.

[source,c]
----
<<arm7m external functions>>=
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc f)
{
    MRT_SyncParams *params = mrtSyncQueuePut(f) ;

#       if (defined(__ARM_ARCH) &&  __ARM_ARCH == 7)
    if (params != NULL) {
        SCB->ICSR = SCB_ICSR_PENDSVSET_Msk ;
    }
#       endif /* __ARM_ARCH */

    return params ;
}
----

=== ARM v7-M Initialization

[source,c]
----
<<arm7m external functions>>=
void
mrt_Initialize(void)
{
    mrtPlatformInit() ;
    mrtECBPoolInit() ;
    mrtInitSysTimer() ;
#       if !(defined(MRT_NO_TRACE) || defined(MRT_NO_STDIO))
    mrt_RegisterTraceHandler(mrtPrintTraceInfo) ;
#       endif /* !defined(MRT_NO_TRACE) && !defined(MRT_NO_STDIO) */
}
----

=== EFM32GG Includes

[source,c]
----
<<efm32gg includes>>=

#include "em_device.h"
#include "em_chip.h"
#include "em_cmu.h"
#include "em_emu.h"
#include "em_rtc.h"
#include "em_rmu.h"
#include "em_burtc.h"

#ifdef MRT_SWO_OUTPUT
#   include "bsp_trace.h"
#endif /* MRT_SWO_OUTPUT */
----

=== EFM32GG Timing Interfaces

[source,c]
----
<<efm32gg constants>>=
#define MRT_TIMER_FREQUENCY     1024
/*
 * for a timer frequency of 1024 ticks / sec,
 * max delay is 4,194,303 s == 69,905 min == 1,165 hr == 48.5 days
 */
#define MRT_MAX_MSEC_DELAY\
    ((MRT_MAX_CLOCK_TICKS / (uint32_t)(MRT_TIMER_FREQUENCY)) * (uint32_t)(1000))
----

[source,c]
----
<<efm32gg static functions>>=
static inline MRT_DelayTime
mrtMsecToTicks(
    MRT_DelayTime msec)
{
    if (msec > MRT_MAX_MSEC_DELAY) {
        msec = MRT_MAX_MSEC_DELAY ;
    }
    /*
     * Use 64 bit arithmetic to avoid overflow.
     */
    return ((uint64_t)msec * (uint64_t)(MRT_TIMER_FREQUENCY) +
            (uint64_t)(1000 / 2)) / (uint64_t)(1000) ;
}
----

[source,c]
----
<<efm32gg static functions>>=
static inline MRT_DelayTime
mrtTicksToMsec(
    MRT_DelayTime ticks)
{
    return ((uint64_t)ticks * UINT64_C(1000) +
            UINT64_C(MRT_TIMER_FREQUENCY / 2)) /
            UINT64_C(MRT_TIMER_FREQUENCY) ;
}
----

[source,c]
----
<<efm32gg static functions>>=
static void
mrtInitSysTimer(void)
{
    RTC_Reset() ;
    /*
     * The Low Frequency Crystal is driving the RTC.
     * It's frequency is 32,768 Hz.
     * Set RTC prescaler to divide by 32 to get a 1024 Hz timer frequency.
     */
    CMU_ClockDivSet(cmuClock_RTC, cmuClkDiv_32) ;
    /*
     * Enable Low Freq A Clock to run the RTC.
     */
    CMU_ClockEnable(cmuClock_RTC, true) ;
    RTC_Init_TypeDef init = RTC_INIT_DEFAULT ;
    init.enable = false ;
    RTC_Init(&init) ;
    /*
     * Enable interrupt at the NVIC.
     */
    NVIC_ClearPendingIRQ(RTC_IRQn) ;
    NVIC_EnableIRQ(RTC_IRQn) ;
}
----

[source,c]
----
<<efm32gg static functions>>=
static void
mrtSysTimerMask(void)
{
    RTC_IntDisable(RTC_IFC_COMP0) ;
}
----

[source,c]
----
<<efm32gg static functions>>=
static void
mrtSysTimerUnmask(void)
{
    RTC_IntEnable(RTC_IFC_COMP0) ;
}
----

[source,c]
----
<<efm32gg static functions>>=
static void
mrtSysTimerStart(
    MRT_DelayTime time)
{
    RTC_CompareSet(0, time) ;
    RTC_IntClear(RTC_IFC_COMP0) ;
    mrtSysTimerUnmask() ;
    RTC_Enable(true) ;
}
----

[source,c]
----
<<efm32gg static functions>>=
static MRT_DelayTime
mrtSysTimerStop(void)
{
    /*
     * There is a race between when we read the CNT register and when we
     * actually get the timer stopped where it may expire. If it expires, the
     * interrupt flag will be set and we can use that as an indication that the
     * CNT register is not valid (i.e. it was cleared to zero when the timer
     * expired).  This is different than if we had just been enabled and
     * requested to stop before one tick went by (in our case that's ~ 244
     * microsecond) and count would have been zero. So this is a bit tricky in
     * here.
     */
    MRT_DelayTime remain ;

    mrtSysTimerMask() ;
    if (RTC->CTRL & RTC_CTRL_EN) {
        remain = RTC->COMP0 ;
        remain -= RTC->CNT ;
        /*
         * Check that the timer didn't expire, as is indicated by the interrupt
         * flag, while we were trying to read the registers.
         */
        if (RTC->IF & RTC_IF_COMP0) {
            remain = 0 ;
        }
    } else {
        remain = 0 ;
    }
    RTC_Enable(false) ; // timer disabled

    return remain ;
}
----

[source,c]
----
<<efm32gg external functions>>=
void
RTC_IRQHandler(void)
{
    RTC_Enable(false) ; // timer disabled
    RTC_IntClear(RTC_IFC_COMP0) ;
    MRT_DelayTime nextTime = mrt_TimerExpireService() ;
    if (nextTime != 0) {
        mrtSysTimerStart(nextTime) ;
    }
}
----

=== EFM32GG Initialization

[source,c]
----
<<efm32gg static functions>>=
static void
mrtPlatformInit(void)
{
    /*
     * Workaround for chip errata.
     */
    CHIP_Init() ;
    /*
     * Set stack align, so ISR's are truly ordinary "C" functions.
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk ;
    /*
     * Update the global notion of the system clock frequency.  The device
     * drivers need this to calculate various dividers properly.
     */
    SystemCoreClockUpdate() ;
    /*
     * High frequency peripheral clock.
     */
    CMU_ClockDivSet(cmuClock_HFPER, cmuClkDiv_1) ;
    CMU_ClockEnable(cmuClock_HFPER, true) ;
    /*
     * Enable the LF Crystal Oscillator.
     */
    CMU_OscillatorEnable(cmuOsc_LFXO, true, true) ;
    /*
     * Enable the Ultra-Low Frequency Oscillator for use by the Backup
     * Real Time clock.
     */
    CMU_OscillatorEnable(cmuOsc_ULFRCO, true, true) ;
    /*
     * Enable the low energy clock bus.
     */
    CMU_ClockEnable(cmuClock_CORELE, true) ;
    /*
     * Select the external crystal oscillator for the low frequency clocks.
     */
    CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO) ;
    CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO) ;
    /*
     * Enable the Backup Realtime Clock as a timestamp.
     * N.B. we must enable the Backup Unit itself before the clock
     * is programmable.
     */
     RMU_ResetControl(rmuResetBU, rmuResetModeClear) ;
     BURTC_Init_TypeDef buinit = BURTC_INIT_DEFAULT ;
     buinit.clkDiv = burtcClkDiv_2 ;
     /*
      * set to 1 kHz frequency, default is 2.
      * This will give us a 1 msec free running clock.
      */
     BURTC_Init(&buinit) ;

#       ifdef MRT_SWO_OUTPUT
    /*
     * Retarget instrumentation I/O to the SWO output so it will
     * show up in the debugger output console.
     */
    BSP_TraceSwoSetup() ;
#       endif /* MRT_SWO_OUTPUT */

    NVIC_SetPriority(PendSV_IRQn, MRT_PENDSV_PRIORITY) ;    // <1>
}
----
<1> After reset, all exception priorities are at the highest level.
We make sure the set the PendSV priority to our lowest level value
so that the sync function dispatch works properly.

=== EFM32GG Suspending Execution

[source,c]
----
<<efm32gg static functions>>=
static void
mrtWait(void)
{
    mrtBeginCriticalSection() ;                     // <1>

    if (mrtEventQueueEmpty(&tocEventQueue)) {       // <2>
        EMU_EnterEM2(true) ;
    }

    mrtEndCriticalSection() ;
}
----
<1> Make sure the Pend SV handler does not run after this point.
<2> By the time `mrtWait` is invoked, we know that the both event queues
had gone empty.
However, between the time the test for empty event queues is made
and we reach here, an interrupt could have gone off.
For the ARM v7-M architectures, that means the Pend SV handler would
have been executed and any queue sync functions invoked.
Those sync functions could have placed events on the TOC event queue.
So to make sure there is no pending work to be done,
_i.e._ to make sure we didn't loose the race with the interrupt,
we must test if there are any queued TOC events.
_N.B._ the sync queue will always be empty here since the
Pend SV exception handler is free to run until after
we have executed `mrtBeginCriticalSection`.

=== EFM32GG Tracing

[source,c]
----
<<efm32gg trace static functions>>=
static char const *
mrtTimestamp(void)
{
    static char tsbuf[16] ;

    uint32_t ts = BURTC_CounterGet() ;

    snprintf(tsbuf, sizeof(tsbuf), "%03lu.%03lu", ts / 1000, ts % 1000) ; // <1>
    return tsbuf ;
}
----
<1> Recall that the `BURTC` was set up to be a free running 1 msec counter.
The timestamp is split into a seconds portion and a milliseconds portion.

=== EFM32GG Files

[source,c]
----
<<micca_rt_efm32gg.h>>=
/*
<<edit warning>>
<<copyright info>>

<<version info>>
*/

#ifndef MICCA_RT_H_
#define MICCA_RT_H_

<<common header file definitions>>

#endif /* MICCA_RT_H_ */
----

[source,c]
----
<<micca_rt_efm32gg.c>>=
/*
<<edit warning>>
<<copyright info>>

<<version info>>
*/

/*
 * Includes
 */
#include "micca_rt.h"
#include "micca_rt_internal.h"
<<efm32gg includes>>

/*
 * Constants
 */
<<mrt implementation constants>>
<<arm7m constants>>
<<efm32gg constants>>

/*
 * Data Types
 */
<<mrt implementation simple types>>
<<mrt implementation aggregate types>>

/*
 * Forward References
 */
<<mrt forward references>>

/*
 * Static Data
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static data>>
#   endif /* MRT_NO_TRACE */

<<mrt static data>>
<<efm32gg static data>>

/*
 * Static Inline Functions
 */
<<mrt implementation static inlines>>

/*
 * Static Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static functions>>
<<efm32gg trace static functions>>
#   endif /* MRT_NO_TRACE */

<<arm7m static functions>>
<<efm32gg static functions>>
<<mrt static functions>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external functions>>
<<efm32gg trace external functions>>
#   endif /* MRT_NO_TRACE */

<<arm7m external functions>>
<<efm32gg external functions>>
<<mrt external functions>>
----

=== MSP432 Includes

[source,c]
----
<<msp432 includes>>=
#define NO_MSP_CLASSIC_DEFINES

#include "msp.h"

#define TIMER_DIVIDER   256

extern uint32_t SystemCoreClock ;
----

=== MSP432 Timing Interfaces

[source,c]
----
<<msp432 includes>>=
#define MRT_MAX_MSEC_DELAY ((MRT_MAX_CLOCK_TICKS / mrtTimerFrequency) * 1000UL)

<<msp432 static data>>=
static uint32_t mrtTimerFrequency ;
----

[source,c]
----
<<msp432 static functions>>=
static inline MRT_DelayTime
mrtMsecToTicks(
    MRT_DelayTime msec)
{
    /*
     * for 3 MHz divided down by 256
     * max delay is 366,503,875 ms
     * == 3,665,038 s == 61083 min == 1,018 hr == 42 days
     */
    if (msec > MRT_MAX_MSEC_DELAY) {
        msec = MRT_MAX_MSEC_DELAY ;
    }
    /*
     * We must avoid overflow if the requested number of
     * msecs is large.
     */
    return msec < MRT_MAX_CLOCK_TICKS / mrtTimerFrequency ?
            ((msec * mrtTimerFrequency) + 1000UL / 2UL) / 1000UL :
            ((msec + 1000UL / 2UL) / 1000UL) * mrtTimerFrequency ;
}
----

[source,c]
----
<<msp432 static functions>>=
static inline MRT_DelayTime
mrtTicksToMsec(
    MRT_DelayTime ticks)
{
    return ticks < MRT_MAX_CLOCK_TICKS / 1000UL ?
        ((ticks * 1000UL) + mrtTimerFrequency / 2UL) / mrtTimerFrequency :
        ((ticks + mrtTimerFrequency / 2UL) / mrtTimerFrequency) * 1000UL ;
}
----

[source,c]
----
<<msp432 static functions>>=
static void
mrtInitSysTimer(void)
{
    /*
     * for 3 MHz, dividing down by 256 ==> 11718
     */
    mrtTimerFrequency = SystemCoreClock / (uint32_t)256 ;

    TIMER32_1->CONTROL =
            TIMER32_CONTROL_PRESCALE_2 |
            TIMER32_CONTROL_SIZE |
            TIMER32_CONTROL_ONESHOT ;
    TIMER32_1->INTCLR = 0 ;
    NVIC_ClearPendingIRQ(T32_INT1_IRQn) ;
    NVIC_EnableIRQ(T32_INT1_IRQn) ;
}
----

[source,c]
----
<<msp432 static functions>>=
static void
mrtSysTimerMask(void)
{
    BITBAND_PERI(TIMER32_1->CONTROL, TIMER32_CONTROL_IE_OFS) = 0 ;
}
----

[source,c]
----
<<msp432 static functions>>=
static void
mrtSysTimerUnmask(void)
{
    TIMER32_1->INTCLR = 0 ;
    BITBAND_PERI(TIMER32_1->CONTROL, TIMER32_CONTROL_IE_OFS) = 1 ;
}
----

[source,c]
----
<<msp432 static functions>>=
static void
mrtSysTimerStart(
    MRT_DelayTime time)
{
    TIMER32_1->LOAD = time ;
    mrtSysTimerUnmask() ;
    BITBAND_PERI(TIMER32_1->CONTROL, TIMER32_CONTROL_ENABLE_OFS) = 1 ;
}
----

[source,c]
----
<<msp432 static functions>>=
static MRT_DelayTime
mrtSysTimerStop(void)
{
    mrtSysTimerMask() ;
    BITBAND_PERI(TIMER32_1->CONTROL, TIMER32_CONTROL_ENABLE_OFS) = 0 ;
    return TIMER32_1->VALUE ;
}
----

[source,c]
----
<<msp432 external functions>>=
void
T32_INT1_IRQHandler(void)
{
    TIMER32_1->INTCLR = 0 ;
    MRT_DelayTime nextTime = mrt_TimerExpireService() ;
    if (nextTime != 0) {
        mrtSysTimerStart(nextTime) ;
    } else {
        mrtSysTimerStop() ;
    }
}
----

=== MSP432 Initialization

[source,c]
----
<<msp432 static functions>>=
static void
mrtPlatformInit(void)
{
    NVIC_SetPriority(PendSV_IRQn, MRT_PENDSV_PRIORITY) ;    // <1>
}
----
<1> After reset, all exception priorities are at the highest level.
We make sure the set the PendSV priority to our lowest level value
so that the sync function dispatch works properly.

=== MSP432 Suspending Execution

[source,c]
----
<<msp432 static functions>>=
static void
mrtWait(void)
{
    mrtBeginCriticalSection() ;

    if (mrtEventQueueEmpty(&tocEventQueue)) {
        __DSB() ; // <1>
        __WFI() ;
    }

    mrtEndCriticalSection() ;
}
----
<1> ARM recommends a data synchronization barrier instruction before
going to sleep to insure any writes have been fully synced to memory
before going to sleep and having clocks and other things turned off.
We don't need it in this pariticular case since no write operation has
been performed.
However, we will follow the recommendation as it is only a single
instruction and we don't want some change in the future to create
a mysterious problem.

=== MSP432 Tracing

[source,c]
----
<<msp432 trace static functions>>=
static char const *
mrtTimestamp(void)
{
    return "0" ;
}
----

=== MSP432 Files

[source,c]
----
<<micca_rt_msp432.h>>=
/*
<<copyright info>>

<<version info>>
*/

#ifndef MICCA_RT_H_
#define MICCA_RT_H_

<<common header file definitions>>

#endif /* MICCA_RT_H_ */
----

[source,c]
----
<<micca_rt_msp432.c>>=
/*
<<edit warning>>
<<copyright info>>

<<version info>>
*/

/*
 * Includes
 */
#include "micca_rt.h"
#include "micca_rt_internal.h"
<<msp432 includes>>

/*
 * Constants
 */
<<mrt implementation constants>>
<<arm7m constants>>

/*
 * Data Types
 */
<<mrt implementation simple types>>
<<mrt implementation aggregate types>>

/*
 * Forward References
 */
<<mrt forward references>>

/*
 * Static Data
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static data>>
#   endif /* MRT_NO_TRACE */

<<mrt static data>>
<<msp432 static data>>

/*
 * Static Inline Functions
 */
<<mrt implementation static inlines>>

/*
 * Static Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static functions>>
<<msp432 trace static functions>>
#   endif /* MRT_NO_TRACE */

<<arm7m static functions>>
<<msp432 static functions>>
<<mrt static functions>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external functions>>
#   endif /* MRT_NO_TRACE */

<<arm7m external functions>>
<<msp432 external functions>>
<<mrt external functions>>
----

== MSP430 Specific Code

[source,c]
----
<<msp430 includes>>=
#include "msp430.h"

#ifndef MRT_TIMER_FREQUENCY
#   define MRT_TIMER_FREQUENCY     4096UL
#endif /* MRT_TIMER_FREQUENCY */
#define MRT_MAX_CLOCK_TICKS     (UINT32_MAX - 1)
#define MRT_MAX_MSEC_DELAY\
        ((MRT_MAX_CLOCK_TICKS / MRT_TIMER_FREQUENCY) * 1000UL)
----

=== MSP430 Critical Sections

[source,c]
----
<<msp430 static functions>>=
static inline void
mrtBeginCriticalSection(void)
{
    __disable_interrupt() ;
}
static inline void
mrtEndCriticalSection(void)
{
    __enable_interrupt() ;
}
----

=== MSP430 Timing Interfaces

[source,c]
----
<<msp430 static functions>>=
static inline MRT_DelayTime
mrtMsecToTicks(
    MRT_DelayTime msec)
{
    if (msec > MRT_MAX_MSEC_DELAY) {
        msec = MRT_MAX_MSEC_DELAY ;
    }
    /*
     * We must avoid overflow if the requested number of
     * msecs is large.
     */
    return msec < MRT_MAX_CLOCK_TICKS / MRT_TIMER_FREQUENCY ?
            ((msec * MRT_TIMER_FREQUENCY) + 1000UL / 2UL) / 1000UL :
            ((msec + 1000UL / 2UL) / 1000UL) * MRT_TIMER_FREQUENCY ;
}
----

[source,c]
----
<<msp430 static functions>>=
static inline MRT_DelayTime
mrtTicksToMsec(
    MRT_DelayTime ticks)
{
    return ticks < MRT_MAX_CLOCK_TICKS / 1000UL ?
        ((ticks * 1000UL) + MRT_TIMER_FREQUENCY / 2UL) / MRT_TIMER_FREQUENCY :
        ((ticks + MRT_TIMER_FREQUENCY / 2UL) / MRT_TIMER_FREQUENCY) * 1000UL ;
}
----

[source,c]
----
<<msp430 static functions>>=
static void
mrtSysTimerMask(void)
{
    TA0CCTL0 &= ~CCIE ;
}
----

[source,c]
----
<<msp430 static functions>>=
static void
mrtSysTimerUnmask(void)
{
    TA0CCTL0 &= ~CCIFG ;
    TA0CCTL0 |= CCIE ;
}
----

[source,c]
----
<<msp430 static functions>>=
static inline uint16_t
readTimer(void)
{
#   define  SUCCESSIVE_MATCHES  3

    uint16_t cmp1Reg ;
    uint16_t cmp2Reg ;
    uint8_t cnt ;

    cnt = 1 ;
    cmp1Reg = TA0R ;
    do {
        cmp2Reg = TA0R ;
        cnt = cmp1Reg == cmp2Reg ? cnt + 1 : 1 ;
        cmp1Reg = cmp2Reg ;
    } while (cnt < SUCCESSIVE_MATCHES) ;

    return cmp2Reg ;

#   undef SUCCESSIVE_MATCHES
}
----

[source,c]
----
<<msp430 static functions>>=
static void
setNextTime(
    uint16_t clockTicks)
{
    _disable_interrupts() ;

    if (clockTicks == 1) {
        clockTicks++ ;
    }
    TA0CCR0 = readTimer() + clockTicks ;
    mrtSysTimerUnmask() ;

    _enable_interrupts() ;
}
----

[source,c]
----
<<msp430 static functions>>=
static void
mrtSysTimerStart(
    MRT_DelayTime time)
{
    clockCnts = time >> 16 ;
    setNextTime(time) ;
}
----

[source,c]
----
<<msp430 static data>>=
/*
 * We keep a higher precision time indication by counting Timer A overflows.
 * This variable holds the number of Timer A overflow interrupts that have
 * occurred. When concatenated with the value of the TA0R register from
 * Timer A and treated as a 32 bit quantity, the value represented is the
 * time since the system started as a U(20,12) fixed radix point number
 * in units of seconds (this is because we are running timer A off of the
 * 32 KHz clock divided down by 8 ==> 4096 ticks / sec). For 20 integer bits of
 * seconds, the clock time value rolls over after ~1,000,000 seconds or
 * about 12.1 days.
 *
 * Use the function, "sysTimeTicks()" to obtain the time value.
 */
static uint16_t timerTicks ;
static uint16_t clockCnts ;
----

[source,c]
----
<<msp430 static functions>>=
/*
 * To get a high resolution time value we combine the in memory counter that
 * counts timer overflows with the current value of the timer register (TA0R).
 * However we must be careful here because the counter is shared with an
 * interrupt service routine. So we make this function a "monitor" function and
 * we must check that the interrupt flag is not set right after we read the
 * timer value. If it is, then the memory counter will be off by one since
 * there is a pending interrupt that has not been serviced.
 */
uint32_t
sysTimeTicks(void)
{
    _disable_interrupts() ;

    uint16_t tvalue = readTimer() ;
    /*
     * If the timer rolls over between the time we enter this function and the
     * time we get here, then the interrupt flag will be set. In that case, the
     * memory counter will be off by one (since the interrupt service routine
     * will NOT have been run as we are in a "monitor" function).  Also we can
     * assume the timer value is simply zero, reflecting the timer value when
     * the roll over occurs (as it will not take a tick's worth of time to
     * execute to here.
     *
     * If there is no roll over of the timer, then the time is simply the
     * concatenation of the memory counter value and the timer value.
     */
    bool rollover = (TA0CTL & TAIFG) != 0 ;
    _enable_interrupts() ;

    return rollover ?
        (((uint32_t)timerTicks + 1) << 16) :
        (((uint32_t)timerTicks << 16) | tvalue) ;
}
----

[source,c]
----
<<msp430 static functions>>=
static MRT_DelayTime
mrtSysTimerStop(void)
{
    MRT_DelayTime remain ;

    mrtSysTimerMask() ;
    uint16_t timer = readTimer() ;
    /*
     * Account that the timer might go off between when we
     * stop it and when we read it.
     */
    if (TA0CCTL0 & CCIFG) {
        remain = clockCnts ?
                (MRT_DelayTime)(clockCnts - 1) << 16 : 0 ;
    } else {
        remain = TA0CCR0 - timer ;
        remain += (MRT_DelayTime)clockCnts << 16 ;
    }
    return remain ;
}
----

[source,c]
----
<<msp430 static functions>>=
void
__attribute__((interrupt(TIMER0_A0_VECTOR)))
timerA0ISR(void)
{
    if (clockCnts == 0) {
        MRT_DelayTime next = mrt_TimerExpireService() ;
        if (next) {
            mrtSysTimerStart(next) ;
        }
        __low_power_mode_off_on_exit() ;
    } else {
        /*
         * Loading the compare register with the timer
         * value causes us to count an entire 16 bits worth
         * of ticks.
         */
        TA0CCR0 = TA0R ;
        --clockCnts ;
    }
}
----

[source,c]
----
<<msp430 static functions>>=
static void
mrtInitSysTimer(void)
{
    /*
     * Stop and Clear the timer.
     */
    TA0CTL = TACLR ;
    /*
     * Set up clock source to ACLK and Divide down by 8.
     */
    TA0CTL |= TASSEL_1 | ID_3 ;
    TA0CCTL0 = 0 ;
    TA0CCTL1 = 0 ;
    TA0CCTL2 = 0 ;
    /*
     * Start the timer in continuous mode. 
     * Enable the timer overflow interrupt.
     */
    TA0CTL |= MC_2 | TAIE ;
    /*
     * Zero out the upper level counter that keeps track of ticks.
     */
    timerTicks = 0 ;
}
----

=== MSP430 Async Execution Interface

[source,c]
----
<<msp430 external functions>>=
MRT_SyncParams *
mrt_SyncRequest(
    MRT_SyncFunc f)
{
    MRT_SyncParams *params = mrtSyncQueuePut(f) ;
    if (params == NULL) {
        mrtFatalError(mrtSyncOverflow) ;
    }
}
----

[source,c]
----
<<msp430 external functions>>=
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc f)
{
    return mrtSyncQueuePut(f) ;
}
----

=== MSP430 Suspending Execution

[source,c]
----
<<msp430 static functions>>=
static void
mrtWait(void)
{
    mrtBeginCriticalSection() ;
    if (mrtSyncQueueEmpty()) {
        __bis_SR_register(LPM0_bits | GIE) ;
    } else {
        mrtEndCriticalSection() ;
    }
}
----

=== MSP430 Initialization

[source,c]
----
<<msp430 external functions>>=
void
mrt_Initialize(void)
{
    mrtECBPoolInit() ;
    mrtInitSysTimer() ;
}
----

=== MSP430 Tracing

[source,c]
----
<<msp430 trace static functions>>=
static char const *
mrtTimestamp(void)
{
    return "0" ;
}
----

=== MSP430 Files

[source,c]
----
<<micca_rt_msp430.h>>=
/*
<<edit warning>>
<<copyright info>>

<<version info>>
*/

#ifndef MICCA_RT_H_
#define MICCA_RT_H_

<<common header file definitions>>

#endif /* MICCA_RT_H_ */
----

[source,c]
----
<<micca_rt_msp430.c>>=
/*
<<edit warning>>
<<copyright info>>

<<version info>>
*/

/*
 * Includes
 */
#include "micca_rt.h"
#include "micca_rt_internal.h"
<<msp430 includes>>

/*
 * Constants
 */
<<mrt implementation constants>>

/*
 * Data Types
 */
<<mrt implementation simple types>>
<<mrt implementation aggregate types>>

/*
 * Forward References
 */
<<mrt forward references>>
<<msp430 forward references>>

/*
 * Static Data
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static data>>
#   endif /* MRT_NO_TRACE */

<<mrt static data>>
<<msp430 static data>>

/*
 * Static Inline Functions
 */
<<mrt implementation static inlines>>

/*
 * Static Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static functions>>
<<msp430 trace static functions>>
#   endif /* MRT_NO_TRACE */

<<msp430 static functions>>
<<mrt static functions>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external functions>>
#   endif /* MRT_NO_TRACE */

<<msp430 external functions>>
<<mrt external functions>>
----

== Common Header File Definitions

In this section,
the arrangement of literal program chucks that are common
to all header files for the run-time is given.

[source,c]
----
<<common header file definitions>>=
/*
 * Includes
 */
<<mrt interface includes>>

/*
 * Constants
 */
<<mrt interface constants>>

/*
 * Preprocessor Defines
 */
#ifndef COUNTOF
#   define COUNTOF(a)  (sizeof(a) / sizeof(a[0]))
#endif /* COUNTOF */

/*
 * Data Types
 */
<<mrt interface simple types>>
<<mrt interface aggregate types>>

#   ifndef MRT_NO_TRACE
<<mrt interface trace aggregate types>>
#   endif /* MRT_NO_TRACE */

/*
 * External Functions
 */
<<mrt external interfaces>>
#   ifndef MRT_NO_TRACE
<<mrt trace external interfaces>>
#   endif /* MRT_NO_TRACE */
----

== Internal Header File

The run-time code uses an internal header file to separate declarations
that should not be generally exposed.
This header file, called `micca_rt_internal.h`, must be included in
the generated domain code, but contains definitions that are not
needed by bridge code.

[source,c]
----
<<mrt interface includes>>=
#include <stddef.h>
#include <stdbool.h>
#include <inttypes.h>
#include <stdarg.h>
#include <assert.h>
----

[source,c]
----
<<micca_rt_internal.h>>=
/*
<<edit warning>>
<<copyright info>>

<<version info>>
*/

#ifndef MICCA_RT_INTERNAL_H_
#define MICCA_RT_INTERNAL_H_

/*
 * Standard Includes
 */
#ifndef MRT_NO_STDIO
#   include <stdio.h>
#endif /* MRT_NO_STDIO */

#include <stdlib.h>
#include <string.h>

#if __STDC_VERSION__ >= 201112L         /* <1> */
#   include <stdalign.h>
#   include <stdnoreturn.h>
#else
#   ifndef noreturn
#       ifdef __CC_ARM
#           define noreturn __declspec(noreturn)
#       else /* __CC_ARM */
#           define noreturn
#       endif /* __CC_ARM */
#   endif /* noreturn */
#   ifndef alignas
#       define alignas(x)
#   endif /* alignas */
#endif /* __STDC_VERSION__ >= 201112L */

/*
 * Constants
 */
<<mrt internal constants>>

/*
 * Data Types
 */
<<mrt internal simple types>>
<<mrt internal aggregate types>>
#   ifndef MRT_NO_TRACE
<<mrt internal trace simple types>>
<<mrt internal trace aggregate types>>
#   endif /* MRT_NO_TRACE */

/*
 * External Functions
 */
<<mrt internal external interfaces>>

/*
 * Static Inline Functions
 */
<<mrt internal static inlines>>

#endif /* MICCA_RT_INTERNAL_H_ */
----
<1> Although we target the C11 standard syntax,
there are really only a few C11 features that we use.
So, for those stuck with a C99 compiler,
we can use the preprocessor the remove the C11 dependencies.
The most serious implication is over the `alignas` macro.
We seek to have the most liberal alignment we can obtain,
and if that is not the default by a C99 compiler, then
the declaration of event parameters and sync function parameters
could cause problems.
