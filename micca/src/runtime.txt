// vim:set syntax=asciidoc:

= Runtime Support

[partintro]
.Runtime Support
--
In the previous part of the book,
we described the domain specific language (DSL) that is used to
describe a domain to `micca`.
From that description,
code is generated and the generated code targets the run-time
environment that is explained in this part of the book.

When translating an executable model,
parts of the model can be mapped directly onto the implementation language.
For example in a `micca` translation,
class instances are referred to using a ``C'' pointer to the instance
memory.
This allows attribute access by simple indirection on the pointer,
_e.g._ for a state activity, `self->Temp = 27`, can be used to update the
`Temp` attribute of the instance.

Other aspects of mapping model execution to the implementation are not
directly supported in the implementation language.
Consider the execution of a state model.
There is no intrinsic support for state machines in the ``C'' language.
To dispatch events to state machines requires that we write additional
``C'' code to implement the execution rules of Moore state machines.
We will gather that code into ``C'' functions and the functions will require
data that must be structured in a particular way.

This part of the book is primarily concerned with showing the functions
and data structures required to map model execution rules onto the
implementation.
Taken together,
they define the details of how execution happens in a `micca` translated
domain.
We have purposely chosen a simple scheme of execution, namely,
single threaded and event driven with callbacks to handle the domain specific
computations.
This choice enables this translation scheme to be used in small,
embedded, ``bare metal'' computing technology.
We will also produce a flavor of the run-time that can execute in a POSIX
environment.
This will allow us to target POSIX,
if that is appropriate to the application,
and also to use POSIX as a simulation environment for testing an embedded
system.
This turns out to be very useful since debugging and other facilities
tend to be much richer in the POSIX world than in the bare metal embedded
world.

Once we know how the functions and data structures of the run-time code
operate,
we can show the code generation that takes the platform model data and
converts it to ``C'' code.
That is the subject of the next part of the book.
--

== Introduction

To start,
we enumerate the characteristics of the
computing technology targeted by the `micca` run-time.

* The implementation language is ``C''.
* All data is held in primary memory and there is no automatic persistent
storage provided.
* All classes and other resources are allocated fixed size memory pools
whose size is known at compile time. There is no use of dynamically allocated
memory or of any generic system heap by the run-time code.
* The address in memory of a class instance serves as an architecturally
generated identifier for the instance and we use that identifier exclusively
in the interfaces of the run-time code.
* No other constraints on the identification of class instances is provided,
particularly, no enforcement of uniqueness based on attribute values is
provided.
* The only support for asynchronous execution is that of an interrupt.
Facilities are provided to allow interrupt service code to synchronize
to the running background.
There is no notion of semaphores, condition variables or any other
mutual exclusion locking scheme other than that required to prevent
interrupts from executing during small critical sections of code.
* Background execution is single threaded.
There is no notion of _task_ or _process_ or _thread_ as those terms are
usually defined for computer operating systems.
There is no notion of processor context, context switching or process
preemption.
All execution is run-to-completion except as preempted by interrupts.
* The execution pattern is event driven with callbacks that run to completion
and perform the required computation.
Given the single threaded nature of sequencing execution,
callbacks that run for longer than the desired response latency time of the
system can be problematic.
This scheme is targeted at applications that are _reactive_ in nature,
sensing external stimulus and responding to that stimulus,
and _not_ long-running computationally intensive transformations.
The execution scheme is very similar to that used for most graphical
user interface applications.
* There is no notion of event priority.
Events are dispatched in the order they are signaledfootnote:[With the
exception that self directed events are dispatched before
non-self directed ones.
However, this is one of the prescribed execution rules of state models.].
* Events are dispatched within the context of a _thread of control_.
Threads of control have an direct corollation with transactions on the domain
data.
* Referential integrity is enforced at the end of each data transaction.
This implies that any changes in the stored data for relationships is
verified against the constraints implied by the relationship
conditionality and multiplicity.
Referential integrity is evaluated whenever there has been any change
in class instances or relationship linkage during a thread of control.
* Some of the constructs for the run-time depend upon the target processor.
We will show three implementations, namely, the ARM V7-M architecture,
the TI MSP430 architecture and the POSIX architecture.

As we have said before,
this execution scheme is _not_ intended for all applications.
The computational demands of some applications are such that the
single threaded, event driven, callback nature is simply inappropriate
and another execution scheme should be used.
However,
for a large class of applications,
this scheme works very well and has many advantages in terms of simplicity
of the implementation
and the lack of shared information between concurrent execution threads.

=== Limitation of the Run Time

Although `micca` supplies everything needed to sequence execution and
manage model data,
there are several other components of a target platform that are *not*
supplied by `micca`.
Notably:

* Exception handling is very system specific.
The details of how processor exceptions are handled must be supplied by
the project.
The run-time provides the means to synchronize between exceptions and the
background processing but nothing else.
* The run-time requires access to some type of timing resource.
The interface to the timing resource is well defined but
projects will have to supply code to manipulate the timing resource.
Typically in an embedded context, a hardware timer is used.
For a POSIX environment,
code is included to time delayed event dispatch using `SIGALRM`.
* No support is provided to obtain the current time of day.
Many embedded platforms have no timing facilities.
If time of day is important to your project,
then hardware should provide some battery backed up time of day
clock hardware or you will have to provide some timing resource
from which the time of day can be deduced.
* Access to hardware can require significant effort to implement.
Projects are strongly encouraged *not* to access hardware directly
from domain models.
Direct hardware access limits the ability of the model to be run
in a different environment for simulation and debugging.
Rather, a well defined hardware access layer should be put into place
and external operations defined by the domain models expressing
their hardware dependencies.
Then bridging code may be created to map from the external operations
of the domain to the hardware access layer.
This scheme is *not* supplied by `micca` and projects will have to
create the hardware access to provide a complete target platform.
* The `micca` run-time provides simple linear iteration techniques for
access to class instances and to navigate relationships.
These simple techniques work well in many circumstances,
but when the number of class instances is large other types of searching
will be desired.
`Micca` does not supply any techniques for hashing, binary searches or
any of the many other ways that a class instance may be located.
If these techniques are required for a particular domain,
projects will have to supply their own code to accomplish it.
Such code is not difficult to use in the `micca` environment since
you have direct access the code for the activities, but it
is not supplied.
`Micca` does guarantee the ordering of initial instances in the class storage
pool,
so often a binary search using the standard ``C'' library functions will
suffice if initial instances are defined in a sorted order.

=== Conditional Compilation

The run-time support the following ``C'' preprocessor symbols:

[IMPORTANT]
It is important the code files for the run-time and all the domains that
constitute an application be compiled with the same set of preprocessor
symbol definitions.

`NDEBUG`::
    The run-time uses the standard `assert` macro and the assertions may
    be removed by defining this symbol.
`MRT_NO_NAMES`::
    If defined, this symbol will exclude naming information about classes,
    relationships and other domain entities from being compiled in.
    For small memory systems,
    strings can consume a considerable amount of space and are usually
    only used during debugging.
`MRT_TRANSACTIONSIZE`::
    The value of this symbol sets the maximum number of relationships
    that can be modified during a data transaction.
    The default value is 64.
`MRT_EVENTPOOLSIZE`::
    The value of this symbol sets the number event control blocks which
    are used for signaling events.
    The default value is 32.
    This number represents the maximum number of signaled events that
    may be _in flight_ at the same time.
`MRT_ECB_PARAM_SIZE`::
    This value of this symbol set the maximum number of bytes that can
    be occupied by event parameters or sync function parameters.
    The default value is 32.
`MRT_SYNCQUEUESIZE`::
    The value of this symbol defines the maximum number of synchronization
    requests from the foreground processing that may be outstanding
    at the same time.
    The default value is 10.
    This symbol represent the number of interrupts that may occur during
    the execution of a state activity.
`MRT_INSTANCESETSIZE`::
    The value of this symbol is the maximum number of instance references
    that may be held in an instance reference set.
    The default value is 128.
`MRT_NO_TRACE`::
    Defining this symbol removes code from the run-time that traces
    event dispatch.
    Event dispatch tracing is important during testing and debugging but
    may be removed from the delivered system.
`MRT_INSTRUMENT`::
    Defining this symbol includes code to print the function name, file name
    and line number for all functions generated by the code generator.
    This information forms a trace of executed functions.
`MRT_INSTRUMENT_ENTRY`::
    Defining this symbol can override the code that is placed at the
    beginning of each generated function for instrumentation. By default
    when `MRT_INSTRUMENT` is defined the following code is placed at
    the entry of each generated function:
    +
......
    printf("%s: %s %d\n", __func__, __FILE__, __LINE__) ;
......
`MRT_HARNESS`::
    Defining this symbol will override the default definition of
    `MRT_INSTRUMENT_ENTRY` to cause all the instrumentation information
    to be output via the test harness.
`MRT_ARM_ARCH_7M`::
    Defining this symbol compiles in the ARM Version 7-M specific
    code for executing sync requests from the foreground.
`MRT_ARM_7M_SWO`::
    Defining this symbol removes code that sets up ARM-7M specific
    debugging hardware.

== The Main Program

In ``C'',
execution begins with the function called, `main`.
`Micca` *does not provide* this function.
Each system will have to construct a custom `main` function.
The goals of `main` are to perform any required initialization
and then to enter the event loop.
Below we show an outline of what a `main` function would do.

(((micca,Run Time Function,main)))
[source,c]
----
int
main(
    int argc,
    char *argv[])
{
    /*
     * Hardware and other low level system initialization is usually done
     * first.
     */

    /*
     * Initialize the run-time code itself.
     */
    mrt_Initialize() ;

    /*
     * Initialize domains, bridges and any other code that might require access
     * to the facilities of the run-time code. Typically, each domain in the
     * system would have an "init()" domain operation and these can be invoked
     * here. Sometimes domain interactions are such that a second round of
     * initialization is required.  Bridges between domains may also require
     * that the initialization for a domain be done before the bridge can be
     * initialized. Once mrt_Initialize() has been invoked, domains may
     * generate events and do other model level activities.  Regardless of how
     * the initialization is accomplished, it is system specific and,
     * unfortunately, only temporally cohesive.
     */

    /*
     * Entering the event loop causes the system to run.
     */
    mrt_EventLoop() ;

    /*
     * It is possible that domain activities can cause the main loop to exit.
     * Here we consider that successful. Other actions are possible and
     * especially if the event loop is exited as a result of some unrecoverable
     * system error.
     */
    return EXIT_SUCCESS ;
}
----

The only hard and fast requirements are that `mrt_Initialize` must be called
before any facilities of the run-time are used and `mrt_EventLoop` must
be invoked to cause the system to run.

(((micca,Run Time Function,mrt_Initialize)))

*****
[source,c]
----
<<mrt external interfaces>>=
extern void mrt_Initialize(void) ;
----

The `mrt_Initialize` function initializes the micca run-time.
This function should be called early in the initialization of a system
and must be invoked before using any run-time facilities such as
signaling an event.
*****

The implementation of `mrt_Initialize` is target platform specific.
So we postpone showing its code until later when we discuss how the
run-time is tailored to the supported target computing platforms.

=== Event Loop

The figure below shows a diagram of
the flow of control in the event loop.

image::main-loop.pdf[title="Micca Run Time Event Loop"]

Processing is divided between the background and foreground.
Foreground processing happens as a result of an interruptfootnote:[In the
POSIX environment, signals serve the role of an interrupt].
A queue is used to synchronize between the two execution realms.
The background processing is single threaded.
We will discuss the internal logic of processing an event later.
For now, we make these points.

* If interrupts have occurred,
we deal with their background synchronization first and completely.
The exact process to synchronize between interrupts and the background
is processor architecture dependent.
* Only one event is dispatched after synchronizing with interrupts.
Because we deal with all the interrupts before dispatching a single event,
interrupt synchronization has an effective higher priority than event dispatch.
* After dispatching one event, we check if any activity has requested
that the event loop terminate.
If so, then flow continues to the remainder of the `main` program.
* If there is no work to be done, _i.e._ both the sync queue and the event
queue are empty, then the run-time determines if there has been a
request to exit the event loop.
If so, the the event loop is terminated and control returns to the
caller of the `mrt_EventLoop` function.
* If the event loop is not exited, the run-time
waits until there is further work to be done.
Note that any further work must arise from interrupt service and its
synchronization to the background.
Waiting is platform specific, but usually, for embedded systems,
involves going into a low power mode.
For the POSIX version of the run-time, the `pselect(2)` system call is used
to suspend the process awaiting either a signal or a change in status
of a file descriptor.

*****
(((micca,Run Time Function,mrt_EventLoop)))
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_EventLoop(void) ;
----

The `mrt_EventLoop` function enters the micca run-time event loop
and dispatches event to cause the system to run.
Control remains in the event loop unless specifically requested to
exit via the `mrt_SyncToEventLoop` function.

[IMPORTANT]
The `mrt_EventLoop` function must not be called recursively, _i.e._
`mrt_EventLoop` is not to be invoked as part of an activity.
The system must remain in the event loop until properly exited.
Only after the event loop has been exited may it be re-entered.
*****

To a first approximation,
the event loop is an infinite loop.
Most applications will enter the event loop after their initialization
phase and remain there forever.

(((micca,Run Time Function,mrt_EventLoop)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_EventLoop(void)
{
    mrtExitEventLoop = false ;
    for (;;) {
        if (!mrt_ProcessOneEvent()) {
            if (mrtExitEventLoop) {
                break ;
            }
            mrtWait() ;
        }
    }
}
----

As we see,
the flow of control loops,
processing one event at a time as long as it has not been requested to exit the
loop.

Testing and other considerations mean that we may want to exit the
event loop to gain control of the program.
Exiting the event loop is controlled by a boolean variable.

(((micca,Run Time Function,mrtExitEventLoop)))
[source,c]
----
<<mrt static data>>=
static bool mrtExitEventLoop ;
----

Rather than expose the variable directly,
we provide a function to set it.
One use case for this function is in test code where the main
test application will enter the event loop and some state activity
will execute `mrt_SyncToEventLoop()` to return control back to the test
application.
There are other uses.
For example, if the system detects a catastrophic situation,
it may want to exit the event loop and allow the subsequent code to
gracefully bring down the system or force the system to reset.
The exact details are system specific,
but this provides the means to gain control of the run-time execution
for exceptional situations.

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_SyncToEventLoop() ;
----

The `mrt_SyncToEventLoop` function will cause the event loop to exit
after completing any ongoing processing.
Note the event loop is exited only if the system is about to wait,
_i.e._ we exit the event loop rather than wait for more work to come along.
The previous value of the exit status is returned.
*****

(((micca,Run Time Function,mrt_SyncToEventLoop)))
[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_SyncToEventLoop(void)
{
    bool exitControl = mrtExitEventLoop ;
    mrtExitEventLoop = true ;
    return exitControl ;
}
----

=== Process a Single Event

An external interface is also provided to process a single event.

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_ProcessOneEvent(void) ;
----

The `mrt_ProcessOneEvent` function may be invoked to process a single
event and then return to the caller.
The return value for `mrt_ProcessOneEvent` indicates if an event
was actually dispatched.
A return value of `false` indicates that the event queue is empty.

[IMPORTANT]
The function `mrt_ProcessOneEvent` is not to be invoked while in the
event loop, _i.e._ `mrt_ProcessOneEvent` is not to be invoked by
domain activities.
It is only valid to invoke this function if the program is not currently
running under the control of the event loop.
*****

This function is used by the event loop but can also be invoked on it own.
This is _not_ the recommended mechanism of running a `micca` based
application, but sometimes it is necessary.
Again,
testing is sometimes best accomplished by letting a test program
control event-by-event dispatch.
Another use case involves situations where `micca` generated domains
must be integrated with legacy code.
The legacy code will probably have its own execution loop and
we will have to dispatch `micca` events under control of the legacy
execution scheme.
This is not an ideal situation,
but when migrating an older system to a `micca` translated system
a transition period is unavoidable.
We provide the ability to micro-manage the event dispatch with the full
realization that the capablity will be abused by some projects.

(((micca,Run Time Function,mtr_ProcessOneEvent)))
[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_ProcessOneEvent(void)
{
    <<ProcessOneEvent: background sync>>

    return mrtDispatchOneEvent() ;
}
----

Note that the exact manner in which background synchronization
functions are executed is dependent upon the processor architecture.
We will discuss this later, but for now,
it is only important to remember that all requests for background
synchronization are executed before dispatching at most one event.
The code for `mrtDispatchOneEvent` is shown later when we discuss event
dispatch.

== Managing Data

Before we discuss the details of how execution is sequenced,
we will show how data is managed by the run-time.
Execution sequencing is directed at class instances and it will be
helpful to understand how instances are stored before we get to
discussing how they are operated upon.

The run-time provides functions to support the basic lifetime of
instances.
We need to be able to:

* Create instances synchronously as part of an activity.
* Create instances asynchronously as part of a event dispatch.
* Delete instances synchronously as part of an activity.
* Delete instances asynchronously when the instance enters a terminal state.

=== Instance Data [[instance-data,Instance Data]]

For every class (and assigner),
the code generator will declare a ``C'' structure whose members contain
all the attributes and other elements of the class.
The structure of each class is, in general, different.
Each class can have different attributes and relationships and this
is reflected in members of the ``C'' structure that is used for each class.
From the point of view of the run-time and the operations provided by
the run-time,
instances can be treated the same.
The view of a class instance by the run-time is shown below.

(((micca,Run Time Data,MRT_Instance)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtinstance {
    struct mrtclass const *classDesc ;
    MRT_AllocStatus alloc ;
    MRT_StateCode currentState ;
    MRT_RefCount refCount ;

#       ifndef MRT_NO_NAMES
    char const *name ;
#       endif /* MRT_NO_NAMES */
} MRT_Instance ;
----

`classDesc`::
    A pointer to a <<class-data-structure,class data structure>>.
    The class data structure contains
    information that is common to all instances of the class.
`alloc`::
    A value that shows the allocation status of the memory for the instance.
    A value of 0, means the instance memory is not in use and can allocated
    to a new instance.
    A negative value means the memory has been reserved but is not in active
    use.
    A positive value means the memory has been reserved and the instance
    is in active use.
`currentState`::
    For those classes that have a state model,
    the `currentState` member holds a small integer number indicating the
    current state in which the instance resides.
    A value of `MRT_StateCode_IG` (-1) is used to show that the class does not
    have a state model.
`refCount`::
    A counter value used to enforce referential integrity.
    At the end of a data transaction,
    this member is used as an accumulator of the number of times the
    instance is referenced in a relationship.
`name`::
    An instance may have a name that it was given during the intial instance
    population.
    For instances not defined as part of the initial instance population,
    this member is set to `NULL`.

The `micca` code generator will facilitate this view of an arbitrary instance
by inserting this structure as the first element of the ``C'' structure
that is generated for each class.
In this manner,
a pointer to an arbitrary class instance can be cast to a pointer to a
`MRT_Instance` with impunity.

(((micca,Run Time Data,MRT_AllocStatus)))
[source,c]
.Allocation Status Data Type
----
<<mrt interface simple types>>=
typedef int16_t MRT_AllocStatus ;
----

A class instance is nothing more than an element of a ``C'' array.
The size of the array, and consequently the maximum number of instances
of the class, is fixed at compile time.
The `alloc` member of the instance structure is used to keep track of the
status of the array elements as instances are created and deleted at run-time.
We will also use this member to track _event-in-flight_ errors.
We will discuss this more <<event-in-flight-error,below>>,
but we need a way to insure that events that have been signaled are not
delivered to instances that have been deleted.

(((micca,Run Time Data,MRT_StateCode)))
[source,c]
.Current State Data Type
----
<<mrt interface simple types>>=
typedef int8_t MRT_StateCode ;
----

The data type for the `currentState` member is just a small integer.
By specifying 8 bits we limit the number of states of a state model to 127.
That is an enormous number of states for a class state model.
We use negative state numbers to indicate the non-transitioning actions
that may occur when an event is dispatched.

(((micca,Run Time Constant,MRT_StateCode_IG)))
(((micca,Run Time Constant,MRT_StateCode_CH)))
[source,c]
----
<<mrt constants>>=
#define MRT_StateCode_IG    (-1)
#define MRT_StateCode_CH    (-2)
----

We will also have need for a counter used in the enforcement of
referential integrity.

(((micca,Run Time Data,MRT_RefCount)))
[source,c]
.Reference Count Data Type
----
<<mrt interface simple types>>=
typedef uint8_t MRT_RefCount ;
----

=== Class Data

All the behavior of data management and execution sequencing is
completely determined by the values contained in the data structures
supplied to the various functions of the run-time.
This is distinct from some software architecture mechanisms that
use _ad hoc_ generated code from a model compiler to implement
some capabilities.
Being completely data driven and separately compilable is a design goal of the
run-time.

Since the behavior of all instances of a given class is the same,
each class has a data structure that contains all the class invariant
information.

First, we consider class attributes.
We will have need to obtain attribute values in a generic way.
From the platform model,
we see that there are two types of attributes, independent and dependent.
We will need to encode that difference.

(((micca,Run Time Data,MRT_AttrType)))
[source,c]
.Attribute Type Data Type
----
<<mrt interface simple types>>=
typedef enum {
    mrtIndependentAttr,
    mrtDependentAttr
} MRT_AttrType ;
----

Dependent attributes are those computed by some formula.
The code generator will enclose the formula in a function that
we can invoke to obtain the attribute value.

(((micca,Run Time Data,MRT_AttrFormula)))
[source,c]
.Attribute Formula Data Type
----
<<mrt interface aggregate types>>=
typedef void MRT_AttrFormula(void *const self, void *pvalue, MRT_AttrSize vsize) ;
----

Formula functions will be invoked with a pointer to the instance,
a pointer to where the result is to be stored and the size of the
result area in bytes.

The description of an attribute is then a discriminated union.

(((micca,Run Time Data,MRT_Attribute)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtattribute {
    MRT_AttrSize size ;
    MRT_AttrType type ;
    union {
        MRT_AttrOffset offset ;
        MRT_AttrFormula *formula ;
    } access ;

#       ifndef MRT_NO_NAMES
    char const *name ;
#       endif /* MRT_NO_NAMES */
} MRT_Attribute ;
----

`size`::
    The number of bytes of memory occupied by the attribute value.
`type`::
    The type of the attribute, independent or dependent.
`access`::
    A union whose value depends upon the value of the `type` member.
    `offset`;;
        For `mrtIndependentAttr` types, the `offset` member contains
        the offset in bytes from the beginning of the instance memory
        to the attribute.
    `formula`;;
        For `mrtDependentAttr` types, the `formula` member contains
        a pointer to a function that computes the value of the attribute.
`name`::
    The name of the attribute.

To manage all the aspects of class instances,
we need information on memory allocation, event dispatch, relationships
in which the instances participate and many other pieces of information.

[[class-data-structure]]
(((micca,Run Time Data,MRT_Class)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtclass {
    struct mrtinstallocblock *iab ;
    unsigned eventCount ;
    struct mrteventdispatchblock const *edb ;
    struct mrtpolydispatchblock const *pdb ;
    unsigned relCount ;
    struct mrtrelationship const * const *classRels ;
    unsigned attrCount ;
    MRT_Attribute const *classAttrs ;
    unsigned instCount ;
    struct mrtsuperclassrole const *containment ;

#       ifndef MRT_NO_NAMES
    char const *name ;
    char const *const *eventNames ;
#       endif /* MRT_NO_NAMES */
} MRT_Class ;
----

`iab`::
    A pointer to an instance allocation block (IAB).
    The IAB is used to dynamically allocation class instances.
`eventCount`::
    The total number of transitioning and polymorphic events to which
    the class responds.
`edb`::
    A pointer to an event dispatch block (EDB).
    The EDB is used to dispatch events to a state machine.
    For classes that do not have a state model,
    this value is set to `NULL`.
`pdb`::
    A pointer to a polymorphic dispatch block (PDB).
    The PDB is used to dispatch polymorphic events.
    For classes that have no polymorphic events,
    this value is set to `NULL`.
`relCount`::
    The number of relationships in which the class participates.
`classRels`::
    A pointer an array of relationship description pointers describing
    the relationships in which the class participates.
    The array has `relCount` elements.
`attrCount`::
    The number of attributes the class contains.
`classAttrs`::
    A pointer an array of descriptions for the attributes the class contains.
    The array has `attrCount` elements.
`instCount`::
    The number of instances of the class.
    This number represents the number of elements in the array that is
    used to store the class instances.
`containment`::
    For classes that are union subclasses, this member points to a descriptor
    for the immediate superclass in the generalization.
    For other classes, the value is `NULL`.
`name`::
    A pointer to a `NUL` terminated string containing the name of the class.
`eventNames`::
    A pointer to an array of character pointers to the names of the
    class events.
    This information is used in tracing event dispatch.

When generically describing classes,
the subclasses of union based generalizations pose a special situation.
All other class instances are stored in an array.
Union subclasses are stored in the structure of their related
superclass.
The essential information for a union subclass is the class of its
ultimate superclass and the offset from the beginning of the
superclass to where the instance is located.
Note that a union subclass can be subject to repeated generalization
of another union subclass.
The ultimate superclass is the class at the top of the generalization
hierarchy.

In the next section,
the instance allocation block is described as we continue to define
how data is managed by the run-time.
Later, we describe the event dispatch block and polymorphic dispatch
block when we discuss event dispatch.

=== Instance Allocation

There are three ways to create an instance:

. Create an instance as part of an initial instance population.
. Create an instance synchronously to the execution of some activity by invoking
a function.
. Create an instance asynchronously to the execution of some activity by sending
an event.

Creating initial instances is handled during code generation using the
population data specified when the domain is configured.
The code generator arranges for initial instance values to be inserted as
initializers of the class storage array.
In this section,
we are going to discuss synchronous instance creation.
This is instance creation by a direct function invocation and when
the function returns the instance is ready and available.
Later we will discuss asynchronous instance creation which is instance
creation by signaling an event.

=== Instance Allocation Block

The instances of a class are contained in a single array variable
which serves as the memory pool for the instances.
To support managing a pool of class instances,
an *Instance Allocation Block*, or *IAB* for short,
data structure is used to keep track of the memory pool.
What we need is a data structure that describes the properties of the
class instance memory pool.

[source,c]
----
<<mrt interface aggregate types>>=
typedef void (*MRT_InstCtor)(void *const) ;
typedef void (*MRT_InstDtor)(void *const) ;
----

(((micca,Run Time Data,MRT_iab)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtinstallocblock {
    void *storageStart ;
    void *storageFinish ;
    void *storageLast ;
    MRT_AllocStatus alloc ;
    size_t instanceSize ;
    MRT_InstCtor construct ;
    MRT_InstDtor destruct ;
    unsigned linkCount ;
    MRT_AttrOffset const *linkOffsets ;
} MRT_iab ;
----

`storageStart`::
    A pointer to the beginning of the memory where the instance storage
    pool is located.
    This is the array allocated to hold the instances of a class.
`storageFinish`::
    A pointer to one element beyond the end of the instance storage pool
    for the class.
    This pointer may not be dereferenced, of course, but provides the
    boundary marker for the end of the pool.
`storageLast`::
    A pointer to the instance that was last allocated. This is used as
    the starting point for allocating the next instance.
`alloc`::
    The next value of the allocation counter to be assigned to a newly
    allocated instance. This member is used to give a unique number
    (modulo the maximum value that can be held in the data type)
    to each allocation of the array element where an instance is stored.
    The number is used to diagnose run-time analysis errors.
`instanceSize`::
    The number of bytes of memory occupied by an instance.
`construct`::
    A pointer to a constructor function. If there is no constructor defined
    for the class, then the value of this member may be set to `NULL`.
`destruct`::
    A pointer to a destructor function. If there is no destructor defined
    for the class, then the value of this member may be set to `NULL`.
`linkCount`::
    The number of link pointer containers in the instance.
`linkOffsets`::
    A pointer to an array of offsets to the link pointer containers
    in an instance. The array contains `linkCount` elements.

Instance creation and deletion also supports a very simplified notion of
construction and destruction for the instances.
This is no where near as complicated or full featured as something in C++.
Constructors and destructors take no arguments but are implicitly supplied a
pointer to the instance when invoked.

Constructors and destructors are primarily useful for when the instance has a
more complicated data structure as an attribute,
as might be the case if the attribute data type is user defined.
If you need to do complicated construction of instances,
the preferred method is to do that with an instance based operation
or as part of a state activity for an asynchronously created instance.

=== Finding Instance Memory

Before we can create an instance,
we need to find memory for it.

*****
[source,c]
----
<<mrt forward references>>=
static MRT_Instance *
mrtFindInstSlot(
    MRT_iab *iab) ;
----

`iab`::
    A pointer to the instance allocation block for the class for
    which instance memory is to be allocated.

`mrtFindInstSlot` searchs for unused instance memory in the memory pool
described by `iab`.
It returns a pointer to the allocated memory if successful and
`NULL` if no memory is available in the class pool.
*****

The allocation algorithm is a simple linear search starting at the last
location that was allocated.

(((micca,Run Time Function,mrtFindInstSlot)))
[source,c]
.Implementation
----
<<mrt static functions>>=
static MRT_Instance *
mrtFindInstSlot(
    MRT_iab *iab)
{
    assert(iab != NULL) ;
    assert(iab->storageLast < iab->storageFinish) ;
    /*
     * Search for an empty slot in the pool. Start at the next location after
     * where we last allocated an instance.
     */
    MRT_Instance *inst ;
    for (inst = mrtNextInstSlot(iab, iab->storageLast) ;
            inst->alloc != 0 && inst != iab->storageLast ;
            inst = mrtNextInstSlot(iab, inst)) {
        /* Empty Body */
    }
    /*
     * Check if we ended up on a slot that is free.
     */
    return inst->alloc == 0 ? inst : NULL ; // <1>

}
----
<1> If we wrap all the way around to where we started and still did not
find an instance storage element whose `alloc` member was zero,
then we have run out of space!
That condition is indicated by returning `NULL`.

Finding the next element in the instance storage array involves
performing the pointer arithmetic modulo the size of the array.
Since the pool is allocated in a contiguous block of memory,
we must wrap around the iterator when it passes the end of the
storage pool.
That is accomplished with the `mrtNextInstSlot()` function.

*****
[source,c]
----
<<mrt forward references>>=
static inline void *
mrtNextInstSlot(
    MRT_iab *iab,
    void *ptr) ;
----

The `mrtNextInstSlot` function returns the memory address of the next instance
after the one pointed to by `ptr` in the class instance pool described by
`iab`.
*****

(((micca,Run Time Function,mrtNextInstSlot)))
[source,c]
.Implementation
----
<<mrt static functions>>=
static inline 
void *
mrtNextInstSlot(
    MRT_iab *iab,
    void *ptr)
{
    ptr = (void *)((uintptr_t)ptr + iab->instanceSize) ; // <1>
    if (ptr >= iab->storageFinish) { // <2>
        ptr = iab->storageStart ;
    }
    return ptr ;
}
----
<1> Since the size of instance varies from class to class,
we must take over scaling the pointer arithmetic by the size of the
instance.
<2> Perform the wrap around if we cross over the boundary of
the storage array.

=== Instance Containment

For most classes,
the Instance Allocation Block describes everything we need to know
about how the instances are stored.
However,
classes that are subclasses of a union generalization do not have
their own storage pool.
Union subclass instances are stored as part of the instance structure
of the containing superclass.
The containment may be several levels deep as a union subclass can be
the superclass for another union generalization.
The `MRT_Class` data structure contains the necessary information
to deal with this.
Here we present a function that forms the basis of allowing us to
treat the union subclasses the same as other classes.

*****
[source,c]
----
<<mrt external interfaces>>=
extern MRT_iab *
mrt_GetStorageProperties(
    MRT_Class const *classDesc,
    size_t *offsetptr) ;
----

`classDesc`::
    A pointer to the class data for which storage properties are computed.
`offsetptr`::
    A pointer to a location where the instance offset is returned.
    If not `NULL`, then 
    a value is returned via the pointer that is the offset in bytes from the
    beginning of an instance to where the class storage begins.

The `mrt_GetStorageProperties` function a pointer to the IAB that describes the
storage containment for the class.
For non-union subclasses,
this is simply the IAB that describes the class storage pool.
For union subclasses,
the returned IAB will be for the ultimate superclass that contains the class
instances.
*****

(((micca,Run Time Function,mrt_GetStorageProperties)))
[source,c]
.Implementation
----
<<mrt external functions>>=
MRT_iab *
mrt_GetStorageProperties(
    MRT_Class const *classDesc,
    MRT_AttrOffset *offsetptr)
{
    assert(classDesc != NULL) ;
    MRT_iab *iab = classDesc->iab ;
    MRT_AttrOffset instanceOffset = 0 ; // <1>
    for (struct mrtsuperclassrole const *container = classDesc->containment ;
            container != NULL ;
            container = container->classDesc->containment) {// <2>
        instanceOffset += container->storageOffset ;
        iab = container->classDesc->iab ;
    }
    if (offsetptr) {// <3>
        *offsetptr = instanceOffset ;
    }

    return iab ;
}
----
<1> For non-union subclasses, the offset to the beginning of the
instance data is always zero.
Only union subclasses are stored with their superclass and will have
a non-zero offset.
<2> We iterate up the generalization hierarchy to find the ultimate
superclass that contains the class instances.
At each step of the iteration, we accumulate the relative offset of
each contained instance.
<3> The offset is returned only if requested.

We will also find occasion to want to compute the index into the
storage pool for a particular instance.
Storage pool indices make convenient identifiers of a class instance
outside of a domain.
Again we must allow that the instance may be a union subclass instance.

*****
[source,c]
----
<<mrt external interfaces>>=
extern unsigned
mrt_InstanceIndex(
    void *instance) ;
----

`instance`::
    A pointer to a class instance.

The `mrt_InstanceIndex` function returns the array index value of the instance
in its storage pool.
*****

(((micca,Run Time Function,mrt_InstanceIndex)))
[source,c]
.Implemenation
----
<<mrt external functions>>=
unsigned
mrt_InstanceIndex(
    void *instance)
{
    assert(instance != NULL) ;

    MRT_Instance *instref = instance ;
    MRT_AttrOffset offset ;
    MRT_iab *iab = mrt_GetStorageProperties(instref->classDesc, &offset) ;
    return (((uintptr_t)instance - offset) - (uintptr_t)iab->storageStart) /
            iab->instanceSize ; // <1>
}
----
<1> The `instanceSize` member of the IAB is the number of bytes occupied
by an instance.
For union subclasses, the IAB returned by `mrt_GetStorageProperties` will
be for the enclosing supertype.
So we have to make sure and subtract off the offset to the subclass
before computing the index.
For non-union subclass instances, `offset` here will be zero.
Such are the complexities when taking over the pointer arithmetic
and it is necessary to be generic.

The inverse of finding the instance index is to convert such an index
into a reference to an instance.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void *
mrt_InstanceReference(
    MRT_Class const *classDesc,
    unsigned index) ;
----

`classDesc`::
    A pointer to the class description for the reference to be computed.
`index`::
    An array index into the class storage pool.
    If `index` out of bounds, then a fatal system error occurs.

The `mrt_InstanceReference` function returns
a pointer to the instance in the class storage pool for the
class described by `classDesc` and indexed by the value of `index`.
*****

(((micca,Run Time Function,mrt_InstanceReference)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void *
mrt_InstanceReference(
    MRT_Class const *classDesc,
    unsigned index)
{
    assert(classDesc != NULL) ;
    MRT_AttrOffset offset ;
    MRT_iab *iab = mrt_GetStorageProperties(classDesc, &offset) ;
    void *instref = (void *)((uintptr_t)iab->storageStart +
            (index * iab->instanceSize) + offset) ;
    assert(instref < iab->storageFinish) ;
    if (instref >= iab->storageFinish) {
#           ifndef MRT_NO_NAMES
        mrtFatalError(mrtNoInstSlot, classDesc->name) ;
#           else
        mrtFatalError(mrtNoInstSlot, classDesc) ;
#           endif /* MRT_NO_NAMES */
    }

    return instref ;
}
----

=== Creating an Instance

The function, `mrt_CreateInstance`, is used to synchronously
create an instance of a class.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void *
mrt_CreateInstance(
    MRT_Class const *classDesc,
    MRT_StateCode initialState) ;
----

`classDesc`::
    A pointer to the class data for the instance to be created.
`initialState`::
    The state number into which the instance will be placed.
    For classes that do not have an associated state model this argument
    is ignored.
    For classes that do have an associated state model,
    the class will be created in the state given by `initialState`.
    If this argument is `MRT_StateCode_IG` or if the value given for
    `initialState` is not a valid state number for the class,
    then the instance is created in its default initial state.

`mrt_CreateInstance` allocates memory for an instance of the class
described by `classDesc` and places the instance in the state
given by `initialState`.
No state activity is run as part of synchronous instance creation.
*****

(((micca,Run Time Function,mrt_CreateInstance)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void *
mrt_CreateInstance(
    MRT_Class const *classDesc,
    MRT_StateCode initialState)
{
    assert(classDesc != NULL) ;

    /*
     * Search for an empty slot in the pool.
     */
    MRT_iab *iab = classDesc->iab ;
    MRT_Instance *inst = mrtFindInstSlot(iab) ;
    if (inst == NULL) {
#           ifndef MRT_NO_NAMES
        mrtFatalError(mrtNoInstSlot, classDesc->name) ;
#           else
        mrtFatalError(mrtNoInstSlot, classDesc) ;
#           endif /* MRT_NO_NAMES */
    }
    /*
     * Record where we left off for the next allocation attempt.
     */
    iab->storageLast = inst ;
    /*
     * Initialize the memory for the instance.
     */
    mrtInitializeInstance(inst, classDesc, initialState) ;

    return inst ;
}
----

==== Initializing Instance Memory

Once we have identified the memory for an instance,
we can make is ready to use.
This involves zeroing out the memory and then initialzing the
members of the `MRT_Instance` structure.
Any link list references must be initialized to empty and
the constructor is run if there is one.

(((micca,Run Time Function,mrtInitializeInstance)))
[source,c]
.Implementation
----
<<mrt static functions>>=
static void
mrtInitializeInstance(
    MRT_Instance *inst,
    MRT_Class const *classDesc,
    MRT_StateCode initialState)
{
    assert(inst != NULL) ;
    assert(classDesc != NULL) ;

    MRT_iab *iab = classDesc->iab ;
    assert(iab != NULL) ;
    /*
     * Start with a zeroed out memory space.
     */
    memset(inst, 0, iab->instanceSize) ; // <1>
    inst->classDesc = classDesc ;
    /*
     * Mark the slot as in use.
     */
    inst->alloc = mrtIncrAllocCounter(iab) ;
    if (classDesc->edb != NULL) {
        assert(initialState < classDesc->edb->stateCount) ;

        inst->currentState = (initialState == MRT_StateCode_IG ||
            initialState >= classDesc->edb->stateCount) ?
                classDesc->edb->initialState : initialState ; // <2>
    } else {
        inst->currentState = MRT_StateCode_IG ; // <3>
    }

    MRT_AttrOffset const *offsets = iab->linkOffsets ; // <4>
    for (unsigned count = iab->linkCount ; count != 0 ; count--, offsets++) {
        MRT_LinkRef *link = (MRT_LinkRef *)((uintptr_t) inst + *offsets) ;
        mrtLinkRefInit(link) ;
    }
    /*
     * Run the constructor if there is one.
     */
    if (iab->construct) {
        iab->construct(inst) ;
    }
    mrtMarkRelationship(classDesc->classRels, classDesc->relCount) ; // <5>
}
----
<1> Setting the memory of the instance to zero is very important.
This insures that backward referencing pointers that are used in
relationships are `NULL` and we depend upon that fact in the
relationship linkage code.
<2> We use `MRT_StateCode_IG` as a special value to indicate that
we want the instance created in its default initial state.
We also protect against illegal values of the initial state and treat
them the same.
<3> If a class does not have a state model, then we ignore the
value passed in to the function and set the current state to ignored.
This is a convenient value for such a situation.
<4> If a class contains any linked list terminus used for relationship
navigation,
they must be initialized to show that the linked list is empty.
<5> Creating an instance means it must be evaluated for referential
integrity at the end of the data transaction.
This is discussed in the next chapter.

One other important point here.
There is a counter in the IAB that is incremented each time an
instance is allocated and this value is used in the `alloc`
member of the instance.
This is another part of the strategy to detect an
_event-in-flight_ error.
This is described further below.
The effect of running this counter is that every instance gets a
different `alloc` member value (modulo the size of the counter variable)
The increment has one little catch.
The counter is signed and we use the positive and negative values
differently.
Here we want to make sure the value remains positive.

[source,c]
----
<<mrt forward references>>=
static inline MRT_AllocStatus mrtIncrAllocCounter(MRT_iab *iab) ;
----

(((micca,Run Time Function,mrtIncrAllocCounter)))
[source,c]
.Implementation
----
<<mrt static functions>>=
static inline 
MRT_AllocStatus
mrtIncrAllocCounter(
    MRT_iab *iab)
{
    /*
     * Catch any overflow
     */
    iab->alloc = (iab->alloc == INT16_MAX ? 1 : iab->alloc + 1) ;
    return iab->alloc ;
}
----

=== Deleting an Instance

The function, `mrt_DeleteInstance`, is used to synchronously
destroy an instance.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_DeleteInstance(
    void *instref) ;
----

`instref`::
    A pointer to an instance to be destroyed.

The `mrt_DeleteInstance` function deletes the instance given by `instref`.
*****

Just as there was a distinction between synchronous and asynchronous
instance creation,
there is a similar distinction for destruction.
Asynchronous destruction happens as a result of an instance entering
an _terminal_ state and that is discussed further below.
Here we are dealing with synchronous destruction of an instance.

(((micca,Run Time Function,mrt_DeleteInstance)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_DeleteInstance(
    void *instref)
{
    MRT_Instance *inst = instref ;
    assert(inst != NULL) ;
    if (inst == NULL || inst->alloc == 0) {
        return ;
    }
    MRT_Class const *classDesc = inst->classDesc ;
    assert(classDesc != NULL) ;
    MRT_iab *iab = classDesc->iab ;
    assert(iab != NULL) ;
    /*
     * Run the destructor, if there is one.
     */
    if (iab->destruct) {
        iab->destruct(inst) ;
    }
    /*
     * Unlink the instance from its relationships.
     */
    mrtDeleteLinks(classDesc->classRels, classDesc->relCount, instref) ;
    /*
     * Mark the slot as free.
     */
    inst->alloc = 0 ;
}
----

Deleting an instance is a simple matter.
If there is a destructor, it is run.
The slot is free when its `alloc` member has a value of 0.
But beware,
for designs that have complicated relationships among the classes,
instance deletion can be very complicated, requiring much care
that the interdependencies among classes are properly preserved.
That work is not done here!
It is the responsibility of the analysis model to take any actions
necessary to preserve data integrity when deleting an instance.

=== Iterating Over Class Instances

It is a common operation to iterate over the instances of a class.
This is done both in the internals of the run-time as well as by
domain activity code.
For example,
domain code has the need to search for instances meeting certain criteria
such as the value of an attribute.
For small instance populations,
that search can be implemented by iterating over the instances of the
class and making the comparison to the criteria.
Consequently,
the run-time provides a general means to iterate over the instances
of a class.

The interface to instance iteration follows familiar patterns of Start, More,
Next and Get.
We have designed the interface in this way to avoid having to
return `NULL` as a special value to indicate the end of the iteration.
First, we need a data structure to hold the information we need for
iteration.

(((micca,Run Time Data,MRT_InstIterator)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtinstanceiterator {
    void *instance ;
    MRT_iab *iab ;
} MRT_InstIterator ;
----

`instance`::
    A pointer to the memory of the next instance in the iteration.
`iab`::
    A pointer to the Instance Allocation Block for the class across which
    the iteration is to be performed.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstIteratorStart(
    MRT_InstIterator *iter,
    MRT_Class const *classDesc) ;
----

`iter`::
    A pointer to a class instance iterator that is used to record the
    state of the iteration.
`classDesc`::
    A pointer to the class description for the class across which the
    iteration will happen.

The `mrt_InstIteratorStart` function is called to initialize an
instance iterator to iterate over instances of the class described
by `classDesc`.
*****

(((micca,Run Time Function,mrt_InstIteratorStart)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstIteratorStart(
    MRT_InstIterator *iter,
    MRT_Class const *classDesc)
{
    assert(classDesc != NULL) ;
    assert(iter != NULL) ;

    MRT_AttrOffset instanceOffset ;
    MRT_iab *iab = mrt_GetStorageProperties(classDesc, &instanceOffset) ;
    assert(iab != NULL) ;

    iter->iab = iab ;
    iter->instance = (void *)((uintptr_t)iab->storageStart + instanceOffset) ;
    if (((MRT_Instance *)iter->instance)->alloc <= 0) { // <1>
        mrt_InstIteratorNext(iter) ;
    }
    return ;
}
----
<1> The iterator is designed to check if the instance is actually in
use. Here we check the first instance and if it is not being used
advance the iterator onward.

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_InstIteratorMore(
    MRT_InstIterator *iter) ;
----

`iter`::
    A pointer to a class instance iterator.

The `mrt_InstIteratorMore` function returns a boolean value indicating
if there are addition class instances which have not been visited.
It returns `true` to indicate that the iterator references a
valid class instance and `false` otherwise.
*****

(((micca,Run Time Function,mrt_InstIteratorMore)))
[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_InstIteratorMore(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance < iter->iab->storageFinish ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern void *
mrt_InstIteratorGet(
    MRT_InstIterator *iter) ;
----

`iter`::
    A pointer to a class instance iterator.

The `mrt_InstIteratorGet` function returns a pointer to the class
instance that is currently being visited in the iteration.
It is not valid to invoke `mrt_InstIteratorGet` after the
`mrt_InstIteratorMore` function has returned `false`.
This function is analogous to dereferencing a pointer.
*****

(((micca,Run Time Function,mrt_InstIteratorGet)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void *
mrt_InstIteratorGet(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance ;
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstIteratorNext(
    MRT_InstIterator *iter) ;
----

`iter`::
    A pointer to a class instance iterator.

The `mrt_InstIteratorNext` function advances the class instance iterator
to the next valid class instance.
To be a valid class instance,
the instance memory slot must be allocated and in active use.
*****

(((micca,Run Time Function,mrt_InstIteratorNext)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstIteratorNext(
    MRT_InstIterator *iter)
{
    assert(iter != NULL) ;

    MRT_iab *iab = iter->iab ;
    while (iter->instance < iab->storageFinish) { // <1>
        iter->instance = (void *)((uintptr_t)iter->instance + iab->instanceSize) ;
        if (((MRT_Instance *)iter->instance)->alloc > 0) {
            break ;
        }
    }
    return ;
}
----
<1> Advancing the instance pointer to past the storage pool for the
class indicates that we have visited all the instances.

=== Instance Sets

Another common model level operation is to accumulate a set of
class instances.
Most action languages are based on the concept of accumulating a set
of class instances based on some criteria (_e.g._ matching some value
of an attribute) and then iterating over that set to perform an operation
on each instance.
When the operation is simple,
this construct can be translated into an interation over the class
instances performing the criteria test and operation together.
This is to say that just because the action language statement implies
determining the contents of an instance set does not mean that it must
necessarily be implemented that way.
For simple situations involving searching for a criteria and then
immediately performing some operation,
it is not necessary to accumulate a set first and then iterate over the set.

However,
there are times when obtaining a set is crucial and cannot be replaced
by simple iteration over the class instances.
For those cases the run-time provides an instance set concept.
The design of the instance set had the goal of making it reasonable
to allocate the sets as automatic variables on the stack.
One could design the instance set to be a list of instance reference
pointers.
Unfortunately, such sets would occupy a significant amount of space.
We want to be able to allocate instance sets as automatic variables
to avoid the complication of managing the lifetime of the set variables.
Since our target environment is usually quite limited,
large automatic variables are to be avoided.

The chosen design uses a bit vector.
Since class instances are contained in an array,
the index of a class instance in the storage pool array can be used
as an index into a bit vector.
The bit vector design trades off more processing to build and access the
set, but makes many other set operations much easier.
For example, since instance sets do not contain duplicates,
the ability to arithmetically `OR` in a bit means we do not have to
make any explicit tests to avoid inserting duplicate instances in the set.

The data structure for a instance set is shown below.

(((micca,Run Time Data,MRT_InstSet)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef uint32_t MRT_SetWord ;
#define MRT_SETWORD_BITS    (sizeof(MRT_SetWord) * 8)

typedef struct mrtinstanceset {
    MRT_Class const *classDesc ; // <1>
    MRT_SetWord instvector[(MRT_INSTANCESETSIZE + MRT_SETWORD_BITS - 1) /
            MRT_SETWORD_BITS] ; // <2>
} MRT_InstSet ;
----
<1> An instance set records instances of one particular class.
In other words, instance sets are typed to the class of instances they hold.
<2> The bit vector is allocated in `MRT_SetWord` words and we round up to
insure we have enough space for all the instances.

Like all the other memory allocations in the run-time,
we have to fix the maximum number of instance references that can be held
in the set.
By default we set that number to 128.

[source,c]
----
<<mrt constants>>=
#ifndef MRT_INSTANCESETSIZE
#   define MRT_INSTANCESETSIZE 128
#endif /* MRT_INSTANCESETSIZE */
----

A function is provided to properly initalize an instance set variable.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstSetInitialize(
    MRT_InstSet *set,
    MRT_Class const *classDesc) ;
----

`set`::
    A pointer to an instance set.
`classDesc`::
    A pointer to a class descriptor. The instance set will contain only
    instances of this class.

The `mrt_InstSetInitialize` function initialized the instance set
data structure pointed to by `set` to prepare it to accept instances
of the class described by `classDesc`.
*****

(((micca,Run Time Function,mrt_InstSetInitialize)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstSetInitialize(
    MRT_InstSet *set,
    MRT_Class const *classDesc)
{
    assert(classDesc != NULL) ;
    set->classDesc = classDesc ;
    memset(set->instvector, 0, sizeof(set->instvector)) ;
}
----

The primary operation on instance sets is to add an instance.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstSetAddInstance(
    MRT_InstSet *set,
    void *instance) ;
----

`set`::
    A pointer to an instance set.
`instance`::
    A pointer to a class instance to be inserted into the set.

The `mrt_InstSetAddInstance` function inserts `instance` into the
instance set pointed to by `set`.
Attempts to add an instance already in the set are silently ignored.
Attempts to add an instance that is not of the same class for which
the set was initialized is also silently ignored.
*****

(((micca,Run Time Function,mrt_InstSetAddInstance)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstSetAddInstance(
    MRT_InstSet *set,
    void *instance)
{
    MRT_Instance *instref = instance ;

    assert(instref != NULL) ;
    assert(instref->classDesc = set->classDesc) ;
    if (instref->classDesc != set->classDesc) { // <1>
        return ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCESETSIZE) ;
    set->instvector[instid / MRT_SETWORD_BITS] |=
            (1 << (instid % MRT_SETWORD_BITS)) ; // <2>
}
----
<1> Make sure we do not add instances of the wrong class.
Instance indices are only unique within a given class.
<2> This bit twiddling selects the correct bit in the correct word
of the bit vector.
The correct word is given by the quotient of the index and the
number of bits in a set vector word.
The correct bit offset within a word is given by the modulus.
We are using divide and modulus operations with the full expectation
that the compiler will recognize, at some level of optimization,
that `MRT_SETWORD_BITS` is a power of two and transform the divide and modulus
into bitwise operations.

We also need a means to remove an instance from the set.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstSetRemoveInstance(
    MRT_InstSet *set,
    void *instance) ;
----

`set`::
    A pointer to an instance set.
`instance`::
    A pointer to a class instance to be inserted into the set.

The `mrt_InstSetRemoveInstance` function removes `instance` from the
instance set pointed to by `set`.
Attempts to remove an instance that is not in the set are silently ignored.
*****

(((micca,Run Time Function,mrt_InstSetRemoveInstance)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstSetRemoveInstance(
    MRT_InstSet *set,
    void *instance)
{
    MRT_Instance *instref = instance ;

    assert(instref != NULL) ;
    assert(instref->classDesc = set->classDesc) ;
    if (instref->classDesc != set->classDesc) {
        return ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCESETSIZE) ;
    set->instvector[instid / MRT_SETWORD_BITS] &=
            ~(1 << (instid % MRT_SETWORD_BITS)) ; // <1>
}
----
<1> More bit twiddling. The bitwise AND of the one's complement of a mask
clears in the result any bit that was set in the mask.

We also provide a test for membership in an instance set.

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_InstSetMember(
    MRT_InstSet *set,
    void *instance) ;
----

`set`::
    A pointer to an instance set.
`instance`::
    A pointer to a class instance to be tested for set membership.

The `mrt_InstSetMember` function determines if `instance` is a
member of the instance set pointed to by `set`.
The instance must be of the same class as that associated with `set`.
The function returns `true` is `instance` is in the set and
`false` otherwise.
*****

(((micca,Run Time Function,mrt_InstSetMember)))
[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_InstSetMember(
    MRT_InstSet *set,
    void *instance)
{
    MRT_Instance *instref = instance ;

    assert(instref != NULL) ;
    assert(instref->classDesc = set->classDesc) ;

    if (instref->classDesc != set->classDesc) {
        return false ;
    }
    unsigned instid = mrt_InstanceIndex(instance) ;
    assert(instid < MRT_INSTANCESETSIZE) ;
    MRT_SetWord w = set->instvector[instid / MRT_SETWORD_BITS] ;
    MRT_SetWord mask = (1 << (instid % MRT_SETWORD_BITS)) ;

    return (w & mask) != 0 ;
}
----

We also supply set operations, starting with determining if the
instance set is empty.

*****
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_InstSetEmpty(
    MRT_InstSet *set) ;
----

`set`::
    A pointer to an instance set.

The `mrt_InstSetEmpty` returns `true` if the instance set pointed to by
`set` contains no elements and `false` otherwise.
*****

(((micca,Run Time Function,mrt_InstSetEmpty)))
[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_InstSetEmpty(
    MRT_InstSet *set)
{
    assert(set != NULL) ;
    MRT_SetWord *pvect = set->instvector ;
    while (pvect < set->instvector + COUNTOF(set->instvector)) {
        if (*pvect++ != 0) {
            return false ;
        }
    }

    return true ;
}
----

A function to determine the number of members of the instance set is
provided

*****
[source,c]
----
<<mrt external interfaces>>=
extern unsigned
mrt_InstSetCardinality(
    MRT_InstSet *set) ;
----

`set`::
    A pointer to an instance set.

The `mrt_InstSetCardinality` returns `true` if the instance set pointed to by
`set` contains no elements and `false` otherwise.
*****

(((micca,Run Time Function,mrt_InstSetCardinality)))
[source,c]
.Implementation
----
<<mrt external functions>>=
unsigned
mrt_InstSetCardinality(
    MRT_InstSet *set)
{
    assert(set != NULL) ;
    unsigned card = 0 ;
    for (MRT_SetWord *pvect = set->instvector ;
            pvect < set->instvector + COUNTOF(set->instvector) ; pvect++) {
        MRT_SetWord w = *pvect ;
        MRT_SetWord mask = 1 ;
        for (unsigned bit = MRT_SETWORD_BITS ; w != 0 && bit != 0 ; bit--) {
            if ((w & mask) != 0) {
                card++ ;
                w &= ~mask ; // <1>
            }
            mask <<= 1 ;
        }
    }

    return card ;
}
----
<1> Once we count the bit, we clear it. This allows us to short circuit
the loop if no other bits in the word are set.

A test for set equality is also supplied.

******
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_InstSetEqual(
    MRT_InstSet *set1,
    MRT_InstSet *set2) ;
----

`set1`::
    A pointer to an instance set.
`set2`::
    A pointer to an instance set.

The `mrt_InstSetEqual` returns true if instance set `set1` is equal
to instance set `set2` and false otherwise.
If `set1` and `set2` refer to different instance set, then
false is returned.
******

(((micca,Run Time Function,mrt_InstSetEqual)))
[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_InstSetEqual(
    MRT_InstSet *set1,
    MRT_InstSet *set2)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;

    if (set1->classDesc != set2->classDesc) {
        return false ;
    }
    MRT_SetWord *src1 = set1->instvector ;
    MRT_SetWord *src2 = set2->instvector ;
    while (src1 < set1->instvector + COUNTOF(set1->instvector)) {
        if (*src1++ != *src2++) {
            return false ;
        }
    }

    return true ;
}
----

Basic set operations are also provided.
We start with the set union operation.

******
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstSetUnion(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result) ;
----

`set1`::
    A pointer to an instance set.
`set2`::
    A pointer to an instance set.
`result`::
    A pointer to an instance set where the result is placed.

The `mrt_InstSetUnion` function computes the set union of
`set1` and `set2` storing the result in the set pointed to by `result`.
If `set1` and `set2` do not refer to sets of the same class,
then the result set is the same set as `set1`.
******

(((micca,Run Time Function,mrt_InstSetUnion)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstSetUnion(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ | *src2++ ;
        }
    } else {
        memcpy(result->instvector, set1->instvector, sizeof(result->instvector)) ;
    }
}
----

******
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstSetIntersect(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result) ;
----

`set1`::
    A pointer to an instance set.
`set2`::
    A pointer to an instance set.
`result`::
    A pointer to an instance set where the result is placed.

The `mrt_InstSetIntersect` function computes the set intersection of
`set1` and `set2` storing the result in the set pointed to by `result`.
If `set1` and `set2` do not refer to sets of the same class,
then the returned set is the empty set of the same class as `set1`.
******

(((micca,Run Time Function,mrt_InstSetIntersect)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstSetIntersect(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ & *src2++ ;
        }
    } else {
        memset(result->instvector, 0, sizeof(result->instvector)) ;
    }
}
----

******
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstSetMinus(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result) ;
----

`set1`::
    A pointer to an instance set.
`set2`::
    A pointer to an instance set.
`result`::
    A pointer to an instance set where the result is placed.

The `mrt_InstSetMinus` function computes the set difference
of `set1` minus `set2` (order is significant in this case) storing
the result in the set pointed to by `result`.
If `set1` and `set2` do not refer to sets of the same class,
then the result set is the same as `set1`.
******

(((micca,Run Time Function,mrt_InstSetMinus)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstSetMinus(
    MRT_InstSet *set1,
    MRT_InstSet *set2,
    MRT_InstSet *result)
{
    assert(set1 != NULL) ;
    assert(set1->classDesc != NULL) ;
    assert(set2 != NULL) ;
    assert(set2->classDesc != NULL) ;
    assert(result != NULL) ;
    assert(set1->classDesc == set2->classDesc) ;

    result->classDesc = set1->classDesc ;
    if (set1->classDesc == set2->classDesc) {
        MRT_SetWord *dst = result->instvector ;
        MRT_SetWord *src1 = set1->instvector ;
        MRT_SetWord *src2 = set2->instvector ;
        while (dst < result->instvector + COUNTOF(result->instvector)) {
            *dst++ = *src1++ & ~*src2++ ;
        }
    } else {
        memcpy(result->instvector, set1->instvector, sizeof(result->instvector)) ;
    }
}
----

=== Iterating Over Instance Sets

Once we have computed an instance set,
we need some way to iterate over the resulting set.
Since we have chosen a bit vector representation of the set,
the iteration code is slightly more complicated as we must keep track
of which word and bit offset we are currently referring to.
Iterating over instance sets has one additional complication.
It is possible that a class instance referenced in an instance set
has been deleted in the time between when the instance set was accumulated
and the time when the iteration across the set occurs.
So,
iterating over instance set must also guard against an instance that,
although it may be a member of the set, has been deleted between the
time the set was constructed and the time that the iteration occurs.

First, we start with the iterator data structure.
This holds the state information we need to determine our place in the
set.

(((micca,Run Time Data,MRT_InstSetIterator)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtinstsetiterator {
    MRT_InstSet *set ;
    void *instance ;
    MRT_SetWord *vectorloc ;
    unsigned bitoffset ;
} MRT_InstSetIterator ;
----

`set`::
    A pointer to the instance set across which the iteration will occur.
`instance`::
    A pointer to the current instance of the iteration.
`vectorloc`::
    A pointer to the word within the instance set where the current instance
    is located.
`bitoffset`::
    The bit offset into the word pointed to by `vectorloc` that represents
    the current instance of the iteration.

The operations on the iteration follow our usual pattern of
Begin, More, Next and Get.

******
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstSetIterBegin(
    MRT_InstSet *set,
    MRT_InstSetIterator *iter) ;
----

`set`::
    A pointer to an instance set across which the iteration will occur.
`iter`::
    A pointer to an instance set iterator which will hold the state of the
    iteration.

The `mrt_InstSetIterBegin` initializes the set iterator pointed to
by `iter` in order to iterate across the instance set pointed to by `set`.
This function must be called first to prepare an iteration across an
instance set.
******

(((micca,Run Time Function,mrt_InstSetIterBegin)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstSetIterBegin(
    MRT_InstSet *set,
    MRT_InstSetIterator *iter)
{
    assert(set != NULL) ;
    assert(iter != NULL) ;

    iter->set = set ;
    iter->vectorloc = set->instvector ;
    iter->bitoffset = 0 ;
    if ((*iter->vectorloc & 1) == 0) { // <1>
        mrt_InstSetIterNext(iter) ;
    } else {
        iter->instance = mrt_InstanceReference(iter->set->classDesc, 0) ;
        if (((MRT_Instance *)iter->instance)->alloc <= 0) { // <2>
            mrt_InstSetIterNext(iter) ;
        }
    }
}
----
<1> Check if the first instance belongs to the set. If not, we want to
advance the iterator until we have a valid set member.
<2> Check if the set instance is still actively being used. If not,
we want to advance the iterator to one that is.

******
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_InstSetIterMore(
    MRT_InstSetIterator *iter) ;
----

`iter`::
    A pointer to an instance set iterator.

The `mrt_InstSetIterMore` function returns `true` if there are
more instances to visit in the instance set referenced by `iter` and
`false` otherwise.
******

(((micca,Run Time Function,mrt_InstSetIterMore)))
[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_InstSetIterMore(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    return iter->instance != NULL ;
}
----

******
[source,c]
----
<<mrt external interfaces>>=
extern void *
mrt_InstSetIterGet(
    MRT_InstSetIterator *iter) ;
----

`iter`::
    A pointer to an instance set iterator.

The `mrt_InstSetIterGet` function obtains the current instance from the
instance set referenced by `iter`.
It is not valid to invoke this function after `mrt_InstSetIterMore`
returns `false`.
******

(((micca,Run Time Function,mrt_InstSetIterGet)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void *
mrt_InstSetIterGet(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    assert(iter->instance != NULL) ;
    return iter->instance ;
}
----

******
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_InstSetIterNext(
    MRT_InstSetIterator *iter) ;
----

`iter`::
    A pointer to an instance set iterator.

The `mrt_InstSetIterNext` function advances the set iterator pointed to by
`iter` to the next element of the set.
******

Advancing the iterator is a more complicated operation.
We must account for the word boundaries in the bit vector as well as
the number of bits in each of the vector words.
Finally, we must also make sure the next element of the set is still
a valid, allocated instance of the class.

(((micca,Run Time Function,mrt_InstSetIterNext)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_InstSetIterNext(
    MRT_InstSetIterator *iter)
{
    assert(iter != NULL) ;
    
    iter->bitoffset++ ; //<1>
    if (iter->bitoffset >= MRT_SETWORD_BITS) {
        iter->vectorloc++ ;
        iter->bitoffset = 0 ;
    }
    while (iter->vectorloc <
            iter->set->instvector + COUNTOF(iter->set->instvector)) {
        if (*iter->vectorloc != 0) { // <2>
            MRT_SetWord mask = 1 << iter->bitoffset ;
            for ( ; iter->bitoffset < MRT_SETWORD_BITS ; iter->bitoffset++) {
                if ((*iter->vectorloc & mask) != 0) { // <3>
                    unsigned instindex =
                        (iter->vectorloc - iter->set->instvector) *
                        MRT_SETWORD_BITS + iter->bitoffset ; // <4>
                    MRT_Instance *instref = mrt_InstanceReference(
                        iter->set->classDesc, instindex) ;
                    if (instref->alloc > 0) { // <5>
                        iter->instance = instref ;
                        return ;
                    }
                }
                mask <<= 1 ;
            }
        }
        iter->vectorloc++ ; // <6>
        iter->bitoffset = 0 ;
    }

    iter->instance = NULL ;
}
----
<1> Advance the iterator by one bit in the bit vector,
accounting for running off the end of the vector word.
<2> A simple test determines if we can skip the entire word of bits.
<3> Check if we have found a set bit in the bit vector.
This indicates that the corresponding instance is a member of the set.
<4> Compute the index of the instance in bit vector.
This is the same to the index of the instance in the storage array.
<5> Verify that the instance was not deleted between the time the
set was build and the time the iteration across the set happens.
<6> Advance to the next word of the bit vector.

== Managing Referential Integrity

When the target translation platform is based on a Relational Database
Management System (RDMS) or some other data architecture that
supports the relational model of data (_e.g._ `rosea` or TclRAL),
referential integrity checking comes with the underlying data management
facilities.
Such data management facilities constrain the values of data and
move much of the data integrity validation away from the application code.
Such is the motivation to use these facilities since they replace
application code with declarative specifications of validity.

When targeting static-typed languages such as ``C'',
translation platforms frequently do not offer any help in insuring
referential integrity of the data as the system runs.
Sometimes this limitation is understandable.
It takes more code and data space to deal with referential integrity.
For applications that do little dynamic instance creation or relationship
changes,
the risk that some code path results in a violation of
referential integrity is much less.
Nonetheless,
execution platforms that do not provide any referential integrity checks
impose a significant burden on the programmer and result in
systems that are potentially less reliable.

In `micca`,
we will support detection of referential integrity violations.
As we will see,
there is considerable complexity in achieving this goal.
To be clear,
this is what `micca` supports.

* Integrity constraints implied by the associations and generalizations
supplied in the configuration DSL will be checked at run-time.
* Violations of referential integrity will result in a fatal system error.
There is no support for rolling back data values to a known good state
or ignoring the error and proceeding anyway.
* Integrity constraints are checked at the end of transactions on the
data model.
The duration of the transaction is not under direct program control,
but there is an ongoing
transaction when a thread of control is executing.
A thread of control is defined to be the duration of the dispatch
of the set of events initiated by an event signaled from outside of a
state activity or by the delivery of a delayed event.
We discuss the thread of control concept in more detail below
when we deal with managing execution.

Because of our design choice to use the address of a class instance as
an identifier,
to manage referential integrity we need:

* Functions to create, delete and update reference pointers that implement
relationships.
* Data structures and values that encode the specifications of the
relationships from the platform model.
* Run-time code that, using the relationship specifications, evaluates
whether referential integrity was maintained.

In keeping with our goal that the run-time be completely data driven,
the code generator will supply the necessary information about all the
associations and generalizations in the domain.
This will allow us to manipulate the pointer values used in the relationships
and to check that the result does not violate any of the
multiplicity and conditionality constraints specified for the
relationship.

We will show how this is accomplished by:

. Showing the data structures used to describe relationships.
. Explaining how transactions work and how referential integrity is checked.
. Giving code to relate and unrelate instances in a relationship that
operates with the integrity check.

=== Describing Relationships

In this section we present the data structures that are supplied
by the `micca` code generator to describe the properties of a relationship.
You can think of these data structures as an implementation version
of the various classes in the platform model that deal with
class relationships.
The code generator takes data from the platform model population that
was created during domain configuration and generates
initialized ``C'' variables of the types described below.

From the <<relationship-subsystem,platform model>>,
we know that there are four different types of relationships.

(((micca,Run Time Data,MRT_RelType)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef enum {
    mrtSimpleAssoc,
    mrtClassAssoc,
    mrtRefGeneralization,
    mrtUnionGeneralization
} MRT_RelType ;
----

The combination of the conditionality and multiplicity of a relationship
can be encoded in four values.

(((micca,Run Time Data,MRT_Cardinality)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef enum {
    mrtAtMostOne = 0,
    mrtExactlyOne,
    mrtZeroOrMore,
    mrtOneOrMore
} MRT_Cardinality ;
----

There are also three different ways that pointer references are stored.

(((micca,Run Time Data,MRT_RefStorageType)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef enum {
    mrtSingular,
    mrtArray,
    mrtLinkedList
} MRT_RefStorageType ;
----

For singular references,
a single pointer member is allocated in the class structure.

For array reference storage,
the class structure member is a counted array of the type shown below:

(((micca,Run Time Data,MRT_ArrayRef)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtarrayref {
    MRT_Instance * const *links ;
    unsigned count ;
} MRT_ArrayRef ;
----

For linked list reference storage,
the referring class has a set of link pointers that serve as the
terminus for the linked list.
In addition,
the referenced class has a set of link pointers that enable it to
be linked into the list of instances headed by the referring class.

(((micca,Run Time Data,MRT_LinkRef)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtlinkref {
    struct mrtlinkref *next ;
    struct mrtlinkref *prev ;
} MRT_LinkRef ;
----

==== Association Participants

To characterize the role a participant class in an association plays,
the following data is needed.

[source,c]
----
<<mrt interface aggregate types>>=
struct mrtassociationrole {
    MRT_Class const *classDesc ;
    MRT_Cardinality cardinality ;
    MRT_RefStorageType storageType ;
    MRT_AttrOffset storageOffset ;
    MRT_AttrOffset linkOffset ;
} ;
----

`classDesc`::
    A pointer to the class data for the participant.
`cardinality`::
    The encoding of the conditionality and multiplicity of the relationship.
    This encoding is from point of view of how many references to the
    participant that are made by the other participant in the relationship.
`storageType`::
    An encoding of the structure of how the reference pointers are stored.
`storageOffset`::
    The offset in bytes from the beginning of an instance to where the
    reference pointers for the relationship are stored.
`linkOffset`::
    For participants whose value of `storageType` is `mrtLinkedList`,
    this member gives the number of bytes from the beginning of the
    target participant instance where the linked list pointers are stored.
    For other values of `storageType` the value is ignored.

==== Simple Associations

Simple associations are made up of a source and target.

[source,c]
----
<<mrt interface aggregate types>>=
struct mrtsimpleassociation {
    struct mrtassociationrole source ;
    struct mrtassociationrole target ;
} ;
----

==== Class Based Associations

For class based associations,
there is another role played by the associator class.
Associator classes always have two singular references to the
participant classes.

[source,c]
----
<<mrt interface aggregate types>>=
struct mrtassociatorrole {
    MRT_Class const *classDesc ;
    MRT_AttrOffset forwardOffset ;
    MRT_AttrOffset backwardOffset ;
} ;
----

`classDesc`::
    A pointer to the class data for the participant.
`forwardOffset`::
    The offset in bytes from the begining of an instance of the
    associator class to the forward reference pointer.
    The forward reference pointer refers to a class instance that
    serves as the target of the association.
`backwardOffset`::
    The offset in bytes from the begining of an instance of the
    associator class to the backward reference pointer.
    The backward reference pointer refers to a class instance that
    serves as the source of the association.

A class based association has descriptive information on all three
class roles.

[source,c]
----
<<mrt interface aggregate types>>=
struct mrtclassassociation {
    struct mrtassociationrole source ;
    struct mrtassociationrole target ;
    struct mrtassociatorrole associator ;
} ;
----

==== Reference Generalizations

For generalization relationships implemented by pointer references,
the superclass implements its reference to a subclass by holding a
simple pointer to the subclass instance.
It is possible for the superclass to determine the type of the
related subclass by simply following the reference to the subclass
and then examining the `classDesc` member of the instance.
data structure.

[source,c]
----
<<mrt interface aggregate types>>=
struct mrtsuperclassrole {
    MRT_Class const *classDesc ;
    MRT_AttrOffset storageOffset ;
} ;
----

`classDesc`::
    A pointer to the class data for the participant.
`storageOffset`::
    The offset in bytes from the beginning of a reference superclass
    instance to where the reference to its related subclass is stored.
    The structure member found at `storageOffset` from the beginning of
    the instance is of type `MRT_Instance`.

The information needed to describe the role of the subclass in a
reference generalization is:

[source,c]
----
<<mrt interface aggregate types>>=
struct mrtrefsubclassrole {
    MRT_Class const *classDesc ;
    MRT_AttrOffset storageOffset ;
} ;
----

`classDesc`::
    A pointer to the class data for the participant.
`storageOffset`::
    The offset in bytes from the beginning of a reference subclass
    instance to where the reference to its related superclass is stored.
    The structure member found at `storageOffset` from the beginning of
    the instance is a pointer to the superclass instance.

A reference generalization relationship can be described by its
superclass role information and the set of subclass roles for the
subclasses that participate in the generalization.
We store the subclass role set as a count and pointer to a corresponding
array.

[source,c]
----
<<mrt interface aggregate types>>=
struct mrtrefgeneralization {
    struct mrtsuperclassrole superclass ;
    unsigned subclassCount ;
    struct mrtrefsubclassrole const *subclasses ;
} ;
----

==== Union Generalizations

A union generalization results in subclass instances being held as a union in
the superclass instance structure.
From the superclass perspective,
the information needed to describe where the subclass is stored is
the same as for a reference supertype.
The only difference is that `storageOffset` is an offset to the
union holding the subclass rather than a reference pointer to a subclass.

Subclass instances held in union generalizations do not have a
pointer back to their related superclasses.
The related superclass can be determined by pointer arithmetic (_i.e._
subtracting the superclass `storageOffset` from the subclass instance pointer).
So the role information for a union subclass is nothing more than
a pointer to its class descriptor

Similar to the reference generalization,
the union generalization information consists of that for the
superclass an a set of subclass role information values.

[source,c]
----
<<mrt interface aggregate types>>=
struct mrtuniongeneralization {
    struct mrtsuperclassrole superclass ;
    unsigned subclassCount ;
    MRT_Class const * const *subclasses ;
} ;
----

==== Relationship Properties

Finally,
the relationship data is held as a discriminated union.
There is a type field and a union of four structures for the
specific information required to describe each type of relationship.

(((micca,Run Time Data,MRT_Relationship)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtrelationship {
    MRT_RelType relType ;
    union {
        struct mrtsimpleassociation simpleAssociation ;
        struct mrtclassassociation classAssociation ;
        struct mrtrefgeneralization refGeneralization ;
        struct mrtuniongeneralization unionGeneralization ;
    } relInfo ;

#       ifndef MRT_NO_NAMES
    char const *name ;
#       endif /* MRT_NO_NAMES */
} MRT_Relationship ;
----

`relType`::
    A value to indicate the type of the relationship.
`relInfo`::
    A union of the various types of relationship information structures
    that describes the details of the relationship.
    The union must be interpreted according to the value of the `relType`
    member.
`name`::
    The name of the relationship.

=== Data Transactions

To check referential integrity,
it is necessary to introduce the concept of a transaction on the
domain data model.
The transaction concept is necessary because we must be able to defer
the integrity check until such time as the domain activities can insure
that the integrity constraints are met.
For example,
consider two classes in a one-to-one unconditional relationship.
If an instance of one class is created we do not want to check referential
integrity until the code has had an opportunity to create a corresponding
instance of the associated class.

The precise rules of data integrity are that each state activity must
leave the domain data in a consistent state or signal one or more events
that, when dispatched, will ultimately bring the domain data into a
consistent state.
The later phrase of this rule implies that there is a _thread of control_
which determines the boundary of when data consistency is checked.
We will describe how threads of control work later.
For now,
we are concerned with data transactions as a means of deciding when
data integrity is to be verified.

Each time a relationship is manipulated, by:

.. creating instances that participate in a relationship
.. deleting instances that participate in a relationship
.. updating references between participating instances
.. reclassifying subclass instances in a generalization

the relationship pointer references must be verified.
As described below,
the run-time provides functions to perform the relationship pointer
operations.
During a transaction,
we want to save a reference to the relationship information
for each relationship that is manipulated.
We save the affected relationships in the following structure.

[source,c]
----
<<mrt implementation aggregate types>>=
struct mrtTransaction {
    unsigned count ;
    MRT_Relationship const *relationships[MRT_TRANSACTIONSIZE] ;
} ;
----

Like all run-time resources,
the memory allocated to them is fixed at compile time.

[source,c]
----
<<mrt constants>>=
#ifndef MRT_TRANSACTIONSIZE
#   define MRT_TRANSACTIONSIZE 64
#endif /* MRT_TRANSACTIONSIZE */
----

We use a static variable to hold the transaction relationships.

[source,c]
----
<<mrt static data>>=
static struct mrtTransaction mrtTransaction ;
----

During a transaction,
run-time functions that either modify the relationship pointer storage
or change the number of active instances invoke
`mrtMarkRelationship` to save away the relationships that will need to
be checked at the end of the transaction.
This prevents us from having to check every relationship at the end
of every transaction.

The only complication in the marking algorithm is that we wish to
maintain the marked relationship descriptions as a set with no duplicates.
Modifying instances of relationships multiple times during the
transaction does not mean we need to evaluate the referential integrity
more than once.
We wish to save that computation and consequently will search the
marked relationships to eliminate any duplicate mark.

[source,c]
----
<<mrt forward references>>=
static void
mrtMarkRelationship(
    MRT_Relationship const *const *rel,
    unsigned relCount) ;
----

(((micca,Run Time Function,mrtMarkRelationship)))
[source,c]
.Implementation
----
<<mrt static functions>>=
static void
mrtMarkRelationship(
    MRT_Relationship const * const *rel,
    unsigned relCount)
{
    for ( ; relCount != 0 ; --relCount, ++rel) {
        bool found = false ;
        MRT_Relationship const **marked = mrtTransaction.relationships ;
        for (unsigned markedCount = mrtTransaction.count ; markedCount != 0 ;
                --markedCount, ++marked) { // <1>
            if (*marked == *rel) {
                found = true ;
                break ;
            }
        }

        if (!found) {
            if (mrtTransaction.count >= COUNTOF(mrtTransaction.relationships)) {
                mrtFatalError(mrtTransOverflow) ; // <2>
            }
            mrtTransaction.relationships[mrtTransaction.count++] = *rel ;
        }
    }
}
----
<1> First we iterate over the set of relationship description pointers
already marked to see if we can find a match to the one we are trying
to insert.
<2> Since we are about to insert a new relationship description,
we have to check for overflow.
As usual, exceeding resource limits is a fatal error.

At the end of a transaction,
we iterate across all the relationship descriptions that were
saved during the transaction and check the referential integrity
of the stored pointers.

(((micca,Run Time Function,mrtEndTransaction)))
[source,c]
----
<<mrt static functions>>=
void
mrtEndTransaction(void)
{
    MRT_Relationship const **rships = mrtTransaction.relationships ;
    for (unsigned count = 0 ; count < mrtTransaction.count ; count++, ++rships) {
        if (!mrtCheckRelationship(*rships)) {
            mrtTransaction.count -= count ;
            memmove(mrtTransaction.relationships, rships,
                mrtTransaction.count * sizeof(*rships)) ; // <1>

#               ifndef MRT_NO_NAMES
            mrtFatalError(mrtRefIntegrity, (*rships)->name) ;
#               else
            mrtFatalError(mrtRefIntegrity, *rships) ;
#               endif /* MRT_NO_NAMES */
        }
    }
    mrtTransaction.count = 0 ;
}
----
<1> We "shuffle up" the contents of the transaction relationships array
before giving up with a fatal error.
The reason for this is that it is possible to install a fatal error handler
that long jumps out of the event loop.
We don't want to remove the relationship that failed from the transaction list,
but all those that have passed the integrity check need to be discarded.
It is possible for a fatal error that has long jumped out of the event
loop to repair the damage and want to continue on.
This is certainly the case when we are testing the run-time code itself.
Test cases know what problem they have created and can correct it
so that subsequenct tests can proceed along.
However, the failed relationships will still be checked at the next
end of transaction time.
So we insure that any recovery of the integrity check happened correctly.

==== Verifying Referential Integrity

At the end of a transaction on the data model,
`mrtEndTransaction` iterates across the set of saved relationship
descriptors and checks the relationship to insure the data model
is in a consistent state.
The design approach is to use the `refCount` member of each instance
as a place to store how many times the instance is referred to by
the other participant in the relationship.
Knowing the cardinality of the relationship,
we can evaluate the `refCount` values to determine if referential integrity has
been maintained.

The overall steps are:

. Zero out the `refCount` member of all instances of both participating
classes.
. Using the relationship description information,
find the reference pointers in the class instance that refer to the
other participating class instance and increment the `refCount` member in
the other participating instance if its pointer is found.
This is done for both participants in the relationship.
. Evaluate the `refCount` value against what the cardinality of the
relationship requires.

This algorithm must be generic and capable of operating on any class instance.
This will mean that there will be a lot of pointer arithmetic using
offsets to structure members and other
type unsafe operations happening in the code.
Sometimes ``C'' as a language is accused of being little more than a
high level assembler and it is those type unsafe facilities
that we must employ here to obtain a single body of code that can
operate on an arbitrary class instance.

[source,c]
----
<<mrt forward references>>=
static bool mrtCheckRelationship(MRT_Relationship const *rel) ;
----

The `mrtCheckRelationship` function returns a boolean value indicating
if the relationship described by `rel` has correct referential integrity.

Since there are four types of relationships in terms of how the
reference pointers are stored,
the function considers each type separately.

(((micca,Run Time Function,mrtCheckRelationship)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtCheckRelationship(
    MRT_Relationship const *rel)
{
    bool result = false ;

    switch (rel->relType) {
    case mrtSimpleAssoc: {
        <<mrtCheckRelationship: simple associations>>
    }
        break ;

    case mrtClassAssoc: {
        <<mrtCheckRelationship: class based associations>>
    }
        break ;

    case mrtRefGeneralization: {
        <<mrtCheckRelationship: reference generalizations>>
    }
        break ;

    case mrtUnionGeneralization: {
        <<mrtCheckRelationship: union generalizations>>
    }
        break ;

    /*
     * N.B. no default case. We will just fail the check if
     * this happens.
     */
    }

    return result ;
}
----

For simple associations,
we zero out the `refCount` member in both participants.
The references between the class instances is tracked
and then the values of the `refCount` members are compared against
what the relationship requires.

[source,c]
----
<<mrtCheckRelationship: simple associations>>=
struct mrtsimpleassociation const *assoc = &rel->relInfo.simpleAssociation ;

mrtZeroRefCounts(assoc->source.classDesc) ;
mrtZeroRefCounts(assoc->target.classDesc) ;

mrtCountAssocRefs(&assoc->source, &assoc->target) ;

result =
    mrtCheckRefCounts(assoc->source.classDesc, assoc->source.cardinality) &&
    mrtCheckRefCounts(assoc->target.classDesc, assoc->target.cardinality) ;
----

Class based associations are more complicated.
Recall that class based associations are treated in a decomposed manner
where each side is related to the associator class and the associator
class is unconditionally and singularly related to each participant.
So we will consider each side separately.

[source,c]
----
<<mrtCheckRelationship: class based associations>>=
struct mrtclassassociation const *assoc = &rel->relInfo.classAssociation ;

result = mrtCheckAssociatorRefs(&assoc->associator) ; // <1>
if (result) {
    /*
     * On the first side, we evaluate the references from the source class
     * to the associator class.
     */
    mrtZeroRefCounts(assoc->source.classDesc) ;
    mrtZeroRefCounts(assoc->associator.classDesc) ;
    mrtCountClassAssocRefs(&assoc->source, assoc->associator.classDesc,
            assoc->associator.backwardOffset) ;
    result = mrtCheckRefCounts(assoc->source.classDesc,
                assoc->source.cardinality) &&
            mrtCheckRefCounts(assoc->associator.classDesc, mrtExactlyOne) ;

    /*
     * If the first side is okay, then we can evaluate the references from the
     * target class to the associator class.
     */
    if (result) {
        mrtZeroRefCounts(assoc->target.classDesc) ;
        mrtZeroRefCounts(assoc->associator.classDesc) ;
        mrtCountClassAssocRefs(&assoc->target, assoc->associator.classDesc,
                assoc->associator.forwardOffset) ;
        result = mrtCheckRefCounts(assoc->target.classDesc,
                assoc->target.cardinality) &&
            mrtCheckRefCounts(assoc->associator.classDesc, mrtExactlyOne) ;
    }
}
----
<1> We start by checking the singular references from the associator
class to the two participants.

Since a generalization represents a disjoint union between between the
superclass and the set of subclasses,
each superclass instance must be referenced exactly once from among all
the subclasses of the generalization.
Conversely,
each subclass must reference exactly one superclass instance.
This means we will have to iterate over the subclasses as we zero out
the `refCount` member and count the references.

[source,c]
----
<<mrtCheckRelationship: reference generalizations>>=
struct mrtrefgeneralization const *gen = &rel->relInfo.refGeneralization ;

mrtZeroRefCounts(gen->superclass.classDesc) ;

struct mrtrefsubclassrole const *subclass = gen->subclasses ;
for (unsigned subcount = gen->subclassCount ; subcount != 0 ;
        --subcount, ++subclass) {
    mrtZeroRefCounts(subclass->classDesc) ;
}

mrtCountGenRefs(gen) ;

result = mrtCheckRefCounts(gen->superclass.classDesc, mrtExactlyOne) ;
subclass = gen->subclasses ;
for (unsigned subcount = gen->subclassCount ; subcount != 0 && result ;
        --subcount, ++subclass) {
    result = mrtCheckRefCounts(subclass->classDesc, mrtExactlyOne) ;
}
----

When a generalization is stored in a union,
there are no reference pointers.
However, we can still verify that the subclass instance is actually
allocated.

[source,c]
----
<<mrtCheckRelationship: union generalizations>>=
struct mrtuniongeneralization const *gen = &rel->relInfo.unionGeneralization ;

result = true ;
MRT_Class const *superClass = gen->superclass.classDesc ;
MRT_InstIterator iter ;
for (mrt_InstIteratorStart(&iter, superClass) ; mrt_InstIteratorMore(&iter) ;
        mrt_InstIteratorNext(&iter)) {
    MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
    MRT_Instance *subInst = (MRT_Instance *)
            ((uintptr_t)instref + gen->superclass.storageOffset) ;
    if (subInst->alloc <= 0) {
        result = false ;
        break ;
    }
}
----

The first of the generic operations that must be performed on
class instances is to set the `refCount` member of the instance
structure to zero.

[source,c]
----
<<mrt forward references>>=
static void mrtZeroRefCounts(MRT_Class const *classDesc) ;
----

The algorithm is simple.
We iterate over all the class instances and set the `refCount` member to
zero.

(((micca,Run Time Function,mrtZeroRefCounts)))
[source,c]
----
<<mrt static functions>>=
static void
mrtZeroRefCounts(
    MRT_Class const *classDesc)
{
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, classDesc) ; mrt_InstIteratorMore(&iter) ;
            mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        instref->refCount = 0 ;
    }
}
----

The other operation that depends only upon accessing the `refCount` member
of an instance is to evaluate the value of `refCount` against what
the cardinality of the relationship.
There are four possible values of the cardinality.
One of the values, `mrtZeroOrMore`, implies that any value of
`refCount` is satisfactory since `refCount` is defined as an unsigned
quantity and must, necessarily, be greater than or equal to zero.

For the other three values of cardinality we define functions to
perform the comparison.

(((micca,Run Time Function,mrtCompareAtMostOne)))
(((micca,Run Time Function,mrtCompareExactlyOne)))
(((micca,Run Time Function,mrtCompareOneOrMore)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtCompareAtMostOne(
    unsigned refCount)
{
    return refCount <= 1 ;
}

static bool
mrtCompareExactlyOne(
    unsigned refCount)
{
    return refCount == 1 ;
}

static bool
mrtCompareOneOrMore(
    unsigned refCount)
{
    return refCount >= 1 ;
}
----

The reference counts are checked by iterating over the instances
and invoking the proper cardinality comparison function.
The first failure means we can stop.

[source,c]
----
<<mrt forward references>>=
static bool
mrtCheckRefCounts(MRT_Class const *classDesc, MRT_Cardinality cardinality) ;
----

(((micca,Run Time Function,mrtCheckRefCounts)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtCheckRefCounts(
    MRT_Class const *classDesc,
    MRT_Cardinality cardinality)
{
    if (cardinality == mrtZeroOrMore) { // <1>
        return true ;
    }

    static bool (*const compareFuncs[])(unsigned) = {
        [mrtAtMostOne] = mrtCompareAtMostOne,
        [mrtExactlyOne] = mrtCompareExactlyOne,
        [mrtZeroOrMore] = NULL, // <2>
        [mrtOneOrMore] = mrtCompareOneOrMore
    } ;

    assert(cardinality <= mrtOneOrMore) ;
    bool (*const compareCardinality)(unsigned) = compareFuncs[cardinality] ; // <3>

    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, classDesc) ; mrt_InstIteratorMore(&iter) ;
            mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        if (!compareCardinality(instref->refCount)) {
            return false ; // <4>
        }
    }

    return true ;
}
----
<1> Dispense with the always true case first. There is no reason
to iterate through the instances when the result is always true.
<2> We could omit this and it would be set to zero like any other
uninitialized static variable.
We include it to make clear that that we have accounted for all the cases
and have factored out the `mrtZeroOrMore` case above.
<3> Select the comparison function based on the encoded cardinality.
A small table of pointers to the comparison functions is handy to do this.
<4> We need not go past the first failure.

The singular references made by associator classes are special in the
sense that they should never be `NULL`.
Unrelating class based associations will set those references to `NULL` and
we need to make sure that either the associator instance was reused by
relating to other instances or it was deleted.

[source,c]
----
<<mrt forward references>>=
static bool
mrtCheckAssociatorRefs(struct mrtassociatorrole const *associator) ;
----

(((micca,Run Time Function,mrtCheckAssociatorRefs)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtCheckAssociatorRefs(
    struct mrtassociatorrole const *associator)
{
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, associator->classDesc) ;
            mrt_InstIteratorMore(&iter) ; mrt_InstIteratorNext(&iter)) {
        void *inst = mrt_InstIteratorGet(&iter) ;
        MRT_Instance *ref = *(MRT_Instance **)
                ((uintptr_t)inst + associator->forwardOffset) ;
        if (ref == NULL || ref->alloc == 0) { // <1>
            return false ;
        }
        ref = *(MRT_Instance **)((uintptr_t)inst + associator->backwardOffset) ;
        if (ref == NULL || ref->alloc == 0) {
            return false ;
        }
    }

    return true ;
}
----
<1> Reference pointers in an associator class must be non-NULL and must
point to an allocated instance.

==== Counting References

Of the four types of relationships,
three of them actually contain pointer values that refer to class instances.
The differences in the manner in which the three pointer references are
organized leads us have separate functions for each type.

First we consider counting the references in a simple association.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountAssocRefs(
    struct mrtassociationrole const *source,
    struct mrtassociationrole const *target) ;
----

The `mrtCountAssocRefs` function counts the number of times each
active instance of `source` refers to active instances of `target` and
_vice versa_.

Counting references mean understanding how the reference pointers are
stored.
There are three ways that reference pointer are stored:
single pointer, counted arrays and linked lists.
We use the knowledge of offsets in the instance to
where the pointer values are stored to access target instances.

(((micca,Run Time Function,mrtCountAssocRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountAssocRefs(
    struct mrtassociationrole const *source,
    struct mrtassociationrole const *target)
{
    switch (source->storageType) {
    case mrtSingular:
        mrtCountSingularRefs(source->classDesc, source->storageOffset,
            target->classDesc) ;
        break ;

    case mrtLinkedList:
    case mrtArray:
    default:
        /*
         * For simple associations, the reference from the referring class to
         * the referenced class is always singular.  If we get here, there is a
         * serious linkage problem.
         */
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }

    switch (target->storageType) {
    case mrtSingular:
        mrtCountSingularRefs(target->classDesc, target->storageOffset,
            source->classDesc) ;
        break ;

    case mrtArray:
        mrtCountArrayRefs(target->classDesc, target->storageOffset,
            source->classDesc) ;
        break ;

    case mrtLinkedList:
        mrtCountLinkedListRefs(target->classDesc, target->storageOffset,
                source->classDesc, target->linkOffset) ;
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
----

We will now show how the references stored in the three types are counted.
For singular references, the reference is a pointer to the related
class instance.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountSingularRefs(
    MRT_Class const *sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *targetClass) ;
----

`sourceClass`::
    A pointer to the class description block for the class instances
    that make a singular reference to target instances.
`offset`::
    The offset in bytes from the beginning of source instances to
    where the pointer to the target instance is located.
`targetClass`::
    A pointer to the class description for the class instances
    to which the source instances refer.

The `mrtCountSingularRefs` functions iterates across all the active
`source` instances, accesses the pointer in the source instance
and increments the `refCount` member in the referenced target instance.

(((micca,Run Time Function,mrtCountSingularRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountSingularRefs(
    MRT_Class const *sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *targetClass)
{
    MRT_iab *targetiab = mrt_GetStorageProperties(targetClass, NULL) ;

    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&srciter) ;
        MRT_Instance *targetInst =
                *(MRT_Instance **)((uintptr_t)instref + offset) ;
        if ((void *)targetInst >= targetiab->storageStart &&
                (void *)targetInst < targetiab->storageFinish &&
                targetInst->alloc > 0) { // <1>
            targetInst->refCount = targetInst->refCount == UINT8_MAX ?
                    2 : targetInst->refCount + 1 ; // <2>
        }
    }
}
----
<1> Validate that the reference pointer value actually points into
target instance storage. This will eliminate any NULL values also.
Note we also insist that the target instance be active.
<2> We want to avoid the possibility of overflow of the reference counter.
It is only an unsigned 8-bit quantity.
Should it overflow, we could misinterpret the count.
If we are at its max value, then we set it back to 2.
Why 2? Zero and one are significant in this case and we know the values
has already passed two, so we resume our count from there.
Any value greater than 1 will yield the same conclusion about
the referential integrity.

For array references, the references are an array of pointers to the related
class instance.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountArrayRefs(
    MRT_Class const *sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *targetClass) ;
----

`sourceClass`::
    A pointer to the class description block for the class instances
    that make an array reference to target instances.
`offset`::
    The offset in bytes from the beginning of source instances to
    where the pointer array to the target instance is located.
`targetClass`::
    A pointer to the class description for the class instances
    to which the source instances refer.

The `mrtCountArrayRefs` functions iterates across all the active
`source` instances, accesses the pointer in the source instance
and increments the `refCount` member in the referenced target instance.

(((micca,Run Time Function,mrtCountArrayRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountArrayRefs(
    MRT_Class const *sourceClass,
    MRT_AttrOffset offset,
    MRT_Class const *targetClass)
{
    MRT_iab *targetiab = mrt_GetStorageProperties(targetClass, NULL) ;

    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&srciter) ;
        MRT_ArrayRef *srcrefs =
                (MRT_ArrayRef *)((uintptr_t)instref + offset) ;
        MRT_Instance *const *iter = srcrefs->links ;
        for (unsigned count = srcrefs->count ; count != 0 ; count--, iter++) {
            MRT_Instance *targetInst = *iter ;
            if ((void *)targetInst >= targetiab->storageStart &&
                    (void *)targetInst < targetiab->storageFinish &&
                    targetInst->alloc > 0) {
                targetInst->refCount = targetInst->refCount == UINT8_MAX ?
                        2 : targetInst->refCount + 1 ;
            }
        }
    }
}
----

The structure of the linked list pointers makes counting them
a bit more complicated.
We must know the offset within the source instance where the link
list terminus is located.
Since the link pointers in the target are embedded somewhere in the target
instance structure,
we need to know the offset into the target instance that the links point to
in order recover a pointer to the beginning of the target instance..

[source,c]
----
<<mrt forward references>>=
static void
mrtCountLinkedListRefs(
    MRT_Class const *sourceClass,
    MRT_AttrOffset refOffset,
    MRT_Class const *targetClass,
    MRT_AttrOffset linkOffset) ;
----

`sourceClass`::
    A pointer to the class description for the class instances
    that make a linked reference to target instances.
`refOffset`::
    The offset in bytes from the beginning of source instances to
    where the linked list terminus is located.
`targetClass`::
    A pointer to the class description for the class instances
    to which the source instances refer.
`linkOffset`::
    The offset in bytes from the beginning of target instances to where
    the linked list pointers are located.

The `mrtCountLinkedListRefs` function iterates through the linked list
contained in the source instances to reference the target instances.
When a target instance is found, it's `refCount` member is incremented.

(((micca,Run Time Function,mrtCountLinkedListRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountLinkedListRefs(
    MRT_Class const *sourceClass,
    MRT_AttrOffset refOffset,
    MRT_Class const *targetClass,
    MRT_AttrOffset linkOffset)
{
    MRT_iab *targetiab = mrt_GetStorageProperties(targetClass, NULL) ;
    MRT_InstIterator srciter ;
    for (mrt_InstIteratorStart(&srciter, sourceClass) ;
            mrt_InstIteratorMore(&srciter) ; mrt_InstIteratorNext(&srciter)) {
        MRT_Instance *srcInst = mrt_InstIteratorGet(&srciter) ;
        MRT_LinkRef *ref = (MRT_LinkRef *)((uintptr_t)srcInst + refOffset) ;
        if (ref->next != NULL) { // <1>
            for (MRT_LinkRef *trgIter = mrtLinkRefBegin(ref) ;
                    trgIter != mrtLinkRefEnd(ref) ; trgIter = trgIter->next) {
                MRT_Instance *targetInst =
                    (MRT_Instance *)((uintptr_t)trgIter - linkOffset) ; // <2>
                if ((void *)targetInst >= targetiab->storageStart &&
                        (void *)targetInst < targetiab->storageFinish &&
                        targetInst->alloc > 0) {
                    targetInst->refCount = targetInst->refCount == UINT8_MAX ?
                            2 : targetInst->refCount + 1 ;
                }
            }
        }
    }
}
----
<1> Guard against uninitialized link pointers.
<2> The link pointers that form the linked list of target instances are
located `linkOffset` from the beginning of the target instance.
So we need to do some pointer arithmetic to get the pointer to the beginning
of the instance.
We have to do this computation because it may be the case that the target is on
several linked lists depending upon the relationships in which it participates.

Counting class based associations uses the basic counting primatives that
we have already seen.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountClassAssocRefs(
    struct mrtassociationrole const *participant,
    MRT_Class const *assocClass,
    MRT_AttrOffset assocOffset) ;
----

To count class based associations,
we have to count the references from each participant to the associator
class.
References from the participant to the associator class can be of any type.
References from the associator class back to the participant are always
singular.

(((micca,Run Time Function,mrtCountClassAssocRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountClassAssocRefs(
    struct mrtassociationrole const *participant,
    MRT_Class const *assocClass,
    MRT_AttrOffset assocOffset)
{
    switch (participant->storageType) {
    case mrtSingular:
        mrtCountSingularRefs(participant->classDesc, participant->storageOffset,
            assocClass) ;
        break ;

    case mrtArray:
        mrtCountArrayRefs(participant->classDesc, participant->storageOffset,
            assocClass) ;
        break ;

    case mrtLinkedList:
        mrtCountLinkedListRefs(participant->classDesc,
                participant->storageOffset, assocClass,
                participant->linkOffset) ;
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
    mrtCountSingularRefs(assocClass, assocOffset, participant->classDesc) ;
}
----

In a reference type generalization,
all of the references are always singular.
However,
we must iterate across all the subclasses of the generalization in order to
count the references that the subclasses make back to the superclass.

[source,c]
----
<<mrt forward references>>=
static void
mrtCountGenRefs(
    struct mrtrefgeneralization const *gen) ;
----

(((micca,Run Time Function,mrtCountGenRefs)))
[source,c]
----
<<mrt static functions>>=
static void
mrtCountGenRefs(
    struct mrtrefgeneralization const *gen)
{
    MRT_Class const *superClass = gen->superclass.classDesc ;
    MRT_InstIterator iter ;
    for (mrt_InstIteratorStart(&iter, superClass) ;
            mrt_InstIteratorMore(&iter) ; mrt_InstIteratorNext(&iter)) {
        MRT_Instance *instref = mrt_InstIteratorGet(&iter) ;
        MRT_Instance *subInst = *(MRT_Instance **)
                ((uintptr_t)instref + gen->superclass.storageOffset) ;
        if (subInst != NULL) {
            MRT_Class const *subClass = subInst->classDesc ;

            MRT_iab *subiab = mrt_GetStorageProperties(subClass, NULL) ;
            if ((void *)subInst >= subiab->storageStart &&
                    (void *)subInst < subiab->storageFinish &&
                    subInst->alloc > 0) {
                subInst->refCount = subInst->refCount == UINT8_MAX ?
                        2 : subInst->refCount + 1 ;
            }
        }
    }

    struct mrtrefsubclassrole const *subclass = gen->subclasses ;
    for (unsigned subcount = gen->subclassCount ; subcount != 0 ;
            --subcount, ++subclass) {
        mrtCountSingularRefs(subclass->classDesc, subclass->storageOffset,
                gen->superclass.classDesc) ;
    }
}
----

=== Operations on Relationship Instances

Since the relationship descriptions have sufficient information
to manage referential integrity,
they also can be used to do the pointer manipulations required with
instances of the relationships are created or deleted.
It is important for the run-time to provide functions to perform these
operations since determining referential integrity depends upon
correct reference pointer manipulation.

Because we are using pointer values to manage instance identity and
referencesfootnote:[as opposed to attribute values if we were doing this
using relational concepts],
we need to be clear what operations must be performed for classes
that participate in relationships.

For class based associations:

* There is a one-to-one correspondence between instances of class based
association and instances of the associator class.
* Because of this correspondence,
when an instance of an associator is created, the creation operation
must be supplied with instance references to the participating instances.
The run-time will make up the pointer references appropriately.
The participating instances must not already be part of the relationship.
This implies that they participating instances are newly created
or the run-time will unlink them from the association before creating
the new instance of the association.
* Conversely, deleting an instance of an associator class is sufficient
to delete an instance of the class based association itself.
* Deleting an instance of a class participating in a class based association
*does not* cause the corresponding instance (or instances) of the associator
to be deleted.
* An operation to swap a different instance of a participating class
is also provided.

For simple associations:

* There is a one-to-one correspondence between instance of the simple
association and instances of the referring class.
* Because of this correspondence,
when an instance of the referring class is created, the creation operation
must be supplied with an instance reference to the referenced participating
class.
* Conversely, deleting an instance of a referring class,
unlinks the references to the referenced class.
* Deleting an instance of a referenced class, unlinks the pointers to
the referring class.
* An operation to swap a different instance of a referenced class
is also provided.


For referenced based generalizations:

* When creating an instance of a subclass,
the creation operation must be supplied with an instance reference
to the superclass.
The implication is that object creation must be in subclass to superclass
order.
* Deleting an instance of the subclass, unlinks the references between
the subclass and superclass.
The same applies to superclass instance deletions.
The references are unlinked, but the corresponding superclass or subclass
is instance _not_ deleted.
* An operation to reclassify subclass is also provided. This is a short
hand for a delete / create sequence of a related subclass instance.

For union based generalizations:

* Subclass instances may not be directly created.
It is necessary to create the superclass and reclassify the subclass
instance to the desired subclass type.
This may need to be repeated down a hierarchy if multiple generalization
are defined.
Note this implies the creation order for union based generalization is
from superclass to subclass order.
This is opposite of that for reference generalizations.
* Superclass or subclass instances may be deleted.
In this case, there are no pointer references to modify, but
referential integrity will be evaluated.
* An operation to reclassify subclass is also provided. This is a short
hand for a delete / create sequence of a related subclass instance.

=== Creating Relationship Links

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_CreateSimpleLinks(
    MRT_Relationship const *rel,
    void *source,
    void *target) ;
----

`rel`::
    A pointer to a relationship description for the relationship
    across which the relate operation is to happen.
`source`::
    A pointer to a class instance that serves the source role in the
    relationship.
`target`::
    A pointer to a class instance that serves the target role in the
    relationship.
*****

This function is used to establish pointer links when instances are create
as well as when they are "swapped".

(((micca,Run Time Function,mrt_CreateSimpleLinks)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_CreateSimpleLinks(
    MRT_Relationship const *rel,
    void *source,
    void *target)
{
    assert(rel != NULL) ;
    assert(source != NULL) ;
    assert(target != NULL) ;

    switch (rel->relType) {
    case mrtSimpleAssoc: {
        <<mrt_CreateSimpleLinks: link simple association>>
    }
        break ;

    case mrtClassAssoc: {
        <<mrt_CreateSimpleLinks: link class association>>
    }
        break ;

    case mrtRefGeneralization: {
        <<mrt_CreateSimpleLinks: link reference generalization>>
    }
        break ;

    case mrtUnionGeneralization:
        // There are no pointer linkages for a union generalization.
        // N.B. fall through

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }

    mrtMarkRelationship(&rel, 1) ;
}
----

For simple associations,
we must establish two sets of pointer linkages.
From source to target is the primary referring direction.
This is always a simple, single pointer value.
From target to source is in the back link direction and
may be either singular or a linked list.

[source,c]
----
<<mrt_CreateSimpleLinks: link simple association>>=
struct mrtsimpleassociation const *assoc = &rel->relInfo.simpleAssociation ;

if (assoc->source.classDesc != ((MRT_Instance *)source)->classDesc ||
        assoc->target.classDesc != ((MRT_Instance *)target)->classDesc) {
    mrtFatalError(mrtRelationshipLinkage) ;
}

mrtLink(&assoc->source, source, target) ;
mrtLink(&assoc->target, target, source) ;
----

Since the core of what is going on here is linking the two instances,
let's look at what `mrtLink` does.
We will use this function several more times later on.

Like most of the access to relationship pointers we have already seen,
`mrtLink` does some unsafe pointer arithmetic to find the location in the
instance where references are stored.
Then, depending upon the type of reference storage,
updates the instance pointers.

(((micca,Run Time Function,mrtLink)))
[source,c]
.Implementation
----
<<mrt static functions>>=
static void
mrtLink(
    struct mrtassociationrole const *sourceRole,
    void *source,
    void *target)
{
    switch (sourceRole->storageType) {
    case mrtSingular: {
        void **ref = (void **)((uintptr_t)source +
                sourceRole->storageOffset) ; // <1>
        *ref = target ;
    }
        break ;

    case mrtArray:
        // can't link array types
        mrtFatalError(mrtStaticRelationship) ;
        break ;

    case mrtLinkedList: {
        MRT_LinkRef *targetLinks = (MRT_LinkRef *)((uintptr_t)target +
                sourceRole->linkOffset) ;
        if (targetLinks->next != NULL && targetLinks->prev != NULL) {
            mrtLinkRefRemove(targetLinks) ; // <2>
        }

        // Find the linked list terminus in the source instance and
        // insert the target on the list.
        MRT_LinkRef *sourceList = (MRT_LinkRef *)((uintptr_t)source +
                sourceRole->storageOffset) ; // <3>
        assert(targetLinks->next == NULL && targetLinks->prev == NULL) ;
        mrtLinkRefInsert(targetLinks, sourceList) ;
    }
        break ;

    default:
        mrtFatalError(mrtRelationshipLinkage) ;
        break ;
    }
}
----
<1> For a singular pointer, the `storageOffset` is to a simple pointer
location.
If the value stored at the pointer location was not `NULL`,
overwriting it serves to unlink any previously linked participant.
<2> If the target is already on a linked list somewhere,
then we unlink it before placing it on the new list.
We can do this since we do not need the list head to unlink an item from a
list.
To find the link pointers in the target,
note the offset into the target is actually given in the association
description of the source.
This arrangement is convenient in other cases, despite its the confusion
of using a source description to access something in the target instance.
Note also that we might be removing the target from the same list
to which we will immediately insert it.
That's alright, it is necessary to insure the referenced instances form a set.
<3> For linked reference storage,
the `storageOffset` is the byte offset to the linked list terminus.

For class based associations,
the `mrt_CreateSimpleLinks` function updates only one of the pointer
references, from the associator class to either the source or target
participant of the relationship.

[source,c]
----
<<mrt_CreateSimpleLinks: link class association>>=
struct mrtclassassociation const *cassoc = &rel->relInfo.classAssociation ;
struct mrtassociatorrole const *arole = &cassoc->associator ;
struct mrtassociationrole const *srole = &cassoc->source ;
struct mrtassociationrole const *trole = &cassoc->target ;

if (arole->classDesc != ((MRT_Instance *)source)->classDesc) { // <1>
    mrtFatalError(mrtRelationshipLinkage) ;
}

if (srole->classDesc == ((MRT_Instance *)target)->classDesc) { // <2>
    void **p_backRef = (void **)((uintptr_t)source + arole->backwardOffset) ;
    *p_backRef = target ;
    mrtLink(srole, target, source) ;
} else if (trole->classDesc == ((MRT_Instance *)target)->classDesc) { // <3>
    void **p_forwRef = (void **)((uintptr_t)source + arole->forwardOffset) ;
    *p_forwRef = target ;
    mrtLink(trole, target, source) ;
} else {
    mrtFatalError(mrtRelationshipLinkage) ;
}
----
<1> When invoked on a class based association,
we insist that the "source" instance reference argument be an instance
reference to the associator class.
<2> Test to determine if the "target" instance reference refers to
the source participant of the association.
If so, then we update the "backward" side of the associative class,
_i.e._ the reference from the associator instance to the source
participant.
The naming is a bit strained here.
<3> Conversely, test to determin if the "target" instance reference refers
to the target participant of the association.
This corresponds to the "forward" reference by the associative class,
_i.e._ the reference from the associator instance to the target
participant.
Again, the naming is a bit difficult.

When relating reference generalizations,
the reference from the subclass to the superclass is singular and
unconditional.
The reference from the superclass to the subclass is also singular.

[source,c]
----
<<mrt_CreateSimpleLinks: link reference generalization>>=
struct mrtrefgeneralization const *gen = &rel->relInfo.refGeneralization ;

MRT_Class const *subclassClass = ((MRT_Instance *)source)->classDesc ; // <1>
int subclassCode = mrtFindRefGenSubclassCode(subclassClass, gen->subclasses,
        gen->subclassCount) ;

MRT_Class const *superclassClass = ((MRT_Instance *)target)->classDesc ; // <2>
if (gen->superclass.classDesc != superclassClass) {
    mrtFatalError(mrtRelationshipLinkage) ;
}

void **p_superRef = (void **)((uintptr_t)source +
        gen->subclasses[subclassCode].storageOffset) ;
*p_superRef = target ;

void **p_subRef = (void **)((uintptr_t)target + gen->superclass.storageOffset) ;
*p_subRef = source ;
----
<1> For reference generalizations,
the "source" instance reference must be one of the subclasses that
participates in the relationship.
The primary reference in a generalization is from subclass instance to
superclass instance.
<2> The "target" instance reference must then be to the superclass of the
generalization.

Finding the participating subclass of the generalization is a linear search
of the subclass roles in the relationship description.

(((micca,Run Time Function,mrtFindRefGenSubclassCode)))
[source,c]
----
<<mrt static functions>>=
static int
mrtFindRefGenSubclassCode(
    MRT_Class const *subclassClass,
    struct mrtrefsubclassrole const *subclasses,
    unsigned count)
{
    int subcode ;

    for (subcode = 0 ; subcode < count ; ++subcode, ++subclasses) {
        if (subclassClass == subclasses->classDesc) {
            return subcode ;
        }
    }

    mrtFatalError(mrtRelationshipLinkage) ;
}
----

=== Create Associator Links

Linking class based associations must account for the nature
of the associator class.
A class based association is treated as being decomposed into
two associations, one each between the participants and the associator
class.

[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_CreateAssociatorLinks(
    MRT_Relationship const *rel,
    void *assoc,
    void *source,
    void *target) ;
----

(((micca,Run Time Function,mrt_CreateAssociatorLinks)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void
mrt_CreateAssociatorLinks(
    MRT_Relationship const *rel,
    void *assoc,
    void *source,
    void *target)
{
    assert(rel != NULL) ;
    assert(assoc != NULL) ;
    assert(source != NULL) ;
    assert(target != NULL) ;

    mrt_CreateSimpleLinks(rel, assoc, source) ; // <1>
    mrt_CreateSimpleLinks(rel, assoc, target) ;

    mrtMarkRelationship(&rel, 1) ;
}
----
<1> In keeping with the concept that a class based assocation is
decomposed into two association legs, we need only create the links
for both sides.

=== Deleting Relationship Linkage

We must also provide a function to delete relationship linkage pointers.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrtDeleteLinks(
    struct mrtrelationship const * const *classRels,
    unsigned relCount,
    void *inst) ;
----

`classRels`::
    A pointer to an array of relationships description pointers
    that describe the relationships in which `inst` is a participant.
`relCount`::
    The number of elements in the `classRels` array.
`inst`::
    A pointer to the class instance that is to be unlinked from its
    relationship.
*****

(((micca,Run Time Function,mrtDeleteLinks)))
[source,c]
.Implementation
----
<<mrt static functions>>=
void
mrtDeleteLinks(
    struct mrtrelationship const * const *classRels,
    unsigned relCount,
    void *inst)
{
    assert(inst != NULL) ;
    /*
     * Mark the transaction since we are updating the reference pointers.
     */
    mrtMarkRelationship(classRels, relCount) ;

    MRT_Instance *instref = inst ;
    MRT_Class const *instclass = instref->classDesc ;

    for ( ; relCount != 0 ; relCount--, classRels++) {
        struct mrtrelationship const * const rel = *classRels ;
        switch (rel->relType) {
        case mrtSimpleAssoc: {
            <<mrtDeleteLinks: unlink simple association>>
        }
            break ;

        case mrtClassAssoc: {
            <<mrtDeleteLinks: unlink class based association>>
        }
            break ;

        case mrtRefGeneralization: {
            <<mrtDeleteLinks: unlink reference generalization>>
        }
            break ;

        case mrtUnionGeneralization:
            // For a union generalization, there are no pointer links.
            break ;

        default:
            mrtFatalError(mrtRelationshipLinkage) ;
            break ;
        }
    }
}
----

To unrelate simple associations,
we must verify that the classes of the instance actually participate in the
association and the perform the pointer operations to unlink the instances.

[source,c]
----
<<mrtDeleteLinks: unlink simple association>>=
struct mrtsimpleassociation const *s_assoc = &rel->relInfo.simpleAssociation ;

if (instclass == s_assoc->source.classDesc) {
    mrtSimpUnlinkForward(s_assoc, inst) ;
} else if (instclass == s_assoc->target.classDesc) {
    mrtSimpUnlinkBack(s_assoc, inst) ;
} else {
    mrtFatalError(mrtRelationshipLinkage) ;
}
----

[source,c]
----
<<mrt forward references>>=
static void
mrtSimpUnlinkForward(
    struct mrtsimpleassociation const *assoc,
    void *source) ;
----

Unlinking a simple association in the forward direction implies that we
are unlinking the primary reference.
This primary reference is always singular and always non-NULL.
When we are unlinking the primary reference we will follow the reference
and try to unlink any back references.

[source,c]
.Implementation
----
<<mrt static functions>>=
static void
mrtSimpUnlinkForward(
    struct mrtsimpleassociation const *assoc,
    void *source)
{
    struct mrtassociationrole const *sourceRole = &assoc->source ;

    if (sourceRole->storageType == mrtSingular) {
        void **p_targetInst = (void **)
                ((uintptr_t)source + sourceRole->storageOffset) ;
        MRT_Instance *targetInst = *p_targetInst ;
        *p_targetInst = NULL ; // <1>

        struct mrtassociationrole const *targetRole = &assoc->target ;
        assert(targetInst != NULL) ;
        if (targetInst != NULL && targetInst->alloc > 0 &&
                targetInst->classDesc == targetRole->classDesc) { // <2>
            mrtUnlinkBackref(targetRole, source, targetInst) ;
        }
    } else {
        // Simple forward association links are always singular.
        mrtFatalError(mrtRelationshipLinkage) ;
    }
}
----
<1> Assigning `NULL` to the primary reference effectively unlinks
the target instance.
<2> The test for `NULL` is just _belt and suspenders_ for when the
`assert` macro is conditionally compiled out.
We only want to attempt to unlink the back reference is the target instance
is still allocated and of the same class.
Normally, instance don't just change their class out from under themselves.
However, union based subclass instances do.
Migrating a union subclass instance results in any back reference pointers
to the instance remaining valid, but the class of the instance now
occupying the memory has changed.
Union subclasses are somewhat painful.

[source,c]
----
<<mrt forward references>>=
static void
mrtSimpUnlinkBack(
    struct mrtsimpleassociation const *assoc,
    void *target) ;
----

The case of unlinking back references for a simple association,
occurs when the target instance is being deleted.
In this case,
we only delete the back references made by the target.
In particular we make no attempt to follow the source references
and delete the primary reference pointer.
If the refering instance is not later deleted,
then referential integrity checking will find a pointer to
an unallocated instance.
This will be caught in referential integrity checking.
we must be prepared for the fact that the back references are
already gone.
This is because it is possible to delete the referenced instance of
a simple association before deleting the refering instance.

[source,c]
.Implementation
----
<<mrt static functions>>=
static void
mrtSimpUnlinkBack(
    struct mrtsimpleassociation const *assoc,
    void *target)
{
    struct mrtassociationrole const *targetRole = &assoc->target ;

    if (targetRole->storageType == mrtSingular) {
        void **p_sourceInst = (void **)
                ((uintptr_t)target + targetRole->storageOffset) ;
        *p_sourceInst = NULL ; // <1>
    } else if (targetRole->storageType == mrtLinkedList) { // <2>
        MRT_LinkRef *sourceList = (MRT_LinkRef *)
                ((uintptr_t)target + targetRole->storageOffset) ; // <3>
        assert(sourceList->next != NULL && sourceList->prev != NULL) ;
        for (MRT_LinkRef *iter = mrtLinkRefBegin(sourceList) ;
                iter != mrtLinkRefEnd(sourceList) ; ) {
            MRT_LinkRef *sourceInst = iter ;
            iter = iter->next ; // <4>
            mrtLinkRefRemove(sourceInst) ;
        }
    } else {
        // Can't unlink array type linkages.
        mrtFatalError(mrtStaticRelationship) ;
    }
}
----
<1> For the singular pointer case we can just write `NULL` to the
back reference.
Even if it was already `NULL`, it won't matter.
The link is severed.
<2> In this case, the target instance is being deleted and all of
its back links must be removed.
<3> This is the list of back links to source instances.
<4> Be careful to advance the iterator before deleting the item from the list.

In this function we are trying to delete a single back link from the "target"
to the "source".
This is the back link deletion associated with deleting the primary
reference pointer and we have tracked to a target instance.

[source,c]
----
<<mrt forward references>>=
static void
mrtUnlinkBackref(
    struct mrtassociationrole const *targetRole,
    void *source,
    void *target) ;
----

[source,c]
----
<<mrt static functions>>=
static void
mrtUnlinkBackref(
    struct mrtassociationrole const *targetRole,
    void *source,
    void *target)
{
    assert(source != NULL) ;
    assert(target != NULL) ;
    assert(targetRole != NULL) ;

    if (targetRole->storageType == mrtSingular) {
        void **p_sourceInst = (void **)
                ((uintptr_t)target + targetRole->storageOffset) ; // <1>
        *p_sourceInst = NULL ;
    } else if (targetRole->storageType == mrtLinkedList) {
        MRT_LinkRef *sourcelinks = (MRT_LinkRef *)
                ((uintptr_t)source + targetRole->linkOffset) ; // <2>

        if (sourcelinks->next != NULL && sourcelinks->prev != NULL) { // <3>
            mrtLinkRefRemove(sourcelinks) ;
        }
    } else {
        // Can't unlink array type linkages.
        mrtFatalError(mrtStaticRelationship) ;
    }
}
----
<1> The entity at the storageOffset is a simple pointer back to the
source instance.  Point to where the source reference is located
in the target instance.
<2> The source instance is linked onto a list whose list terminus is
contained in the target instance.
We need to remove the source instance from that list.
We only need a pointer to the links member in the
source instance to remove it from the list (it is doubly linked).
The links are offset into the source instance by the `linkOffset` given in
the "target" role relationship descriptor.
<3> Check that the instance is actually linked on the list.
If the source has been deleted previously,
then it will have been removed from the list already.

For class based associations,
we deal with the association in two steps, between each participant and
the associator class.

[source,c]
----
<<mrtDeleteLinks: unlink class based association>>=
struct mrtclassassociation const *c_assoc = &rel->relInfo.classAssociation ;

if (instclass == c_assoc->associator.classDesc) {
    struct mrtassociatorrole const *assocRole = &c_assoc->associator ;
    struct mrtassociationrole const *sourceRole = &c_assoc->source ;
    struct mrtassociationrole const *targetRole = &c_assoc->target ;

    void **p_targetInst = (void **)
            ((uintptr_t)inst + assocRole->forwardOffset) ; // <1>
    MRT_Instance *targetInst = *p_targetInst ;
    *p_targetInst = NULL ;
    assert(targetInst != NULL) ;
    if (targetInst != NULL && targetInst->alloc > 0) {
        mrtUnlinkBackref(targetRole, inst, targetInst) ;
    }

    void **p_sourceInst = (void **)
            ((uintptr_t)inst + assocRole->backwardOffset) ;
    MRT_Instance *sourceInst = *p_sourceInst ;
    *p_sourceInst = NULL ;
    assert(sourceInst != NULL) ;
    if (sourceInst != NULL && sourceInst->alloc > 0) {
        mrtUnlinkBackref(sourceRole, inst, sourceInst) ;
    }
}
----
<1> Start with the forward direction to the target.
Point to where the target reference is located in the associator instance.

For reference generalizations,
the references are singular pointers between the superclass and subclass
instances.
We must make sure the classes given actually participate in the
generalization.

[source,c]
----
<<mrtDeleteLinks: unlink reference generalization>>=
struct mrtrefgeneralization const *gen = &rel->relInfo.refGeneralization ;

if (instclass != gen->superclass.classDesc) {
    // Instance is a subclass instance
    int subclassCode = mrtFindRefGenSubclassCode(instclass, gen->subclasses,
            gen->subclassCount) ;
    // Obtain the pointer to the superclass instance.
    void **p_superInst = (void **)
            ((uintptr_t)inst + gen->subclasses[subclassCode].storageOffset) ;
    MRT_Instance *superInst = *p_superInst ;
    *p_superInst = NULL ;
    assert(superInst != NULL) ;
    // NULL out the pointer in the superclass instance pointing to the subclass
    // instance.
    if (superInst != NULL && superInst->alloc > 0) {
        void **p_subInst = (void **)
                ((uintptr_t)superInst + gen->superclass.storageOffset) ;
        *p_subInst = NULL ;
    }
} else {
    // Instance is a superclass instance
    // NULL out the pointer to the subclass instance only,
    // i.e. only the back reference.
    void **p_subInst = (void **)((uintptr_t)inst + gen->superclass.storageOffset) ;
    *p_subInst = NULL ;
}
----

=== Reclassifying Subclasses

Generalization relationships represent a disjoint union of the
subclasses.
Because of this property,
we know that there is an unconditional relationship between a subclass
instance and a superclass instance and an unconditional relationship
between a superclass instance and a subclass instance from among all the
subclasses of the generalization.
This situation leads to the concept of a reclassify operation to allow
a related subclass instance to migrate from one subclass to another.
It is a powerful concept to model modal operations in a domain.
The run-time provides a function to accomplish the details.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void *
mrt_Reclassify(
    MRT_Relationship const *rel,
    void *super,
    MRT_Class const *newSubclass) ;
----

`rel`::
    A pointer to a relationship description for the relationship
    across which the reclassify operation is to happen.
`super`::
    A pointer to a class instance that serves the superclass role in the
    relationship.
`newSubclass`::
    A pointer to the class description to which the currently related
    subclass instance is to be reclassified.

The `mrt_Reclassify` function migrates the class of the instance
currently related to `super` along the `rel` generalization to be of
the new class, `newSubclass`.
Conceptually,
reclassification implies that the currently related subclass instance
is unrelated and deleted and a new instance of `newSubclass` is created
and related to `super`.

The return value of the function is an instance pointer to the newly
created subclass instance.
*****

Since we support two different ways to store subclass instances,
the reclassification considers each type separately.

(((micca,Run Time Function,mrt_Reclassify)))
[source,c]
.Implementation
----
<<mrt external functions>>=
void *
mrt_Reclassify(
    MRT_Relationship const *rel,
    void *super,
    MRT_Class const *newSubclass)
{
    void *newSubInst = NULL ;

    if (rel->relType == mrtRefGeneralization) {
        <<mrt_Reclassify: reclassify reference generalization>>
    } else if (rel->relType == mrtUnionGeneralization) {
        <<mrt_Reclassify: reclassify union generalization>>
    } else {
        mrtFatalError(mrtRelationshipLinkage) ;
    }

    return newSubInst ;
}
----

For reference type generalizations,
we must perform the complete delete / create sequence.

[source,c]
----
<<mrt_Reclassify: reclassify reference generalization>>=
struct mrtrefgeneralization const *gen = &rel->relInfo.refGeneralization ;

/*
 * Check that we have the correct superclass.
 */
MRT_Class const *superclassClass = ((MRT_Instance *)super)->classDesc ;
if (gen->superclass.classDesc != superclassClass) {
    mrtFatalError(mrtRelationshipLinkage) ;
}
/*
 * Offset into the superclass instance to where the pointer to the
 * subclass instance is located.
 */
void **p_subInst = (void **)((uintptr_t)super + gen->superclass.storageOffset) ;
void *subInst = *p_subInst ;
if (subInst != NULL) {
    /*
     * Delete the old subclass instance.  Deleting will cause the subclass
     * instance to be unlinked from the generalization.
     */
    mrt_DeleteInstance(subInst) ;
}

/*
 * Create a new instance of the new subclass.
 */
newSubInst = mrt_CreateInstance(newSubclass, MRT_StateCode_IG) ;
/*
 * Create the links to the super class instance.
 */
mrt_CreateSimpleLinks(rel, newSubInst, super) ;
----

For generalizations implemented as unions,
the reclassification sequence is much simpler.
There is no need to delete and create a new instance of the new
subclass.
We need only transform the currently related instance into the new
subclass.

[source,c]
----
<<mrt_Reclassify: reclassify union generalization>>=
struct mrtuniongeneralization const *gen = &rel->relInfo.unionGeneralization ;

MRT_Class const *superclassClass = ((MRT_Instance *)super)->classDesc ;
if (gen->superclass.classDesc != superclassClass) {
    mrtFatalError(mrtRelationshipLinkage) ;
}
/*
 * Check that the new subclass is one that is part of this generalization.
 * We don't actually need the subclass code itself.
 */
mrtFindUnionGenSubclassCode(newSubclass, gen->subclasses, gen->subclassCount) ;
/*
 * Point to where the subclass instance is stored within the superclass.
 */
newSubInst = (void *)((uintptr_t)super + gen->superclass.storageOffset) ;
MRT_Instance *subInst = newSubInst ;
/*
 * Clean up any relationship pointers.
 */
if (subInst->alloc > 0) {
    MRT_Class const *newSubClass = subInst->classDesc ;
    mrtDeleteLinks(newSubClass->classRels, newSubClass->relCount, subInst) ;
}
/*
 * Set up the memory for the subclass instance according to the new subclass.
 */
mrtInitializeInstance(subInst, newSubclass, MRT_StateCode_IG) ;
----

This function is the counterpart for finding a subclass among the
subclasses for a union generalization.

(((micca,Run Time Function,mrtFindUnionGenSubclassCode)))
[source,c]
----
<<mrt static functions>>=
static int
mrtFindUnionGenSubclassCode(
    MRT_Class const *subclassClass,
    MRT_Class const * const *subclasses,
    unsigned count)
{
    int subcode ;

    for (subcode = 0 ; subcode < count ; ++subcode, ++subclasses) {
        if (subclassClass == *subclasses) {
            return subcode ;
        }
    }

    mrtFatalError(mrtRelationshipLinkage) ;
}
----

=== Linked List Operations

The run-time supplies a set of linked list operations for use
in manipulating the lists of instance pointers used to realize and
navigate associations.
They are the usual circularly, doubly linked list manipulations
and are presented here without little further comment.

[source,c]
----
<<mrt interface static inlines>>=
static inline
MRT_LinkRef *
mrtLinkRefBegin(
    MRT_LinkRef *iter)
{
    return iter->next ;
}
static inline
MRT_LinkRef *
mrtLinkRefEnd(
    MRT_LinkRef *iter)
{
    return iter ;
}
static inline
bool
mrtLinkRefEmpty(
    MRT_LinkRef *ref)
{
    return ref->next == ref ;
}
static inline
bool
mrtLinkRefNotEmpty(
    MRT_LinkRef *ref)
{
    return ref->next != ref ;
}
----

Note that an empty list is one where the list terminus points back to itself.

[source,c]
----
<<mrt implementation static inlines>>=
static inline
void
mrtLinkRefInit(
    MRT_LinkRef *ref)
{
    ref->next = ref->prev = ref ;
}
----

Because the list is doubly linked,
we only have to have a pointer to the item to remove it.

[source,c]
----
<<mrt implementation static inlines>>=
static inline
void
mrtLinkRefRemove(
    MRT_LinkRef *item)
{
    item->prev->next = item->next ;
    item->next->prev = item->prev ;
    item->next = item->prev = NULL ; // <1>
}
----

The insert function inserts an item before a given point in the list.
Since it is usually called with a list head as the insertion place,
the net effect is to place the item last in the list.

[source,c]
----
<<mrt implementation static inlines>>=
static inline
void
mrtLinkRefInsert(
    MRT_LinkRef *item,
    MRT_LinkRef *at)
{
    if (item->next != NULL || item->prev != NULL) { // <2>
        mrtFatalError(mrtRelationshipLinkage) ;
    }
    item->prev = at->prev ;
    item->next = at ;
    at->prev->next = item ;
    at->prev = item ;
}
----

<1> Since all the linked lists maintained as part of a set of references
form a set,
we set the values of the `next` and `prev` members to `NULL` when
the item has been removed from a list.
<2> We also test that they are `NULL` before inserting an item into a list
to insure that we are not inserting a duplicate.
Inserting an item already in the list destroys the pointer structure
of the list.

== Managing Execution

In this section we discuss the rules and policies associated
with managing the sequencing of execution.
There are two means available to domain activities to control the
sequencing of execution.

* Invoke an ordinary function.
* Generate an event to the instance of a class.

Not much needs to be said about invoking functions.
Control is transferred to the entry point and runs until the function
is complete, transferring control back to next statement of the caller.
Typically, such functions are organized into those that are associated
with the domain as whole, a particular class or the instances of a class.
Such organization may be helpful to the programmer,
but since they are directly supported by the implementation language,
the `micca` run-time does not get involved in mediating them.

The run-time does get involved with those computations that must leave
off at some point,
waiting for some other action in the system or the external environment,
and then resume execution maintaining the past history.
This type of execution is implemented as a state machine.

=== State Machine Rules

Each class that has lifecycle behavior may have a state model associated
with it and each instance of that class will have a state variable
that allows it to execute as an state machine independent of the
other instances of the class.
The run-time supports a Moore type state model.

In the Moore formulation of state models,
activity code is associated with states and is executed
upon entry into a state.
This is distinguished from the Mealy formulation where
actions are associated with the transitions and are executed
upon exiting a state.
Much writing and discussion has been wasted attempting to
justify one type of state model over another.
What we know is they are computationally equivalent,
_i.e._ we can prove that there is no problem that you can solve
with a Moore machine that cannot also be solved with a Mealy
machine and _vice versa_.
Whether your application is easier to describe with one type rather
than the other is something that you alone may decide.
Moore machines are the traditional formulation for Executable UML
and they have the simplest implementation structures.
What we specifically reject here is any use of hierarchical state
models.
They are unnecessary and add complication that is not welcome.
The power of computation in Executable UML is derived from the
interaction of simple state machines each of which is tied to the
lifecycle of a particular class.
If you have some state model that is large and complicated where
you think some other kind of higher order structure is needed,
the usual reason is that you have multiple classes masquerading as one
and further refinement of your analysis is necessary.
That is not usually a welcome answer to the situation,
because if the analyst had been able to conceive of a better solution,
he/she would probably have done so already.
When state models are used to describe the lifecycle behavior of
a well defined class (and not sets of classes or the domain as whole)
there is no need for more complicated state execution schemes
such as hierarchies.

Generally, state actions affect other computations in the domain
by updating instance attribute values or by generating events to
other instances.
The important distinction here is that the application code of the
state actions does not deal with actually dispatching the events
nor does it control which event is dispatched next.

=== Event Types

There are three types of events:

. Transition events that cause transitions in state machines.
. Polymorphic events that are mapped at runtime across a generalization
hierarchy to transition events.
. Creations events that support asynchronous instance creation.

Creation events are transition events that are also associated with
an instance creation.
Our strategy for creation events is to create the instance in an inactive
state before queuing the event that will activate the instance and
cause a transition.
We will have need to distinguish between the various event types
and use an enumeration to accomplish that.

(((micca,Run Time Data,MRT_EventType)))
[source,c]
----
<<mrt interface simple types>>=
typedef enum {
    mrtTransitionEvent,
    mrtPolymorphicEvent,
    mrtCreationEvent
} MRT_EventType ;
----

The process of signaling an event involves the following steps:

. Obtain an *Event Control Block* (ECB) from the free pool of ECB's.
. Set the values of the fields in the ECB.
. Queue the ECB for later dispatch.

=== Event Control Block

The Event Control Block (ECB) is the primary data structure for signaling and
dispatching events.

(((micca,Run Time Data,MRT_ecb)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtecb {
    struct mrtecb *next ;
    struct mrtecb *prev ;
    MRT_EventCode eventNumber ;
    MRT_AllocStatus alloc ;
    MRT_Instance *targetInst ;
    MRT_Instance *sourceInst ;
    MRT_DelayTime delay ;
    alignas(max_align_t) MRT_EventParams eventParameters ;
} MRT_ecb ;
----

`next`, `prev`::
    Event queuing is done by doubly linked lists
    and the links are allocated as part of the ECB as the `next` and
    `prev` members.
`eventNumber`::
    The event number.
    Events are also encoded as small zero based sequential integers
    that are unique only within the class to which they are associated.
    Event numbers are ultimately used as an array index.
`alloc`::
    The `alloc` member is yet another part of _event-in-flight_ detection.
    We will discuss that more <<event-in-flight-error,below>>
    when we discuss event dispatch.
    For now, this member of the ECB holds the value of the allocation
    counter for the instance that is the target of the event.
    So when an event is generated, a copy of the current value of
    the `alloc` member of the instance is stored in the ECB.
`targetInst`::
    A pointer to the instance that is to receive the event.
`sourceInst`::
    A pointer to the instance that is the signaler of the event.
    If the event is generated outside the context of an instance
    (_e.g._ in an domain operation), then this member value is set to `NULL`.
    The `sourceInst` member also serves an important role in enforcing the rules
    for delayed events.
    More on that later.
`delay`::
    The number of milliseconds to delay before the event is posted.
`eventParameters`::
    Storage for any parameter values passed along with the event.
    We discuss event parameter data storage <<event-parameter-storage, below>>.


Event codes are captured by small integer values.

(((micca,Run Time Data,MRT_EventCode)))
[source,c]
----
<<mrt interface simple types>>=
typedef uint8_t MRT_EventCode ;
----

Delay times are in milliseconds and we wish to have a wide dynamic
range of times.

(((micca,Run Time Data,MRT_DelayTime)))
[source,c]
----
<<mrt interface simple types>>=
typedef uint32_t MRT_DelayTime ;
----

Note that there is no notion of priority contained in the ECB.
Some software architectures queue events in a priority order.
That is not supported here.
Frankly, if you need event priorities to make your system work,
then you need to revisit your design or look for a software architecture
that supports multiple threads of execution.

Like all the other data structures, there is a storage pool for ECB's
and we define a size for it here that can be overridden
on the compiler command line.
Sizing the pool for ECB's can be difficult.
It must be worst case allocation as running out of ECB's
is a fatal system error.
The pool must be sized to account for the maximum number of
events that can be in flight at the same time.
This includes delayed events, since they can be considered to be
slow flying events.

[source,c]
----
<<mrt constants>>=
#ifndef MRT_EVENTPOOLSIZE
#   define MRT_EVENTPOOLSIZE 32
#endif /* MRT_EVENTPOOLSIZE */
----

We must allocate the memory for the ECB storage.
As usual, storage is just an array of structures.

[source,c]
----
<<mrt static data>>=
static MRT_ecb mrtECBPool[MRT_EVENTPOOLSIZE] ;
----

=== Event Parameter Storage [[event-parameter-storage]]

We need to design how events that carry parameteric data will operate.
In this formulation of state machines,
events may carry additional parameters.
Space has to be allocated for that data.
The more difficult issue is to deal with the type of the parameter data.
There are a couple of solutions, neither of which is very satisfying.
We could collect all the parameters from all the state machines
in the system and create a giant union.
This would properly allocate the amount of parameter storage required
and provide a type safe manner to deal with that data.
Unfortunately, the parameters to states are scattered in very many
places in a system and gathering them together is a difficult
undertaking.

Here we take the approach of providing a fixed amount of memory and letting
state actions cast that memory into the appropriate type.
Needless to say, this can also be a source of errors, but is
much easier to manage.
This choice makes sense for many systems.
The number of states that use parametric data is usually small and using a
fixed size works better than might be expected upon first consideration.
The important point here is that events can carry data with them.
Many state machine formulations don't support this
and it is very difficult to correctly manage memory lifetime
without it.
It is one of those things that you might not use very often but
it is difficult to do without when you need it.

We fix the amount of memory used for event parameter storage,
allowing it to be overridden by the defining the appropriate macro.

[source,c]
----
<<mrt constants>>=
#ifndef MRT_ECB_PARAM_SIZE
#   define MRT_ECB_PARAM_SIZE  32
#endif /* MRT_ECB_PARAM_SIZE */
----

(((micca,Run Time Data,MRT_EventParams)))
[source,c]
----
<<mrt interface simple types>>=
typedef char MRT_EventParams[MRT_ECB_PARAM_SIZE] ;
----

The platform model has been very careful to insure the type signatures
of events and state activities.
When signaling an event,
the code generator will generate code to insert event parameters into
the data area using the signature associated with the event.
In the state activity,
the parameters will be moved into local variables according to the
signature of the state activity.

Note that the parameters are passed by value but care must be taken when
passing pointer references to data (_e.g._ `NUL` terminated strings passed as
pointers). The run-time does nothing to manage the life time of the
storage when values are passed by reference.

=== Event Queues

In this run-time architecture,
we do asynchronous event dispatch from an event queue.
This is one of the simplest ways to insure that we meet the
requirement that state activities run to completion.
Since a queue is used,
as a state activity executes and potentially signals other events,
we know those events will not be dispatched until after the state activity
completes.
Therefore,
there is no danger of a long complicated chain of event dispatching cycling
back around to alter the state of the instance or potentially modify some data
value that the state activity accesses after generating the event.
The guaranteed of run-to-completion for state activity execution is very
important.
We now examine the code that performs the queueing.

To serve as the head of the linked lists,
we define an event queue structure that just contains the
`next` and `prev` pointers.

(((micca,Run Time Data,MRT_EventQueue)))
[source,c]
----
<<mrt implementation aggregate types>>=
typedef struct mrteventqueue {
    MRT_ecb *next ;
    MRT_ecb *prev ;
} MRT_EventQueue ;
----

There are four queues that are used to manage events.

[source,c]
----
<<mrt static data>>=
static MRT_EventQueue eventQueue ;
static MRT_EventQueue tocEventQueue ;
static MRT_EventQueue delayedEventQueue ;
static MRT_EventQueue freeEventQueue ;
----

The `eventQueue` queue holds  events waiting to be dispatched.
The events in this queue are those signaled as part of an
ongoing thread of control.
The `tocEventQueue` queue holds events that start a new thread of
control.
Typically,
those are events generated outside of a domain or delayed events finally
being delivered.
The `delayedEventQueue` queue holds events that are
to be delivered by the run-time at some future time.
Finally, the `freeEventQueue` queue holds those ECB's
that are not currently begin used.
From the data structures and the semantics of the queuing,
a given ECB can be on at most one of the queues at any time.
Most of the time each ECB is on exactly one of the queues,
but there are short times when an ECB is not in any queue and a pointer
to the ECB is held in a local variable.

The operations that are performed on event queue are associated with
adding and removing elements.
This code is very conventional and I'm sure you seen it or
something very much like it many times before.

(((micca,Run Time Function,mrtEventQueueBegin)))
[source,c]
----
<<mrt static functions>>=
static inline
MRT_ecb *
mrtEventQueueBegin(
    MRT_EventQueue *queue)
{
    return queue->next ;
}
----

(((micca,Run Time Function,mrtEventQueueEnd)))
[source,c]
----
<<mrt static functions>>=
static inline
MRT_ecb *
mrtEventQueueEnd(
    MRT_EventQueue *queue)
{
    return (MRT_ecb *)queue ;
}
----

(((micca,Run Time Function,mrtEventQueueEmpty)))
[source,c]
----
<<mrt static functions>>=
static inline
bool
mrtEventQueueEmpty(
    MRT_EventQueue *queue)
{
    return queue->next == (MRT_ecb *)queue ;
}
----

(((micca,Run Time Function,mrtEventQueueInsert)))
[source,c]
----
<<mrt static functions>>=
static inline
void
mrtEventQueueInsert(
    MRT_ecb *item,
    MRT_ecb *at)
{
    item->prev = at->prev ;
    item->next = at ;
    at->prev->next = item ;
    at->prev = item ;
}
----

(((micca,Run Time Function,mrtEventQueueRemove)))
[source,c]
----
<<mrt static functions>>=
static inline
void
mrtEventQueueRemove(
    MRT_ecb *item)
{
    item->prev->next = item->next ;
    item->next->prev = item->prev ;
    item->prev = item->next = NULL ; // <1>
}
----
<1> Although it is not strictly necessary to NULL out the pointers when
an item is removed from the queue,
it does aid in debugging to know if an ECB is being held outside of
one of the queues.

Since we have a pool of ECB's,
we need some operations to manage the pool.
We start with initialization.
This places all the ECB's in the pool onto the free event queue.

(((micca,Run Time Function,mrtEventPoolInit)))
[source,c]
----
<<mrt static functions>>=
static void
mrtEventPoolInit(void)
{
    assert(MRT_EVENTPOOLSIZE >= 1) ;
    /*
     * Initialize the queue terminus structures.
     */
    eventQueue.next = eventQueue.prev = (MRT_ecb *)&eventQueue ;
    tocEventQueue.next = tocEventQueue.prev = (MRT_ecb *)&tocEventQueue ;
    delayedEventQueue.next = delayedEventQueue.prev = (MRT_ecb *)&delayedEventQueue ;
    freeEventQueue.next = freeEventQueue.prev = (MRT_ecb *)&freeEventQueue ;
    /*
     * Place all the event control blocks on the free event
     * queue.  Allocation occurs from there.
     */
    for (MRT_ecb *ecb = mrtECBPool ;
            ecb < mrtECBPool + MRT_EVENTPOOLSIZE ; ++ecb) {
        mrtEventQueueInsert(ecb, (MRT_ecb *)&freeEventQueue) ;
    }
}
----

Event allocation is just removing an ECB from the free list.
_N.B._ that running out of Event Control Blocks is fatal.

(((micca,Run Time Function,mrtAllocEvent)))
[source,c]
----
<<mrt static functions>>=
static inline 
MRT_ecb *
mrtAllocEvent(void)
{
    if (mrtEventQueueEmpty(&freeEventQueue)) {
        mrtFatalError(mrtNoECB) ;
    }

    MRT_ecb *ecb = freeEventQueue.next ;
    mrtEventQueueRemove(ecb) ;
    memset(ecb, 0, sizeof(*ecb)) ; // <1>
    return ecb ;
}
----
<1> We zero out the ECB. Although not strictly necessary,
it is convenient for debugging, especially when there are event
parameters involved.

(((micca,Run Time Function,mrtFreeEvent)))
[source,c]
----
<<mrt static functions>>=
static inline
void
mrtFreeEvent(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;

    mrtEventQueueInsert(ecb, (MRT_ecb *)&freeEventQueue) ;
}
----

We will have need to find particular events in a queue.
Events are identified by the source of the event, the target of the event
and the number of the event.

(((micca,Run Time Function,mrtFindEvent)))
[source,c]
----
<<mrt static functions>>=
static MRT_ecb *
mrtFindEvent(
    MRT_EventQueue *queue,
    MRT_Instance *sourceInst,
    MRT_Instance *targetInst,
    MRT_EventCode event)
{
    /*
     * Simple iteration through the list of events in the queue.
     */
    for (MRT_ecb *iter = mrtEventQueueBegin(queue) ;
            iter != mrtEventQueueEnd(queue) ;
            iter = iter->next) {
        if (iter->sourceInst == sourceInst && iter->targetInst == targetInst &&
                iter->eventNumber == event) {
            return iter ;
        }
    }
    return NULL ;
}
----

=== Event Signaling

Signaling an event is a very common operation for a state activity.
In this section,
we describe the code to accomplish event signaling.
As we mentioned before,
before an event can be signaled, we must obtain and fill in an ECB.
We start our description with a function that does just that.

*****
[source,c]
----
<<mrt external interfaces>>=
extern MRT_ecb *mrt_NewEvent(
    MRT_EventCode event,
    void *target,
    void *source) ;
----

`event`::
    The numerical code for the event.
`target`::
    A pointer to the instance that is to receive the event.
`source`::
    A pointer to the instance that is sending the event.
    If the event is being sent outside of the context of a class instance,
    then this argument should be set to `NULL`.

The `mrt_NewEvent` function allocates an ECB structure,
fills in the elements and returns the newly minted ECB.
*****

(((micca,Run Time Function,mrt_NewEvent)))
[source,c]
.Implementation
----
<<mrt external functions>>=
MRT_ecb *
mrt_NewEvent(
    MRT_EventCode event,
    void *target,
    void *source)
{
    MRT_Instance *targetInst = target ;
    MRT_Instance *sourceInst = source ;

    assert(targetInst != NULL) ;
    assert(targetInst->alloc != 0) ;
    assert(event < targetInst->classDesc->eventCount) ;

    MRT_ecb *ecb = mrtAllocEvent() ;

    ecb->eventNumber = event ;
    ecb->alloc = targetInst->alloc ;
    ecb->targetInst = targetInst ;
    ecb->sourceInst = sourceInst ;
    ecb->delay = 0 ;

    return ecb ;
}
----

=== Posting an Event

Once you have obtained an ECB initialized for the proper type of the
event, then you need to fill in any event parameter data.
Frequently, there are none.
Then the ECB is ready to be placed on a queue.
There is a distinction between events an instance sends to itself and those
that an instance sends to a different instance.
Self directed events are placed on the front of the event queue
so that they are dispatched in preference to the non-self directed events.
This is one of the fundamental execution rules.
Posting an event involves determining the correct place in the queue
for the ECB.
The decision is made based on the ECB values.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_PostEvent(
    MRT_ecb *ecb) ;
----

`ecb`::
    A pointer to an Event Control Block (ECB) that is to be queued
    for dispatch.

The `mrt_PostEvent` function queues the ECB pointed to by `ecb` to
an appropriate event queue.
*****

(((micca,Run Time Function,mrt_PostEvent)))
[source,c]
----
<<mrt external functions>>=
void
mrt_PostEvent(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;
    assert(ecb->targetInst != NULL) ;

        /*
         * The place in some event queue where the ECB will be inserted.
         */
    MRT_ecb *place ;

    if (ecb->sourceInst == NULL) { // <1>
        place = (MRT_ecb *)&tocEventQueue ;
    } else {
        place = (MRT_ecb *)&eventQueue ;
        if (ecb->sourceInst == ecb->targetInst) { // <2>
            while (place != mrtEventQueueEnd(&eventQueue) &&
                    place->sourceInst == place->targetInst) {
                place = place->next ;
            }
        }
    }

    mrtEventQueueInsert(ecb, place) ;
}
----
<1> All events that are signaled outside of a state activity start a
new thread of control.
<2> Ordinary transitioning events directed between distinct instances
are queued to the end of the event queue.
For self directed events we have to find the appropriate place.
That place is the first event in the queue that is not self directed.
The loop preserves the order of event dispatch in the unlikely
(but not illegal) case that a state activity sends multiple
self directed events.

=== Asynchronous Instance Creation

As we mentioned earlier,
asynchronous instance creation is accomplished by a combination of
creating an instance and then sending it an event.
The transition caused by the event then causes a state activity to be
executed.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void *
mrt_CreateAsync(
    MRT_Class const *targetClass,
    MRT_EventCode event,
    void *eventparams,
    size_t paramsize,
    void *sourceInst) ;
----

`targetClass`::
    A pointer to the class description for the instance that is to
    be created.
`event`::
    The number of the event to signal to the newly created instance.
`eventparams`::
    A pointer to the event parameters for the creation event.
`paramsize`::
    The number of bytes of event parameter data pointed to by `eventparams`.
`sourceInst`::
    A pointer to the class instance that is the source of the creation
    event. If the creation event is signaled outside of a state activity,
    then this value should be `NULL`.

The `mrt_CreateAsync` function asynchronously creates an instance of the
class described by `targetClass` and arranges for `event` to be
signaled to the new instance.
Note the event parameters must be provided.
After the function returns,
the instance has been created in an inactive state and the event
has been posted.
The return value is the pointer to the newly created instance and
can be used to initialize the values of attribute of the instance.
*****

(((micca,Run Time Function,mrt_CreateAsync)))
[source,c]
----
<<mrt external functions>>=
void *
mrt_CreateAsync(
    MRT_Class const *targetClass,
    MRT_EventCode event,
    void *eventparams,
    size_t paramsize,
    void *sourceInst)
{
    assert(targetClass != NULL) ;
    assert(targetClass->edb != NULL) ;
    assert(targetClass->edb->creationState >= 0) ;
    assert(event < targetClass->edb->eventCount) ;

    MRT_Instance *targetInst = mrt_CreateInstance(targetClass,
            targetClass->edb->creationState) ; // <1>
    targetInst->alloc = -targetInst->alloc ; // <2>

    MRT_ecb *ecb = mrtAllocEvent() ;
    ecb->eventNumber = event ;
    ecb->alloc = targetInst->alloc ;
    ecb->targetInst = targetInst ;
    ecb->sourceInst = sourceInst ;
    ecb->delay = 0 ;
    assert(paramsize <= sizeof(ecb->eventParameters)) ;
    if (paramsize > 0 && eventparams != NULL) {
        size_t copy = paramsize <= sizeof(ecb->eventParameters) ?
            paramsize : sizeof(ecb->eventParameters) ;
        memcpy(ecb->eventParameters, eventparams, copy) ;
    }

    mrt_PostEvent(ecb) ;

    return targetInst ;
}
----
<1> We want the instance created in the pseudo-initial state.
<2> The `alloc` member is made negative for instances that are awaiting
the dispatch of a creation event.
Effectively the negative `alloc` value signals that the memory is reserved
but the instance is not yet active.
During event dispatch, this value will be turned back into a positive one.

=== Delayed Events

The concept of a delayed event is to request the run-time to post
an event at some time in the future.
This implies that the run-time has access to some type of timing
facility by which it can know that a given amount of time has elapsed
and this implies that the run-time will hold on to the ECB until
that future time has arrived.

There is one significant XUML rule associated with delayed events.
There can be only one outstanding delayed event of a given event
type between any sending / receiving pair of instances
(which may be the same instance).
This is another way of stating that delayed events are identified by
their event name (or numerical encoding), the target instance
and the source instance.
There are a number of ways to interpret an attempt to generate
what amounts to a duplicate delayed event.
It could be considered an error, but that is inconvenient
and goes against the grain of our attempts to minimize run-time errors.
So the run-time regards an attempt to generate a delayed event
of the same name between the same sending and receiving pair as
a request to cancel the original event and create the new one
at its newly given time.
This turns out to be very convenient in practice, eliminating the
need to perform checks.
Cancelling and reinstating a new event turns out to be what is
desired in most circumstances.

To understand the implementation of delayed events,
it is necessary to understand the way the delayed event queue
is maintained.
The run-time has a delayed event queue where ECB's are placed awaiting
to be posted.
In servicing the delayed events,
we are particularly trying to avoid doing any periodic computation.
For example, we could treat the delayed event queue as a simple list
and wake up periodically and run down the list decrementing time values
and checking if any events have expired.
Such a scheme is easy to implement, but in highly embedded and power
sensitive application,
periodic activity of this type is wasteful and deemed inappropriate.

In this implementation, we keep the delayed event queue in time relative
order.
This design meets two important criteria; only a single source of timing
is used and there is no periodic execution activity.
The cost of meeting these criteria is the price paid
to find the appropriate place in the delayed event queue when a
delayed event is requested.

There is sometimes a temptation for analysts to try to use delayed
events for precise timing control over external interactions.
For example,
you could conceive of using delayed events as a means of generating
a pulse width modulated (PWM) square wave to control a motor.
Delayed events are generally *not* suitable for high speed, high precision
timing such as that required by motor control.
Since we are using only a single timing resource that is shared
in the system,
we are not able to achieve the precise jitter free timing that would be
needed for a PWM.
Most microcontrollers have many timing resources available in hardware
and they should be used for functions that require high precision.
What delayed events are most useful for is time outs for interactions
in the millisecond to minutes range and for those functions
where some jitter in the timing is acceptable (_e.g._ blinking an LED).
The delayed event time is only guaranteed to be the minimum amount
of time that is to elapse before the event is delivered.

There are three functions supplied for dealing with delayed events:

. Post a delayed event.
. Cancel a delayed event.
. Query the remaining time for a delayed event.

The unit of time for delayed events is milliseconds.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_PostDelayedEvent(
    MRT_ecb *ecb,
    MRT_DelayTime time) ;
----

`ecb`::
    A pointer to an Event Control Block (ECB) that is to be queued
    for dispatch.
`time`::
    The minimum number of milliseconds of time that must elapse before
    the event given by `ecb` is posted for dispatch.

The `mrt_PostDelayedEvent` function requests that the event given by
`ecb` be dispatched no sooner than `time` milliseconds from now.
The value of the `time` argument may be 0,
in which case the event is posted for dispatch immediately.
All delayed events start a new thread of control.
*****

(((micca,Run Time Function,mrt_PostDelayedEvent)))
[source,c]
----
<<mrt external functions>>=
void
mrt_PostDelayedEvent(
    MRT_ecb *ecb,
    MRT_DelayTime time)
{
    assert(ecb != NULL) ;

    ecb->delay = time ;
    if (time != 0) {
        mrtQueueDelayedEvent(ecb) ;
    } else {
        mrtEventQueueInsert(ecb, (MRT_ecb *)&tocEventQueue) ; // <1>
    }
}
----
<1> All delayed events start a new thread of control,
even those which have had no delay.

We see here the distinction between posting a delayed event and
the ordinary posting of an event.
For delayed events,
the event will end up on the delayed event queue or the thread of
control queue.
The determining factor is the delay time.
If the delay is zero, then the event goes to the thread of control
queue directly.
Otherwise, it is placed on the thread of control queue after the
delay time.
Delayed events never go to the ordinary event queue.

==== Posting Delayed Events

Posting delayed events involves finding the correct spot in the
time relative delayed event queue to place the new event.

(((micca,Run Time Function,mrtQueueDelayedEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtQueueDelayedEvent(
    MRT_ecb *ecb)
{
    ecb->delay = mrtMsecToTicks(ecb->delay) ;
    /*
     * Stop the timing queue so we may examine it.
     */
    mrtStopDelayedQueueTiming() ;
    /*
     * If the event already exists, remove it.
     */
    MRT_ecb *prevEvent = mrtFindEvent(&delayedEventQueue,
            ecb->sourceInst, ecb->targetInst, ecb->eventNumber) ;
    if (prevEvent) {
        mrtRemoveDelayedEvent(prevEvent) ;
    }
    /*
     * Insert the new event.
     */
    mrtInsertDelayedEvent(ecb) ;
    /*
     * Start the timer to expire for the first event
     * on the queue.
     */
    mrtStartDelayedQueueTiming() ;
}
----

There are five main actions of this function.

. Convert the delay value from millisecond units to
units of `ticks`.
A tick is platform specific.
Computers sometimes don't typically keep time in conventional human units,
particularly small embedded systems as we are dealing with.
However, we would like to run the delayed event queue in system
specific units to avoid as much unnecessary conversion as we can.
This conversion will be described below for each supported platform.
. Stop the timing of the delayed event queue.
More on this later but the goal of stopping the delayed event
queue timing is to freeze the state of the queue so that we
may operate on it.
. Determine if there is already an event matching the one begin posted.
This enforces the rule about not having two delayed events of the
same type between the same sending / receiving pair.
If one is found then it is removed.
. Assured of no duplicates, the new event can be inserted into the timing
queue.  We will see how that happens below.
. Finally, the timing of the delayed queue is started.


==== Canceling Delayed Events

Cancelling a delayed event is one of the more complicated delayed event
operations.
We must account for the various places where a delayed event may be queued.

A delayed event may be in one of two places:

. In the delayed event queue awaiting either waiting for its time to expire
or having already been marked as expired.
. In the thread of control event queue awaiting dispatch.

We will have more to say about event dispatch below,
but it is possible to try to cancel an event after its time has
expired but before it has been delivered to the target instance.
The mechanisms make the guarantee that after invoking
`mrt_EventDelayCancel`
the application can be assured that the event will *not* be
delivered until such time when it is posted again.
Note that it is possible to attempt to cancel a delayed event after
it has already been delivered.
This is not an error.
Unfortunately, the run-time code cannot turn time backwards.

*****
[source,c]
----
<<mrt external interfaces>>=
extern void
mrt_CancelDelayedEvent(
    MRT_EventCode event,
    void *target,
    void *source) ;
----

`event`::
    The number of the event.
`targetInst`::
    A pointer to the instance structure that is to receive the event.
`sourceInst`::
    A pointer to the instance structure that is sending the event.
    Events generated outside of a class instance set this argument to `NULL`.

The `mrt_CancelDelayedEvent` function cancels the delayed event
given by `event` and signaled from `source` to `target`.
After the return from this function the event is guaranteed not to be
delivered.
*****

(((micca,Run Time Function,mrt_CancelDelayedEvent)))
[source,c]
----
<<mrt external functions>>=
void
mrt_CancelDelayedEvent(
    MRT_EventCode event,
    void *target,
    void *source)
{
    MRT_Instance *targetInst = target ;
    MRT_Instance *sourceInst = source ;
    assert(targetInst != NULL) ;
    /*
     * Stop delayed queue so that we may examine it.
     */
    mrtStopDelayedQueueTiming() ;
    /*
     * Search for the event in the delayed event queue.
     */
    MRT_ecb *foundEvent = mrtFindEvent(&delayedEventQueue, sourceInst,
            targetInst, event) ;
    if (foundEvent) {
        /*
         * Removing from the delayed queue requires additional processing of
         * the delay times.
         */
        mrtRemoveDelayedEvent(foundEvent) ;
    } else {
        /*
         * If the event is not in the delayed queue, then search the thread of
         * control event queue. The timer could have expired and the event
         * placed in the queue.
         */
        foundEvent = mrtFindEvent(&tocEventQueue, sourceInst, targetInst, event) ;
        if (foundEvent) {
            mrtEventQueueRemove(foundEvent) ;
            mrtFreeEvent(foundEvent) ;
        }
        /*
         * We can get here, without finding the event in the delayed queue or
         * the thread of control event queue.  That's okay, it just amounts to
         * an expensive no-op and implies that the event has expired, was
         * queued and has already been dispatched or had never been generated
         * at all.
         */
    }
    mrtStartDelayedQueueTiming() ;
}
----

Like all operations dealing with the delayed event queue,
we must first put the queue in a state that we
can examine it without asynchronous timing services
modifying its state.
Then we search the delayed event queue for the event to cancel.
The only complication in the implementation is the need to search the thread of
control event queue should the ECB have already been expired off of the delayed
queue.

==== Time Remaining for a Delayed Event

The last provided operation on delayed events is to query the amount
of time remaining for a particular delayed event.
Since we hold the delayed events in sorted order of time differences,
the task of determining the amount of remaining time involves
traversing the queue and summing the time increments of all the
events in front of the event of interest.
The only special case here is what to do if we don't find the
delayed event at all.
In that case, zero is returned.

*****
[source,c]
----
<<mrt external interfaces>>=
extern MRT_DelayTime
mrt_RemainingDelayTime(
    MRT_EventCode event,
    void *target,
    void *source) ;
----

`event`::
    The number of the event.
`targetInst`::
    A pointer to the instance structure that is to receive the event.
`sourceInst`::
    A pointer to the instance structure that is sending the event.
    Events generated outside of a class instance set this argument to `NULL`.

The `mrt_RemainingDelayTime` function returns the amount of time
remaining before the `event` is posted from `source` to `target`.
The remaining time will be 0 if the event has already been posted or
is such a delayed event does not exist.
A return value of 0 does _not_ imply that the event has already been
dispatched.
*****

The algorithm for computing the remaining time is to simply walk the
delayed event queue from the beginning, summing up the
set of time delays until we reach the ECB of delayed event.

(((micca,Run Time Function,mrt_RemainingDelayTime)))
[source,c]
----
<<mrt external functions>>=
MRT_DelayTime
mrt_RemainingDelayTime(
    MRT_EventCode event,
    void *target,
    void *source)
{
    MRT_Instance *targetInst = target ;
    MRT_Instance *sourceInst = source ;
    assert(targetInst != NULL) ;

    mrtStopDelayedQueueTiming() ;
    /*
     * Iterate through the delayed event time and sum all the delay times to
     * give the total amount of time remaining for the found event.
     */
    MRT_DelayTime remain = 0 ;
    MRT_ecb *iter ;
    MRT_ecb *endOfQueue = mrtEventQueueEnd(&delayedEventQueue) ;
    for (iter = mrtEventQueueBegin(&delayedEventQueue) ; iter != endOfQueue ;
            iter = iter->next) {
        remain += iter->delay ;
        if (iter->sourceInst == sourceInst && iter->targetInst == targetInst &&
                iter->eventNumber == event) {
            break ;
        }
    }
    mrtStartDelayedQueueTiming() ;
    /*
     * Return the amount of time remaining for the event.  If we didn't find
     * the event, the just return 0.
     */
    return iter == endOfQueue ? 0 : mrtTicksToMsec(remain) ;
}
----

Note that zero is returned if we did not find the event on the
delayed queue.
Returning zero does _not_ tell us if the event has already been
dispatched or might be still in flight on the event queue.

==== Delayed Event Queue Operations

In this section we will look at the operations on the delayed
event queue itself.
As we have seen above,
the events in the delayed event queue are ordered by relative time.
Inserting and removing from the queue must keep the ECB's
in time relative order.

[source,c]
----
<<mrt forward references>>=
static void mrtInsertDelayedEvent(MRT_ecb *ecb) ;
----

(((micca,Run Time Function,mrtInsertDelayedEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtInsertDelayedEvent(
    MRT_ecb *ecb)
{
    /*
     * We walk down the queue to find the correct slot.  That slot is the first
     * place in the queue where our delay value is less than the delay value at
     * that place in the queue.  As we walk the queue, we subtract the delay
     * value of each entry we pass since that entry will have expired before
     * the one being inserted.
     */
    MRT_ecb *iter ;
    for (iter = mrtEventQueueBegin(&delayedEventQueue) ;
            iter != mrtEventQueueEnd(&delayedEventQueue) ;
            iter = iter->next) {
        /*
         * By keeping this comparison to be strictly less than, we preserve the
         * order of event dispatch to match that of event generation.
         */
        if (ecb->delay < iter->delay) {
            /*
             * We are going to insert before the entry pointed to by "iter".
             * Therefore, we need to decrease its delay value by the amount of
             * time that will have elapsed after the entry we are about to
             * insert expires.
             */
            iter->delay -= ecb->delay ;
            break ;
        } else {
            ecb->delay -= iter->delay ;
        }
    }
    /*
     * At this point we have found our place in the queue.  Either we are
     * between entries or this delay was longer than the cumulative delays of
     * all the ECB's in the queue. Insert the ECB.
     */
    mrtEventQueueInsert(ecb, iter) ;
}
----

Removing an entry from the queue is much simpler.
The only job here is to account for the time that the entry would
have consumed had it been left in the queue.
That time must be added to its next neighbor (if there is one).

[source,c]
----
<<mrt forward references>>=
static void mrtRemoveDelayedEvent(MRT_ecb *ecb) ;
----

(((micca,Run Time Function,mrtRemoveDelayedEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtRemoveDelayedEvent(
    MRT_ecb *ecb)
{
    /*
     * If we are not at the end of the queue, all the delay from the removed
     * entry is added onto the next entry in the queue.
     */
    if (ecb->next != mrtEventQueueEnd(&delayedEventQueue)) {
        ecb->next->delay += ecb->delay ;
    }
    /*
     * Remove the ECB from the delayed queue.
     */
    mrtEventQueueRemove(ecb) ;
    /*
     * Return the ECB back to the pool.
     */
    mrtFreeEvent(ecb) ;
}
----

==== Expired Events in the Delayed Event Queue

When the delay time expires there are several ways to deal with the events
that need to be dispatched.
One approach would be simply to sync to the background and let code
run there to remove expired events from the delayed event queue
and restart the timer.
Such a design is subject to problematic, unpredictable timing skew.
After the timer source has expired and posted the synchronization request,
the background may not execute immediately.
Either a currently executing state action or a previously queued
sync function would delay the transfer of expired events from the delayed
queue to the event queue.
If there if another delayed event to expire,
we would like to start the expiration timing without inserting some
unpredictable time in between.
Essentially, we would like to overlap the timing of the next delayed
event with the time it takes to complete the current activities and
execute the timer sync request.

This design chooses to mark the events in the delayed event queue as
expired and that provides a means of knowing which events in the delayed
queue are active.
The question then is how to signify that an event in the delayed event queue
has expired.
Since a delay value of 0 is meaningful, we use a delay value of
the maximum for a delay time as the expired marker.
We mark the `delay` member of the ECB with a special value to indicated that
it has expired but not yet been removed from the delayed event queue.
This allows us to keep track of the state of the ECB in the delayed
event queue and still find the next timer interval during the timer
interrupt service routine.

[source,c]
----
<<mrt implementation constants>>=
#define MRT_DELAY_EXPIRED  UINT32_MAX
----

The `mrtExpireDelayedEvents` function is run to traverse the delayed event
queue and mark any events that have a delay value of 0 as expired.
It is used both in the delayed event timer service as well as in the background
processing of the delayed event queue.
The return value is pointer to an ECB.
This will be `NULL` if there are no other events in the delayed queue that
require timing.
Otherwise,
the returned ECB pointer will reference the first unexpired,
non-zero delay event.
The semantics are a bit strained,
but the function is used for two distinct purposes.

[source,c]
----
<<mrt forward references>>=
static MRT_ecb *mrtExpireDelayedEvents(void) ;
----

(((micca,Run Time Function,mrtExpireDelayedEvents)))
[source,c]
----
<<mrt static functions>>=
static MRT_ecb *
mrtExpireDelayedEvents(void)
{
    /*
     * Iterate along the delayed event queue.
     */
    for (MRT_ecb *iter = mrtEventQueueBegin(&delayedEventQueue) ;
            iter != mrtEventQueueEnd(&delayedEventQueue) ;
            iter = iter->next) {
        if (iter->delay == 0) {
            /*
             * Mark all the events that have zero delay time as expired.
             */
            iter->delay = MRT_DELAY_EXPIRED ;
        } else if (iter->delay != MRT_DELAY_EXPIRED) {
            /*
             * Stop at the first non-zero delay time.  This marks the boundary
             * of events that need additional delay time.  The first such event
             * is the next amount of time to delay.
             */
            return iter ;
        }
        /*
         * else ... Skip any events that might already be expired.
         */
    }
    /*
     * We have run the queue without finding an unexpired event.
     */
    return NULL ;
}
----

The function below is then run in the background to re-queue the
expired events.

(((micca,Run Time Function,mrtTransferExpiredEvents)))
[source,c]
----
<<mrt static functions>>=
static void
mrtTransferExpiredEvents(void)
{
    /*
     * Iterate through the delayed event queue looking for those entries that
     * have been marked as expired.
     */
    for (MRT_ecb *iter = mrtEventQueueBegin(&delayedEventQueue) ;
            iter != mrtEventQueueEnd(&delayedEventQueue) &&
            iter->delay == MRT_DELAY_EXPIRED ; /* empty 3rd expression */) {
        /*
         * Advance the iterator here, because we are about to invalidate it by
         * removing the entry from the queue.
         */
        MRT_ecb *ecb = iter ;
        iter = iter->next ;
        /*
         * Remove the ECB from the delayed queue and insert it into the thread
         * of control event queue for dispatch.
         */
        mrtEventQueueRemove(ecb) ;
        mrtEventQueueInsert(ecb, (MRT_ecb *)&tocEventQueue) ;
    }
}
----

The concept of starting the delayed event queue timing is
associated with starting the timing resource with the delay time of the
event on the front of the delayed queue.
We move the delay value from the head of the delayed event queue
into the timer and zero the delay member.

[source,c]
----
<<mrt forward references>>=
static void mrtStartDelayedQueueTiming(void) ;
----

(((micca,Run Time Function,mrtStartDelayedQueueTiming)))
[source,c]
----
<<mrt static functions>>=
static void
mrtStartDelayedQueueTiming(void)
{
    if (!mrtEventQueueEmpty(&delayedEventQueue)) {
        MRT_ecb *ecb = mrtEventQueueBegin(&delayedEventQueue) ;
        assert(ecb->delay != 0) ;
        mrtSysTimerStart(ecb->delay) ;
        ecb->delay = 0 ;
    }
}
----

An analogous operation is needed to stop the queue timing.
Any remaining time is set back into the first entry on the queue.
This puts the queue into a state where ECB's can be inserted,
deleted or summed to find the time remaining for an event.

[source,c]
----
<<mrt forward references>>=
static void mrtStopDelayedQueueTiming(void) ;
----

(((micca,Run Time Function,mrtStopDelayedQueueTiming)))
[source,c]
----
<<mrt static functions>>=
static void
mrtStopDelayedQueueTiming(void)
{
    /*
     * Avoid the whole thing if there is nothing in the delayed event queue.
     */
    if (!mrtEventQueueEmpty(&delayedEventQueue)) {
        /*
         * Stop the timer, obtaining the residual time.
         */
        MRT_DelayTime remain = mrtSysTimerStop() ;
        /*
         * There are two cases here. It is possible for the remaining time
         * returned from mrtSysTimerStop() to be zero. This can happen if the
         * physical timing resource (which might be running asynchronously to
         * the processor) happens to expire within a single tick as we are
         * stopping it.
         */
        if (remain == 0) {
            /*
             * Since the timer has expired we must mark any events with a zero
             * delay time value as expired and, since we are running in the
             * background here, transfer the expired events to be dispatched.
             */
            mrtExpireDelayedEvents() ;
            mrtTransferExpiredEvents() ;
            /*
             * At this point, either the delayed event queue is empty, or the
             * event at the head of the queue has a non-zero delay time.
             */
        } else {
            /*
             * It is possible that the timing resource expired and its
             * interrupt service ran just before we could get the timer
             * stopped. That would mean that there are expired events on the
             * delayed queue at this point and we need to transfer them off the
             * delayed queue to be dispatched.
             */
            mrtTransferExpiredEvents() ;
            /*
             * If any events expired, the delayed event queue might now be
             * empty. However, if the queue is not empty, we must make sure the
             * entry at the head preserves the remaining amount of time that
             * needs to elapse.
             */
            if (!mrtEventQueueEmpty(&delayedEventQueue)) {
                MRT_ecb *ecb = mrtEventQueueBegin(&delayedEventQueue) ;
                assert(ecb->delay == 0) ;
                ecb->delay = remain ;
            }
        }
    }
}
----

Conceptually, starting and stopping the queue timing moves the time value
of the first ECB on the delay queue into and out of the real timing
resource (whatever that may be).
So when the the delayed event queue timing is running,
at least the first ECB on the queue will have a zero delay time.
When it is stopped, we must insure that the first queued ECB has a non-zero
delay time.

There is a race condition between the background code executing
`mrtStopDelayedQueueTiming()` and
the timer services that may run asynchronously as an interrupt.
After the return from `mrtSysTimerStop()` the timer will have been stopped
and will not cause any interrupt.
However, at any time previous to that the timer interrupt might have gone off
and expired one or more events.
Although a sync function will have been posted,
it will *not* have had an opportunity to run.
So we must make sure to transfer any expired events to the event queue.
This insures that the event generation does not get out of order.

The other complication here is that we might stop the timer just the instant
before it expired.
In this case the underlying timer services might think that there is no
time left on the timer, but the timer interrupt did not actually occur.
This is the case where we just win the race as opposed to the previous
situation where we just lost the race.
So, just in case, we transfer any events on the delay queue that happen
to show zero delay times to the event queue.


The `mrt_TimerExpireService` function is provided
for the asynchronous timer execution to call that performs task of expiring
events and finding the next time that needs to be placed in the timer.

[source,c]
----
<<mrt external interfaces>>=
/*
 * Must be invoked from interrupt service level only!
 */
extern MRT_DelayTime
mrt_TimerExpireService(void) ;
----

(((micca,Run Time Function,mrt_TimerExpireService)))
[source,c]
----
<<mrt external functions>>=
MRT_DelayTime
mrt_TimerExpireService(void)
{
    /*
     * Sync to the background to request the expired events be transferred to
     * the event queue.
     */
    mrt_SyncRequest(mrtExpiredEventService) ;
    /*
     * Mark the delayed events as expired, returning a pointer to the first
     * unexpired event.
     */
    MRT_ecb *unexpired = mrtExpireDelayedEvents() ;
    MRT_DelayTime nextTime ;
    if (unexpired) {
        /*
         * If there is an unexpired event, then its delay time is the next time
         * to expire. We return that time and zero out the delay time.
         */
        assert(unexpired->delay != 0) ;
        nextTime = unexpired->delay ;
        unexpired->delay = 0 ;
    } else {
        /*
         * Otherwise, there is nothing else to time.
         */
        nextTime = 0 ;
    }

    return nextTime ;
}
----

. The function assumes it is called from interrupt service level,
_i.e._ it assumes that it may touch the delayed
event queue with impunity since it cannot be interrupted by other
code that might manipulate the state of those queues.
. The function returns the next time to expire.
The caller is responsible for placing that time into the
timer facility if it is non-zero.
If the returned time is zero,
then the timer facility is not currently needed and should
remain stopped.

Notice that the function `mechExpiredEventService` is queued
as as sync function to perform the last step of moving
the expired events to the event queue.
The run-time uses its own internal facilities to post this
function as a sync function.
This insures that delayed event posting is no different than
any other interrupt synchronization and preserves the notion that the event
queues are not accessed by interrupt service code and therefore do
not need to be guarded by a critical section.

(((micca,Run Time Function,mrtExpiredEventService)))
[source,c]
----
<<mrt static functions>>=
static void
mrtExpiredEventService(
    MRT_SyncParams const *params) /* Not used */
{
    /*
     * Since the expired event queue is accessed here, we must make sure that
     * the timer interrupt does not go off.
     */
    mrtSysTimerMask() ; // <1>
    mrtTransferExpiredEvents() ;
    mrtSysTimerUnmask() ;
}
----
<1> We do have to guard the delayed event queue from any timer interrupt.

==== Timing Considerations

With timing being such a common activity in programming,
there are very many system specific situations that arise in
obtaining timing services on any particular platform.
When running on top of an operating system,
it will provide the necessary timing services.
Unfortunately, the interface to those services varies from OS to OS.
On bare metal platforms,
generally you will have to get timer peripherals and interrupts
involved.
We will do what we can here to factor away the essential logic
from the platform specific,
but note that getting delayed event services running on any particular
platform will require some additional work.

We will try to make as few assumptions about the available timing services
of the platform as we can.
Here are the constraints on the timing services:

* The is only a single source of timing.
    That timing source allows us to specify some time value to it
    and it will respond with some notification when the given time
    has elapsed.
* It is possible to stop the timing and determine how much time
    remains before it expires.
* It is not acceptable to execute code periodically that does nothing.
    This is to account for battery powered devices that cannot afford to
    wake up and check a timing queue only to find out that there is nothing
    to do.
    Activity must be strictly event driven and that implies that
    we can get positive notification when a time period has elapsed.

=== Event Dispatch

Finally, we arrive at the point where we can discuss event dispatching.
Up until this time,
we have been concerned with signaling events,
_i.e._ queuing events to be delivered.
Now we examine the means by which events are delivered to target instances.

First,
we must clarify that despite the fact we have been discussing the
_event queue_ as if it were a single entity,
there are in fact two queues used for dispatching events.
The reason for two queues is that we need a way to determine the boundaries
of a _thread of control_.

All events that originate outside of a state activity or are the
result of a delayed event start a thread of control.
The thread of control ends when all the subsequent events that originate
from the event starting the thread of control have been dispatched
and any activities resulting from the event dispatch has been run.
A thread of control is an important concept because its boundaries
determine when the data model must be consistent and when we can
check the referential integrity.

So our strategy is to use one queue to hold events that start a
thread of control and another queue to hold the events that are awaiting
dispatch for the ongoing thread of control.
When the queue for the ongoing thread of control is empty,
then we can start a new thread of control by using events queued
to the thread of control queue.
When both queues are empty,
there is no work to be done and we must wait for subsequent
interactions of the system with the outside world.

==== Dispatching One Event

When the run-time needs to dispatch an event it invokes the
`mrtDispatchOneEvent` function.
This function deals with the two event queues and determines if we
are at the end of a thread of control.

(((micca,Run Time Function,mrtDispatchOneEvent)))
[source,c]
----
<<mrt static functions>>=
static bool
mrtDispatchOneEvent(void)
{
        #ifdef MRT_ARM_ARCH_7M
    __set_BASEPRI(MRT_PENDSV_PRIORITY) ; // <1>
        #endif /* MRT_ARM_ARCH_7M */

    MRT_EventQueue *queue ;
    if (mrtEventQueueEmpty(&eventQueue)) {
        mrtEndTransaction() ; // <2>
        queue = mrtEventQueueEmpty(&tocEventQueue) ? NULL : &tocEventQueue ;
    } else {
        queue = &eventQueue ;
    }

    bool dispatched ;
    if (queue != NULL) {
        MRT_ecb *ecb = queue->next ;
        mrtEventQueueRemove(ecb) ;
        mrtDispatchEvent(ecb) ;
        mrtFreeEvent(ecb) ; // Return the ECB to the pool.

        dispatched = true ;
    } else {
        dispatched = false ;
    }

        #ifdef MRT_ARM_ARCH_7M
    __set_BASEPRI(0) ;
        #endif /* MRT_ARM_ARCH_7M */

    return dispatched ;
}
----
<1> This is part of the exception processing that is used in the ARM 7M
platform and is explained below.
<2> Here we discover that the thread of control is over and we examine
the data model to insure referential integrity.

There are two distinct types of events: transitioning events and
polymorphic events.
The event types are distinct in that the numerical encoding of the
events is used in different ways.
In the <<platform-event-class,platform model>>,
all the events for a given state model must have distinct names.
The distinction in the platform model between Transitioning Event
and Deferred Event is the difference we now see between an ordinary
transition event and a polymorphic event.
The code generator will assign a unique integer to each event.
The set of transition events will be encoded sequentially
starting at 0 up to E - 1,
where E is the number of transitioning events in the state model.
Polymorphic events for the class are then encoded starting at E
up to E + P - 1, where P is the number of polymorphic events.
Note that only superclass classes that have both polymorphic events
(either defined or inherited) and
a state model of its own will have both transition events and
polymorphic events defined for it.
However, all events have a unique name in the platform model
and a unique numerical encoding in the run-time.

Encoding the event number in this fashion makes it convenient to
identify an event for a class when, for example, it is in a delayed
event queue.
As we will see below,
at dispatch time, any polymorphic event numbers will have the number
of transition events for the class (E in the discussion above)
subtracted from their encoded number so that they can be used as an
array index into the data structures used for polymorphic event mapping.

There is a secondary usage of transition events for asynchronous
instance creation.
A transition event that is dispatched when the current state of the
instance is the pseudo-initial creation state is deemed a creation event.
We wish to treat creation events separately because of the
design strategy we have used to implement asynchronous instance creation.
The strategy creates the instance in the creation state, marks its
memory slot as allocated but inactive,
and queues a transition event.
When the event is dispatched, the instance memory slot must be marked 
active and a transition event dispatch happens.
By marking the instance as inactive, but allocated, we can make sure
the instance data is not accessed during the time between when it
was created and when the creation event is actually dispatched.
But, because there is additional processing to be done before a creation
event is dispatched as a transition event,
we have to be able to identify a transition event as being using
in an asynchronous instance creation context.

We provide separate functions to dispatch each event type.

[source,c]
----
<<mrt forward references>>=
static void mrtDispatchTransitionEvent(MRT_ecb *ecb) ;
static void mrtDispatchPolymorphicEvent(MRT_ecb *ecb) ;
static void mrtDispatchCreationEvent(MRT_ecb *ecb) ;
----

Once an event has been chosen for dispatch,
the logic to determine the type of the event and, therefore,
which dispatch function to invoke is shown below.

[source,c]
----
<<mrt forward references>>=
static void mrtDispatchEvent(MRT_ecb *ecb) ;
----

(((micca,Run Time Function,mrtDispatchEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDispatchEvent(
    MRT_ecb *ecb)
{
    assert(ecb != NULL) ;
    assert(ecb->targetInst != NULL) ;

    MRT_Class const *classDesc = ecb->targetInst->classDesc ;
    assert(classDesc != NULL) ;

    MRT_edb const *edb = classDesc->edb ;
    if (edb == NULL) {
        mrtDispatchPolymorphicEvent(ecb) ;
    } else {
        if (ecb->eventNumber < edb->eventCount) {
            if (ecb->targetInst->currentState == edb->creationState) {
                mrtDispatchCreationEvent(ecb) ;
            } else {
                mrtDispatchTransitionEvent(ecb) ;
            }
        } else {
            assert(classDesc->pdb != NULL) ;
            assert(ecb->eventNumber - edb->eventCount <
                    classDesc->pdb->eventCount) ;
            mrtDispatchPolymorphicEvent(ecb) ;
        }
    }
}
----

Event typing is discovered by first determining if there are any
transition events.
If not, then we must have a polymorphic event (and consequently,
its numbering will have started at 0).
Otherwise,
if the event number falls in the range of transition events,
then it must be either an ordinary transition event or a transition
event used as a creation event.
Finally, for the case where there are both transition and polymorphic
events defined for the class,
events outside of the transition event range must be dispatched
as polymorphic events.

In the sections below,
we consider the dispatch of each particular event type.

=== Transition Event Dispatch

The most frequent event type to dispatch is that of a transitioning event to a
state machine.
We refer to these event types as, _transition_, only to distinguish them from
the more complicated and less frequent used polymorphic and creation event
types.

Dispatching an event in its simplest terms involves using the
current state of the instance and the event number contained in
an ECB as indices into the transition matrix.
The transition matrix is the same for all instances of a class.
The entry in the transition matrix is the new state to which a
transition is to be made.
There are a few additional rules needed to
account for _ignored_ and _can't happen_ events.

Ignored events (IG) cause no transition.
Events that are ignored can be thought of as an optimization
on the state transition graph.
Ignored events could be handled by adding a new state to which
the ignored event makes a transition and that new state
has all the other outbound transitions that the original state had.
Clearly, having the concept of ignored events saves much clutter
in the state transition graph.

When the analyst considers a transition to be a logical impossibility,
then it is declared as a can't happen (CH) event.
In the micca run-time,
a can't happen transition is treated as a fatal system error.
This is a policy decision of the architecture,
so *do not* assume that _can't happen_ means
_shouldn't happen_ or _has a low probability of happening_.
In this architecture, can't happen means absolutely impossible to
happen and if it does happen then there has been a tear in the
logic / space / time continuum and the only course available is to
give up and declare a fatal error.

The data structure used for transitioning event dispatch
is called an *Event Dispatch Block* (EDB).
The code generator supplies an EDB for each class (and assigner)
that has a state model.
Below we will see how all this ties together.
For now, we discuss the data structure and how it is used.

(((micca,Run Time Data,MRT_edb)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrteventdispatchblock {
    MRT_DispatchCount stateCount ;
    MRT_DispatchCount eventCount ;
    MRT_StateCode initialState ;
    MRT_StateCode creationState ;
    MRT_StateCode const *transitionTable ;
    MRT_PtrActivityFunction const *activityTable ;
    bool const *terminalStates ;

#       ifndef MRT_NO_NAMES
    char const *const *stateNames ;
#       endif /* MRT_NO_NAMES */
} MRT_edb ;
----

`stateCount`::
    The number of states in the transition matrix.
`eventCount`::
    The number of events in the transition matrix.
`initialState`::
    The number of the state that is the default state when an
    instance is created synchronously.
`creationState`::
    The number of the state that is the default state when an
    instance is created asynchronously.
`transitionTable`::
    A pointer to the transition matrix.
`activityTable`::
    A pointer to the state activities.
`terminalStates`::
    A pointer to a boolean array that determines if a state is a
    terminal state.
`stateNames`::
    A pointer to an array of character pointers to the names of the
    class states.
    This information is used in tracing event dispatch.

The dimensions of the state transition matrix are `stateCount` rows
by `eventCount` columns.
The counts are held as small integers.

(((micca,Run Time Data,MRT_DispatchCount)))
[source,c]
----
<<mrt interface simple types>>=
typedef uint8_t MRT_DispatchCount ;
----

The transition table is in state major order,
_i.e._ the current state is used to index conceptual rows and the event number
is used to index conceptual columns.
The dimensions of the transition table are captured in the EDB to allow run
time bounds checking during event dispatch.

The basic transition algorithm is to use the current state of an instance and
the event number of an event as the indices into the transition matrix.
The entry in the transition matrix is the new state.
Notice the very simple data structures required for Moore state machines.

The new state is used as an index into the `activityTable`.
The activity table is an array of function pointers to the activity associated
with each state.

(((micca,Run Time Data,MRT_ActivityFunction)))
[source,c]
----
<<mrt interface simple types>>=
typedef void MRT_ActivityFunction(void *const, void const *const) ;
typedef MRT_ActivityFunction *MRT_PtrActivityFunction ;
----

Since Moore state machines associate the activity with the state,
that code segment is supplied as a function matching the prototype above.
The first argument is a pointer to the instance receiving the event.
It is `void` typed and state activities are expected to recover
the correct type by casting the pointer to the be of the proper
class data structure.
The second argument is a pointer to the event parameters.
Again, the correct type is recovered in the state activity to match
the parameter signature of the activity.
Notice that assigning back into event parameters does not make any sense as the
parameter values are discarded after the state action completes.

One other feature of the state machine dispatch rules regards terminal states.
A state may be marked as terminal and if so,
then the run-time will destroy the instance when the state action is completed.
The `terminalStates` member points to an array, indexed by state number,
that specifies if a particular state is indeed a terminal state.
As is frequently the case, the class may have no terminal states.
In this case, `terminalState` member may be set to `NULL` to
indicate this fact and save the storage of the final state booleans
(_i.e._ there is no need to have an array of `false` values).

(((micca,Run Time Function,mrtDispatchTransitionEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDispatchTransitionEvent(
    MRT_ecb *ecb)
{
    MRT_Instance *targetInst = ecb->targetInst ;
    MRT_edb const *edb = targetInst->classDesc->edb ;
    assert(edb != NULL) ;
    assert(edb->stateCount > targetInst->currentState) ;
    assert(edb->eventCount > ecb->eventNumber) ;
    /*
     * Check for the "event-in-flight" error. This occurs when an instance is
     * deleted while there is an event for that instance in the event queue.
     * For this architecture, such occurrences are considered as run-time
     * detected analysis errors.
     */
    if (targetInst->alloc != ecb->alloc) {
#           ifndef MRT_NO_NAMES
        mrtFatalError(mrtEventInFlight,
                ecb->sourceInst ? ecb->sourceInst->classDesc->name : "?",
                ecb->sourceInst ? ecb->sourceInst->name : "?",
                targetInst->classDesc->eventNames[ecb->eventNumber],
                targetInst->classDesc->name,
                targetInst->name ? targetInst->name : "?") ;
#           else
        mrtFatalError(mrtEventInFlight, ecb->sourceInst, ecb->eventNumber,
                targetInst) ;
#           endif /* MRT_NO_NAMES */
    }
    /*
     * Fetch the new state from the transition table.
     */
    MRT_StateCode newState = *(edb->transitionTable +
            targetInst->currentState * edb->eventCount + ecb->eventNumber) ;

#       ifndef MRT_NO_TRACE
    /*
     * Trace the transition.
     */
    mrtTraceTransitionEvent(ecb->eventNumber, ecb->sourceInst,
            ecb->targetInst, targetInst->currentState, newState) ;
#       endif /* MRT_NO_TRACE */

    /*
     * Check for a can't happen transition.
     */
    if (newState == MRT_StateCode_CH) {
#           ifndef MRT_NO_NAMES
        mrtFatalError(mrtCantHappen, targetInst->classDesc->name,
                targetInst->name ? targetInst->name : "?",
                targetInst->classDesc->edb->stateNames[targetInst->currentState],
                targetInst->classDesc->eventNames[ecb->eventNumber]) ;
#           else
        mrtFatalError(mrtCantHappen, targetInst, targetInst->currentState,
                ecb->eventNumber) ;
#           endif /* MRT_NO_NAMES */
    } else if (newState != MRT_StateCode_IG) {
        assert(newState < edb->stateCount) ;
        /*
         * We update the current state to reflect the transition before
         * executing the activity for the state.
         */
        targetInst->currentState = newState ;
        /*
         * Invoke the state activity if there is one.
         */
        MRT_PtrActivityFunction activity = edb->activityTable[newState] ;
        if (activity) {
            activity(targetInst, &ecb->eventParameters) ;
        }
        /*
         * Check if we have entered a terminal state. If so, the instance is
         * deleted.
         */
        if (edb->terminalStates && edb->terminalStates[newState]) {
            mrt_DeleteInstance(targetInst) ; // <1>
        }
    }
}
----
<1> This is where asynchronous instance deletion occurs.
If the state is designated as terminal,
then the run-time deletes the instance after its state activity completes.

The processing for dispatching a transition event follows directly from
the definitions.
After the check for an event-in-flight error,
we perform the indexing into the transition matrix.
The indexing expression results from the need to treat a linear
set of bytes as a two dimensional matrix.
We can't type it any differently since we have different sized
transition matrices for each different state model.
After obtaining the new state,
we must determine if we are actually going to make a transition
or if the event is to be ignored or considered a fatal error.
Assuming that we are transitioning,
then the associated state action is found and executed.
Note that empty state actions may be dispensed with and a `NULL`
inserted into the action table.
After the action, we check if the instance entered a final state.

[[event-in-flight-error,event-in-flight error]]
We are finally in a position to explain the event-in-flight error
in detail.
The mechanisms detect only one analysis error at run-time,
the delivery of an event to an instance that has been deleted.
Because events are queued,
it is possible for an event to be generated for an instance and then
while the event is on the queue awaiting to be delivered,
the target instance is deleted by some other code executing.
For a single threaded architecture,
this is considered an analysis error.
Deliverying events to deleted instances should never happen!
The analytical model is responsible for insuring that instance deletion is
accomplished only after there are no events awaiting to be delivered.
However, it can happen and the run-time detect and catch this.

A significant difficulty arises in systems that use distinct memory pools
for the instances of each class.
If an instance is destroyed and another one created, they may very
well end up in exactly the same array slot and therefore have exactly
the same instance pointer value.
So, a pathological case where an event is generated for an instance,
the instance is deleted and then re-created while the event is queued
could end up delivering the event to the newly recreated instance.
Quite the wrong thing to do.

The strategy used here is to vary the number in the
`alloc` field of the instance each time it is allocated.
Then a copy of the `alloc` field is placed in the ECB
when the event is queued.
In effect,
the real identifier of an instance is its pointer plus the value of
the `alloc` field.
When dispatched, the values of the `alloc` fields in the
two structures must match or else the target instance has
been destroyed and re-created in the same memory slot.
Of course, the observant reader will have seen that in the case where
the target instance is destroyed and recreated 16,000 times while the event
is queued will result in the event being dispatched to the wrong
instance.
This is considered such a remote possibility as to be of no practical concern.

=== Polymorphic Event Dispatch

Polymorphic events in their full generality can be complex,
but they are based on a simple idea.
In fact, there is nothing going on in the dispatch of polymorphic events
that could not otherwise be handled in the state activity.
Strictly speaking,
polymorphic events must be considered an optimization,
but a very convenient and significant one.
Previously,
we have described the rules concerning polymorphic events.

When a polymorphic event is dispatched,
we must traverse the generalization from the superclass to the subclass
to determine the type of the subclass.
Conceptually, determining which subclass is related to a particular
instance of a superclass is not difficult.
There are two fundamental steps in dispatching a polymorphic event:

. Determining which subtype instance is currently related to a supertype
instance.
. Mapping the polymorphic event encoding in the supertype to an event encoding
in the subtype.

In order to accomplish the first step,
the run-time has know how the generalization relationship is stored in the
instances.
The run-time supports two different schemes of storing the generalization
relationship,
either as a pointer reference or as a union member of the superclass
structure.

Both relationship storage techniques have their uses and we will not
discuss the pros and cons of one choice over another here.
If the generalization relationship is stored as a reference,
then the superclass instances will contain an instance pointer to a subtype.
If the generalization relationship is stored as a union,
then the superclass structure will a member that is a union of the data types
of all the subtypes of the generalization hierarchy.

As we will see,
if we can locate where in the superclass instance structure
the subclass encoding and the subclass reference or union are located,
then we can determine the type of the subclass instance to which 
a particular superclass instance is related.
To do that we assume that the there is a data type that can hold
the byte offset from the beginning of the superclass instance structure
to the required information.
As you can probably imagine,
this will be a tricky piece of code since it must pick out
information from an arbitrary data structure in a generic fashion.

(((micca,Run Time Data,MRT_AttrOffset)))
[source,c]
----
<<mrt interface simple types>>=
typedef size_t MRT_AttrOffset ;
----

==== Polymorphic Event Mapping

We now turn our attention to the actual mapping of polymorphic events.
The mapping is analogous to the mapping of current state and event to
a new state for normal event dispatch.
For polymorphic events,
the mapping is from subclass code of the currently related subclass and
polymorphic event number to a new event.
The data structure required for this is given by:

(((micca,Run Time Data,MRT_gdb)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtgendispatchblock {
    struct mrtrelationship const *relship ;
    MRT_EventCode const *eventMap ;
} MRT_gdb ;
----

`relship`::
    A pointer to the relationship description for the relationship
    across which the polymorphic event will be dispatched.
`eventMap`::
    The `eventMap` member is a pointer to the mapping
    of polymorphic events for the generalization.
    This mapping is indexed in major order by subclass code and in
    minor order by polymorphic event number.

A key realization here is that as we are mapping along a generalization
relationship,
a given polymorphic event may be mapped into a normal event where it will be
consumed by the state machine of the class or it may be delegated further down
the hierarchy.
To be delegated further implies that a polymorphic event will be mapped
into yet another polymorphic event to be further mapped in a subsequent
dispatch.

Now we can tie it all together.
For a superclass class that has associated polymorphic events the code
generator supplies a Polymorphic Dispatch Block (PDB) to direct the run-time as
to how to perform the mapping of polymorphic events to transitioning events.

(((micca,Run Time Data,MRT_pdb)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtpolydispatchblock {
    MRT_DispatchCount eventCount ;
    MRT_DispatchCount genCount ;
    struct mrtgendispatchblock const *genDispatch ;

#       ifndef MRT_NO_NAMES
    char const *const *genNames ;
#       endif /* MRT_NO_NAMES */
} MRT_pdb ;
----

`eventCount`::
    The `eventCount` member holds the number of polymorphic
    events associated with the superclass.
    Like transition events, polymorphic events are encoded as zero based
    sequential integers so they may be used as array indices in the
    mapping process.
`genCount`::
    The `genCount` member holds the number of generalization
    that originate at the superclass class.
`genDispatch`::
    The `genDispatch` member holds a pointer to an array of
    Generalization Dispatch Blocks.
    The array contains `genCount` elements.
`genNames`::
    A pointer to an array of generalization relationship names.
    The array is of length, `genCount`.

Now we can give the code for polymorphic event dispatch.

(((micca,Run Time Function,mrtDispatchPolymorphicEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDispatchPolymorphicEvent(
    MRT_ecb *ecb)
{
    MRT_pdb const *pdb = ecb->targetInst->classDesc->pdb ;
    assert(pdb != NULL) ;
    assert(pdb->genCount > 0) ;
    /*
     * Compute the base offset for polymorphic event numbering.  This base
     * offset will be used to turn the polymorphic event number into an array
     * index.
     */
    MRT_edb const *edb = ecb->targetInst->classDesc->edb ;
    MRT_EventCode eventOffset = edb == NULL ?  0 : edb->eventCount ;
    assert(ecb->eventNumber - eventOffset < pdb->eventCount) ;
    /*
     * Save the original event number and target instance pointer.  We intend
     * to reuse the same ECB for each event we dispatch and will need these
     * values should there be more than one generalization associated with this
     * superclass.
     */
    MRT_EventCode origEvent = ecb->eventNumber ;
    MRT_Instance *origTarget = ecb->targetInst ;
    /*
     * For each generalization that originates at the superclass an event is
     * generated down that generalization to one of the subclasss.
     */
    MRT_gdb const *sdb = pdb->genDispatch ;
    for (unsigned gnum = 0 ; gnum < pdb->genCount ; ++sdb, ++gnum) {
        MRT_Relationship const *rel = sdb->relship ;
        MRT_Instance *targetInst ;
        int subclassCode ;

        /*
         * Find the target instance reference and the class of the target
         * instance. How we do this depends upon how the generalization is
         * stored in the superclass instance.
         */
        if (rel->relType == mrtRefGeneralization) {
            /*
             * When the generalization is implemented via a pointer, we need an
             * extra level of indirection to fetch the address of the subclass.
             */
            struct mrtrefgeneralization const *gen =
                    &rel->relInfo.refGeneralization ;
            targetInst = *(MRT_Instance **)((uintptr_t)origTarget +
                    gen->superclass.storageOffset) ;
            assert(targetInst != NULL) ;
            /*
             * We must also guard against the possibility that the subclass was
             * unrelated from the superclass before the polymorphic event was
             * dispatched.
             */
            if (targetInst == NULL) {
#                   ifndef MRT_NO_NAMES
                mrtFatalError(mrtRefIntegrity, rel->name) ;
#                   else
                mrtFatalError(mrtRefIntegrity, rel) ;
#                   endif /* MRT_NO_NAMES */
            }
            assert(targetInst->classDesc != NULL) ;
            subclassCode = mrtFindRefGenSubclassCode(targetInst->classDesc,
                    gen->subclasses, gen->subclassCount) ;
        } else if (rel->relType == mrtUnionGeneralization) {
            /*
             * When the generalization is implemented by a union, we need only
             * point to the address of the subclass since it is contained
             * within the superclass.
             */
            struct mrtuniongeneralization const *gen =
                    &rel->relInfo.unionGeneralization ;
            targetInst = (MRT_Instance *)((uintptr_t)origTarget +
                    gen->superclass.storageOffset) ;
            assert(targetInst->classDesc != NULL) ;
            subclassCode = mrtFindUnionGenSubclassCode(targetInst->classDesc,
                    gen->subclasses, gen->subclassCount) ;
        } else {
            mrtFatalError(mrtRelationshipLinkage) ;
        }
        /*
         * Check that our subclass instance is indeed allocated and usable.  We
         * are trying to guard against the possiblity that the subclass
         * instance was deleted before the polymorphic event was delivered.
         */
        assert(targetInst->alloc > 0) ;
        if (targetInst->alloc <= 0) {
#               ifndef MRT_NO_NAMES
            mrtFatalError(mrtEventInFlight,
                    ecb->sourceInst ? ecb->sourceInst->classDesc->name : "?",
                    ecb->sourceInst ? ecb->sourceInst->name : "?",
                    targetInst->classDesc->eventNames[origEvent],
                    targetInst->classDesc->name,
                    targetInst->name ? targetInst->name : "?") ;
#            else
            mrtFatalError(mrtEventInFlight, ecb->sourceInst, origEvent,
                    targetInst) ;
#           endif /* MRT_NO_NAMES */
        }
        ecb->targetInst = targetInst ;
        ecb->alloc = targetInst->alloc ;
        /*
         * Fetch the event number for the subclass from the polymorphic
         * mapping.  The class of the subclass related to the superclass
         * determines the mapped value for the event.  Note we must subtract
         * off any offset in the event encoding that was consumed by the
         * transition events.
         */
        ecb->eventNumber = *(sdb->eventMap +
                subclassCode * pdb->eventCount + origEvent - eventOffset) ;

#           ifndef MRT_NO_TRACE
        /*
         * Trace the transition.
         */
        mrtTracePolyEvent(origEvent, ecb->sourceInst, origTarget,
                subclassCode, gnum, ecb->eventNumber) ;
#           endif /* MRT_NO_TRACE */

        mrtDispatchEvent(ecb) ; // <1>
    }
}
----
<1> Since a polymorphic event may map to either another polymorphic event
or to a transition event, we will use the general dispatch function
to recursively dispatch the mapped event.

The code loops through all of the generalizations for which the `targetInst`
is a superclass.
The vast majority of the time there is only one generalization.
The strategy used here is to reuse the ECB that was carrying the polymorphic
event as the ECB for the remapped events.
This saves allocating a new ECB and avoids any problem that there may not
be an ECB available at that time.
The mapping of a polymorphic event is a function of the superclass target
and the polymorphic event number.
So we hold them in local variables as we overwrite the necessary fields
in the ECB to hold the mapped event information.

The core of the algorithm is to determine the subclass code of the related
subclass instance and use that as the row index into the polymorphic event map
for the generalization.
The event number (appropriately offset by the number of transition events)
is then used as the column index to find the mapping entry.
That mapping entry contains a new event number.
The new target of the event is the currently related subclass instance.
As we have discussed,
this may be a stored as a pointer or may be a union member of the superclass
instance structure.
For the pointer case,
we fetch the pointer from its location in the superclass structure.
For the union case,
the location in the superclass structure is the
beginning of the union, _i.e._ we down cast to the subclass member.
We fill in the `alloc` field to enable the event in
flight detection just in case the mapped event causes a transition.
Finally the newly minted ECB is recursively dispatched and the
next generalization is considered.
Recursively dispatching the event preserves the order of delivery of
the events.
Note that when there are multiple generalization hierarchies for
the event,
the dispatch order is determined by the order the code generator
decides for generalization dispatch blocks.

=== Creation Event Dispatch

Fortunately, creation events are much simpler than polymorphic events.
Creation event dispatch fixes up the `alloc` field of the
target and the ECB before normal event dispatch.
No additional data structures are required.

(((micca,Run Time Function,mrtDispatchCreationEvent)))
[source,c]
----
<<mrt static functions>>=
static void
mrtDispatchCreationEvent(
    MRT_ecb *ecb)
{
#       ifndef MRT_NO_TRACE
    /*
     * Trace the transition.
     */
    mrtTraceCreationEvent(ecb->eventNumber, ecb->sourceInst, ecb->targetInst,
            ecb->targetInst->classDesc) ;
#       endif /* MRT_NO_TRACE */

    assert(ecb->alloc == ecb->targetInst->alloc) ;
    assert(ecb->alloc < 0) ;
    assert(ecb->targetInst->alloc < 0) ;
    assert(ecb->targetInst->currentState ==
        ecb->targetInst->classDesc->edb->creationState) ;

    ecb->alloc = ecb->targetInst->alloc = -ecb->targetInst->alloc ; // <1>
    mrtDispatchTransitionEvent(ecb) ;
}
----
<1> By negating the `alloc` value, we show that the instance is now active.

== Bridging Domains

All but the simplest of systems will contain more that one domain.
A domain represent a coherent subject matter with its own set of rules
and policies.
Domains are also the unit of encapsulation and reuse.

Consider a simple example of a domain that controls a chemical reaction
vessel.
One aspect of synthesizing something in a reaction vessel
is controlling the temperature of the vessel.
Such systems typically delegate control to another domain so that
a Reaction Management domain would delegate setting and maintaining
the reaction vessel temperature to a Signal I/O domain.

From the point of view of Reaction Management, the reaction vessel has
heaters, coolers, pumps, valves and such things and it is its responsibility
to sequence the vessel operations to accomplish the synthesis.
Reaction Management does not know the details of what it is controlling.
It wants to set the vessel temperature to 57C and maintain it there
for some time period.
How that happens in terms of heaters, thermal load and other such
physical considerations is delegated.

From the point of view of Signal I/O,
it knows that it is controlling output actuators with input sensors
as feed back.
That output point number 57 corresponds to a reactor vessel is not in
its scope of concern.

The concept of a domain is very much related to the concept of
_separation of concerns_.
But that which is separated must be combined if we are to obtain a
useful system.
The difference in the semantic view points of domains must be
bridged by translating the assumptions and dependencies of one domain
into the services provided by other domains.

There are several approaches to bridging.
The most elegant approach is _implicit bridgeing_ which
is related to _aspect oriented programming_ concepts.
In this style of bridging,
we would use a separate means to describe how operations in one domain
would be mapped to side effects in another domain.
For example, we would want to be able to state that
when the state activity in the Reaction Management domain updates
the reactor vessel set point attribute we would want the temperature
to be transferred to output point number 57 of the Signal I/O domain.
The advantage of this type of bridging is that the individual domains are
not modified and the domain semantics are not disturbed.
The bridge interactions are defined outside of the domain itself.
It is then a code generator's task to generate the domain code so that
the bridge mapping is implemented.
The disadvantage of this type of bridging is that it is very difficult
to implement both the means to specify the domain interactions
and the code generator required to generate the bridging code.

Another approach to bridging is termed, _explicit bridging_.
In this form,
a domain makes explicit invocations to an _external entity_.
The invocations demonstrate the explicit requirements that the domain
delegates and the service it requires.
Bridges then map the external entity invocations to interactions
with other domains that provide the required service.
Explicit bridging is a workable technique but can lead to
a large number of domain operations being needed to service a client
domain's dependencies.
Often,
a client domain and service domain will have _counterpart classes_.
These are classes that represent different aspects of the same entity
but do so in the semantics of the individual domains.
In such cases,
model level operations in the client domain, _e.g._ updating an attribute
value, are bridged to a similar model operations in the service domain,
_e.g_ updating the counterpart class attribute with a scaled value.
If it is necessary to code a domain operation for each such model level
operation,
the service domain will be unnecessarily complicated and its reuse will
be limited since the details of how model level actions need to take place
will very much depend upon the context in which the service domain is used.

Making available the ability to do some model level operations such as
updating attributes or signaling event from outside of the domain
can make explicit bridging much easier and prevent cluttering the
external interfaces of service domains with domain operations specifically
built to support the use of the service domain in one particular system.
Doing so breaks the encapsulation of the domain,
albeit in a very controlled manner.

`Micca` takes the follow view of bridging:

* Domain designs should provide domain operations for those computations that
cannot be accomplished by a single simple model level operation.
Operations such as involve navigating a relationship or other more complicated
activities of instance creation and relationship linkage require
processing code to accomplish and that code is best gathered in
a domain operation.
* The `micca` code generator provides the means to break encapsulation
of a domain for simple model level actions such as signaling an event
or reading a class instance attribute.
* A domain must be populated before it can be bridged.
If there is an initial instance population,
bridges usually must account for that.
If the population of instances for a class is static,
this will usually greatly simplify the bridge.
* Bridge operation code is manually coded to map the semantics of one
domain onto another and, in general, is specific to the use of
the bridged domains in a particular system and, therfore, _not_ reusable.
* Dynamic activity in one domain may have to be reflected in the bridge.
For example, instance creation in one domain may have to result in
creating an instance of a counterpart class in a service domain.
In such cases, the bridge itself may have to track the dynamics of the
two domains.

These consideration make domain bridging abstract and complicated.
Sadly, the methodological fundamentals of bridging seem to be lacking
and much of what is done to build systems from bridged domains smacks of
being _ad hoc_.
There is much more that could be said about bridging that space does not
allow for here.
Projects are cautioned that bridging domains can be a significant
activity for which plans need to be made.

In this section,
we discuss the facilities provide by `micca` to perform operations on a
domain from outside the domain itself.
These facilities are intended to be used by bridge operation code.
Conceptually,
`micca` builds a _portal_ into the domain and supplies a set of functions
that will reach through the portal and perform operations in the domain.
The set of operations that can be performed is very limited but is a useful
set for implementing bridge operations.

=== Portal Data Structures [[portal-data-structures,Portal Data Structures]]

The only externally scoped identifiers in the generate ``C'' code file
are those of the domain operations.
All other generated code contains identifiers that are file static in
scope.
This is done to prevent collisions and contention of names at link time.
As a result,
other translation units have no access to the internals of a domain
as was the design goal.

Since we intend to provide some operations on the internals of a domain
we need a way to identify the entities upon which we are operating.
Internally,
a `micca` generated domain uses pointers to refer to instances, class
descriptors and other essential data.
We do _not_ want to expose addresses of the internals of a domain
to the outside.
Since all class instances are really elements of the class storage array,
the index of an instance in the storage array serves as a convenient
external identifier.
The `micca` code generator will place a set of ``C'' preprocessor
definitions in the generated header file to numerically encode
the classes, instances and attributes.
It is these small integer numbers that will serve as identifiers outside of the
domain and which we will use as array indices (with appropriate bounds
checking) inside the domain.

(((micca,Run Time Data,MRT_ClassId)))
(((micca,Run Time Data,MRT_InstId)))
(((micca,Run Time Data,MRT_AttrId)))
(((micca,Run Time Data,MRT_AttrSize)))
(((micca,Run Time Data,MRT_AssignerId)))
[source,c]
----
<<mrt interface simple types>>=
typedef unsigned short MRT_ClassId ;
typedef unsigned short MRT_InstId ;
typedef unsigned short MRT_AttrId ;
typedef size_t MRT_AttrSize ;
typedef unsigned short MRT_AssignerId ;
----

To operate on the internals of a domain requires a data structure
that maps the numerically encoded identifiers to the internals
of domain.

(((micca,Run Time Data,MRT_DomainPortal)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef struct mrtdomainportal {
    unsigned classCount ;
    MRT_Class const *classes ;
    unsigned assignerCount ;
    MRT_Class const *assigners ;

#       ifndef MRT_NO_NAMES
    char const *name ;
#       endif /* MRT_NO_NAMES */
} MRT_DomainPortal ;
----

`classCount`::
    The number of classes in the domain.
`classes`::
    A pointer to an array of class descriptions for the domain.
    The array contains `classCount` elements.
`assignerCount`::
    The number of assigners in the domain.
`assigners`::
    A pointer to an array of class description for the assigners.
    The array contains `assignerCount` elements.
`name`::
    A pointer to a NUL terminated character array giving the name of the domain.

The domain portal is a collection of class descriptions
for the classes and assigners in the domain.
Note that relationships are not accessible via the portal.

For each domain,
the code generator will create an externally scoped variable of the
above type.
The name of the variable follows the form `<domain name>__PORTAL`,
_i.e._ the suffix `__PORTAL` is appended to the domain name.
This variable forms the _portal_ into the domain and below we
describe the operations on the domain that are available via the portal.

=== Portal Access Functions [[portal-access-functions,Portal Access Functions]]

In this section we describe the set of operations that are avaiable
through the portal.
All the portal access functions return an integer value.
Non-negative return values indicate success and return the requested
information.
Negative return values indicate errors as described below.

[source,c]
----
<<mrt constants>>=
    // No such class.
#define MICCA_PORTAL_NO_CLASS       (-1)
    // No such instance.
#define MICCA_PORTAL_NO_INST        (-2)
    // No such attribute.
#define MICCA_PORTAL_NO_ATTR        (-3)
    // Instance slot is not in use.
#define MICCA_PORTAL_UNALLOC        (-4)
    // Class does not have a state model.
#define MICCA_PORTAL_NO_STATE_MODEL (-5)
    // No such event for the class.
#define MICCA_PORTAL_NO_EVENT       (-6)
    // No such state for the class.
#define MICCA_PORTAL_NO_STATE       (-7)
    // Class does not support dynamic instances.
#define MICCA_PORTAL_NO_DYNAMIC     (-8)
    // Operation not allowed on a dependent attribute.
#define MICCA_PORTAL_DEPENDENT_ATTR (-9)
    // Value was truncated due to lack of space.
#define MICCA_PORTAL_TRUNCATED      (-10)
----

Internally,
the portal access functions often need to find a class instance.
We have factored that into a static function.

(((micca,Run Time Function,mrtPortalGetInstRef)))
[source,c]
----
<<mrt static functions>>=
static int
mrtPortalGetInstRef(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_Instance **ref)
{
    int result ;

    if (classId < portal->classCount) {
        MRT_Class const *pclass = portal->classes + classId ;
        if (instId < pclass->instCount) {
            void *inst = mrt_InstanceReference(pclass, instId) ;
            if (ref) {
                *ref = inst ;
            }
            result = 0 ;
        } else {
            result = MICCA_PORTAL_NO_INST ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

==== References to Attributes

There is one case where we expose some internal pointer information
and this is for attributes.
Attributes implemented as arrays don't pass well by value in ``C''.
Obtaining a reference to the attribute is often the best way to
deal with passing its value around.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalGetAttrRef(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void **pref,
    MRT_AttrSize *size) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`attrId`::
    The number of the attribute to be read. This number is generated by micca
    and placed in the domain header file.
`pref`::
    A pointer to a memory pointer where the attribute reference is placed.
    If this argument is `NULL` then no reference is returned.
`size`::
    A pointer to where the size of the attribute is placed.
    If this argument is `NULL` then no size information is returned.

`mrt_GetAttrRef` obtains a pointer to the storage location for an
attribute and the size of that storage location.
The return value is 0, if the attribute storage could be found.
Negative numbers indicate an error occurred.
*****

(((micca,Run Time Function,mrt_PortalGetAttrRef)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalGetAttrRef(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void **pref,
    MRT_AttrSize *size)
{
    int result ;
    MRT_Instance *instref ;

    result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result == 0) {
        assert(instref != NULL) ;
        if (instref->alloc != 0) {
            MRT_Class const *class = instref->classDesc ;
            if (attrId < class->attrCount) {
                MRT_Attribute const *attr = class->classAttrs + attrId ;
                if (attr->type == mrtIndependentAttr) {
                    if (pref) {
                        *pref = (void *)((uintptr_t)instref + attr->access.offset) ;
                    }
                    if (size) {
                        *size = attr->size ;
                    }
                } else {
                    result = MICCA_PORTAL_DEPENDENT_ATTR ;
                }
            } else {
                result = MICCA_PORTAL_NO_ATTR ;
            }
        } else {
            result = MICCA_PORTAL_UNALLOC ;
        }
    }

    return result ;
}
----

==== Reading Attributes

Instance attribute values may be read through the portal.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalReadAttr(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void *dst,
    MRT_AttrSize dstSize) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`attrId`::
    The number of the attribute to be read. This number is generated by micca
    and placed in the domain header file.
`dst`::
    A pointer to memory where the attribute value is placed.
`dstSize`::
    The number of bytes pointed to by `dst`.

`mrt_PortalReadAttr` reads an attribute value from a domain.
No more than `dstSize` bytes will be placed in the memory pointed to by
`dst`.
If the return value is non-negative, then it represents the actual number of
bytes read.
Negative numbers indicate an error occurred.
*****

(((micca,Run Time Function,mrt_PortalReadAttr)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalReadAttr(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void *dst,
    MRT_AttrSize dstSize)
{
    assert(dst != NULL) ;

    MRT_Instance *instref ;
    int result ;

    result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result == 0) {
        assert(instref != NULL);
        if (instref->alloc != 0) {
            MRT_Class const *class = instref->classDesc ;
            if (attrId < class->attrCount) {
                MRT_Attribute const *attr = class->classAttrs + attrId ;
                MRT_AttrSize srcSize = attr->size ;
                if (dstSize >= srcSize) {
                    result = srcSize ;
                    if (attr->type == mrtIndependentAttr) {
                        void *src = (void *)((uintptr_t)instref +
                                attr->access.offset) ;
                        memcpy(dst, src, srcSize) ;
                    } else {
                        attr->access.formula(instref, dst, srcSize) ;
                    }
                } else {
                    result = MICCA_PORTAL_TRUNCATED ;
                }
            } else {
                result = MICCA_PORTAL_NO_ATTR ;
            }
        } else {
            result = MICCA_PORTAL_UNALLOC ;
        }
    }

    return result ;
}
----

==== Updating Attributes

Instance attribute values may be updated through the portal.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalUpdateAttr(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void const *src,
    MRT_AttrSize srcSize) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`attrId`::
    The number of the attribute to be updated.
    This number is generated by micca and placed in the domain header file.
`src`::
    A pointer to memory from where the attribute value is taken.
`srcSize`::
    The number of bytes pointed to by `src`.

`mrt_PortalUpdateAttr` updates an attribute value in a domain.
If the return value is non-negative,
then it represents the actual number of bytes copied into the attribute
storage location.
Negative numbers indicate an error occurred.
*****

(((micca,Run Time Function,mrt_PortalUpdateAttr)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalUpdateAttr(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_AttrId attrId,
    void const *src,
    MRT_AttrSize srcSize)
{
    assert(src != NULL) ;

    void *dst ;
    MRT_AttrSize dstSize ;

    int result = mrt_PortalGetAttrRef(portal, classId, instId, attrId, &dst,
            &dstSize) ;
    if (result == 0) {
        assert(dst != NULL) ;
        int copied ;
        if (srcSize == 0) {
            copied = dstSize ;
        } else {
            copied = dstSize < srcSize ? dstSize : srcSize ;
        }
        memcpy(dst, src, copied) ;
        result = copied ;
    }

    return result ;
}
----

==== Signaling Events

The portal allows signalling an event to a class instance.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalSignalEvent(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`eventNumber`::
    The event number of the event to signal.
`eventParameters`::
    A pointer to the supplemental event parameters. This may be set to `NULL`
    if there are not parameters for the event.

`mrt_PortalSignalEvent` signals an ordinary or polymorphic event to the given
instance.
The return value is 0 upon success.
Negative numbers indicate an error occurred.
*****

(((micca,Run Time Function,mrt_PortalSignalEvent)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalSignalEvent(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters)
{
    int result ;
    MRT_ecb *ecb ;

    result = mrtPortalNewECB(portal, classId, instId, eventNumber,
            eventParameters, &ecb) ;
    if (result == 0) {
        mrt_PostEvent(ecb) ;
    }

    return result ;
}
----

Internally, we factor obtaining an ECB into its own function.

(((micca,Run Time Function,mrtPortalNewECB)))
[source,c]
----
<<mrt static functions>>=
static int
mrtPortalNewECB(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters,
    MRT_ecb **ecbRef)
{
    int result ;
    MRT_Instance *instref ;

    result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result == 0) {
        if (instref->alloc > 0) {
            MRT_Class const *classDesc = portal->classes + classId ;
            MRT_ecb *ecb = NULL ;
            MRT_DispatchCount eventCount ;

            if (classDesc->edb == NULL) {
                if (classDesc->pdb == NULL) {
                    return MICCA_PORTAL_NO_EVENT ;
                } else {
                    eventCount = classDesc->pdb->eventCount ;
                }
            } else {
                if (classDesc->pdb == NULL) {
                    eventCount = classDesc->edb->eventCount ;
                } else {
                    eventCount = classDesc->edb->eventCount +
                            classDesc->pdb->eventCount ;
                }
            }

            if (eventNumber < eventCount) {
                ecb = mrt_NewEvent(eventNumber, instref, NULL) ;
                if (eventParameters) {
                    memcpy(ecb->eventParameters, eventParameters,
                        sizeof(ecb->eventParameters)) ;
                }
                if (ecbRef) {
                    *ecbRef = ecb ;
                }
                result = 0 ;
            } else {
                result = MICCA_PORTAL_NO_EVENT ;
            }
        } else {
            result = MICCA_PORTAL_UNALLOC ;
        }
    }

    return result ;
}
----

==== Signaling Delayed Events

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalSignalDelayedEvent(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters,
    MRT_DelayTime delay) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`eventNumber`::
    The event number of the event to signal.
`eventParameters`::
    A pointer to the supplemental event parameters. This may be set to `NULL`
    if there are not parameters for the event.
`delay`::
    The number of milliseconds to delay before the event is dispatched.

`mrt_PortalSignalDelayedEvent` signals an ordinary or polymorphic event
to the deliverd to an instance after a delay time.
The return value is 0 upon success.
Negative numbers indicate an error occurred.
*****

(((micca,Run Time Function,mrt_PortalSignalDelayedEvent)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalSignalDelayedEvent(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters,
    MRT_DelayTime delay)
{
    int result ;
    MRT_ecb *ecb ;

    result = mrtPortalNewECB(portal, classId, instId, eventNumber,
            eventParameters, &ecb) ;
    if (result == 0) {
        mrt_PostDelayedEvent(ecb, delay) ;
    }

    return result ;
}
----

==== Canceling Delayed Events

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalCancelDelayedEvent(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`classId`::
    The number of the class. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
`eventNumber`::
    The event number of the event to signal.

`mrt_PortalCancelDelayedEvent` cancels a delayed event.
The return value is 0 upon success.
Negative numbers indicate an error occurred.
*****

(((micca,Run Time Function,mrt_PortalCancelDelayedEvent)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalCancelDelayedEvent(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber)
{
    int result ;
    MRT_Instance *instref ;

    result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result == 0) {
        mrt_CancelDelayedEvent(eventNumber, instref, NULL) ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalRemainingDelayTime(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_DelayTime *delayRef) ;
----

(((micca,Run Time Function,mrt_PortalRemainingDelayTime)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalRemainingDelayTime(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_DelayTime *delayRef)
{
    int result ;
    MRT_Instance *instref ;

    result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result == 0) {
        MRT_DelayTime delay = mrt_RemainingDelayTime(eventNumber, instref, NULL) ;
        if (delayRef) {
            *delayRef = delay ;
        }
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalCreateInstance(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_StateCode initialState) ;
----

(((micca,Run Time Function,mrt_PortalCreateInstance)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalCreateInstance(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_StateCode initialState)
{
    int result ;

    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        if (class->containment == NULL) {
            MRT_Instance *inst = mrt_CreateInstance(class, initialState) ;
            assert(inst != NULL) ;
            MRT_iab *iab = class->iab ;
            assert(iab != NULL) ;
            assert(iab->storageStart != NULL) ;
            result = ((uintptr_t)inst - (uintptr_t)iab->storageStart) /
                    iab->instanceSize ;
        } else {
            result = MICCA_PORTAL_NO_DYNAMIC ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalCreateAsync(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters) ;
----

(((micca,Run Time Function,mrt_PortalCreateAsync)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalCreateAsync(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters)
{
    int result ;

    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        if (class->containment == NULL) { // <1>
            MRT_Instance *inst = mrt_CreateAsync(class, eventNumber,
                eventParameters,
                eventParameters == NULL ? 0 : sizeof(MRT_EventParams),
                NULL) ;
            result = mrt_InstanceIndex(inst) ;
        } else {
            result = MICCA_PORTAL_NO_DYNAMIC ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----
<1> Union subclass instances cannot be created asynchronously.

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalDeleteInstance(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId) ;
----

(((micca,Run Time Function,mrt_PortalDeleteInstance)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalDeleteInstance(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId)
{
    int result ;
    MRT_Instance *inst ;

    result = mrtPortalGetInstRef(portal, classId, instId, &inst) ;
    if (result == 0) {
        mrt_DeleteInstance(inst) ;
    }

    return result ;
}
----

==== Signaling Events To Assigners

The portal allows signalling an event to an assigner instance.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalSignalEventAssigner(
    MRT_DomainPortal const *portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters) ;
----

`portal`::
    A pointer to the portal structure for the domain.
`assignerId`::
    The number of the assigner. This number is generated by micca and placed in
    the domain header file.
`instId`::
    The number of the instance. Instance numbers are consecutive non-negative
    integers up to the maximum number of instances defined for the class.
    Single assigners have only one instance and so `instId` must be 0 for
    them.
    Multiple assigners may have an `instId` value greater than 0.
`eventNumber`::
    The event number of the event to signal.
`eventParameters`::
    A pointer to the supplemental event parameters. This may be set to `NULL`
    if there are not parameters for the event.

`mrt_PortalSignalEventAssigner` signals a transitioning event to the given
assigner instance.
Polymorphic and creation events cannot be signaled to an assigner.
The return value is 0 upon success.
Negative numbers indicate an error occurred.
*****

(((micca,Run Time Function,mrt_PortalSignalEventAssigner)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalSignalEventAssigner(
    MRT_DomainPortal const *portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId,
    MRT_EventCode eventNumber,
    MRT_EventParams eventParameters)
{
    assert(portal != NULL) ;
    int result ;

    if (assignerId < portal->assignerCount) {
        MRT_Class const *passigner = portal->assigners + assignerId ;
        if (instId < passigner->instCount) {
            MRT_iab *iab = passigner->iab ;
            assert(iab != NULL) ;
            MRT_Instance *instref = (MRT_Instance *)
                    ((uintptr_t)iab->storageStart + iab->instanceSize * instId) ;
            if (instref->alloc > 0) {
                MRT_edb const *edb = passigner->edb ;
                if (eventNumber < edb->eventCount) {
                    MRT_ecb *ecb = mrt_NewEvent(eventNumber, instref, NULL) ;
                    if (eventParameters) {
                        memcpy(ecb->eventParameters, eventParameters,
                            sizeof(ecb->eventParameters)) ;
                    }
                    mrt_PostEvent(ecb) ;
                    result = 0 ;
                } else {
                    result = MICCA_PORTAL_NO_EVENT ;
                }
            } else {
                result = MICCA_PORTAL_UNALLOC ;
            }
        } else {
            result = MICCA_PORTAL_NO_INST ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

==== Obtaining Class Current State

The portal supports reading the current state of an instance of a class
having a state model.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalInstanceCurrentState(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId) ;
----
*****

(((micca,Run Time Function,mrt_PortalInstanceCurrentState)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalInstanceCurrentState(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_InstId instId)
{
    MRT_Instance *instref ;
    int result ;

    result = mrtPortalGetInstRef(portal, classId, instId, &instref) ;
    if (result == 0) {
        assert(instref != NULL);
        if (instref->alloc > 0) {
            MRT_Class const *class = instref->classDesc ;
            result = class->edb != NULL ?
                    instref->currentState : MICCA_PORTAL_NO_STATE_MODEL ;
            assert(result >= 0) ;
        } else {
            result = MICCA_PORTAL_UNALLOC ;
        }
    }

    return result ;
}
----

==== Obtaining Assigner Current State

The portal supports reading the current state of an assigner of a class
having a state model.

*****
[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalAssignerCurrentState(
    MRT_DomainPortal const *portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId) ;
----
*****

(((micca,Run Time Function,mrt_PortalAssignerCurrentState)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalAssignerCurrentState(
    MRT_DomainPortal const *portal,
    MRT_AssignerId assignerId,
    MRT_InstId instId)
{
    assert(portal != NULL) ;
    int result ;

    if (assignerId < portal->assignerCount) {
        MRT_Class const *passigner = portal->assigners + assignerId ;
        if (instId < passigner->instCount) {
            MRT_iab *iab = passigner->iab ;
            assert(iab != NULL) ;
            MRT_Instance *instref = (MRT_Instance *)
                    ((uintptr_t)iab->storageStart + iab->instanceSize * instId) ;
            if (instref->alloc > 0) {
                assert(instref->classDesc->edb != NULL) ;
                result = instref->currentState ;
            } else {
                result = MICCA_PORTAL_UNALLOC ;
            }
        } else {
            result = MICCA_PORTAL_NO_INST ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

=== Domain Introspection

For testing and other purposes,
it is useful to be able to inquire about the characteristics of a
domain at run-time.
The functions in this section expose other domain portal information.

*****
[source,c]
----
<<mrt external interfaces>>=
extern char const *
mrt_PortalDomainName(
    MRT_DomainPortal const *portal) ;
----

`portal`::
    A pointer to a domain portal data structure.

The `mrt_PortalDomainName` function returns a pointer to the the name of the
domain described by the portal data pointed to by `portal`.
If the domain was compiled with the preprocessor symbol `MRT_NO_NAMES`
defined, then the return value is `NULL`.
*****

(((micca,Run Time Function,mrt_PortalDomainName)))
[source,c]
.Implementation
----
<<mrt external functions>>=
char const *
mrt_PortalDomainName(
    MRT_DomainPortal const *portal)
{
    assert(portal != NULL) ;

#       ifndef MRT_NO_NAMES
    return portal->name ;
#       else
    return NULL ;
#       endif /* MRT_NO_NAMES */
}
----

*****
[source,c]
----
<<mrt external interfaces>>=
extern unsigned
mrt_PortalDomainClassCount(
    MRT_DomainPortal const *portal) ;
----

`portal`::
    A pointer to a domain portal data structure.

The function `mrt_PortalDomainClassCount` returns the number of classes
in the domain.
Classes may be identified to the other portal functions using unsigned
numbers ranging from 0 to the return value of `mrt_PortalDomainClassCount`
minus 1.
*****

(((micca,Run Time Function,mrt_PortalDomainClassCount)))
[source,c]
.Implementation
----
<<mrt external functions>>=
unsigned
mrt_PortalDomainClassCount(
    MRT_DomainPortal const *portal)
{
    assert(portal != NULL) ;
    return portal->classCount ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassName(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    char const **nameRef) ;
----

(((micca,Run Time Function,mrt_PortalClassName)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassName(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    char const **nameRef)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
#           ifndef MRT_NO_NAMES
        MRT_Class const *class = portal->classes + classId ;
        if (nameRef) {
            *nameRef = class->name ;
        }
#           else
        if (nameRef) {
            *nameRef = NULL ;
        }
#           endif /* MRT_NO_NAMES */
        result = 0 ;
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassAttributeCount(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId) ;
----

(((micca,Run Time Function,mrt_PortalClassAttributeCount)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassAttributeCount(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        result = class->attrCount ;
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassInstanceCount(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId) ;
----

(((micca,Run Time Function,mrt_PortalClassInstanceCount)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassInstanceCount(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        result = class->instCount ;
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassEventCount(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId) ;
----

(((micca,Run Time Function,mrt_PortalClassEventCount)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassEventCount(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        result = class->eventCount ;
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassStateCount(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId) ;
----

(((micca,Run Time Function,mrt_PortalStateCount)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassStateCount(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        MRT_edb const *edb = class->edb ;
        result = edb != NULL ? edb->stateCount : 0 ;
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassAttributeName(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_AttrId attrId,
    char const **nameRef) ;
----

(((micca,Run Time Function,mrt_PortalClassAttributeName)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassAttributeName(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_AttrId attrId,
    char const **nameRef)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        if (attrId < class->attrCount) {
            if (nameRef) {
#                   ifndef MRT_NO_NAMES
                *nameRef = class->classAttrs[attrId].name ;
#                   else
                *nameRef = NULL ;
#                   endif /* MRT_NO_NAMES */
            }
            result = 0 ;
        } else {
            result = MICCA_PORTAL_NO_ATTR ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassAttributeSize(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_AttrId attrId) ;
----

(((micca,Run Time Function,mrt_PortalClassAttributeSize)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassAttributeSize(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_AttrId attrId)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        if (attrId < class->attrCount) {
            result = class->classAttrs[attrId].size ;
        } else {
            result = MICCA_PORTAL_NO_ATTR ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassEventName(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_EventCode eventCode,
    char const **nameRef) ;
----

(((micca,Run Time Function,mrt_PortalClassEventName)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassEventName(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_EventCode eventCode,
    char const **nameRef)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        if (class->eventCount != 0) {
            if (eventCode >= 0 && eventCode < class->eventCount) {
#                   ifndef MRT_NO_NAMES
                char const *const *eventNames = class->eventNames ;
                if (eventNames != NULL && nameRef != NULL) {
                    *nameRef = eventNames[eventCode] ;
                }
#                   else
                if (nameRef != NULL) {
                    *nameRef = NULL ;
                }
#                   endif /* MRT_NO_NAMES */
                result = 0 ;
            } else {
                result = MICCA_PORTAL_NO_EVENT ;
            }
        } else {
            result = MICCA_PORTAL_NO_STATE_MODEL ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

[source,c]
----
<<mrt external interfaces>>=
extern int
mrt_PortalClassStateName(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_StateCode stateCode,
    char const **nameRef) ;
----

(((micca,Run Time Function,mrt_PortalClassStateName)))
[source,c]
.Implementation
----
<<mrt external functions>>=
int
mrt_PortalClassStateName(
    MRT_DomainPortal const *portal,
    MRT_ClassId classId,
    MRT_StateCode stateCode,
    char const **nameRef)
{
    assert(portal != NULL) ;

    int result ;
    if (classId < portal->classCount) {
        MRT_Class const *class = portal->classes + classId ;
        MRT_edb const *edb = class->edb ;
        if (edb != NULL) {
            if (stateCode >= 0 && stateCode < edb->stateCount) {
                if (nameRef) {
#                       ifndef MRT_NO_NAMES
                    *nameRef = edb->stateNames[stateCode] ;
#                       else
                    *nameRef = NULL ;
#                       endif /* MRT_NO_NAMES */
                }
                result = 0 ;
            } else {
                result = MICCA_PORTAL_NO_STATE ;
            }
        } else {
            result = MICCA_PORTAL_NO_STATE_MODEL ;
        }
    } else {
        result = MICCA_PORTAL_NO_CLASS ;
    }

    return result ;
}
----

== Asynchronous Execution

When the main loop was discussed,
we made a brief mention of asynchronous execution in the context
of executing synchronization functions.
It is now time to discuss how the run-time deals with asynchronous
execution.
First we discuss some background and then present the means used by
the run-time to synchronize the two execution contexts.

Until now, the discussion of data management and execution
sequencing have assumed that we have a single execution context.
However,
all modern computer architectures support the concept of an interrupt.
An interrupt signaled by some external hardware causes the processor
to stop executing and transfer control to a different section of code
so that immediate action can be taken on the cause of the interrupt.
After the external condition is handled,
execution can resume where it was interrupted.
The need for asynchronous execution was recognized early in computer
architecture design as interaction with the external environment is much
of what makes a computer a useful machine.

The exact details of how this happens is different for every computer
architecture.
Some computers offer very sophisticated schemes that include arbitrating
the priority of multiple competing interrupt sources.
Most offer only a single priority of interrupt processing or place the
burden of prioritization on the programmer or external hardware.
The `micca` run-time is intended for highly embedded systems and,
in such systems, achieving the low execution overhead is of great value.
So the model of asynchronous execution used by the run-time mirrors that which
is provided directly by the hardware architecture.
Techniques for having multiple, scheduled execution contexts are very
well known.
None of them is used here.
Here we are only interested in a very simple model of asynchronous execution
that closely mirrors what is provided by the computing hardware.
Amazingly, this is much less restrictive than might be first imagined.

Nesting interrupts is not forbidden, but is definitely not encouraged.
No restriction is put on what may happen at interrupt service.
This is usually a potential source of error in many systems.
Because the execution is asynchronous to domain model execution,
any access to the domain data structures from interrupt service
*must not* be attempted.
It is ultimately unsafe and results in horribly difficult to detect
timing windows being generated wherein things will mysteriously and
irreproducibly fail.

However, it is usually necessary for an interrupt to communicate
back to the domain models.
Usually, the interrupt signals some change of condition
in the environment that has been detected by the hardware.
The interrupt may not be able to do everything required to handle the situation
and frequently additional computation is required to resolve what has happened.
The run-time provides a way for an interrupt to request
synchronization with the running background.
This is accomplished by having the interrupt service code
perform a synchronization request.

[source,c]
----
<<mrt external interfaces>>=
extern MRT_SyncParams *mrt_SyncRequest(MRT_SyncFunc) ;
----

That request is in the form of a function with optional parameters
that is to be executed at the first *safe* opportunity.
As we saw before,
the synchronization functions are executed in between state actions
to insure that the domain data are in a coherent state.

The run-time provides a sync queue where interrupts may place
their requests for background synchronization execution.
We do this with a simple queue that is implemented in an array.
Like all resources in the run-time,
the storage required for the queue is fixed at compile time.

[source,c]
----
<<mrt constants>>=
#ifndef MRT_SYNCQUEUESIZE
#   define MRT_SYNCQUEUESIZE 10
#endif /* MRT_SYNCQUEUESIZE */
----

The number of queue entries can be sized appropriately for the system.
Generally, the number of queue slots must be sized to handle
any cluster of interrupts that go off at nearly the same time.

It is necessary to provide interrupts the ability to pass parameters
to the background sync functions.
This is often data that must be sampled coincident with the interrupt
in order to capture the correct external state.
To avoid problems with variable life times,
data is passed by value by placing it in a parameter area.

This is not a good strategy for passing a large amount of
data from the interrupt context to the background.
In those cases, it is necessary to manage memory between the
background and the interrupts.
No facilities are provided by the run-time to do this as it usually
must to be constructed _ad hoc_ to suit the particular needs of the
data transfer.
It is often sufficient to manage a memory pool in the background and use the
synchronization to the background to allow interrupt service to return memory
to the pool when it is no longer needed.
The architypical example is communications buffers.
Background code can manage a buffer pool.
When outgoing messages are transmitted,
synchronization to the background can be used to return the buffer to
the pool.
Incoming messages can be placed in pre-queued buffers and when the message
is complete, synchronizing to the background passes buffer pointers
to be processed and returned to the pool.

For our purposes here, it is only necessary to define some data structure
that can be used by the interrupt service code to place data that
will be delivered to the background function.
The same considerations that were discussed for
<<event-parameter-storage,event parameters>>
apply for sync function parameters.
So we use the same strategy.

(((micca,Run Time Data,MRT_SyncParams)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef MRT_EventParams MRT_SyncParams ;
----

And so we can define the prototype for a sync function.

(((micca,Run Time Data,MRT_SyncFunc)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef void (*MRT_SyncFunc)(MRT_SyncParams const *) ;
----

Each element of the sync queue is a pointer to the sync function
and a place where the interrupt service code may place the values
of the parameters.

(((micca,Run Time Data,MRT_SyncBlock)))
[source,c]
----
<<mrt implementation aggregate types>>=
typedef struct mrtsyncblock {
    MRT_SyncFunc function ;
    alignas(max_align_t) MRT_SyncParams params ;
} MRT_SyncBlock ;
----

The sync queue is stored in an array and we use a couple of
pointers to keep track of the head and tail.

(((micca,Run Time Data,MRT_SyncQueue)))
[source,c]
----
<<mrt implementation aggregate types>>=
typedef struct mrtsyncqueue {
    MRT_SyncBlock *head ;
    MRT_SyncBlock *tail ;
} MRT_SyncQueue ;
----

Following our usual pattern,
we allocate storage for the sync queue entries as an array and
for the control structure that tracks the queue boundaries within
the sync queue entry array.

[source,c]
----
<<mrt static data>>=
static MRT_SyncBlock mrtSyncQueueStorage[MRT_SYNCQUEUESIZE] ;
static MRT_SyncQueue mrtSyncQueue = {
    .head = mrtSyncQueueStorage,
    .tail = mrtSyncQueueStorage,
} ;
----

There are only three operations on the sync queue.
First we must be able to determine if the queue is empty or not.
Emptiness is determined when the queue head is equal to the queue tail.
For this type of queue operation,
the head is where the next entry is removed and the tail is where the
next entry is inserted.

[source,c]
----
<<mrt forward references>>=
static inline bool mrtSyncQueueEmpty(void) ;
----

[source,c]
----
<<mrt static functions>>=
static inline
bool
mrtSyncQueueEmpty(void)
{
    return mrtSyncQueue.head == mrtSyncQueue.tail ;
}
----

Inserting a function into the synchronization queue is an activity
that may only be performed from interrupt service level.
*N.B.* that this function does *not* implement a critical section
around access to the sync queue.
It assumes that it is being invoked from an interrupt context already
and will not be preempted by any other execution.

[source,c]
----
<<mrt forward references>>=
static inline MRT_SyncParams *mrtSyncQueuePut(MRT_SyncFunc f, bool fatal) ;
----

[source,c]
----
<<mrt static functions>>=
static inline
MRT_SyncParams *
mrtSyncQueuePut(
    MRT_SyncFunc f,
    bool fatal)
{
    MRT_SyncBlock *tail = mrtSyncQueue.tail ;
    if (++mrtSyncQueue.tail >=
            mrtSyncQueueStorage + MRT_SYNCQUEUESIZE) {
        mrtSyncQueue.tail = mrtSyncQueueStorage ;
    }
    if (mrtSyncQueueEmpty()) {
        if (fatal) {
            mrtFatalError(mrtSyncOverflow) ;
        }
        return NULL ;
    }

    tail->function = f ;
    return &tail->params ;
}
----

Insertion happens at the tail.
Incrementing the tail pointer must account for wrapping around the array
boundary.
Overflow is detected as the queue being empty after the insertion is made.
This logic has the effect of consuming one of the queue storage slots 
in order to detect overflow and
this will need to be accounted for in sizing the sync queue storage.
The `fatal` argument determines if queue overflow is a fatal system error
or not.
This allow for dealing with sync requests that can be ignored if it would
cause a sync queue overflow.
Note that the sync queue slot is not modified until after
overflow is detected.
This insures that should an error happen during development,
the queue can be examined and will be in a consistent state.

The consumer of the sync queue entries is the main loop.

[source,c]
----
<<mrt forward references>>=
static inline MRT_SyncBlock *mrtSyncQueueGet(void) ;
----

[source,c]
----
<<mrt static functions>>=
static inline
MRT_SyncBlock *
mrtSyncQueueGet(void)
{
    MRT_SyncBlock *head ;

    beginCriticalSection() ;
    if (mrtSyncQueueEmpty()) {
        head = NULL ;
    } else {
        head = mrtSyncQueue.head ;
        if (++mrtSyncQueue.head >=
                mrtSyncQueueStorage + MRT_SYNCQUEUESIZE) {
            mrtSyncQueue.head = mrtSyncQueueStorage ;
        }
    }
    endCriticalSection() ;

    return head ;
}
----

Since the main loop runs with interrupts enabled,
obtaining a sync queue entry must be done in a critical section.
We remove entries from the head of the queue.
Otherwise, the only complexity in the code is to account for
the array storage wrap around.

=== Dispatching Synchronization Functions

The event loop we saw above performed the background synchronization
before dispatching a single event.
For most processor architectures,
that code appears as below:

[source,c]
----
<<ProcessOneEvent: background sync>>=
#   ifndef MRT_ARM_ARCH_7M
while (mrtInvokeOneSyncFunction()) {
    ; /* empty */
}
#   endif
----

We execute in a loop, invoking one sync function until there are no
more queued up.
It turns out we can do something a bit better for the ARM v7-M
architecture.
We will discuss that below when we consider the platform specific code.

[source,c]
----
<<mrt forward references>>=
static inline bool mrtInvokeOneSyncFunction(void) ;
----

Invoking a sync function is a simple matter of pulling it off the
sync queue and passing a pointer to the parameters to it.
We return a value indicating if a function was called.

[source,c]
----
<<mrt static functions>>=
static inline
bool
mrtInvokeOneSyncFunction(void)
{
    bool didOne ;

    MRT_SyncBlock const *blk = mrtSyncQueueGet() ;
    if (blk != NULL && blk->function != NULL) {
        blk->function(&blk->params) ;
        didOne = true ;
    } else {
        didOne = false ;
    }

    return didOne ;
}
----

For the ARM v7-M processor,
we can execute the sync functions in a service handler and then there
is no burden to the event loop to constantly test if any synchronization
need to be performed.
The process will handle vectoring to this code when necessary.

[source,c]
----
<<ARM 7M components>>=
void
PendSV_Handler(void)
{
    for (MRT_SyncBlock *blk = mrtSyncQueueGet() ; blk != NULL ;
            blk = mrtSyncQueueGet()) {
        if (blk->function) {
            blk->function(&blk->params) ;
        }
    }
}
----

== Event Dispatch Tracing

Debugging event driven, callback, state machine based applications can be
rather more complicated than conventional, linear flow code.
When class instances generate events to other instances and it can
be hard to determine the exact sequence of execution by simply
examining the source code.
Indeed, part of the intent here is to factor away from the application
the details of sequencing execution.
Setting a breakpoint in the action of a state is easy enough,
the difficulties arise when trying to determine where to set a breakpoint
to catch the results of the next event dispatch.
Given that many events will be flying around a given program,
it is very useful to be able to extract the set of event dispatches
in chronological order.

To help in debugging,
the run-time can be conditionally compiled to support tracing the event
dispatch.
After the code is properly compiled,
a pointer to a trace callback function may be registered and
then each event dispatched will result in the function being called
with the information about the dispatch.

It should be noted that dealing with trace information can be
very difficult.
For small embedded systems,
there may not be sufficient space to store the strings that give
names to states and events (the `MRT_NO_NAMES` macro can be defined
to remove the string information).
This means that only numbers are available to the tracing code
and there is substantial effort required to back
translate the numbers into strings that are meaningful to a human.

Because tracing also affects the performance of the run-time code,
it may also be excluded by defining the `MRT_NO_TRACE` macro.
Most projects will want to define `MRT_NO_TRACE` in code compiled
for a release.


=== Trace Information

Since there are three types of events,
there are three distinct sets of information generated when
an event is dispatched.
There is information common to all events and information
specific to each event type.

(((micca,Run Time Data,MRT_SubclassCode)))
[source,c]
----
<<mrt interface simple types>>=
typedef uint8_t MRT_SubclassCode ;
----

(((micca,Run Time Data,MRT_TraceInfo)))
[source,c]
----
<<mrt trace aggregate types>>=
typedef struct mrttraceinfo {
    MRT_EventType eventType ;
    MRT_EventCode eventNumber ;
    MRT_Instance *sourceInst ;
    MRT_Instance *targetInst ;
    union {
        struct transitiontrace {
            MRT_StateCode currentState ;
            MRT_StateCode newState ;
        } transitionTrace ;
        struct polytrace {
            MRT_SubclassCode subcode ;
            MRT_DispatchCount genNumber ;
            MRT_EventCode mappedEvent ;
        } polyTrace ;
        struct creationtrace {
            MRT_Class const *targetClass ;
        } creationTrace ;
    } info ;
} MRT_TraceInfo ;
----

Data common to all event dispatch traces.

`eventType`::
    The type of the event that was dispatched.
`eventNumber`::
    The number of the event that was dispatched.
`sourceInst`::
    A pointer to the instance that was the source of the dispatched event.
`targetInst`::
    A pointer to the instance that was the target of the dispatched event.

`transitionTrace`::
    Data for transition event dispatch traces.
`currentState`:::
    The current state of the instance before the event dispatch.
`newState`:::
    The new state entered as a result of the transition.

`polyTrace`::
    Data for polymorphic event dispatch traces.
`subcode`:::
    The subclass code of the currently related instance.
`genNumber`:::
    The number of the generalization down which the event was dispatched.
`mappedNumber`:::
    The new event number to which the polymorphic event mapped.

`creationTrace`::
    Data for creation event dispatch traces.
`targetClass`:::
    A pointer to the class structure for the target of the
    creation event.

=== Access to Trace Information

Event tracing information is passed out of the run-time by
having the application register a callback function.
That function takes a pointer to the trace information as its
argument.

(((micca,Run Time Data,MRT_TraceHandler)))
[source,c]
----
<<mrt trace aggregate types>>=
typedef void (*MRT_TraceHandler)(MRT_TraceInfo const *) ;
----

The function is registered with the run-time by invoking:

[source,c]
----
<<mrt trace external interfaces>>=
extern MRT_TraceHandler mrt_RegisterTraceHandler(MRT_TraceHandler) ;
----

The trace callback function is supplied as the argument and the
previous value of the callback is returned.
Tracing can be turned off by invoking `mrt_RegisterTraceHandler` with `NULL`.

[source,c]
----
<<mrt trace static data>>=
static MRT_TraceHandler mrtTraceHandler ;
----

[source,c]
----
<<mrt trace external functions>>=
MRT_TraceHandler
mrt_RegisterTraceHandler(
    MRT_TraceHandler handler)
{
    MRT_TraceHandler oldhandler = mrtTraceHandler ;
    mrtTraceHandler = handler ;
    return oldhandler ;
}
----

The implementation of registering a handler is simply to record the
function pointer in a variable.

For each type of event dispatch,
the run-time calls a specific function to determine if tracing
is enabled and to marshal the trace information into the proper
data structure.

[source,c]
----
<<mrt trace static functions>>=
static inline 
void
mrtTraceTransitionEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_StateCode currentState,
    MRT_StateCode newState)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace ;

        trace.eventType = mrtTransitionEvent ;
        trace.eventNumber = event ;
        trace.sourceInst = source ;
        trace.targetInst = target ;
        trace.info.transitionTrace.currentState = currentState ;
        trace.info.transitionTrace.newState = newState ;

        mrtTraceHandler(&trace) ;
    }
}
----

[source,c]
----
<<mrt trace static functions>>=
static inline 
void
mrtTracePolyEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_SubclassCode subclass,
    MRT_DispatchCount genNumber,
    MRT_EventCode newEvent)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace ;

        trace.eventType = mrtPolymorphicEvent ;
        trace.eventNumber = event ;
        trace.sourceInst = source ;
        trace.targetInst = target ;
        trace.info.polyTrace.subcode = subclass ;
        trace.info.polyTrace.genNumber = genNumber ;
        trace.info.polyTrace.mappedEvent = newEvent ;

        mrtTraceHandler(&trace) ;
    }
}
----

[source,c]
----
<<mrt trace static functions>>=
static inline 
void
mrtTraceCreationEvent(
    MRT_EventCode event,
    MRT_Instance *source,
    MRT_Instance *target,
    MRT_Class const *class)
{
    if (mrtTraceHandler) {
        MRT_TraceInfo trace ;

        trace.eventType = mrtCreationEvent ;
        trace.eventNumber = event ;
        trace.sourceInst = source ;
        trace.targetInst = target ;
        trace.info.creationTrace.targetClass = class ;

        mrtTraceHandler(&trace) ;
    }
}
----

=== Tracing Strategies

Clearly,
tracing can generate data at a rather high rate and can be
rather intrusive upon the execution of the system.
Several strategies may be used to deal with the trace data.
If possible,
all the trace data can be dumped in a raw form out a communications
interface and let some other program decode and display it.
That may still be too intrusive and sometimes it is best to
filter the trace data based on the target instance pointer value.
In this way you may trace the event dispatches on only a subset of
instances.
Several different filtering schemes, such as source instance or classes,
can be envisioned.

Another possibility is to store trace information in a memory
area in some sort of circular queue arrangement.
Then it is possible for the application to start and stop such tracing
and achieve ``logic analyzer'' type triggering functionality.
The trace information can then be extracted from memory and analyzed.

When running in a POSIX environment,
one can assume reasonable I/O facilities.
The POSIX version of the run-time includes default trace handling to
timestamp and print the trace data in human readable form.

You will also note that the trace information has no timing data associated
with it.
This type of data is so system specific that it is left to the
tracing callback to supply.
If you have a free running cycle counter in your system,
this can be a good indicator of relative time and the trace callback
function can add this to the data set supplied by the run-time.
Your system may also have source of clocked timing data that can also
be used as a timing reference.
In either case, augmenting the trace data with some sort of relative
time information is very valuable.

Tracing can also be used as a framework for testing.
If a domain is built to run in a testing framework where tracing is enabled,
then recording all the trace information allows one to determine
the amount of _transition_ coverage a test set causes.
The goal is to develop test sets that drive the domain with appropriate data so
that all state transitions are taken.
Tracing allows the recording of what transitions a given thread of control
causes.
Since in most well designed state machines,
state activity code is small and does not contain complicated or intricate
internal program flow,
causing all state activities to be executed is often close to complete
statement coverage.
As an added benefit,
state machines can be considered as directed graphs.
A depth first traversal of a directed graph can be be used to determine
a spanning tree for the graph.
Traversing a spanning tree for a graph insures that all nodes in the graph
are visited and the event sequence given by the spanning tree
can guide the generation of test set data and can help to minimize the
number of test cases required to ensure adequate coverage.

== Error Handling

Until now we have glossed over the subject of how to handle errors
in the `micca` run-time.
In XUML,
the domains assume a perfect architecture in the sense that
no formal mechanism is provided to signal architectural errors back to
the application domains.
This makes sense because the application models are meant to be implementation
independent and able to be run on a variety of underlying platforms.
However,
an error policy, in much the same terms as data and execution policies,
must be put into place.
The details of the error handling policy will vary between
software architectures, so it is important to state them clearly.
For the `micca` run-time, the following principles guide error handling.

* To that extent possible, the run-time operations should not report
errors back to the application.
For implementation languages that do not support exception handling,
the usual technique of returning error codes is not very effective.
Either by accident or sloth, many error codes are not checked.
Even when the error code is checked,
there is little recovery recourse for the application.
For example,
it does little good to know that we are unable to generate an
event because we do not have sufficient ECB resources when there
is nothing a state activity can do to free up the required resources.
* Errors that result from exhausted resources or analysis errors
detected at run-time are *fatal*.
Exactly how fatal errors are acted upon is platform dependent and may
result in terminating a program or completely resetting the system.
Regardless of the consequence of a fatal error, the assumption is
that the program can no longer continue to run.

With these principles in mind, we define a set of error conditions
that are detected by the run-time.
All these conditions are fatal and are handled by invoking a fatal
error handler.

(((micca,Run Time Data,MRT_ErrorCode)))
[source,c]
----
<<mrt interface simple types>>=
typedef enum {
    mrtCantHappen = 1,
    mrtEventInFlight,
    mrtNoECB,
    mrtNoInstSlot,
    mrtSyncOverflow,
    mrtRefIntegrity,
    mrtTransOverflow,
    mrtStaticRelationship,
    mrtRelationshipLinkage,

#       ifdef _POSIX_C_SOURCE
    mrtTimerOpFailed,
    mrtSignalOpFailed,
    mrtSelectWaitFailed,
#       endif /* _POSIX_C_SOURCE */
} MRT_ErrorCode ;
----

We will need a string representation of the error codes to
make human readable messages.

[source,c]
----
<<mrt static data>>=
static char const * const errMsgs[] = {
    [0] = "no error",     /* place holder */
    [mrtNoECB] = "no available Event Control Blocks\n",
    [mrtSyncOverflow] = "synchronization queue overflow\n",
    [mrtTransOverflow] = "transaction markings overflow\n",
    [mrtStaticRelationship] = "attempt to modify static relationship\n",
    [mrtRelationshipLinkage] = "invalid instance linkage operation or value\n",

#       ifndef MRT_NO_NAMES
    [mrtCantHappen] = "can't happen transition: %s.%s: %s - %s -> CH\n",
    [mrtEventInFlight] = "event-in-flight error: %s.%s - %s -> %s.%s\n",
    [mrtNoInstSlot] = "no available instance slots: %s\n",
    [mrtRefIntegrity] = "referential integrity check failed: %s\n",
#       else
    [mrtCantHappen] = "can't happen transition: %p: %u - %u -> CH\n",
    [mrtEventInFlight] = "event-in-flight error: %p - %u -> %p\n",
    [mrtNoInstSlot] = "no available instance slots: %p\n",
    [mrtRefIntegrity] = "referential integrity check failed: %p\n",
#       endif /* MRT_NO_NAMES */

#       ifdef _POSIX_C_SOURCE
    [mrtTimerOpFailed] = "interval timer operation failed: %s\n",
    [mrtSignalOpFailed] = "signal operation failed: %s\n",
    [mrtSelectWaitFailed] = "blocking on pselect() failed: %s\n",
#       endif /* _POSIX_C_SOURCE */
} ;
----

Everywhere else the run-time operations have been crafted to
avoid error possibilities.
For example, as discussed in delayed event generation,
we interpret the attempt to generate a duplicate delayed event
as wishing to cancel the existing one and instantiate a new one.
This semantic interpretation avoids generating an error and avoids
all the additional code require in state actions that generate
delayed events.

Exactly how fatal errors are handled will depend upon the specifics
of how the platform handles errors.
We define an interface for a fatal error handler.

(((micca,Run Time Data,MRT_FatalErrorHandler)))
[source,c]
----
<<mrt interface aggregate types>>=
typedef void (*MRT_FatalErrorHandler)(MRT_ErrorCode, char const *, va_list) ;
----

The interface is patterned after `vprintf`,
giving a format string and a pointer to a variable length argument list.

[source,c]
----
<<mrt forward references>>=
static void
mrtDefaultFatalErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list ap) ;
----

The system provides a default fatal error handler,
a message is printed to the standard error stream.

[source,c]
----
<<mrt static functions>>=
static void
mrtDefaultFatalErrorHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list ap)
{
    vfprintf(stderr, errMsgs[errNum], ap) ;
}
----

A pointer to the fatal error handler is initialized with the default one.

[source,c]
----
<<mrt static data>>=
static MRT_FatalErrorHandler mrtErrHandler = mrtDefaultFatalErrorHandler ;
----

Because fatal error handling is usually so platform specific and
because of the need to test fatal error paths,
we provide the ability to delegate the consequence of the
fatal error.

[source,c]
----
<<mrt external interfaces>>=
extern MRT_FatalErrorHandler
mrt_SetFatalErrorHandler(
    MRT_FatalErrorHandler newHandler) ;
----

[source,c]
.Implementation
----
<<mrt external functions>>=
MRT_FatalErrorHandler
mrt_SetFatalErrorHandler(
    MRT_FatalErrorHandler newHandler)
{
    MRT_FatalErrorHandler prevHandler = mrtErrHandler ;
    if (newHandler) {
        mrtErrHandler = newHandler ;
    }
    return prevHandler ;
}
----

The run-time internally calls `mrtFatalError`.
This function is presented next.

[source,c]
----
<<mrt forward references>>=
static noreturn void mrtFatalError(MRT_ErrorCode errNum, ...) ;
----

[source,c]
----
<<mrt static functions>>=
static noreturn
void
mrtFatalError(
    MRT_ErrorCode errNum,
    ...)
{
    va_list ap ;
    /*
     * All hope is lost here. Make sure we don't
     * execute any asynchronous code.
     */
    beginCriticalSection() ;

    assert(mrtErrHandler != NULL) ;
    assert(errNum < COUNTOF(errMsgs)) ;

    va_start(ap, errNum) ;
    mrtErrHandler(errNum, errMsgs[errNum], ap) ;
    /*
     *  If the handler does return, we insist that all errors
     *  are fatal. So we abort().
     */
    abort() ;
}
----

As we see in the code,
we insist that there is an error handler.
There is always the default one and a different handler can be specified
if necessary.
Finally,
`abort()` is called should the error handler return.

== Avoiding Fatalities

In this error handling strategy,
every run-time detected error is fatal.
Although the details of the processing for fatal errors can be delegated,
in most systems of the class we consider here,
fatal errors usually result in a system reset.
Under the vast majority of circumstances,
that is the desired behavior.
However,
there are some particular circumstances where causing a fatal
error is not the desired behavior.

Consider the case where some external stimulus results in an event
being generated.
If the stimulus occurs more frequently than events can be processed,
then the run-time will run out of event control blocks causing a
fatal error.
As an example,
consider the arrival of a communications packet.
If somewhere during the processing of the packet an event is generated,
then if packets arrive too fast a fatal error can be generated.
In effect it would provide a means for an external stimulus to cause the
system to crash.
Certainly for the case of a communications packet,
the preferred behavior would be to drop the packet and let higher level
protocol deal with the necessary retries, etc.
It is then necessary to be able to determine if generating an event
would be successful.

In this section we describe functions that can be used to avoid run-time
requests that would exhaust an underlying resource and therefore
cause a fatal system error.
It should be emphasized that these functions are *not*
intended for ordinary or casual use.
Under the vast majority of circumstances,
such as when one state machine generates an event to another state
machine,
event generation and other such activities should continue to assume
that there are no resources that can be consumed.
System analysis and testing should then determine the appropriate sizing
for the various resource pools.
The capability described in this section is to handle unusual and
extraordinary circumstances where hardware failure or failure to
abide by communications protocols could force the system into a
fatal error situation.

Note also that the alternative provided here causes the external stimulus
that would cause the fatal error condition effectively to be ignored.
For some system requirements that is not an acceptable solution.
For example,
consider a digital input line that is used to generate an interrupt
and that interrupt signals an external condition monitored by hardware,
say the maximum extent of motion of physical robot arm.
If this interrupt arrives at a very fast rate,
one might conclude the hardware has failed.
Ignoring the interrupt might do little other than mask a problem that should
cause a fatal error condition and potentially reset the system.
The conclusion is that providing a means of avoiding fatal error conditions
is not intented to serve as an overall error handling policy.
Careful analysis and consideration is still required.
If an interrupt arrives faster than expected and,
because of what the interrupt represents, it cannot be ignored,
that fact and the response to it must be deduced by the interrupt service
code (_e.g._ by determining the interrupt frequency) and actions
appropriate to the system must be taken.
It can be a difficult problem to solve and the functions provided here
are too generic to be used indescrimately.

There are three internal run-time resources that can be exhausted.

* Class instances can be dynamically created and each class has its own instance
pool.
* Event control blocks are used for generating and dispatching state machine
events.
* The foreground / background synchronization queue has a fixed number
of slots and excessive synchronization requests from interrupt service
routines can fill the queue.

=== Checking for Available Instance Space

The `mrt_InstanceAvailable()` function provides a means determine if there
is space available to create a new instance of a class.

(((micca,Run Time Function,mrt_InstanceAvailable)))
[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_InstanceAvailable(
    MRT_Class const *classDesc) ;
----

`classDesc`::
    A pointer to the class data for which the space check is made.

`mrt_InstanceAvailable` returns `true` if there at least one instance
of `classDesc` may be created without exhausting the memory pool
of instances for the class.

[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_InstanceAvailable(
    MRT_Class const *classDesc)
{
    assert(classDesc != NULL) ;

    /*
     * Search for an empty slot in the pool.
     */
    return mrtFindInstSlot(classDesc->iab) != NULL ;
}
----

=== Checking for Event Blocks

[source,c]
----
<<mrt external interfaces>>=
extern bool
mrt_EventAvailable(void) ;
----

[source,c]
.Implementation
----
<<mrt external functions>>=
bool
mrt_EventAvailable(void)
{
    return !mrtEventQueueEmpty(&freeEventQueue) ;
}
----

=== Non-Fatal Background Synchronization

[source,c]
----
<<mrt external interfaces>>=
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc f) ;
----

== POSIX Specific Code

At this point we have reached the end of the generic
code and must now begin to account for the platform differences
in the way timing and asynchronous execution is handled.
This software architecture can be run on a conventional POSIX platform.
This includes Linux, Mac OS X and even Cygwin.
The primary purpose of making the run-time function in a POSIX environment
is simulation.
Often, a domain can be executed for testing and simulation purposes on
a conventional computer more easily than in the target environment.
With I/O and disk storage, testing and tracing logic is often much easier.
It is also perfectly reasonable to implement an application using `micca` and
targeting a POSIX platform.

=== POSIX Include Files

We will need a number of POSIX specific include files.

[source,c]
----
<<posix includes>>=
#include <signal.h>
#include <errno.h>
#include <sys/select.h>
#include <sys/time.h>
#include <time.h>
----

=== POSIX Critical Sections

We start with a discussion of how to implement a critical section
in POSIX.
In POSIX,
the `signal` is the means of asynchronous execution.
There are times when we must insure that execution is _not_
interrupted by asynchronous signal execution.
The functions in this section accomplish that.

The technique here is to maintain a signal mask of all the signals
that are under control of the run-time.
This signal mask can then be used to control signal execution as necessary.
Note that an application can call low level signal handling primitives
and manage subsets of signals outside of the run-time.
This is definitely discouraged.

[source,c]
----
<<posix static data>>=
static sigset_t mrtSigMask ;
----

It is necessary to initialize our managed signal mask to be empty.

[source,c]
----
<<posix static functions>>=
static inline
void
mrtInitCriticalSection(void)
{
    sigemptyset(&mrtSigMask) ;
}
----

Starting a critical section just means that we must block all the managed
signals.

[source,c]
----
<<posix static functions>>=
static inline
void
beginCriticalSection(void)
{
    if (sigprocmask(SIG_BLOCK, &mrtSigMask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

The end of a critical section is equally easily accomplished by unblocking
the managed signals.

[source,c]
----
<<posix static functions>>=
static inline
void
endCriticalSection(void)
{
    if (sigprocmask(SIG_UNBLOCK, &mrtSigMask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

=== POSIX Timing Interfaces

In this section we present the timing interface for POSIX systems.
In this timing scheme,
the interval timer that measures real time
is used and notifications of elapsed time arrive via SIGALRM.

In an embedded system,
time is usually measured in units of clock ticks,
where the amount of real time represented by a clock tick will vary
from system to system.
It is useful then to run the delayed event queue in hardware device
units rather than a conventional time measure so that we may avoid
the conversion computation each time the delayed event queue timing
is started or stopped.

So, we introduce a couple of functions to convert between clock ticks
and milliseconds and _vice versa_.
Since the POSIX interface operates at a higher level, in the POSIX
case there is no transformation.
Note that there is a bit of data type slight of hand going on here.
We use the `MRT_DelayTime` type to hold values of milliseconds
and clock ticks.
In practice this is not a problem, but the type will have to be
chosen to account for the largest values held either of the uses
of the data type.

[source,c]
----
<<posix static functions>>=
static inline
MRT_DelayTime
mrtMsecToTicks(
    MRT_DelayTime msec)
{
    return msec ;
}
----

[source,c]
----
<<posix static functions>>=
static inline
MRT_DelayTime
mrtTicksToMsec(
    MRT_DelayTime ticks)
{
    return ticks ;
}
----

[source,c]
----
<<posix static functions>>=
static void
mrtSysTimerMask(void)
{
    /*
     * Make sure SIGALRM does not go off.
     */
    sigset_t mask ;
    sigemptyset(&mask) ;
    sigaddset(&mask, SIGALRM) ;
    if (sigprocmask(SIG_BLOCK, &mask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

[source,c]
----
<<posix static functions>>=
static void
mrtSysTimerUnmask(void)
{
    /*
     * Allow SIGALRM to notify us.
     */
    sigset_t mask ;
    sigemptyset(&mask) ;
    sigaddset(&mask, SIGALRM) ;
    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

To start a timer we supply the number of ticks we want to expire
before we are notified.

[source,c]
----
<<posix static functions>>=
static void
mrtSysTimerStart(
    MRT_DelayTime time)
{
    struct itimerval delayedEventTimer ;

    delayedEventTimer.it_interval.tv_sec = 0 ;
    delayedEventTimer.it_interval.tv_usec = 0 ;
    delayedEventTimer.it_value.tv_sec = time / 1000 ;
    delayedEventTimer.it_value.tv_usec = (time % 1000) * 1000 ;

    if (setitimer(ITIMER_REAL, &delayedEventTimer, NULL) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }
    mrtSysTimerUnmask() ;
}
----

The code initializes the *real* interval timer to use in servicing the
delayed event queue.
We set the `it_interval` member,
which represents the next value to be loaded into the timer,
to 0.
Then when the time given by the `it_value` member
expires the timer is stopped.
The system timer is specified in microseconds and our time value is in
milliseconds,
so some conversion must be performed.
Upon expiration, SIGALRM is generated.
Notice that we exit the function with SIGALRM unblocked.

Stopping the timer returns the amount of time that had not elapsed.

[source,c]
----
<<posix static functions>>=
static MRT_DelayTime
mrtSysTimerStop(void)
{
    mrtSysTimerMask() ;
    /*
     * Fetch the remaining time.
     */
    struct itimerval delayedEventTimer ;
    if (getitimer(ITIMER_REAL, &delayedEventTimer) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }
    /*
     * Convert the returned time into milliseconds.
     */
    MRT_DelayTime remain =
            delayedEventTimer.it_value.tv_sec * 1000 +
            delayedEventTimer.it_value.tv_usec / 1000 ;
    /*
     * Set the current timer value to zero to turn it off.
     */
    memset(&delayedEventTimer, 0, sizeof(delayedEventTimer)) ;
    if (setitimer(ITIMER_REAL, &delayedEventTimer, NULL) != 0) {
        mrtFatalError(mrtTimerOpFailed, strerror(errno)) ;
    }

    return remain ;
}
----

Stopping the timer must make sure that SIGALRM
does not expire during the process of getting things stopped.

Since the timing services use SIGALRM, the signal registration function
is used to insure that SIGALRM is serviced.

[source,c]
----
<<posix static functions>>=
static void
mrtSysTimerExpire(
    int signum)
{
    MRT_DelayTime nextTime = mrt_TimerExpireService() ;
    if (nextTime != 0) {
        mrtSysTimerStart(nextTime) ;
    }
}
----


[source,c]
----
<<posix static functions>>=
static void
mrtInitSysTimer(void)
{
    mrt_RegisterSignal(SIGALRM, mrtSysTimerExpire) ;
}
----

=== POSIX Async Execution Interface

The POSIX view of a process includes the notion of _signals_.
Signals are a form of asynchronous execution,
and reasonably correspond to the interrupts of a bare metal system.
As we have seen in the timer services above,
we can use signals to access a variety of services on a POSIX system.

In this section we fill out the asynchronous execution interfaces
using signals.
As we will see,
POSIX systems also require that you deal with their I/O interface in order to
properly handle execution sequencing.
For now, we present an interface that allows an application to
deal with the asynchronous aspects of signals.
As expected,
the interface allows an application to register a sync function
that will be executed at the first safe opportunity after the signal
has expired.

[source,c]
----
<<posix external functions>>=
MRT_SyncParams *
mrt_SyncRequest(
    MRT_SyncFunc f)
{
    return mrtSyncQueuePut(f, true) ;
}
----

The alternate interface is also easily implemented.

[source,c]
----
<<posix external functions>>=
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc f)
{
    return mrtSyncQueuePut(f, false) ;
}
----

Applications can register a signal function that will be
called ultimately be called after the signal triggers.

(((micca,Run Time Data,MRT_SignalFunc)))
[source,c]
----
<<posix external interfaces>>=
typedef void (*MRT_SignalFunc)(int) ;

extern void
mrt_RegisterSignal(
    int sigNum,
    MRT_SignalFunc func) ;
----

The arguments are simply, `sigNum`, the number of the signal
being registered and `func`, a pointer to a sync function that will
be called.
If `func` is `NULL`, then the signal's behavior is reset
to its default behavior.

[source,c]
----
<<posix external functions>>=
void
mrt_RegisterSignal(
    int sigNum,
    MRT_SignalFunc func)
{
    assert(sigNum > 0) ;

    struct sigaction action ;
    if (func) {
        action.sa_handler = func ;
        sigaddset(&mrtSigMask, sigNum) ;
    } else {
        action.sa_handler = SIG_DFL ;
        sigdelset(&mrtSigMask, sigNum) ;
    }
    sigfillset(&action.sa_mask) ;
    action.sa_flags = 0 ;

    int sigresult = sigaction(sigNum, &action, NULL) ;
    if (sigresult != 0) {
        mrtFatalError(mrtSignalOpFailed, strerror(errno)) ;
    }
}
----

We set up signal handlers to run uninterrupted by other signals.
This is accomplished by filling the `sa_mask` member of the
`sigaction` structure.
This is simplifies keeping track of what is going on.

=== POSIX I/O Interface

On POSIX platforms,
the run-time must also supply services to handle I/O.
The reason for this is that there are two means of awakening a sleeping
process, receiving a signal and servicing a I/O file
descriptor.footnote:[ There are other ways to integrate signals and I/O in
POSIX systems.  The use of a `pselect` based approach is a design decision.]
On bare metal systems,
I/O is frequently accomplished on an `ad hoc` basis
and the single mechanism of the sync queue is usually sufficient.
However, POSIX makes a distinction between signals and I/O operations on
file descriptors and an interface needs to be provided to deal with
servicing file descriptors that require attention.

We model this interface after the one for signals.
The idea is that a set of callback functions can be registered
on a file descriptor for reading, writing or an exception.
When the condition is satisfied the callback is invoked.
So we must define an I/O callback function as:

(((micca,Run Time Data,MRT_FDServiceFunc)))
[source,c]
----
<<posix external interfaces>>=
typedef void (*MRT_FDServiceFunc)(int) ;
----

When the callback is invoked,
it is passed the value of the file descriptor that requires service.

The run-time provide two functions for I/O.
One registers the callbacks for a file descriptor and the other removes 
a file descriptor from consideration.

[source,c]
----
<<posix external interfaces>>=
extern void
mrt_RegisterFDService(
    int fd,
    MRT_FDServiceFunc readService,
    MRT_FDServiceFunc writeService,
    MRT_FDServiceFunc exceptService) ;
----

`fd`::
    A file descriptor as returned from `open`, `socket`
    or any other system calls that create file descriptors.
`readService`::
    A pointer to a callback function that will be registered for the file
    descriptor and invoked when the file descriptor is readable
    or `NULL` if no callback is registered.
`writeService`::
    A pointer to a callback function that will be registered for the file
    descriptor and invoked when the file descriptor is writable
    or `NULL` if no callback is registered.
`exceptService`::
    A pointer to a callback function that will be registered for the file
    descriptor and invoked when the file descriptor is in an exception
    condition or `NULL` if no callback is registered.
    In practice, exception conditions are used only for reading
    OOB (out of bands) data on a TCP socket.

The corresponding remove function has the following interface.

[source,c]
----
<<posix external interfaces>>=
extern void
mrt_UnregisterFDService(
    int fd,
    bool rmRead,
    bool rmWrite,
    bool rmExcept) ;
----

`fd`::
    A file descriptor as returned from `open`, `socket`
    or any other system calls that create file descriptors.
`rmRead`::
    A boolean indicated whether or not the file descriptor should
    have its read callback unregistered.
`rmWrite`::
    A boolean indicated whether or not the file descriptor should
    have its write callback unregistered.
`rmExcept`::
    A boolean indicated whether or not the file descriptor should
    have its exception callback unregistered.

The implementation of these two functions requires some internal
data structures to track the file descriptor sets.
File descriptor sets are handed to `pselect` to indicate how a process
is to be awakened for I/O servicing.

To track the callback functions we need a data structure.

(((micca,Run Time Data,MRT_FDServiceMap)))
[source,c]
----
<<posix implementation aggregate types>>=
typedef struct mrtfdservicemap {
    bool set ;
    MRT_FDServiceFunc read ;
    MRT_FDServiceFunc write ;
    MRT_FDServiceFunc except ;
} MRT_FDServiceMap ;
----

`set`::
    A boolean indicating whether or not the entry is in use.
`read`::
    A pointer to the read callback registered for the file descriptor
    or `NULL` if no callback is registered.
`write`::
    A pointer to the write callback registered for the file descriptor
    or `NULL` if no callback is registered.
`except`::
    A pointer to the exception callback registered for the file descriptor
    or `NULL` if no callback is registered.

Following our familiar pattern,
we define an array of mapping entries that defines a pool for storing
the entries that map file descriptor state to callbacks.
This array is indexed by file descriptor value.

[source,c]
----
<<posix static data>>=
static struct mrtfdservicemap mrtFDServicePool[FD_SETSIZE] ;
----

The value of `FD_SETSIZE` is determined by the system and is the
maximum number of file descriptors that can be in a `fd_set` given
to `select`.

One complication of using `pselect` as a means of registering intent
on multiple file descriptors is that you must keep track of the largest
value of a file descriptor in the set handed to `pselect`.
This is an argument to `pselect` (and `select`).
Fortunately, UNIX file descriptors operate in a rather predictable manner.
Each process has file descriptors 0, 1, and 2 open when the process is
started.
Creating a new file descriptor (_e.g._ by opening a file) will allocate
the next largest unused file descriptor number.
This rule applies to the three file descriptors opened by default for a process.
So, for example, closing file descriptor 2 and then opening a new file
will result in file descriptor 2 being reused.
All this makes tracking the maximum file descriptor number relatively easy.
We only need a single integer variable.

[source,c]
----
<<posix static data>>=
static int mrtMaxFD = -1 ;
----

Since `mrtMaxFD` holds the maximum value of the file descriptors
that have been registered, the value -1 indicates that there are no
registered file descriptors.

We need variables to hold the three sets of file descriptors needed
by `pselect`.

[source,c]
----
<<posix static data>>=
static fd_set mrtReadFDS ;
static fd_set mrtWriteFDS ;
static fd_set mrtExceptFDS ;
----

Finally, we can talk about the implementation of the I/O registration
functions.

[source,c]
----
<<posix external functions>>=
void
mrt_RegisterFDService(
    int fd,
    MRT_FDServiceFunc readService,
    MRT_FDServiceFunc writeService,
    MRT_FDServiceFunc exceptService)
{
    assert(fd >= 0 && fd < FD_SETSIZE) ;
    MRT_FDServiceMap *fds = mrtFDServicePool + fd ;

    fds->read = readService ;
    if (readService) {
        FD_SET(fd, &mrtReadFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtReadFDS) ;
    }

    fds->write = writeService ;
    if (writeService) {
        FD_SET(fd, &mrtWriteFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtWriteFDS) ;
    }

    fds->except = exceptService ;
    if (exceptService) {
        FD_SET(fd, &mrtExceptFDS) ;
        fds->set = true ;
    } else {
        FD_CLR(fd, &mrtExceptFDS) ;
    }

    if (fds->read == NULL && fds->write == NULL && fds-> except == NULL) {
        if (fds->set && fd >= mrtMaxFD) {
            --mrtMaxFD ;
        }
        fds->set = false ;
    } else if (fds->set && fd > mrtMaxFD) {
        mrtMaxFD = fd ;
    }
}
----

The function simply tests the various callback functions and if
they are not `NULL`,
then the file descriptor is added to the appropriate set.
As written,
`mrt_RegisterFDService` may be used to modify file descriptors already
registered.
The last bit of logic is there in case `mrt_RegisterFDService` is used
to effectively remove the file descriptor by supplying three `NULL`
callback function pointers.
We must also account for the maximum file descriptor value that
has been registered.

Unregistering a file descriptor from consideration is also straight forward.

[source,c]
----
<<posix external functions>>=
void
mrt_UnregisterFDService(
    int fd,
    bool rmRead,
    bool rmWrite,
    bool rmExcept)
{
    assert(fd >= 0 && fd < FD_SETSIZE) ;
    MRT_FDServiceMap *fds = mrtFDServicePool + fd ;

    if (rmRead) {
        fds->read = NULL ;
        FD_CLR(fd, &mrtReadFDS) ;
    }

    if (rmWrite) {
        fds->write = NULL ;
        FD_CLR(fd, &mrtWriteFDS) ;
    }

    if (rmExcept) {
        fds->except = NULL ;
        FD_CLR(fd, &mrtExceptFDS) ;
    }

    if (fds->read == NULL && fds->write == NULL && fds-> except == NULL &&
            fd >= mrtMaxFD) {
        mrtMaxFD = fd - 1 ;
    }
}
----

We also need something to initialize the file descriptor sets that we
are maintaining.

[source,c]
----
<<posix static functions>>=
static void
mrtInitFDService(void)
{
    FD_ZERO(&mrtReadFDS) ;
    FD_ZERO(&mrtWriteFDS) ;
    FD_ZERO(&mrtExceptFDS) ;
}
----

=== POSIX Suspending Execution

The main loop detects when there is nothing left to do and
suspends execution.
Here we present how that suspension happens for the POSIX version of the
run-time.

This design is based on using `pselect` to suspend a process until
either a signal occurs or a file descriptor requires service.
The `mechWait` function is called by the main loop when there is no
work currently to be done.
It is invoked inside of a critical section.
This is an important entry condition for `mechWait`.
In the POSIX case,
this means that `mechWait` must be invoked with all the registered
signals blocked.
We then use `pselect` to atomically enable all signals and block the process.

[source,c]
----
<<posix static functions>>=
static void
mrtWait(void)
{
    beginCriticalSection() ;
    if (mrtSyncQueueEmpty()) {
        /*
         * Copy the file descriptor sets since "pselect" modifies them in place
         * upon return.
         */
        fd_set readfds ;
        memcpy(&readfds, &mrtReadFDS, sizeof(readfds)) ;
        fd_set writefds ;
        memcpy(&writefds, &mrtWriteFDS, sizeof(writefds)) ;
        fd_set exceptfds ;
        memcpy(&exceptfds, &mrtExceptFDS, sizeof(exceptfds)) ;
        /*
         * Allow all the signals during the select.
         */
        sigset_t mask ;
        sigemptyset(&mask) ;
        /*
         * "mrtMaxFD" holds the maximum value of any registered file
         * descriptor. We must add one to get the number of file descriptors
         * "pselect" is to consider.
         */
        int r = pselect(mrtMaxFD + 1, &readfds, &writefds,
                &exceptfds, NULL, &mask) ;
        if (r == -1) {
            if (errno != EINTR) {
                mrtFatalError(mrtSelectWaitFailed, strerror(errno)) ;
            }
            /*
             * Got a signal while waiting. We go back to the main loop on the
             * assumption that something has been placed in the sync queue.
             */
        } else {
            /*
             * Dispatch the service functions for the file descriptors.
             */
            MRT_FDServiceMap *s = mrtFDServicePool ;
            for (int fd = 0 ; r > 0 && fd <= mrtMaxFD ;
                    ++fd, ++s) {
                /*
                 * Do exceptions first. This is only important for sockets, but
                 * without going first the OOB data processing won't work.
                 */
                if (FD_ISSET(fd, &exceptfds)) {
                    assert(s->except != NULL) ;
                    s->except(fd) ;
                    --r ;
                }
                if (FD_ISSET(fd, &readfds)) {
                    assert(s->read != NULL) ;
                    s->read(fd) ;
                    --r ;
                }
                if (FD_ISSET(fd, &writefds)) {
                    assert(s->write != NULL) ;
                    s->write(fd) ;
                    --r ;
                }
            }
        }
    }
    endCriticalSection() ;
}
----

By far, most of the work in `mechWait` is to deal with the
file descriptor status changes.
The file descriptor sets
must be copied before being handed to `pselect` since it modifies
them in place.
After we determine that it was a file descriptor status change that
caused us to wake up,
we must go through and find all file descriptors that had a status
change and invoke the callback function.

The way that we are using `pselect` in this circumstance may seem
a bit backwards.
Upon entry to `mechWait`,
we start a critical section where
the registered signals are blocked.
The signal mask given to `pselect` is empty, meaning that `pselect`
will allow all signals while the process sleeps.
Upon the return from `pselect` we will be back to the state where
the registered signals are blocked.
Thus we avoid the race condition where
we have determined that the sync queue is empty, but
asynchronous execution that might affect the
sync queue arrives before we can put the process to sleep.
This is exactly the type of race condition `pselect` is used to prevent.

It is also worth noting we do _not_ use any time out in the
`pselect` invocation.
All timing is done via delayed events, and they are signalled via
`SIGALRM` and managed on the delayed event queue as discussed before.

=== POSIX Tracing

[source,c]
----
<<posix static functions>>=
#   ifndef MRT_NO_TRACE
#   ifndef MRT_NO_NAMES
static void
mrtPrintTraceInfo(
    MRT_TraceInfo const *traceInfo)
{
    char const *sourceName ;
    char const *sourceClassName ;
    char sourceIdNum[32] ;

    if (traceInfo->sourceInst == NULL) {
        sourceName = "?" ;
        sourceClassName = "?" ;
    } else {
        sourceClassName = traceInfo->sourceInst->classDesc->name ;
        sourceName = traceInfo->sourceInst->name ;
        if (sourceName == NULL) {
            unsigned instid = mrt_InstanceIndex(traceInfo->sourceInst) ;
            snprintf(sourceIdNum, sizeof(sourceIdNum), "%u", instid) ;
            sourceName = sourceIdNum ;
        }
    }
    
    char const *targetName = traceInfo->targetInst->name ;
    char targetIdNum[32] ;
    if (targetName == NULL) {
        unsigned instid = mrt_InstanceIndex(traceInfo->targetInst) ;
        snprintf(targetIdNum, sizeof(targetIdNum), "%u", instid) ;
        targetName = targetIdNum ;
    }

    switch (traceInfo->eventType) {
    case mrtTransitionEvent: {
        MRT_StateCode newState = traceInfo->info.transitionTrace.newState ;
        char const *newStateName ;
        if (newState == MRT_StateCode_IG) {
            newStateName = "IG" ;
        } else if (newState == MRT_StateCode_CH) {
            newStateName = "CH" ;
        } else {
            newStateName = traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.newState] ;
        }

        printf("%s: Transition: %s.%s - %s -> %s.%s: %s ==> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->edb->stateNames[
                traceInfo->info.transitionTrace.currentState],
            newStateName) ;
    }
        break ;

    case mrtPolymorphicEvent: {
        MRT_Relationship const *rel = traceInfo->targetInst->classDesc->pdb->
                genDispatch[traceInfo->info.polyTrace.genNumber].relship ;
        MRT_Class const *subclass ;
        char const *subname = NULL ;
        if (rel->relType == mrtRefGeneralization) {
            subclass = rel->relInfo.refGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode].classDesc ;
            subname = subclass->name ;
        } else if (rel->relType == mrtUnionGeneralization) {
            subclass = rel->relInfo.unionGeneralization.
                subclasses[traceInfo->info.polyTrace.subcode] ;
            subname = subclass->name ;
        } else {
            printf("%s: bad relationship type in polymorphic event, %d\n",
                mrtTimestamp(), rel->relType) ;
            break ;
        }
        printf("%s: Polymorphic: %s.%s - %s -> %s.%s: %s - %s -> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->targetInst->classDesc->name, targetName,
            traceInfo->targetInst->classDesc->pdb->genNames[
                traceInfo->info.polyTrace.genNumber],
            subclass->eventNames[traceInfo->info.polyTrace.mappedEvent],
            subname) ;
    }
        break ;

    case mrtCreationEvent:
        printf("%s: Creation: %s.%s - %s -> %s ==> %s\n",
            mrtTimestamp(), sourceClassName, sourceName,
            traceInfo->targetInst->classDesc->eventNames[traceInfo->eventNumber],
            traceInfo->info.creationTrace.targetClass->name,
            targetName) ;
        break ;

    default:
        printf("%s: Unknown trace event type, \"%u\"",
                mrtTimestamp(), traceInfo->eventType) ;
        break ;
    }
}
#   else  /* MRT_NO_NAMES is defined */
static void
mrtPrintTraceInfo(
    MRT_TraceInfo const *traceInfo)
{
    switch (traceInfo->eventType) {
    case mrtTransitionEvent:
        printf("%s: Transition: %p - %u -> %p: %u ==> %u\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->targetInst,
                traceInfo->info.transitionTrace.currentState,
                traceInfo->info.transitionTrace.newState) ;
        break ;

    case mrtPolymorphicEvent:
        printf("%s: Polymorphic: %p - %u -> %p: %u - %u -> %d\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->targetInst,traceInfo->info.polyTrace.genNumber,
                traceInfo->info.polyTrace.mappedEvent,
                traceInfo->info.polyTrace.subcode) ;
        break ;

    case mrtCreationEvent:
        printf("%s: Creation: %p - %u -> %p ==> %p\n",
                mrtTimestamp(), traceInfo->sourceInst, traceInfo->eventNumber,
                traceInfo->info.creationTrace.targetClass,
                traceInfo->targetInst) ;
        break ;

    default:
        printf("%s: Unknown trace event type, \"%u\"",
                mrtTimestamp(), traceInfo->eventType) ;
        break ;
    }
}
#   endif /* MRT_NO_NAMES */
#   endif /* MRT_NO_TRACE */
----

[source,c]
----
<<posix forward references>>=
#   ifndef MRT_NO_TRACE
static char const *mrtTimestamp(void) ;
#   endif /* MRT_NO_TRACE */
----

[source,c]
----
<<posix static functions>>=
#   ifndef MRT_NO_TRACE
static char const *
mrtTimestamp(void)
{
    static char timestamp[128] ;

    struct timeval now ;
    if (gettimeofday(&now, NULL) != 0) {
        return "unknown" ;
    }

    struct tm *ltime ;
    ltime = localtime(&now.tv_sec) ;
    if (ltime == NULL) {
        return strerror(errno) ;
    }

    int tlen = strftime(timestamp, sizeof(timestamp), "%FT%T", ltime) ;
    if (tlen == 0) {
        return strerror(errno) ;
    }

    int flen = snprintf(timestamp + tlen, sizeof(timestamp) - tlen,
            ".%03u.%03u", (unsigned)(now.tv_usec / 1000),
            (unsigned)(now.tv_usec % 1000)) ;
    if (flen > (sizeof(timestamp) - tlen)) {
        return "too big" ;
    }

    return timestamp ;
}
#   endif /* MRT_NO_TRACE */
----

=== POSIX Initialization

Here we present the POSIX version of the required internal initialization.

[source,c]
----
<<posix external functions>>=
void
mrt_Initialize(void)
{
    mrtEventPoolInit() ;
    mrtInitCriticalSection() ;
    mrtInitSysTimer() ;
    mrtInitFDService() ;
    setvbuf(stdout, NULL, _IOLBF, 0) ; // set up line buffering on stdout
#       ifndef MRT_NO_TRACE
    mrt_RegisterTraceHandler(mrtPrintTraceInfo) ;
#       endif /* MRT_NO_TRACE */
}
----

== ARM 7M Specific Code

[source,c]
----
<<arm7m includes>>=
#include "core_cm3.h"
#define__ARM_ARCH_7M__

/*
 * Use the Energy Micro library functions for low level peripheral access.
 */
#include "em_chip.h"
#include "em_cmu.h"
#include "em_emu.h"
#include "em_rtc.h"
#include "em_dbg.h"


#define PENDSV_IRQN (-2)    /* 14 Pend SV */
#define MRT_PENDSV_PRIORITY     0xff

#define SWO_LOCATION 0
#ifndef MRT_TIMER_FREQUENCY
#   define MRT_TIMER_FREQUENCY     4096UL
#endif /* MRT_TIMER_FREQUENCY */
#define MRT_MAX_CLOCK_TICKS     (UINT32_MAX - 1)
#define MRT_MAX_MSEC_DELAY\
        ((MRT_MAX_CLOCK_TICKS / MRT_TIMER_FREQUENCY) * 1000UL)
----

=== ARM 7M Critical Sections

[source,c]
----
<<arm7m static functions>>=
static inline
void
mrtInitCriticalSection(void)
{
    NVIC_SetPriority(PENDSV_IRQN, MRT_PENDSV_PRIORITY) ;
}
static inline
void
beginCriticalSection(void)
{
    __disable_irq() ;
}
static inline
void
endCriticalSection(void)
{
    __enable_irq() ;
}
----

=== ARM 7M Timing Interfaces

[source,c]
----
<<arm7m static functions>>=
static inline
MRT_DelayTime
mrtMsecToTicks(
    MRT_DelayTime msec)
{
    if (msec > MRT_MAX_MSEC_DELAY) {
        msec = MRT_MAX_MSEC_DELAY ;
    }
    /*
     * We must avoid overflow if the requested number of
     * msecs is large.
     */
    return msec < MRT_MAX_CLOCK_TICKS / MRT_TIMER_FREQUENCY ?
            ((msec * MRT_TIMER_FREQUENCY) + 1000UL / 2UL) / 1000UL :
            ((msec + 1000UL / 2UL) / 1000UL) * MRT_TIMER_FREQUENCY ;
}
----

[source,c]
----
<<arm7m static functions>>=
static inline
MRT_DelayTime
mrtTicksToMsec(
    MRT_DelayTime ticks)
{
    return ticks < MRT_MAX_CLOCK_TICKS / 1000UL ?
        ((ticks * 1000UL) + MRT_TIMER_FREQUENCY / 2UL) / MRT_TIMER_FREQUENCY :
        ((ticks + MRT_TIMER_FREQUENCY / 2UL) / MRT_TIMER_FREQUENCY) * 1000UL ;
}
----

[source,c]
----
<<arm7m static functions>>=
static void
mrtSysTimerMask(void)
{
    RTC_IntDisable(RTC_IFC_COMP0) ;
}
----

[source,c]
----
<<arm7m static functions>>=
static void
mrtSysTimerUnmask(void)
{
    RTC_IntEnable(RTC_IFC_COMP0) ;
}
----

[source,c]
----
<<arm7m static functions>>=
static void
mrtSysTimerStart(
    MRT_DelayTime time)
{
    RTC_CompareSet(0, ticks) ;
    RTC_IntClear(RTC_IFC_COMP0) ;
    mrtSysTimerUnmask() ;
    RTC_Enable(true) ;
}
----

[source,c]
----
<<arm7m static functions>>=
static MRT_DelayTime
mrtSysTimerStop(void)
{
    /*
     * There is a race between when we read the CNT register and when we
     * actually get the timer stopped where it may expire. If it expires, the
     * interrupt flag will be set and we can use that as an indication that
     * the CNT register is not valid (i.e. it was cleared to zero when the
     * timer expired).  This is different than if we had just been enabled and
     * requested to stop before one tick went by (in our case that's ~ 244
     * microsecond) and count would have been zero. So this is a bit tricky in
     * here.
     */
    MRT_DelayTime remain ;

    mrtSysTimerMask() ;
    if (RTC->CTRL & RTC_CTRL_EN) {
        remain = RTC->COMP0 ;
        remain -= RTC->CNT ;
        /*
         * Check that the timer didn't expire, as is indicated by the
         * interrupt flag, while we were trying to read the registers.
         */
        if (RTC->IF & RTC_IF_COMP0) {
            remain = 0 ;
        }
    } else {
        remain = 0 ;
    }
    RTC_Enable(false) ; // timer disabled

    return remain ;
}
----

[source,c]
----
<<arm7m external functions>>=
void
RTC_IRQHandler(void)
{
    RTC_Enable(false) ; // timer disabled
    RTC_IntClear(RTC_IFC_COMP0) ;
    MRT_DelayTime nextTime = mrt_TimerExpireService() ;
    if (nextTime != 0) {
        mrtSysTimerStart(nextTime) ;
    }
}
----

[source,c]
----
<<arm7m static functions>>=
static void
mrtInitSysTimer(void)
{
    RTC_Reset() ;
    /*
     * Set RTC prescaler to divide by 8.
     */
    CMU_ClockDivSet(cmuClock_RTC, cmuClkDiv_8) ;
    /*
     * Enable Low Freq A Clock to run the RTC.
     */
    CMU_ClockEnable(cmuClock_RTC, true) ;
    RTC_Init_TypeDef init = RTC_INIT_DEFAULT ;
    init.enable = false ;
    RTC_Init(&init) ;
    /*
     * Enable interrupt at the NVIC.
     */
    NVIC_ClearPendingIRQ(RTC_IRQn) ;
    NVIC_EnableIRQ(RTC_IRQn) ;
}
----

=== ARM 7M Async Execution Interface

[source,c]
----
<<arm7m external functions>>=
MRT_SyncParams *
mrt_SyncRequest(
    MRT_SyncFunc f)
{
    beginCriticalSection() ;
    MRT_SyncParams *params = mrtSyncQueuePut(f, true) ;
    endCriticalSection() ;
    SCB->ICSR = SCB_ICSR_PENDSVSET_Msk ;
    return params ;
}
----

The alternate interface is also easily implemented.

[source,c]
----
<<arm7m external functions>>=
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc f)
{
    beginCriticalSection() ;
    MRT_SyncParams *params = mrtSyncQueuePut(f, false) ;
    endCriticalSection() ;
    if (params) {
        SCB->ICSR = SCB_ICSR_PENDSVSET_Msk ;
    }
    return params ;
}
----

[source,c]
----
<<arm7m external functions>>=
void
PendSV_Handler(void)
{
    /*
     * Empty the foreground / background
     * synchronization queue.
     */
    for (MRT_SyncBlock blk = mrtSyncQueueGet() ; blk ; blk = syncQueueGet()) {
        if (blk->function) {
            blk->function(&blk->params) ;
        }
    }
}
----

=== ARM 7M Suspending Execution

[source,c]
----
<<arm7m static data>>=
uint8_t sysEnergyMode = 2 ;
----

[source,c]
----
<<arm7m static functions>>=
static void
mrtWait(void)
{
    beginCriticalSection() ;
    if (mrtSyncQueueEmpty()) {
        bool systick = (SysTick->CTRL & SysTick_CTRL_ENABLE_Msk) != 0 ;
        SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk ;

        switch (sysEnergyMode) {
        case 1:
            EMU_EnterEM1() ;
            break ;

        case 2:
        default:
            EMU_EnterEM2(true) ;
            break ;

        case 3:
            EMU_EnterEM3(true) ;
            break ;

        case 4:
            /*
             * Only the reset pin or power cycle wakes us up after this.
             */
            EMU_EnterEM4() ;
            break ;
        }

        if (systick) {
            SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk ;
        }
    }
    endCriticalSection() ;
}
----

=== ARM 7M Initialization

[source,c]
----
<<arm7m static functions>>=
static void
mrtPlatformInit(void)
{
    /*
     * Make sure and set up the vector table in case it has been moved from its
     * default location.
     */
    #pragma section=".intvec"
    SCB->VTOR = (uint32_t)__section_begin(".intvec") ;
    /*
     * Set stack align, so ISR's are truly ordinary "C" functions.
     */
    SCB->CCR |= SCB_CCR_STKALIGN_Msk ;
    /*
     * Workaround for chip errata.
     */
    CHIP_Init() ;
    /*
     * Update the global notion of the system clock frequency.  The device
     * drivers need this to calculate various dividers properly.
     */
    SystemCoreClockUpdate() ;
    /*
     * Bring the system clock down to 7 MHz.
     */
    CMU_HFRCOBandSet(cmuHFRCOBand_7MHz) ;
    /*
     * High frequency peripheral clock.
     */
    CMU_ClockDivSet(cmuClock_HFPER, cmuClkDiv_1) ;
    CMU_ClockEnable(cmuClock_HFPER, true) ;
    /*
     * Enable the LF Crystal Oscillator.
     */
    CMU_OscillatorEnable(cmuOsc_LFXO, true, true) ;
    /*
     * Enable the low energy clock bus.
     */
    CMU_ClockEnable(cmuClock_CORELE, true) ;
    /*
     * Select the external crystal oscillator for the low frequency clocks.
     */
    CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO) ;
    CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO) ;
    /*
     * Enable clocking the PRS.
     */
    CMU_ClockEnable(cmuClock_PRS, true) ;

#ifndef MRT_ARM_7M_SWO
    /*
     * We want to set up for SWO here.
     * Enable the HF Peripheral Clock to the GPIO block.
     */
    CMU_ClockEnable(cmuClock_GPIO, true) ;
    /*
     * To use Serial Wire Viewer we need to enable the auxiliary clock and
     * set up the I/O pins. SWO is wired to the location 0 pin out.
     */
    if (DBG_Connected()) {
        DBG_SWOEnable(SWO_LOCATION) ;
        /*
         * Keep the aux clock running in EM2 mode.
         */
        BITBAND_Peripheral(&EMU->CTRL, _EMU_CTRL_EMVREG_SHIFT, 1) ;
    }
#endif /* MRT_ARM_7M_SWO */
}
----

[source,c]
----
<<arm7m external functions>>=
void
mrt_Initialize(void)
{
    mrtPlatformInit() ;
    mrtEventPoolInit() ;
    mrtInitCriticalSection() ;
    mrtInitSysTimer() ;
}
----

== MSP430 Specific Code

[source,c]
----
<<msp430 includes>>=
#include "msp430.h"

#ifndef MRT_TIMER_FREQUENCY
#   define MRT_TIMER_FREQUENCY     4096UL
#endif /* MRT_TIMER_FREQUENCY */
#define MRT_MAX_CLOCK_TICKS     (UINT32_MAX - 1)
#define MRT_MAX_MSEC_DELAY\
        ((MRT_MAX_CLOCK_TICKS / MRT_TIMER_FREQUENCY) * 1000UL)
----

=== MSP430 Critical Sections

[source,c]
----
<<arm7m static functions>>=
static inline
void
mrtInitCriticalSection(void)
{
}
static inline
void
beginCriticalSection(void)
{
    __disable_interrupt() ;
}
static inline
void
endCriticalSection(void)
{
    __enable_interrupt() ;
}
----

=== MSP430 Timing Interfaces

[source,c]
----
<<msp430 static functions>>=
static inline
MRT_DelayTime
mrtMsecToTicks(
    MRT_DelayTime msec)
{
    if (msec > MRT_MAX_MSEC_DELAY) {
        msec = MRT_MAX_MSEC_DELAY ;
    }
    /*
     * We must avoid overflow if the requested number of
     * msecs is large.
     */
    return msec < MRT_MAX_CLOCK_TICKS / MRT_TIMER_FREQUENCY ?
            ((msec * MRT_TIMER_FREQUENCY) + 1000UL / 2UL) / 1000UL :
            ((msec + 1000UL / 2UL) / 1000UL) * MRT_TIMER_FREQUENCY ;
}
----

[source,c]
----
<<msp430 static functions>>=
static inline
MRT_DelayTime
mrtTicksToMsec(
    MRT_DelayTime ticks)
{
    return ticks < MRT_MAX_CLOCK_TICKS / 1000UL ?
        ((ticks * 1000UL) + MRT_TIMER_FREQUENCY / 2UL) / MRT_TIMER_FREQUENCY :
        ((ticks + MRT_TIMER_FREQUENCY / 2UL) / MRT_TIMER_FREQUENCY) * 1000UL ;
}
----

[source,c]
----
<<msp430 static functions>>=
static void
mrtSysTimerMask(void)
{
    TACCTL0 &= ~CCIE ;
}
----

[source,c]
----
<<msp430 static functions>>=
static void
mrtSysTimerUnmask(void)
{
    TACCTL0 &= ~CCIFG ;
    TACCTL0 |= CCIE ;
}
----

[source,c]
----
<<msp430 static functions>>=
static void
mrtSysTimerStart(
    MRT_DelayTime time)
{
    clockCnts = ticks >> 16 ;
    setNextTime(ticks) ;
}
----

[source,c]
----
<<msp430 static data>>=
/*
 * We keep a higher precision time indication by counting Timer A overflows.
 * This variable holds the number of Timer A overflow interrupts that have
 * occurred. When concatenated with the value of the TAR register from
 * Timer A and treated as a 32 bit quantity, the value represented is the
 * time since the system started as a U(20,12) fixed radix point number
 * in units of seconds (this is because we are running timer A off of the
 * 32 KHz clock divided down by 8 ==> 4096 ticks / sec). For 20 integer bits of
 * seconds, the clock time value rolls over after ~1,000,000 seconds or
 * about 12.1 days.
 *
 * Use the function, "sysTimeTicks()" to obtain the time value.
 */
static uint16_t timerTicks ;
static uint16_t clockCnts ;
----

[source,c]
----
<<msp430 static functions>>=
static inline
uint16_t
readTimer(void)
{
#   define  SUCCESSIVE_MATCHES  3

    uint16_t cmp1Reg ;
    uint16_t cmp2Reg ;
    uint8_t cnt ;

    cnt = 1 ;
    cmp1Reg = TAR ;
    do {
        cmp2Reg = TAR ;
        cnt = cmp1Reg == cmp2Reg ? cnt + 1 : 1 ;
        cmp1Reg = cmp2Reg ;
    } while (cnt < SUCCESSIVE_MATCHES) ;

    return cmp2Reg ;

#   undef SUCCESSIVE_MATCHES
}
----

[source,c]
----
<<msp430 static functions>>=
/*
 * To get a high resolution time value we combine the in memory counter that
 * counts timer overflows with the current value of the timer register (TAR).
 * However we must be careful here because the counter is shared with an
 * interrupt service routine. So we make this function a "monitor" function and
 * we must check that the interrupt flag is not set right after we read the
 * timer value. If it is, then the memory counter will be off by one since
 * there is a pending interrupt that has not been serviced.
 */
#pragma type_attribute=__monitor
uint32_t
sysTimeTicks(void)
{
    uint16_t tvalue = readTimer() ;
    /*
     * If the timer rolls over between the time we enter this function and the
     * time we get here, then the interrupt flag will be set. In that case, the
     * memory counter will be off by one (since the interrupt service routine
     * will NOT have been run as we are in a "monitor" function).  Also we can
     * assume the timer value is simply zero, reflecting the timer value when
     * the roll over occurs (as it will not take a tick's worth of time to
     * execute to here.
     *
     * If there is no roll over of the timer, then the time is simply the
     * concatenation of the memory counter value and the timer value.
     */
    return (IFG1 & TAIFG) ?
        (((uint32_t)timerTicks + 1) << 16) :
        (((uint32_t)timerTicks << 16) | tvalue) ;
}
----

[source,c]
----
<<msp430 static functions>>=
#pragma type_attribute=__monitor
static void
setNextTime(
    uint16_t clockTicks)
{
    if (clockTicks == 1) {
        ++clockTicks ;
    }
    TACCR0 = readTimer() + clockTicks ;
    mrtSysTimerUnmask() ;
}
----

[source,c]
----
<<msp430 static functions>>=
static MRT_DelayTime
mrtSysTimerStop(void)
{
    MRT_DelayTime remain ;

    mrtSysTimerMask() ;
    uint16_t timer = readTimer() ;
    /*
     * Account that the timer might go off between when we
     * stop it and when we read it.
     */
    if (TACCTL0 & CCIFG) {
        remain = clockCnts ?
                (MRT_DelayTime)(clockCnts - 1) << 16 : 0 ;
    } else {
        remain = TACCR0 - timer ;
        remain += (MRT_DelayTime)clockCnts << 16 ;
    }
    return remain ;
}
----

[source,c]
----
<<msp430 static functions>>=
#pragma vector=TIMERA0_VECTOR
static __interrupt
void
timerA0ISR(void)
{
    if (clockCnts == 0) {
        MRT_DelayTime next = mrt_TimerExpireService() ;
        if (next) {
            mrtSysTimerStart(next) ;
        }
        __low_power_mode_off_on_exit() ;
    } else {
        /*
         * Loading the compare register with the timer
         * value causes us to count an entire 16 bits worth
         * of ticks.
         */
        TACCR0 = TAR ;
        --clockCnts ;
    }
}
----

[source,c]
----
<<msp430 static functions>>=
static void
mrtInitSysTimer(void)
{
    /*
     * Stop and Clear the timer.
     */
    TACTL = TACLR ;
    /*
     * Set up clock source to ACLK and Divide down by 8.
     */
    TACTL |= TASSEL_1 | ID_3 ;
    TACCTL0 = 0 ;
    TACCTL1 = 0 ;
    TACCTL2 = 0 ;
    /*
     * Start the timer in continuous mode. 
     * Enable the timer overflow interrupt.
     */
    TACTL |= MC_2 | TAIE ;
    /*
     * Zero out the upper level counter that keeps track of ticks.
     */
    timerTicks = 0 ;
}
----

=== MSP430 Async Execution Interface

[source,c]
----
<<msp430 external functions>>=
MRT_SyncParams *
mrt_SyncRequest(
    MRT_SyncFunc f)
{
    return mrtSyncQueuePut(f, true) ;
}
----

[source,c]
----
<<msp430 external functions>>=
MRT_SyncParams *
mrt_TrySyncRequest(
    MRT_SyncFunc f)
{
    return mrtSyncQueuePut(f, false) ;
}
----

=== MSP430 Suspending Execution

[source,c]
----
<<msp430 static functions>>=
static void
mrtWait(void)
{
    beginCriticalSection() ;
    if (mrtSyncQueueEmpty()) {
        __bis_SR_register(LPM0_bits | GIE) ;
    } else {
        endCriticalSection() ;
    }
}
----

=== MSP430 Initialization

[source,c]
----
<<msp430 external functions>>=
void
mrt_Initialize(void)
{
    mrtEventPoolInit() ;
    mrtInitCriticalSection() ;
    mrtInitSysTimer() ;
}
----

== Code Organization

[source,c]
----
<<standard includes>>=
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdalign.h>
#include <stdnoreturn.h>
#include <string.h>
#include <assert.h>
----

[source,c]
----
<<common includes>>=
#include "micca_rt.h"
#include <inttypes.h>
----

[source,c]
----
<<common defines>>=
#ifndef COUNTOF
#define COUNTOF(a)  (sizeof(a) / sizeof(a[0]))
#endif /* COUNTOF */
----

[source,c]
----
<<conditional compilation tests>>=
#if defined(MRT_HARNESS) && (defined(MRT_NO_NAMES) || defined(MRT_NO_TRACE))
#error "test harness requires both MRT_NO_NAMES and MRT_NO_TRACE to be undefined"
#endif
----

=== POSIX Files

[source,c]
----
<<micca_rt_posix.h>>=
/*
<<copyright info>>
<<version info>>
*/

#ifndef MICCA_RT_H_
#define MICCA_RT_H_

/*
 * Standard Includes
 */
<<standard includes>>

/*
 * Preprocessor Defines
 */
<<common defines>>
/*
 * Constants
 */
<<mrt constants>>

/*
 * Data Types
 */
<<mrt interface simple types>>
<<mrt interface aggregate types>>

#   ifndef MRT_NO_TRACE
<<mrt trace aggregate types>>
#   endif /* MRT_NO_TRACE */

/*
 * Static Inline Functions
 */
<<mrt interface static inlines>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external interfaces>>
#   endif /* MRT_NO_TRACE */

<<mrt external interfaces>>
<<posix external interfaces>>

#endif /* MICCA_RT_H_ */
----

[source,c]
----
<<micca_rt_posix.c>>=
/*
<<copyright info>>
<<version info>>
*/

<<conditional compilation tests>>

#define _POSIX_C_SOURCE 200112L

<<common includes>>
<<posix includes>>

/*
 * Constants
 */
<<mrt implementation constants>>

/*
 * Data Types
 */
<<mrt implementation simple types>>
<<mrt implementation aggregate types>>
<<posix implementation aggregate types>>

/*
 * Forward References
 */
<<mrt forward references>>
<<posix forward references>>

/*
 * Static Data
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static data>>
#   endif /* MRT_NO_TRACE */

<<mrt static data>>
<<posix static data>>

/*
 * Static Inline Functions
 */
<<mrt implementation static inlines>>

/*
 * Static Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static functions>>
#   endif /* MRT_NO_TRACE */

<<posix static functions>>
<<mrt static functions>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external functions>>
#   endif /* MRT_NO_TRACE */

<<posix external functions>>
<<mrt external functions>>
----

=== ARM 7M Files

[source,c]
----
<<micca_rt_arm7m.h>>=
/*
<<copyright info>>
<<version info>>
*/

#ifndef MICCA_RT_H_
#define MICCA_RT_H_

#define MRT_ARM_ARCH_7M

/*
 * Standard Includes
 */
<<standard includes>>

/*
 * Preprocessor Defines
 */
<<common defines>>
/*
 * Constants
 */
<<mrt constants>>

/*
 * Data Types
 */
<<mrt interface simple types>>
<<mrt interface aggregate types>>

#   ifndef MRT_NO_TRACE
<<mrt trace aggregate types>>
#   endif /* MRT_NO_TRACE */

/*
 * Static Inline Functions
 */
<<mrt interface static inlines>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external interfaces>>
#   endif /* MRT_NO_TRACE */

<<mrt external interfaces>>

#endif /* MICCA_RT_H_ */
----

[source,c]
----
<<micca_rt_arm7m.c>>=
/*
<<copyright info>>
<<version info>>
*/

<<conditional compilation tests>>

<<common includes>>
<<arm7m includes>>

/*
 * Constants
 */
<<mrt implementation constants>>

/*
 * Data Types
 */
<<mrt implementation simple types>>
<<mrt implementation aggregate types>>

/*
 * Forward References
 */
<<mrt forward references>>
<<arm7m forward references>>

/*
 * Static Data
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static data>>
#   endif /* MRT_NO_TRACE */

<<mrt static data>>
<<arm7m static data>>

/*
 * Static Inline Functions
 */
<<mrt implementation static inlines>>

/*
 * Static Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static functions>>
#   endif /* MRT_NO_TRACE */

<<arm7m static functions>>
<<mrt static functions>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external functions>>
#   endif /* MRT_NO_TRACE */

<<arm7m external functions>>
<<mrt external functions>>
----

=== MSP430 Files

[source,c]
----
<<micca_rt_msp430.h>>=
/*
<<copyright info>>
<<version info>>
*/

#ifndef MICCA_RT_H_
#define MICCA_RT_H_

/*
 * Standard Includes
 */
<<standard includes>>

/*
 * Preprocessor Defines
 */
<<common defines>>
/*
 * Constants
 */
<<mrt constants>>

/*
 * Data Types
 */
<<mrt interface simple types>>
<<mrt interface aggregate types>>

#   ifndef MRT_NO_TRACE
<<mrt trace aggregate types>>
#   endif /* MRT_NO_TRACE */

/*
 * Static Inline Functions
 */
<<mrt interface static inlines>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external interfaces>>
#   endif /* MRT_NO_TRACE */

<<mrt external interfaces>>

#endif /* MICCA_RT_H_ */
----

[source,c]
----
<<micca_rt_msp430.c>>=
/*
<<copyright info>>
<<version info>>
*/

<<conditional compilation tests>>

<<common includes>>
<<msp430 includes>>

/*
 * Constants
 */
<<mrt implementation constants>>

/*
 * Data Types
 */
<<mrt implementation simple types>>
<<mrt implementation aggregate types>>

/*
 * Forward References
 */
<<mrt forward references>>
<<msp430 forward references>>

/*
 * Static Data
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static data>>
#   endif /* MRT_NO_TRACE */

<<mrt static data>>
<<msp430 static data>>

/*
 * Static Inline Functions
 */
<<mrt implementation static inlines>>

/*
 * Static Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace static functions>>
#   endif /* MRT_NO_TRACE */

<<msp430 static functions>>
<<mrt static functions>>

/*
 * External Functions
 */
#   ifndef MRT_NO_TRACE
<<mrt trace external functions>>
#   endif /* MRT_NO_TRACE */

<<msp430 external functions>>
<<mrt external functions>>
----
