// vim:set syntax=asciidoc:

= An Example

== Introduction

In this section,
we discuss an example that illustrates the usage of `micca`.
Unfortunately,
there is rather a lot of background material that we will not cover here.
We do not explain how to create an XUML model
nor will we spend much time explaining why the example model was designed
the way it was.
There are many good books that explain XUML in detail and will teach
you the basics of modelingfootnote:[
<<mb-xuml,Mellor and Balcer>>,
<<rs-xuml,Chris Raistrick _et.al_>> and
<<ls-build,Leon Starr>> all are worthy of a close reading.].
We suggest you read at least one of them.
It is also the case that this package represents one particular piece
of a larger workflow and this means that readers who may not be
completely familiar with model-driven translation oriented development
may have many questions that remain.

The subject matter of our example is an automatic clothes washer.
This is a very simple washing machine,
especially compared to modern commercially available washers.
The intent is to select a subject that most people would be familiar
with from ordinary experience so that we don't have to devote too much
time explaining the problem.
One word of caution.
This model is an example for pedagogical purposes
and probably has little correspondence with the way _real_ washing
machines operate or are designed to operate.
You will also notice a lack of any attention paid to _what can go wrong_.
For industrial strength programs,
handling probable failure cases is very important but we have dispensed
with those considerations here to focus on how the model is
translated into the implementation code using +rosea+.

=== Domain Data

The figure below shows a class diagram for the washing machine control
domain in UML graphical notation.

[[class-diagram,class diagram]]

image::wmc-class-diagram.pdf[title="Washing Machine Class Diagram"]

In our world,
a Washing Machine operates according to some Washing Cycle.
The Washing Cycle is a set of parameters that specifies aspects of
the washing that will turn dirty clothes into clean ones.
The Washing Machine itself has a Clothes Tub into which the dirty
laundry is placed.
There are also Water Valves to control the flow of water into and out of
the Clothes Tub and Motors to run a water pump, agitate the
Clothes Tub and rotate the Clothes Tub to spin excess water out of the
clean laundry.
Rounding out the machinery,
there is a Water Level Sensor that will tell us when the Clothes Tub
is filled with water or empty of water.

For a well engineered model,
the class diagram must also have a set of descriptions of what
the attributes and relationship actually mean,
what the value domains of the attributes are and many other
aspects that describe how the problem is represented in the model.
These descriptions are vital to understanding a class diagram.
Here again, in the interests of space,
we will have to suffice ourselves with more casual descriptions
included along with the example as it translated into the implementation
and an admonition that writing the model descriptions is an essential
aspect of a well engineered solution.

The class diagram shows the static aspects of our domain
and is always the first aspect of the model that must be considered
when deriving the implementation.
The class diagram facet of the model is static in the sense that
at any point in time,
the logical predicates you can infer from the diagram will be true.
The classes hold the parameters of the domain and the relationships
state how the components are associated with respect to each other.
Later, we visit the dynamic and algorithmic facets of the domain
but, for now, we will endeavor to represent the classes and relationships
in terms of the +rosea+ package constructs.

==== Washing Machine Class

By examining the graphics of the model we can see that the Washing Machine
class has attributes, participates in associations and has a state model.

[source,tcl]
----
<<WM class>>=
class WashingMachine {
    <<WM attributes>>
    statemodel {
        <<WM statemodel>>
    }
}
----

Looking at the Washing Machine class on the <<class-diagram,class diagram>>,
we see that there are two attributes.
The MachineID attribute is an identifier and we make its data type
a simple string.
The CycleType attribute is referential attribute and we will not need it.

[source,tcl]
----
<<WM attributes>>=
attribute MachineID {char const *} -id 1
----

While we are discussing R4, we can define its characteristics.
We can represent the participating classes, multiplicity and conditionality as
presented in the class diagram by the following domain configuration statement.

[source,tcl]
----
<<wmctrl relationships>>=
association R4 WashingMachine 0..*--1 WashingCycle
----

==== Washing Cycle Class

Examining the class diagram and other graphics for the domain shows that
the Washing Cycle class is a simple class consisting entirely of
descriptive attributes.

[source,tcl]
----
<<WC class>>=
class WashingCycle {
    <<WC attributes>>
}
----

We need only specify the attributes and their data types,
marking the CycleType as the identifier (as was shown in the graphic).
In order to determine the proper data types of the attributes we
would need to consult the descriptive text associated with the class diagram.
As we have no such text in this example,
we will infer a set of data types based on how the attribute values
will be used in the processing.

[source,tcl]
----
<<WC attributes>>=
attribute CycleType {char const *}
attribute WashWaterTemp WaterTemp
attribute RinseWaterTemp WaterTemp
attribute WashDuration int
attribute RinseDuration int
attribute SpinDuration int
attribute AgitationSpeed WashSpeed
attribute SpinSpeed WashSpeed
----

[source,tcl]
----
<<type aliases>>=
typealias WaterTemp {enum {WT_Hot, WT_Cold, WT_Warm}}
----

==== Clothes Tub Class

By now the pattern of examining the model graphics to determine
the class characteristics is established.
The Clothes Tub class is an active class with a state model.
A Clothes Tub only has identifying and referential attributes what are
elided.

[source,tcl]
----
<<CT class>>=
class ClothesTub {
    statemodel {
        <<CT statemodel>>
    }
}
----

The `R1` association itself can be transcribed from the graphic as follows.

[source,tcl]
----
<<wmctrl relationships>>=
association R1 ClothesTub 1--1 WashingMachine
----

==== Water Valve Class

The Water Valve class represents the means to move water into and out of
a Clothes Tub.

[source,tcl]
----
<<WV class>>=
class WaterValve {
    <<WV attributes>>
    <<WV operations>>
}
----

[source,tcl]
----
<<WV attributes>>=
attribute ValveID ValveType
----

[source,tcl]
----
<<type aliases>>=
typealias ValveType {enum {WV_Hot, WV_Cold, WV_Drain}}
----

The R3 relationship represents the design of the washing machine hardware
that includes three valves on each machine.
Notice the we don't concern ourselves here with whether a washing machine
has three or three thousand valves on it.
That is dealt with when we populate the class instances.
The important point here is that there is one or more valves associated
with each tub.

[source,tcl]
----
<<wmctrl relationships>>=
association R3 WaterValve 1..*--1 ClothesTub
----

==== Motor Class

The Motor class is similar to the Water Valve class.

[source,tcl]
----
<<MTR class>>=
class Motor {
    <<MTR attributes>>
    <<MTR operations>>
}
----

[source,tcl]
----
<<MTR attributes>>=
attribute MotorID MotorType
----

[source,tcl]
----
<<type aliases>>=
typealias MotorType {enum {MTR_Pump, MTR_Agitator, MTR_Spin}}
----

The R2 relationships states the hardware design of using one or more
motors to operation a clothes tub.

[source,tcl]
----
<<wmctrl relationships>>=
association R2 Motor 1..*--1 ClothesTub
----

==== Water Level Sensor

The Water Level Sensor class is also simple.

[source,tcl]
----
<<WLS class>>=
class WaterLevelSensor {
    <<WLS operations>>
}
----

It is R5 that sets the rule about one Water Level Sensor per Clothes Tub.

[source,tcl]
----
<<wmctrl relationships>>=
association R5 WaterLevelSensor 1--1 ClothesTub
----

=== Domain Dynamics

The second facet of the model that is considered during translation
is the dynamics.
The model encodes the sequences of domain execution as state models
attached to classes.
In this model,
there are two classes for which state models are defined,
Washing Machine and Clothes Tub.
The control is partitioned by the model between these classes.
The Washing Machine class is given the responsibility for coordinating
the actions needed to clean clothes according to the particulars
specified by the Washing Cycle.
In this example that coordination primarily involves timing the various
components of the washing cycle.
The Clothes Tub class deals with sequencing the mechanics of the washer
to perform a specific activity.

For each state model we will present a graphical representation of
the state model.
We also show the state transition table.
It is important to have both representations.
In the graphic,
it is conventional not to show ignored or error transitions.
However,
in the transition table all possible transitions and their outcomes
are exposed.

==== Washing Machine State Model

The state model for the Washing Machine class is shown below.
You will notice that in the graphic
the states contain action language statements that specify
the processing to be performed when the state is entered.
We will say more about the actions when we take up the domain processing
below.
For now,
it is convenient to have the actions present on the diagram in order
to better understand exactly what the washing machine will do as it
responds to events and thereby better understand how the state machines
achieve the overall result of producing clean clothes.

image::wm-states.pdf[title="Washing Machine State Model Diagram"]

From the diagram we can see how the washing machine cycles in a rather
simple circular form filling, washing, draining, rinsing and spinning
to convert dirty clothes into clean ones.
The state activities are primarily concerned with obtaining the
particular details of the next step and requesting the Clothes Tub
to carry out that step.
The various durations are handled by signaling delayed events
to march things along to the next step in the cleaning.

The transition table corresponding to the diagram is shown next.

.Washing Machine Transition Table
[options="header,unbreakable",cols="<h,4*^"]
|===========================
|                   |Start              |Full       |Done           |Empty
|Stopped            |Filling To Wash    |CH         |CH             |CH
|Filling To Wash    |CH                 |Washing    |CH             |CH
|Washing            |CH                 |CH         |Draining Wash  |CH
|Draining Wash      |CH                 |CH         |CH             |Filling To Rinse
|Filling To Rinse   |CH                 |Rinsing    |CH             |CH
|Rinsing            |CH                 |CH         |Draining Rinse |CH
|Draining Rinse     |CH                 |CH         |CH             |Spinning
|Spinning           |CH                 |CH         |Stopped        |CH
|===========================

The transition table may be directly translated into the required
`rosea` configuration statements.
Below, we have not shown the Tcl code that executes for each
state activity.
We will return to the processing below.
For now, we use a set of literate program chunks to represent the
state activity code in order to get a clearer view of how the transition
table is represented as `statemodel` configuration statements.

[source,tcl]
----
<<WM statemodel>>=
initialstate Stopped
defaulttrans CH

state Stopped {} {
    <<WM stopped activity>>
}
transition Stopped - Start -> FillingToWash

state FillingToWash {} {
    <<WM filling to wash activity>>
}
transition FillingToWash - Full -> Washing

state Washing {} {
    <<WM washing activity>>
}
transition Washing - Done -> DrainingWash

state DrainingWash {} {
    <<WM draining wash activity>>
}
transition DrainingWash - Empty -> FillingToRinse

state FillingToRinse {} {
    <<WM filling to rinse activity>>
}
transition FillingToRinse - Full -> Rinsing

state Rinsing {} {
    <<WM rinsing activity>>
}
transition Rinsing - Done -> DrainingRinse

state DrainingRinse {} {
    <<WM draining rinse activity>>
}
transition DrainingRinse - Empty -> Spinning

state Spinning {} {
    <<WM spinning activity>>
}
transition Spinning - Done -> Stopped
----

==== Clothes Tub State Model

The diagram below shows the state model for the Clothes Tub class.
This model is _not_ circular like that of the Washing Machine
class.
There are two paths through the states.
One corresponds to agitating the tub for the purposes of either
washing or rinsing.
The other path corresponds to spinning the tub to remove excess
water from the clean clothes.
Both paths start at the Empty state.

image::ct-states.pdf[title="Clothes Tub State Model Diagram"]

The transition table follows immediately from the diagram.

.Clothes Tub Transition Table
[options="header,unbreakable",cols="<h,7*^"]
|===========================
|              |Fill    |TubFull |Agitate   |Drain    |TubEmpty |Spin     |Stop
|Empty         |Filling |CH      |CH        |CH       |CH       |Spinning |CH
|Filling       |CH      |Full    |CH        |CH       |IG (1)   |CH       |CH
|Full          |CH      |CH      |Agitating |CH       |CH       |CH       |CH
|Agitating     |CH      |CH      |CH        |Emptying |CH       |CH       |CH
|Emptying      |CH      |IG (1)  |CH        |CH       |Empty    |CH       |CH
|Spinning      |CH      |CH      |CH        |CH       |CH       |CH       |Stopping Spin
|Stopping Spin |Filling |CH      |CH        |CH       |CH       |CH       |CH
|===========================

(1) For the *Filling* and *Emptying* states,
we allow for the fact that when the water level sensor is
enabled it may send events that reflect its current state.
So we simply ignore those sensor events in which we are not currently
interested.

The `rosea` configuration statements follow directly from the transition table.

[source,tcl]
----
<<CT statemodel>>=
initialstate Empty
defaulttrans CH

state Empty {} {
    <<CT empty activity>>
}
transition Empty - Fill -> Filling
transition Empty - Spin -> Spinning

state Filling {temp WaterTemp} {
    <<CT filling activity>>
}
transition Filling - TubFull -> Full
transition Filling - TubEmpty -> IG

state Full {} {
    <<CT full activity>>
}
transition Full - Agitate -> Agitating

state Agitating {} {
    <<CT agitating activity>>
}
transition Agitating - Drain -> Emptying

state Emptying {} {
    <<CT emptying activity>>
}
transition Emptying - TubEmpty -> Empty
transition Emptying - TubFull -> IG

state Spinning {} {
    <<CT spinning activity>>
}
transition Spinning - Stop -> StoppingSpin

state StoppingSpin {} {
    <<CT stopping spin activity>>
}
transition StoppingSpin - Fill -> Filling
----

=== Domain Processing

The third facet of the model that must be translated is the processing.
Processing is executed in state activities or the various operations
of the domain or classes.
We represent the processing as action language.
There are several different action languages that are in use.
In the example,
we follow an <<mb-xuml,established syntax>> for the actions.
All the action languages allow for writing expressions and for
performing model level processing.
Since we are not parsing the action language in this context,
we are not particular about the syntax as long as the action statements
convey the required processing unambiguously.

For state activities,
the diagrams above show the action language that is to be executed
when the state is entered.
In the translations below,
we duplicate the action language from the state and write the translation to
Tcl code immediately following.
In most cases,
the translation maps one action language statement to one Tcl command.

The model level actions performed by the state activities,
such as access to attribute values, navigating the class diagram
or signaling events
is accomplished by invoking the procedures that we discussed in the
<<packageprocedures>> section.

==== Washing Machine State Activities

Below is the processing for the Washing Machine state activities.
For the first few states,
we will make several comments on the correspondence between the
action language statements and the Tcl code.
After the translation pattern is established,
we present the remaining state with minimal explanation.
In the interest of clarity,
no attempt has been made to shorten or optimize the Tcl code.
There will be cases where some variable assignments will seem
superfluous and command nesting might seem a more natural
way to express the logic.
Here we are trying to emphasize the relationships between the
action language statements and the Tcl code.
In delivered code, we might be more succinct.

// %States images/wm-states.uxf WashingMachine

// %Action WashingMachine Stopped
.Stopped Activity Action Language
----
# Stop spinning -- wash complete
select one ct related by self->R1[CT]
signal Stop to ct
----
The Stopped state of the Washing Machine is entered when the cycle
is complete and we must signal the Clothes Tub to stop spinning.
The action consists of finding the related Clothes Tub instance
and signaling the Stop event to it.

.Stopped Implementation
[source,tcl]
----
<<WM stopped activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Stop>%
----
Recall that all state activities have an implicit `self` argument
defined for them.
With the Clothes Tub instance in hand,
it is then signaled to Stop using the `signal`
instance command that we have already seen.
There are a couple things to note here.

. The use of the direction syntax, _i.e._ `~R1`, obviates the need to
say that we are navigating to an instance of the `CT` class in the
manner that the action language statement does.
Because of the syntax convention and the manner in which the
association was defined,
the system knows the destination class.
. The question arises whether the instance reference returned from
`findOneRelated` in the above traversal across `~R1`
can ever be the empty reference or ever reference multiple instances.
The answer is no!
The `R1` association,
as shown in the class diagram,
is singular and unconditional on the Clothes Tub side.
Every traversal from Washing Machine to Clothes Tub along `~R1` is guaranteed
to return exactly one instance.
Any operation in the domain that would perturb that state of affairs
is rejected as violating the referential integrity of the
class diagram.
Consequently,
no test of the multiplicity of the returned reference is necessary as the
system is already making that test and so it would be strictly redundant.
In general,
traversing unconditional relationships never requires a test to determine if
we obtained an instance reference and traversing a conditional relationship
should always be followed by a test of the returned reference to
see if it is empty.
The fact that a relationship is conditional implies that there is
to be conditional processing associated with traversing the relationship.

'''

// %Action WashingMachine "Filling To Wash"
.Filling To Wash Activity Action Language
----
# Fill the tub with wash water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.WashWaterTemp) to ct
----

.Filling To Wash Implementation
[source,tcl]
----
<<WM filling to wash activity>>=
%<instance wc findOneRelated self R4>%
%<instance ct findOneRelated self ~R1>%
WaterTemp t = %<instance wc attribute WashWaterTemp>% ;
%<instance ct signal Fill temp t>%
----

'''

// %Action WashingMachine Washing
.Washing Activity Action Language
----
# Agitate the tub to wash.
select one ct related by self->R1[CT]
signal Agitate to ct
select one wc related by self->R4[WC]
signal Done to self at wc.WashDuration
----
While in the Washing state, clothes are being agitated in the tub.
The state uses a delayed event to determine when the washing part of
the cycle is finished.
Note that the delay time of the signal is an attribute value obtained
from the Washing Cycle class.
Here Washing Cycle serves a role of holding attributes that just specify
conditions for another class
This is a common arrangement.

.Washing Implementation
[source,tcl]
----
<<WM washing activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Agitate>%
%<instance wc findOneRelated self R4>%
MRT_DelayTime duration = %<instance wc attribute WashDuration>% * 1000 ;
%<instance self delaysignal duration Done>% // <1>
----
<1> We are implicitly assuming the units of WashDuration are seconds.
In truth, the units are minutes, but we are not patient enough
to wait that long for the example to execute.

The delayed signal is accomplished by using the `delaysignal` procedure.
Notice that the event is self directed, albeit delayed by the washing
cycle time.
So this state sends two signals,
one to the Clothes Tub to tell it to start agitating the clothes
and a delayed signal to itself so it when know when the clothes have
been washing long enough.

'''

// %Action WashingMachine "Draining Wash"
.Draining Wash Activity Action Language
----
# Stop washing and drain
# the dirty wash water.
select one ct related by self->R1[CT]
signal Drain to ct
----

.Draining Wash Implementation
[source,tcl]
----
<<WM draining wash activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Drain>%
----

'''

// %Action WashingMachine "Filling To Rinse"
.Filling To Rinse Activity Action Language
----
# Fill the tub with rinse water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.RinseWaterTemp) to ct
----

.Filling To Rinse Implementation
[source,tcl]
----
<<WM filling to rinse activity>>=
%<instance wc findOneRelated self R4>%
%<instance ct findOneRelated self ~R1>%
WaterTemp t = %<instance wc attribute RinseWaterTemp>% ;
%<instance ct signal Fill temp t>%
----

'''

// %Action WashingMachine Rinsing
.Rinsing Activity Action Language
----
# Agitate the tub to rinse.
select one ct related by self->R1[CT]
signal Agitate to ct
select one wc related by self->R4[WC]
signal Done to self at wc.RinseDuration
----

.Rinsing Implementation
[source,tcl]
----
<<WM rinsing activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Agitate>%
%<instance wc findOneRelated self R4>%
MRT_DelayTime rinse = %<instance wc attribute RinseDuration>% * 1000 ;
%<instance self delaysignal rinse Done>%
----

'''

// %Action WashingMachine "Draining Rinse"
.Draining Rinse Activity Action Language
----
# Stop rinsing and drain
# the rinse water.
select one ct related by self->R1[CT]
signal Drain to ct
----

.Draining Rinse Implementation
[source,tcl]
----
<<WM draining rinse activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Drain>%
----

'''

// %Action WashingMachine Spinning
.Spinning Activity Action Language
----
# Spin out excess water.
select one ct related by self->R1[CT]
signal Spin to ct
select one wc related by self->R4[WC]
signal Done to self at wc.SpinDuration
----

.Spinning Implementation
[source,tcl]
----
<<WM spinning activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Spin>%
%<instance wc findOneRelated self R4>%
MRT_DelayTime spin = %<instance wc attribute SpinDuration>% * 1000 ;
%<instance self delaysignal spin Done>%
----

==== Clothes Tub State Activities

The other state model in our example is for the Clothes Tub class

// %States images/ct-states.uxf ClothesTub

// %Action ClothesTub Empty
.Empty Activity Action Language
----
# Stop the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Stop()
# Close the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Close()
# Disable the sensor
select one wls related by self->R5[WLS]
wls.Disable()
# Inform the washing machine
select one wm related by self->R1[WM]
signal Empty to wm
----

.Empty Implementation
[source,tcl]
----
<<CT empty activity>>=
%<instance mtr foreachRelated self ~R2>%
    if (%<instance mrt attribute MotorID>% == MTR_Pump) {
        %<instance mtr operation Stop>%
        break ;
    }
%<end>%

%<instance wv foreachRelated self ~R3>%
    if (%<instance wv attribute ValveID>% == WV_Drain) {
        %<instance wv operation Close>%
        break ;
    }
%<end>%

%<instance wls findOneRelated self ~R5>%
%<instance wls operation Disable>%

%<instance wm findOneRelated self R1>%
%<instance wm signal Empty>%
----

'''

// %Action ClothesTub Filling
.Filling Activity Action Language
----
# Enable the sensor
select one wls related by self->R5[WLS]
wls.Enable()
# Open inlet valve(s)
if (temp = 'Hot')
    select one wv related by self->R3[WV]
        where (ValveID = 'Hot')
    wv.Open()
else if (temp = 'Cold')
    select one wv related by self->R3[WV]
        where (ValveID = 'Cold')
    wv.Open()
else if (temp = 'Warm')
    select many wvs related by self->R3[WV]
        where (ValveID = 'Hot' OR ValveID = 'Cold')
    foreach wv in wvs
        wv.Open()
    endfor
end if
----

.Filling Implementation
[source,tcl]
----
<<CT filling activity>>=
%<instance wls findOneRelated self ~R5>%
%<instance wls operation Enable>%
%<instance wv foreachRelated self ~R3>%
    ValveType vid = %<instance wv attribute ValveID>% ;
    if (temp == WT_Hot && vid == WV_Hot) {
        %<instance wv operation Open>%
        break ;
    } else if (temp == WT_Cold && vid == WV_Cold) {
        %<instance wv operation Open>%
        break ;
    } else if (temp == WT_Warm && (vid == WV_Hot || vid == WV_Cold)) {
        %<instance wv operation Open>%
    }
%<end>%
----

'''

// %Action ClothesTub Full
.Full Activity Action Language
----
# Disable the sensor
select one wls related by self->R5[WLS]
wls.Disable()
# Close all water valves
select many wvs related by self->R3[WV]
    where (ValveID = 'Hot' OR ValveID = 'Cold')
foreach wv in wvs
    wv.Close()
endfor
# Inform the washing machine
select one wm related by self->R1[WM]
signal Full to wm
----

.Full Implementation
[source,tcl]
----
<<CT full activity>>=
%<instance wls findOneRelated self ~R5>%
%<instance wls operation Disable>%
%<instance wv foreachRelated self ~R3>%
    ValveType vid = %<instance wv attribute ValveId>% ;
    if (vid == WV_Hot || vid == WV_Cold) {
        %<instance wv operation Close>%
    }
%<end>%
%<instance wm findOneRelated self R1>%
%<instance wm signal Full>%
----

'''

// %Action ClothesTub Agitating
.Agitating Activity Action Language
----
# Start the agitator motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Agitator')
mtr.Start()
----

.Agitating Implementation
[source,tcl]
----
<<CT agitating activity>>=
%<instance mtr foreachRelated self ~R2>%
    if (%<instance mtr attribute MotorId>% == MTR_Agitator) {
        %<instance mrt operation Start>%
        break ;
    }
%<end>%
----

'''

// %Action ClothesTub Emptying
.Emptying Activity Action Language
----
# Stop the motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Agitator')
mtr.Stop()
# Open the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Open()
# Start the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Start()
# Enable the sensor
select one wls related by self->R5[WLS]
wls.Enable()
----

.Emptying Implementation
[source,tcl]
----
<<CT emptying activity>>=
%<instance mtr foreachRelated self ~R2>%
    if (%<instance mtr attribute MotorId>% == MTR_Agitator) {
        %<instance mrt operation Stop>%
        break ;
    }
%<end>%
%<instance wv foreachRelated self ~R3>%
    if (%<instance wv attribute ValveId>% == WV_Drain) {
        %<instance wv operation Open>%
        break ;
    }
%<end>%
%<instance mtr foreachRelated self ~R2>%
    if (%<instance mtr attribute MotorId>% == MTR_Pump) {
        %<instance mrt operation Start>%
        break ;
    }
%<end>%
%<instance wls findOneRelated self ~R5>%
%<instance wls operation Enable>%
----

'''

// %Action ClothesTub Spinning
.Spinning Activity Action Language
----
# Open the drain valve
select one wv related by self->R2[WV]
     where (ValveID = 'Drain')
wv.Open()
# Start the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Start()
# Start the spin motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Spin')
mtr.Start()
----

.Spinning Implementation
[source,tcl]
----
<<CT spinning activity>>=
%<instance wv foreachRelated self ~R3>%
    if (%<instance wv attribute ValveId>% == WV_Drain) {
        %<instance wv operation Open>%
        break ;
    }
%<end>%
%<instance mtr foreachRelated self ~R2>%
    MotorType mid = %<instance mtr attribute MotorId>% ;
    if (mid == MTR_Pump || mid == MTR_Spin) {
        %<instance mrt operation Start>%
    }
%<end>%
----

'''

// %Action ClothesTub "Stopping Spin"
.Stopping Spin Activity Action Language
----
# Stop the motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Spin')
mtr.Stop()
# Stop the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Stop()
# Close the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Close()
----

.Stopping Spin Implementation
[source,tcl]
----
<<CT stopping spin activity>>=
%<instance mtr foreachRelated self ~R2>%
    MotorType mid = %<instance mtr attribute MotorId>% ;
    if (mid == MTR_Pump || mid == MTR_Spin) {
        %<instance mrt operation Stop>%
    }
%<end>%
%<instance wv foreachRelated self ~R3>%
    if (%<instance wv attribute ValveId>% == WV_Drain) {
        %<instance wv operation Close>%
        break ;
    }
%<end>%
----

==== Class Instance Operations

The Water Valve, Motor and Water Level Sensor classes have instance based
operations that serve as an interface to external operations that are intended
to perform the physical actions associated with the hardware.
The external operations that are invoked detail the dependencies this
domain assumes will be performed by some other domain.

[float]
==== Water Valve Operations

[source,tcl]
----
<<WV operations>>=
instop Open {} {
    external valveOpen vid %<instance self attribute ValveID>%
}

instop Close {} {
    external valveClose vid %<instance self attribute ValveID>%
}
----

[float]
==== Motor Class Operations

[source,tcl]
----
<<MTR operations>>=
instop Start {} {
    external motorStart vid %<instance self attribute MotorID>%
}

instop Stop {} {
    external motorStop vid %<instance self attribute MotorID>%
}
----

[float]
==== Water Level Sensor Operations

[source,tcl]
----
<<WLS operations>>=
instop Enable {} {
    external sensorEnable %<instance self attribute MachineID>%
}

instop Disable {} {
    external sensorDisable %<instance self attribute MachineID>%
}
----

==== Domain Operations

In this section we show the code for the domain operations.
We assume that there is some entity in our overall system that
will invoke these operations.
To make our example run,
we will contrive to make that happen
even though we do not intend to supply a user interface, _per se_.

[float]
==== Create Washer

Since there several classes involved in creating a functioning washer,
a domain operation can make that simpler.

(((proc,domain operation,createWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop MRT_InstId createWasher {washer {char const *}} {
    %<WashingMachine create wm MachineID washer>%
    %<WashingCycle findByName nwc Normal>%
    %<R4 relate nwc wm>%

    %<ClothesTub create ct>%
    %<R1 relate ct wm>%

    %<WaterValve create wv ValveID WV_Hot>%
    %<R3 relate wv wm>%
    %<WaterValve create wv ValveID WV_Cold>%
    %<R3 relate wv wm>%
    %<WaterValve create wv ValveID WV_Drain>%
    %<R3 relate wv wm>%

    %<Motor create mtr MotorID MTR_Pump>%
    %<R2 relate mtr wm>%
    %<Motor create mtr MotorID MTR_Agitator>%
    %<R2 relate mtr wm>%
    %<Motor create mtr MotorID MTR_Spin>%
    %<R2 relate mtr wm>%

    %<WaterLevelSensor create wls>%
    %<R5 relate wls wm>%

    return %<WashingMachine instid wm>%
}
----

[float]
==== Delete Washer

If we can create a washer, it is also necessary to be able to delete one.
Here we must be careful to leave the data model referentially consistent.

(((proc,domain operation,deleteWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void deleteWasher {washer {char const *}} {
    %<WashingMachine foreachInstance wm>%
        if (strcmp(washer, %<instance wm attribute MachineID>%) == 0) {
            %<instance ct findOneRelated wm ~R1>%
            %<instance wls findOneRelated ct ~R5>%
            %<R5 unrelate wls ct>%
            %<instance wls delete>%
            %<instance wv foreachRelated ct ~R3>%
                %<R3 unrelate wv ct>%
                %<instance wv delete>%
            %<end>%
            %<instance mtr foreachRelated ct ~R2>%
                %<R2 unrelate mtr ct>%
                %instance mtr delete>%
            %<end>%
            %<R1 unrelate ct wm>%
            %<instance ct delete>%
            %<instance wm delete>%
            return ;
        }
    %<end>%
    printf("unknown washer, %s\n", washer) ;
}
----

[float]
==== Start Washer

To start a washing machine we must supply the identifier of the
washer so we can know which one is to be started.
Although our instance population only included a single WashingMachine
instance,
as we stated before, the models will run with an arbitrary number
of washing machine instances.

The implementation of the operation first searches all the instances
of WashingMachine to find the correct one to start.
It is possible to request an unknown washer to start.
After finding the correct instance,
the *Start* event will kick things off.

(((proc,domain operation,startWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void startWasher {washer {char const *}} {
    %<WashingMachine foreachInstance wm>%
        if (strcmp(washer, %<instance wm attribute MachineID>%) == 0) {
            %<instance wm signal Start>%
            return ;
        }
    %<end>%
    printf("unknown washer, %s\n", washer) ;
}
----

[float]
==== Select Cycle

On the class diagram,
relationship `R4` determines which Washing Cycle will be used to
control the operations.
Selecting a wash cycle means we must reform the `R4` relationship,
_i.e._ unlink the existing cycle and link in a different one.
The implementation of the `selectCycle` domain operation does just that.

(((proc,domain operation,selectCycle)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void selectCycle {washer {char const *} cycle {char const *}} {
    %<WashingCycle instanceReference reqcycle>%
    reqcycle = NULL ;
    %<WashingCycle foreachInstance wc>%
        if (strcmp(cycle, %<instance wc attribute CycleType>%) == 0) {
            reqcycle = wc ;
        }
    %<end>%
    if (reqcycle == NULL) {
        printf("unknown washing cycle, %s\n", cycle) ;
        return ;
    }

    %<WashingMachine foreachInstance wm>%
        if (strcmp(washer, %<instance wm attribute MachineID) == 0) {
            %<instance wc findOneRelated wm R4>%
            %<R4 unrelate wm wc>%
            %<R4 relate wm reqcycle>%
            return ;
        }
    %<end>%
    printf("unknown washing machine, %s\n", washer) ;
}
----

=== Initial Instance Population

In this section we populate the data of the domain model.

// HERE
[source,tcl]
----
<<initial instance population>>=
class WashingCycle\
    {CycleType WashWaterTemp RinseWaterTemp WashDuration RinseDuration\
             SpinDuration AgitationSpeed SpinSpeed} {

    Normal Cold Cold 20 10 10 Medium Medium
    Whites Hot Cold 20 10 20 High High
    PermPress Warm Cold 15 10 15 Medium Medium
    Delicate Cold Cold 15 10 10 Low Low
}
----

We intend to have only a single WashingMachine instance and have chosen
to populate it directly rather than invoke `createWasher` in order to
show how that might happen.
Note that the model will run correctly regardless of how many washing
machines we are trying to control even though we are creating only
a single instance here.

[source,tcl]
----
<<initial instance population>>=
class WashingMachine {MachineID CycleType} {wm1 Normal}
----

The class model dictates that each washer have exactly one ClothesTub.

[source,tcl]
----
<<initial instance population>>=
class ClothesTub MachineID wm1
----

[source,tcl]
----
<<initial instance population>>=
class Motor\
    {MotorID    MachineID} {
    Pump        wm1
    Agitator    wm1
    Spin        wm1
}
----

Each washing machine, also by design,
has three valves to control hot and cold water and draining.

[source,tcl]
----
<<initial instance population>>=
class WaterValve\
    {ValveID    MachineID} {
    Hot         wm1
    Cold        wm1
    Drain       wm1
}
----

Finally, each washing machine has a sensor that can determine
whether the tub is full or empty.

[source,tcl]
----
<<initial instance population>>=
class WaterLevelSensor MachineID wm1
----

=== Stubbing the External Operations [[stubbing-external-operations]]

External operations invoked by the domain must be resolved.
In this section we stub out those operations with sufficient code
to be able to run our example program.

For the MOTOR and VALVE operations we will content ourselves to simply
log the fact that they were invoked.
The control that is implied by the operation is ``open loop'' and no
feed back is assumed.
So when we say ``Open a Valve'' we will assume that the value does what
it is told.
This leads us to the following implementation.

[source,tcl]
----
<<external operation stubs>>=
namespace eval ::wmctrl::Motor::MOTOR {
    ::logger::initNamespace [namespace current] info
    proc start {motor} {
        log::info "starting motor, \"$motor\""
    }
    proc stop {motor} {
        log::info "stopping motor, \"$motor\""
    }
}

namespace eval ::wmctrl::WaterValve::VALVE {
    ::logger::initNamespace [namespace current] info
    proc open {valve} {
        log::info "opening valve, \"$valve\""
    }
    proc close {valve} {
        log::info "closing valve, \"$valve\""
    }
}
----

The SENSOR operations present a bit more difficulty to stub.
In this case,
there _is_ feedback from the interaction.
We must signal back the state of tub as being full or empty.
So in some sense we must _simulate_ the action of the sensor.
To accomplish simulating the sensor,
we will record data in a relvar identified by the washing machine id.
This will allow us to simulate an arbitrary number of washing machines.
We will delay the announcement of the new state for some time
to simulate the water filling or draining.
To make the example run in reasonable times,
we assume the tub will fill or empty in 3 seconds.
That's quick!

[source,tcl]
----
<<external operation stubs>>=
namespace eval ::wmctrl::WaterLevelSensor::SENSOR {
    namespace import ::ral::*
    namespace import ::ralutil::*

    ::logger::initNamespace [namespace current] debug

    relvar create SensorState {
        MachineID   string
        State       string
        TimerID     string
    } MachineID

    proc enable {machine} {
        log::debug "enable sensor on machine, \"$machine\""

        set ss [relvar restrictone SensorState MachineID $machine]
        if {[relation isempty $ss]} {
            set ss [relvar insert SensorState [list\
                MachineID $machine State TubEmpty TimerID None]]
        }
        set sensorState [relation extract $ss State]

        set newState\
            [expr {$sensorState eq "TubEmpty" ? "TubFull" : "TubEmpty"}]
        set tid [after 3000 [namespace code [list trigger $machine $newState]]]
        relvar updateone SensorState sstate [list MachineID $machine] {
            tuple update $sstate State $newState TimerID $tid
        }
    }

    proc disable {machine} {
        log::debug "disable sensor on machine, \"$machine\""
        set ss [relvar restrictone SensorState MachineID $machine]
        if {[relation isnotempty $ss]} {
            after cancel [relation extract $ss TimerID]
        }
    }
----

Delivering the indication that the Water Level Sensor has detected
a change in the water level really means we want to send the
appropriate ClothesTub instance either the *TubFull* or *TubEmpty*
event.
Conveniently, we have been keeping track of the sensor state using
string named the same as the event we intend to deliver.
So all we have to do is search for the correct Clothes Tub that
matches the sensor and signal an event.
We also update our notion of the current status of the sensor.

[source,tcl]
----
<<external operation stubs>>=
    proc trigger {machine value} {
        set ct [::wmctrl::ClothesTub findById MachineID $machine]
        rosea tunnel $ct signal $value
        relvar updateone SensorState sstate [list MachineID $machine] {
            tuple update $sstate State $value
        }
    }
}
----

=== Running the Example

Before we can start the example running,
we have to figure out how we are going to stop it.
Recall that to dispatch state machine events we must
*enter the Tcl event loop*.
We will use the +vwait+ command to do that.
But we need some way to break out of the event loop
so that we can look at the results of the run.
To do that, we will set a global variable named +::done+ and
invoke +::vwait+ on that variable.

To actually set the +::done+ variable,
we will install a command trace on the Stopping Spin state activity
of the Clothes Tub class.
This state is entered when the cycle is done
and it is our intent to regain control of the execution flow after
each washing cycle.
Since state activities are turned into ordinary Tcl procs,
we can use a command execution trace to assign a value to +::done+ and
thereby resume execution after our call to +::vwait+.
Note that we are adding this synchronization solely to be able to
run one washing cycle in our example and gain control after that
cycle has completed.
Once we come out of the event loop,
we will want to do some other processing to show the execution
results of the example.
An actual application would most likely run forever or invoke
+::exit+ based on some other condition or circumstance.

[source,tcl]
----
<<running the example>>=
proc syncToStop {cmd code result op} {
    set ::done 1
}

trace add execution\
    [rosea info statemodel activityproc wmctrl ClothesTub StoppingSpin]\
    leave syncToStop ; # <1>
----
<1> We get the name of the Tcl proc that is the activity for the state
by using the `info` command.
Here we request `syncToStop` be executed when we leave the state activity
procedure.

Finally, yes truly finally,
we are in a position to drive the domain operations to select a cycle and
run the washer through the cycle.
We will turn on tracing so we can see what happened.

[source,tcl]
----
<<running the example>>=
rosea trace control on

wmctrl selectCycle wm1 PermPress
puts "**** Start Run"
wmctrl startWasher wm1

vwait ::done ; # <1>

puts "**** Finish Run"
rosea trace control off

puts "**** Trace Begin"
puts [rosea trace format [rosea trace decode all]]
puts "**** Trace End"

rosea trace diagram all images/wmctrl-seqdiag.diag span_height 7 ; # <2>

rosea trace control save wmctrl-trace.sqlite ; # <3>
----
<1> Enter the Tcl event loop.
State machine events will then be dispatched and the washer will operate.
At some time,
the `StoppingSpin` state activity completes,
that causes `syncToStop` to be invoked,
`syncToStop` writes to the `::done` variable and that will cause the
`vwait` command to return.
It's really not as complicated as it appears: it is just a literal
application of the execution rules.
<2> Draw a sequence diagram of the example run.
This will allow us to compare the textual log with a graphic containing
the same information.
<3> We save the traces to demonstrate that the trace data can be made
available for future analysis.

=== Example Run Results

After running the example we obtain the following output.

[literal]
.Output From Running the Example
--
// include::wmctrl-trace.txt[]
--

The first section is the set of log messages that show the interaction
with the motors, values and sensors.
This amounts to a trace of the external side effects that the domain
produces on the washing machine hardware.
The second portion shows the chronological trace of the state machine
event dispatch.
The first column of the trace is the time of day and the second column is
the time difference between the last trace entry (in the form of _s.ms.us_).
The remainder of the trace show the details of the event dispatch.
The first portion of the _Transition_ trace shows the event being
dispatched from a source instance to a target instance.
The state machine transition of the target instance,
from current state to new state,
is shown after the ``==>'' symbol.
Instances are shown with the set of attribute name / value pairs that
form the identifier contained in the instance reference.

The figure below shows the trace information in sequence diagram form.
This diagram was produced using +rosea diagram all+ to generate
a file suitable for the +seqdiag+ program to render a graphic.

// image::wmctrl-seqdiag.pdf[title="Example Sequence Diagram"]

The track labeled *EXTERNAL* shows events that originate outside of the
domain.
The example begins with a *Start* event being sent to an instance of the
*WashingMachine* class.
The other external events arise from the Water Level Sensor detecting
the status of the Clothes Tub.
The clothes are cleaned by a sequence of events exchanged between the
*WashingMachine* and *ClothesTub* instances to coordinate the steps of the
washing cycle to clean clothes.
Although the sequence diagram does not tell the whole story of the
program execution (_e.g._ the side effects caused by the state activities
are often very important),
it does go a long way to showing the chronological unfolding of the
example's execution.

