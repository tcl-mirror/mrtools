// vim:set syntax=asciidoc:

= An Example
[partintro]
--
In this part,
we show an example of a simple domain being translated using `micca`.
--

== Controlling a Washing Machine

=== Introduction

It is traditional in technical books to start off with a simple example.
This example is not quite as simple as the classic _hello world!_ example
but will suffice to give a summary of many of the characteristics
of `micca` translated domain.
We anticipate that there will be many questions after reading the
example and those questions are answered in later chapters.

Unfortunately,
there is rather a lot of background material that we will not cover here.
We do not explain how to create an XUML model
nor will we spend much time explaining why the example model was designed
the way it was.
There are many good books that explain XUML in detail and will teach
you the basics of modelingfootnote:[
<<mb-xuml,Mellor and Balcer>>,
<<rs-xuml,Chris Raistrick _et.al_>> and
<<ls-build,Leon Starr>> all are worthy of a close reading.].
We suggest you read at least one of them.
It is also the case that this package represents one particular piece
of a larger workflow and this means that readers who may not be
completely familiar with model-driven translation oriented development
may have many questions that remain.

The subject matter of our example is an automatic clothes washer.
This is a very simple washing machine,
especially compared to modern commercially available washers.
The intent is to select a subject that most people would be familiar
with from ordinary experience so that we don't have to devote too much
time explaining the problem.
One word of caution.
This model is an example for pedagogical purposes
and probably has little correspondence with the way _real_ washing
machines operate or are designed to operate.
You will also notice a lack of any attention paid to _what can go wrong_.
For industrial strength programs,
handling probable failure cases is very important but we have dispensed
with those considerations here to focus on how the model is
translated into the implementation code using `micca`.

=== Translation Overview

To translate an XUML model using `micca`,
the model is encoded in a domain specific language.
You may draw the model in your favorite tool.
For this translation we choose to keep the domain description
in one file and an initial instance population in another file.
This is a common way to be able to provide several different populations
to the same domain.

In the file for the domain,
we use the `domain` command to specify the details of the model.

[source,tcl]
----
<<wmctrl.micca>>=
<<copyright info>>

domain wmctrl {
    <<WM class>>
    <<WC class>>
    <<CT class>>
    <<WV class>>
    <<MTR class>>
    <<WLS class>>
    <<wmctrl relationships>>
    <<wmctrl operations>>
    <<external operation>>
    <<type aliases>>
    epilogue {
        <<main program>>
    }
}
----

Within the `domain` script,
we specify the details of the classes, relationship and operations.

The `population` command is used to specify the initial class instances.
These are instances that will exist when the domain starts to execute.

[source,tcl]
----
<<wmctrl_pop.micca>>=
population wmctrl {
    <<WM population>>
    <<WC population>>
    <<CT population>>
    <<MTR population>>
    <<WV population>>
    <<WLS population>>
}
----

=== Domain Data

The figure below shows a class diagram for the washing machine control
domain in UML graphical notation.

[[class-diagram,class diagram]]

image::wmc-class-diagram.pdf[title="Washing Machine Class Diagram"]

In our world,
a Washing Machine operates according to some Washing Cycle.
The Washing Cycle is a set of parameters that specifies aspects of
the washing that will turn dirty clothes into clean ones.
The Washing Machine itself has a Clothes Tub into which the dirty
laundry is placed.
There are also Water Valves to control the flow of water into and out of
the Clothes Tub and Motors to run a water pump, agitate the
Clothes Tub and rotate the Clothes Tub to spin excess water out of the
clean laundry.
Rounding out the machinery,
there is a Water Level Sensor that will tell us when the Clothes Tub
is filled with water or empty of water.

For a well engineered model,
the class diagram must also have a set of descriptions of what
the attributes and relationship actually mean,
what the value domains of the attributes are and many other
aspects that describe how the problem is represented in the model.
These descriptions are vital to understanding a class diagram.
Here again, in the interests of space,
we will have to suffice ourselves with more casual descriptions
included along with the example as it translated into the implementation
and an admonition that writing the model descriptions is an essential
aspect of a well engineered solution.

The class diagram shows the static aspects of our domain
and is always the first aspect of the model that must be considered
when deriving the implementation.
The class diagram facet of the model is static in the sense that
at any point in time,
the logical predicates you can infer from the diagram will be true.
The class attributes hold those properties of the domain whose values can vary
and the relationships state how the entities abstracted by the classes
are associated with each other.
Later, we visit the dynamic and algorithmic facets of the domain
but, for now, we will endeavor to represent the classes and relationships
in terms of the `micca` constructs.

==== Washing Machine Class

By examining the graphics of the model we can see that the Washing Machine
class has attributes, participates in associations and has a state model.

(((Example,Class,WashingMachine)))
[source,tcl]
----
<<WM class>>=
class WashingMachine {
    attribute MachineID char -dimension 32 ; # <1>

    statemodel {
        <<WM statemodel>>
    }

    <<WM operations>>
}
----
<1> The `-dimension` argument makes the attribute an array.
Character arrays are assumed to hold `NUL` terminated strings as is
the usual convention in ``C''.

Looking at the Washing Machine class on the <<class-diagram,class diagram>>,
we see that there are two attributes.
The MachineID attribute is an identifier and we make its data type
a simple string.
Usually, attributes that are used purely for identification purposes
are excluded from the description of the domain.
In this case, we will use Machine ID for other purposes and so
must be retained as an attribute of the Washing Machine class.
`Micca` will make up its own identifier for instances of the class.
Since we still want Machine ID to be an identfier,
we must take on that responsibility.
We will need a class operation that can search the instances
of the Washing Machine class to determine if one already exists
with a given Machine ID value.

The CycleType attribute is referential attribute and we will not need it.
Generally,
attributes that are purely referential in nature are excluded from
the `micca` translation.
This is because `micca` will generate its own identifier for instances
and will store the necessary information to realize relationships.
Since in this case the Cycle Type attribute is only used to realize
relationship, R4, we need not include this attribute and can let `micca`
manage the information needed for R4.

While we are discussing R4, we can define its characteristics.
We can represent the participating classes, multiplicity and conditionality as
presented in the class diagram by the following domain configuration statement.

[source,tcl]
----
<<wmctrl relationships>>=
association R4 WashingMachine 0..*--1 WashingCycle
----

==== Washing Cycle Class

Examining the class diagram and other graphics for the domain shows that
the Washing Cycle class is a simple class consisting entirely of
descriptive attributes.

(((Example,Class,WashingCycle)))
[source,tcl]
----
<<WC class>>=
class WashingCycle {
    attribute CycleType char -dimension 32
    attribute WashWaterTemp WaterTemp
    attribute RinseWaterTemp WaterTemp
    attribute WashDuration unsigned
    attribute RinseDuration unsigned
    attribute SpinDuration unsigned
    attribute AgitationSpeed WashSpeed
    attribute SpinSpeed WashSpeed
}
----

We need only specify the attributes and their data types.
In order to determine the proper data types of the attributes we
would need to consult the descriptive text associated with the class diagram.
As we have no such text in this example,
we will infer a set of data types based on how the attribute values
will be used in the processing.

[source,tcl]
----
<<type aliases>>=
typealias WaterTemp {enum {WT_Hot, WT_Cold, WT_Warm}}
typealias WashSpeed {enum {WS_Low, WS_Medium, WS_High}}
----

==== Clothes Tub Class

By now the pattern of examining the model graphics to determine
the class characteristics is established.
The Clothes Tub class is an active class with a state model.
A Clothes Tub only has identifying and referential attributes that are
elided.

(((Example,Class,ClothesTub)))
[source,tcl]
----
<<CT class>>=
class ClothesTub {
    statemodel {
        <<CT statemodel>>
    }
    <<CT operations>>
}
----

The `R1` association itself can be transcribed from the graphic as follows.

[source,tcl]
----
<<wmctrl relationships>>=
association R1 ClothesTub 1--1 WashingMachine
----

==== Water Valve Class

The Water Valve class represents the means to control the movement of water
into and out of a Clothes Tub.
Since a Clothes Tub can have several valves,
we need an attribute to distinguish them.

(((Example,Class,WaterValve)))
[source,tcl]
----
<<WV class>>=
class WaterValve {
    attribute ValveID ValveType

    <<WV operations>>
}
----

The type of a valve comes from a fixed, well-known set.

[source,tcl]
----
<<type aliases>>=
typealias ValveType {enum {WV_Hot, WV_Cold, WV_Drain}}
----

The R3 relationship represents the design of the washing machine hardware
that includes three valves on each machine.
Notice the we don't concern ourselves here with whether a washing machine
has three or three thousand valves on it.
That is dealt with when we populate the class instances.
The important point here is that there is one or more valves associated
with each tub and each water valve is connected to exactly one tub.

[source,tcl]
----
<<wmctrl relationships>>=
association R3 WaterValve 1..*--1 ClothesTub
----

==== Motor Class

The Motor class is similar to the Water Valve class.

(((Example,Class,Motor)))
[source,tcl]
----
<<MTR class>>=
class Motor {
    attribute MotorID MotorType

    <<MTR operations>>
}
----

Our washer has three types of motors.

[source,tcl]
----
<<type aliases>>=
typealias MotorType {enum {MTR_Pump, MTR_Agitator, MTR_Spin}}
----

The R2 relationships states the hardware design of using one or more
motors to operation a clothes tub.

[source,tcl]
----
<<wmctrl relationships>>=
association R2 Motor 1..*--1 ClothesTub
----

==== Water Level Sensor

The Water Level Sensor class is also simple.
It has no attributes.
It is closely associated with the Clothes Tub for which it senses.

(((Example,Class,WaterLevelSensor)))
[source,tcl]
----
<<WLS class>>=
class WaterLevelSensor {
    <<WLS operations>>
}
----

It is R5 that sets the rule about one Water Level Sensor per Clothes Tub.

[source,tcl]
----
<<wmctrl relationships>>=
association R5 WaterLevelSensor 1--1 ClothesTub
----

=== Domain Dynamics

The second facet of the model that is considered during translation is the
dynamics.
The model encodes the sequences of domain execution as state models attached to
classes.
In this model,
there are two classes for which state models are defined,
Washing Machine and Clothes Tub.
The control is partitioned by the model between these classes.
The Washing Machine class is given the responsibility for coordinating
the actions needed to clean clothes according to the particulars
specified by the Washing Cycle.
In this example that coordination primarily involves timing the various
components of the washing cycle.
The Clothes Tub class deals with sequencing the mechanics of the washer
to perform a specific activity.

For each state model we will present a graphical representation of
the state model.
We also show the state transition table.
It is important to have both representations.
In the graphic,
it is conventional not to show ignored or error transitions.
However,
in the transition table all possible transitions and their outcomes
are exposed.

==== Washing Machine State Model

The state model for the Washing Machine class is shown below.
You will notice that in the graphic
the states contain action language statements that specify
the processing to be performed when the state is entered.
We will say more about the actions when we take up the domain processing
below.
For now,
it is convenient to have the actions present on the diagram in order
to better understand exactly what the washing machine will do as it
responds to events and thereby better understand how the state machines
achieve the overall result of producing clean clothes.

image::wm-states.pdf[title="Washing Machine State Model Diagram"]

From the diagram we can see how the washing machine cycles in a rather
simple circular form filling, washing, draining, rinsing and spinning
to convert dirty clothes into clean ones.
The state activities are primarily concerned with obtaining the
particular details of the next step and requesting the Clothes Tub
to carry out that step.
The various durations are handled by signaling delayed events
to march things along to the next step in the cleaning.

The transition table corresponding to the diagram is shown next.

.Washing Machine Transition Table
[options="header,unbreakable",cols="<h,4*^"]
|===========================
|                   |Start              |Full       |Done           |Empty
|Stopped            |Filling To Wash    |CH         |CH             |CH
|Filling To Wash    |CH                 |Washing    |CH             |CH
|Washing            |CH                 |CH         |Draining Wash  |CH
|Draining Wash      |CH                 |CH         |CH             |Filling To Rinse
|Filling To Rinse   |CH                 |Rinsing    |CH             |CH
|Rinsing            |CH                 |CH         |Draining Rinse |CH
|Draining Rinse     |CH                 |CH         |CH             |Spinning
|Spinning           |CH                 |CH         |Stopped        |CH
|===========================

The transition table may be directly translated into the required
`micca` configuration statements.
Below, we have not shown the Tcl code that executes for each
state activity.
We will return to the processing below.
For now, we use a set of literate program chunks to represent the
state activity code in order to get a clearer view of how the transition
table is represented as `statemodel` configuration statements.

(((Example,State Model,WashingMachine)))
[source,tcl]
----
<<WM statemodel>>=
initialstate Stopped
defaulttrans CH

state Stopped {} {
    <<WM stopped activity>>
}
transition Stopped - Start -> FillingToWash

state FillingToWash {} {
    <<WM filling to wash activity>>
}
transition FillingToWash - Full -> Washing

state Washing {} {
    <<WM washing activity>>
}
transition Washing - Done -> DrainingWash

state DrainingWash {} {
    <<WM draining wash activity>>
}
transition DrainingWash - Empty -> FillingToRinse

state FillingToRinse {} {
    <<WM filling to rinse activity>>
}
transition FillingToRinse - Full -> Rinsing

state Rinsing {} {
    <<WM rinsing activity>>
}
transition Rinsing - Done -> DrainingRinse

state DrainingRinse {} {
    <<WM draining rinse activity>>
}
transition DrainingRinse - Empty -> Spinning

state Spinning {} {
    <<WM spinning activity>>
}
transition Spinning - Done -> Stopped
----

==== Clothes Tub State Model

The diagram below shows the state model for the Clothes Tub class.
This model is _not_ circular like that of the Washing Machine
class.
There are two paths through the states.
One corresponds to agitating the tub for the purposes of either
washing or rinsing.
The other path corresponds to spinning the tub to remove excess
water from the clean clothes.
Both paths start at the Empty state.

image::ct-states.pdf[title="Clothes Tub State Model Diagram"]

The transition table follows immediately from the diagram.

.Clothes Tub Transition Table
[options="header,unbreakable",cols="<h,7*^"]
|===========================
|              |Fill    |TubFull |Agitate   |Drain    |TubEmpty |Spin     |Stop
|Empty         |Filling |CH      |CH        |CH       |CH       |Spinning |CH
|Filling       |CH      |Full    |CH        |CH       |IG (1)   |CH       |CH
|Full          |CH      |CH      |Agitating |CH       |CH       |CH       |CH
|Agitating     |CH      |CH      |CH        |Emptying |CH       |CH       |CH
|Emptying      |CH      |IG (1)  |CH        |CH       |Empty    |CH       |CH
|Spinning      |CH      |CH      |CH        |CH       |CH       |CH       |Stopping Spin
|Stopping Spin |Filling |CH      |CH        |CH       |CH       |CH       |CH
|===========================

(1) For the *Filling* and *Emptying* states,
we allow for the fact that when the water level sensor is
enabled it may send events that reflect its current state.
So we simply ignore those sensor events in which we are not currently
interested.

The `micca` configuration statements follow directly from the transition table.

(((Example,State Model,ClothesTub)))
[source,tcl]
----
<<CT statemodel>>=
initialstate Empty
defaulttrans CH

state Empty {} {
    <<CT empty activity>>
}
transition Empty - Fill -> Filling
transition Empty - Spin -> Spinning

state Filling {temp WaterTemp} {
    <<CT filling activity>>
}
transition Filling - TubFull -> Full
transition Filling - TubEmpty -> IG

state Full {} {
    <<CT full activity>>
}
transition Full - Agitate -> Agitating

state Agitating {} {
    <<CT agitating activity>>
}
transition Agitating - Drain -> Emptying

state Emptying {} {
    <<CT emptying activity>>
}
transition Emptying - TubEmpty -> Empty
transition Emptying - TubFull -> IG

state Spinning {} {
    <<CT spinning activity>>
}
transition Spinning - Stop -> StoppingSpin

state StoppingSpin {} {
    <<CT stopping spin activity>>
}
transition StoppingSpin - Fill -> Filling
----

=== Domain Processing

The third facet of the model that must be translated is the processing.
Processing is executed in state activities or the various operations
of the domain or classes.
We represent the processing as action language.
There are several different action languages that are in use.
In the example,
we follow an <<mb-xuml,established syntax>> for the actions.
All the action languages allow for writing expressions and for
performing model level processing.
Since we are not parsing the action language in this context,
we are not particular about the syntax as long as the action statements
convey the required processing unambiguously.

For state activities,
the diagrams above show the action language that is to be executed
when the state is entered.
In the translations below,
we duplicate the action language from the state and write the translation to
Tcl code immediately following.
In most cases,
the translation maps one action language statement to one Tcl command.

The model level actions performed by the state activities,
such as access to attribute values,
navigating the class diagram or signaling events,
is accomplished by invoking commands that are expanded into ``C'' code.
The commands are contained between the ``%<'' and ``>%'' markers.
All the content between the markers is replaced with the
``C'' code implements the model level execution semantics.
Otherwise, ordinary ``C'' code is passed along unmodified.

In the code below,
we strive for a clear correspondence between the action language of
the activity and its translation into ``C'' and macro commands.
This is not the only translation possible and not necessarily the
most efficient.
The intent is to show the correspondence between the actions and
the translation into ``C''.

==== Washing Machine Operations

The operation below searches the instances of the WashingMachine
class for any instance which matches the `id` argument value.

(((Example,Operation,findByMachineID)))
[source,tcl]
----
<<WM operations>>=
classop {struct WashingMachine *} findByMachineID {id {char const *}} {
    %<WashingMachine foreachInstance wm>%
        if (strcmp(id, %<instance wm attribute MachineID>%) == 0) {
            return wm ;
        }
    %<end>%

    return NULL ;
}
----

The `%<WashingMachine foreachInstance wm>%` command expands to
a loop to iterate across each instance of the Washing Machine class.
The `wm` variable is assigned a reference (or pointer value) to an
instance of Washing Machine.
All the ``C'' code until the `%<end>%` statement is in the implied
iteration loop.
In this case,
we fetch the `MachineID` attribute value and compare it for a match.

==== Washing Machine State Activities

Below is the processing for the Washing Machine state activities.
For the first few states,
we will make several comments on the correspondence between the
action language statements and the Tcl code.
After the translation pattern is established,
we present the remaining state with minimal explanation.
In the interest of clarity,
no attempt has been made to shorten or optimize the Tcl code.
There will be cases where some variable assignments will seem
superfluous and command nesting might seem a more natural
way to express the logic.
Here we are trying to emphasize the relationships between the
action language statements and the Tcl code.
In delivered code, we might be more succinct.

// %States images/wm-states.uxf WashingMachine

'''
// %Action WashingMachine Stopped
.Stopped Activity Action Language
----
# Stop spinning -- wash complete
select one ct related by self->R1[CT]
signal Stop to ct
----
The Stopped state of the Washing Machine is entered when the cycle
is complete and we must signal the Clothes Tub to stop spinning.
The action consists of finding the related Clothes Tub instance
and signaling the Stop event to it.

.Stopped Implementation
[source,tcl]
----
<<WM stopped activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Stop>%
MRT_InstId selfid = %<my instid>% ;
%<external cycleComplete washerid selfid>%
----
'''

Recall that all state activities have an implicit `self` argument
defined for them.
The `%<instance ct findOneRelated self ~R1>%` command
navigates from `self` along `~R1` and assigns the
resulting Clothes Tub instance into a reference variable named `ct`.
With the Clothes Tub instance in hand,
the `Stop` event is signaled to it using the `signal` command.
There are a couple things to note here.

. The use of the direction syntax, _i.e._ `~R1`, says that we navigate
the `R1` relationship in the *reverse* direction.
Supplying a direction obviates the need to
say that we are navigating to an instance of the `CT` class in the
manner that the action language statement does.
Because of the syntax convention and the manner in which the
association was defined,
the system knows the destination class.
. The question arises whether the instance reference returned from
`findOneRelated` in the above traversal across `~R1`
can ever be the empty reference or ever reference multiple instances.
The answer is no!
The `R1` association,
as shown in the class diagram,
is singular and unconditional on the Clothes Tub side.
Every traversal from Washing Machine to Clothes Tub along `~R1` is guaranteed
to return exactly one instance.
Any operation in the domain that would perturb that state of affairs
is rejected as violating the referential integrity of the
class diagram.
Consequently,
no test of the multiplicity of the returned reference is necessary as the
system is already making that test and so it would be strictly redundant.
In general,
traversing unconditional relationships never requires a test to determine if
we obtained an instance reference and traversing a conditional relationship
should always be followed by a test of the returned reference to
see if it is empty.
The fact that a relationship is conditional implies that there is
to be conditional processing associated with traversing the relationship.
. We have added a call to an external operation to notify the outside
world that the washer had completed it cycle.
Below we show how to use this to terminate the example run.

'''
// %Action WashingMachine "Filling To Wash"
.Filling To Wash Activity Action Language
----
# Fill the tub with wash water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.WashWaterTemp) to ct
----

.Filling To Wash Implementation
[source,tcl]
----
<<WM filling to wash activity>>=
%<instance wc findOneRelated self R4>%
%<instance ct findOneRelated self ~R1>%
WaterTemp washtemp = %<instance wc attribute WashWaterTemp>% ;
%<instance ct signal Fill temp washtemp>%
----

'''

// %Action WashingMachine Washing
.Washing Activity Action Language
----
# Agitate the tub to wash.
select one ct related by self->R1[CT]
signal Agitate to ct
select one wc related by self->R4[WC]
signal Done to self at wc.WashDuration
----
While in the Washing state, clothes are being agitated in the tub.
The state uses a delayed event to determine when the washing part of
the cycle is finished.
Note that the delay time of the signal is an attribute value obtained
from the Washing Cycle class.
Here Washing Cycle serves a role of holding attributes that just specify
conditions for another class
This is a common arrangement.

.Washing Implementation
[source,tcl]
----
<<WM washing activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Agitate>%
%<instance wc findOneRelated self R4>%
MRT_DelayTime washtime = %<instance wc attribute WashDuration>% * 1000 ;
%<my delaysignal washtime Done>% // <1>
----
<1> We are implicitly assuming the units of WashDuration are seconds.
In truth, the units are minutes, but we are not patient enough
to wait that long for the example to execute.

The delayed signal is accomplished by using the `delaysignal` command.
Notice that the event is self directed, albeit delayed by the washing
cycle time.
So this state sends two signals,
one to the Clothes Tub to tell it to start agitating the clothes
and a delayed signal to itself so it when know when the clothes have
been washing for the amount of time defined by the related
Washing Cycle.

'''

// %Action WashingMachine "Draining Wash"
.Draining Wash Activity Action Language
----
# Stop washing and drain
# the dirty wash water.
select one ct related by self->R1[CT]
signal Drain to ct
----

.Draining Wash Implementation
[source,tcl]
----
<<WM draining wash activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Drain>%
----

'''

// %Action WashingMachine "Filling To Rinse"
.Filling To Rinse Activity Action Language
----
# Fill the tub with rinse water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.RinseWaterTemp) to ct
----

.Filling To Rinse Implementation
[source,tcl]
----
<<WM filling to rinse activity>>=
%<instance wc findOneRelated self R4>%
%<instance ct findOneRelated self ~R1>%
WaterTemp rinsetemp = %<instance wc attribute RinseWaterTemp>% ;
%<instance ct signal Fill temp rinsetemp>%
----

'''

// %Action WashingMachine Rinsing
.Rinsing Activity Action Language
----
# Agitate the tub to rinse.
select one ct related by self->R1[CT]
signal Agitate to ct
select one wc related by self->R4[WC]
signal Done to self at wc.RinseDuration
----

.Rinsing Implementation
[source,tcl]
----
<<WM rinsing activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Agitate>%
%<instance wc findOneRelated self R4>%
MRT_DelayTime rinsetime = %<instance wc attribute RinseDuration>% * 1000 ;
%<my delaysignal rinsetime Done>%
----

'''

// %Action WashingMachine "Draining Rinse"
.Draining Rinse Activity Action Language
----
# Stop rinsing and drain
# the rinse water.
select one ct related by self->R1[CT]
signal Drain to ct
----

.Draining Rinse Implementation
[source,tcl]
----
<<WM draining rinse activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Drain>%
----

'''

// %Action WashingMachine Spinning
.Spinning Activity Action Language
----
# Spin out excess water.
select one ct related by self->R1[CT]
signal Spin to ct
select one wc related by self->R4[WC]
signal Done to self at wc.SpinDuration
----

.Spinning Implementation
[source,tcl]
----
<<WM spinning activity>>=
%<instance ct findOneRelated self ~R1>%
%<instance ct signal Spin>%
%<instance wc findOneRelated self R4>%
MRT_DelayTime spintime = %<instance wc attribute SpinDuration>% * 1000 ;
%<my delaysignal spintime Done>%
----

==== Clothes Tub State Activities

The other state model in our example is for the Clothes Tub class

// %States images/ct-states.uxf ClothesTub

// %Action ClothesTub Empty
.Empty Activity Action Language
----
# Stop the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Stop()
# Close the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Close()
# Disable the sensor
select one wls related by self->R5[WLS]
wls.Disable()
# Inform the washing machine
select one wm related by self->R1[WM]
signal Empty to wm
----

Because the Clothes Tub interacts frequently with its related
Motor and Water Valve instances,
we will create some instance based operations to
help us locate the required Motor or Water Valve instance.
It is common to factor out such code as it usually corresponds
to an action language `where` clause.
This allows us to create type specific and type safe code
for the query.

[source,tcl]
----
<<CT operations>>=
instop {struct Motor *} findRelatedMotor {mtrid MotorType} {
    %<instance mtr foreachRelated self ~R2>%
        if (%<instance mtr attribute MotorID>% == mtrid) {
            return mtr ;
        }
    %<end>%
    return NULL ;
}
----

[source,tcl]
----
<<CT operations>>=
instop {struct WaterValve *} findRelatedValve {valveid ValveType} {
    %<instance valve foreachRelated self ~R3>%
        if (%<instance valve attribute ValveID>% == valveid) {
            return valve ;
        }
    %<end>%
    return NULL ;
}
----

With these help operations,
the Clothes Tub state activities require much less boilerplate code.

.Empty Implementation
[source,tcl]
----
<<CT empty activity>>=
%<Motor instref mtr>%
mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
if (mtr != NULL) {
    %<instance mtr operation Stop>% ;
}

%<WaterValve instref wv>%
wv = %<my operation findRelatedValve valveid WV_Drain>% ;
if (wv != NULL) {
    %<instance wv operation Close>% ;
}

%<instance wls findOneRelated self ~R5>%
%<instance wls operation Disable>% ;

%<instance wm findOneRelated self R1>%
%<instance wm signal Empty>%
----

'''

// %Action ClothesTub Filling
.Filling Activity Action Language
----
# Enable the sensor
select one wls related by self->R5[WLS]
wls.Enable()
# Open inlet valve(s)
if (temp = 'Hot')
    select one wv related by self->R3[WV]
        where (ValveID = 'Hot')
    wv.Open()
else if (temp = 'Cold')
    select one wv related by self->R3[WV]
        where (ValveID = 'Cold')
    wv.Open()
else if (temp = 'Warm')
    select many wvs related by self->R3[WV]
        where (ValveID = 'Hot' OR ValveID = 'Cold')
    foreach wv in wvs
        wv.Open()
    endfor
end if
----

[source,tcl]
----
<<CT operations>>=
instop MRT_InstSet findRelatedWaterValves {} {
    %<WaterValve instset watervalves>%
    %<instance wv foreachRelated self ~R3>%
        ValveType vid = %<instance wv attribute ValveID>% ;
        if (vid == WV_Hot || vid == WV_Cold) {
            %<instset watervalves add wv>%
        }
    %<end>%

    return watervalves ;
}
----

.Filling Implementation
[source,tcl]
----
<<CT filling activity>>=
%<instance wls findOneRelated self ~R5>%
%<instance wls operation Enable>% ;
%<WaterValve instref wv>%

if (temp == WT_Hot) {
    wv = %<my operation findRelatedValve valveid WV_Hot>% ;
    if (wv != NULL) {
        %<instance wv operation Open>% ;
    }
} else if (temp == WT_Cold) {
    wv = %<my operation findRelatedValve valveid WV_Cold>% ;
    if (wv != NULL) {
        %<instance wv operation Open>% ;
    }
} else if (temp == WT_Warm) {
    %<WaterValve instset watervalves>%
    watervalves = %<my operation findRelatedWaterValves>% ;
    %<instset watervalves foreachSelected wv>%
        %<instance wv operation Open>% ;
    %<end>%
}
----

'''

// %Action ClothesTub Full
.Full Activity Action Language
----
# Disable the sensor
select one wls related by self->R5[WLS]
wls.Disable()
# Close all water valves
select many wvs related by self->R3[WV]
    where (ValveID = 'Hot' OR ValveID = 'Cold')
foreach wv in wvs
    wv.Close()
endfor
# Inform the washing machine
select one wm related by self->R1[WM]
signal Full to wm
----

.Full Implementation
[source,tcl]
----
<<CT full activity>>=
// Disable the sensor
%<instance wls findOneRelated self ~R5>%
%<instance wls operation Disable>% ;

// Close all water valves
%<WaterValve instset watervalves>%
watervalves = %<my operation findRelatedWaterValves>% ;
%<instset watervalves foreachSelected wv>%
    %<instance wv operation Close>% ;
%<end>%

// Inform the washing machine
%<instance wm findOneRelated self R1>%
%<instance wm signal Full>%
----

'''

// %Action ClothesTub Agitating
.Agitating Activity Action Language
----
# Start the agitator motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Agitator')
mtr.Start()
----

.Agitating Implementation
[source,tcl]
----
<<CT agitating activity>>=
// Start the agitator motor
%<Motor instref mtr>%
mtr = %<my operation findRelatedMotor mtrid MTR_Agitator>% ;
if (mtr != NULL) {
    %<instance mtr operation Start>% ;
}
----

'''

// %Action ClothesTub Emptying
.Emptying Activity Action Language
----
# Stop the motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Agitator')
mtr.Stop()
# Open the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Open()
# Start the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Start()
# Enable the sensor
select one wls related by self->R5[WLS]
wls.Enable()
----

.Emptying Implementation
[source,tcl]
----
<<CT emptying activity>>=
// Stop the motor
%<Motor instref mtr>%
mtr = %<my operation findRelatedMotor mtrid MTR_Agitator>% ;
if (mtr != NULL) {
    %<instance mtr operation Stop>% ;
}

// Open the drain valve
%<WaterValve instref wv>%
wv = %<my operation findRelatedValve valveid WV_Drain>% ;
if (wv != NULL) {
    %<instance wv operation Open>% ;
}

// Start the pump
mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
if (mtr != NULL) {
    %<instance mtr operation Start>% ;
}

// Enable the sensor
%<instance wls findOneRelated self ~R5>%
%<instance wls operation Enable>% ;
----

'''

// %Action ClothesTub Spinning
.Spinning Activity Action Language
----
# Open the drain valve
select one wv related by self->R2[WV]
     where (ValveID = 'Drain')
wv.Open()
# Start the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Start()
# Start the spin motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Spin')
mtr.Start()
----

.Spinning Implementation
[source,tcl]
----
<<CT spinning activity>>=
// Open the drain valve
%<WaterValve instref wv>%
wv = %<my operation findRelatedValve valveid WV_Drain>% ;
if (wv != NULL) {
    %<instance wv operation Open>% ;
}

// Start the pump
%<Motor instref mtr>%
mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
if (mtr != NULL) {
    %<instance mtr operation Start>% ;
}

// Start the spin motor
mtr = %<my operation findRelatedMotor mtrid MTR_Spin>% ;
if (mtr != NULL) {
    %<instance mtr operation Start>% ;
}
----

'''

// %Action ClothesTub "Stopping Spin"
.Stopping Spin Activity Action Language
----
# Stop the motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Spin')
mtr.Stop()
# Stop the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Stop()
# Close the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Close()
----

.Stopping Spin Implementation
[source,tcl]
----
<<CT stopping spin activity>>=
// Stop the motor
%<Motor instref mtr>%
mtr = %<my operation findRelatedMotor mtrid MTR_Spin>% ;
if (mtr != NULL) {
    %<instance mtr operation Stop>% ;
}

// Stop the pump
mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
if (mtr != NULL) {
    %<instance mtr operation Stop>% ;
}

// Close the drain valve
%<WaterValve instref wv>%
wv = %<my operation findRelatedValve valveid WV_Drain>% ;
if (wv != NULL) {
    %<instance wv operation Close>% ;
}
----

==== Class Instance Operations

The Water Valve, Motor and Water Level Sensor classes have instance based
operations that serve as an interface to external operations that are intended
to perform the physical actions associated with the hardware.
The external operations that are invoked detail the dependencies this
domain assumes will be performed by some other domain.

[float]
==== Water Valve Operations

[source,tcl]
----
<<WV operations>>=
instop void Open {} {
    MRT_InstId selfid = %<my instid>% ;
    %<external valveOpen valveid selfid>%
}

instop void Close {} {
    MRT_InstId selfid = %<my instid>% ;
    %<external valveClose valveid selfid>%
}
----

[float]
==== Motor Class Operations

[source,tcl]
----
<<MTR operations>>=
instop void Start {} {
    MRT_InstId selfid = %<my instid>% ;
    %<external motorStart motorid selfid>%
}

instop void Stop {} {
    MRT_InstId selfid = %<my instid>% ;
    %<external motorStop motorid selfid>%
}
----

[float]
==== Water Level Sensor Operations

[source,tcl]
----
<<WLS operations>>=
instop void Enable {} {
    %<instance ct findOneRelated self R5>%
    MRT_InstId ctid = %<instance ct instid>% ;
    %<external sensorEnable tubid ctid>%
}

instop void Disable {} {
    %<instance ct findOneRelated self R5>%
    MRT_InstId ctid = %<instance ct instid>% ;
    %<external sensorDisable tubid ctid>%
}
----

==== Domain Operations

In this section we show the code for the domain operations.
We assume that there is some entity in our overall system that
will invoke these operations.
To make our example run,
we will contrive to make that happen
even though we do not intend to supply a user interface, _per se_.

[float]
==== Create Washer

Since there several classes involved in creating a functioning washer,
a domain operation can make that simpler.

(((Example,Domain Operation,createWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop MRT_InstId createWasher {washer {char const *}} {
    %<WashingMachine instref wm>%
    wm = %<WashingMachine operation findByMachineID id washer>% ;
    if (wm == NULL) {
        %<WashingMachine create wm MachineID washer>%
        %<WashingCycle findByName Normal nwc>%
        %<R4 relate wm nwc>%

        %<ClothesTub create ct>%
        %<R1 relate ct wm>%

        %<WaterValve create wv ValveID WV_Hot>%
        %<R3 relate wv ct>%
        %<WaterValve create wv ValveID WV_Cold>%
        %<R3 relate wv ct>%
        %<WaterValve create wv ValveID WV_Drain>%
        %<R3 relate wv ct>%

        %<Motor create mtr MotorID MTR_Pump>%
        %<R2 relate mtr ct>%
        %<Motor create mtr MotorID MTR_Agitator>%
        %<R2 relate mtr ct>%
        %<Motor create mtr MotorID MTR_Spin>%
        %<R2 relate mtr ct>%

        %<WaterLevelSensor create wls>%
        %<R5 relate wls ct>%
    }
    return %<instance wm instid>% ;
}
----

[float]
==== Delete Washer

If we can create a washer, it is also necessary to be able to delete one.
Here we must be careful to leave the data model referentially consistent.

(((Example,Domain Operation,deleteWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void deleteWasher {washer {char const *}} {
    %<WashingMachine instref wm>%
    wm = %<WashingMachine operation findByMachineID id washer>% ;
    if (wm != NULL) {
        %<instance ct findOneRelated wm ~R1>%
        %<instance wls findOneRelated ct ~R5>%
        %<R5 unrelate wls ct>%
        %<instance wls delete>%
        %<instance wv foreachRelated ct ~R3>%
            %<R3 unrelate wv ct>%
            %<instance wv delete>%
        %<end>%
        %<instance mtr foreachRelated ct ~R2>%
            %<R2 unrelate mtr ct>%
            %<instance mtr delete>%
        %<end>%
        %<R1 unrelate ct wm>%
        %<instance ct delete>%
        %<instance wm delete>%
    } else {
        printf("unknown washer, %s\n", washer) ;
    }
}
----

[float]
==== Start Washer

To start a washing machine we must supply the identifier of the
washer so we can know which one is to be started.
Although our instance population only included a single WashingMachine
instance,
as we stated before, the models will run with an arbitrary number
of washing machine instances.

The implementation of the operation first searches all the instances
of WashingMachine to find the correct one to start.
It is possible to request an unknown washer to start.
After finding the correct instance,
the *Start* event will kick things off.

(((Example,Domain Operation,startWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void startWasher {washer {char const *}} {
    %<WashingMachine instref wm>%
    wm = %<WashingMachine operation findByMachineID id washer>% ;
    if (wm != NULL) {
        %<instance wm signal Start>%
    } else {
        printf("unknown washer, %s\n", washer) ;
    }
}
----

[float]
==== Select Cycle

On the class diagram,
relationship `R4` determines which Washing Cycle will be used to
control the operations.
Selecting a wash cycle means we must reform the `R4` relationship,
_i.e._ unlink the existing cycle and link in a different one.
The implementation of the `selectCycle` domain operation does just that.

(((Example,Domain Operation,selectCycle)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void selectCycle {washer {char const *} cycle {char const *}} {
    %<WashingCycle instref reqcycle>%
    reqcycle = NULL ;
    %<WashingCycle foreachInstance wc>%
        if (strcmp(cycle, %<instance wc attribute CycleType>%) == 0) {
            reqcycle = wc ;
        }
    %<end>%
    if (reqcycle == NULL) {
        printf("unknown washing cycle, %s\n", cycle) ;
        return ;
    }
    %<WashingMachine instref wm>%
    wm = %<WashingMachine operation findByMachineID id washer>% ;
    if (wm != NULL) {
        %<instance wc findOneRelated wm R4>%
        %<R4 unrelate wm wc>%
        %<R4 relate wm reqcycle>%
    } else {
        printf("unknown washer, %s\n", washer) ;
    }
}
----

==== Initialize

(((Example,Domain Operation,init)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void init {} {
    %<WashingMachine foreachInstance wm>%
        %<instance wm signal Start>%
    %<end>%
}
----

=== Initial Instance Population

In this section we populate the data of the domain model.

We intend to have only a single WashingMachine instance and have chosen
to populate it directly rather than invoke `createWasher` in order to
show how that might happen.
Note that the model will run correctly regardless of how many washing
machines we are trying to control even though we are creating only
a single instance here.

[source,tcl]
----
<<WM population>>=
class WashingMachine {
    instance wm1 MachineID {"wm1"} R4 PermPress ; # <1>
}
----
<1> Note that although we do not have any referential attributes
in the WashingMachine class,
we must still account for how the R4 relationship is to be handled.
Here we state that the WashingMachine instance name, wm1, will be
related across R4 to the WashingCycle instance name, Normal.

[source,tcl]
----
<<WC population>>=
class WashingCycle {
    table {CycleType WashWaterTemp RinseWaterTemp WashDuration RinseDuration\
             SpinDuration AgitationSpeed SpinSpeed}\
    Normal {{"Normal"} WT_Cold WT_Cold 20 10 10 WS_Medium WS_Medium}\
    Whites {{"Whites"} WT_Hot WT_Cold 20 10 20 WS_High WS_High}\
    PermPress {{"PermPress"} WT_Warm WT_Cold 15 10 15 WS_Medium WS_Medium}\
    Delicate {{"Delicate"} WT_Cold WT_Cold 15 10 10 WS_Low WS_Low}
}
----

The class model dictates that each washer have exactly one ClothesTub.

[source,tcl]
----
<<CT population>>=
class ClothesTub {
    instance ct1 R1 wm1
}
----

[source,tcl]
----
<<MTR population>>=
class Motor {
    table   {MotorID        R2}\
    mtr1    {MTR_Pump       ct1}\
    mrt2    {MTR_Agitator   ct1}\
    mtr3    {MTR_Spin       ct1}
}
----

Each washing machine, also by design,
has three valves to control hot and cold water and draining.

[source,tcl]
----
<<WV population>>=
class WaterValve {
    table   {ValveID    R3}\
    wv1     {WV_Hot     ct1}\
    wv2     {WV_Cold    ct1}\
    wv3     {WV_Drain   ct1}
}
----

Finally, each washing machine has a sensor that can determine
whether the tub is full or empty.

[source,tcl]
----
<<WLS population>>=
class WaterLevelSensor {
    instance wls1 R5 ct1
}
----

=== Stubbing the External Operations [[stubbing-external-operations]]

External operations invoked by the domain must be resolved.
In this section we stub out those operations with sufficient code
to be able to run our example program.

For the washing machine we included an external operation
to notify the completion of the wash cycle.

[source,tcl]
----
<<external operation>>=
externalop void cycleComplete {washerid MRT_InstId} {
    /*
     * Exit the event loop for the purposes of the example.  This call is used
     * to cause the event loop to exit. This means that we will only run one
     * cycle of the washer before the program terminates.
     */
    mrt_SyncToEventLoop() ;
}
----

For the MOTOR and VALVE operations we will content ourselves to simply
log the fact that they were invoked.
The control that is implied by the operation is ``open loop'' and no
feed back is assumed.
So when we say ``Open a Valve'' we will assume that the value does what
it is told.
This leads us to the following implementation.

[source,tcl]
----
<<external operation>>=
externalop void motorStart {motorid MRT_InstId} {
    printf("%s: starting motor %u\n", __func__, motorid) ; // <1>
}
externalop void motorStop {motorid MRT_InstId} {
    printf("%s: stopping motor %u\n", __func__, motorid) ;
}
externalop void valveOpen {valveid MRT_InstId} {
    printf("%s: opening valve %u\n", __func__, valveid) ;
}
externalop void valveClose {valveid MRT_InstId} {
    printf("%s: closing valve %u\n", __func__, valveid) ;
}
----
<1> In `micca`,
we may supply code for an external operation.
Normally that code is *not* placed in the generated code file.
An external operation is usually resolved by code elsewhere in the
system.
For testing convenience,
`micca` can be given an option to emit any defined external operation
code.

The SENSOR operations present a bit more difficulty to stub.
In this case,
there _is_ feedback from the interaction.
We must signal back the state of tub as being full or empty.
So in some sense we must _simulate_ the action of the sensor.
To accomplish simulating the sensor,
we will record data in a relvar identified by the washing machine id.
This will allow us to simulate an arbitrary number of washing machines.
We will delay the announcement of the new state for some time
to simulate the water filling or draining.
To make the example run in reasonable times,
we assume the tub will fill or empty in 3 seconds.
That's quick!

[source,tcl]
----
<<external operation>>=
prologue {
    static bool tubFull[WMCTRL_CLOTHESTUB_INSTCOUNT] = {
        [WMCTRL_CLOTHESTUB_CT1_INSTID] = false,
    } ;
}

externalop void sensorEnable {tubid MRT_InstId} {
    printf("%s: enable sensor for tub %u\n", __func__, tubid) ;

    tubFull[tubid] = !tubFull[tubid] ;

    mrt_PortalSignalDelayedEvent(&wmctrl__PORTAL,
        WMCTRL_CLOTHESTUB_CLASSID,
        tubid,
        mrtTransitionEvent,
        tubFull[tubid] ?    WMCTRL_CLOTHESTUB_TUBFULL_EVENT :
                            WMCTRL_CLOTHESTUB_TUBEMPTY_EVENT,
        NULL,
        3000) ;
}
externalop void sensorDisable {tubid MRT_InstId} {
    printf("%s: disable sensor for tub %u\n", __func__, tubid) ;

    mrt_PortalCancelDelayedEvent(&wmctrl__PORTAL,
        WMCTRL_CLOTHESTUB_CLASSID,
        tubid,
        tubFull[tubid] ?    WMCTRL_CLOTHESTUB_TUBFULL_EVENT :
                            WMCTRL_CLOTHESTUB_TUBEMPTY_EVENT) ;
}
----

Delivering the indication that the Water Level Sensor has detected
a change in the water level really means we want to send the
appropriate ClothesTub instance either the *TubFull* or *TubEmpty*
event.
So we use a boolean to track the state of the tub, toggling that
state when the sensor is enabled.

=== Running the Example

Before we can start the example running,
we explain how we are going to stop it.
Recall that to dispatch state machine events we must
*enter the event loop*.
We will invoke the `mrt_EventLoop` function to do that.
But we need some way to break out of the event loop
so that we can stop the example run.
To do that, somewhere we must invoke the `mrt_SyncToEventLoop` function.

We will invoke `mrt_SyncToEventLoop` in the external operation
*cycleComplete*.
This operation is invoked when the cycle is done
and it is our intent to regain control of the execution flow after
each washing cycle.
Note that we are implementing the external operation in this manner solely to
be able to run one washing cycle in our example and gain control after that
cycle has completed.
An actual application would most likely run forever or invoke
`exit` based on some other condition or circumstance.

Finally, yes truly finally,
we are in a position to run the washer through the cycle.
This is done by supplying a `main` program.
The domain initialization done by `wmctrl_init` signals all the
initial instances (one in our case) to start.
After that, the event loop gains control and the execution sequencing
begins.

[source,tcl]
----
<<main program>>=
int
main(
    int argc,
    char *argv[])
{
    mrt_Initialize() ;
    wmctrl_init() ;
    mrt_EventLoop() ;

    return EXIT_SUCCESS ;
}
----

=== Example Program

The example program must be generated by running `micca`.
Normally,
this would be done using the `micca` program.
Here we are doing it using a Tcl script as this is more convenient
during the development of `micca` itself.

[source,tcl]
----
<<build_wmctrl.tcl>>=
source ../../tcl/micca.tcl
micca configureFromFile wmctrl.micca
micca configureFromFile wmctrl_pop.micca
micca generate stubexternalops true
----

=== Example Run Results

After running the example we obtain the following output.

[literal]
.Output From Running the Example
--
include::wmctrl-trace.txt[]
--

The trace consists of the chronological trace of the state machine
event dispatch and
the logging messages of the external operation stubs.
The first column of the event dispatch
trace is the time of day down to microseconds.
The remainder of the trace show the details of the event dispatch.
The first portion of the _Transition_ trace shows the event being
dispatched from a source instance to a target instance.
The state machine transition of the target instance,
from current state to new state,
is shown after the ``==>'' symbol.
Instances are shown in the form of _class.instance_ if such information
is known.
For events originating outside of a state activity,
the instance is shown as ``none.none''.
