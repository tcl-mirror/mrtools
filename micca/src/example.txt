// vim:set syntax=asciidoc:

= An Example
[partintro]
--
In this part,
we show an example of a simple domain being translated using `micca`.
--

== Controlling a Washing Machine

=== Introduction

It is traditional in technical books to start off with a simple example.
This example is not quite as simple as the classic _Hello World!_ example
but will suffice to give a summary of many of the characteristics
of `micca` translated domain.
We anticipate that there will be many questions after reading the
example and those questions are answered in later chapters.

Unfortunately,
there is rather a lot of background material that we will not cover here.
We do not explain how to create an XUML model
nor will we spend much time explaining why the example model was designed
the way it was.
There are many good books that explain XUML in detail and will teach
you the basics of modelingfootnote:[
<<mb-xuml,Mellor and Balcer>>,
<<rs-xuml,Chris Raistrick _et.al_>> and
<<ls-build,Leon Starr>> all are worthy of a close reading.].
We suggest you read at least one of them.
However, if your role is to perform the translation of a model,
then the details of how the model was created are not particularly important.
As long as you understand basic model execution rules,
the translation can be done ignoring the details of what the model
actually does.
As long as you preserve all the application logic in the translation,
the details of that logic are are secondary.
It is also the case that this package represents one particular piece
of a larger workflow and this means that readers who may not be
completely familiar with model-driven translation oriented development
may have many questions that remain.

The subject matter of our example is an automatic clothes washer.
This is a very simple washing machine,
especially compared to modern commercially available washers.
The intent is to select a subject that most people would be familiar
with from ordinary experience so that we don't have to devote too much
time explaining the problem.
One word of caution.
This model is an example for pedagogical purposes
and probably has little correspondence with the way _real_ washing
machines operate or are designed to operate.
You will also notice a lack of any attention paid to _what can go wrong_.
For industrial strength programs,
handling probable failure cases is very important but we have dispensed
with those considerations here to focus on how the model is
translated into the implementation code using `micca`.

=== Translation Overview

To translate an XUML model using `micca`,
the model is encoded in a domain specific language.
You may draw the model in your favorite tool.
This example was done using http://www.umlet.com[UMLet]
as a drawing tool.
For this translation, we choose to keep the domain description
in one file and an initial instance population in another file.
This is a common way to be able to provide several different populations
to the same domain,
an important consideration for testing and deployment.

In the file for the domain,
we use the `domain` command to specify the details of the model.

[source,tcl]
----
<<wmctrl.micca>>=
<<copyright info>>

domain wmctrl {
    <<WM class>>
    <<WC class>>
    <<CT class>>
    <<WV class>>
    <<MTR class>>
    <<WLS class>>
    <<wmctrl relationships>>
    <<wmctrl operations>>
    <<external operation>>
    <<type aliases>>
    epilogue {
        <<main program>>
    }
}
----

Within the `domain` script,
we specify the details of the classes, relationship and operations.

The `population` command is used to specify the initial class instances.
These are instances that will exist when the domain starts to execute.

[source,tcl]
----
<<wmctrl_pop.micca>>=
population wmctrl {
    <<WM population>>
    <<WC population>>
    <<CT population>>
    <<MTR population>>
    <<WV population>>
    <<WLS population>>
}
----

=== Domain Data

The first facet of a domain to translate is always the data.
The data defines the basis on which the code can operate.
The figure below shows a class diagram for the washing machine control
domain in UML graphical notation.

[[class-diagram,class diagram]]

image::wmc-class-diagram.pdf[title="Washing Machine Class Diagram"]

In our world,
a Washing Machine operates according to some Washing Cycle.
The Washing Cycle is a set of parameters that specifies aspects of
the washing that will turn dirty clothes into clean ones.
The Washing Machine itself has a Clothes Tub into which the dirty
laundry is placed.
There are also Water Valves to control the flow of water into and out of
the Clothes Tub and Motors to run a water pump, agitate the
Clothes Tub and rotate the Clothes Tub to spin excess water out of the
clean laundry.
Rounding out the machinery,
there is a Water Level Sensor that will tell us when the Clothes Tub
is filled with water or empty of water.

For a well engineered model,
the class diagram must also have a set of descriptions of what
the attributes and relationship actually mean,
what the value domains of the attributes are and many other
aspects that describe how the problem is represented in the model.
These descriptions are vital to understanding a class diagram.
Here again, in the interests of space,
we will have to suffice ourselves with more casual descriptions
included along with the example as it translated into the implementation
and an admonition that writing the model descriptions is an essential
aspect of a well engineered solution.

The class diagram shows the static aspects of our domain
and is always the first aspect of the model that must be considered
when deriving the implementation.
The class diagram facet of the model is static in the sense that
at any point in time,
the logical predicates you can infer from the diagram will be true.
The class attributes hold those properties of the domain whose values can vary
and the relationships state how the entities abstracted by the classes
are associated with each other.
Later, we visit the dynamic and algorithmic facets of the domain
but, for now, we will endeavor to represent the classes and relationships
in terms of the `micca` constructs.

==== Washing Machine Class

By examining the graphics of the model we can see that the Washing Machine
class has attributes, operations and a state model.

(((Example,Class,WashingMachine)))
[source,tcl]
----
<<WM class>>=
class WashingMachine { # <1>
    attribute MachineID {char[32]}

    statemodel {
        <<WM statemodel>>
    }

    <<WM operations>>
}
----
<1> The basic anatomy of a class specification is the same.
Classes usually (but not always) have attributes.
Active classes have a state model.
Some classes define class-based or instance-based operations as a
means of factoring common code into one location.
We have chosen to include the state model and operations as
literate program chunks to highlight the way the components
of a class are specified.

Looking at the Washing Machine class on the <<class-diagram,class diagram>>,
we see that there are two attributes.
The MachineID attribute is an identifier and we make its data type
a simple string.
Usually, attributes that are used purely for identification purposes
are excluded from the implementation of the domain.
In this case, we will use Machine ID for other purposes and so
must be retained as an attribute of the Washing Machine class.
`Micca` will make up its own identifier for instances of the class.
Since we still want Machine ID to be an identfier,
we must take on that responsibility.
We will need a class operation that can search the instances
of the Washing Machine class to determine if one already exists
with a given Machine ID value.

The CycleType attribute is referential attribute and we will not need it.
Generally,
attributes that are purely referential in nature are excluded as
attributes when a class is defined to `micca`.
This is because `micca` will generate its own identifier for instances and will
assume the responsibility to store the necessary information to realize
relationships.
Since in this case the Cycle Type attribute is only used to realize
relationship, R4, we need not include this attribute and can let `micca`
manage the information needed for R4.

While we are discussing R4, we can define its characteristics.
We can represent the participating classes, multiplicity and conditionality as
presented in the class diagram by the following domain configuration statement.

[source,tcl]
----
<<wmctrl relationships>>=
association R4 WashingMachine 0..*--1 WashingCycle
----

The syntax of the `association` command is intended to follow directly
from the model graphic.
In this case,
`R4` is an association where instances of the `WashingMachine` class refer
to instances of the `WashingCycle` class.
Specifically, each instance of the `WashingMachine` class refers to exactly
one instance of the `WashingCycle` class and, conversely, each instance
of the `WashingCycle` class is referred to by zero or more instances of
the `WashingMachine` class.
The `micca` run time will insure that this declarative statement of
the multiplicity and conditionality of the association instances remains
true during the run time of the program.

==== Washing Cycle Class

Examining the class diagram and other graphics for the domain shows that
the Washing Cycle class is a simple class consisting entirely of
descriptive attributes.

(((Example,Class,WashingCycle)))
[source,tcl]
----
<<WC class>>=
class WashingCycle {
    attribute CycleType {char[32]}
    attribute WashWaterTemp WaterTemp_t
    attribute RinseWaterTemp WaterTemp_t
    attribute WashDuration unsigned
    attribute RinseDuration unsigned
    attribute SpinDuration unsigned
    attribute AgitationSpeed WashSpeed_t
    attribute SpinSpeed WashSpeed_t

    <<WC operations>>
}
----

We need only specify the attributes and their data types.
In order to determine the proper data types of the attributes we
would need to consult the descriptive text associated with the class diagram.
As we have no such text in this example,
we will infer a set of data types based on how the attribute values
will be used in the processing.
We can declare the data types to `micca`; in this case some enumerations.

[source,tcl]
----
<<type aliases>>=
typealias WaterTemp_t {enum {WT_Hot, WT_Cold, WT_Warm}}
typealias WashSpeed_t {enum {WS_Low, WS_Medium, WS_High}}
----

==== Clothes Tub Class

By now the pattern of examining the model graphics to determine
the class characteristics is established.
The Clothes Tub class is an active class with a state model.
A Clothes Tub only has identifying and referential attributes and they
are elided as `micca` will provide the necessary identifier and
reference storage.

(((Example,Class,ClothesTub)))
[source,tcl]
----
<<CT class>>=
class ClothesTub { # <1>
    statemodel {
        <<CT statemodel>>
    }
    <<CT operations>>
}
----
<1> Note in this case there are no attributes of `ClothesTub`.
The `MachineID` attribute shown in the class diagram is both an
identifier and referential.
Since we only ever refer to instances of `ClothesTub` as they
apply to their corresponding `WashingMachine` this single attribute
can be eliminated and `micca` will take on the responsibility of
identifying the instances and insuring enough information is stored
to navigate the `R1` association.

The `R1` association itself can be transcribed from the graphic as follows.
`R1` states that there is an exact one-to-one correspondence between
`ClothesTub` instances and `WashingMachine` instances.
This is formal statement of a fundamental rule of the Washing Machine
physical design.

[source,tcl]
----
<<wmctrl relationships>>=
association R1 ClothesTub 1--1 WashingMachine
----

==== Water Valve Class

The Water Valve class represents the means to control the movement of water
into and out of a Clothes Tub.
Since a Clothes Tub can have several valves,
we need an attribute to distinguish them.
So, we keep the `ValveID` attribute.
The `MachineID` attribute is discarded as it is purely referential.

(((Example,Class,WaterValve)))
[source,tcl]
----
<<WV class>>=
class WaterValve {
    attribute ValveID ValveType_t

    <<WV operations>>
}
----

The type of a valve comes from a fixed, well-known set.

[source,tcl]
----
<<type aliases>>=
typealias ValveType_t {enum {WV_Hot, WV_Cold, WV_Drain}}
----

The R3 relationship represents the design of the washing machine hardware
that includes three valves on each machine.
Notice the we don't concern ourselves here with whether a washing machine
has three or three thousand valves on it.
That is dealt with when we populate the class instances.
The important point here is that there is one or more valves associated
with each tub and each water valve is connected to exactly one tub.
The exact number is not represented in the model because the logic
of the model does not change if there are three or three thousand
water valves attached to the Washing Machine.
Of course, when we implement computing operations on the Water Valves,
whether there are three or three thousand might have a very significant
impact on the algorithms we might choose.

[source,tcl]
----
<<wmctrl relationships>>=
association R3 WaterValve 1..*--1 ClothesTub
----

==== Motor Class

The Motor class is similar to the Water Valve class.

(((Example,Class,Motor)))
[source,tcl]
----
<<MTR class>>=
class Motor {
    attribute MotorID MotorType_t

    <<MTR operations>>
}
----

Our washer has three types of motors.

[source,tcl]
----
<<type aliases>>=
typealias MotorType_t {enum {MTR_Pump, MTR_Agitator, MTR_Spin}}
----

The R2 relationships states the hardware design of using one or more
motors to operation a clothes tub.

[source,tcl]
----
<<wmctrl relationships>>=
association R2 Motor 1..*--1 ClothesTub
----

==== Water Level Sensor

The Water Level Sensor class is also simple.
It has no attributes.
It is closely associated with the Clothes Tub for which it senses.

(((Example,Class,WaterLevelSensor)))
[source,tcl]
----
<<WLS class>>=
class WaterLevelSensor {
    <<WLS operations>>
}
----

It is R5 that sets the rule about one Water Level Sensor per Clothes Tub.

[source,tcl]
----
<<wmctrl relationships>>=
association R5 WaterLevelSensor 1--1 ClothesTub
----

=== Domain Dynamics

The second facet of the model that is considered during translation is the
dynamics.
The model encodes the sequences of domain execution as state models attached to
classes.
In this model,
there are two classes for which state models are defined,
Washing Machine and Clothes Tub.
The control is partitioned by the model between these classes.
The Washing Machine class is given the responsibility for coordinating
the actions needed to clean clothes according to the particulars
specified by the Washing Cycle.
In this example,
that coordination primarily involves timing the various components of the
washing cycle.
The Clothes Tub class deals with sequencing the mechanics of the washer
to perform a specific activity.
Together, the classes coordinate their activities to achieve clothes washing.

For each state model,
we will present a graphical representation of the state model.
We also show the state transition table.
It is important to have both representations.
In the graphic,
it is conventional not to show ignored or error transitions.
However,
in the transition table all possible transitions and their outcomes
are exposed.

==== Washing Machine State Model

The state model for the Washing Machine class is shown below.
You will notice that in the graphic
the states contain language statements that specify
the processing to be performed when the state is entered.
We will say more about the state activities when we take up the domain
processing below.
For now,
it is convenient to have the actions present on the diagram in order
to better understand exactly what the washing machine will do as it
responds to events and thereby better understand how the state machines
achieve the overall result of producing clean clothes.

image::wm-states.pdf[title="Washing Machine State Model Diagram"]

From the diagram we can see how the washing machine cycles in a rather
simple circular form filling, washing, draining, rinsing and spinning
to convert dirty clothes into clean ones.
The state activities are primarily concerned with obtaining the
particular details of the next step and requesting the Clothes Tub
to carry out that step.
The various durations are handled by signaling delayed events
to march things along to the next step in the cleaning.

The transition table corresponding to the diagram is shown next.

.Washing Machine Transition Table
[options="header,unbreakable",cols="<h,4*^"]
|===========================
|                   |Start              |Full       |Done           |Empty
|Stopped            |Filling To Wash    |CH         |CH             |CH
|Filling To Wash    |CH                 |Washing    |CH             |CH
|Washing            |CH                 |CH         |Draining Wash  |CH
|Draining Wash      |CH                 |CH         |CH             |Filling To Rinse
|Filling To Rinse   |CH                 |Rinsing    |CH             |CH
|Rinsing            |CH                 |CH         |Draining Rinse |CH
|Draining Rinse     |CH                 |CH         |CH             |Spinning
|Spinning           |CH                 |CH         |Stopped        |CH
|===========================

The transition table may be directly translated into the required
`micca` configuration statements.
Below, we have not shown state activity code.
We will return to the processing <<domain-processing,below>>.
For now, we simply transliterate the transition table into the
required `transition` statements.

(((Example,State Model,WashingMachine)))
[source,tcl]
----
<<WM statemodel>>=
initialstate Stopped
defaulttrans CH

transition Stopped - Start -> FillingToWash

transition FillingToWash - Full -> Washing

transition Washing - Done -> DrainingWash

transition DrainingWash - Empty -> FillingToRinse

transition FillingToRinse - Full -> Rinsing

transition Rinsing - Done -> DrainingRinse

transition DrainingRinse - Empty -> Spinning

transition Spinning - Done -> Stopped
----

==== Clothes Tub State Model

The diagram below shows the state model for the Clothes Tub class.
This model is _not_ circular like that of the Washing Machine
class.
There are two paths through the states.
One corresponds to agitating the tub for the purposes of either
washing or rinsing.
The other path corresponds to spinning the tub to remove excess
water from the clean clothes.
Both paths start at the Empty state.

image::ct-states.pdf[title="Clothes Tub State Model Diagram"]

The transition table follows immediately from the diagram.

.Clothes Tub Transition Table
[options="header,unbreakable",cols="<h,7*^"]
|===========================
|              |Fill    |TubFull |Agitate   |Drain    |TubEmpty |Spin     |Stop
|Empty         |Filling |CH      |CH        |CH       |CH       |Spinning |CH
|Filling       |CH      |Full    |CH        |CH       |IG (1)   |CH       |CH
|Full          |CH      |CH      |Agitating |CH       |CH       |CH       |CH
|Agitating     |CH      |CH      |CH        |Emptying |CH       |CH       |CH
|Emptying      |CH      |IG (1)  |CH        |CH       |Empty    |CH       |CH
|Spinning      |CH      |CH      |CH        |CH       |CH       |CH       |Stopping Spin
|Stopping Spin |Filling |CH      |CH        |CH       |CH       |CH       |CH
|===========================

(1) For the *Filling* and *Emptying* states,
we allow for the fact that when the water level sensor is
enabled it may send events that reflect its current state.
So we simply ignore those sensor events in which we are not currently
interested.

The `micca` configuration statements follow directly from the transition table.

(((Example,State Model,ClothesTub)))
[source,tcl]
----
<<CT statemodel>>=
initialstate Empty
defaulttrans CH

transition Empty - Fill -> Filling
transition Empty - Spin -> Spinning

transition Filling - TubFull -> Full
transition Filling - TubEmpty -> IG

transition Full - Agitate -> Agitating

transition Agitating - Drain -> Emptying

transition Emptying - TubEmpty -> Empty
transition Emptying - TubFull -> IG

transition Spinning - Stop -> StoppingSpin

transition StoppingSpin - Fill -> Filling
----

=== Domain Processing [[domain-processing]]

The third facet of the model that must be translated is the processing.
Processing is executed in state activities or the various operations
of the domain or classes.
We represent the processing as action language.
There are several different action languages that are in use.
In the example,
we follow an <<mb-xuml,established syntax>> for the actions.
All the action languages allow for writing expressions and for
performing model level processing.
Since we are not automatically parsing the action language in this context,
we are not particular about the syntax as long as the action statements
convey the required processing unambiguously.
In the `micca` scheme,
action language translation is done manually with substantial support
from `micca` for specifying model level types of processing.

For state activities,
the diagrams above show the action language that is to be executed
when the state is entered.
In the translations below,
we duplicate the action language from the state and write the translation to
``C'' code immediately following.

The model level actions performed by the state activities,
such as access to attribute values,
navigating the class diagram or signaling events,
is accomplished by invoking embedded macro
commands that are expanded into ``C'' code.
The commands are contained between the ``%<'' and ``>%'' markers.
All the content between the markers (and the markers themselves) is replaced
with the ``C'' code that implements the model level execution semantics
implied by the embedded macro command.
Otherwise, ordinary ``C'' code is passed along unmodified.
The `micca` scheme uses directly coded ``C'' for flow of control,
variables and expression evaluation.
Access to model level execution actions is provided by the embedded
macro commands.

In the code below,
we strive for a clear correspondence between the action language of
the activity and its translation into ``C'' and macro commands.
This is not the only translation possible and not necessarily the
most efficient.
The intent is to show the correspondence between the actions and
the translation into ``C''.
In the interest of clarity,
no attempt has been made to shorten or optimize the ``C'' code.
There will be cases where some variable assignments will seem superfluous.

==== Washing Machine State Activities

Below is the processing for the Washing Machine state activities.
For the first few states,
we will make several comments on the correspondence between the
action language statements and the ``C'' code.
After the translation pattern is established,
we present the remaining state with minimal explanation.

// %States images/wm-states.uxf WashingMachine

'''
The Stopped state of the Washing Machine is entered when the cycle
is complete and we must signal the Clothes Tub to stop spinning.
The action consists of finding the related Clothes Tub instance
and signaling the Stop event to it.

// %Action WashingMachine Stopped
.Stopped Activity Action Language
----
# Stop spinning -- wash complete
select one ct related by self->R1[CT]
signal Stop to ct
----

.Stopped State Implementation
[source,tcl]
----
<<WM statemodel>>=
state Stopped {} {
    %<my findOneRelated ct ~R1>%
    %<instance ct signal Stop>%

    // This code is not part of the model activity. <1>
    MRT_InstId selfid = %<my instid>% ;
    %<externalop cycleComplete washerid selfid>% ;
}
----
<1> We have added a call to an external operation to notify the outside
world that the washer had completed it cycle.
This is strictly for the benefit of running the example.
<<running-the-example,Below>> we show how this is used to terminate the example
run.

'''

All state activities have an implicit `self` argument defined for them.
`Self` is an reference to the instance upon which the activity is operating.
The `%<my findOneRelated ct ~R1>%` command
navigates from `self` along `~R1` and assigns the
resulting Clothes Tub instance into a variable named `ct` that is
typed as a reference to a Clothes Tub.
With the Clothes Tub instance in hand,
the `Stop` event is signaled to it using the `signal` command.
There are a couple things to note here.

. The use of the direction syntax, _i.e._ `~R1`, says that we navigate
the `R1` relationship in the *reverse* direction.
Supplying a direction obviates the need to
say that we are navigating to an instance of the `ClothesTub` class in the
manner that the action language statement does.
Because of the syntax convention and the manner in which the
association was defined,
the system knows the destination class.
. The question arises whether the instance reference returned from
`findOneRelated` in the above traversal across `~R1`
can ever be the empty reference or ever reference multiple instances.
The answer is no!
The `R1` association,
as shown in the class diagram,
is singular and unconditional on the Clothes Tub side.
Every traversal from Washing Machine to Clothes Tub along `~R1` is guaranteed
to return exactly one instance.
Any operation in the domain that would perturb that state of affairs
is rejected as violating the referential integrity of the
class diagram.
Consequently,
no test of the multiplicity of the returned reference is necessary as the
system is already making that test and so it would be strictly redundant.
In general,
traversing unconditional relationships never requires a test to determine if
we obtained an instance reference and traversing a conditional relationship
should always be followed by a test of the returned reference to
see if it is empty.
The fact that a relationship is conditional implies that there is
to be conditional processing associated with traversing the relationship.

'''
The Filling To Wash state is entered when the washing machine wishes to
fill it clothes tub with water in preparation for a period of clothes
washing.
In the action,
it is necessary to find out the water temperature that is to be used
for washing.
That information is stored as an attribute of the related washing cycle
and passed as the `temp` parameter of the Fill event.
We know the name of the parameter to the Fill event is `temp` because
that is the name of the parameter of the Filling state into which
the Fill event causes a transition.

// %Action WashingMachine "Filling To Wash"
.Filling To Wash Activity Action Language
----
# Fill the tub with wash water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.WashWaterTemp) to ct
----

.Filling To Wash State Implementation
[source,tcl]
----
<<WM statemodel>>=
state FillingToWash {} {
    %<my findOneRelated wc R4>%
    %<my findOneRelated ct ~R1>%
    WaterTemp_t washtemp = %<instance wc attr WashWaterTemp>% ;
    %<instance ct signal Fill temp washtemp>%   // <1>
}
----
<1> Note that embedded macros _cannot_ be nested, so it is necessary
to assign the wash water temperature to a variable.
There is no efficiency concern here.
Optimizations by the compiler will remove any unneeded local variables.

'''
While in the Washing state, clothes are being agitated in the tub.
The state uses a delayed event to determine when the washing part of
the cycle is finished.
Note that the delay time of the signal is another attribute value obtained
from the Washing Cycle class.
Here Washing Cycle serves a role of holding attributes that just specify
conditions for another class
This is a common arrangement in models.

// %Action WashingMachine Washing
.Washing Activity Action Language
----
# Agitate the tub to wash.
select one ct related by self->R1[CT]
signal Agitate to ct
select one wc related by self->R4[WC]
signal Done to self at wc.WashDuration
----

.Washing State Implementation
[source,tcl]
----
<<WM statemodel>>=
state Washing {} {
    %<my findOneRelated ct ~R1>%
    %<instance ct signal Agitate>%
    %<my findOneRelated wc R4>%
    MRT_DelayTime washtime = %<instance wc attr WashDuration>% * 1000 ;
    %<my delaysignal washtime Done>% // <1>
}
----
<1> We are implicitly assuming the units of WashDuration are seconds.
In truth, the units are minutes, but we are not patient enough
to wait that long for the example to execute.

'''

The delayed signal is accomplished by using the `my delaysignal` macro command.
The event is directed to the `self` instance (the `my` command implies this),
albeit delayed by the washing cycle time.
So this state sends two signals,
one to the Clothes Tub to tell it to start agitating the clothes
and a delayed signal to itself so it when know when the clothes have
been washing for the amount of time defined by the related
Washing Cycle.

The remaining Washing Machine state activities follow the established pattern.

'''
// %Action WashingMachine "Draining Wash"
.Draining Wash Activity Action Language
----
# Stop washing and drain
# the dirty wash water.
select one ct related by self->R1[CT]
signal Drain to ct
----

.Draining Wash State Implementation
[source,tcl]
----
<<WM statemodel>>=
state DrainingWash {} {
    %<my findOneRelated ct ~R1>%
    %<instance ct signal Drain>%
}
----

'''

// %Action WashingMachine "Filling To Rinse"
.Filling To Rinse Activity Action Language
----
# Fill the tub with rinse water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.RinseWaterTemp) to ct
----

.Filling To Rinse State Implementation
[source,tcl]
----
<<WM statemodel>>=
state FillingToRinse {} {
    %<my findOneRelated wc R4>%
    %<my findOneRelated ct ~R1>%
    WaterTemp_t rinsetemp = %<instance wc attr RinseWaterTemp>% ;
    %<instance ct signal Fill temp rinsetemp>%
}
----

'''

// %Action WashingMachine Rinsing
.Rinsing Activity Action Language
----
# Agitate the tub to rinse.
select one ct related by self->R1[CT]
signal Agitate to ct
select one wc related by self->R4[WC]
signal Done to self at wc.RinseDuration
----

.Rinsing State Implementation
[source,tcl]
----
<<WM statemodel>>=
state Rinsing {} {
    %<my findOneRelated ct ~R1>%
    %<instance ct signal Agitate>%
    %<my findOneRelated wc R4>%
    MRT_DelayTime rinsetime = %<instance wc attr RinseDuration>% * 1000 ;
    %<my delaysignal rinsetime Done>%
}
----

'''

// %Action WashingMachine "Draining Rinse"
.Draining Rinse Activity Action Language
----
# Stop rinsing and drain
# the rinse water.
select one ct related by self->R1[CT]
signal Drain to ct
----

.Draining Rinse State Implementation
[source,tcl]
----
<<WM statemodel>>=
state DrainingRinse {} {
    %<my findOneRelated ct ~R1>%
    %<instance ct signal Drain>%
}
----

'''

// %Action WashingMachine Spinning
.Spinning Activity Action Language
----
# Spin out excess water.
select one ct related by self->R1[CT]
signal Spin to ct
select one wc related by self->R4[WC]
signal Done to self at wc.SpinDuration
----

.Spinning State Implementation
[source,tcl]
----
<<WM statemodel>>=
state Spinning {} {
    %<my findOneRelated ct ~R1>%
    %<instance ct signal Spin>%
    %<my findOneRelated wc R4>%
    MRT_DelayTime spintime = %<instance wc attr SpinDuration>% * 1000 ;
    %<my delaysignal spintime Done>%
}
----
'''

==== Clothes Tub State Activities

The other state model in our example is for the Clothes Tub class

Because the Clothes Tub interacts frequently with its related
Motor and Water Valve instances,
we will create some instance based operations to
help us locate the required Motor or Water Valve instance.
It is common to factor out such code as it usually corresponds
to an action language `where` clause.
This allows us to create type specific and type safe code
for the query.

Factoring out the search code also allows us to control the algorithm used.
Below we just use a simple linear search as the `micca` embedded
macro commands provide iterators for the class instances.
This works well for a small number of instances.
However, if the number of instances was large
or the frequency of the search was high,
then you might consider a more sophisticated search technique such
as binary searching or hash based searching.

[source,tcl]
----
<<CT operations>>=
instop {struct Motor *} findRelatedMotor {mtrid MotorType_t} {
    %<my foreachRelatedWhere mtr {mtr->MotorID == mtrid} ~R2>%
        return mtr ;
    %<end>%

    return NULL ;
}
----

[source,tcl]
----
<<CT operations>>=
instop {struct WaterValve *} findRelatedValve {valveid ValveType_t} {
    %<my foreachRelatedWhere valve {valve->ValveID == valveid} ~R3>%
        return valve ;
    %<end>%

    return NULL ;
}
----

[source,tcl]
----
<<CT operations>>=
instop MRT_InstSet findRelatedWaterValves {} {
    %<my selectRelatedWhere watervalves vid\
            {vid->ValveID == WV_Hot || vid->ValveID == WV_Cold} ~R3>%

    return watervalves ;
}
----

With these helper operations,
the Clothes Tub state activities require much less boilerplate code.

// %States images/ct-states.uxf ClothesTub

'''
// %Action ClothesTub Empty
.Empty Activity Action Language
----
# Stop the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Stop()
# Close the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Close()
# Disable the sensor
select one wls related by self->R5[WLS]
wls.Disable()
# Inform the washing machine
select one wm related by self->R1[WM]
signal Empty to wm
----

.Empty State Implementation
[source,tcl]
----
<<CT statemodel>>=
state Empty {} {
    %<Motor instref mtr>%
    mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
    assert(mtr != NULL) ;
    %<instance mtr operation Stop>% ;

    %<WaterValve instref wv>%
    wv = %<my operation findRelatedValve valveid WV_Drain>% ;
    assert(wv != NULL) ;
    %<instance wv operation Close>% ;

    %<my findOneRelated wls ~R5>%
    %<instance wls operation Disable>% ;

    %<my findOneRelated wm R1>%
    %<instance wm signal Empty>%
}
----

'''

// %Action ClothesTub Filling
.Filling Activity Action Language
----
# Enable the sensor
select one wls related by self->R5[WLS]
wls.Enable()
# Open inlet valve(s)
if (temp = 'Hot')
    select one wv related by self->R3[WV]
        where (ValveID = 'Hot')
    wv.Open()
else if (temp = 'Cold')
    select one wv related by self->R3[WV]
        where (ValveID = 'Cold')
    wv.Open()
else if (temp = 'Warm')
    select many wvs related by self->R3[WV]
        where (ValveID = 'Hot' OR ValveID = 'Cold')
    foreach wv in wvs
        wv.Open()
    endfor
end if
----

.Filling State Implementation
[source,tcl]
----
<<CT statemodel>>=
state Filling {temp WaterTemp_t} {
    %<my findOneRelated wls ~R5>%
    %<instance wls operation Enable>% ;
    %<WaterValve instref wv>%

    if (temp == WT_Hot) {
        wv = %<my operation findRelatedValve valveid WV_Hot>% ;
        assert(wv != NULL) ;
        %<instance wv operation Open>% ;
    } else if (temp == WT_Cold) {
        wv = %<my operation findRelatedValve valveid WV_Cold>% ;
        assert(wv != NULL) ;
        %<instance wv operation Open>% ;
    } else if (temp == WT_Warm) {
        %<WaterValve instset watervalves>%
        watervalves = %<my operation findRelatedWaterValves>% ;
        %<instset watervalves foreachSelected wv>%
            %<instance wv operation Open>% ;
        %<end>%
    }
}
----
'''

// %Action ClothesTub Full
.Full Activity Action Language
----
# Disable the sensor
select one wls related by self->R5[WLS]
wls.Disable()
# Close all water valves
select many wvs related by self->R3[WV]
    where (ValveID = 'Hot' OR ValveID = 'Cold')
foreach wv in wvs
    wv.Close()
endfor
# Inform the washing machine
select one wm related by self->R1[WM]
signal Full to wm
----

.Full State Implementation
[source,tcl]
----
<<CT statemodel>>=
state Full {} {
    // Disable the sensor
    %<my findOneRelated wls ~R5>%
    %<instance wls operation Disable>% ;

    // Close all water valves
    %<WaterValve instset watervalves>%
    watervalves = %<my operation findRelatedWaterValves>% ;
    %<instset watervalves foreachSelected wv>%
        %<instance wv operation Close>% ;
    %<end>%

    // Inform the washing machine
    %<my findOneRelated wm R1>%
    %<instance wm signal Full>%
}
----

'''

// %Action ClothesTub Agitating
.Agitating Activity Action Language
----
# Start the agitator motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Agitator')
mtr.Start()
----

.Agitating State Implementation
[source,tcl]
----
<<CT statemodel>>=
state Agitating {} {
    // Start the agitator motor
    %<Motor instref mtr>%
    mtr = %<my operation findRelatedMotor mtrid MTR_Agitator>% ;
    assert(mtr != NULL) ;
    %<instance mtr operation Start>% ;
}
----

'''

// %Action ClothesTub Emptying
.Emptying Activity Action Language
----
# Stop the motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Agitator')
mtr.Stop()
# Open the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Open()
# Start the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Start()
# Enable the sensor
select one wls related by self->R5[WLS]
wls.Enable()
----

.Emptying State Implementation
[source,tcl]
----
<<CT statemodel>>=
state Emptying {} {
    // Stop the motor
    %<Motor instref mtr>%
    mtr = %<my operation findRelatedMotor mtrid MTR_Agitator>% ;
    assert(mtr != NULL) ;
    %<instance mtr operation Stop>% ;

    // Open the drain valve
    %<WaterValve instref wv>%
    wv = %<my operation findRelatedValve valveid WV_Drain>% ;
    assert(wv != NULL) ;
    %<instance wv operation Open>% ;

    // Start the pump
    mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
    assert(mtr != NULL) ;
    %<instance mtr operation Start>% ;

    // Enable the sensor
    %<my findOneRelated wls ~R5>%
    %<instance wls operation Enable>% ;
}
----

'''

// %Action ClothesTub Spinning
.Spinning Activity Action Language
----
# Open the drain valve
select one wv related by self->R2[WV]
     where (ValveID = 'Drain')
wv.Open()
# Start the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Start()
# Start the spin motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Spin')
mtr.Start()
----

.Spinning State Implementation
[source,tcl]
----
<<CT statemodel>>=
state Spinning {} {
    // Open the drain valve
    %<WaterValve instref wv>%
    wv = %<my operation findRelatedValve valveid WV_Drain>% ;
    assert(wv != NULL) ;
    %<instance wv operation Open>% ;

    // Start the pump
    %<Motor instref mtr>%
    mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
    assert(mtr != NULL) ;
    %<instance mtr operation Start>% ;

    // Start the spin motor
    mtr = %<my operation findRelatedMotor mtrid MTR_Spin>% ;
    assert(mtr != NULL) ;
    %<instance mtr operation Start>% ;
}
----

'''

// %Action ClothesTub "Stopping Spin"
.Stopping Spin Activity Action Language
----
# Stop the motor
select one mtr related by self->R2[MTR]
    where (MotorID = 'Spin')
mtr.Stop()
# Stop the pump
select one mtr related by self->R2[MTR]
    where (MotorID = 'Pump')
mtr.Stop()
# Close the drain valve
select one wv related by self->R3[WV]
     where (ValveID = 'Drain')
wv.Close()
----

.Stopping Spin State Implementation
[source,tcl]
----
<<CT statemodel>>=
state StoppingSpin {} {
    // Stop the motor
    %<Motor instref mtr>%
    mtr = %<my operation findRelatedMotor mtrid MTR_Spin>% ;
    assert(mtr != NULL) ;
    %<instance mtr operation Stop>% ;

    // Stop the pump
    mtr = %<my operation findRelatedMotor mtrid MTR_Pump>% ;
    assert(mtr != NULL) ;
    %<instance mtr operation Stop>% ;

    // Close the drain valve
    %<WaterValve instref wv>%
    wv = %<my operation findRelatedValve valveid WV_Drain>% ;
    assert(wv != NULL) ;
    %<instance wv operation Close>% ;
}
----

'''

=== Class Operations

Class operations are those defined to operate on the class
as a whole.
Consequently, class operation do _not_ have an implied `self`
variable.
A common use for class operation is to select an instance of the
class based on supplied attribute values (_i.e._ to implement
`select from instances where` type action language statements).

==== Washing Machine Operations

The operation below searches the instances of the WashingMachine
class for any instance which matches the `id` argument value.

(((Example,Operation,findByMachineID)))
[source,tcl]
----
<<WM operations>>=
classop {struct WashingMachine *} findByMachineID {id {char const *}} {
    %<WashingMachine findWhere wm {strcmp(id, wm->MachineID) == 0}>%
    return wm ;
}
----

The `%<WashingMachine findWhere wm>%` command expands to
a loop to iterate across each instance of the Washing Machine class.
The `wm` variable is assigned a reference (or pointer value) to an
instance of Washing Machine.
If the where clause (the invocation of `strcmp()` in this case)
evaluates to true,
then iteration stops and `wm` holds the matching machine.
Otherwise, `wm` will be `NULL` if no match is found.

==== Washing Cycle Operations

We construct a similar class operation for the Washing Cycle class.
It is a common idom to construct such class operations for
attributes that are identifiers of the class.
This allows activities to verify an instance exists with a given value
for the identifier or to insure that no duplicated instances are created.

(((Example,Operation,findByCycleType)))
[source,tcl]
----
<<WC operations>>=
classop {struct WashingCycle *} findByCycleType {cycleType {char const *}} {
    %<WashingCycle findWhere wc {strcmp(cycleType, wc->CycleType) == 0}>%
    return wc ;
}
----

==== Instance Operations

The Water Valve, Motor and Water Level Sensor classes have instance based
operations that serve as an interface to external operations that are intended
to perform the physical actions associated with the hardware.
The external operations that are invoked detail the dependencies this
domain assumes will be performed by some other domain.

[float]
==== Water Valve Operations

[source,tcl]
----
<<WV operations>>=
instop void Open {} {
    MRT_InstId selfid = %<my instid>% ;
    %<externalop valveOpen valveid selfid>% ;
}

instop void Close {} {
    MRT_InstId selfid = %<my instid>% ;
    %<externalop valveClose valveid selfid>% ;
}
----

[float]
==== Motor Class Operations

[source,tcl]
----
<<MTR operations>>=
instop void Start {} {
    MRT_InstId selfid = %<my instid>% ;
    %<externalop motorStart motorid selfid>% ;
}

instop void Stop {} {
    MRT_InstId selfid = %<my instid>% ;
    %<externalop motorStop motorid selfid>% ;
}
----

[float]
==== Water Level Sensor Operations

[source,tcl]
----
<<WLS operations>>=
instop void Enable {} {
    %<my findOneRelated ct R5>%
    MRT_InstId ctid = %<instance ct instid>% ;
    %<externalop sensorEnable tubid ctid>% ;
}

instop void Disable {} {
    %<my findOneRelated ct R5>%
    MRT_InstId ctid = %<instance ct instid>% ;
    %<externalop sensorDisable tubid ctid>% ;
}
----

==== Domain Operations

In this section we show the code for the domain operations.
We assume that there is some entity, such as a user interface,
in the overall system that will invoke these operations.
To make our example run,
we will contrive to make that happen
even though we do not intend to supply a user interface, _per se_.

[float]
==== Create Washer

Since there several classes involved in creating a functioning washer,
a domain operation is useful to localize the construction of a washer.

(((Example,Domain Operation,createWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop int createWasher {washer {char const *}} {
    %<WashingMachine instref wm>%
    wm = %<WashingMachine operation findByMachineID id washer>% ;
    if (wm == NULL) {
        %<WashingCycle findByName Normal nwc>%  // <1>
        %<WashingMachine create wm MachineID washer R4 nwc>%

        %<ClothesTub create ct R1 wm>%

        %<WaterValve create wv ValveID WV_Hot R3 ct>%
        %<WaterValve create wv ValveID WV_Cold R3 ct>%
        %<WaterValve create wv ValveID WV_Drain R3 ct>%

        %<Motor create mtr MotorID MTR_Pump R2 ct>%
        %<Motor create mtr MotorID MTR_Agitator R2 ct>%
        %<Motor create mtr MotorID MTR_Spin R2 ct>%

        %<WaterLevelSensor create wls R5 ct>%
        return %<instance wm instid>% ;
    } else {
        MRT_DEBUG("washer, %s, already exists\n", washer) ;
        return -1 ;
    }
}
----
<1> By default, the Washing Cycle is set to `Normal`.

[float]
==== Delete Washer

If we can create a washer, it is also necessary to be able to delete one.
Here we must be careful to leave the data model referentially consistent.

(((Example,Domain Operation,deleteWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop bool deleteWasher {washer {char const *}} {
    bool status ;
    %<WashingMachine instref wm>%
    wm = %<WashingMachine operation findByMachineID id washer>% ;
    if (wm != NULL) {
        %<instance wm findOneRelated ct ~R1>%
        %<instance ct findOneRelated wls ~R5>%
        %<instance wls delete>%
        %<instance ct foreachRelated wv ~R3>%
            %<instance wv delete>%
        %<end>%
        %<instance ct foreachRelated mtr ~R2>%
            %<instance mtr delete>%
        %<end>%
        %<instance ct delete>%
        %<instance wm delete>%
        status = true ;
    } else {
        MRT_DEBUG("unknown washer, %s\n", washer) ; // <1>
        status = false ;
    }

    return status ;
}
----
<1> `micca` provides a `printf` style ``C'' preprocessor macro for
debugging output.

[float]
==== Start Washer

To start a washing machine we must supply the identifier of the
washer so we can know which one is to be started.
Although our instance population only included a single WashingMachine
instance,
as we stated before, the models will run with an arbitrary number
of washing machine instances.

The implementation of the operation first searches all the instances
of WashingMachine to find the correct one to start.
It is possible to request an unknown washer to start.
After finding the correct instance,
the *Start* event will kick things off.

(((Example,Domain Operation,startWasher)))
[source,tcl]
----
<<wmctrl operations>>=
domainop bool startWasher {washer {char const *}} {
    bool status ;
    %<WashingMachine instref wm>%
    wm = %<WashingMachine operation findByMachineID id washer>% ;
    if (wm != NULL) {
        %<instance wm signal Start>%
        status = true ;
    } else {
        MRT_DEBUG("unknown washer, %s\n", washer) ;
        status = false ;
    }

    return status ;
}
----

[float]
==== Select Cycle

On the class diagram,
relationship `R4` determines which Washing Cycle will be used to
control the operations.
Selecting a wash cycle means we must reform the `R4` relationship,
_i.e._ relate the existing cycle to a different one.
The implementation of the `selectCycle` domain operation does just that.

(((Example,Domain Operation,selectCycle)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void selectCycle {washer {char const *} cycle {char const *}} {
    %<WashingMachine instref wm>%
    wm = %<WashingMachine operation findByMachineID id washer>% ;
    if (wm == NULL) {
        MRT_DEBUG("unknown washer, %s\n", washer) ;
        return ;
    }

    %<WashingCycle instref reqCycle>%
    reqCycle = %<WashingCycle operation findByCycleType cycleType cycle>% ;
    if (reqCycle == NULL) {
        MRT_DEBUG("unknown washing cycle, %s\n", cycle) ;
        return ;
    }

    %<R4 swap wm reqCycle>%
}
----

==== Initialize

Most domains will need to have an initialization operation that
can be invoked as the system is started.
Here we start all the washing machines in the initial instance population.

(((Example,Domain Operation,init)))
[source,tcl]
----
<<wmctrl operations>>=
domainop void init {} {
    %<WashingMachine foreachInstance wm>%
        %<instance wm signal Start>%
    %<end>%
}
----

=== Initial Instance Population

In this section we supply an initial instance population for the domain.
`Micca` will arrange for the initial instances to be in place when the domain
begins execution.

We intend to have only a single WashingMachine instance and have chosen
to populate it directly rather than invoke `createWasher` in order to
show how an initial instance population is specified.
Note that the model will run correctly regardless of how many washing
machines we are trying to control even though we are creating only
a single instance here.

[source,tcl]
----
<<WM population>>=
class WashingMachine {
    instance wm1 MachineID {"wm1"} R4 PermPress ; # <1>
}
----
<1> Note that although we do not have any referential attributes
in the WashingMachine class,
we must still account for how the R4 relationship is to be handled.
Here we state that the WashingMachine instance named, ``wm1'',
will be related across R4 to the WashingCycle instance named, ``PermPress''.
The `PermPress` name is of our own invention and is the instance
name in the initial population.
It is defined below.
Notice that in the class model for the domain,
the Washing Machine class had a referential attribute that referenced
the Washing Cycle class.
The `R4` specification here accomplishes the same purpose, namely,
this instance of Washing Machine references a specific instance of
Washing Cycle.

[source,tcl]
----
<<WC population>>=
class WashingCycle {
    table {CycleType WashWaterTemp RinseWaterTemp WashDuration RinseDuration\
             SpinDuration AgitationSpeed SpinSpeed}\
    Normal {{"Normal"} WT_Cold WT_Cold 20 10 10 WS_Medium WS_Medium}\
    Whites {{"Whites"} WT_Hot WT_Cold 20 10 20 WS_High WS_High}\
    PermPress {{"PermPress"} WT_Warm WT_Cold 15 10 15 WS_Medium WS_Medium}\
    Delicate {{"Delicate"} WT_Cold WT_Cold 15 10 10 WS_Low WS_Low} ; # <1>
}
----
<1> Note that the character string literals are enclosed in braces ({}).
This is necessary since double quote marks (") are significant to the
Tcl embedded macro processor and we need to make sure that the double
quote characters make is all the way to the ``C'' code.
Enclosing text in braces prevents any interpretation of the enclosed text.

The class model dictates that each washer have exactly one ClothesTub.

[source,tcl]
----
<<CT population>>=
class ClothesTub {
    instance ct1 R1 wm1
}
----

Each Washing Machine also has three motors.

[source,tcl]
----
<<MTR population>>=
class Motor {
    table   {MotorID        R2}\
    mtr1    {MTR_Pump       ct1}\
    mrt2    {MTR_Agitator   ct1}\
    mtr3    {MTR_Spin       ct1}
}
----

Each washing machine, also by design,
has three valves to control hot and cold water and draining.

[source,tcl]
----
<<WV population>>=
class WaterValve {
    table   {ValveID    R3}\
    wv1     {WV_Hot     ct1}\
    wv2     {WV_Cold    ct1}\
    wv3     {WV_Drain   ct1}
}
----

Finally, each washing machine has a sensor that can determine
whether the tub is full or empty.

[source,tcl]
----
<<WLS population>>=
class WaterLevelSensor {
    instance wls1 R5 ct1
}
----

=== Stubbing the External Operations [[stubbing-external-operations]]

External operations invoked by the domain must be resolved.
In this section we stub out those operations with sufficient code
to be able to run our example program.

Normally,
external operation code is supplied outside of the domain specification.
It is typically resolved by code used to bridge one domain to another.
For convenience,
`micca` allows code to be associated with an external operation
and, with the correct options to the code generator,
that code is passed to the output ``C'' file.
This is convenient for testing, demonstration purposes and
running a domain in isolation,
but should _not_ be the primary means of supplying external operation code for
domain.

For the Motor and Valve operations,
we will content ourselves simply to log the fact that they were invoked.
The control that is implied by the operation is ``open loop'' and no
feed back is assumed.
So when we say ``Open a Valve'' we will assume that the value does what
it is told.
This leads us to the following implementation.

[source,tcl]
----
<<external operation>>=
externalop void motorStart {motorid MRT_InstId} {
    MRT_DEBUG("%s: starting motor %u\n", __func__, motorid) ;
}
externalop void motorStop {motorid MRT_InstId} {
    MRT_DEBUG("%s: stopping motor %u\n", __func__, motorid) ;
}
externalop void valveOpen {valveid MRT_InstId} {
    MRT_DEBUG("%s: opening valve %u\n", __func__, valveid) ;
}
externalop void valveClose {valveid MRT_InstId} {
    MRT_DEBUG("%s: closing valve %u\n", __func__, valveid) ;
}
----

The Water Level Sensor operations present a bit more difficulty to stub.
In this case,
there _is_ feedback from the interaction.
We must signal back the state of tub as being full or empty.
So in some sense we must _simulate_ the action of the sensor.
To accomplish simulating the sensor,
we will record data in a variable indexed by the washing machine instance ID.
This will allow us to simulate an arbitrary number of washing machines.
We will delay the announcement of the new state for some time
to simulate the water filling or draining.
To make the example run in reasonable times,
we assume the tub will fill or empty in 3 seconds.
That's quick!

Delivering the indication that the Water Level Sensor has detected
a change in the water level really means we want to send the
appropriate ClothesTub instance either the *TubFull* or *TubEmpty*
event.
So we use a boolean to track the state of the tub, toggling that
state when the sensor is enabled.

[source,tcl]
----
<<external operation>>=
prologue {
    static bool tubFull[WMCTRL_CLOTHESTUB_INSTCOUNT] ;
}
----

The enable of the sensor then complements the state held in our
variable and signals a delayed event to the domain
via the portal interface.
The value of the state variable for the sensor is used to select
which event, Full or Empty, is sent to the Clothes Tub.

[source,tcl]
----
<<external operation>>=
externalop void sensorEnable {tubid MRT_InstId} {
    MRT_DEBUG("%s: enable sensor for tub %u\n", __func__, tubid) ;

    tubFull[tubid] = !tubFull[tubid] ;

    mrt_PortalSignalDelayedEvent(&wmctrl__PORTAL,
        WMCTRL_CLOTHESTUB_CLASSID,
        tubid,
        tubFull[tubid] ?    WMCTRL_CLOTHESTUB_TUBFULL_EVENT :
                            WMCTRL_CLOTHESTUB_TUBEMPTY_EVENT,
        NULL, 0,
        3000) ; // <1>
}
----
<1> Since this an external operation, we will use the bridging portal
of `micca` to signal the event.
The portal functions supplied by the run time provide a convenient
way to access many model level actions inside of a domain.

To disable the sensor, we just cancel the delayed event.
Given that the state activities disable the sensor after it
has signaled it state, canceling the event usually results in
no real operation.

[source,tcl]
----
<<external operation>>=
externalop void sensorDisable {tubid MRT_InstId} {
    MRT_DEBUG("%s: disable sensor for tub %u\n", __func__, tubid) ;

    mrt_PortalCancelDelayedEvent(&wmctrl__PORTAL,
        WMCTRL_CLOTHESTUB_CLASSID,
        tubid,
        tubFull[tubid] ? WMCTRL_CLOTHESTUB_TUBFULL_EVENT :
                         WMCTRL_CLOTHESTUB_TUBEMPTY_EVENT) ;
}
----

=== Running the Example [[running-the-example]]

Before we can start the example running,
we explain how we are going to stop it.
To dispatch state machine events we must
*enter the event loop*.
The event loop is provided by the run time code and is how events
are signaled and dispatched.
We will invoke the `mrt_EventLoop` function to do that.
But we need some way to break out of the event loop
so that we can stop the example run.
To do that, somewhere we must invoke the `mrt_SyncToEventLoop` function.

We will invoke `mrt_SyncToEventLoop` in the external operation
*cycleComplete*.
This operation is invoked when the cycle is done
and it is our intent to regain control of the execution flow after
each washing cycle.
Note that we are implementing the external operation in this manner solely to
be able to run one washing cycle in our example and gain control after that
cycle has completed.
An actual application would most likely run forever or invoke
`exit` based on some other condition or circumstance.

[source,tcl]
----
<<external operation>>=
externalop void cycleComplete {washerid MRT_InstId} {
    MRT_DEBUG("%s: cycle complete for washer %u\n", __func__, washerid) ;
    /*
     * Exit the event loop for the purposes of the example.  This call is used
     * to cause the event loop to exit. This means that we will only run one
     * cycle of the washer before the program exits the event loop and then
     * terminates.
     */
    mrt_SyncToEventLoop() ;
}
----

Finally, yes truly finally,
we are in a position to run the washer through the cycle.
This is done by supplying a `main` program.
The domain initialization done by `wmctrl_init` signals all the
initial instances (one in our case) to start.
After that, the event loop gains control and the execution sequencing
begins.

[source,tcl]
----
<<main program>>=
int
main(
    int argc,
    char *argv[])
{
    mrt_Initialize() ; // <1>
    wmctrl_init() ;
    mrt_EventLoop() ;

    return EXIT_SUCCESS ;
}
----
<1> The run time must be initialized before initializing the domain since
the domain initialization code signals an event.
System initialization that does not use run time facilities, _e.g._
hardware initialization, may be done before initializing the run time.

=== Example Program

The example program must be generated by running `micca`.
Normally,
this would be done using the `micca` program.
Here we are doing it using a Tcl script as this is more convenient
during the development of `micca` itself.

[source,tcl]
----
<<build_wmctrl.tcl>>=
source ../../tcl/micca.tcl
micca configureFromFile wmctrl.micca
micca configureFromFile wmctrl_pop.micca
micca generate stubexternalops true ; # <1>
----
<1> This option insures that the code we supplied to stub the external
operations is passed along to the resulting ``C'' output file.

=== Example Run Results

After running the example we obtain the following output.

[literal]
.Output From Running the Example
--
include::wmctrl-trace.txt[]
--

The trace consists of the chronological trace of the state machine event
dispatch.
The first column of the event dispatch
trace is the time of day down to microseconds.
The remainder of the trace show the details of the event dispatch.
A _Transition_ trace shows the event being
dispatched from a source instance to a target instance.
(The output here is reminiscent of the `transition` statements of
the state model specification.
The transition of the target instance,
from current state to new state,
is shown in the second portion of the trace output using the ``==>'' symbol.
Instances are shown in the form of _class.instance_ if such naming
information is known.
For events originating outside of a state activity,
the instance is shown as ``?.?''.
For instances that have no naming information (_i.e._ they were created
dynamically), then the instance id number is shown.
