// vim:set syntax=asciidoc:

= Configuring a Domain

[partintro]
--
In the last part of the book,
we showed the platform specific model that `micca` uses.
To translate a domain it is necessary to populate the platform
specific model with the specific characteristics of the domain to be translated.
Since the platform model is implemented in `rosea`,
we could populate it using the `rosea populate` command.
This would be a difficult and tedious way to populate the platform
model for a human.
It might be perfectly acceptable to create a `rosea` population
programmatically, but it requires detailed knowledge of the platform model.
We will provide a much more convenient interface for humans by using
a domain specific language (DSL).

The DSL in this case is also a Tcl script and we will build the
DSL processing directly into the `micca` domain.
We will use the Tcl interpreter to parse the DSL.
The code that reads the DSL arranges for the script to be executed in
a context where command names resolve to procedures that populate the
`micca` platform specific model.

In this part,
we describe the commands that make up the DSL used to populate the
platform model.
--

== Configuration Commands

Configuring a domain in `micca` happens as a domain operation.
When we parse the various portions of a domain description,
we will use namespaces to confine the script execution and to expose
the appropriate commands to the configuration scripts.
This requires us to define child namespaces for the `micca` domain.
We must use some care in this because a `rosea` domain already has some
child namespaces defined on it. We will use a naming convention to
avoid any possible naming collisions.

The configuration script is a Tcl script and the full resources of
Tcl are available.
In particular, the `source` command is useful for organizing
configuration scripts into smaller pieces that can be included,
using the `source` command, into a configuration.

In this part,
we first present the commands that are used to configure a domain under
`micca`.
These will be domain operations of the `micca` domain.
Afterwards,
we will define further child namespaces and commands within them that
accomplish gathering all the information needed to define the characteristics
of a domain.

=== Configure

One of our top level +micca+ commands is to configure a domain from
a script.

*****
+::micca configure+ _script_

+script+::
    A Tcl script that is executed in an environment that will resolve
    _domain configuration_ commands that may be used to define
    the characteristics of a domain to be translated by `micca`.
*****

[float]
==== Implementation

(((micca,operation,configure)))
[source,tcl]
----
<<micca configuration>>=
operation configure {script} {
    return [@Config@::miccaConfigure $script]
}
----

=== ConfigureFromChan

It is often convenient to obtain the +configure+ script from an I/O channel.
The +micca configureFromChan+ command supports reading the configure
script directly from a channel.

*****
+::micca configureFromChan+ _channel_

+channel+::
    A Tcl channel handle that has been opened for reading.

The `configureFromChan` command invokes `configure` on the script
obtained by reading _channel_ until end of file is reached.
*****

[float]
==== Implementation

(((micca,operation,configureFromChan)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromChan {chan} {
    return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
}
----

=== ConfigureFromFile

It is often convenient to hold the +configure+ script in a file.
The +micca configureFromFile+ command supports reading the configure
script directly from a file.

*****
+::micca configureFromFile+ _filename_

+filename+::
    The name of a file containing a domain configuration script.

The `configureFromFile` command invokes `configure` on the script
obtained by reading the contents of the file named, _filename_.
*****

[float]
==== Implementation

(((micca,operation,configureFromFile)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromFile {filename} {
    set chan [::open $filename r]
    try {
        return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
    } finally {
        ::chan close $chan
    }
}
----

== Configuration Namespace Layout

The +::micca::@Config@+ namespace holds all the procedures and data that
correspond to the DSL to populate the platform model.
We will create a set of child namespaces that mirror the nesting of the
configuration language statements.
At the top level,
the +domain+ command is used to define each domain.
The +domain+ command accepts a script body that then defines the
components of the domain.
That script will be evaluated in a namespace where the commands that
define the domain components, _e.g._ `class` and relationship commands,
resolve appropriately.
This lets us put commands for the body specifying a particular component into a
namespace which prevents any problems of accidentally invoking commands that
are inappropriate for that context.

We will use this technique for other child namespaces that correspond to
the nesting of DSL statements.
We layout the +::micca::@Config@+ namespace as shown below.

[source,tcl]
----
<<configuration commands namespace>>=
namespace eval @Config@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    <<helper commands namespace>>

    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds} ; # <1>
    <<config data>>
    <<config commands>>

    <<domain config namespace layout>>
    <<population config namespace layout>>
}
----
<1> We are evaluating the configuration DSL inside a child namespace of
of the `micca` domain, but we are trying to populate `micca` classes.
We find it convenient to resolve commands through the main `micca` namespace
as well as others that help things along.

=== Evaluating Configuration Scripts

The top level domain operations of `micca` that configure domains
all invoke `miccaConfigure` as the common entry point into the configuration
DSL code.

[float]
==== Implementation

(((micca,Config,miccaConfigure)))
[source,tcl]
----
<<config commands>>=
proc miccaConfigure {script} {
    variable errcount
    set errcount 0

    variable configlineno
    set configlineno 1

    ConfigEvaluate [namespace current] $script

    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
CONFIG_ERRORS     {encountered %d configuration script errors}
----

You could evaluate the configuration script by simply gathering it together
and passing it to the core `namespace eval` command.
Unfortunately,
the first error that is encountered will terminate the evaluation.
This is decidedly inconvenient as you would prefer to continue on and
come up with a list of errors for the evaluation much like a
conventional language compiler does when compiling a source file.
Discovering errors one at a time is tediously unproductive.

Of course, it is possible to continue evaluating after an error but
that requires a bit more code.
We will also want to be able to evaluate scripts in different namespace
contexts as we described above.
We will accomplish all this by taking advantage of the core +::apply+ command
and its ability to execute a lambda function in a given namespace.
So given a script body and an namespace we can evaluate it as shown below.

(((micca,Config,ConfigEvaluate)))
[source,tcl]
----
<<config commands>>=
namespace export ConfigEvaluate

proc ConfigEvaluate {ns body} {
    variable evalLambda
    tailcall ::apply [concat $evalLambda [list $ns]] $body ; # <1>
}
----
<1> The `concat` command treats its arguments as a list.
On the off chance that the `ns` argument contains embedded whitespace,
we need to insure that it is treated as a single element list.
Hence the need to include the invocation of the `list` command.

The lambda function that performs the command evaluation is given below.
We hold the evaluation lambda as a piece of data.

[source,tcl]
----
<<config data>>=
variable evalLambda {{body} {
    upvar #0 ::micca::@Config@::errcount errcount ; # <1>
    upvar #0 ::micca::@Config@::configlineno configlineno
    set lineno $configlineno
    set command {}
    foreach line [split $body \n] { # <2>
        append command $line \n
        incr lineno ; # <3>
        if {[info complete $command]} {
            try {
                eval $command
            } on error {result} {
                puts $::errorInfo
                log::error "line $configlineno:\
                    \"[string trim $command]\":\n\"$result\""
                incr errcount
            }
            set command {} ; # <4>
            set configlineno $lineno
        }
    }
    return $errcount
}}
----
<1> We need to keep track of all the errors encountered and
what line of the script we are currently dealing with.
<2> We split the body along lines and then reassemble the lines
into a complete command. The +info complete+ command tells us when
we have something that has some chance of being a real command.
<3> We need to keep track of where we are in the +body+.
<4> After evaluating a command we begin to assemble another one and
set our location counter to where that command starts.

== Defining a Domain

As we described above,
the domain configuration commands will take the data in their
arguments and store it away.
After we have finished all the configuration scripts,
then the `generate` command is used to produce the ``C'' code and header files.

When configuring a domain,
we will evaluate the configuration script in the +DomainDef+ child namespace.
That namespace will define commands for all the components of the
domain.
We will use a similar arrangement for other nested aspects of
domain definitions.

=== Domain

*****
+domain+ _name_ _body_

+name+::
    The name of the domain. A domain name must be a non-empty string.
    The domain is used as a component for the file name of the generated
    code files, so domain names must be compatible with file name
    path components for the operating platform where `micca` is run.
+body+::
    A Tcl script containing invocation of the domain definition commands
    to specify the details of the domain configuration.

The `domain` command defines a domain named, _name_, and evaluates
_body_ in a context where commands in _body_ may be used to define
the characteristics of a domain.
*****

[float]
==== Implementation

(((micca,Config,domain)))
[source,tcl]
----
<<config commands>>=
proc domain {name body} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name domain
    }

    namespace upvar DomainDef DomainName DomainName ; # <1>
    set DomainName $name

    CheckDuplicate Domain Name $name ; # <2>
    Domain create Name $name

    try {
        ral relvar eval {
            ConfigEvaluate [namespace current]::DomainDef $body

            upvar #0 ::micca::@Config@::errcount errcount

            # We must compute how polymorphic events are inherited down
            # generalization hierarchies.
            <<domain: propagate polymorphic events>>
            <<domain: union subclass semantics>>
        }
    } on error {result opts} {
        # puts $::errorInfo
        HandleConfigError $result
    }
}
----
<1> We place the domain name into a variable in the child namespace where the
context implies that all the components defined are to be part of this domain.
<2> We do not allow the +domain+ command to be invoked more than once.
To configure a domain properly we need to be able to see its entire
definition at once.

(((error code,BAD_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_NAME      {"%s" is not a valid name for a %s}
----

[[post-config-domain]]
After evaluating the domain configuration script,
it is necessary to perform some additional clean up and evaluation.
For now,
we will say that there are semantic evaluations and checks that can only
be done after the entire domain configuration script has been processed.
The reason for this lies mainly with the way the DSL script commands
were defined to make them more convenient to use when translating an XUML model.
Polymorphic events must be dealt with after the domain configuration
is in place.
Again we will discuss this further
<<domain-propagate-polymorphic-events,below>>.

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-1.0 {
    Define an empty domain
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            # A domain may be empty of components.
        }
    }
    readMiccaAttribute Domain Name Name foo
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test domain-1.1 {
    Badly named domain
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain {} {}
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

== Defining Domain Components

In this section we discuss the commands that are used to define
the components of a domain.
Following our established pattern,
we define child namespaces for those domain component commands
that have a nested structure.

We start with the namespace layout for the +DomainDef+ namespace.

[source,tcl]
----
<<domain config namespace layout>>=
namespace eval DomainDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}
    <<domain config commands>>

    # Child namespaces for domain commands with additional structure
    <<class config namespace layout>>
    <<assigner config namespace layout>>
}
----

We see that there are two child namespaces defined with `DomainDef`.
These correspond to commands that have script bodies associated with them.

=== Interface

It is sometimes useful to include additional output in the header file
generated for a domain.
For example,
the domain may define operation parameters that are of a type already
defined in a header file.
That header file needs to be included in the generated header for the
domain.
The `interface` command provides a means to include arbitrary text into
the header file generated for the domain.

*****
`interface` _text_

`text`::
    Arbitrary text to be placed in the output of the generated interface file.

The `interface` command adds the string of the _text_ argument to
the interface file generated for the domain.
*****

[float]
==== Implementation

(((micca,Config,interface)))
[source,tcl]
----
<<domain config commands>>=
proc interface {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Interface $text
}
----

=== Prologue

It is also convenient to be able to include arbitrary text into the
generated code file for a domain.
The `prologue` command includes that text before any of the generated code.

*****
`prologue` _text_

`text`::
    Arbitrary text to be placed in the output code file before any generated
    code.

The `prologue` command adds the string of the _text_ argument to
the generated code file for the domain.
The `prologue` command may be invoked multiple times and the value of
all the _text_ arguments is concatenated in the order encountered.
The accumulated prologue text is emitted into the generated code file
before any `micca` generated code.
*****

[float]
==== Implementation

(((micca,Config,prologue)))
[source,tcl]
----
<<domain config commands>>=
proc prologue {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Prologue $text
}
----

=== Epilogue

The `epilogue` command includes text into the domain code file after
any generated code.
This can be use for small functions defined to handle the particulars
of user defined data types.

*****
`epilogue` _text_

`text`::
    Arbitrary text to be placed in the output code file after any generated
    code.

The `epilogue` command adds the string of the _text_ argument to
the generated code file for the domain.
The `epilogue` command may be invoked multiple times and the value of
all the _text_ arguments is concatenated in the order encountered.
The accumulated epilogue text is emitted into the generated code file
after any `micca` generated code.
*****

[float]
==== Implementation

(((micca,Config,epilogue)))
[source,tcl]
----
<<domain config commands>>=
proc epilogue {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Epilogue $text
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-2.0 {
    Define a domain with a non-empty interface
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            prologue "#include <stdio.h>"
        }
    }
    log::debug [formatMiccaClass Domain]
    string trimright [readMiccaAttribute Domain Prologue Name foo]
} -result {#include <stdio.h>}
----

==== Append To Domain Attribute

The operations for the `interface`, `prologue` and `epilogue` commands
can be factored into common code.

[float]
==== Implementation

(((micca,Config,AppendToDomainAttribute)))
[source,tcl]
----
<<domain config commands>>=
proc AppendToDomainAttribute {domainname attrname text} {
    set domref [Domain findById Name $domainname]
    withAttribute $domref $attrname {
        set value [set $attrname]
        if {$value ne {} && [string index $value end] ne "\n"} {
            append $attrname \n ; # <1>
        }
        append $attrname $text
    }
    return
}
----
<1> We make sure that the text appended to the domain attribute is done
as a line. In case the previous line didn't have a new line in it,
we will add one.
This will prevent any problems where continuing on the same line
could be misinterpreted.

=== Class

The class command is used to define classes and specify their characteristics.

*****
+class+ _name_ _script_

+name+::
    The name of the class. A class name must be a valid ``C'' identifier.
+script+::
    A Tcl script containing invocations of the class definition commands
    to specify the details of the class configuration.

The `class` command defines a class named, _name_, and evaluates _script_
to configure the class.
Class definitions are open ended and extensible.
If the `class` command is invoked on a previously defined class,
then any additional configuration is added to the definition of the class.
*****

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<domain config commands>>=
proc class {name body} {
    variable DomainName ; # <1>

    if {[isEmptyRef [DomainElement findById Domain $DomainName Name $name]]} {# <2>
        DomainElement create Domain $DomainName Name $name
        Class create Domain $DomainName Name $name\
            Number [GenNumber $DomainName Class [list $DomainName]]
        ValueElement create Domain $DomainName Name $name
    }

    namespace upvar ClassDef ClassName ClassName ; # <3>
    set ClassName $name
    ConfigEvaluate [namespace current]::ClassDef $body

    return
}
----
<1> We have arranged for a namespace variable to hold the current
domain context.
This is a convenient way to pass the domain name to where it is needed
by the configuration commands.
<2> We allow the `class` command to be invoked multiple times with the
same name.
This makes extending class definitions (_e.g._ adding a state model to
a class) much easier.
<3> Provide the class name to the body of the class definition script.

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test class-1.0 {
    Define class with a bad name
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class @%x {}
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

=== Association

The +association+ command is used to define both simple and class based
associations depending upon arguments.
In the `association` command we use some syntax conventions to mirror
the UML graphical notation to make the clerical aspects of the
translation easier.

*****
`association` _name_  _?option value ...?_ _source_ _spec_ _target_ ?_script_?

`name`::
    The name of the association. Conventionally, relationships names are of the
    form *R<d>* where _<d>_ is one or more decimal digits but any
    non-empty string which does not start with a tilde (\~) can be used.
`option value ...`::
    Options to the `association` command are given as argument
    option / value pairs:
    Valid options and their values are:
    `-associator` _class_:::
    The `-associator` option defines the association to be
    *class based* and specifies _class_ as the association class.
`source`::
    The name of the class that defines the starting class for a forward
    traversal of the relationship.
`spec`::
    The specifier of the relationship conditionality and multiplicity.
    The _spec_ argument is one of the following strings.
    We allow two forms for some of the specifiers.
    The first form follows UML notation and the second form follows
    TclRAL notation which is patterned after regular expression notation.
        `1--1`:::
            The association is _one to one_.
        `0..1--1` or `?--1`:::
            The association is _at most one to one_.
        `0..1--0..1` or `?--?`:::
            The association is _at most one to at most one_.
        `1..*--1` or `+--1`:::
            The association is _one or more to one_.
        `0..*--1` or `*--1`:::
            The association is _zero or more to one_.
        `1..*--0..1` or `+--?`:::
            The association is _one or more to at most one_.
        `0..*--0..1` or `*--?`:::
            The association is _zero or more to at most one_.
        `1..*--1..*` or `+--+`:::
            The association is _one or more to one or more_.
        `0..*--1..*` or `*--+`:::
            The association is _zero or more to one or more_.
        `1..*--0..*` or `+--*`:::
            The association is _one or more to zero or more_.
        `0..*--0..*` or `*--*`:::
            The association is _zero or more to zero or more_.
`target`::
    The name of the class that defines the ending class for a forward
    traversal of the relationship.
`script`::
    An optional _script_ that is evaluated to define an assigner on the
    association.

The `association` command defines an association relationship between a
_source_ class and a _target_class_.
The forward direction of navigating the relationship is from _source_
to _target_.
The conditionality and multiplicity of the association is given by the
_spec_ argument.
A class based association is indicated by the `-associator` option.
The association command may have an optional _script_ argument that is
used to define an assigner on the association.
*****

In the command,
we are using the _spec_ string to encode several distinct pieces of information.
Each different association specifier implies the conditionality,
multiplicity and other properties of the association.
We encode those properties in data whose identifier is the _spec_ string
itself.

[source,tcl]
----
<<config data>>=
# Since we allow two different techniques to identify the association
# specifics, we will factor away the specification data from its name.
relvar create Config_AssocSpec {
    SpecName    string
    SpecID      string
} SpecName

relvar create Config_SpecDetail {
    SpecID              string
    NeedsAssociator     boolean
    ReflexiveAllowed    boolean
    ReferringCond       boolean
    ReferringMult       boolean
    ReferencedCond      boolean
    ReferencedMult      boolean
} SpecID

relvar association C1\
    Config_AssocSpec SpecID +\
    Config_SpecDetail SpecID 1

relvar eval {
    relvar insert Config_AssocSpec {
        SpecName    1--1
        SpecID      sp0
    } {
        SpecName    0..1--1
        SpecID      sp1
    } {
        SpecName    ?--1
        SpecID      sp1
    } {
        SpecName    0..1--0..1
        SpecID      sp2
    } {
        SpecName    ?--?
        SpecID      sp2
    } {
        SpecName    1..*--1
        SpecID      sp3
    } {
        SpecName    +--1
        SpecID      sp3
    } {
        SpecName    0..*--1
        SpecID      sp4
    } {
        SpecName    *--1
        SpecID      sp4
    } {
        SpecName    1..*--0..1
        SpecID      sp5
    } {
        SpecName    +--?
        SpecID      sp5
    } {
        SpecName    0..*--0..1
        SpecID      sp6
    } {
        SpecName    *--?
        SpecID      sp6
    } {
        SpecName    1..*--1..*
        SpecID      sp7
    } {
        SpecName    +--+
        SpecID      sp7
    } {
        SpecName    0..*--1..*
        SpecID      sp8
    } {
        SpecName    *--+
        SpecID      sp8
    } {
        SpecName    1..*--0..*
        SpecID      sp9
    } {
        SpecName    +--*
        SpecID      sp9
    } {
        SpecName    0..*--0..*
        SpecID      sp10
    } {
        SpecName    *--*
        SpecID      sp10
    }

    relvar insert Config_SpecDetail {
        SpecID sp0  NeedsAssociator false ReflexiveAllowed true
            ReferringCond false ReferringMult false
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp1 NeedsAssociator false ReflexiveAllowed false
            ReferringCond true ReferringMult false
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp2 NeedsAssociator false ReflexiveAllowed true
            ReferringCond true ReferringMult false
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp3 NeedsAssociator false ReflexiveAllowed true
            ReferringCond false ReferringMult true
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp4 NeedsAssociator false ReflexiveAllowed false
            ReferringCond true ReferringMult true
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp5 NeedsAssociator false ReflexiveAllowed false
            ReferringCond false ReferringMult true
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp6 NeedsAssociator false ReflexiveAllowed true
            ReferringCond true ReferringMult true
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp7 NeedsAssociator true ReflexiveAllowed true
            ReferringCond false ReferringMult true
            ReferencedCond false ReferencedMult true
    } {
        SpecID sp8 NeedsAssociator true ReflexiveAllowed false
            ReferringCond true ReferringMult true
            ReferencedCond false ReferencedMult true
    } {
        SpecID sp9 NeedsAssociator true ReflexiveAllowed false
            ReferringCond false ReferringMult true
            ReferencedCond true ReferencedMult true
    } {
        SpecID sp10 NeedsAssociator true ReflexiveAllowed true
            ReferringCond true ReferringMult true
            ReferencedCond true ReferencedMult true
    }
}
----

[float]
===== Implementation

Like most of the commands in the configuration language,
the bulk of the code is involved with populating the relvars
holding the essential data provided in the command arguments.
For the `association` command,
there is some argument parsing to determine whether the association
is simple or class based.
Then it is a matter of filling in the correct information based on the
type of the association.

(((micca,Config,association)))
[source,tcl]
----
<<domain config commands>>=
proc association {name args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME association
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    if {[llength $args] < 3} {
        tailcall DeclError ASSOC_OPTIONS $args
    }

    set associator {}
    while {1} {
        set arg [lindex $args 0]

        if {$arg eq "-associator"} {
            set associator [lindex $args 1]
            set args [lrange $args 2 end]
        } elseif {$arg eq "--"} {
            break
            set args [lrange $args 1 end]
        } else {
            break
        }
    }
    if {[llength $args] < 3 || [llength $args] > 4} {
        tailcall DeclError ASSOC_OPTIONS $args
    }
    lassign $args source spec target script

    # Obtain references to the domain name
    variable DomainName

    <<association: check arguments>>

    # Many relvars have tuples with the same heading, so we construct it
    # once here.
    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple

    # Populate the data for a Relationship and Association since that
    # is what this command defines.
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Association create {*}$reltuple

    # Populate the type of association we are dealing with.
    if {$associator eq {}} {
        <<association: populate simple association>>
    } else {
        <<association: populate class based association>>
    }

    if {$script ne {}} {
        namespace upvar ClassDef ClassName ClassName
        set ClassName $name

        namespace upvar AssignerDef IdClassName IdClassName
        set IdClassName {}

        ConfigEvaluate [namespace current]::AssignerDef $script
    }

    return
}
----

(((error code,TILDE_NAME)))
(((error code,ASSOC_OPTIONS)))
[source,tcl]
----
<<error code formats>>=
TILDE_NAME {names beginning with the tilde character are not allowed\
    in this context, "%s"}
ASSOC_OPTIONS {association options error, expected\
    "?-associator <class>? source spec target ?script?", got "%s"}
----

Here we use the data that we supplied above to make sure the
`spec` association specifier and the supplied arguments make sense together.
Certain forms of reflexiveness are not allowed and certain specifiers
imply that you must define a class based association.
Such rules are easier to express in data rather than long sequences
of checking code.

[source,tcl]
----
<<association: check arguments>>=
set csd [pipe {
    relvar restrictone ::micca::@Config@::Config_AssocSpec SpecName $spec |
    relation semijoin ~ [relvar set ::micca::@Config@::Config_SpecDetail]
}]
if {[relation isempty $csd]} {
    tailcall DeclError BAD_RELATIONSHIP_SPEC $spec
}
relation assign $csd
if {$NeedsAssociator && $associator eq {}} {
    tailcall DeclError NEED_ASSOCIATOR $spec
}
if {$source eq $target && !$ReflexiveAllowed} {
    tailcall DeclError REFLEXIVE_NOT_ALLOWED $spec
}
----

(((error code,BAD_RELATIONSHIP_SPEC)))
(((error code,NEED_ASSOCIATOR)))
(((error code, REFLEXIVE_NOT_ALLOWED)))
[source,tcl]
----
<<error code formats>>=
BAD_RELATIONSHIP_SPEC  {bad relationship specifier, "%s"}
NEED_ASSOCIATOR {relationship of type, "%s", requires associative class}
REFLEXIVE_NOT_ALLOWED   {associations of type, "%s", cannot be reflexive}
----

For simple associations,
the `association` command arguments supply what we need and we
perform a series of inserts into the platform data model.

[source,tcl]
----
<<association: populate simple association>>=
SimpleAssociation create {*}$reltuple

SimpleReferringClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source\
    Conditionality  $ReferringCond\
    Multiplicity    $ReferringMult
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
ClassRole create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
DirectionalReference create\
    Domain          $DomainName\
    Class           $source\
    Name            $name\
    Role            source
AssociationReference create\
    Domain          $DomainName\
    Class           $source\
    Name            $name
Reference create\
    Domain          $DomainName\
    Class           $source\
    Name            $name
ClassComponent create\
    Domain          $DomainName\
    Class           $source\
    Name            $name

SimpleReferencedClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target\
    Conditionality  $ReferencedCond
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
ClassRole create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
DirectionalReference create\
    Domain          $DomainName\
    Class           $target\
    Name            $name\
    Role            target
if {$source ne $target} {
    AssociationReference create\
        Domain          $DomainName\
        Class           $target\
        Name            $name
    Reference create\
        Domain          $DomainName\
        Class           $target\
        Name            $name
    ClassComponent create\
        Domain          $DomainName\
        Class           $target\
        Name            $name
}
----

For class based associations we have a few more class instances to create
as we populate that branch of the `micca` platform model.

[source,tcl]
----
<<association: populate class based association>>=
ClassBasedAssociation create {*}$reltuple

SourceClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source\
    Conditionality  $ReferringCond\
    Multiplicity    $ReferringMult
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
ClassRole create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
DirectionalReference create\
    Domain          $DomainName\
    Class           $source\
    Name            $name\
    Role            source
AssociationReference create\
    Domain          $DomainName\
    Class           $source\
    Name            $name
Reference create\
    Domain          $DomainName\
    Class           $source\
    Name            $name
ClassComponent create\
    Domain          $DomainName\
    Class           $source\
    Name            $name

TargetClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target\
    Conditionality  $ReferencedCond\
    Multiplicity    $ReferencedMult
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
ClassRole create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
DirectionalReference create\
    Domain          $DomainName\
    Class           $target\
    Name            $name\
    Role            target
if {$source ne $target} {
    AssociationReference create\
        Domain          $DomainName\
        Class           $target\
        Name            $name
    Reference create\
        Domain          $DomainName\
        Class           $target\
        Name            $name
    ClassComponent create\
        Domain          $DomainName\
        Class           $target\
        Name            $name
}

AssociatorClass create\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator
ClassRole create\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator
AssociatorReference create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
Reference create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
ClassComponent create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test association-1.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class x {
                attribute a1 string
                attribute a2 string
            }
            class y {
                attribute a1 string
            }
            association R10 y 1--1 x
        }
    }
    log::debug [formatMiccaClass SimpleAssociation]
    log::debug [formatMiccaClass SimpleReferringClass]
    log::debug [formatMiccaClass SimpleReferencedClass]
    testConditions\
        {[refMultiplicity [SimpleAssociation findAll]] == 1}\
        {[refMultiplicity [SimpleReferringClass findAll]] == 1}\
        {[refMultiplicity [SimpleReferencedClass findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test association-2.0 {
    Define class based association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class a {
                attribute a1 string
            }
            class e {
                attribute a1 string
                attribute a2 string
            }
            class f {
                attribute a1 string
            }
            association R11 -associator a f 1..*--1..* e
        }
    }
    log::debug [formatMiccaClass AssociatorClass]
    log::debug [formatMiccaClass AssociatorReference]
    log::debug [formatMiccaClass SourceClass]
    log::debug [formatMiccaClass TargetClass]
    testConditions\
        {[refMultiplicity [AssociatorClass findAll]] == 1}\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [SourceClass findAll]] == 1}\
        {[refMultiplicity [TargetClass findAll]] == 1}
} -result {1}
----

=== Generalization

Defining a generalization relationship is quite a bit simpler than
the effort we just saw in defining associations.
For generalizations,
it is necessary to specify the superclass and the set of subclasses.
The only complexity is that `micca` allows two choices for how to
store subclasses of a generalization.
The simplest is to use references to store the relationship pointers
in much the same manner as used for associations.
Because of the nature of a generalization relationship,
the other possibility is to store the subclass as a discriminated union.
The alternatives are specified as options to the generalization command.

*****
`generalization` _name_ _?-union | -reference?_ _super_ _sub1_ _sub2_ _?...?_

`name`::
    The name of the generalization. Conventionally, relationships names are of
    the form *R<d>* where _<d>_ is one or more decimal digits but any non-empty
    string can be used.
`-union | -reference`::
    An option to specify if subclasses of the generalization are to be
    held as a discriminated union in the same structure as the superclass
    or held in separate storage having the relationship navigation implemented
    using reference pointers.
    If no option is given, the `-reference` is assumed.
`super`::
    The name of the class that serves as the superclass of the generalization.
`subN`::
    The names of the classes that serve as the subclasses of the generalization.
    You must specify at least two subclasses to define a generalization.
*****

[float]
==== Implementation

(((micca,Config,generalization)))
[source,tcl]
----
<<domain config commands>>=
proc generalization {name args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME generalization
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    set type reference
    while {1} {
        set args [lassign $args arg]

        if {$arg eq "-reference"} {
            set type reference
        } elseif {$arg eq "-union"} {
            set type union
        } else {
            set super $arg
            break
        }
    }

    if {[llength $args] < 2} {
        tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
    }
    if {$super in $args} {
        tailcall DeclError SUPER_AS_SUBCLASS $super [join $args {, }]
    }
    if {[llength [lsort -unique $args]] != [llength $args]} {
        tailcall DeclError DUPLICATE_SUBCLASS $args
    }

    variable DomainName

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]

    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Generalization create {*}$reltuple

    set supertuple [list\
        Domain          $DomainName\
        Class           $super\
        Relationship    $name\
        Role            target\
    ]
    set subtuple [dict create\
        Domain          $DomainName\
        Relationship    $name\
        Role            source\
    ]
    set reftuple [list\
        Domain          $DomainName\
        Class           $super\
        Name            $name
    ]
    if {$type eq "reference"} {
        ReferenceGeneralization create {*}$reltuple
        ReferencedSuperclass create {*}$supertuple
        SubclassReference create {*}$reftuple
        Reference create {*}$reftuple
        ClassComponent create {*}$reftuple
        foreach sub $args {
            dict set subtuple Class $sub
            ReferringSubclass create {*}$subtuple
            dict set reftuple Class $sub
            SuperclassReference create {*}$reftuple
            Reference create {*}$reftuple
            ClassComponent create {*}$reftuple
        }
    } elseif {$type eq "union"} {
        UnionGeneralization create {*}$reltuple
        UnionSuperclass create {*}$supertuple
        SubclassContainer create Domain $DomainName Class $super Name $name ; # <1>
        ClassComponent create Domain $DomainName Class $super Name $name
        foreach sub $args {
            dict set subtuple Class $sub
            UnionSubclass create {*}$subtuple
        }
    }
    Superclass create {*}$supertuple
    ClassRole create {*}$supertuple

    foreach sub $args {
        dict set subtuple Class $sub
        Subclass create {*}$subtuple
        ClassRole create {*}$subtuple
    }

    return
}
----
<1> For union based subclass storage,
we create the container as a class component in the superclass.
This is done here since we have the information and the R96 relationship is
unconditional.
Union superclasses always have a subclass container.

(((error code,TOO_FEW_SUBCLASSES)))
(((error code,SUPER_AS_SUBCLASS)))
(((error code,DUPLICATE_SUBCLASS)))
[source,tcl]
----
<<error code formats>>=
TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
SUPER_AS_SUBCLASS   {super class, "%s", cannot be included in subclasses, "%s"}
DUPLICATE_SUBCLASS  {subclass set contains a duplicate subclass name, "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-1.0 {
    Define reference generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int
            }
            generalization R1 -reference super sub1 sub2
        }
    }
    log::debug [formatMiccaClass ReferenceGeneralization]
    log::debug [formatMiccaClass ReferencedSuperclass]
    log::debug [formatMiccaClass ReferringSubclass]
    testConditions\
        {[refMultiplicity [ReferenceGeneralization findAll]] == 1}\
        {[refMultiplicity [ReferencedSuperclass findAll]] == 1}\
        {[refMultiplicity [ReferringSubclass findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test generalization-2.0 {
    Define union generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class usuper {
                attribute sid int
            }
            class usub1 {
                attribute sid int
            }
            class usub2 {
                attribute sid int
            }
            generalization R2 -union usuper usub1 usub2
        }
    }
    log::debug [formatMiccaClass UnionGeneralization]
    log::debug [formatMiccaClass UnionSuperclass]
    log::debug [formatMiccaClass UnionSubclass]
    log::debug [formatMiccaClass SubclassContainer]
    testConditions\
        {[refMultiplicity [UnionGeneralization findAll]] == 1}\
        {[refMultiplicity [UnionSuperclass findAll]] == 1}\
        {[refMultiplicity [UnionSubclass findAll]] == 2}\
        {[refMultiplicity [SubclassContainer findAll]] == 1}
} -result {1}
----

==== Union Subclass Semantic Checks

The choice to store subclass instances as a union within the class
structure of its superclass has a number of advantages from an implementation
point of view.
But the choice also places restrictions on how subclasses may be treated.
The union subclass is less general than the reference subclass and so
we need to restrict the uses of union subclasses.
In most simple situations where union subclasses are most frequently used,
these restrictions do not apply.
But there are situations where the inclusion of the subclass as part of the
structure of the superclass instance means a certain configuration cannot
be supported.
Here we check the following:

* A union subclass cannot be a subclass of two independent generalizations.
This is just another way of saying that a component of a ``C'' structure
cannot be a component of a different ``C'' structure at the same time.
If a subclass is to be a subclass in multiple generalizations,
only one can be a union subclass and the others must be reference subclasses.
* Creation events cannot be sent to union subclasses.
There is no independent storage for union subclasses as it is contained
in the storage allocated to the superclass.

[source,c]
----
<<domain: union subclass semantics>>=
set multiunions [pipe {
    UnionSubclass findWhere {$Domain eq $name} |
    deRef ~ |
    relation group ~ Relationships Relationship Role |
    relation restrictwith ~ {[relation cardinality $Relationships] > 1}
}]
relation foreach multiunion $multiunions {
    relation assign $multiunion
    log::error "In domain, \"$Domain\", union subclass, \"$Class\",\
        participates in multiple union generalizations,\
        \"[join [relation list $Relationships Relationship] {, }]\":\
        this is not allowed for union subclasses"
    incr errcount
}
----

[source,c]
----
<<domain: union subclass semantics>>=
set unioncreates [pipe {
    UnionSubclass findWhere {$Domain eq $name} |
    findRelated % R47 R40 R41 ~R51 R50 ~R56
} {} |%]
forAllRefs unioncreate $unioncreates {
    assignAttribute $unioncreate
    log::error "In domain, \"$Domain\", union subclass, \"$Model\",\
        accepts creation events: this is not allowed for union subclasses"
    incr errcount
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test union-subclasses-1.0 {
    Union subclass in multiple generalizations
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super1 {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int
            }
            class super2 {
                attribute sid int
            }
            class sub3 {
                attribute sid int
            }
            generalization R1 -union super1 sub1 sub2
            generalization R2 -union super2 sub1 sub3
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test union-subclasses-2.0 {
    Union subclass with creation state
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super1 {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int

                statemodel {
                    state s1 {} {
                    }

                    transition @ - e1 -> s1
                }
            }
            generalization R1 -union super1 sub1 sub2
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

=== Type Alias

*****
`typealias` _name_ _definition_

`name`::
    The name of the type alias.
`definition`::
    A ``C'' typename.

The `typealias` command defines an alias _name_ for a ``C'' typename given
by, _definition_.
Type alias helps map model level type information to ``C'' `typedef` statements
that are included in the generated code.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc typealias {aliasname typename} {
    variable DomainName
    TypeAlias create Domain $DomainName TypeName $aliasname\
        TypeDefinition $typename

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typealias-1.0 {
    Define a type alias
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            typealias rawbyte uint8_t
        }
    }
    log::debug [formatMiccaClass TypeAlias]
    readMiccaAttribute TypeAlias TypeDefinition Domain foo TypeName rawbyte
} -result {uint8_t}
----

=== Domain Operation

The `domainop` command is used to define domain operations.
The set of domain operations defined for a domain constitute the
external callable interface to the domain.
Typically, domain operations are defined to allow other domains
to access major services of the domain.

*****
`domainop` _rettype_ _name_ _parameters_ _body_ ?_comment_?

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the domain operation.
`name`::
    The name of the domain operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the domain operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
`comment`::
    An optional string that is passed along by the code generated to the
    generated header file.
*****

[float]
==== Implementation

(((micca,Config,domainop)))
[source,tcl]
----
<<domain config commands>>=
proc domainop {rettype name parameters body {comment {}}} {
    variable DomainName

    DomainOperation create\
        Domain $DomainName\
        Name $name\
        Body $body\
        ReturnDataType $rettype\
        Comment [string trim $comment]

    set paramtuple [dict create Domain $DomainName Operation $name]
    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName DomainOperationParameter\
                [list $DomainName $name]]
        DomainOperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domainop-1.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }
        }
    }
    log::debug [formatMiccaClass DomainOperation]
    log::debug [formatMiccaClass DomainOperationParameter]
    testConditions\
        {[refMultiplicity [DomainOperation findAll]] == 1}\
        {[refMultiplicity [DomainOperationParameter findAll]] == 2}\
} -result {1}
----

== Defining Class Components

Since there are several aspects of classes,
the +class+ command takes a _script_ argument which should
invoke the commands we discuss in this section.
Following our pattern,
we define a namespace where the class body script is evaluated.

[source,tcl]
----
<<class config namespace layout>>=
namespace eval ClassDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class config commands>>

    <<state model config namespace layout>>
}
----

=== Attribute

Within a class definition,
the `attribute` command specifies the attributes of the class.
In this context,
attributes are a slightly different concept than the attributes
seen on a class diagram.
As part of the translation process,
some attributes found on the XUML class diagram are elided from
the implementation.
For example,
attributes that are used solely for referential or identifying purposes
need not be included as attributes in the implementation.
This is because the translation is using the address of a class
instance as an architecturally supplied identifier and in implementing
relationship traversal.
So the attributes defined here are descriptive in nature and define
the logical parameters of the class rather than the structural aspects
of the class.

*****
`attribute` _name_ _type_ ? `-default` _value_ ?

`name`::
    The name of the attribute. Attributes names may not be the empty string.
`type`::
    The type of the attribute. The _type_ may be any valid ``C'' type name.
`-default` _value_::
    If specified, the `-default` option specifies a default value for the
    attribute. If no value is supplied when a class instance is created
    or populated, then the default value is used.
*****

The implementation of the `attribute` command simply creates tuples
in the relvars to hold the attribute characteristics.

[float]
==== Implementation

(((micca,Config,attribute)))
[source,tcl]
----
<<class config commands>>=
proc attribute {name type args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME attribute
    }
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    Attribute create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name\
        DataType    $type
    ClassComponent create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name

    if {[llength $args] > 2} {
        tailcall DeclError ATTRIBUTE_OPTIONS $args
    } elseif {[llength $args] == 2} {
        lassign $args option defvalue
        if {$option ne "-default"} {
            tailcall DeclError UNKNOWN_OPTION attribute $option
        } else {
            DefaultValue create\
                Domain      $DomainName\
                Class       $ClassName\
                Attribute   $name\
                Value       $defvalue
        }
    }
}
----

(((error code,ARG_FORMAT)))
(((error code,ATTRIBUTE_OPTIONS)))
[source,tcl]
----
<<error code formats>>=
ARG_FORMAT      {options and values must come in pairs, got "%s"}
ATTRIBUTE_OPTIONS {attribute options error, expected "-default <value>",\
            got "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test attribute-1.0 {
    Define class with attributes
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20
            }
            class c2 {
                attribute b1 uint8
                attribute b2 float
            }
        }
    }
    log::debug [formatMiccaClass Attribute]
    log::debug [formatMiccaClass DefaultValue]
    testConditions\
        {[refMultiplicity [Attribute findAll]] == 4}\
        {[refMultiplicity [DefaultValue findAll]] == 1}
} -result {1}
----

=== Polymorphic Events

Polymorphic events are defined in a superclass and when dispatched
to the superclass are mapped into events in the subclass state models.
The `polymorphic` commands defines a polymorphic event and optionally
the signature of event parameters that the event carries.

*****
`polymorphic` _event_ ?_argname argtype_ ...?

`event`::
    The name of an event that will be deemed polymorphic across
    any generalization relationships in which the class participates.

`argname argtype ...`::
    The argument signature of the event. Arguments must be given in
    name / type pairs. Argument names must be ``C'' identifiers and
    argument types must be ``C'' type names.

The `polymorphic` command defines _event_ as being polymorphic with
optional event arguments given by _argname_ / _argtype_ pairs.
Note that the signature of event arguments of a polymorphic event
is inherited down the generalization hierarchy.
If when the polymorphic event is mapped onto a local state machine
any event parameters required by the state must have been defined
using this command.
Unlike a non-polymorphic event which will assume the parameter signature
of a state unless otherwise defined,
polymorphic event parameters must be defined in this command.
*****


[float]
==== Implementation

For a polymorphic event,
we simply create instances of the PolymorphicEvent class and its
related classes.
At the end of a domain configuration script we will find it necessary to
rationalize the polymorphic events and the transition events defined
locally in a state model.

(((micca,Config,polymorphic)))
[source,tcl]
----
<<class config commands>>=
proc polymorphic {name args} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    set psigid [expr {[llength $args] != 0 ?\
            [FindParameterSignature $args] : {}}]

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $name\
    ]
    Event create {*}$eventtuple PSigID $psigid
    DeferredEvent create {*}$eventtuple Number -1
    PolymorphicEvent create {*}$eventtuple

    return
}
----

==== Propagating Polymorphic Events

[[domain-propagate-polymorphic-events]]
<<post-config-domain,Previously>>,
we indicated that polymorphic event rules require that we perform
some other processing once the configuration script for a domain
has been executed.
Now we are prepared to show that processing.
It will be helpful to refer to the Event subsystem of the platform model
above to follow the description.

The `polymorphic` command above inserts the argument event names into the
model classes simply as a deferred event that is polymorphic.
We must resolve two issues.

. For classes that are super classes for generalizations,
we must have corresponding instances of *Deferral Path* for each of the
generalization hierarchies.
. For classes that are sub classes,
they either consume the polymorphic event in a state model or
it continues to be inherited by any sub classes further down the
generalization hierarchy.

To solve the first issue we know that
relationship, *R86*, specifies how a polymorphic event may be propagated along
multiple generalizations when it is signaled to a given superclass.
After the configuration script has been executed,
we will have all the *Superclass* instances and all the *Deferred Event*
instances and can now make up the correlation between them.

Starting with the *Polymorphic Event* class we can navigate *R81* to
find the corresponding *Deferred Event* and then join to the *Superclass*.
This gives the set of paths along which the polymorphic event must
be propagated.

[source,tcl]
----
<<domain: propagate polymorphic events>>=
# Create Deferral Path instances corresponding to polymorphic events

set paths [pipe {
    PolymorphicEvent findWhere {$Domain eq $name} |
    findRelated ~ R81 |
    deRef ~ Domain Model Event |
    relation join ~ [deRef [Superclass findAll]]\
        -using {Domain Domain Model Class}
}]

foreach path [relation body $paths] {
    DeferralPath create {*}$path
}
----

To solve the second issue,
we must walk the generalization hierarchy and determine if events
are being consummed or inherited down the hierarchy.
We want to start the walk only on the ultimate super classes,
_i.e._ those super classes that are 'not' themselves the sub class of
some other generalization.

[source,tcl]
----
<<domain: propagate polymorphic events>>=
forAllRefs super [FindUltimateSuperclasses $name] {
    PropagatePolyEvents $super
}
----

After all the polymorphic events have been rearranged,
we can now number the events.
Deferred Events and Transitioning Events are each numbered separately.
These numbers are used by the code generator to construct array indices.

[source,tcl]
----
<<domain: propagate polymorphic events>>=
DeferredEvent update [pipe {
    DeferredEvent findWhere {$Domain eq $name} |
    deRef ~ |
    relation eliminate ~ Number |
    relation tag ~ Number -ascending Event -within {Domain Model}
}]

TransitioningEvent update [pipe {
    TransitioningEvent findWhere {$Domain eq $name} |
    deRef ~ |
    relation eliminate ~ Number |
    relation tag ~ Number -ascending Event -within {Domain Model}
}]
----

So we find all *Superclass* instances that have no corresponding
*Subclass* role and propagate any polymorphic events down the generalization
hierarchy.

[source,tcl]
----
<<helper commands>>=
proc FindUltimateSuperclasses {domain} {
    set subs [Subclass findWhere {$Domain eq $domain}]
    set supers [Superclass findWhere {$Domain eq $domain}]
    return [pipe {
        relation semiminus [deRef $subs] [deRef $supers]\
            -using {Domain Domain Class Class} |
        ::rosea::Helpers::ToRef ::micca::Superclass ~
    }] ; # <1>
}
----
<1> This is where a little relational algebra can go a long way.
The `semiminus` command finds all the tuples that are *not* related.
In this case we find the Superclass instances that do *not* have a
correspondence to a Subclass instance.
The `semiminus` operation is done only across the same domain and
class, _i.e._ without respect to any relationship.
This yields the Superclass instances that are *not* Subclass
instances of any relationship.

The problem we are trying to solve in the propagation of polymorphic events
arises from the way in which we attempt to minimize the amount
of input from the user when specifying the events.
Recall that the `polymorphic` command simply inserts instances into the
*Polymorphic Event* class (and corresponding instances in *Deferred Event*
and *Event* classes).
Events found when defining a state model are simply created as instances of
the *Local Event* class (and again the corresponding *Transitioning Event* and
*Event* instances).
At the end of the configuration process we can now deduce which events
were inherited down the generalization hierarchy and which were truly
local events.

For sub classes that are leafs of generalization hierarchy,
polymorphic events inherited from the super class are migrated to
be *Mapped Events*.
For sub classes that are intermediate in the hierarchy,
polymorhphic events are migrated to instances of *Inherited Event*.
Both *Inherited Event* and *Mapped Event* are types of *Non-Local Event*
and *R85* insures that they affect only *Subclass* instances.

There are two other twists to be accounted.
It is possible for a mid-level class to consume an inherited polymorphic
event in a state transition.
In that case, the event is no longer available to any subclasses of
the consuming class.
We want to detect if a user mistakenly used an event by the same name
in a subclass state model.
Second,
inherited polymorphic events may not be explicitly consumed in a leaf
subclass.
In this case, the event is subject to the default transition rule for
the state model.
However, we want to warn the user of such events as it may indicate
a problem in specifying the state model (_e.g._ a polymorphic event was
added to a superclass and not accounted for in the subclasses).

The `PropagatePolyEvents` procedure below accomplishes this reclassification
operation.
By doing it this way,
we do not burden the user with all the subtle characteristics
of polymorphic events.
We need only specify which events are polymorphic and which events
cause a state model transition and then we can deduce the intent
to inherit down the generalization hierarchy.
Of course, what is unburdened from the user will be placed upon the
code and in this case there are some subtle twists and turns.

The `PropagatePolyEvents` procedure takes a singular instance reference to a
*Superclass* and tracks the polymorphic event inheritance down the hierarchy.

[[propagate-polyevents,propagate polymorphic events]]
(((micca,Helpers,PropagatePolyEvents)))
[source,tcl]
----
<<config commands>>=
proc PropagatePolyEvents {super} {
    variable errcount
    # Starting at the superclass, find all the subclasses along the
    # generalization.
    set subs [instop $super findSubclasses]

    # Find the events that are deferred by the superclass. These could be
    # either polymorphic events defined in the superclass or inherited events
    # from another generalization.
    set defrdevents [findRelated $super R86 R80]

    # Set up some variables with the superclass attribute values.
    assignAttribute $super {Domain supDomain} {Class supClass}\
        {Relationship supRelationship}

    # Iterate over each subclass of the generalization.
    forAllRefs sub $subs {
        assignAttribute $sub {Domain subDomain} {Class subClass}\
            {Relationship subRelationship} {Role subRole}

        # We need to know if this subclass is also a superclass for another
        # generalization. We find that out by querying the ClassRole for all
        # the other relationships the subclass participates in and then
        # filtering those where it serves as a Superclass.
        set multigens [pipe {
            ClassRole findWhere {$Domain eq $subDomain &&\
                $Class eq $subClass && $Relationship ne $subRelationship} |
            findRelated % {~R40 Superclass}
        } {} |%]

        # Iterate over the deferred events
        forAllRefs defrdevent $defrdevents {
            # We need the event name and argument signature
            assignAttribute $defrdevent {Event event} {PSigID psigid}

            # Check if the event already exists
            set evt [Event findById Domain $subDomain Model $subClass\
                    Event $event]
            if {[isEmptyRef $evt]} {
                <<PropagatePolyEvents: inherit missing deferred event>>
            } else {
                <<PropagatePolyEvents: resolve found deferred event>>
            }
        }
        # Recursively descend any generalization hierarchies repeating the
        # process for them.
        forAllRefs multigen $multigens {
            PropagatePolyEvents $multigen
        }
    }
}
----

If an event has been deferred to a subclass,
then we need to know if a given subclass is a leaf subclass in the
generalization hierarchy or if it is part of a repeated generalization.
A leaf subclass has no generalizations for which it is the superclass.
This tells us if we must consume any inherited events or if they will
be allowed to be inherited further down the hierarchy.
Subclasses that are part of a repeated generation will have
instances of *Superclass* to show their role in that generalization.

[source,tcl]
----
<<PropagatePolyEvents: inherit missing deferred event>>=
if {[isEmptyRef $multigens]} {
    <<PropagatePolyEvents: leaf missing deferred event>>
} else {
    <<PropagatePolyEvents: non-leaf missing deferred event>>
}
----

If an event has been deferred to a leaf subclass and there is no
corresponding defined event for the leaf subclass,
then it must be that the event was never found in a transition statement
or declared in the subclass.
We create a new Mapped Event for it, but also issue a warning.

From the Events subsystem of the platform model,
we can see that creating a Mapped Event requires creating a number of
other related class instances.

[source,tcl]
----
<<PropagatePolyEvents: leaf missing deferred event>>=
Event create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    PSigID $psigid
TransitioningEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Number -1
MappedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    ParentModel $supClass
Non-LocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole

<<PropagatePolyEvents: warn of missing deferred event>>
----

When we warn about the fact that a deferred event was not explicitly
consumed in a state model, we look up the default transition so that
we can say what will happen if the event is ever dispatched to the
subclass.
The analyst will then have to decide if that is acceptable behavior.

[source,tcl]
----
<<PropagatePolyEvents: warn of missing deferred event>>=
set trule [findRelated $sub R40 R41 ~R51 R50 R59]
switch -exact -- [readAttribute $trule Name] {
    IG {
        set phrase "ignoring the event"
    }
    CH {
        set phrase "a system error"
    }
    default {
        set phrase "unknown behavior"
    }
}

log::warn "In domain, \"$subDomain\", class, \"$subClass\", event, \"$event\"\
    is polymorphic across, \"$subRelationship\",\
    and was not consumed in the state model: signalling $event to\
    $subClass or its related superclasses will result in $phrase"
----

When an event is deferred to a subclass that is subject to repeated
generalization,
then the event is inherited down the generalization hierarchy.
Again, creating a Deferred Event requires creating a number of other
class instances.

[source,tcl]
----
<<PropagatePolyEvents: non-leaf missing deferred event>>=
Event create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    PSigID $psigid
DeferredEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Number -1
InheritedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event
Non-LocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole

# Note that we need to provide a Deferral Path for all the generalizations that
# may stem from this subclass.  So we iterate over all the superclass
# relationships this subclass participates in.
forAllRefs multigen $multigens {
    DeferralPath create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        Relationship [readAttribute $multigen Relationship]\
        Role target
}
----

If the deferred event is found to already have been defined,
then there are several cases that must be dealt with.

. The event could be a Local Event that was defined as part of a State Model.
. The event could be inherited from a superclass.
. The event could be polymorphic. This would be the case if a user
redefined an inherited polymorphic event in one of the subclasses of the
generalization.
That is not necessary to do (that is what this code is actually doing),
but neither is it wrong.

We handle these cases, starting with the Local Event.

[source,tcl]
----
<<PropagatePolyEvents: resolve found deferred event>>=
set local [findRelated $evt {~R80 TransitioningEvent} {~R82 LocalEvent}]
if {[isNotEmptyRef $local]} {
    <<PropagatePolyEvents: migrate local event to mapped event>>
} else {
    <<PropagatePolyEvents: migrate inherited event to mapped event>>
}
----

Migrating a Local Event to a Mapped Event implies deleting the
Local Event and creating a new instance of Mapped Event.
*R83* implies that we need to create a new instance of Non-Local Event.

One further concern here is whether this subclass is a leaf subclass.
If it is, then this is just the normal consumption of an inherited
event as a transition in the state model of the subclass.
However,
if the subclass is subject to repeated generalization,
then the event may no longer be inherited by the lower level generalizations.
It is an easy mistake for a user to make,
so we do some checking.

[source,tcl]
----
<<PropagatePolyEvents: migrate local event to mapped event>>=
delete $local
MappedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    ParentModel $supClass
Non-LocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole
updateAttribute $evt PSigID $psigid

<<PropagatePolyEvents: check for non-leaf consumption>>
----

We deem it an error to consume an event at a mid-level subclass and then
have lower level subclasses also handle the event as if it were
inherited to them.
It doesn't make any sense.
The test fundamentally depends upon whether there are any
superclass roles played by this subclass.
We have already computed that and need to test it here.
The added complexity is that we need to find all the subclasses down
all the generalizations that may stem from this subclass.
This is effectively the transitive closure of the generalization
hierarchy.

[source,tcl]
----
<<PropagatePolyEvents: check for non-leaf consumption>>=
if {[isNotEmptyRef $multigens]} {
    <<PropagatePolyEvents: compute subclasses using event>>

    if {[llength $usingevent] != 0} {
        log::error "In domain, \"$subDomain\", class, \"$subClass\",\
            event, \"$event\", is inherited across, \"$subRelationship\"\
            and is consumed in the $subClass state model:\
            yet class(es), \"[join $usingevent {, }]\", assume \"$event\"\
            is deferred to them"
        incr errcount
    }
}
----

To compute the entire set of subclasses that may be contained in
generalizations rooted at the current subclass,
we will build a binary relation that can be used to compute
the transitive closure.
We define a helper procedure that can be called recursively to
descend the generalization hierarchy.
The strategy is to build a relation that is the Cartesian product of
a relation that holds the names of superclasses and one that holds
the names of the subclasses on the next level.
Then, we find superclasses that are immediately related to the subclasses
and recursively compute the binary relation again.
By taking the union of this binary relation at each level in the
generalization,
we have the entire hierarchy and can pass that off to compute the
transitive closure.

[source,tcl]
----
<<helper commands>>=
proc findSubclassesOf {supers} {
    if {[isEmptyRef $supers]} {# <1>
        return [relation create {Super string Sub string}]
    }
    set supnames [pipe {
        deRef $supers |
        relation project ~ Class |
        relation rename ~ Class Super
    }] ; # <2>
    set subclasses [instop $supers findSubclasses] ; # <3>
    set subnames [pipe {
        deRef $subclasses |
        relation project ~ Class |
        relation rename ~ Class Sub
    }] ; # <4>

    set uses [relation times $supnames $subnames]

    set nextsupers [pipe {
        deRef $subclasses |
        relation semijoin ~ [deRef [ClassRole findAll]]\
            -using {Domain Domain Class Class} |
        relation semijoin ~ [deRef [Superclass findAll]] |
        ::rosea::Helpers::ToRef ::micca::Superclass ~
    }] ; # <5>

    return [relation union $uses [findSubclassesOf $nextsupers]] ; # <6>
}
----
<1> Stop if there are no further generalizations.
<2> Superclass names in a relation with one attribute, `Super`.
<3> Find the immediate subclasses.
<4> Subclass names in a relation with one attribute, `Sub`.
<5> Step down the hierarchy to those superclasses that have the same
name as the subclasses.
<6> Recursively descend to the next level and union the results from there.

Given a relation value that has the Superclasses and Subclasses at each
level in a generalization hierarchy,
we can compute the transitive closure of this relation.
The `relation tclose` command computes all possible paths and
we we restrict the result to being just paths from our current subclass.

[source,tcl]
----
<<PropagatePolyEvents: compute subclasses using event>>=
set subsusing [pipe {
    findSubclassesOf $multigens|
    relation tclose ~ |
    relation restrictwith ~ {$Super eq $subClass} |
    relation project ~ Sub |
    relation list ~ Sub
}] ; # <1>
set usingevent [pipe {
    Event findWhere {$Domain eq $subDomain && $Model in $subsusing &&\
            $Event == $event} |
    deRef ~ |
    relation project ~ Model |
    relation list ~ Model
}] ; # <2>
----
<1> We are only interested in the names of the subclasses that are ultimately
related to the current subclass.
That is sufficient for the next query.
<2> We get the names of the subclasses that use the event by querying
the Events to see which ones have Model attributes present in our
list of using subtypes.

If the deferred event was not local,
then two other possiblities exist.
First, it could be inherited.
If so, then for leaf subclasses we want to migrate the event to be a
Mapped Event.
If we aren't at a leaf, then the event passed further down.
The second possibility is that the event is classified as a Polymorphic
Event.
This can happen when a user redeclares an event as Polymorphic
at a mid-level subclass.
It is not necessary to do but it's not wrong.

[source,tcl]
----
<<PropagatePolyEvents: migrate inherited event to mapped event>>=
set inherit [findRelated $evt {~R80 DeferredEvent} {~R81 InheritedEvent}]
if {[isNotEmptyRef $inherit]} {
    <<PropagatePolyEvents: create mapped event at leaf>>
} else {
    <<PropagatePolyEvents: handle superfluous polymorphic event>>
}
----

If we have found an inherited event at a leaf subclass,
we want to migrate it to be a mapped event.

[source,tcl]
----
<<PropagatePolyEvents: create mapped event at leaf>>
if {[isEmptyRef $multigens]} {
    delete $inherit
    MappedEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        ParentModel $supClass
}
----

If we find a superfluous polymorphic event declaration,
we patch things up by simply migrating it to be an Inherited Event
as it would have been if the user had not inserted the extra
polymorphic statement in the configuration.
Also note, that the case were we define a polymorphic event in a
leaf subclass does not arise though this code path.
Because a leaf subclass never plays a Superclass role,
then no Deferral Path instance will be created that is associated with
the Polymorphic Event defined by the leaf subclass.
In other words, the error is detected because referential integrity
checks will fail.

[source,tcl]
----
<<PropagatePolyEvents: handle superfluous polymorphic event>>=
set poly [findRelated $evt {~R80 DeferredEvent} {~R81 PolymorphicEvent}]
if {[isNotEmptyRef $poly] && [isNotEmptyRef $multigens]} {
    delete $poly
    InheritedEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event
    Non-LocalEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        Relationship $subRelationship\
        Role $subRole
}
----

[float]
===== Tests

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.0 {
    Define polymorphic events
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2 a int
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {d int} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {d int} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                }
            }
            generalization R1 S X Y
        }
    }
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 4}\
        {[refMultiplicity [MappedEvent findAll]] == 4}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.1 {
    Define polymorphic events -- inherit across one level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.2 {
    Define polymorphic events -- new event in leaf subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int

                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - e3 -> s2 ; # New local event!
                }
            }
            class Y {
                attribute id int

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            generalization R1 S X Y
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 4}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 4}\
        {[refMultiplicity [LocalEvent findAll]] == 1}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.3 {
    Define polymorphic events -- inject polymorphic event mid-level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                polymorphic e3
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 10}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 8}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.4 {
    Define polymorphic events -- multiple hierarchies
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 S A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 8}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.5 {
    Define polymorphic events -- common subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e3 -> s1
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                }
            }
            generalization R1 S X Y

            class Z {
                attribute zid int
                polymorphic e3
            }
            class A {
                attribute zid int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                }
            }
            generalization R2 Z A X
        }
    }
    log::debug [formatMiccaClass DeferralPath]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 6}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.6 {
    Define polymorphic events -- consume mid level event
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 6}\
        {[refMultiplicity [InheritedEvent findAll]] == 1}\
        {[refMultiplicity [MappedEvent findAll]] == 5}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.7 {
    Define polymorphic events -- compound generalization at mid level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                polymorphic e3
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B

            class C {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e3 -> s1
                }
            }
            class D {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e4 -> s1
                }
            }
            generalization R3 X C D
        }
    }
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 16}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 14}\
        {[refMultiplicity [LocalEvent findAll]] == 1}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.8 {
    polymorphic events -- consume mid level event and use lower down
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # consume e1 here
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # use e1 across R2 -- error
                    transition s1 - e2 -> s1 ; # use e2 across R3 -- error
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1 ; # no e1 used -- correct
                }
            }
            generalization R2 X A B

            class C {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # use e1 across R3 -- error
                    transition s1 - e2 -> s1
                }
            }

            class D {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1 ; # no e1 used -- correct
                }
            }
            generalization R3 A C D
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.9 {
    Define polymorphic event in leaf subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class Y {
                attribute id int
                polymorphic e3
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.10 {
    Define polymorphic events -- superfluous polymorphic definitions
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                polymorphic e2 ; # e2 is inherited along R1 and declared poly here
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

=== Class Operation

A class operation is a body of code that associated to a particular class.
Class operations at the analysis level are rare,
but when translating they are often useful.
For example,
if you wish to implement some search or sort algorithm on the instances
of a class that could be defined as a class operation.
Also operations that summarize information across multiple class
instances are often implemented easiestly using a class operation.

*****
+classop+ _rettype_ _name_ _parameters_ _body_

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the class operation.
`name`::
    The name of the class operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
*****

[float]
==== Implementation

(((micca,Config,classop)))
[source,tcl]
----
<<class config commands>>=
proc classop {rettype name parameters body} {
    DefineOperation false $rettype $name $parameters $body
}
----

=== Instance Operation

An instance operation is a body of code executed on a particular class instance.

*****
+instop+ _rettype_ _name_ _parameters_ _body_

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the instance operation.
`name`::
    The name of the instance operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the instance operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
    The code in _body_ may refer to a variable named `self` which holds
    a reference to the class instance on which the operation was invoked.
*****

[float]
==== Implementation

(((micca,Config,instop)))
[source,tcl]
----
<<class config commands>>=
proc instop {rettype name parameters body} {
    DefineOperation true $rettype $name $parameters $body
}
----

==== Define Operation

Defining class and instance operations is easily factored into
common code.

[float]
==== Implementation

(((micca,Config,DefineOperation)))
[source,tcl]
----
<<class config commands>>=
proc DefineOperation {isinst rettype name parameters body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    Operation create Domain $DomainName Class $ClassName Name $name Body $body\
        ReturnDataType $rettype IsInstance $isinst
    set paramtuple [dict create Domain $DomainName Class $ClassName\
            Operation $name]

    if {$isinst} {
        dict set paramtuple Name self
        dict set paramtuple DataType "struct $ClassName *"
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test classop-1.0 {
    Define a class operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c4 {
                attribute a1 int

                classop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation ReturnDataType Domain foo Class c4 Name color
} -result {float}
----

[source,tcl]
----
<<config command tests>>=
test instop-1.0 {
    Define an instance operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c5 {
                attribute a1 int

                instop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation IsInstance Domain foo Class c5 Name color
} -result {true}
----

=== Constructor

A constructor for a class is another concept that is occasionally useful
in an implementation but not needed at the model level.
When we create class instances, we will insist that a value for every
attribute be supplied.
This will insure that there are no uninitialized attributes.
Sometimes, we will find it convenient to have attribute data types that
are user defined and encapsulated.
It may require a constructor to initialize such encapsulated data types.
Note that constructors do not take arguments and so are not particularly
useful for setting attribute values.

*****
+constructor+ _body_

`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.

The `constructor` command defines a _body_ of code that is executed
when an instance of a class is created.
*****

[float]
==== Implementation

(((micca,Config,constructor)))
[source,tcl]
----
<<class config commands>>=
proc constructor {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName
    Constructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

=== Destructor

By analogy to a constructor,
a class may have a destructor that is called when an instance is deleted.

*****
+destructor+ _body_

`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.

The `destructor` command defines a _body_ of code that is executed
when an instance of a class is deleted.
*****

[float]
==== Implementation

(((micca,Config,destructor)))
[source,tcl]
----
<<class config commands>>=
proc destructor {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName
    Destructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

== Defining Class State Models

State models in XUML are used to specify the sequence of computations
associated with the life cycle of class instances.
All instances of a class have the same behavior,
yet each instance has it own notion of current state and so may progress
through its life cycle independently of any other instance.

Traditionally,
http://en.wikipedia.org/wiki/Moore_machine[Moore]
type state models are used in XUML to define the life cycle behavior.
The other alternative is a
http://en.wikipedia.org/wiki/Mealy_machine[Mealy]
type state model.
They are mathematically equivalent in the sense that any problem that
can be solved by one formulation can also be solved by the other.
Individuals have their preferences over which formulation is better
and we will not indulge in that discussion here.
We only point out that hierarchical state models are _not_
supported in the this translation scheme.
Hierarchical state models are an unnecessary abomination.

As usual, we need a namespace in which to hold the state model definition
commands.

[source,tcl]
----
<<state model config namespace layout>>=
namespace eval StateModelDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<state model config commands>>
}
----

=== Statemodel

The `statemodel` command is used to define a state model for a class
or an assigner.
Both use the same command and support the same commands in the
script body for defining states, events and transitions.

*****
+statemodel+ _body_

+body+::
    A Tcl Script that is evaluated in a context to allow the definition
    of the properties of the class state model.
*****

[float]
==== Implementation

The implementation of the `statemodel` command follows the usual pattern.
We evaluate `body` in the proper context and then
insert the argument data into the proper relvars that are used to
collect the state model specifications.

(((micca,Config,statemodel)))
[source,tcl]
----
<<class config commands>>=
proc statemodel {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    namespace upvar StateModelDef\
        InitialState InitialState\
        DefaultTrans DefaultTrans\
        Terminals Terminals

    set InitialState {}
    set DefaultTrans {}
    set Terminals [list]

    ConfigEvaluate [namespace current]::StateModelDef $body

    if {$DefaultTrans eq {}} {
        set DefaultTrans CH
    }
    StateModel create\
        Domain          $DomainName\
        Model           $ClassName\
        InitialState    $InitialState\
        DefaultTrans    $DefaultTrans
    InstanceStateModel create\
        Domain          $DomainName\
        Class           $ClassName

    foreach terminal $Terminals {
        set sref [State findWhere {$Domain eq $DomainName &&\
                $Model eq $ClassName && $Name eq $terminal}]
        updateAttribute $sref IsTerminal true
    }
}
----

=== State

The `state` command defines code that is executed when the state is entered
and any parameters that are passed in from the event that caused the
transition.

*****
+state+ _name_ _parameters_ _body_

`name`::
    The name of the state. Name must not be the empty string or one of
    the reserved names of *@*, *CH* or *IG*.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
    A list of the formal parameters of the state.
    Parameters are specified in the same manner as for the `::proc` command.
`body`::
    A string containing the code that is executed when the state is
    entered.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
*****

[float]
==== Implementation

(((micca,Config,state)))
[source,tcl]
----
<<state model config commands>>=
proc state {name params body} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME state
    }
    if {$name eq "@" || [isNotEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    variable InitialState

    if {$InitialState eq {}} {
        set InitialState $name
    }

    set psigid [FindParameterSignature $params]
    set stateref [State create\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Activity        [string trim $body]\
        IsTerminal      false\
        PSigID          $psigid\
    ]
    StatePlace create\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Number          [GenNumber $DomainName StatePlace\
                            [list $DomainName $ClassName]]

    if {$psigid ne {}} {
        set asigid [pipe {
            findRelated $stateref R78 |
            readAttribute ~ ASigID
        }]
        StateTransition update [pipe {
            findRelatedWhere $stateref ~R72 {$ASigID eq {}} |
            deRef % ASigID |
            relation update % sttuple {1} {
                tuple update $sttuple ASigID $asigid
            }
        } {} |%]
    }

    return
}
----

(((error code,BAD_STATE_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_STATE_NAME    {"%s" is not a valid state name}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test state-1.0 {
    Define a state with parameters
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 int

                statemodel {
                    transition s1 - e1 -> s2
                    event e1 e int f float

                    state s1 {a int b float} {
                        printf("in state s1\n") ;
                    }
                    state s2 {c int d float} {
                        printf("in state s2\n") ;
                    }

                    state s3 {i char j double} {
                    }
                    event e2 e char f double

                    transition s2 - e2 -> s3
                    transition s3 - e1 -> s1
                }
            }
        }
    }
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    log::debug [formatMiccaClass ParameterSignature]
    log::debug [formatMiccaClass Parameter]
    log::debug [formatMiccaClass ArgumentSignature]
    log::debug [formatMiccaClass Argument]
    testConditions\
        {[refMultiplicity [State findAll]] == 3}\
        {[refMultiplicity [Event findAll]] == 2}\
        {[refMultiplicity [ParameterSignature findAll]] == 5}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test state-2.0 {
    State / event parameter mismatch
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 int

                statemodel {
                    event e1 a float b int

                    transition s1 - e1 -> s1 ; # e1 and s1, different signatures

                    state s1 {a int b float} {
                    }

                    state s2 {a int b float} {
                    }

                    event e2 f int g float
                    transition s1 - e2 -> s2
                    # e2 and s2, same signature, different parameter names

                    transition s2 - e3 -> s1
                    event e3 h char i unsigned ; # e3 and s1, different
                }
            }
        }
    }
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    log::debug [formatMiccaClass ParameterSignature]
    log::debug [formatMiccaClass Parameter]
    log::debug [formatMiccaClass ArgumentSignature]
    log::debug [formatMiccaClass Argument]
} -result {encountered 2 configuration script errors} -returnCodes error
----

=== State Parameters

In XUML,
a state may define a set of parameters that are passed to the activity
of the state when the activity is executed.
Most of the time,
states do not define any parameters and so there is nothing else to
understand about how the parameter passing works.

If a state does define parameters,
then it is a corollary of the Moore machine formulation that
any event that causes a transition into a state with parameters must
carry a matching set of arguments whose values were determined when the
event was signalled.
So if an event causes a transition to different states,
then each state must have the same parameter signature.
Conversely, if different event cause a transition into the same state,
the events must have the same parameter signature.

What determines the matching of event and state parameters is
the position and data type of the parameters.
Specifically,
the parameter names don't matter when we are trying to decide if
the parameters of an event and the parameters of the state into which
the event causes a transition match.
For example an event may view its parameters as `int size, float incr` and a
corresponding state may view its parameters as `int count, float prec`.
In this case the signature of position and type is the same despite the
difference in the parameter naming.
Seen another way, states and events may have a different semantic
view of their parameters as given by the parameter names, but have
matching syntax of parameter position and data type.

In our attempt so minimize the amount of specification of information
in the configuration DSL,
the declaration of events is optional.
Here are the rules:

. An event and its parameters may be declared with the `event` command
and that is the signature it is given.
. A polymorphic event that has parameters must declare them as part
of the `polymorphic` command.
. If there is no event declaration, the event name and signature is
assumed from the state into which the event causes a transition.
Its parameter naming, position and type information is assumed from that
of the state.

The rules outlined in this discussion are not the only possiblity.
It is the one that has been chosen for `micca` as it matches the
function invocation rules of ``C'' while still allowing flexiblity
in parameter name specification.
We deem this approach more consistent with ``C'' implementation concepts
and more flexible than one that is based strictly on parameter names
and the need to declare event parameter signatures.

The helper procedures in this section do the work of setting up parameter
signatures and the underlying argument signatures.
Here is where signature equality is determined.

==== FindParameterSignature

The `FindParameterSignature` procedure searches for an existing parameter
signature that matches the parameter list argument and returns the
parameter signature ID.
If none exists that matches,
it creates a new one and returns the ID of the new one.

[float]
==== Implementation

The tricky part in determining the equality of two parameter signatures
is that we want to find that Parameter Signature where all the
related Parameter instances have the correct values for the parameter
name, position and data type.
The information about position and data type is held in the Argument Signature
and we will cover that next.

Again this is a situation where some relational algebra can come to the
rescue.
In this case we will create a relation value that holds the parameter
name, position and data type.
We then use the `relation group` command to create a relation valued
attribute that groups together the parameter name, position and
data type for the existing instances of Parameter.
Equality can then be determined by the equality of two relations.

(((micca,Helpers,FindParameterSignature)))
[source,tcl]
----
<<helper commands>>=
proc FindParameterSignature {params} {
    if {[dict size $params] == 0} {
        return
    }

    set asigid [FindArgumentSignature $params] ; # <1>
    if {$asigid eq {}} {
        error "panic: did not create an argument signature for \"$params\""
    }

    set poscounter -1
    set parampos [relation create {Name string Position int ASigID string}]
    dict for {pname ptype} $params {
        set parampos [relation insert $parampos [list\
            Name $pname\
            Position [incr poscounter]\
            ASigID $asigid\
        ]]
    } ; # <2>
    set psigref [pipe {
        Parameter findAll | deRef ~ |
        relation group ~ ParamNames Name Position ASigID |
        relation restrictwith ~ {[relation is $ParamNames == $parampos]} |
        relation semijoin ~ [deRef [ParameterSignature findAll]]
        ::rosea::Helpers::ToRef ::micca::ParameterSignature ~
    }] ; # <3>

    if {[isEmptyRef $psigref]} {# <4>
        namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

        set psigid psig[GenNumber $DomainName ParameterSignature\
                [list $DomainName]]
        ParameterSignature create\
            Domain $DomainName\
            PSigID $psigid\
            ASigID $asigid
        set poscounter -1
        dict for {pname ptype} $params {
            Parameter create\
                Domain $DomainName\
                PSigID $psigid\
                Name $pname\
                Position [incr poscounter]\
                ASigID $asigid
        }
    } else {
        set psigid [readAttribute $psigref PSigID]
    }

    return $psigid
}
----
<1> The argument signature encodes the position and data type information.
<2> The heading of this relation matches the attribute names in the
Parameter class.
<3> Step by step:
    . Get all the Parameter instances as a relation value.
    . Group together the Name, Position and ASigID attributes. This leaves
      us with a relation value with the attributes Domain, PSigID and
      ParamNames, where ParamName is relation valued.
    . Find the one matching the information in the parameters argument.
    . Find the corresponding Parameter Signature.
    . Turn it into an instance reference for later use.
<4> If we fail to find a match, then create the Parameter Signature and
Parameter instances. Otherwise, we can return the PSigID value.

==== FindArgumentSignature

To separate parameter names from their position and data type,
we introduce the concept of an Argument Signature.
Here equality is based solely on positions` and data types of the
arguments.
This concept is useful when considering how argument values carried by an
event are transferred to the formal parameter of a state activity.
In that situation,
the names don't matter in ``C'', only order and data type.

[float]
==== Implementation

The implementation here follows the same strategy used for
`FindParameterSignature`.
We create a relation value that contains the Position and DataType information
that corresponds to the parameters.
The grouping and comparing is similar.

[source,tcl]
----
<<helper commands>>=
proc FindArgumentSignature {params} {
    if {[llength $params] == 0} {
        return
    }

    set poscounter -1
    set parampos [dict create]
    dict for {pname ptype} $params {
        dict set parampos [incr poscounter] $ptype
    }
    set argpos [relation fromdict $parampos Position int DataType string] ; # <1>
    set asigref [pipe {
        Argument findAll | deRef ~ |
        relation group ~ ArgPositions Position DataType |
        relation restrictwith ~ {[relation is $ArgPositions == $argpos]} |
        relation semijoin ~ [deRef [ArgumentSignature findAll]] |
        ::rosea::Helpers::ToRef ::micca::ArgumentSignature ~
    }]

    if {[isEmptyRef $asigref]} {
        namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

        set asigid asig[GenNumber $DomainName ArgumentSignature\
                [list $DomainName]]
        ArgumentSignature create\
            Domain  $DomainName\
            ASigID   $asigid
        set poscounter -1
        dict for {pname ptype} $params {
            Argument create\
                Domain      $DomainName\
                ASigID      $asigid\
                Position    [incr poscounter]\
                DataType    $ptype
        }
    } else {
        set asigid [readAttribute $asigref ASigID]
    }

    return $asigid
}
----
<1> Since there are only two attributes in the relation value of position
and data type information, we can use a Tcl `dict` to accumulate the
information and then TclRAL has convenience methods to move between
relation values and Tcl dictionaries.

=== Event

Event definitions are optional,
but in the case of events with parameters may make the parameter set
clearer by declaring the event.

*****
`event` _name_ ?_argname argtype_ ...?

`name`::
    The name of the event.

`argname argtype ...`::
    The argument signature of the event. Arguments must be given in
    name / type pairs. Argument names must be ``C'' identifiers and
    argument types must be ``C'' type names.

The `event` command defines _name_ as being an event with
optional event arguments given by _argname_ / _argtype_ pairs.
*****

[float]
==== Implementation

The implementation does the usual platform class instance creation to
store away the data in the command arguments.
However,
since events may be defined simply by their appearance in a
`transition` command, we need to check if we have already seen the
event.
If we have, then we want to update the parameter signature to match
what was defined in this command.
Further,
if this event causes any state transition where the argument signature
has not already been determined,
then we need to update the StateTransition instances to reflect the
argument signature implied by this event.
This processing is done here to make the order of event and transition
specification arbitrary.

(((micca,Config,event)))
[source,tcl]
----
<<state model config commands>>=
proc event {name args} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set psigid [expr {[llength $args] != 0 ?\
            [FindParameterSignature $args] : {}}]

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $name\
    ]
    set evtref [Event findById {*}$eventtuple]
    if {[isEmptyRef $evtref]} {
        set evtref [Event create {*}$eventtuple PSigID $psigid]
        TransitioningEvent create {*}$eventtuple Number -1
        LocalEvent create {*}$eventtuple
    } else {
        updateAttribute $evtref PSigID $psigid
    }

    if {$psigid ne {}} {
        set asigid [pipe {
            findRelated $evtref R69 |
            readAttribute ~ ASigID
        }] ; # <1>
        StateTransition update [pipe {
            findRelatedWhere $evtref\
                {{~R80 TransitioningEvent} {~R70 TransitionPlace}\
                {~R71 StateTransition}} {$ASigID eq {}} |
            deRef % ASigID |
            relation update % sttuple {1} {
                tuple update $sttuple ASigID $asigid
            }
        } {} |%] ; # <2>
    }
}
----
<1> If we have a parameter signature, then get the corresponding
argument signature.
<2> Update the argument signature for any StateTransition instance where
this event caused a transition and which does not already have a value
for its argument signature.

=== Transition

For Moore type state models,
one can conceive of the mapping of states to events as a transition
matrix with a row for each state and a column for each event.
Each matrix cell has a value of the new state for the transition.
The `transition` command is used to define the values of cells
in the conceptual transition matrix.

*****
+transition+ _source_ `-` _event_ `->` _target_

+source+::
    The name of a state in the state model being defined or the
    special reserved name, `@`.
+event+::
    The name of an event that causes the transition.
+target+::
    The name of a state in the state model being defined or one of the
    special non-transitioning states, `IG` or `CH`.

The `transition` command defines the transition that is to happen
when _event_ is dispatched to a state machine when the current
state is _source_, causing the new state to be _target_.
*****

[float]
==== Implementation

The implementation of the `transition` command consists mainly of
inserting tuples into the event classes using the data from the command
arguments.
Note however, that all the events defined by invoking `transition` are
deemed to be a *LocalEvent*.
This certainly may not be true for classes that are leaf subclass of
a generalization hierarchy.
When the domain configuration is completed we will propagate the
polymorphic events down the generalization hierarchies and in that
process recategorize any inherited events properly.

One other minor concern is dealing with the initial pseudo-state, *@*.
This state is where an instance resides if it has been created
asynchronously.
One may not define the `@` state in a `state` command
(it cannot have an activity)
and the only valid place it can appear is as the `source` state in a
`transition` command.

We also have to handle the argument signature of the transition.
If the new state or the event already has an argument signature
we will use it here when the State Transition is created.

(((micca,Config,transition)))
[source,tcl]
----
<<state model config commands>>=
proc transition {source - event -> target} {
    if {$event eq {}} {
        tailcall DeclError BAD_NAME event
    }
    if {[isNotEmptyRef [TransitionRule findById Name $source]]} {# <1>
        tailcall DeclError BAD_STATE_NAME $name
    }
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    if {$source eq "@"} {
        if {[isNotEmptyRef [TransitionRule findById Name $target]]} {
            tailcall DeclError BAD_CREATION_TARGET $target
        }
        set cstuple [list\
            Domain          $DomainName\
            Model           $ClassName\
            Name            @\
        ]
        # We have to conditionally create the CreationState instance since we
        # can have multiple transition commands that use @ as the source state.
        if {[isEmptyRef [CreationState findById {*}$cstuple]]} {
            CreationState create {*}$cstuple
        }
        if {[isEmptyRef [StatePlace findById {*}$cstuple]]} {
            StatePlace create {*}$cstuple\
                Number [GenNumber $DomainName StatePlace\
                        [list $DomainName $ClassName]]
        }
    }

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $event\
    ]
    set eventref [Event findById {*}$eventtuple]
    if {[isEmptyRef $eventref]} {
        set stateref [State findWhere {$Domain eq $DomainName &&\
            $Model eq $ClassName && $Name eq $target}]
        set psigid [expr {[isNotEmptyRef $stateref] ?\
                [readAttribute $stateref PSigID] : {}}]
        Event create {*}$eventtuple PSigID $psigid
        TransitioningEvent create {*}$eventtuple Number -1
        LocalEvent create {*}$eventtuple
    }

    set transtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        State   $source\
        Event   $event\
    ]
    TransitionPlace create {*}$transtuple

    set trref [TransitionRule findById Name $target]
    if {[isNotEmptyRef $trref]} {
        Non-StateTransition create {*}$transtuple TransRule $target
    } else {
        # Create the state transition instance. If the state or event has
        # already been created, then use the argument signature from them, else
        # just leave it empty. Note we only look for states or events that
        # a non-empty parameter signature.
        
        set asigid {}
        set stateref [State findWhere {$Domain eq $DomainName &&\
            $Model eq $ClassName && $Name eq $target && $PSigID ne {}}]
        if {[isNotEmptyRef $stateref]} {
            set asigid [pipe {
                findRelated $stateref R78 |
                readAttribute ~ ASigID
            }]
        } else {
            set eventref [Event findWhere {$Domain eq $DomainName &&\
                $Model eq $ClassName && $Event eq $event && $PSigID ne {}}]
            if {[isNotEmptyRef $eventref]} {
                set asigid [pipe {
                    findRelated $eventref R69 |
                    readAttribute ~ ASigID
                }]
            }
        }

        set stref [StateTransition create {*}$transtuple\
                NewState $target ASigID $asigid]
    }

    return
}
----
<1> Ignoring a transition out of the pseudo-initial state is not allowed
and any transition out of the pseudo-initial state not mentioned in a
`transition` command will be set to CH anyway. So just don't let
transition out of the pseudo-initial state go anywhere except a real state.

(((error code,BAD_CREATION_TARGET)))
[source,tcl]
----
<<error code formats>>=
BAD_CREATION_TARGET {the target of a creation event must be a state,\
        got "%s"}
----

=== Initialstate

By default,
instances created from classes that have a state model are placed in
the first state that was defined for the model.
The `initialstate` command is used to specify explicitly the inital state
for newly created instances.

*****
+initialstate+ _name_

+name+::
    The name of at state in the state model being defined.
    Instances of the class that are created synchronously using
    the `create` class command will be placed in this state.

The `initialstate` command sets the default state that an instance will be
created in. If no `initialstate` command is encountered in the definition
of a state model, then the first state defined to the state model is used
as the initial state.
*****

[float]
==== Implementation

(((micca,Config,initialstate)))
[source,tcl]
----
<<state model config commands>>=
proc initialstate {name} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME initialstate
    }
    if {$name eq "@" || [isNotEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }
    variable InitialState $name
    return
}
----

=== Defaulttrans

It is customary to write `transition` commands only for outgoing
transition that appear on the state model graphic.
For any entries in transition matrix that are not set by a `transition`
command,
a default value is supplied.
That default is either `IG` or `CH` depending upon the argument to the
`defaulttrans` command.
If no `defaulttrans` command is invoked when a state model is defined,
then the default transition will be `CH`.

*****
+defaulttrans+ _trans_

+trans+::
    Either the string *IG* or *CH*.
    For all transitions not explicitly mentioned in a `transition` command,
    the default transition is defined as _trans_.
    If `defaulttrans` is not invoked during a state model definition
    then the default transition is *CH*.
*****

[float]
==== Implementation

(((micca,Config,defaulttrans)))
[source,tcl]
----
<<state model config commands>>=
proc defaulttrans {name} {
    if {[isEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError EXPECTED_PSEUDO_STATE $name
    }
    variable DefaultTrans $name
    return
}
----

(((error code,EXPECTED_PSEUDO_STATE)))
[source,tcl]
----
<<error code formats>>=
EXPECTED_PSEUDO_STATE    {expected CH or IG, got "%s"}
----

==== Terminal

Terminal states are those where the class instance is deleted after
the state activity is executed.
This allows for asynchronous deletion of class instances.

*****
+terminal+ _?state ...?_

+state+::
    The name of a state in the state model that will be marked as a
    terminal state.
    If a state machine transitions into a terminal state,
    the associated instance is deleted after the state activity is
    executed.
*****

[float]
===== Implementation

(((micca,Config,terminal)))
[source,tcl]
----
<<state model config commands>>=
proc terminal {args} {
    variable Terminals
    ::struct::set add Terminals $args
    return
}
----

== Defining Assigners

The assigner concept is not frequently used in XUML models
but is an essential concept in modeling competitive relationships.
Some associations model competitive behavior such as allocating
resources.
For such situations,
instances of the relationships must be created and deleted,
'i.e.' linked and unlinked,
according to some protocol and in some fashion that serializes
the relationship lifecycle between competing classes.
Lifecycle behavior of associations is accomplished in XUML models by
associating a state model and having the state model
activities insure the proper creation of relationship instances.
Such state models are known as _assigners_.

Note that we associate the assigner with the relationship.
We do *not* require factoring the relationships into a class based association
and then attach the assigner to the associator class.
In `micca`,
the relationship may or may not be class based and if it is the associator class
may or may not have a state model.
The assigner state model is independent of any class and its state model.
It is, after all, a state model to deal with the application semantics
of forming and dissolving the relationship.

Also note that only associative relationships may have an assigner.
Assigners are not meaningful for generalization relationships given
the disjoint union nature of a generalization.

There is a further complication.
Usually,
there is a single state machine associated with the association assigner.
However,
some assigners have more complicated competitive protocols.
In those cases the association may have multiple assigners
that are partitioned by another class.
The archetypal example is that of assigning department store clerks
to customers.
If any clerk can service any customer,
then a single assigner is used to sequence properly the assignment of
available clerks to waiting customers.
If the store policy is that a customer can only be served by a clerk working in
a particular department,
then there will be as many assigners as there are departments and
the identity of the department class serves to identify the assigner instances
needed to insure that clerks, within the department, are not over allocated
and that customers, visiting the department, are not over served by
clerks from the wrong department.
This is the essential concept behind a multiple assigner.

Assigners and multi-assigners fall into the XUML semantics category of
not-that-common but essential to express the proper execution semantics.
As we will see,
the specifications required for assigners is almost the same as that
for ordinary class state models.

Assigners are defined by a script specified as part of an
`association` command.
In this section we show the command that may be executed in that script.
We will need to define a namespace in which the script can be evaluated.

[source,tcl]
----
<<assigner config namespace layout>>=
namespace eval AssignerDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<assigner config commands>>
}
----

=== Assigner State Model

The `statemodel` command for assigners takes the same commands as
that for classes.
Indeed, much of the same code is in common.

*****
+statemodel+ _body_

+body+::
    A Tcl Script that is evaluated in a context to allow the definition
    of the properties of the assigner state model.
*****

[float]
==== Implementation

The difference between assigner state model and class state models is
only in a few class instances and relationships, notably, R50 and R53.

(((micca,Config,statemodel)))
[source,tcl]
----
<<assigner config commands>>=
proc statemodel {body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName AssocName

    namespace upvar ::micca::@Config@::DomainDef::ClassDef::StateModelDef\
        InitialState InitialState\
        DefaultTrans DefaultTrans\
        Terminals Terminals

    set InitialState {}
    set DefaultTrans {}
    set Terminals [list]

    ConfigEvaluate ::micca::@Config@::DomainDef::ClassDef::StateModelDef $body ; # <1>

    if {$DefaultTrans eq {}} {
        set DefaultTrans CH
    }
    StateModel create\
        Domain          $DomainName\
        Model           $AssocName\
        InitialState    $InitialState\
        DefaultTrans    $DefaultTrans

    set assoctuple [list\
        Domain          $DomainName\
        Association     $AssocName
    ]
    AssignerStateModel create {*}$assoctuple

    variable IdClassName
    if {$IdClassName eq {}} {
        SingleAssigner create {*}$assoctuple
    } else {
        MultipleAssigner create {*}$assoctuple Class $IdClassName
        ValueElement create Domain $DomainName Name $AssocName
    }

    foreach terminal $Terminals {
        set sref [State findWhere Domain $DomainName Model $ClassName\
                Name $terminal]
        updateAttribute $sref IsFinal true
    }
}
----
<1> We evaluate the assigner state model script in the same namespace as for
the class state models.
Other than setting up a few variables differently,
the configuration data for assigners is the same as for classes.

=== Identify By Class

For multiple assigners we need to specify which class serves to partition
the assigners into multiple instances.
Defining such a class signifies that the assigner is to be multiple rather
than singular.

*****
`identifyby` _class_

`class`::
    The name of a class that serves to partition the instances of a multiple
    assigner.

The `identifyby` command defines an assigner to be a multiple assigner and
specifies _class_ as the partitioning class.
*****

[float]
==== Implementation

(((micca,Config,identifyby)))
[source,tcl]
----
<<assigner config commands>>=
proc identifyby {class} {
    variable IdClassName $class
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test assigner-1.0 {
    Define a single assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
            }
            class client {
            }
            association R1 clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
        }
    }
    log::debug [formatMiccaClass AssignerStateModel]
    log::debug [formatMiccaClass SingleAssigner]
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    testConditions\
        {[refMultiplicity [AssignerStateModel findAll]] == 1}\
        {[refMultiplicity [SingleAssigner findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test assigner-1.1 {
    Define a multiple assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
            }
            class client {
            }
            association R1 clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {
            }
            association R2 department 1..*--1 clerk
        }
    }
    log::debug [formatMiccaClass AssignerStateModel]
    log::debug [formatMiccaClass MultipleAssigner]
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    testConditions\
        {[refMultiplicity [AssignerStateModel findAll]] == 1}\
        {[refMultiplicity [MultipleAssigner findAll]] == 1}
} -result {1}
----

== Populating a Domain

At this point we have covered all the commands that are used to
define the configuration of a domain.
We now turn our attention to specifying an initial instance population.
The initial instances of a domain are those class (and assigner) instances
that will exist when the domain start running.

For many systems, particularly small embedded systems,
much of the class instance data can be specified as part of the initial
instance population.
This has a substantial benefit to the implementation.
Since class data is held in ``C'' arrays, initial instances can be
specified as initializers for those class storage arrays.
The ``C'' language then guarantees that initializer values are in
place before `main` begins execution.
This usually requires much less memory space than having initialiation code to
create the initial instances and that code is executed only once.

In our population scheme, we allow for several populations to be defined
for a domain.
In practice,
development of a domain will usually entail creating multiple populations
for both testing and deployment.
Populations can be managed by keeping them in separate files and then
assembling the domain using Tcl `source` commands.

Following our usual pattern,
we define a namespace in which to evaluate the population commands.

[source,tcl]
----
<<population config namespace layout>>=
namespace eval PopDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<population config commands>>

    <<class instance config namespace layout>>
    <<assigner instance config namespace layout>>
}
----

=== Population

The `population` command gives a collection of class component values a
name.
The complete domain population must be given by the invocation of `population`.

*****
`population` _name_ _domain_ _script_

`name`::
    The name of the population.
`domain`::
    The name of the domain to which the population applies.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of initial instance values for a domain.

The `population` command is used to define initial instance values for
the classes and assigners in _domain_.
*****

[float]
==== Implementation

(((micca,Config,population)))
[source,tcl]
----
<<config commands>>=
proc population {name domain script} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name population
    }

    variable errcount

    if {$errcount != 0} {
        error "cannot populate with configuration errors"
    }

    namespace upvar PopDef PopulationName PopulationName DomainName DomainName
    set PopulationName $name
    set DomainName $domain

    set popref [Population create Name $name Domain $DomainName]

    try {
        ral relvar eval {
            ConfigEvaluate [namespace current]::PopDef $script
        }
    } on error {result} {
        puts $::errorInfo
        HandleConfigError $result
        return
    }

    # At this point the population is complete and we can begin the processing
    # to validate that the population is correct.

    # First, we need the set of class component values and class instances that
    # are part of the population of this domain.
    set popvalues [pipe {
        ClassComponentValue findWhere {
            $Population eq $name && $Domain eq $domain} |
        deRef ~
    }]
    # puts [relformat $popvalues popvalues]
    set popinsts [pipe {
        ClassInstance findWhere {$Population eq $name && $Domain eq $domain} |
        deRef ~
    }]
    # puts [relformat $popinsts popinsts]

    <<population: check completeness>>
    <<population: check class populations>>
    <<population: check reference values>>
}
----

==== Validating a Population

Once a population has been gather by the `population` command,
we perform some validation on the population to make sure it
is correct and we will be able to proceed to code generations.
We inspect several factors:

* We insist that there be some population for every domain element
that can have values.
* All classes that are not union subclasses must have either a set
of initial instances or an allocation greater than 0 or both.
Since union subclasses are stored within their superclass,
they do not have a separate storage pool.
* At the end of population, we know which associations are static and can
then make the final decision about reference storage.
* All initial instances have their references defined so we can make sure
that the references themselves are correct and that there is no referential
integrity problems with the initial instance population.

There is a substantial amount of code required to perform this validation.
This is the result of the many different types of references that are
supported and the fact that the value of class component is taken
as a simple string.
The format and content of an initial value string depends upon the
context of the initialization and so each has to be examined.
The simple string nature of initial values means we cannot take
advantage of referential integrity and other declarative means to
insure correctness.
Hence, there will be a lot of code.

==== Checking Completeness

Value Elements in the platform model are the entities that can have
initial instance population values.
We want to query all the Value Elements that have no corresponding Element
Population in the Population.
These are the missing elements that were not included in the population.
The only type of class that can be missing is a union subclass.
These classes do not have a storage pool of their own and so can be missing.
and for which we will generate warning messages.

[source,tcl]
----
<<population: check completeness>>=
set usubs [pipe {
    UnionSubclass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation project ~ Domain Class |
    relation rename ~ Class Name
}] ; # <1>
set missing [pipe {
    findRelated $popref {R101 ElementPopulation} |
    findUnrelated ~ R101 |
    deRef ~ |
    relation minus ~ $usubs
}] ; # <2>
if {[relation isnotempty $missing]} {
    set elements [relation list $missing Name]
    log::error "in population, \"$name\", for domain, \"$domain\",\
        the following elements are missing any population values:\
        [join $elements {, }]"
    incr errcount
}
----
<1> Arrange for the union subclasses to have a header that is compatible
with the Value Element heading.
<2> Here we are looking for the Value Elements that are _unrelated_
to the population. They are the ones that have do not appear.
We subtract off the union subclasses so they are not diagnosed as missing.

[source,tcl]
----
<<config command tests>>=
test populate-4.0 {
    Population missing elements
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class c1 {
                attribute c1_id int
                attribute c1_color {char const*}
            }
            class c2 {
                attribute c2_id int
                attribute temp int -default 25
            }
        }

        population p1 bar {
            class c1 {
                instance fred1 c1_id 20 c1_color {"blue"}
            }
            # no population for "c2"
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

==== Checking Class Allocation

For class populations,
the maximum number of simultaneous instances is the sum of the
initial instance population plus the number of additional storage locations
allocated in the `allocate` command.
If both these quantities sum to zero,
then it is not possible to ever have an instance of the class and
the ``C'' compiler will not let us declare an array variable with 0 elements.

[source,tcl]
----
<<population: check class populations>>=
set noinsts [pipe {
    ClassPopulation findWhere\
        {$Population eq $name && $Domain eq $domain && $Allocation == 0} |
    deRef ~ |
    ralutil::rvajoin ~ $popinsts Instances |
    relation restrictwith ~ {[relation isempty $Instances]}
}] ; # <1>

if {[relation isnotempty $noinsts]} {
    log::error "in population, \"$name\", for domain, \"$domain\",\
        the following classes have no defined instances and a zero allocation:\
        [join [relation list $noinsts Class] {, }]"
    incr errcount
}
----
<1> The `rvajoin` command performs the relational equivalent of
an _outer join_ but with no `NUL` values.
The result has a relation valued attribute (hence the name `rvajoin`)
whose cardinality matches the number of matched tuples in the join.
In this case,
we are looking for where the relation valued attribute
(`Instances` in this case)
is empty, indicating that there were no matching instances in the population.
We will see this construct often in the population validation
code as we frequently are looking for when there are _no_ matches within
a set.

[source,tcl]
----
<<config command tests>>=
test populate-4.2 {
    class population with no instances and 0 allocation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class c1 {
                attribute c1_id int
                attribute c1_color {char const*}
            }
            class c2 {
                attribute c2_id int
                attribute temp int -default 25
            }
        }

        population p1 bar {
            class c1 {
                instance fred1 c1_id 20 c1_color {"blue"}
            }
            class c2 {
                allocate 0 ; # the allocate command insures we a c2 population
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

==== Checking Reference Values

The values given to reference components for a population are
simply strings that must refer to instances names of the proper
class.
We need to go though all the values for the various types of references
and make sure they were specified correctly.

[source,tcl]
----
<<population: check reference values>>=
<<population: check superclass references>>
<<population: check subclass references>>
<<population: check union subclass references>>
<<population: check associator references>>
<<population: check association references>>
----

==== Checking Superclass Reference Values

When a subclass makes a reference to its superclass,
we must make sure that the superclass instance actually exists.

[source,tcl]
----
<<population: check superclass references>>=
set superrefs [pipe {
    relation semijoin $::micca::ReferringSubclass $popvalues\
        -using {Domain Domain Class Class Relationship Component} |
    relation rename ~ Class Subclass Instance Subinstance Value Instance\
        Component Relationship |
    relation join ~ $::micca::ReferencedSuperclass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Role
}] ; # <1>

if {[relation isnotempty $superrefs]} {
    # puts [relformat $superrefs superrefs]

    # Find references to superclasses that are *not* in the population.
    set badsuperrefs [pipe {
        ralutil::rvajoin $superrefs $popinsts ValueMatch |
        relation restrictwith ~ {[relation isempty $ValueMatch]}
    }]
    # puts [relformat $badsuperrefs badsuperrefs]
    relation foreach badsuperref $badsuperrefs {
        relation assign $badsuperref
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            subclass instance, \"$Subclass.$Subinstance\", references\
            superclass instance, \"$Class.$Instance\" across,\
            \"$Relationship\", but $Instance does not exist"
        incr errcount
    }

    # Subtract out the bad references so we can proceed.
    set superrefs [pipe {
        relation eliminate $badsuperrefs ValueMatch |
        relation minus $superrefs ~
    }]

    # Look for superclasses that are reference multiple times.
    set multirefs [pipe {
        relation group $superrefs SubRefs Subclass Subinstance |
        relation restrictwith ~ {[relation cardinality $SubRefs] > 1}
    }]
    # puts [relformat $multirefs multirefs]
    relation foreach multiref $multirefs {
        relation assign $multiref
        relation foreach sref $SubRefs {
            relation assign $sref
            lappend screfs $Subclass.$Subinstance
        }
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            superclass instance, \"$Class.$Instance\", is referenced by\
            multiple subclass instances, \"[join $screfs {, }]\" across,\
            \"$Relationship\": this violates the referential integrity of\
            generalizations"
        incr errcount
    }

    # Find the superclasses that are not referenced by any subclass instance.
    # No need to remove the multirefs from consideration, that can create
    # false positives.
    set unrefsupers [pipe {
        relation join $::micca::ReferencedSuperclass $popinsts |
        relation eliminate ~ Number Role |
        ralutil::rvajoin ~ $superrefs RefedSupers |
        relation restrictwith ~ {[relation isempty $RefedSupers]}
    }]
    # puts [relformat $unrefsupers unrefsupers]
    relation foreach unrefsuper $unrefsupers {
        relation assign $unrefsuper
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            superclass instance, \"$Class.$Instance\", is not referenced\
            by any subclass across \"$Relationship\":\
            this violates the referential integrity of generalizations"
        incr errcount
    }
}
----
<1> Queries such as this are much easier to follow if you have the
class diagram graphic handy.
The general form of this query is used several times, so we will explain
this one in detail.
. Find the class component values that are related to a Referring Subclass,
which the role of a class in a generalization that makes a reference
to a superclass.
. Rename some attributes in preparation for doing the next join operation.
. Join to include the name of the Referenced Superclass to which the
subclass must refer.
. Discard the *Role* attribute, as it is not needed.
. Find the superclass instances that match the reference of the subclass.
. Look for those subclasses where there was no match. These are the
ones that are in error.

[source,tcl]
----
<<config command tests>>=
test populate-4.4 {
    bad superclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {
            }
            class sub1 {
            }
            class sub2 {
            }

            generalization R1 super sub1 sub2
        }

        population p1 bar {
            class super {
                instance super1 R1 {sub1 fred1}
                instance super2 R1 {sub2 alice1} ; # super2 is never referenced
            }
            class sub1 {
                instance fred1 R1 super1
            }
            class sub2 {
                instance alice1 R1 super3 ; # There is no "super3" instance.
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test populate-4.17 {
    multiple superclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {
            }
            class sub1 {
            }
            class sub2 {
            }

            generalization R1 super sub1 sub2
        }

        population p1 bar {
            class super {
                instance super1 R1 {sub1 fred1}
                instance super2 R1 {sub2 alice1} ; # not referenced by subclass
            }
            class sub1 {
                instance fred1 R1 super1
            }
            class sub2 {
                instance alice1 R1 super1 ; # Multiple reference to super1
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

==== Checking Subclass Reference Values

When a superclass instance refers to its subclass,
the population value is a list of the form `{<subclass> <instance>}`,
where <subclass> must be one of the subclasses of the generalization
and <instance> must be an instance of <subclass>.
Here we check both conditions.

[source,tcl]
----
<<population: check subclass references>>=
set refedsupers [pipe {
    relation semijoin $::micca::ReferencedSuperclass $popvalues\
        -using {Domain Domain Class Class Relationship Component} |
    relation rename ~ Class Superclass Instance Superinstance\
        Component Relationship
}] ; # <1>
CheckSubclassReferences $refedsupers $::micca::ReferringSubclass $popinsts
----
<1> Find the component values that are values for Referenced Superclasses

[source,tcl]
----
<<helper commands>>=
proc CheckSubclassReferences {supers subs insts} {
    if {[relation isempty $supers]} {
        return
    }
    # puts [relformat $supers supers]

    upvar #0 ::micca::@Config@::errcount errcount

    # First check for any values that are *not* two element lists.
    # These are of the wrong format.
    set badvalues [relation restrictwith $supers {[llength $Value] != 2}] ; # <1>
    # puts [relformat $badvalues badvalues]
    relation foreach badvalue $badvalues {
        relation assign $badvalue
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            instance, \"$Class.$Instance\", has a bad format for the\
            value of the subclass reference along, \"$Relationship\":\
            expected a two element list, got, \"$Value\""
        incr errcount
    }

    # Turn the value list elements into attributes of their own.
    set supers [pipe {
        relation minus $supers $badvalues |
        relation extend ~ rstup\
            Class string {[lindex [tuple extract $rstup Value] 0]}\
            Instance string {[lindex [tuple extract $rstup Value] 1]} |
        relation eliminate ~ Value
    }] ; # <2>
    # puts [relformat $supers supers]

    set nonparts [pipe {
        ralutil::rvajoin $supers $subs ClassMatch |
        relation restrictwith ~ {[relation isempty $ClassMatch]}
    }] ; # <3>
    # puts [relformat $nonparts nonparts]
    relation foreach nonpart $nonparts {
        relation assign $nonpart
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            superclass instance, \"$Superclass.$Superinstance\", references\
            subclass instance, \"$Class.$Instance\" across,\
            \"$Relationship\", but $Class is not a subclass of $Relationship"
        incr errcount
    }

    set supers [pipe {
        relation eliminate $nonparts ClassMatch |
        relation minus $supers ~
    }]
    # puts [relformat $supers supers]

    set badrefs [pipe {
        ralutil::rvajoin $supers $insts InstanceMatch |
        relation restrictwith ~ {[relation isempty $InstanceMatch]}
    }] ; # <4>
    # puts [relformat $badrefs badrefs]
    relation foreach badref $badrefs {
        relation assign $badref
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            superclass instance, \"$Superclass.$Superinstance\", references\
            subclass instance, \"$Class.$Instance\" across,\
            \"$Relationship\", but $Instance does not exist"
        incr errcount
    }

    # Check that no subclass is referenced more than once.
    set multirefs [pipe {
        relation eliminate $badrefs InstanceMatch |
        relation minus $supers ~ |
        relation group ~ SuperRefs Superinstance |
        relation restrictwith ~ {[relation cardinality $SuperRefs] > 1}
    }]
    # puts [relformat $multirefs multirefs]
    relation foreach multiref $multirefs {
        relation assign $multiref
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            superclass, \"$Superclass\", instances,\
            \"[join [relation list $SuperRefs Superinstance] {, }]\",\
            all reference subclass instance, \"$Class.$Instance\" across,\
            \"$Relationship\": this violates the referential integrity of\
            generalizations"
        incr errcount
    }

    # Check that every subclass is referenced.
    set unrefsubs [pipe {
        relation join $subs $insts |
        relation eliminate ~ Number Role |
        ralutil::rvajoin ~ $supers RefedSubs |
        relation restrictwith ~ {[relation isempty $RefedSubs]}
    }]
    # puts [relformat $unrefsubs unrefsubs]
    relation foreach unrefsub $unrefsubs {
        relation assign $unrefsub
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            subclass instance, \"$Class.$Instance\", is not referenced\
            by any superclass across \"$Relationship\":\
            this violates the referential integrity of generalizations"
        incr errcount
    }
}
----
<1> Check the format of the populated value.
We need a two element list of the form: `{<subclass name> <instance name>}`
<2> First, remove the tuples with a bad value format.
They have already been handled.
Expand the value to make the subclass and instance explicit attributes.
This has the effect of turning the values in the two element list into
separate attributes.
<3> Check that the subclass reference is to a class that is actually a
subclass for the relationship.
<4> Check that the subclass reference actually refers to an existing instance.
We have to subtract out the non participants since they will fail to
make an instance match also and we don't want to double count that.

[source,tcl]
----
<<config command tests>>=
test populate-4.5 {
    bad subclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {
            }
            class sub1 {
            }
            class sub2 {
            }

            generalization R1 super sub1 sub2
        }

        population p1 bar {
            class super {
                instance super1 R1 {sub1 fred1}
                instance super2 R1 {sub2 alice2} ; # there is no alice2
                instance super3 R1 {sub3 foo} ; # there is no sub3, not reference
            }
            class sub1 {
                instance fred1 R1 super1
            }
            class sub2 {
                instance alice1 R1 super2 ; # not referenced
            }
        }
    }
} -result {encountered 4 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test populate-4.15 {
    multiple subclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {
            }
            class sub1 {
            }
            class sub2 {
            }

            generalization R1 super sub1 sub2
        }

        population p1 bar {
            class super {
                instance super1 R1 {sub1 fred1}
                instance super2 R1 {sub2 alice1}
                instance super3 R1 {sub1 fred1} ; # multiple fred1, not referenced
            }
            class sub1 {
                instance fred1 R1 super1
            }
            class sub2 {
                instance alice1 R1 super2
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

==== Checking Union Subclass Reference Values

Union superclasses must also be checked to insure that they
make the correct references to subclasses.

[source,tcl]
----
<<population: check union subclass references>>=
set unionsupers [pipe {
    relation semijoin $::micca::UnionSuperclass $popvalues\
        -using {Domain Domain Class Class Relationship Component} |
    relation rename ~ Class Superclass Instance Superinstance\
        Component Relationship
}]
CheckSubclassReferences $unionsupers $::micca::UnionSubclass $popinsts
----

[source,tcl]
----
<<config command tests>>=
test populate-4.14 {
    bad union subclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {
                attribute s_id int
            }
            class sub1 {
                attribute temp int -default 25
            }
            class sub2 {
                attribute color int -default 25
            }

            generalization R1 -union super sub1 sub2
        }

        population p1 bar {
            class super {
                instance super1 s_id 20 R1 {sub1 fred1}
                instance super2 s_id 40 R1 {sub2 alice2} ; # there is no alice2
                instance super3 s_id 40 R1 {sub3 foo} ; # there is no sub3
            }
            class sub1 {
                instance fred1
            }
            class sub2 {
                instance alice1 ; # never referenced by a superclass instance
            }
        }
    }
} -result {encountered 3 configuration script errors} -returnCodes error
----

==== Checking Associator Reference Values

The associator class in a class based association always has a
corresponding associator reference.
The reference is always to both classes that participate in the
association.
Since there is a one-to-one correspondence between associator class
instances and instances of the association itself,
the references by an associator class cannot be empty.
There are a couple of complications when dealing with associator
references.
First, we are dealing with references to two classes and do not
want to impose any particular order on the mention of classes
in the instance value.
We are expecting a four element list of the form:
.....
{<oneclass> <oneinstance> <otherclass> <otherinstance>}
.....
where <oneclass> and <otherclass> are class names of the participants
in the association and <oneinstance> and <otherinstance> are instance
names of the corresponding classes.

The second complication arises with reflexive associations.
In this case, the references are both to the same class.
We resolve the directional ambiguity by expecting an initial value of the form:
.....
{forward <oneinstance> backward <otherinstance>}
.....
where <oneinstance> is the instance reached when traversing the association
in its forward direction and <otherinstance> is that reached when traversing
in the backward direction (reflexivity means we cannot determine direction
from the class names alone).

[source,tcl]
----
<<population: check associator references>>=
set assocs [pipe {
    relation semijoin $::micca::AssociatorClass $popvalues\
        -using {Domain Domain Class Class Relationship Component} |
    relation rename ~ Class Assocclass Instance Associnstance\
        Component Relationship |
    relation join ~ $::micca::SourceClass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Role Conditionality Multiplicity |
    relation rename ~ Class SourceClass |
    relation join ~ $::micca::TargetClass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Role Conditionality Multiplicity |
    relation rename ~ Class TargetClass
}] ; # <1>
# puts [relformat $assocs assocs]

set reflexive [relation restrictwith $assocs {$SourceClass eq $TargetClass}] ; # <2> 

set assocs [relation minus $assocs $reflexive]

set badvalues [relation restrictwith $assocs {[llength $Value] != 4}] ; # <3>
relation foreach badvalue $badvalues {
    relation assign $badvalue
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        instance, \"$AssocClass.$AssocInstance\", has a bad format for the\
        value of the associative reference for, \"$Relationship\":\
        expected a four element list, got, \"$Value\""
    incr errcount
}

set assocs [relation minus $assocs $badvalues]
# puts [relformat $assocs assocs]

set nonparts [relation restrictwith $assocs\
    {([lindex $Value 0] ne $SourceClass && [lindex $Value 0] ne $TargetClass) ||\
    ([lindex $Value 2] ne $SourceClass && [lindex $Value 2] ne $TargetClass)}] ; # <4>

# puts [relformat $nonparts nonparts]
relation foreach nonpart $nonparts {
    relation assign $nonpart
    foreach {class instance} $Value {
        if {$class ne $SourceClass && $class ne $TargetClass} {
            log::error "in population, \"$Population\", for domain,\
                \"$Domain\", associator instance,\
                \"$Assocclass.$Associnstance\", references\
                class instance, \"$class.$instance\" across,\
                \"$Relationship\", but $class does not participate in\
                $Relationship"
            incr errcount
        }
    }
}

set assocs [relation minus $assocs $nonparts]

set dupparts [relation restrictwith $assocs\
        {[lindex $Value 0] eq [lindex $Value 2]}] ; # <5>
# puts [relformat $dupparts dupparts]
relation foreach duppart $dupparts {
    relation assign $duppart
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        associator instance, \"$Assocclass.$Associnstance\", both
        references refer to the same class, \"[lindex $Value 0]\""
    incr errcount
}

set assocs [pipe {
    relation minus $assocs $dupparts |
    relation eliminate ~ SourceClass TargetClass
}] ; # <6>

set onerefs [relation extend $assocs otup\
        Class string {[lindex [tuple extract $otup Value] 0]}\
        Instance string {[lindex [tuple extract $otup Value] 1]}] ; # <7>
set otherrefs [relation extend $assocs otup\
        Class string {[lindex [tuple extract $otup Value] 2]}\
        Instance string {[lindex [tuple extract $otup Value] 3]}]

# Find the references for which there are no instances
set badrefs [pipe {
    relation union $onerefs $otherrefs |
    relation eliminate ~ Value |
    ralutil::rvajoin ~ $popinsts ValueMatch |
    relation restrictwith ~ {[relation isempty $ValueMatch]}
}]
# puts [relformat $badrefs badrefs]
relation foreach badref $badrefs {
    relation assign $badref
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        associator instance, \"$Assocclass.$Associnstance\", references\
        instance, \"$Class.$Instance\" across,\
        \"$Relationship\", but $Instance does not exist"
    incr errcount
}

# Now deal with reflexive case. The initial value for the reflexive
# case has a different format and we must be mindful that all the
# references are to the same class.

# puts [relformat $reflexive reflexive]

set badvalues [relation restrictwith $reflexive\
    {[llength $Value] != 4 ||\
    ![struct::set equal [dict keys $Value] {forward backward}]}] ; # <8>
relation foreach badvalue $badvalues {
    relation assign $badvalue
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        instance, \"$AssocClass.$AssocInstance\", has a bad format for the\
        value of component, \"$Relationship\": expected a four element list\
        with \"forward\" and \"backward\" keys, got, \"$Value\""
    incr errcount
}

set reflexive [pipe {
    relation minus $reflexive $badvalues |
    relation eliminate ~ TargetClass |
    relation rename ~ SourceClass Class
}] ; # <9>

set forwrefs [relation extend $reflexive rtup\
        Instance string {[lindex [tuple extract $rtup Value] 1]}] ; # <10>
set backrefs [relation extend $reflexive rtup\
        Instance string {[lindex [tuple extract $rtup Value] 3]}]

set badrefs [pipe {
    relation union $forwrefs $backrefs |
    relation eliminate ~ Value |
    ralutil::rvajoin ~ $popinsts ValueMatch |
    relation restrictwith ~ {[relation isempty $ValueMatch]}
}] ; # <11>
# puts [relformat $badrefs badrefs]
relation foreach badref $badrefs {
    relation assign $badref
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        associator instance, \"$Assocclass.$Associnstance\", references\
        instance, \"$Class.$Instance\" across,\
        \"$Relationship\", but $Instance does not exist"
    incr errcount
}
----
<1> Find the component values that are values for Associator Classes.
We continue to join in other information so as to obtain one big
whacking relation that has all the information in it we need.
In particular we need to know what the Source Class and Target Class
are for the association.
These will be the classes which the initial instance references must specify.
<2> Separate out the reflexive case. We will treat them later.
<3> Check that the format of the initial value.
<4> Check that the initial value does not refer to classes *not* in the
relationship.
<5> Check that reference value is non-reflexive.
<6> Now that we are sure that the initial value refers to the correct classes,
we can get rid of the source and target class attributes.
<7> Expand out the initial value to individual attributes. This turns the
elements of the initial value list into attributes.
Note that we do this for each pair in the initial value and then
union the results together.
<8> Find badly formatted initial values. We still want a four element list,
except now it must be of the form of a dictionary with keys of
`forward` and `backward`.
<9> Juggle some names around to coalesce source and target class names.
<10> Expand out the initial value to individual attributes. This is just
like the non-reflexive case, except we are only interested in the
instance names since the class name is determined already.
<11> Union the forward and backword references and get rid of the *Value*
attribute as it is no longer needed.
Using the, by now, familiar `rvajoin` we can find any non-matching
references.

[source,tcl]
----
<<config command tests>>=
test populate-4.6 {
    bad associator class reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {
                attribute date int -default 0
            }
            class X {
                attribute temp int -default 25
            }
            class Y {
                attribute color int -default 25
            }

            association R1 -associator A X 1--1 Y

            class B {
            }
            class Q {
            }
            class R {
            }
            association R2 -associator B Q 0..*--0..* R
        }

        population p1 bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2} ; # instance y2 is not defined
                instance a3 R1 {Z x2 Q y2} ; # neither Z nor Q participate in R1
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a2
            }
            class Y {
                instance y1 R1 a1
            }

            class B {
                instance b1 R2 {Q q1 R r1}
                instance b2 R2 {Q q1 R r2}
            }
            class Q {
                instance q1 R2 {b1 b2}
            }
            class R {
                instance r1 R2 b1
                instance r2 R2 b2
            }
        }
    }
} -result {encountered 3 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test populate-4.7 {
    bad reflexive associator class reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {
            }
            class X {
            }

            association R1 -associator A X 1..*--1..* X
        }

        population p1 bar {
            class A {
                instance a1 R1 {forward x2 backward x1}
                instance a2 R1 {forward y2 backward y3} ; # y2, y3 don't exist
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a2
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

==== Checking Association Reference Values

Association References are common and have the most different variances
the manner of reference.
There are four subclasses for *R38* in the platform model and we
will include code to check each one.

[source,tcl]
----
<<population: check association references>>=
<<population: check simple referring references>>
<<population: check simple referenced references>>
<<population: check source references>>
<<population: check target references>>
----

[float]
==== Checking Simple Referring Reference Values

[source,tcl]
----
<<population: check simple referring references>>=
set simprefs [pipe {
    relation semijoin $::micca::SimpleReferringClass $popvalues\
        -using {Domain Domain Class Class Relationship Component} |
    relation rename ~ Class Referringclass Instance Referringinstance\
        Value Instance Component Relationship |
    relation join ~ $::micca::SimpleReferencedClass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Role |
    relation extend ~ stup Multiplicity boolean {"false"}
}]

set simpreflex [relation restrictwith $simprefs {$Referringclass eq $Class}]
# puts [relformat $simpreflex simpreflex]
CheckNonReflexiveReferences [relation minus $simprefs $simpreflex] $popinsts

set forwreflex [pipe {
    relation restrictwith $::micca::DirectionalReference {
        $Domain eq $domain && $Role eq "source"
    } |
    relation semijoin ~ $simpreflex\
        -using {Domain Domain Class Class Name Relationship}
}]
CheckReflexiveReferences $forwreflex forward $popinsts
----

[float]
==== CheckNonReflexiveReferences

(((micca,Helpers,CheckNonReflexiveReferences)))
[source,tcl]
----
<<helper commands>>=
proc CheckNonReflexiveReferences {refedrefs insts} {
    if {[relation isempty $refedrefs]} {
        return
    }
    # puts [relformat $refedrefs refedrefs]

    upvar #0 ::micca::@Config@::errcount errcount

    set badnilrefs [relation restrictwith $refedrefs\
        {$Instance eq "@nil@" && !$Conditionality}]
    # puts [relformat $badnilrefs badnilrefs]
    relation foreach badnilref $badnilrefs {
        relation assign $badnilref
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            instance, \"$Referringclass.$Referringinstance\", has a nil\
            reference to \"$Class\" across, \"$Relationship\",\
            but $Relationship is unconditional from $Referringclass to $Class"
        incr errcount
    }

    set refedrefs [pipe {
        relation restrictwith $refedrefs {$Instance ne "@nil@"} |
        relation eliminate ~ Conditionality
    }]
    # puts [relformat $refedrefs refedrefs]

    set badmultrefs [relation restrictwith $refedrefs\
        {[llength $Instance] > 1 && !$Multiplicity}]
    # puts [relformat $badmultrefs badmultrefs]
    relation foreach badmultref $badmultrefs {
        relation assign $badmultref
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            instance, \"$Referringclass.$Referringinstance\",\
            references instances \"[join $Instance {, }]\" of \"$Class\",\
            across, \"$Relationship\",\
            but $Relationship is singular from $Referringclass to $Class"
        incr errcount
    }

    set badrefs [pipe {
        relation minus $refedrefs $badmultrefs |
        relation eliminate ~ Multiplicity |
        relation extend ~ rtup Instances {Relation {Instance string}}\
            {[relation fromlist [tuple extract $rtup Instance] Instance string]} |
        relation eliminate ~ Instance |
        relation ungroup ~ Instances |
        ralutil::rvajoin ~ $insts ValueMatch |
        relation restrictwith ~ {[relation isempty $ValueMatch]}
    }]
    # puts [relformat $badrefs badrefs]
    relation foreach badrefs $badrefs {
        relation assign $badrefs
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            instance, \"$Referringclass.$Referringinstance\", references\
            instance, \"$Class.$Instance\" across,\
            \"$Relationship\", but $Instance does not exist"
        incr errcount
    }
}
----

[float]
==== CheckReflexiveReferences

(((micca,Helpers,CheckReflexiveReferences)))
[source,tcl]
----
<<helper commands>>=
proc CheckReflexiveReferences {reflexive dir insts} {
    if {[relation isempty $reflexive]} {
        return
    }
    # puts [relformat $reflexive reflexive]

    upvar #0 ::micca::@Config@::errcount errcount

    # Find the badly formatted reference value
    set badvalues [relation restrictwith $reflexive\
        {!($Instance eq "@nil@" ||\
            (([dict size $Instance] >= 1 && [dict size $Instance] <= 2) &&\
            [struct::set contains [dict keys $Instance] $dir]))}]
    # puts [relformat $badvalues badvalues]
    relation foreach badvalue $badvalues {
        relation assign $badvalue
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            instance, \"$Referringclass.$Referringinstance\",\
            has a bad format for the value of component, \"$Relationship\":\
            expected a nil reference or a dictionary value with \"$dir\"\
            as a key, got, \"$Instance\""
        incr errcount
    }

    set reflexive [relation minus $reflexive $badvalues]

    # deal with nil references
    set reflexive [pipe {
        relation extend $reflexive rtup NewValue string {
            [tuple extract $rtup Instance] eq "@nil@" ?\
                "$dir @nil@" :\
                ([dict get [tuple extract $rtup Instance] $dir] eq {} ?\
                    "$dir @nil@" : [tuple extract $rtup Instance])
        } |
        relation rename ~ Instance OldValue NewValue Instance |
        relation eliminate ~ OldValue
    }]
    # puts [relformat $reflexive reflexive]

    # Expand out the reference value in the given direction
    set reflexive [pipe {
        relation extend $reflexive rtup\
            NewValue string {[dict get [tuple extract $rtup Instance] $dir]} |
        relation rename ~ Instance OldValue NewValue Instance |
        relation eliminate ~ OldValue
    }]
    # puts [relformat $reflexive reflexive]

    # Check for nil references for uncondnitional relationships
    set badnilrefs [relation restrictwith $reflexive {
        $Instance eq "@nil@" && !$Conditionality}]
    # puts [relformat $badnilrefs badnilrefs]
    relation foreach badnilref $badnilrefs {
        relation assign $badnilref
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            instance, \"$Referringclass.$Referringinstance\", has a nil\
            reference to \"$Class\" across, \"$Relationship\",\
            but $Relationship is unconditional from $Referringclass to $Class"
        incr errcount
    }
    set reflexive [relation minus $reflexive $badnilrefs]

    set badmultrefs [relation restrictwith $reflexive {
        [llength $Instance] > 1 && !$Multiplicity}]
    # puts [relformat $badmultrefs badmultrefs]
    relation foreach badmultref $badmultrefs {
        relation assign $badmultref
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            instance, \"$Referringclass.$Referringinstance\",\
            references instances \"[join $Instance {, }]\" of \"$Class\",\
            across, \"$Relationship\",\
            but $Relationship is singular from $Referringclass to $Class"
        incr errcount
    }
    # Expand out multiple instance references
    set reflexive [relation minus $reflexive $badmultrefs]

    set multiple [relation restrictwith $reflexive {$Multiplicity}]
    set expanded [pipe {
        relation extend $multiple mtup Instances {Relation {Instance string}}\
            {[relation fromlist [tuple extract $mtup Instance] Instance string]} |
        relation eliminate ~ Instance |
        relation ungroup ~ Instances
    }]
    # puts [relformat $expanded expanded]

    # Subtract out the multiple and add in the expanded
    set reflexive [pipe {
        relation minus $reflexive $multiple |
        relation union ~ $expanded
    }]
    # puts [relformat $reflexive reflexive]

    set badrefs [pipe {
        relation restrictwith $reflexive {$Instance ne "@nil@"} |
        ralutil::rvajoin ~ $insts ValueMatch |
        relation restrictwith ~ {[relation isempty $ValueMatch]}
    }]
    # puts [relformat $badrefs badrefs]
    relation foreach badrefs $badrefs {
        relation assign $badrefs
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            instance, \"$Referringclass.$Referringinstance\", references\
            instance, \"$Class.$Instance\" across,\
            \"$Relationship\", but $Instance does not exist"
        incr errcount
    }
}
----

[source,tcl]
----
<<config command tests>>=
test populate-4.8 {
    bad simple referenced class
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }
            class Y {
            }

            association R1 X 1..*--1 Y
        }

        population p1 bar {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2   ; # y2 does not exist
                instance x3         ; # nil reference not allowed
            }
            class Y {
                instance y1 R1 {x1 x2}
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[float]
==== Checking Simple Referenced Reference Values

[source,tcl]
----
<<population: check simple referenced references>>=
set refedrefs [pipe {
    relation semijoin $::micca::SimpleReferencedClass $popvalues\
        -using {Domain Domain Class Class Relationship Component} |
    relation rename ~ Class Referringclass Instance Referringinstance\
        Value Instance Component Relationship |
    relation join ~ $::micca::SimpleReferringClass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Role
}]

set simpreflex [relation restrictwith $refedrefs {$Referringclass eq $Class}]
# puts [relformat $simpreflex simpreflex]
CheckNonReflexiveReferences [relation minus $refedrefs $simpreflex] $popinsts

set backreflex [pipe {
    relation restrictwith $::micca::DirectionalReference {
        $Domain eq $domain && $Role eq "target"
    } |
    relation semijoin ~ $simpreflex\
        -using {Domain Domain Class Class Name Relationship}
}]
CheckReflexiveReferences $backreflex backward $popinsts
----

[source,tcl]
----
<<config command tests>>=
test populate-4.9 {
    bad simple referring class
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }
            class Y {
            }

            association R1 X 1..*--1 Y

            class Z {
            }

            association R2 Z 0..1--1 Y
        }

        population p1 bar {
            class X {
                instance x1 R1 y1 ; # fails since y1 is also faulty
                instance x2 R1 y2
                instance x3 R1 y3
            }
            class Y {
                instance y1             ; # nil reference not allowed
                instance y2 R1 {x1 x2} R2 {z1 z2} ; # mult ref R2
                instance y3 R1 {x3 x4}  ; # x4 does not exist
            }
            class Z {
                instance z1 R2 y2
                instance z2 R2 y3
            }
        }
    }
} -result {encountered 4 configuration script errors} -returnCodes error
----

[float]
==== Checking Source Reference Values

[source,tcl]
----
<<population: check source references>>=
set sourcerefs [pipe {
    relation semijoin $::micca::SourceClass $popvalues\
        -using {Domain Domain Class Class Relationship Component} |
    relation rename ~ Class Referringclass Instance Referringinstance\
        Value Instance Component Relationship |
    relation join ~ $::micca::TargetClass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Class Role |
    relation join ~ $::micca::AssociatorClass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Role
}]
CheckNonReflexiveReferences $sourcerefs $popinsts
----

[source,tcl]
----
<<config command tests>>=
test populate-4.10 {
    bad source class reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {
            }
            class X {
            }
            class Y {
            }

            association R1 -associator A X 1..*--0..1 Y
        }

        population p1 bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 {a1 a2}  ; # singular relationship
                instance x3
                instance x4 R1 a3       ; # no instance a3
            }
            class Y {
                instance y1 R1 a1
                instance y2 R1 a2
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[float]
==== Checking Target Reference Values

[source,tcl]
----
<<population: check target references>>=
set targetrefs [pipe {
    relation semijoin $::micca::TargetClass $popvalues\
        -using {Domain Domain Class Class Relationship Component} |
    relation rename ~ Class Referringclass Instance Referringinstance\
        Value Instance Component Relationship |
    relation join ~ $::micca::SourceClass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Class Role |
    relation join ~ $::micca::AssociatorClass\
        -using {Domain Domain Relationship Relationship} |
    relation eliminate ~ Role
}]
CheckNonReflexiveReferences $targetrefs $popinsts
----

[source,tcl]
----
<<config command tests>>=
test populate-4.11 {
    bad target class reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {
            }
            class X {
            }
            class Y {
            }

            association R1 -associator A X 1..*--0..* Y
        }

        population p1 bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x1 Y y2}
                instance a3 R1 {X x2 Y y2}
            }
            class X {
                instance x1 R1 {a1 a2}
                instance x2 R1 a3
                instance x3 R1 a4       ; # no a4
            }
            class Y {
                instance y1 R1 a1
                instance y2 R1 {a2 a3}
                instance y3             ; # nil not allowed
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test populate-4.12 {
    bad simple referenced class in reflexive association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }

            association R1 X 0..1--0..1 X
        }

        population p1 bar {
            class X {
                instance x1 R1 {forward x2 backward {}}
                instance x2 R1 {forward {} backward x1}
                instance x3
                instance x4 R1 {forward {x1 x2} backward {}} ; # multi
                instance x5 R1 {forward {x3}}               ; # no backward
                instance x6 R1 {forward {y1}} ; # no backward, no instance y1
            }
        }
    }
} -result {encountered 4 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test populate-4.13 {
    bad simple reflexive association that is M:1
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }

            association R1 X 1..*--1 X
        }

        population p1 bar {
            class X {
                instance x1 ; # unconditional
                # x2: reference to x1 bad because x1 faults
                instance x2 R1 {forward x3 backward x1}
                instance x3 R1 {forward x4 backward {}} ; # unconditional
                instance x4 R1 {forward x2 backward y1} ; # no instance y1
            }
        }
    }
} -result {encountered 4 configuration script errors} -returnCodes error
----

=== Class

The `class` command (in the context of a population) is used to specify
the initial instances of a class.

*****
`class` _name_ _script_

`name`::
    The name of the class.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of class component values for a class.

The `class` command is used to define initial instances for a class.
*****

Populating a class entails specifying attribute and reference values
as well as setting space allocation and storage characteristics of the class.
As we said before,
the `micca` architecture allocates a fixed amount of space for each class.
This determines the maximum number of instances that may exist
simultaneously.
A class population can consist of initial instances as well as those
created at run time.
Initial instances may be deleted at run time and their space
is then available for newly created instances.
To control the amount of space allocated,
the `allocation` command can be used to set the additional number of instances
beyond the initial instances that are allocated.
The total number of simultaneous instances is then the sum of the
allocation amount and the initial instances.

Classes can also be allocated to read-only memory.
If there is no dynamic activity on a class, such as state models or
attribute updates,
then the attributes and references can be placed in constant memory.
For small embedded system this can be a significant saving of read/write
memory which is usually in shorter supply.

To accommodate the class population commands we need a namespace
in which to evaluate the script.

[source,tcl]
----
<<class instance config namespace layout>>=
namespace eval ClassInstDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class instance commands>>
}
----

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<population config commands>>=
proc class {name script} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name class
    }

    variable PopulationName
    variable DomainName

    namespace upvar ClassInstDef ClassName ClassName Allocation Allocation
    set ClassName $name
    set Allocation 0

    ConfigEvaluate [namespace current]::ClassInstDef $script

    ElementPopulation create Population $PopulationName\
        Domain $DomainName Element $name
    ClassPopulation create Population $PopulationName Domain $DomainName\
            Class $name Allocation $Allocation

    return
}
----

=== Class Storage Allocation

*****
`allocate` ?_size_?

`size`::
    The number of additional class instances beyond those defined
    by the initial instances for which storage is allocated.

The `allocate` command is used declare that a class population is to have
_size_ additional storage slots allocated to it beyond those used
by the initial instance population.
If no `allocate` command is invoked for a class,
then the class will have zero additional instances allocated.
*****

[float]
==== Implementation

[source,tcl]
----
<<class instance commands>>=
proc allocate {{size 0}} {
    variable Allocation $size

    return
}
----

=== Static Associations

*****
`static` ?_association1_ _association2_ ...?

`associationN`::
    The name of an association that is to be marked as static.
    A static association does not change its references during run time
    (_i.e._ there are not relate or unrelated operations on it during
    run time).
    This information is used by the code generator to make choices about
    the data structure used to store reference pointers.

The `static` command declares that an association does not change
during run time.
*****

[float]
==== Implementation

[source,tcl]
----
<<population config commands>>=
proc static {args} {
    variable PopulationName
    variable DomainName

    foreach assocName $args {
        StaticAssociation create\
            Domain $DomainName\
            Population $PopulationName\
            Association $assocName
    }
}
----

=== Specifying Instance Values

Instances are populated according to their class components.
Class components are of several types but primarily are either
attributes or references.

Attribute values are specified using strings in ``C'' syntax.
The attribute value will be passed along to the generated code file
and must be valid ``C'' initializers.
For example the value for an `int` attribute can be specified as
0x20 or 32 and the ``C'' compiler will handle either.

Reference components present a bigger challenge to specify.
Since fundamentally references will resolve down to object addresses,
initializing references uses instance names as the place holder for
the class instance address.
Different reference types require some additional structure.

* Single references just require a single instance name. The instance
name must be one that is defined for the class to which the reference
refers.
* Multiple reference situation take a list of instance names.
So a reference that refers to many instances must specify a list
of instance names as its initial value.
* References to subclasses are of the form of a two element list,
the first element being the name of the subclass and the second
being the name of the instance.
It is required that the subclass name be one of the subclasses in the
generalization and the instance must be defined for that subclass.
* Reflexive associations require additional path specification
if both directions of the relationship have references defined.
In this case the references are in the form of a dictionary
with keys `forward` and `backward` to indicate the references
in the direction of traversal.
The values of the dictionary are lists of instance names.
The length of the instance names list must be appropriate to the
multiplicity of the reference.

The default value for an attribute or reference is specified by the
literal string, "-".
It is an error to specify a default value for an attribute for which
not default was define during the domain configuration.
The default value of a reference is the _nil_ reference,
which refers to no instance.
It is an error to specify the _nil_ value for a reference representing
an unconditional side of a relationship.
If an attribute value needs to be set to "-", then it must be escaped
and written as, "\-".

=== Setting Instance Values

The `instance` command defines the class component values for an instance
and gives the instance a name.
It is a convenient way to specify a small number of class instances.

*****
`instance` _name_ _comp1 value1 comp2 value2 ..._

`name`::
    The name of the instance. Instance names must be unique within a
    class.
`compN valueN`::
    The remaining arguments are in the form of component name / component
    value pairs. All components of a class must be present except for
    those which have defined default values.

The `instance` command defines a class instance named, _name_, and
gives the class components given by the _compN_ arguments the
corresponding _valueN_ value.
*****

[float]
==== Implementation

We want the `instance` command to set the values for every class component
that can be set, _i.e._ we don't want any underdefined instances.
To do that,
we will determine if the component names provided are sufficient.
If they are, then we can create the Class Instance and the set
of Class Component Value instances.
The latter fall into two types,
those provided as arguments and those which are missing from the arguments but
for which a default value can be deduced.


[source,tcl]
----
<<class instance commands>>=
proc instance {name args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 [namespace parent]::PopulationName PopulationName
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    <<instance: determine correct components>>

    set insttuple [list\
        Population $PopulationName\
        Domain $DomainName\
        Class $ClassName\
        Instance $name\
    ]
    ClassInstance create {*}$insttuple\
        Number [GenNumber $DomainName ClassInstance\
            [list $PopulationName $DomainName $ClassName]]

    <<instance: set values from arguments>>

    <<instance: set remaining defaulted values>>

    return
}
----

To determine if we have the correct components as arguments,
we need to find those components that must be set,
_i.e._ they have no reasonable default.
That set component names must be a subset of those provided as arguments.

[source,tcl]
----
<<instance: determine correct components>>=
set compnames [FindRequiredComponents $DomainName $ClassName]
set argcomps [dict keys $args]
set compdiff [struct::set difference $compnames $argcomps]
if {![struct::set empty $compdiff]} {
    error "for domain, \"$DomainName\",\
        population, \"$PopulationName\", class, \"$ClassName\",\
        instance, \"$name\", values for class components,\
        \"[join $compdiff {, }]\", are not provided\
        and have no default values"
    return
}
----

All class components must be set to a value _except_ attributes that
have a default value and association references that can be set to _nil_.

[source,tcl]
----
<<helper commands>>=
proc FindRequiredComponents {domain class} {
    # Compute the set of association references that are conditional,
    # i.e. they could have a nil reference, which is the default if they
    # are not explicitly initialized.
    # Start with all the Association Participant Classes.
    set assocpart [AssociationParticipantClass findWhere\
        {$Domain eq $domain && $Class eq $class}]
    # Notice that we must traverse to the referenced side to pick
    # up the right conditionality attribute.
    set condrefing [pipe {
        findRelatedWhere $assocpart {{~R38 SimpleReferringClass} R32 ~R33}\
            {$Conditionality} |
        findRelated % R33 ~R32
    } {} |%]

    set condrefed [pipe {
        findRelatedWhere $assocpart {{~R38 SimpleReferencedClass} R33 ~R32}\
            {$Conditionality} |
        findRelated % R32 ~R33
    } {} |%]

    set condsrc [pipe {
        findRelatedWhere $assocpart {{~R38 SourceClass} R34 ~R35}\
            {$Conditionality} |
        findRelated % R35 ~R34
    } {} |%]

    set condtarget [pipe {
        findRelatedWhere $assocpart {{~R38 TargetClass} R35 ~R34}\
            {$Conditionality} |
        findRelated % R34 ~R35
    } {} |%]

    # All the component names for the class
    set compnames [ClassComponent findWhere\
        {$Domain eq $domain && $Class eq $class}]
    # The attributes that have default values
    set defcomps [pipe {
        DefaultValue findWhere {$Domain eq $domain && $Class eq $class} |
        findRelated ~ R22 R21
    }]

    # Union all the conditional references and find the corresponding
    # class components.
    # Subtract that from the total set and then subtract the default attributes.
    set settable [pipe {
        refUnion [findRelated $condrefing R38] [findRelated $condrefed R38] |
        refUnion % [findRelated $condsrc R38] |
        refUnion % [findRelated $condtarget R38] |
        findRelated % ~R90 R25 R23 R21 |
        refMinus $compnames % |
        refMinus % $defcomps |
        deRef % |
        relation project % Name |
        relation list % Name
    } {} |%]
}
----

Create a Class Component Value instance for all the provided component
name / component values provided as arguments to the `instance` command.

[source,tcl]
----
<<instance: set values from arguments>>=
dict for {compname value} $args {
    set value [ResolveInitialValue $DomainName $ClassName $compname $value]
    ClassComponentValue create {*}$insttuple\
        Component $compname Value $value
}

----

The class components that remain to be set to default values are
those class components that are *not* link containers (these are always set
as part of setting a linked reference) and have not already been set
from the provided arguments.

[source,tcl]
----
<<instance: set remaining defaulted values>>=
set defaultcomps [FindRemainingComponents $DomainName $ClassName $argcomps]
foreach compname $defaultcomps {
    set value [ResolveInitialValue $DomainName $ClassName $compname -]
    ClassComponentValue create {*}$insttuple\
        Component $compname Value $value
}
----

[source,tcl]
----
<<helper commands>>=
proc FindRemainingComponents {domain class except} {
    return [pipe {
        ClassComponent findWhere {$Domain eq $domain && $Class eq $class\
                && $Name ni $except} |
        deRef ~ |
        relation list ~ Name
    }]
}
----

==== Resolving Initial Values

Because we introduced the "-" syntax for specifying default values,
we need to look up any defaults at instance population time.
This procedure does the work of insuring that the component exists
and if the default value was specified, makes sure such a default was defined
for the attribute or is the _nil_ reference value.

[source,tcl]
----
<<helper commands>>=
proc ResolveInitialValue {domain class component value} {
    if {$value eq "-"} {
        set compref [ClassComponent findById\
            Domain $domain\
            Class $class\
            Name $component]
        if {[isNotEmptyRef $compref]} {
            # Check for default attribute value
            set attrref [findRelated $compref {~R21 Attribute}]
            if {[isNotEmptyRef $attrref]} {
                set defref [findRelated $attrref ~R22]
                if {[isNotEmptyRef $defref]} {
                    return [readAttribute $defref Value]
                }
                error "attribute $component does not have a default value"
            }
            # Check for an association reference we can set to nil
            set refref [findRelated $compref {~R21 Reference}\
                    {~R23 AssociationReference}]
            if {[isNotEmptyRef $refref]} {
                return @nil@
            }
            error "component, \"$component\", cannot be set to a default value"
        }
    } else {
        set value [subst -nocommands -novariables $value]
    }

    return $value
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test populate-1.0 {
    population instances
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
            }
            class c2 {
                attribute c2_id int
            }
            association R1 c1 1..*--1 c2
        }

        population p1 foo {
            class c1 {
                instance chuck1 c1_id 5 R1 fred1
                instance chuck2 c1_id 7 R1 fred1
            }
            class c2 {
                instance fred1 c2_id 20 R1 {chuck1 chuck2}
            }
            static R1
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 3}\
        {[refMultiplicity [ClassComponentValue findAll]] == 6}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.1 {
    population instances using default values
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int -default 5
            }
            class c2 {
                attribute c2_id int
            }
            association R1 c1 1..*--0..1 c2
        }

        population p1 foo {
            class c1 {
                # color attribute is defaulted
                instance chuck1 c1_id 5 R1 fred1
                instance chuck2 c1_id 7 ; # leave off R1 ==> set to nil
            }
            class c2 {
                instance fred1 c2_id 20 R1 {chuck1 chuck2}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 3}\
        {[refMultiplicity [ClassComponentValue findAll]] == 8}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.2 {
    population fails for under specifying components
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int
            }
            class c2 {
                attribute c2_id int
            }
            association R1 c1 1..*--0..1 c2
        }

        population p1 foo {
            class c1 {
                instance chuck1 c1_id 5 R1 fred1 ; # missing color
                instance chuck2 c1_id 7 color 10
                instance chuck3 R1 fred1 ; # missing c1_id and color
            }
            class c2 {
                instance fred1 c2_id 20 R1 {chuck1 chuck2}
            }
        }
    }
} -result {encountered 3 configuration script errors} -returnCodes error
----

=== Tables of Instance Values

The `instance` command is useful for defining a small number of
initial instances, but can become tedious when larger number of instances
are involved.
For that case,
the `table` command is provided which allows class component values to
be specified in a more tabular layout without having to repeat the
class component names.

*****
`table` _heading_ _name1 values1 name2 values2 ..._

`heading`::
    A list of class component names that are to be specified in
    the remaining arguments
`nameN valuesN`::
    A list of instance names / instance value set pairs.
    Each _nameN_ argument gives the name of an instance to be initialized.
    Each corresponding _valueN_ argument is a list of values to be
    given the the instance.
    The number of values must match the number of component names in the
    _heading_ argument.
    Values are assigned to class components from the _valueN_ argument
    in the same order as the component names in the _heading_.

The `table` command is used to define initial instance values for
the class components.
The components to be initialized are given as a list in the _heading_ argument.
Subsequent arguments then give a name to the instance and a
list of class component values that correspond to _heading_.
Appropriately formatted,
the `table` command can show instance values in a more orderly tablular fashion
than the `instance` command and saves repeating class component names.
*****

[float]
==== Implementation

Our implementation of the `table` command follows from that of
the `instance` command.
The difference is that there is another iteration that allows multiple
instances to be created.

[source,tcl]
----
<<class instance commands>>=
proc table {heading args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 ::micca::@Config@::DomainDef::DomainName DomainName
    upvar #0 [namespace parent]::PopulationName PopulationName
    variable ClassName

    <<table: determine correct components>>

    set insttuple [list\
        Population $PopulationName\
        Domain $DomainName\
        Class $ClassName\
    ]

    dict for {instname compvalues} $args {
        if {[llength $heading] != [llength $compvalues]} {# <1>
            error "number of component values does not match heading:\
                got [llength $compvalues], expected [llength $heading]"
        }
        dict set insttuple Instance $instname ; # <2>

        <<table: set values from arguments>>

        <<table: set remaining defaulted values>>
    }

    return
}
----
<1> The number values associated with each instance have to match the
heading.
<2> Each time through the loop, set up a new instance name.

The `heading` argument must have all the component names that
cannot be defaulted in some way.

[source,tcl]
----
<<table: determine correct components>>=
set compnames [FindRequiredComponents $DomainName $ClassName]
set compdiff [struct::set difference $compnames $heading]
if {![struct::set empty $compdiff]} {
    error "for domain, \"$DomainName\",\
        population, \"$PopulationName\", class, \"$ClassName\",\
        instance, \"$name\", values for class components,\
        \"[join $compdiff {, }]\", are not provided\
        and have no default values"
    return
}
----

We start by creating the Class Instance and setting up
Class Component Values that match the arguments.

[source,tcl]
----
<<table: set values from arguments>>=
ClassInstance create {*}$insttuple\
    Number [GenNumber $DomainName ClassInstance\
        [list $PopulationName $DomainName $ClassName]]
foreach compname $heading compvalue $compvalues {
    set compvalue [ResolveInitialValue $DomainName $ClassName $compname\
            $compvalue]
    ClassComponentValue create {*}$insttuple\
        Component $compname Value $compvalue
}
----

Finally, Class Component Value instances are created for any missing components
that can have a default value.

[source,tcl]
----
<<table: set remaining defaulted values>>=
set defaultcomps [FindRemainingComponents $DomainName $ClassName\
        $heading]
foreach compname $defaultcomps {
    set compvalue [ResolveInitialValue $DomainName $ClassName\
            $compname -]
    ClassComponentValue create {*}$insttuple\
        Component $compname Value $compvalue
}
----

[source,tcl]
----
<<config command tests>>=
test populate-2.0 {
    Population using tables
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
            }
            class c2 {
                attribute c2_id int
            }
            association R1 c1 1..*--1 c2
        }

        population p1 foo {
            class c1 {
                allocate 10
                table   {c1_id      R1}\
                chuck1  {5          fred1}\
                chuck2  {7          fred1}
            }
            class c2 {
                table       {c2_id      R1}\
                fred1       {20         {chuck1 chuck2}}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 3}\
        {[refMultiplicity [ClassComponentValue findAll]] == 6}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-2.1 {
    Population using tables and default values
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int -default 42
            }
            class c2 {
                attribute c2_id int
            }
            association R1 c1 1..*--0..1 c2
        }

        population p1 foo {
            class c1 {
                allocate 10
                table   {c1_id      R1}\
                chuck1  {5          fred1}\
                chuck2  {7          fred1}\
                chuck3  {7          -}
            }
            class c2 {
                table       {c2_id      R1}\
                fred1       {20         {chuck1 chuck2 chuck3}}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 4}\
        {[refMultiplicity [ClassComponentValue findAll]] == 11}
} -result {1}
----

=== Populating Multiple Assigners

For multiple assigners,
it is necessary to specify which instances of the identifying class
is associated to the assigner.
The only information needed to define an assigner is its name
and the name of the instance of the identifying class corresponding to the
assigner.

We start with the now familiar namespace definition.

[source,tcl]
----
<<assigner instance config namespace layout>>=
namespace eval AssignerInstDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<assigner instance commands>>
}
----

=== Assigner

The `assigner` command (in the context of a population) is used to specify
the initial instances of an assigner

*****
`assigner` _association_ _script_

`association`::
    The name of the assocition which has a multiple assigner.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of assigner values.

The `assigner` command is used to define initial instances for an assigner.
*****

[float]
==== Implementation

(((micca,Config,assigner)))
[source,tcl]
----
<<population config commands>>=
proc assigner {assoc script} {
    variable PopulationName
    variable DomainName

    set maref [MultipleAssigner findById Domain $DomainName Association $assoc]
    if {[isEmptyRef $maref]} {# <1>
        tailcall DeclError UNKNOWN_MULT_ASSIGNER $assoc
    }

    namespace upvar AssignerInstDef AssocName AssocName IdClass IdClass
    set AssocName $assoc
    set IdClass [readAttribute $maref Class]

    ConfigEvaluate [namespace current]::AssignerInstDef $script

    if {[isEmptyRef [ElementPopulation findById Population $PopulationName\
            Domain $DomainName Element $assoc]]} {
        ElementPopulation create Population $PopulationName\
            Domain $DomainName Element $assoc
        AssignerPopulation create Population $PopulationName\
            Domain $DomainName Association $assoc
    }

    return
}
----
<1> We need to know the identifying class and insist it is define by this
point.

=== Populating An Assigner Instance

The `instance` command (in the context of an assigner) is used to specify
the initial instance of the identifying class assocated with the assigner
instance.

*****
`instance` _name_ _script_

`name`::
    The name of the assigner instance.
`idinstance`::
    The name of the identifying instance associated with the assigner.
    The _idinstance_ must be an instance defined for the identifying
    class associated with the multiple assigner.

The `instance` command is used to define initial instances for an assigner.
*****

[float]
==== Implementation

[source,tcl]
----
<<assigner instance commands>>=
proc instance {name idinstance} {

    upvar #0 [namespace parent]::PopulationName PopulationName
    upvar #0 [namespace parent]::DomainName DomainName
    variable AssocName
    variable IdClass

    MultipleAssignerInstance create\
        Population $PopulationName\
        Domain $DomainName\
        Association $AssocName\
        Instance $name\
        Number [GenNumber $DomainName MultipleAssignerInstance\
            [list $PopulationName $DomainName $AssocName]]\
        IdClass $IdClass\
        IdInstance $idinstance

    return
}
----

[source,tcl]
----
<<config command tests>>=
test populate-3.0 {
    Populate a multiple assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
            }
            class client {
            }
            association R1 clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {
            }
            association R2 department 1..*--1 clerk
        }

        population p1 foo {
            class clerk {
                instance fred R2 shoes
                instance alice R2 mens
                instance john R2 housewares
            }
            class client {
                allocate 10
            }
            class department {
                instance shoes R2 fred
                instance mens R2 alice
                instance housewares R2 john
            }
            assigner R1 {
                instance shoeclerks shoes
                instance mensclerks mens
                instance housewaresclerks housewares
            }
        }
    }
    log::debug [formatMiccaClass AssignerPopulation]
    log::debug [formatMiccaClass MultipleAssignerInstance]
    log::debug [formatMiccaClass ClassInstance]
    testConditions\
        {[refMultiplicity [AssignerPopulation findAll]] == 1}\
        {[refMultiplicity [MultipleAssignerInstance findAll]] == 3}\
} -result {1}
----

== Handling Configuration Errors

One of the design elements of the configuration DSL is the use of
the `micca` platform model to hold the configuration information.
This design approach allows us to encode the rules for what is a valid
domain configuration into the constraints.
Any attempt to define domain elements that violate those rules
will be caught at the end of the relvar transaction that end
the `configure` command.

The problem with this approach is that the error messages the are
returned refer to the classes of the platform model not those of
the domain we were attempting to define.

We will mitigate this problem by capturing the result returned by
TclRAL and turning it into error messages that are more meaningful
to the task of configuring a domain.
Unfortunately,
the messages produced by TclRAL are intended to be human readable,
so we will have to parse them into a form that is easier to deal
with programmatically.
Fortunately, the messages are very regular in structure so
the parsing code need not be very sophisticated.

Our strategy is to extract only the essential information from the
error message and then map the information onto a more meaningful error
message.
Part of what we want to include in the error message is the values
from the tuples failing the constraint.
These values contain information the user entered rather than the
abstractions of the platform model.

The essential information mapping is shown below.
Naturally enough, we hold it in a relvar.

[source,tcl]
----
<<config data>>=
relvar create Config_DataError {
    Relationship        string
    RefClass            string
    RefType             string
    Format              string
} {Relationship RefClass RefType}
----

The *Relationship* attribute is the name of the relationship in the
platform model that failed the constraint check.
The *RefClass* attribute is the platform model class that has the tuples
that failed the constraint check.
The *RefType* attribute defines the way in which the constraint failed.
The *Format* attribute is a string that contains the text of the
error message that we want to display.
The text in the *Format* attribute may also contain variable references
to attributes in the tuple of *RefClass* that failed.
The variable references in the *Format* will be substituted
with the values from the failing tuples in order to give specifics of
the error back to the user.

[float]
===== Implementation

The design of the `HandleConfigError` procedure is shown below.
It is a nested iteration over the lines of the error result, pulling
off the constraint violation details and then iterating over the
tuples that were found in the violation.

(((micca,Config,HandleConfigError)))
[source,tcl]
----
<<config commands>>=
proc HandleConfigError {result} {
    set lines [split [string trimright $result] \n]
    set nlines [llength $lines]
    set lineno 0
    upvar #0 ::micca::@Config@::errcount errcount
    while {$lineno < $nlines} {
        <<HandleConfigError: examine one failure>>
    }

    return
}
----

The information in the TclRAL error message is simple enough
and well structured enough that a regular expression can be used
to match and extract the interesting parts.

[source,tcl]
----
<<HandleConfigError: examine one failure>>=
set line [lindex $lines $lineno]
incr lineno
if {[regexp {^for[^:]+([^(]+)\(.+\), in relvar (.+)$} $line\
        match rnum refclass]} {
    set rnum [namespace tail $rnum]
    set refclass [namespace tail $refclass]

    # Now iterate over the "tuple" lines that follow the constraint message.
    while {$lineno < $nlines} {
        set tupline [lindex $lines $lineno]
        if {[regexp {^tuple {(.+)} (.+)$} $tupline match tuple phrase]} {
            incr lineno
            incr errcount
            <<HandleConfigError: examine one tuple>>
            <<HandleConfigError: format error message>>
        } else {
            break
        }
    }
} elseif {[regexp {procedural contraint, "([^"]+)", failed} $line match\
        constraint]} {
    # There is only one procedural constraint, R74C.
    # If an error is detected in the procedural constraint script,
    # messages will be printed there.
    # If anything other than R74C come along, we will just log it.
    if {[namespace tail $constraint] ne "R74C"} {
        log::error $result
        incr errcount
    }
} else {
    log::error $result
    incr errcount
}
----

We match the phrase in the tuple message to create an enumeration of
the types of constraint violations.
These are just a bit simpler to handle and look up.

[source,tcl]
----
<<HandleConfigError: examine one tuple>>=
if {[string match {is not referenced*} $phrase]} {
    set reftype notrefed
} elseif {[string match {references no*} $phrase]} {
    set reftype refnone
} elseif {[string match {*to by multiple*} $phrase]} {
    set reftype multrefed
} elseif {[string match {is not referred to*} $phrase]} {
    set reftype notrefto
} else {
    log::error "unknown constraint phrasing, \"$phrase\""
    continue
}
----

Finally, we look up the format information and generate an error message.
Using the `dict with` command allows us to take the tuple value from the
error message, treat it like a dictionary and get the values into
Tcl variable.
The `subst` command then will perform the variable substitutions in the
format string.

[source,tcl]
----
<<HandleConfigError: format error message>>=
set cde [relvar restrictone Config_DataError Relationship $rnum RefClass\
        $refclass RefType $reftype]
if {[relation isnotempty $cde]} {
    dict with tuple {
        log::error [subst -nocommands [relation extract $cde Format]]
    }
} else {
    log::error "$line\n$tupline"
}
----

We now need to enumerate all the platform model constraints that can be violated
and supply messages that provide less abstract and more useful user error
messages.
Because of the way the configuration data is stored into the platform model
classes,
not all violations are even possible.

[source,tcl]
----
<<config data>>=
relvar insert Config_DataError {
    Relationship        R20
    RefClass            Class
    RefType             notrefed
    Format              {in domain, \"$Domain\", class, \"$Name\",\
                        has no class components}
} {
    Relationship        R21
    RefClass            ClassComponent
    RefType             notrefto
    Format              {in domain, \"$Domain\", class, \"$Class\",\
                         component, \"$Name\", failed to be completed created}
} {
    Relationship        R86
    RefClass            DeferredEvent
    RefType             notrefed
    Format              {in domain, \"$Domain\", class, \"$Model\",\
                        defines event, \"$Event\" as polymorphic, yet\
                        $Model is not a superclass}
} {
    Relationship        R101
    RefClass            ElementPopulation
    RefType             refnone
    Format              {in population, \"$Population\",\
                         for domain, \"$Domain\", class or assigner,\
                         \"$Element\", does not exist}
} {
    Relationship        R72
    RefClass            StateTransition
    RefType             refnone
    Format              {in domain, \"$Domain\", class or assigner,\
                         \"$Model\", for the transition,\
                         \"$State - $Event -> $NewState\", state $NewState does\
                         not exist}
} {
    Relationship        R70
    RefClass            TransitionPlace
    RefType             refnone
    Format              {in domain, \"$Domain\", class or assigner,\
                         \"$Model\", event, \"$Event\", causes a transition\
                         out of state, \"$State\", but state $State does not\
                         exist}
} {
    Relationship        R103
    RefClass            ClassComponentValue
    RefType             refnone
    Format              {in population, \"$Population\", for domain,\
                         \"$Domain\", class, \"$Class\", instance,\
                         \"$Instance\" sets the value of \"$Component\" to\
                         \"$Value\", but $Component is not a known\
                         element of $Class"}
}
----

== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path {::micca ::rosea::InstCmds}

    <<helper data>>
    <<helper commands>>
}
----

=== DeclError

All error notification in the package is consolidated in
the +DeclError+ procedure.

[float]
==== Implementation

The +DeclError+ procedure locates a format string based on the error code
and applies its arguments to it.
We use the +::throw+ command to raise the error to insure that we have
consistent error code information for the package.

(((micca,Helpers,DeclError)))
[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list MICCA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

=== Generate Numbers

There are a number of classes that have attributes that are
zero based sequential numbers.
We want a convenient way to generate these ordinal numbers.
Many times we want the number to start at zero within a set of
attributes.

[float]
==== Implementation

[source,tcl]
----
<<helper data>>=
relvar create SeqNumbers {
    Domain string
    ClassName string
    Attrs list
    Number int
} {Domain ClassName Attrs}
----

(((micca,Helpers,GenNumber)))
[source,tcl]
----
<<helper commands>>=
proc GenNumber {domain class args} {
    set num [relvar restrictone SeqNumbers Domain $domain ClassName $class\
        Attrs $args]
    if {[relation isempty $num]} {
        relvar insert SeqNumbers [list\
            Domain $domain\
            ClassName $class\
            Attrs $args\
            Number 0\
        ]
        return 0
    } else {
        set result [expr {[relation extract $num Number] + 1}]
        relvar updateone SeqNumbers sn [list Domain $domain ClassName $class\
            Attrs $args] {
            tuple update $sn Number $result
        }
        return $result
    }
}
----

=== Parse C Type Names

There a number of places where we require a ``C'' type name.
We have adopted the strategy to separate out ``C'' identifiers from
type names when parameters and other such things are required.
In ``C'' itself, parameter and variables follow a declaration
type syntax that is meant to be mnemonic of the way a variable is used.
We find it easier to keep identifiers and types separate,
but it means we need to be able to verify that a given type name is
syntactically correct and to compose a type name and identfier into
a variable or parameter declaration.

Since this is strictly a parsing problem,
we will rely on the parser tools that are part of `tcllib`.
The parser tools take a PEG specification and generate a parser in Tcl.
We will not discuss the grammar and other details of this parsing.
Suffice it to say that we have formulated a PEG for parsing standard
``C'' type names.
The output of the parser tools is a Tcl OO class that can parse a text
string and return an AST of the type name.
We will use the Tcl OO class as a superclass and provide two methods
in our derived class that perform the required type name validation
and generate a variable declaration from a type name and identifier.

[float]
==== Implementation

[source,tcl]
----
<<required packages>>=
package require oo::util
----

(((micca,Helpers,typeverifier)))
[source,tcl]
----
<<helper commands>>=
source [file dirname [info script]]/typename/typeparser.tcl

oo::class create typeverifier {
    superclass typeparser

    method verifyTypeName {typename} {
        try {
            my parset $typename
            return true
        } on error {result} {
            return false
        }
    }

    method composeDeclaration {typename identifier} {
        my variable node
        set node {}

        set ast [my parset $typename]
        ::pt::ast topdown [mymethod TopWalker] $ast

        while {[llength $node] == 4} {
            set node [lindex $node end]
        }
        lassign $node nodetype start end
        return "[string range $typename 0 $end]\
            ${identifier}[string range $typename $end+1 end]"
    }

    method TopWalker {ast} {
        my variable node

        set nodetype [lindex $ast 0]
        if {$nodetype eq "specifier_qualifier_list" ||\
                $nodetype eq "abstract_declarator"} {
            set node $ast
        }
    }
}

typeverifier create typeCheck
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typecheck-1.0 {
    attribute with bad data type
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id {* int}
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test typecheck-1.1 {
    compose a variable declaration
} -setup {
} -cleanup {
} -body {
    ::micca::@Config@::Helpers::typeCheck composeDeclaration\
        {int (*)(int, int)} xx
} -result {int (* xx)(int, int)}
----

=== Checking for Duplicates

(((micca,Helpers,CheckDuplicate)))
[source,tcl]
----
<<helper commands>>=
proc CheckDuplicate {class args} {
    set ref [$class findById {*}$args]
    if {[isNotEmptyRef $ref]} {
        tailcall DeclError DUP_INSTANCE_NAME $class $args
    }
    return
}
----

(((error code,DUP_ELEMENT_NAME)))
[source,tcl]
----
<<error code formats>>=
DUP_INSTANCE_NAME    {an element of class, "%s", already exists with\
        attributes, "%s"}
----

== Test Utility Commands

There are number of utility commands that are part of the testing
infrastructure.
We present them here without additional commentary.

[source,tcl]
----
<<test utility commands>>=
namespace export getMiccaClass
proc getMiccaClass {class} {
    return [deRef [$class findAll]]
}
----

[source,tcl]
----
<<test utility commands>>=
namespace export formatMiccaClass
proc formatMiccaClass {class} {
    return \n[ral relformat [getMiccaClass $class] $class]
}
----

[source,tcl]
----
<<test utility commands>>=
namespace export readMiccaAttribute
proc readMiccaAttribute {class attr args} {
    return [rosea tunnel [$class findById {*}$args] readAttribute $attr]
}
----

[source,tcl]
----
<<test utility commands>>=
proc cleanupDomain {} {
    set preserve {
        ::micca::TransitionRule
    }
    relvar eval {
        foreach var [relvar names {::micca::[A-Z]*}] {
            if {$var ni $preserve} {
                relvar set $var [relation empty [relvar set $var]]
            }
        }
    }

    set config {
        ::micca::@Config@::Helpers::SeqNumbers
    }
    foreach var $config {
        relvar set $var [relation empty [relvar set $var]]
    }
}
----

[source,tcl]
----
<<test utility commands>>=
proc testConditions {args} {
    set result 1
    foreach exp $args {
        set passed [uplevel 1 [list expr $exp]]
        if {!$passed} {
            log::error "\"$exp\" failed"
            set result 0
        }
    }
    return $result
}
----
