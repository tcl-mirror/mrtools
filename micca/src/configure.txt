// vim:set syntax=asciidoc:

= Configuring a Domain

[partintro]
--
In the last part of the book,
we showed the platform specific model that `micca` uses.
To translate a domain it is necessary to populate the platform
specific model with the specific characteristics of the translated domain.
Since the platform model is implemented in `rosea`,
we could populate it using the `rosea populate` command.
This would be a difficult and tedious way to populate the platform
model for a human.
It might be perfectly acceptable to create a `rosea` population
programmatically, but it requires detailed knowledge of the platform model.
We will provide a much more convenient interface for humans by using
a domain specific language (DSL).

The DSL in this case is also a Tcl script and we will build the
DSL processing directly into the `micca` domain.
We will use the Tcl interpreter to parse the DSL.
The code that reads the DSL arranges for the script to be executed in
a context where command names resolve to procedures that populate the
`micca` platform specific model.
--

== Configuration Operations

Configuring a domain in `micca` will happen as a domain operation.
When we parse the various portions of a domain description,
we will use namespaces to confine the script execution and to expose
the appropriate commands to the configuration scripts.
This requires us to define child namespaces for the `micca` domain.
We must use some care in this because a `rosea` domain already has some
child namespaces defined on it. We will use a naming convention to
avoid any possible naming collisions.

In this part,
we first present the commands that are used to configure a domain under
`micca`.
These will be domain operations of the `micca` domain.
Afterwards,
we will define further child namespaces and commands within them that
accomplish gathering all the information needed to define the characteristics
of a domain.

=== Configure

One of our top level +micca+ commands is to configure a domain from
a script.

*****
+::micca configure+ _script_

+script+::
    A Tcl script that is executed in an environment that will resolve
    _domain configuration_ commands that may be used to define
    the characteristics of a domain.
*****

[float]
==== Implementation

(((micca,operation,configure)))
[source,tcl]
----
<<micca configuration>>=
operation configure {script} {
    return [@Config@::miccaConfigure $script]
}
----

=== ConfigureFromChan

It is often convenient to obtain the +configure+ script from an I/O channel.
The +micca configureFromChan+ command supports reading the configure
script directly from a channel.

*****
+::micca configureFromChan+ _channel_

+channel+::
    A Tcl channel handle that is readable.

The `configureFromChan` command invokes `configure` on the script
obtained by reading _channel_ until end of file is reached.
*****

[float]
==== Implementation

(((micca,operation,configureFromChan)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromChan {chan} {
    return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
}
----

=== ConfigureFromFile

It is often convenient to hold the +configure+ script in a file.
The +micca configureFromFile+ command supports reading the configure
script directly from a file.

*****
+::micca configureFromFile+ _filename_

+filename+::
    The name of a file containing a domain configuration script.

The `configureFromFile` command invokes `configure` on the script
obtained by reading the contents of the file named, _filename_.
*****

[float]
==== Implementation

(((micca,operation,configureFromFile)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromFile {filename} {
    set chan [::open $filename r]
    try {
        return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
    } finally {
        ::chan close $chan
    }
}
----

== Configuration Namespace Layout

The +::micca::@Config@+ namespace holds all the procedures that
perform the configuration of a `micca` domain.
We want to create a set of child namespaces
that mirror the nesting of the configuration language statements.
At the top level,
the +domain+ command is used to define each domain.
The +domain+ command accepts a script body that then defines the
components of the domain.
That script will be evaluated in a namespace where the commands that
define the domain components, _e.g._ +class+ and relationship commands,
resolve appropriately.
This lets us put commands for the body specifying a particular component into a
namespace which prevents any problems of accidentally invoking commands that
are inappropriate for that context.

We layout the +::micca::@Config@+ namespace as shown below.

[source,tcl]
----
<<configuration commands namespace>>=
namespace eval @Config@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    <<helper commands namespace>>

    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}
    <<config data>>
    <<config commands>>

    <<domain config namespace layout>>
}
----

=== Evaluating Configuration Scripts

The top level domain operations of `micca` that configure domains
all invoke `miccaConfigure` as the common entry point into the configuration
DSL code.

[float]
==== Implementation

(((micca,ensemble,configure)))
[source,tcl]
----
<<config commands>>=
proc miccaConfigure {script} {
    variable errcount
    set errcount 0

    variable configlineno
    set configlineno 1

    ConfigEvaluate ::micca::@Config@ $script

    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
CONFIG_ERRORS     {encountered %d configuration script errors}
----

You could evaluate the configuration script by simply gathering it together
and passing it to the core +namespace eval+ command.
Unfortunately,
the first error that is encountered will terminate the evaluation.
This is decidedly inconvenient as you would prefer to continue on and
come up with a list of errors for the evaluation much like a
conventional language compiler would do when compiling a source file.
Discovering errors one at a time is tediously unproductive.

Of course, it is possible to continue evaluating after an error but
that requires a bit more code.
We will also want to be able to evaluate scripts in different namespace
contexts as we described above.
We will accomplish all this by taking advantage of the core +::apply+ command
and its ability to execute a lambda function in a given namespace.
So given a script body and an namespace we can evaluate it as shown below.

(((micca,Config,ConfigEvaluate)))
[source,tcl]
----
<<config commands>>=
namespace export ConfigEvaluate

proc ConfigEvaluate {ns body} {
    variable evalLambda
    tailcall ::apply [concat $evalLambda [list $ns]] $body ; # <1>
}
----
<1> The `concat` command treats its arguments as a list.
On the off chance that the `ns` argument contains embedded whitespace,
we need to insure that it is treated as a single element list.
Hence the need to include the invocation of the `list` command.

The lambda function that performs the command evaluation is given below.
We hold the evaluation lambda as a piece of data.

[source,tcl]
----
<<config data>>=
variable evalLambda {{body} {
    upvar #0 ::micca::@Config@::errcount errcount ; # <1>
    upvar #0 ::micca::@Config@::configlineno configlineno
    set lineno $configlineno
    set command {}
    foreach line [split $body \n] { # <2>
        append command $line \n
        incr lineno ; # <3>
        if {[info complete $command]} {
            try {
                eval $command
            } on error {result} {
                puts $::errorInfo
                log::error "line $configlineno: \"$result\""
                incr errcount
            }
            set command {} ; # <4>
            set configlineno $lineno
        }
    }
    return $errcount
}}
----
<1> We need to keep track of all the errors encountered and
what line of the script we are currently dealing with.
<2> We split the body along lines and then reassemble the lines
into a complete command. The +info complete+ command tells us when
we have something that has some chance of being a real command.
<3> We need to keep track of where we are in the +body+.
<4> After evaluating a command we begin to assemble another one and
set our location counter to where that command starts.

== Defining a Domain

As we described above,
the domain configuration commands will take the data in their
arguments and store it away.
After we have finished all the configuration scripts,
then the +generate+ command is used to layout the data structures
and namespace as needed.

When configuring a domain,
we will evaluate the configuration script in the +DomainDef+ child namespace.
That namespace will define commands for all the components of the
domain.
We will use a similar arrangement for other nested aspects of
domain definitions.

=== Domain

*****
+domain+ _name_ _body_

+name+::
    The name of the domain. A domain name must be a non-empty string.
+body+::
    A Tcl script containing invocation of the domain definition commands
    to specify the details of the domain configuration.
*****

[float]
==== Implementation

(((micca,Config,domain)))
[source,tcl]
----
<<config commands>>=
proc domain {name body} {
    namespace upvar DomainDef DomainName DomainName ; # <1>
    set DomainName $name

    try {
        set domref [Domain findById Name $name] ; # <2>
        if {[isEmptyRef $domref]} {
            Domain create Name $name
        }

        ConfigEvaluate [namespace current]::DomainDef $body

        # At this point we have the definition of the domain and enough
        # information to tie together the class references and
        # the association definitions.
        <<domain: bind association references>>

        # We must also compute how polymorphic events are inherited
        # down generalization hierarchies.
        <<domain: propagate polymorphic events>>
    } on error {result} {
        puts $::errorInfo
        # ::micca::@Config@::HandleConfigError $result
    }
}
----
<1> We place the domain name into the child namespace where the context
implies that all the components defined are to be part of this domain.
<2> We allow the +domain+ command to be invoked more than once.
Domains are open ended definitions so we test to make sure we do not
attempt to create a duplicate domain.

(((error code,EMPTY_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_NAME      {"%s" is not a valid name for a %s}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-1.0 {
    Define an empty domain
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            # A domain may be empty of components.
        }
    }
    readMiccaAttribute Domain Name Name foo
} -result {foo}
----

== Defining Domain Components

In this section we discuss the commands that are used to define
the components of a domain.
We define child namespaces for those domain component commands
that have a nested structure.
In this case,
it is the +class+ command that requires additional configuration commands.

We start with the namespace layout for the +DomainDef+ namespace.

[source,tcl]
----
<<domain config namespace layout>>=
namespace eval DomainDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}
    <<domain config commands>>

    <<class config namespace layout>>
    <<assigner config namespace layout>>
}
----

=== Interface

[float]
==== Implementation

(((micca,Config,interface)))
[source,tcl]
----
<<domain config commands>>=
proc interface {text} {
    AppendToDomainAttribute Interface $text
}
----

=== Prologue

[float]
==== Implementation

(((micca,Config,prologue)))
[source,tcl]
----
<<domain config commands>>=
proc prologue {text} {
    AppendToDomainAttribute Prologue $text
}
----

=== Epilogue

[float]
==== Implementation

(((micca,Config,epilogue)))
[source,tcl]
----
<<domain config commands>>=
proc epilogue {text} {
    AppendToDomainAttribute Epilogue $text
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-2.0 {
    Define a domain with a non-empty interface
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            interface "#include <stdio.h>"
        }
    }
    log::debug [formatMiccaClass Domain]
    string trimright [readMiccaAttribute Domain Interface Name foo]
} -result {#include <stdio.h>}
----

=== Append To Domain Attribute

[float]
==== Implementation

(((micca,Config,AppendToDomainAttribute)))
[source,tcl]
----
<<helper commands>>=
proc AppendToDomainAttribute {attr text} {
    upvar #0 ::micca::@Config@::DomainDef::DomainName DomainName

    set domref [Domain findById Name $DomainName]
    withAttribute $domref $attr {
        append $attr $text
        if {[string index $Interface end] ne "\n"} {
            append $attr \n
        }
    }
    return
}
----

=== Class

The class command is used to define classes and specify their characteristics.

*****
+class+ _name_ _script_

+name+::
    The name of the class. A class name must be a non-empty string.
+script+::
    A Tcl script containing invocation of the class definition commands
    to specify the details of the class configuration.
*****

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<domain config commands>>=
proc class {name body} {
    namespace upvar [namespace current] DomainName DomainName ; # <1>
    namespace upvar ClassDef ClassName ClassName
    set ClassName $name

    set delem [DomainElement findById Domain $DomainName Name $name]
    if {[isNotEmptyRef $delem]} {
        tailcall DeclError DUP_ELEMENT_NAME $name
    }
    DomainElement create Domain $DomainName Name $name
    Class create Domain $DomainName Name $name\
        Number [GenNumber $DomainName Class [list $DomainName]]
    ValueElement create Domain $DomainName Name $name

    ConfigEvaluate [namespace current]::ClassDef $body
}
----
<1> Again we arrange for namespace variables to hold the current
domain and class names to provide the context of the definition.

==== Association

The +association+ command is used to define both simple and class based
associations depending upon arguments.

*****
+association+ _name_ _source_ _spec_ _target_ _?option value ...?_

+name+::
    The name of the association. Conventionally, relationships names are of the
    form *R<d>* where _<d>_ is one or more decimal digits but any
    non-empty string can be used.
+source+::
    The name of the class that defines the starting class for a forward
    traversal of the relationship.
+spec+::
    The specifier of the relationship conditionality and multiplicity.
    The _spec_ argument is one of the following strings.
    We allow two forms for some of the specifiers.
    The first form follows UML notation and the second form follows
    TclRAL notation.
        `1--1`:::
            The association is _one to one_.
        `0..1--1` or `?--1`:::
            The association is _at most one to one_.
        `0..1--0..1` or `?--?`:::
            The association is _at most one to at most one_.
        `1..*--1` or `+--1`:::
            The association is _one or more to one_.
        `0..*--1` or `*--1`:::
            The association is _zero or more to one_.
        `1..*--0..1` or `+--?`:::
            The association is _one or more to at most one_.
        `0..*--0..1` or `*--?`:::
            The association is _zero or more to at most one_.
        `1..*--1..*` or `+--+`:::
            The association is _one or more to one or more_.
        `0..*--1..*` or `*--+`:::
            The association is _zero or more to one or more_.
        `1..*--0..*` or `+--*`:::
            The association is _one or more to zero or more_.
        `0..*--0..*` or `*--*`:::
            The association is _zero or more to zero or more_.
+target+::
    The name of the class that defines the ending class for a forward
    traversal of the relationship.
+option value ...+::
    Options to the +association+ command are given as argument
    option / value pairs:
    Valid options and their values are:
    +-associator+ _class_:::
    The +-associator+ option define the association to be
    *class based* and specifies _class_ as the association class.
*****

///////
----
<<manual domain configuration commands>>=
[call [cmd association] [arg name] [arg source] [arg spec] [arg target]\
    [opt [arg "option value ..."]]]

The [cmd association] command defines a referential association called,
[arg name], between
a [arg source] class and a [arg target] class.
The multiplicity and conditionality of the association is specified
by [arg spec].
The [arg spec] argument must be a string from one of the following:
[list_begin itemized]
[item] 1--1
[item] 0..1--1 [emph or] ?--1
[item] 0..1--0..1 [emph or] ?--?
[item] 1..*--1 [emph or] +--1
[item] 0..*--1 [emph or] *--1
[item] 1..*--0..1 [emph or] +--?
[item] 0..*--0..1 [emph or] *--?
[item] 1..*--1..* [emph or] +--+
[item] 0..*--1..* [emph or] *--+
[item] 1..*--0..* [emph or] +--*
[item] 0..*--0..* [emph or] *--*
[list_end]

Options must be one of the following:
[list_begin options]
[opt_def [option -associator] [arg class]]
The [option -associator] option define the association to be
[emph "class based"] and specifies [arg class] as the association class.
[opt_def [option -path] [arg attribute_list]]
The [option -path] option defines the direction of reference for
class based reflexive associations.
The [arg attribute_list] argument is a list of attribute name pairs
that define the attribute correspondence when traversing the reflexive
association in the forward direction.
[list_end]
[para]
[example {
association R1 ClothesTub 1--1 WashingMachine
association R47 Member 1..*--1..* Organization -associator Membership
}]
In the example below,
the direction of [emph R1] is ambiguous since it is reflexive on [emph Element]
and is a class based association.
The [emph Group] associative class contains the referential attributes,
[emph PrevElem] and [emph NextElem] but we still need to state
that the forward direction of traversal is when values of [emph PrevElem] match
those of
[emph NextElem].
[example {
class Element {
    attribute ElemId string -id 1
}
class Group {
    attribute PrevElem string -id 1
    attribute NextElem string -id 1
    reference R1 Element -link {PrevElem ElemId} -link {NextElem ElemId}
}
association R1 Element 0..*--0..* Element -associator Group\ 
    -path {PrevElem NextElem}
}]
----
///////

In the command,
we are using the _spec_ string to encode several distinct pieces of information.
Each different association specifier implies the conditionality,
multiplicity and other properties of the association.
We encode those properties in data whose identifier is the _spec_ string
itself.

[source,tcl]
----
<<config data>>=
relvar create Config_AssocSpec {
    Spec                string
    NeedsAssociator     boolean
    ReflexiveAllowed    boolean
    ReferringCond       boolean
    ReferringMult       boolean
    ReferencedCond      boolean
    ReferencedMult      boolean
} Spec

relvar insert Config_AssocSpec {
    Spec 1--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec 0..1--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec 0..1--0..1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult false
        ReferencedCond true ReferencedMult false
} {
    Spec 1..*--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec 0..*--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec 1..*--0..1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec 0..*--0..1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec 1..*--1..* NeedsAssociator true ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec 0..*--1..* NeedsAssociator true ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec 1..*--0..* NeedsAssociator true ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec 0..*--0..* NeedsAssociator true ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec ?--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec ?--? NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult false
        ReferencedCond true ReferencedMult false
} {
    Spec +--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec *--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec +--? NeedsAssociator false ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec *--? NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec +--+ NeedsAssociator true ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec *--+ NeedsAssociator true ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec +--* NeedsAssociator true ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec *--* NeedsAssociator true ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult true
}
----

[float]
===== Implementation

Like most of the commands in the configuration language,
the bulk of the code is involved with populating the relvars
holding the essential data provided in the command arguments.
For the `association` command,
there is some argument parsing to determine whether the association
is simple or class based.
Then it is a matter of filling in the correct information based on the
type of the association.

(((micca,Config,association)))
[source,tcl]
----
<<domain config commands>>=
proc association {name source spec target args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME association
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    # Obtain references to the domain and class context.
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    <<association: parse arguments>>

    # Many relvars have tuples with the same heading, so we construct it
    # once here.
    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple

    # Populate the data for a Relationship and Association since that
    # is what this command defines.
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Association create {*}$reltuple

    # Populate the type of association we are dealing with.
    if {$associator eq {}} {
        <<association: populate simple association>>
    } else {
        <<association: populate class based association>>
    }

    return
}
----

(((error code,TILDE_NAME)))
[source,tcl]
----
<<error code formats>>=
TILDE_NAME {names beginning with the tilde character are not allowed\
    in this context, "%s"}
    
----

Argument parsing uses a simple +switch+ command arrangement.
We use two variables to hold the option values.

[source,tcl]
----
<<association: parse arguments>>=
set associator {}

foreach {option value} $args {
    switch -exact -- $option {
        -associator {
            set associator $value
        }
        default {
            tailcall DeclError UNKNOWN_OPTION association $option
        }
    }
}
<<association: check arguments>>
----

Here we use the data that we supplied above to make sure the
`spec` association specifier and the supplied arguments make sense together.
Certain forms of reflexiveness are not allowed and certain specifiers
imply that you must define a class based association.
Such rules are easier to express in data rather than long sequences
of checking code.

[source,tcl]
----
<<association: check arguments>>=
set cas [relvar restrictone ::micca::@Config@::Config_AssocSpec Spec $spec]
if {[relation isempty $cas]} {
    tailcall DeclError BAD_RELATIONSHIP_SPEC $spec
}
set needsassoc [relation extract $cas NeedsAssociator]
if {$needsassoc && $associator eq {}} {
    tailcall DeclError NEED_ASSOCIATOR $spec
}
if {$source eq $target} {
    if {![relation extract $cas ReflexiveAllowed]} {
        tailcall DeclError REFLEXIVE_NOT_ALLOWED $spec
    }
}
----

(((error code,BAD_RELATIONSHIP_SPEC)))
(((error code,NEED_ASSOCIATOR)))
(((error code, REFLEXIVE_NOT_ALLOWED)))
[source,tcl]
----
<<error code formats>>=
BAD_RELATIONSHIP_SPEC  {bad relationship specifier, "%s"}
NEED_ASSOCIATOR {relationship of type, "%s", requires associative class}
REFLEXIVE_NOT_ALLOWED   {associations of type, "%s", cannot be reflexive}
----

For simple associations,
the `association` command argument supply what we need and we
perform a series of inserts into the configuration language data model.

[source,tcl]
----
<<association: populate simple association>>=
SimpleAssociation create {*}$reltuple

SimpleReferringClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source\
    Conditionality  [relation extract $cas ReferringCond]\
    Multiplicity    [relation extract $cas ReferringMult]
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
ClassRole create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source

SimpleReferencedClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target\
    Conditionality  [relation extract $cas ReferencedCond]
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
ClassRole create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
----

[source,tcl]
----
<<association: populate class based association>>=
ClassBasedAssociation create {*}$reltuple

SourceClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source\
    Conditionality  [relation extract $cas ReferringCond]\
    Multiplicity    [relation extract $cas ReferringMult]
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
ClassRole create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source

TargetClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target\
    Conditionality  [relation extract $cas ReferencedCond]\
    Multiplicity    [relation extract $cas ReferencedMult]
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
ClassRole create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target

AssociatorClass create\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator
ClassRole create\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator
AssociatorReference create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
Reference create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
ClassComponent create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test association-1.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class x {
                attribute a1 string
                attribute a2 string
            }
            class y {
                attribute a1 string
            }
            association R10 y 1--1 x
        }
    }
    log::debug [formatMiccaClass SimpleAssociation]
    log::debug [formatMiccaClass SimpleReferringClass]
    readMiccaAttribute SimpleReferringClass Multiplicity Domain foo Class y\
        Relationship R10 Role source
} -result {false}
----

[source,tcl]
----
<<config command tests>>=
test association-2.0 {
    Define class based association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class a {
                attribute a1 string
            }
            class e {
                attribute a1 string
                attribute a2 string
            }
            class f {
                attribute a1 string
            }
            association R11 f 1..*--1..* e -associator a
        }
    }
    log::debug [formatMiccaClass AssociatorClass]
    log::debug [formatMiccaClass AssociatorReference]
    readMiccaAttribute SourceClass Multiplicity Domain foo Class f\
        Relationship R11 Role source
} -result {true}
----

=== Generalization

Defining a generalization relationship is quite a bit simpler than
the effort we just saw in defining associations.
For generalizations,
it is necessary to specify the superclass and the set of subclasses.

*****
+generalization+ _name_ _?-union | -reference?_ _super_ _sub1_ _sub2_ _?...?_

+name+::
    The name of the generalization. Conventionally, relationships names are of
    the form *R<d>* where _<d>_ is one or more decimal digits but any non-empty
    string can be used.
+super+::
    The name of the class that serves as the superclass of the generalization.
+subN+::
    The names of the classes that serve as the subclasses of the generalization.
    You must have at least two subclasses to define a generalization.
*****

[float]
==== Implementation

(((micca,Config,generalization)))
[source,tcl]
----
<<domain config commands>>=
proc generalization {name args} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME generalization
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    set type reference
    while {1} {
        set args [lassign $args arg]

        if {$arg eq "-reference"} {
            set type reference
        } elseif {$arg eq "-union"} {
            set type union
        } elseif {$arg eq "--"} {
            set args [lassign $args super]
            break
        } else {
            set super $arg
            break
        }
    }

    if {[llength $args] < 2} {
        tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
    }
    if {$super in $args} {
        tailcall DeclError SUPER_AS_SUBCLASS $super [join $args {, }]
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]

    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Generalization create {*}$reltuple

    set supertuple [list\
        Domain          $DomainName\
        Class           $super\
        Relationship    $name\
        Role            target\
    ]
    set subtuple [dict create\
        Domain          $DomainName\
        Relationship    $name\
        Role            source\
    ]

    if {$type eq "reference"} {
        ReferenceGeneralization create {*}$reltuple
        ReferencedSuperclass create {*}$supertuple
        foreach sub $args {
            dict set subtuple Class $sub
            ReferringSubclass create {*}$subtuple
        }
    } elseif {$type eq "union"} {
        UnionGeneralization create {*}$reltuple
        UnionSuperclass create {*}$supertuple
        SubclassContainer create Domain $DomainName Class $super Name $name
        ClassComponent create Domain $DomainName Class $super Name $name
        foreach sub $args {
            dict set subtuple Class $sub
            UnionSubclass create {*}$subtuple
        }
    }
    Superclass create {*}$supertuple
    ClassRole create {*}$supertuple

    foreach sub $args {
        dict set subtuple Class $sub
        Subclass create {*}$subtuple
        ClassRole create {*}$subtuple
    }

    return
}
----

(((error code,TOO_FEW_SUBCLASSES)))
(((error code,SUPER_AS_SUBCLASS)))
[source,tcl]
----
<<error code formats>>=
TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
SUPER_AS_SUBCLASS   {super class, "%s", cannot be included in subclasses, "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-1.0 {
    Define reference generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int
            }
            generalization R1 -reference super sub1 sub2
        }
    }
    log::debug [formatMiccaClass ReferenceGeneralization]
    log::debug [formatMiccaClass ReferencedSuperclass]
    log::debug [formatMiccaClass ReferringSubclass]
    relation cardinality\
        [lindex [micca::Generalization findById Domain foo Name R1] 1]
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test generalization-2.0 {
    Define union generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class usuper {
                attribute sid int
            }
            class usub1 {
                attribute sid int
            }
            class usub2 {
                attribute sid int
            }
            generalization R2 -union usuper usub1 usub2
        }
    }
    log::debug [formatMiccaClass UnionGeneralization]
    log::debug [formatMiccaClass UnionSuperclass]
    log::debug [formatMiccaClass UnionSubclass]
    log::debug [formatMiccaClass ClassComponent]
    relation cardinality\
        [lindex [micca::Generalization findById Domain foo Name R2] 1]
} -result {1}
----

=== Type Alias

*****
+typealias+ _definition_ _name_

+definition+::
    A ``C'' typename.
+name+::
    The name of the type alias.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc typealias {typedef aliasname} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    TypeAlias create Domain $DomainName TypeName $aliasname\
        TypeDefinition $typedef

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typealias-1.0 {
    Define a type alias
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            typealias uint8 rawbyte
        }
    }
    log::debug [formatMiccaClass TypeAlias]
    readMiccaAttribute TypeAlias TypeDefinition Domain foo TypeName rawbyte
} -result {uint8}
----

=== Domain Operation

*****
+domainop+ _rettype_ _name_ _parameters_ _body_

+definition+::
    A ``C'' typename.
+name+::
    The name of the type alias.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc domainop {rettype name parameters body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

    DomainOperation create Domain $DomainName Name $name Body $body\
        ReturnDataType $rettype
    set paramtuple [dict create Domain $DomainName Operation $name]
    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName DomainOperationParameter\
                [list $DomainName $name]]
        DomainOperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domainop-1.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }
        }
    }
    log::debug [formatMiccaClass DomainOperation]
    log::debug [formatMiccaClass DomainOperationParameter]
    readMiccaAttribute DomainOperation ReturnDataType Domain foo Name color
} -result {void}
----

== Defining Classes Components

Since there are several aspects of classes,
the +class+ command takes a _script_ argument which should
invoke the commands we discuss in this section.
Following our pattern,
we define a namespace where the class body script is evaluated.

[source,tcl]
----
<<class config namespace layout>>=
namespace eval ClassDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class config commands>>

    <<state model config namespace layout>>
}
----

=== Attribute

Within a class definitions,
the +attribute+ command specifies the attributes of the class.

*****
+attribute+ _name_ _type_ ?_option value_ ...?

+name+::
    The name of the attribute. Attributes names may not be the empty string.
+type+::
    The type of the attribute. The _type_ may be any valid ``C'' type name.
*****

The implementation of the +attribute+ command simply creates tuples
in the relvars to hold the attribute characteristics.

[float]
==== Implementation

(((micca,Config,attribute)))
[source,tcl]
----
<<class config commands>>=
proc attribute {name type args} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME attribute
    }
    if {[string range $name 0 1] eq "__"} {
        tailcall DeclError RESERVED_NAME $name
    }
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    ClassComponent create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name
    Attribute create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name\
        DataType    $type

    foreach {option value} $args {
        switch -exact -- $option {
            -default {
                DefaultValue create\
                    Domain      $DomainName\
                    Class       $ClassName\
                    Attribute   $name\
                    Value       $value
            }
            default {
                tailcall DeclError UNKNOWN_OPTION attribute $option
            }
        }
    }
}
----

(((error code,RESERVED_NAME)))
(((error code,INT_TYPE_REQUIRED)))
(((error code,INT_VALUE_REQUIRED)))
[source,tcl]
----
<<error code formats>>=
RESERVED_NAME {names beginning with two underscore characters are reserved,\
        "%s" cannot be used as a name in this context}
INT_TYPE_REQUIRED   {attribute must be of "int" type, got "%s"}
INT_VALUE_REQUIRED  {an integer value is required, got "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test attribute-1.0 {
    Define class with attributes
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20
            }
            class c2 {
                attribute b1 uint8
                attribute b2 float
            }
        }
    }
    relation cardinality [lindex\
        [micca::Attribute findWhere {$Domain eq "foo" && $Class eq "c2"}] 1]
} -result {2}
----

=== Reference

*****
+reference+ _relationship_ _class_ ?_option value_ ...?

+option value+::
    Valid options are:
    +-type+ _linked | array | constant

*****

[float]
==== Implementation

(((micca,Config,reference)))
[source,tcl]
----
<<class config commands>>=
proc reference {relname rclass args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set reftype linked
    set role {}

    foreach {option value} $args {
        switch -exact -- $option {
            -type {
                if {$value ni {linked array constant}} {
                    tailcall DeclError BAD_REF_TYPE $value
                }
                set reftype $value
            }
            -path {
                if {$value ni {forward backward}} {
                    tailcall DeclError BAD_PATH $value
                }
                if {$ClassName ne $rclass} {
                    tailcall DeclError PATH_NOT_ALLOWED $ClassName $rclass
                }
                set role [expr {$value eq "forward" ? "source" : "target"}]
            }
            default {
                tailcall DeclError UNKNOWN_OPTION reference $option
            }
        }
    }
    if {$ClassName eq $rclass && $role eq {}} {
        tailcall DeclError NEED_REFLEXIVE_PATH $relname $ClassName $rclass
    }

    relvar insert ::micca::@Config@::Class_Reference [list\
        Domain              $DomainName\
        ReferringClass      $ClassName\
        Relationship        $relname\
        ReferencedClass     $rclass\
        ReferenceType       $reftype\
        Role                $role\
    ]
}
----

(((error code,BAD_REF_TYPE)))
(((error code,BAD_PATH)))
(((error code, NEED_REFLEXIVE_PATH)))
(((error code, PATH_NOT_ALLOWED)))
[source,tcl]
----
<<error code formats>>=
BAD_REF_TYPE    {unknown reference type value, "%s": should be linked,\
                array or constant}
BAD_PATH        {unknown path value, "%s": should be forward or backward}
NEED_REFLEXIVE_PATH {traversal path must be specified for reflexive\
                    association, %s from %s to %s}
PATH_NOT_ALLOWED    {path option not allowed for non-reflexive reference\
                    from "%s" to "%s"}
----

[source,tcl]
----
<<config data>>=
relvar create Class_Reference {
    Domain              string
    ReferringClass      string
    Relationship        string
    ReferencedClass     string
    Role                string
    ReferenceType       string
} {Domain Relationship ReferringClass ReferencedClass Role}
----

=== Super Reference

*****
+superref+ _relationship_
*****

[float]
==== Implementation

(((micca,Config,reference)))
[source,tcl]
----
<<class config commands>>=
proc superref {relname} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    relvar insert ::micca::@Config@::Class_Reference [list\
        Domain              $DomainName\
        ReferringClass      $ClassName\
        Relationship        $relname\
        ReferencedClass     {}\
        ReferenceType       super\
        Role                target\
    ]
}
----

[source,tcl]
----
<<domain: bind association references>>=

###
# HERE
# Need to make sure that all the Class Reference instances are correct
# in that they refer to real associations, etc.
# The logic below will pick out the correct ones from the association
# point of view, but it is still possible to define a reference to
# a class were no association or generalization has been defined.

set refsupers [pipe {
    relvar set Class_Reference |
    relation semijoin ~ [GetMiccaClass ReferencedSuperclass]\
        -using {Domain Domain ReferringClass Class Relationship Relationship}
}]
relation foreach refsuper $refsupers {
    relation assign $refsuper
    SubclassReference create\
        Domain      $Domain\
        Class       $Class\
        Name        $Relationship\
        Role        $Role
    Reference create\
        Domain      $Domain\
        Class       $Class\
        Name        $Relationship
    ClassComponent create\
        Domain      $Domain\
        Class       $Class\
        Name        $Relationship
}

set refsubs [pipe {
    relvar set Class_Reference |
    relation semijoin ~ [GetMiccaClass ReferringSubclass]\
        -using {Domain Domain ReferringClass Class Relationship Relationship}
}]
relation foreach refsub $refsubs {
    relation assign $refsub
    SuperclassReference create\
        Domain      $Domain\
        Class       $Class\
        Name        $Relationship\
        Role        $Role
    Reference create\
        Domain      $Domain\
        Class       $Class\
        Name        $Relationship
    ClassComponent create\
        Domain      $Domain\
        Class       $Class\
        Name        $Relationship
}

# Do reflexive associations first
set arefs [pipe {
    GetMiccaClass AssociationParticipantClass |
    relation join ~ [relvar set Class_Reference]\
        -using {Domain Domain Class ReferringClass Relationship Relationship\
            Role Role}
}]

# Start with traversal sources

# Switch conditionality and multiplicity for the associative participants

set sc [pipe {
    GetMiccaClass TargetClass |
    relation rename ~ Class TClass Role TRole Conditionality TCond\
            Multiplicity TMult |
    relation join [GetMiccaClass SourceClass] ~ |
    relation eliminate ~ TClass TRole Conditionality Multiplicity |
    relation rename ~ TCond Conditionality TMult Multiplicity
}]
set tc [pipe {
    GetMiccaClass SourceClass |
    relation rename ~ Class SClass Role SRole Conditionality SCond\
            Multiplicity SMult |
    relation join [GetMiccaClass TargetClass] ~ |
    relation eliminate ~ SClass SRole Conditionality Multiplicity |
    relation rename ~ SCond Conditionality SMult Multiplicity
}]

set refing [relation union [GetMiccaClass SimpleReferringClass] $sc]

set srcs [relation join $arefs $refing]

CreateReferenceComponents $srcs
CreateDirectionalComponents $srcs

# Next do the targets
# Make Simple Referenced Class union compatible with Target Class

set refed [pipe {
    GetMiccaClass SimpleReferencedClass |
    relation extend ~ smp Multiplicity boolean {"false"} |
    relation union ~ $tc
}]

set targets [relation join $arefs $refed]
CreateDirectionalComponents $targets

# Next do the non-reflexive case
set nrrefs [pipe {
    relvar set Class_Reference |
    relation restrictwith ~ {$Role eq {}} |
    relation eliminate ~ Role |
    relation join [GetMiccaClass AssociationParticipantClass] ~\
        -using {Domain Domain Class ReferringClass Relationship Relationship}
}]

# Again, start with traversal sources

set srcs [relation join $nrrefs $refing]
CreateReferenceComponents $srcs
CreateDirectionalComponents $srcs

set targets [relation join $nrrefs $refed]
CreateReferenceComponents $targets
CreateDirectionalComponents $targets
----

[source,tcl]
----
<<config commands>>=
proc CreateReferenceComponents {comprels} {
    relation foreach comprel $comprels {
        relation assign $comprel
        set comptuple [list\
            Domain $Domain\
            Class $Class\
            Name $Relationship\
        ]
        ClassComponent create {*}$comptuple
        Reference create {*}$comptuple
        AssociationReference create {*}$comptuple
    }
}

proc CreateDirectionalComponents {comprels} {
    relation foreach comprel $comprels {
        relation assign $comprel
        set comptuple [list\
            Domain $Domain\
            Class $Class\
            Name $Relationship\
            Role $Role\
        ]
        DirectionalReference create {*}$comptuple
        if {$Multiplicity} {
            if {$ReferenceType eq "linked"} {
                LinkedReference create {*}$comptuple
                # place the link container in the referenced class.
                set linktuple [list\
                    Domain $Domain\
                    Class $ReferencedClass\
                    Name ${Relationship}_${Role}_links\
                ]
                ClassComponent create {*}$linktuple
                LinkContainer create {*}$linktuple
            } else {
                lappend comptuple IsConstant\
                    [expr {$ReferenceType eq "array" ? "false" : "true"}]
                ArrayReference create {*}$comptuple
            }
        } else {
            SingularReference create {*}$comptuple
        }
    }
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test reference-1.0 {
    Define class with association reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 c2
            }
            class c2 {
                attribute b1 uint8
                attribute b2 float

                reference R1 c1
            }

            association R1 c1 1..*--1 c2
        }
    }
    log::debug [formatMiccaClass DirectionalReference]
    log::debug [formatMiccaClass SingularReference]
    log::debug [formatMiccaClass LinkedReference]
    readMiccaAttribute ClassComponent Name Domain foo Class c1 Name R1
} -result {R1}
----

[source,tcl]
----
<<config command tests>>=
test reference-2.0 {
    Define class with reflexive association reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 c1 -path forward
                reference R1 c1 -path backward
            }

            association R1 c1 0..1--0..1 c1
        }
    }
    log::debug [formatMiccaClass DirectionalReference]
    log::debug [formatMiccaClass SingularReference]
    readMiccaAttribute ClassComponent Name Domain foo Class c1 Name R1
} -result {R1}
----

[source,tcl]
----
<<config command tests>>=
test reference-3.0 {
    Define class many to many association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 a
            }
            class c2 {
                attribute a1 int
                attribute b1 float

                reference R1 a
            }
            class a {
            }

            association R1 c1 0..*--1..* c2 -associator a
        }
    }
    log::debug [formatMiccaClass DirectionalReference]
    log::debug [formatMiccaClass LinkedReference]
    log::debug [formatMiccaClass AssociatorReference]
    log::debug [formatMiccaClass LinkContainer]
    readMiccaAttribute ClassComponent Name Domain foo Class a Name R1
} -result {R1}
----

[source,tcl]
----
<<config command tests>>=
test reference-4.0 {
    Define class with reference generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super {
                attribute a1 char

                superref R1
            }
            class sub1 {
                attribute a1 char

                reference R1 super
            }
            class sub2 {
                attribute a1 int

                reference R1 super
            }

            generalization R1 super sub1 sub2
        }
    }
    log::debug [formatMiccaClass SubclassReference]
    log::debug [formatMiccaClass SuperclassReference]
    readMiccaAttribute ClassComponent Name Domain foo Class super Name R1
} -result {R1}
----

=== Constructor

*****
+constructor+ _body_
*****

[float]
==== Implementation

(((micca,Config,constructor)))
[source,tcl]
----
<<class config commands>>=
proc constructor {body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName
    Constructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

=== Destructor

*****
+destructor+ _body_
*****

[float]
==== Implementation

(((micca,Config,destructor)))
[source,tcl]
----
<<class config commands>>=
proc destructor {body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName
    Destructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

=== Class Operation

*****
+classop+ _rettype_ _name_ _parameters_ _body_
*****

[float]
==== Implementation

(((micca,Config,classop)))
[source,tcl]
----
<<class config commands>>=
proc classop {rettype name parameters body} {
    DefineOperation false $rettype $name $parameters $body
}
----

=== Instance Operation

*****
+instop+ _rettype_ _name_ _parameters_ _body_
*****
[float]
==== Implementation

(((micca,Config,instop)))
[source,tcl]
----
<<class config commands>>=
proc instop {rettype name parameters body} {
    DefineOperation true $rettype $name $parameters $body
}
----

=== Define Operation

[float]
==== Implementation

(((micca,Config,DefineOperation)))
[source,tcl]
----
<<class config commands>>=
proc DefineOperation {isinst rettype name parameters body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    Operation create Domain $DomainName Class $ClassName Name $name Body $body\
        ReturnDataType $rettype IsInstance $isinst
    set paramtuple [dict create Domain $DomainName Class $ClassName\
            Operation $name]

    if {$isinst} {
        dict set paramtuple Name self
        dict set paramtuple DataType "struct $ClassName *"
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test classop-1.0 {
    Define a class operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c4 {
                attribute a1 int

                classop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation ReturnDataType Domain foo Class c4 Name color
} -result {float}
----

[source,tcl]
----
<<config command tests>>=
test instop-1.0 {
    Define an instance operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c5 {
                attribute a1 int

                instop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation IsInstance Domain foo Class c5 Name color
} -result {true}
----

== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path {::micca ::rosea::InstCmds}
    <<helper data>>
    <<helper commands>>
}
----

=== DeclError

All error notification in the package is consolidated in
the +DeclError+ procedure.

[float]
==== Implementation

The +DeclError+ procedure locates a format string based on the error code
and applies its arguments to it.
We use the +::throw+ command to raise the error to insure that we have
consistent error code information for the package.

(((micca,Helpers,DeclError)))
[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list MICCA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

=== Generate Numbers

There are a number of classes that have attributes that are
zero based sequential numbers.
We want a convenient way to generate these ordinal numbers.
Many times we want the number to start at zero within a set of
attributes.

[float]
==== Implementation

[source,tcl]
----
<<helper data>>=
relvar create SeqNumbers {
    Domain string
    ClassName string
    Attrs list
    Number int
} {Domain ClassName Attrs}
----

[source,tcl]
----
<<helper commands>>=
proc GenNumber {domain class args} {
    set num [relvar restrictone SeqNumbers Domain $domain ClassName $class\
        Attrs $args]
    if {[relation isempty $num]} {
        relvar insert SeqNumbers [list\
            Domain $domain\
            ClassName $class\
            Attrs $args\
            Number 0\
        ]
        return 0
    } else {
        set result [expr {[relation extract $num Number] + 1}]
        relvar updateone SeqNumbers sn [list Domain $domain ClassName $class\
            Attrs $args] {
            tuple update $sn Number $result
        }
        return $result
    }
}
----

[source,tcl]
----
<<helper commands>>=
proc CheckDuplicate {class args} {
    set ref [$class findById {*}$args]
    if {[isNotEmptyRef $ref]} {
        tailcall DeclError DUP_INSTANCE_NAME $class $args
    }
    return
}
----

(((error code,DUP_ELEMENT_NAME)))
[source,tcl]
----
<<error code formats>>=
DUP_INSTANCE_NAME    {an element of class, "%s", already exists with\
        attributes, "%s"}
----

[source,tcl]
----
<<helper commands>>=
proc GetMiccaClass {class} {
    return [deRef [$class findAll]]
}
----

== Test Utility Commands

[source,tcl]
----
<<test utility commands>>=
namespace export formatMiccaClass
proc formatMiccaClass {class} {
    return \n[ral relformat [GetMiccaClass $class] $class]
}

namespace export readMiccaAttribute
proc readMiccaAttribute {class attr args} {
    return [rosea tunnel [$class findById {*}$args] readAttribute $attr]
}

proc cleanupDomain {} {
    relvar eval {
        foreach var [relvar names {::micca::[A-Z]*}] {
            relvar set $var [relation empty [relvar set $var]]
        }

        relvar set ::micca::@Config@::Class_Reference\
            [relation empty [relvar set ::micca::@Config@::Class_Reference]]
    }
}
----
