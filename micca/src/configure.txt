// vim:set syntax=asciidoc:

= Configuring a Domain

[partintro]
--
In the last part of the book,
we showed the platform specific model that `micca` uses.
To translate a domain it is necessary to populate the platform
specific model with the specific characteristics of the domain to be translated.
Since the platform model is implemented in `rosea`,
we could populate it using the `rosea populate` command.
This would be a difficult and tedious way to populate the platform
model for a human.
It might be perfectly acceptable to create a `rosea` population
programmatically, but it requires detailed knowledge of the platform model.
We will provide a much more convenient interface for humans by using
a domain specific language (DSL).

The DSL in this case is also a Tcl script and we will build the
DSL processing directly into the `micca` domain.
We will use the Tcl interpreter to parse the DSL.
The code that reads the DSL arranges for the script to be executed in
a context where command names resolve to procedures that populate the
`micca` platform specific model.

In this part,
we describe the commands that make up the DSL to populate the
platform model.
--

== Configuration Commands

Configuring a domain in `micca` happens as a domain operation.
When we parse the various portions of a domain description,
we will use namespaces to confine the script execution and to expose
the appropriate commands to the configuration scripts.
This requires us to define child namespaces for the `micca` domain.
We must use some care in this because a `rosea` domain already has some
child namespaces defined on it. We will use a naming convention to
avoid any possible naming collisions.

The configuration script is a Tcl script and the full resources of
Tcl are available.
In particular, the `source` command is useful for organizing
configuration scripts into smaller pieces that can be included,
using the `source` command, into a configuration.

In this part,
we first present the commands that are used to configure a domain under
`micca`.
These will be domain operations of the `micca` domain.
Afterwards,
we will define further child namespaces and commands within them that
accomplish gathering all the information needed to define the characteristics
of a domain.

=== Configure

One of our top level +micca+ commands is to configure a domain from
a script.

*****
+::micca configure+ _script_

+script+::
    A Tcl script that is executed in an environment that will resolve
    _domain configuration_ commands that may be used to define
    the characteristics of a domain to be translated by `micca`.
*****

[float]
==== Implementation

(((micca,operation,configure)))
[source,tcl]
----
<<micca configuration>>=
operation configure {script} {
    return [@Config@::miccaConfigure $script]
}
----

=== ConfigureFromChan

It is often convenient to obtain the +configure+ script from an I/O channel.
The +micca configureFromChan+ command supports reading the configure
script directly from a channel.

*****
+::micca configureFromChan+ _channel_

+channel+::
    A Tcl channel handle that has been opened for reading.

The `configureFromChan` command invokes `configure` on the script
obtained by reading _channel_ until end of file is reached.
*****

[float]
==== Implementation

(((micca,operation,configureFromChan)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromChan {chan} {
    return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
}
----

=== ConfigureFromFile

It is often convenient to hold the +configure+ script in a file.
The +micca configureFromFile+ command supports reading the configure
script directly from a file.

*****
+::micca configureFromFile+ _filename_

+filename+::
    The name of a file containing a domain configuration script.

The `configureFromFile` command invokes `configure` on the script
obtained by reading the contents of the file named, _filename_.
*****

[float]
==== Implementation

(((micca,operation,configureFromFile)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromFile {filename} {
    set chan [::open $filename r]
    try {
        return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
    } finally {
        ::chan close $chan
    }
}
----

== Configuration Namespace Layout

The +::micca::@Config@+ namespace holds all the procedures and data that
correspond to the DSL to populate the platform model.
We will create a set of child namespaces that mirror the nesting of the
configuration language statements.
At the top level,
the +domain+ command is used to define each domain.
The +domain+ command accepts a script body that then defines the
components of the domain.
That script will be evaluated in a namespace where the commands that
define the domain components, _e.g._ `class` and relationship commands,
resolve appropriately.
This lets us put commands for the body specifying a particular component into a
namespace which prevents any problems of accidentally invoking commands that
are inappropriate for that context.

We will use this technique for other child namespaces that correspond to
the nesting of DSL statements.
We layout the +::micca::@Config@+ namespace as shown below.

[source,tcl]
----
<<configuration commands namespace>>=
namespace eval @Config@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    <<helper commands namespace>>

    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds} ; # <1>
    <<config data>>
    <<config commands>>

    <<domain config namespace layout>>
    <<population config namespace layout>>
}
----
<1> We are evaluating the configuration DSL inside a child namespace of
of the `micca` domain, but we are trying to populate `micca` classes.
We find it convenient to resolve commands through the main `micca` namespace
as well as others that help things along.

=== Evaluating Configuration Scripts

The top level domain operations of `micca` that configure domains
all invoke `miccaConfigure` as the common entry point into the configuration
DSL code.

[float]
==== Implementation

(((micca,Config,miccaConfigure)))
[source,tcl]
----
<<config commands>>=
proc miccaConfigure {script} {
    variable errcount
    set errcount 0

    variable configlineno
    set configlineno 1

    try {
        ral relvar eval {
            ConfigEvaluate [namespace current] $script
        }
    } on error {result} {
        # puts $::errorInfo
        HandleConfigError $result
    }

    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
CONFIG_ERRORS     {encountered %d configuration script errors}
----

You could evaluate the configuration script by simply gathering it together
and passing it to the core `namespace eval` command.
Unfortunately,
the first error that is encountered will terminate the evaluation.
This is decidedly inconvenient as you would prefer to continue on and
come up with a list of errors for the evaluation much like a
conventional language compiler does when compiling a source file.
Discovering errors one at a time is tediously unproductive.

Of course, it is possible to continue evaluating after an error but
that requires a bit more code.
We will also want to be able to evaluate scripts in different namespace
contexts as we described above.
We will accomplish all this by taking advantage of the core +::apply+ command
and its ability to execute a lambda function in a given namespace.
So given a script body and an namespace we can evaluate it as shown below.

(((micca,Config,ConfigEvaluate)))
[source,tcl]
----
<<config commands>>=
namespace export ConfigEvaluate

proc ConfigEvaluate {ns body} {
    variable evalLambda
    tailcall ::apply [concat $evalLambda [list $ns]] $body ; # <1>
}
----
<1> The `concat` command treats its arguments as a list.
On the off chance that the `ns` argument contains embedded whitespace,
we need to insure that it is treated as a single element list.
Hence the need to include the invocation of the `list` command.

The lambda function that performs the command evaluation is given below.
We hold the evaluation lambda as a piece of data.

[source,tcl]
----
<<config data>>=
variable evalLambda {{body} {
    upvar #0 ::micca::@Config@::errcount errcount ; # <1>
    upvar #0 ::micca::@Config@::configlineno configlineno
    set lineno $configlineno
    set command {}
    foreach line [split $body \n] { # <2>
        append command $line \n
        incr lineno ; # <3>
        if {[info complete $command]} {
            try {
                eval $command
            } on error {result} {
                log::error "line $configlineno: \"$result\""
                incr errcount
            }
            set command {} ; # <4>
            set configlineno $lineno
        }
    }
    return $errcount
}}
----
<1> We need to keep track of all the errors encountered and
what line of the script we are currently dealing with.
<2> We split the body along lines and then reassemble the lines
into a complete command. The +info complete+ command tells us when
we have something that has some chance of being a real command.
<3> We need to keep track of where we are in the +body+.
<4> After evaluating a command we begin to assemble another one and
set our location counter to where that command starts.

== Defining a Domain

As we described above,
the domain configuration commands will take the data in their
arguments and store it away.
After we have finished all the configuration scripts,
then the `generate` command is used to produce the ``C'' code and header files.

When configuring a domain,
we will evaluate the configuration script in the +DomainDef+ child namespace.
That namespace will define commands for all the components of the
domain.
We will use a similar arrangement for other nested aspects of
domain definitions.

=== Domain

*****
+domain+ _name_ _body_

+name+::
    The name of the domain. A domain name must be a non-empty string.
    The domain is used as a component for the file name of the generated
    code files, so domain names must be compatible with file name
    path components for the operating platform where `micca` is run.
+body+::
    A Tcl script containing invocation of the domain definition commands
    to specify the details of the domain configuration.

The `domain` command defines a domain named, _name_, and evaluates
_body_ in a context where commands in _body_ may be used to define
the characteristics of a domain.
*****

[float]
==== Implementation

(((micca,Config,domain)))
[source,tcl]
----
<<config commands>>=
proc domain {name body} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name domain
    }

    namespace upvar DomainDef DomainName DomainName ; # <1>
    set DomainName $name

    CheckDuplicate Domain Name $name ; # <2>
    Domain create Name $name

    ConfigEvaluate [namespace current]::DomainDef $body

    # At this point we have the definition of the domain and enough
    # information to tie together the class references and
    # the association definitions.
    <<domain: bind relationship references>>

    # We must also compute how polymorphic events are inherited
    # down generalization hierarchies.
    <<domain: propagate polymorphic events>>
}
----
<1> We place the domain name into a variable in the child namespace where the
context implies that all the components defined are to be part of this domain.
<2> We do not allow the +domain+ command to be invoked more than once.
To configure a domain properly we need to be able to see its entire
definition at once.

(((error code,BAD_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_NAME      {"%s" is not a valid name for a %s}
----

[[post-config-domain]]
After evaluating the domain configuration script,
it is necessary to perform some additional clean up and evaluation.
For now,
we will say that there are semantic evaluations and checks that can only
be done after the entire domain configuration script has been processed.
The reason for this lies mainly with the way the DSL script commands
were defined to make them more convenient to use when translating an XUML model.

One such action is to bind the association references to the proper
class components.
We discuss this process <<bind-relationship-references,later>>.

Polymorphic events also must be dealt with after the domain configuration
is in place.
Again we will discuss this further
<<domain-propagate-polymorphic-events,below>>.

Although we have said that domain configurations are cumulative,
clearly the need to resolve association bindings and polymorphic event
inheritance means that domain configurations cannot be split arbitrarily.
You will need to be aware that certain divisions of domain configuration
will end up separating information that is needed at the end of the
configuration process.
The most useful split in a domain is between its configuration of classes
and relationship and its population.

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-1.0 {
    Define an empty domain
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            # A domain may be empty of components.
        }
    }
    readMiccaAttribute Domain Name Name foo
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test domain-1.1 {
    Badly named domain
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain {} {}
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

== Defining Domain Components

In this section we discuss the commands that are used to define
the components of a domain.
Following our established pattern,
we define child namespaces for those domain component commands
that have a nested structure.

We start with the namespace layout for the +DomainDef+ namespace.

[source,tcl]
----
<<domain config namespace layout>>=
namespace eval DomainDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}
    <<domain config commands>>

    # Child namespaces for domain commands with additional structure
    <<class config namespace layout>>
    <<assigner config namespace layout>>
}
----

We see that there are two child namespaces defined with `DomainDef`.
These correspond to commands that have script bodies associated with them.

=== Interface

It is sometimes useful to include additional output in the header file
generated for a domain.
For example,
the domain may define operation parameters that are of a type already
defined in a header file.
That header file needs to be included in the generated header for the
domain.
The `interface` command provides a means to include arbitrary text into
the header file generated for the domain.

*****
`interface` _text_

`text`::
    Arbitrary text to be placed in the output of the generated interface file.

The `interface` command adds the string of the _text_ argument to
the interface file generated for the domain.
*****

[float]
==== Implementation

(((micca,Config,interface)))
[source,tcl]
----
<<domain config commands>>=
proc interface {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Interface $text
}
----

=== Prologue

It is also convenient to be able to include arbitrary text into the
generated code file for a domain.
The `prologue` command includes that text before any of the generated code.

*****
`prologue` _text_

`text`::
    Arbitrary text to be placed in the output code file before any generated
    code.

The `prologue` command adds the string of the _text_ argument to
the generated code file for the domain.
The `prologue` command may be invoked multiple times and the value of
all the _text_ arguments is concatenated in the order encountered.
The accumulated prologue text is emitted into the generated code file
before any `micca` generated code.
*****

[float]
==== Implementation

(((micca,Config,prologue)))
[source,tcl]
----
<<domain config commands>>=
proc prologue {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Prologue $text
}
----

=== Epilogue

The `epilogue` command includes text into the domain code file after
any generated code.
This can be use for small functions defined to handle the particulars
of user defined data types.

*****
`epilogue` _text_

`text`::
    Arbitrary text to be placed in the output code file after any generated
    code.

The `epilogue` command adds the string of the _text_ argument to
the generated code file for the domain.
The `epilogue` command may be invoked multiple times and the value of
all the _text_ arguments is concatenated in the order encountered.
The accumulated epilogue text is emitted into the generated code file
after any `micca` generated code.
*****

[float]
==== Implementation

(((micca,Config,epilogue)))
[source,tcl]
----
<<domain config commands>>=
proc epilogue {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Epilogue $text
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-2.0 {
    Define a domain with a non-empty interface
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            prologue "#include <stdio.h>"
        }
    }
    log::debug [formatMiccaClass Domain]
    string trimright [readMiccaAttribute Domain Prologue Name foo]
} -result {#include <stdio.h>}
----

==== Append To Domain Attribute

The operations for the `interface`, `prologue` and `epilogue` commands
can be factored into common code.

[float]
==== Implementation

(((micca,Config,AppendToDomainAttribute)))
[source,tcl]
----
<<domain config commands>>=
proc AppendToDomainAttribute {domainname attrname text} {
    set domref [Domain findById Name $domainname]
    withAttribute $domref $attrname {
        set value [set $attrname]
        if {$value ne {} && [string index $value end] ne "\n"} {
            append $attrname \n ; # <1>
        }
        append $attrname $text
    }
    return
}
----
<1> We make sure that the text appended to the domain attribute is done
as a line. In case the previous line didn't have a new line in it,
we will add one.
This will prevent any problems where continuing on the same line
could be misinterpreted.

=== Class

The class command is used to define classes and specify their characteristics.

*****
+class+ _name_ _script_

+name+::
    The name of the class. A class name must be a valid ``C'' identifier.
+script+::
    A Tcl script containing invocations of the class definition commands
    to specify the details of the class configuration.

The `class` command defines a class named, _name_, and evaluates _script_
to configure the class.
Class definitions are open ended and extensible.
If the `class` command is invoked on a previously defined class,
then any additional configuration is added to the definition of the class.
*****

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<domain config commands>>=
proc class {name body} {
    variable DomainName ; # <1>

    if {[isEmptyRef [DomainElement findById Domain $DomainName Name $name]]} {# <2>
        DomainElement create Domain $DomainName Name $name
        Class create Domain $DomainName Name $name\
            Number [GenNumber $DomainName Class [list $DomainName]]
        ValueElement create Domain $DomainName Name $name
    }

    namespace upvar ClassDef ClassName ClassName ; # <3>
    set ClassName $name
    ConfigEvaluate [namespace current]::ClassDef $body

    return
}
----
<1> We have arranged for a namespace variable to hold the current
domain context.
This is a convenient way to pass the domain name to where it is needed
by the configuration commands.
<2> We allow the `class` command to be invoked multiple times with the
same name.
This makes extending class definitions (_e.g._ adding a state model to
a class) much easier.
<3> Provide the class name to the body of the class definition script.

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test class-1.0 {
    Define class with a bad name
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class @%x {}
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

=== Association

The +association+ command is used to define both simple and class based
associations depending upon arguments.
In the `association` command we use some syntax conventions to mirror
the UML graphical notation to make the clerical aspects of the
translation easier.

*****
`association` _name_  _?option value ...?_ _source_ _spec_ _target_ ?_script_?

`name`::
    The name of the association. Conventionally, relationships names are of the
    form *R<d>* where _<d>_ is one or more decimal digits but any
    non-empty string which does not start with a tilde (\~) can be used.
`option value ...`::
    Options to the `association` command are given as argument
    option / value pairs:
    Valid options and their values are:
    `-associator` _class_:::
    The `-associator` option defines the association to be
    *class based* and specifies _class_ as the association class.
`source`::
    The name of the class that defines the starting class for a forward
    traversal of the relationship.
`spec`::
    The specifier of the relationship conditionality and multiplicity.
    The _spec_ argument is one of the following strings.
    We allow two forms for some of the specifiers.
    The first form follows UML notation and the second form follows
    TclRAL notation which is patterned after regular expression notation.
        `1--1`:::
            The association is _one to one_.
        `0..1--1` or `?--1`:::
            The association is _at most one to one_.
        `0..1--0..1` or `?--?`:::
            The association is _at most one to at most one_.
        `1..*--1` or `+--1`:::
            The association is _one or more to one_.
        `0..*--1` or `*--1`:::
            The association is _zero or more to one_.
        `1..*--0..1` or `+--?`:::
            The association is _one or more to at most one_.
        `0..*--0..1` or `*--?`:::
            The association is _zero or more to at most one_.
        `1..*--1..*` or `+--+`:::
            The association is _one or more to one or more_.
        `0..*--1..*` or `*--+`:::
            The association is _zero or more to one or more_.
        `1..*--0..*` or `+--*`:::
            The association is _one or more to zero or more_.
        `0..*--0..*` or `*--*`:::
            The association is _zero or more to zero or more_.
`target`::
    The name of the class that defines the ending class for a forward
    traversal of the relationship.
`script`::
    An optional _script_ that is evaluated to define an assigner on the
    association.

The `association` command defines an association relationship between a
_source_ class and a _target_class_.
The forward direction of navigating the relationship is from _source_
to _target_.
The conditionality and multiplicity of the association is given by the
_spec_ argument.
A class based association is indicated by the `-associator` option.
The association command may have an optional _script_ argument that is
used to define an assigner on the association.
*****

In the command,
we are using the _spec_ string to encode several distinct pieces of information.
Each different association specifier implies the conditionality,
multiplicity and other properties of the association.
We encode those properties in data whose identifier is the _spec_ string
itself.

[source,tcl]
----
<<config data>>=
# Since we allow two different techniques to identify the association
# specifics, we will factor away the specification data from its name.
relvar create Config_AssocSpec {
    SpecName    string
    SpecID      string
} SpecName

relvar create Config_SpecDetail {
    SpecID              string
    NeedsAssociator     boolean
    ReflexiveAllowed    boolean
    ReferringCond       boolean
    ReferringMult       boolean
    ReferencedCond      boolean
    ReferencedMult      boolean
} SpecID

relvar association C1\
    Config_AssocSpec SpecID +\
    Config_SpecDetail SpecID 1

relvar eval {
    relvar insert Config_AssocSpec {
        SpecName    1--1
        SpecID      sp0
    } {
        SpecName    0..1--1
        SpecID      sp1
    } {
        SpecName    ?--1
        SpecID      sp1
    } {
        SpecName    0..1--0..1
        SpecID      sp2
    } {
        SpecName    ?--?
        SpecID      sp2
    } {
        SpecName    1..*--1
        SpecID      sp3
    } {
        SpecName    +--1
        SpecID      sp3
    } {
        SpecName    0..*--1
        SpecID      sp4
    } {
        SpecName    *--1
        SpecID      sp4
    } {
        SpecName    1..*--0..1
        SpecID      sp5
    } {
        SpecName    +--?
        SpecID      sp5
    } {
        SpecName    0..*--0..1
        SpecID      sp6
    } {
        SpecName    *--?
        SpecID      sp6
    } {
        SpecName    1..*--1..*
        SpecID      sp7
    } {
        SpecName    +--+
        SpecID      sp7
    } {
        SpecName    0..*--1..*
        SpecID      sp8
    } {
        SpecName    *--+
        SpecID      sp8
    } {
        SpecName    1..*--0..*
        SpecID      sp9
    } {
        SpecName    +--*
        SpecID      sp9
    } {
        SpecName    0..*--0..*
        SpecID      sp10
    } {
        SpecName    *--*
        SpecID      sp10
    }

    relvar insert Config_SpecDetail {
        SpecID sp0  NeedsAssociator false ReflexiveAllowed true
            ReferringCond false ReferringMult false
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp1 NeedsAssociator false ReflexiveAllowed false
            ReferringCond true ReferringMult false
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp2 NeedsAssociator false ReflexiveAllowed true
            ReferringCond true ReferringMult false
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp3 NeedsAssociator false ReflexiveAllowed true
            ReferringCond false ReferringMult true
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp4 NeedsAssociator false ReflexiveAllowed false
            ReferringCond true ReferringMult true
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp5 NeedsAssociator false ReflexiveAllowed false
            ReferringCond false ReferringMult true
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp6 NeedsAssociator false ReflexiveAllowed true
            ReferringCond true ReferringMult true
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp7 NeedsAssociator true ReflexiveAllowed true
            ReferringCond false ReferringMult true
            ReferencedCond false ReferencedMult true
    } {
        SpecID sp8 NeedsAssociator true ReflexiveAllowed false
            ReferringCond true ReferringMult true
            ReferencedCond false ReferencedMult true
    } {
        SpecID sp9 NeedsAssociator true ReflexiveAllowed false
            ReferringCond false ReferringMult true
            ReferencedCond true ReferencedMult true
    } {
        SpecID sp10 NeedsAssociator true ReflexiveAllowed true
            ReferringCond true ReferringMult true
            ReferencedCond true ReferencedMult true
    }
}
----

[float]
===== Implementation

Like most of the commands in the configuration language,
the bulk of the code is involved with populating the relvars
holding the essential data provided in the command arguments.
For the `association` command,
there is some argument parsing to determine whether the association
is simple or class based.
Then it is a matter of filling in the correct information based on the
type of the association.

(((micca,Config,association)))
[source,tcl]
----
<<domain config commands>>=
proc association {name args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME association
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    if {[llength $args] < 3} {
        tailcall DeclError ASSOC_OPTIONS $args
    }

    set associator {}
    while {1} {
        set arg [lindex $args 0]

        if {$arg eq "-associator"} {
            set associator [lindex $args 1]
            set args [lrange $args 2 end]
        } elseif {$arg eq "--"} {
            break
            set args [lrange $args 1 end]
        } else {
            break
        }
    }
    if {[llength $args] < 3 || [llength $args] > 4} {
        tailcall DeclError ASSOC_OPTIONS $args
    }
    lassign $args source spec target script

    # Obtain references to the domain name
    variable DomainName

    <<association: check arguments>>

    # Many relvars have tuples with the same heading, so we construct it
    # once here.
    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple

    # Populate the data for a Relationship and Association since that
    # is what this command defines.
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Association create {*}$reltuple

    # Populate the type of association we are dealing with.
    if {$associator eq {}} {
        <<association: populate simple association>>
    } else {
        <<association: populate class based association>>
    }

    if {$script ne {}} {
        namespace upvar ClassDef ClassName ClassName
        set ClassName $name

        namespace upvar AssignerDef IdClassName IdClassName
        set IdClassName {}

        ConfigEvaluate [namespace current]::AssignerDef $script
    }

    return
}
----

(((error code,TILDE_NAME)))
(((error code,ASSOC_OPTIONS)))
[source,tcl]
----
<<error code formats>>=
TILDE_NAME {names beginning with the tilde character are not allowed\
    in this context, "%s"}
ASSOC_OPTIONS {association options error, expected\
    "?-associator <class>? source spec target ?script?", got "%s"}
----

Here we use the data that we supplied above to make sure the
`spec` association specifier and the supplied arguments make sense together.
Certain forms of reflexiveness are not allowed and certain specifiers
imply that you must define a class based association.
Such rules are easier to express in data rather than long sequences
of checking code.

[source,tcl]
----
<<association: check arguments>>=
set csd [pipe {
    relvar restrictone ::micca::@Config@::Config_AssocSpec SpecName $spec |
    relation semijoin ~ [relvar set ::micca::@Config@::Config_SpecDetail]
}]
if {[relation isempty $csd]} {
    tailcall DeclError BAD_RELATIONSHIP_SPEC $spec
}
relation assign $csd
if {$NeedsAssociator && $associator eq {}} {
    tailcall DeclError NEED_ASSOCIATOR $spec
}
if {$source eq $target && !$ReflexiveAllowed} {
    tailcall DeclError REFLEXIVE_NOT_ALLOWED $spec
}
----

(((error code,BAD_RELATIONSHIP_SPEC)))
(((error code,NEED_ASSOCIATOR)))
(((error code, REFLEXIVE_NOT_ALLOWED)))
[source,tcl]
----
<<error code formats>>=
BAD_RELATIONSHIP_SPEC  {bad relationship specifier, "%s"}
NEED_ASSOCIATOR {relationship of type, "%s", requires associative class}
REFLEXIVE_NOT_ALLOWED   {associations of type, "%s", cannot be reflexive}
----

For simple associations,
the `association` command arguments supply what we need and we
perform a series of inserts into the platform data model.

[source,tcl]
----
<<association: populate simple association>>=
SimpleAssociation create {*}$reltuple

SimpleReferringClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source\
    Conditionality  $ReferringCond\
    Multiplicity    $ReferringMult
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
ClassRole create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source

SimpleReferencedClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target\
    Conditionality  $ReferencedCond
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
ClassRole create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
----

For class based associations we have a few more class instances to create
as we populate that branch of the `micca` platform model.

[source,tcl]
----
<<association: populate class based association>>=
ClassBasedAssociation create {*}$reltuple

SourceClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source\
    Conditionality  $ReferringCond\
    Multiplicity    $ReferringMult
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
ClassRole create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source

TargetClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target\
    Conditionality  $ReferencedCond\
    Multiplicity    $ReferencedMult
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
ClassRole create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target

AssociatorClass create\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator
ClassRole create\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator
# We create the class component that will hold the associator class reference
# pointers here. This relationship is unconditional in the micca platform
# model, so we need to create the related instances while we have all the
# information.
AssociatorReference create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
Reference create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
ClassComponent create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test association-1.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class x {
                attribute a1 string
                attribute a2 string
            }
            class y {
                attribute a1 string
            }
            association R10 y 1--1 x
        }
    }
    log::debug [formatMiccaClass SimpleAssociation]
    log::debug [formatMiccaClass SimpleReferringClass]
    log::debug [formatMiccaClass SimpleReferencedClass]
    testConditions\
        {[refMultiplicity [SimpleAssociation findAll]] == 1}\
        {[refMultiplicity [SimpleReferringClass findAll]] == 1}\
        {[refMultiplicity [SimpleReferencedClass findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test association-2.0 {
    Define class based association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class a {
                attribute a1 string
            }
            class e {
                attribute a1 string
                attribute a2 string
            }
            class f {
                attribute a1 string
            }
            association R11 -associator a f 1..*--1..* e
        }
    }
    log::debug [formatMiccaClass AssociatorClass]
    log::debug [formatMiccaClass AssociatorReference]
    log::debug [formatMiccaClass SourceClass]
    log::debug [formatMiccaClass TargetClass]
    testConditions\
        {[refMultiplicity [AssociatorClass findAll]] == 1}\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [SourceClass findAll]] == 1}\
        {[refMultiplicity [TargetClass findAll]] == 1}
} -result {1}
----

=== Generalization

Defining a generalization relationship is quite a bit simpler than
the effort we just saw in defining associations.
For generalizations,
it is necessary to specify the superclass and the set of subclasses.
The only complexity is that `micca` allows two choices for how to
store subclasses of a generalization.
The simplest is to use references to store the relationship pointers
in much the same manner as used for associations.
Because of the nature of a generalization relationship,
the other possibility is to store the subclass as a discriminated union.
The alternatives are specified as options to the generalization command.

*****
`generalization` _name_ _?-union | -reference?_ _super_ _sub1_ _sub2_ _?...?_

`name`::
    The name of the generalization. Conventionally, relationships names are of
    the form *R<d>* where _<d>_ is one or more decimal digits but any non-empty
    string can be used.
`-union | -reference`::
    An option to specify if subclasses of the generalization are to be
    held as a discriminated union in the same structure as the superclass
    or held in separate storage having the relationship navigation implemented
    using reference pointers.
    If no option is given, the `-reference` is assumed.
`super`::
    The name of the class that serves as the superclass of the generalization.
`subN`::
    The names of the classes that serve as the subclasses of the generalization.
    You must specify at least two subclasses to define a generalization.
*****

[float]
==== Implementation

(((micca,Config,generalization)))
[source,tcl]
----
<<domain config commands>>=
proc generalization {name args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME generalization
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    set type reference
    while {1} {
        set args [lassign $args arg]

        if {$arg eq "-reference"} {
            set type reference
        } elseif {$arg eq "-union"} {
            set type union
        } else {
            set super $arg
            break
        }
    }

    if {[llength $args] < 2} {
        tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
    }
    if {$super in $args} {
        tailcall DeclError SUPER_AS_SUBCLASS $super [join $args {, }]
    }
    if {[llength [lsort -unique $args]] != [llength $args]} {
        tailcall DeclError DUPLICATE_SUBCLASS $args
    }

    variable DomainName

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]

    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Generalization create {*}$reltuple

    set supertuple [list\
        Domain          $DomainName\
        Class           $super\
        Relationship    $name\
        Role            target\
    ]
    set subtuple [dict create\
        Domain          $DomainName\
        Relationship    $name\
        Role            source\
    ]
    if {$type eq "reference"} {
        ReferenceGeneralization create {*}$reltuple
        ReferencedSuperclass create {*}$supertuple
        foreach sub $args {
            dict set subtuple Class $sub
            ReferringSubclass create {*}$subtuple
        }
    } elseif {$type eq "union"} {
        UnionGeneralization create {*}$reltuple
        UnionSuperclass create {*}$supertuple
        SubclassContainer create Domain $DomainName Class $super Name $name ; # <1>
        ClassComponent create Domain $DomainName Class $super Name $name
        foreach sub $args {
            dict set subtuple Class $sub
            UnionSubclass create {*}$subtuple
        }
    }
    Superclass create {*}$supertuple
    ClassRole create {*}$supertuple

    foreach sub $args {
        dict set subtuple Class $sub
        Subclass create {*}$subtuple
        ClassRole create {*}$subtuple
    }

    return
}
----
<1> For union based subclass storage,
we create the container as a class component in the superclass.
This is done here since we have the information and the R96 relationship is
unconditional.
Union superclasses always have a subclass container.

(((error code,TOO_FEW_SUBCLASSES)))
(((error code,SUPER_AS_SUBCLASS)))
(((error code,DUPLICATE_SUBCLASS)))
[source,tcl]
----
<<error code formats>>=
TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
SUPER_AS_SUBCLASS   {super class, "%s", cannot be included in subclasses, "%s"}
DUPLICATE_SUBCLASS  {subclass set contains a duplicate subclass name, "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-1.0 {
    Define reference generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int
            }
            generalization R1 -reference super sub1 sub2
        }
    }
    log::debug [formatMiccaClass ReferenceGeneralization]
    log::debug [formatMiccaClass ReferencedSuperclass]
    log::debug [formatMiccaClass ReferringSubclass]
    testConditions\
        {[refMultiplicity [ReferenceGeneralization findAll]] == 1}\
        {[refMultiplicity [ReferencedSuperclass findAll]] == 1}\
        {[refMultiplicity [ReferringSubclass findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test generalization-2.0 {
    Define union generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class usuper {
                attribute sid int
            }
            class usub1 {
                attribute sid int
            }
            class usub2 {
                attribute sid int
            }
            generalization R2 -union usuper usub1 usub2
        }
    }
    log::debug [formatMiccaClass UnionGeneralization]
    log::debug [formatMiccaClass UnionSuperclass]
    log::debug [formatMiccaClass UnionSubclass]
    log::debug [formatMiccaClass SubclassContainer]
    testConditions\
        {[refMultiplicity [UnionGeneralization findAll]] == 1}\
        {[refMultiplicity [UnionSuperclass findAll]] == 1}\
        {[refMultiplicity [UnionSubclass findAll]] == 2}\
        {[refMultiplicity [SubclassContainer findAll]] == 1}
} -result {1}
----

=== Type Alias

*****
`typealias` _name_ _definition_

`name`::
    The name of the type alias.
`definition`::
    A ``C'' typename.

The `typealias` command defines an alias _name_ for a ``C'' typename given
by, _definition_.
Type alias helps map model level type information to ``C'' `typedef` statements
that are included in the generated code.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc typealias {aliasname typename} {
    variable DomainName
    TypeAlias create Domain $DomainName TypeName $aliasname\
        TypeDefinition $typename

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typealias-1.0 {
    Define a type alias
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            typealias rawbyte uint8_t
        }
    }
    log::debug [formatMiccaClass TypeAlias]
    readMiccaAttribute TypeAlias TypeDefinition Domain foo TypeName rawbyte
} -result {uint8_t}
----

=== Domain Operation

The `domainop` command is used to define domain operations.
The set of domain operations defined for a domain constitute the
external callable interface to the domain.
Typically, domain operations are defined to allow other domains
to access major services of the domain.

*****
`domainop` _rettype_ _name_ _parameters_ _body_

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the domain operation.
`name`::
    The name of the domain operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the domain operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
*****

[float]
==== Implementation

(((micca,Config,domainop)))
[source,tcl]
----
<<domain config commands>>=
proc domainop {rettype name parameters body} {
    variable DomainName

    DomainOperation create Domain $DomainName Name $name Body $body\
        ReturnDataType $rettype
    set paramtuple [dict create Domain $DomainName Operation $name]
    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName DomainOperationParameter\
                [list $DomainName $name]]
        DomainOperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domainop-1.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }
        }
    }
    log::debug [formatMiccaClass DomainOperation]
    log::debug [formatMiccaClass DomainOperationParameter]
    testConditions\
        {[refMultiplicity [DomainOperation findAll]] == 1}\
        {[refMultiplicity [DomainOperationParameter findAll]] == 2}\
} -result {1}
----

== Defining Class Components

Since there are several aspects of classes,
the +class+ command takes a _script_ argument which should
invoke the commands we discuss in this section.
Following our pattern,
we define a namespace where the class body script is evaluated.

[source,tcl]
----
<<class config namespace layout>>=
namespace eval ClassDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class config commands>>

    <<state model config namespace layout>>
}
----

=== Attribute

Within a class definition,
the `attribute` command specifies the attributes of the class.
In this context,
attributes are a slightly different concept than the attributes
seen on a class diagram.
As part of the translation process,
some attributes found on the XUML class diagram are elided from
the implementation.
For example,
attributes that are used solely for referential or identifying purposes
need not be included as attributes in the implementation.
This is because the translation is using the address of a class
instance as an architecturally supplied identifier and in implementing
relationship traversal.
So the attributes defined here are descriptive in nature and define
the logical parameters of the class rather than the structural aspects
of the class.

*****
`attribute` _name_ _type_ ? `-default` _value_ ?

`name`::
    The name of the attribute. Attributes names may not be the empty string.
`type`::
    The type of the attribute. The _type_ may be any valid ``C'' type name.
`-default` _value_::
    If specified, the `-default` option specifies a default value for the
    attribute. If no value is supplied when a class instance is created
    or populated, then the default value is used.
*****

The implementation of the `attribute` command simply creates tuples
in the relvars to hold the attribute characteristics.

[float]
==== Implementation

(((micca,Config,attribute)))
[source,tcl]
----
<<class config commands>>=
proc attribute {name type args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME attribute
    }
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    Attribute create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name\
        DataType    $type
    ClassComponent create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name

    if {[llength $args] > 2} {
        tailcall DeclError ATTRIBUTE_OPTIONS $args
    } elseif {[llength $args] == 2} {
        lassign $args option defvalue
        if {$option ne "-default"} {
            tailcall DeclError UNKNOWN_OPTION attribute $option
        } else {
            DefaultValue create\
                Domain      $DomainName\
                Class       $ClassName\
                Attribute   $name\
                Value       $defvalue
        }
    }
}
----

(((error code,ARG_FORMAT)))
(((error code,ATTRIBUTE_OPTIONS)))
[source,tcl]
----
<<error code formats>>=
ARG_FORMAT      {options and values must come in pairs, got "%s"}
ATTRIBUTE_OPTIONS {attribute options error, expected "-default <value>",\
            got "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test attribute-1.0 {
    Define class with attributes
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20
            }
            class c2 {
                attribute b1 uint8
                attribute b2 float
            }
        }
    }
    log::debug [formatMiccaClass Attribute]
    log::debug [formatMiccaClass DefaultValue]
    testConditions\
        {[refMultiplicity [Attribute findAll]] == 4}\
        {[refMultiplicity [DefaultValue findAll]] == 1}
} -result {1}
----

=== Reference

The `reference` command defines the paths along a association by
which related class instances may be found by navigating the
relationship.
Any processing associated with a class that intends to navigate
a particular relationship must include a `reference` command
for that relationship which specifies the characteristics of how
reference pointers are stored to enable the navigation.

*****
`reference` _relationship_ ?_option value_ ...?

`relationship`::
    The name of an association or generalization in which the class
    participates and for which pointer storage for navigation is to be
    allocated.

`option value`::
    Option / value pairs define additional characteristics of the reference.
    Valid options are:
    `-path forward | backward`::
        When an association is reflexive, _i.e._ the source and target
        classes are the same class,
        the `-path` option must be given to indicated if the navigation
        is `forward` from source to target or `backward` from target to source.
        Multiple `-path` options may be given if both forward and backward
        traversal of the association is needed.

The `reference` command defines the intent to navigate from the class
along _relationship_ and defines the characteristics of storage needed
to support that navigation.
*****

[float]
==== Implementation

The definitions of relationship, both associations and generalizations,
and the definitions of how relationship information is to be stored
to support navigating the relationship are intertwined.
We have made the decision to allow the DSL to specify relationships
and references separately and in an arbitrary order.
That decision has two consequences:

. Information must be temporarily stored away outside of the platform model
to support completing the population of the model at a time
when all the required data is available.
For example,
it is possible to specify a reference to a relationship before the
relationship is defined.
It is not possible, in this case, to directly populate the platform
model as there is not enough information about the relationship.
. At an appropriate time in the domain definition,
we must process the temporary information to link up the relationship
definitions to the storage requirements for the reference pointers.
We discuss this processing <<bind-relationship-references,later>>.

Here we consider the information that must be accumulated about the
references. The following relvar captures the information contained in
a `reference` command invocation.

[source,tcl]
----
<<config data>>=
relvar create Class_Reference {
    Domain              string
    Class               string
    Relationship        string
    Role                string
} {Domain Class Relationship Role}
----

As we see below,
the implementation for the `reference` command simply adds tuples to
the above relvar after validating the arguments to the command.

(((micca,Config,reference)))
[source,tcl]
----
<<class config commands>>=
proc reference {relname args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    set role {}

    foreach {option value} $args {
        switch -exact -- $option {
            -path {
                if {$value ni {forward backward}} {
                    tailcall DeclError BAD_PATH $value
                }
                set role [expr {$value eq "forward" ? "source" : "target"}]
            }
            default {
                tailcall DeclError UNKNOWN_OPTION reference $option
            }
        }
    }

    relvar insert ::micca::@Config@::Class_Reference [list\
        Domain              $DomainName\
        Class               $ClassName\
        Relationship        $relname\
        Role                $role\
    ]
}
----

(((error code,BAD_PATH)))
[source,tcl]
----
<<error code formats>>=
BAD_PATH        {unknown path value, "%s": should be forward or backward}
----


[float]
==== Binding Relationship References
[[bind-relationship-references]]
At the end of running a domain configuration script,
_i.e._ at the end of the `domain` commmand,
we  have all the information needed to link up the relationship
definitions with the references made by the participating classes.
The code below is run at the end of the processing in a `domain` command.
The goal is to turn any navigation references into Class Components that are
used to store class pointers that implement the relationship navigation.

Algorithmically, we simply iterate over each instance of `Class_Reference`
that was created by the invocations of the `reference` command.

[source,tcl]
----
<<domain: bind relationship references>>=
upvar #0 ::micca::@Config@::errcount errcount
set class_references [pipe {
    relvar set Class_Reference |
    relation restrict ~ crtup {[tuple extract $crtup Domain] eq $DomainName}
}]
relation foreach ref $class_references {
    <<domain: link one reference>>
}
----

The first item of business is to deal with reflexive associations.
If an association is reflexive,
then there will be two instances of *Class Role*,
one for its role as the source of navigation and the other as the target.
If the `reference` command was invoked with a `-path` option,
then the *Role* attribute will have the value of either `source` or
`target` and we can use that to select a particular instance of *Class Role*.
Otherwise, we select *Class Role* instances based on the information
we have, without resorting to its role.
In either case we need to find the set of *Class Role* instances
associated with the relationship.
That is accomplished as shown below

[source,tcl]
----
<<domain: link one reference>>=
relation assign $ref {Domain refDomain} {Class refClass}\
    {Relationship refRelationship} {Role refRole}
if {$refRole ne {}} {
    set crref [ClassRole findById Domain $refDomain Class $refClass\
        Relationship $refRelationship Role $refRole]
} else {
    set crref [ClassRole findWhere {$Domain eq $refDomain &&\
        $Class eq $refClass && $Relationship eq $refRelationship}]
}
----

The first case we come upon is whether the relationship specified in
the `reference` command was correct.
It's possible that the class being configured by the `reference` command
does not even participate in the relationship.

[source,tcl]
----
<<domain: link one reference>>=
if {[isNotEmptyRef $crref]} {
    <<domain: resolve class role>>
} else {
    error "in domain, \"$refDomain\", class, \"$refClass\",\
        does not participate in relationship, \"$refRelationship\""
}
----

Next we must determine if the relationship was reflexive but no
path information was given.
This is the circumstance where we find multiple class roles with
no way to distinguish them.

[source,tcl]
----
<<domain: resolve class role>>=
if {[isRefSingular $crref]} {
    <<domain: resolve single class role>>
} else {
    error "in domain, \"$refDomain\", relationship, \"$Relationship\",\
        is reflexive for\ class, \"$Class\", and no \"-path\"\
        option was specified"
}
----

Now we can deal with the various cases that arise from *R40* in
the platform model.
There are three cases where a reference is appropriate,
an association, a reference superclass and a reference subclass.
Reference statements for union generalizations are not necessary
since navigating a generalization stored as a union can be accomplished
by pointer arithmetic.
The code below is structured into procedures that examine each type
of relationship.
The procedures return true if they successfully resolved the reference.

[source,tcl]
----
<<domain: resolve single class role>>=
if {[ResolveParticipantReference $crref]} {
    continue
}
if {[ResolveSuper $crref]} {
    continue
}
if {[ResolveSub $crref]} {
    continue
}
# For associator references we have already created the necessary
# class components when the association defined.
set assocref [findRelated $crref {~R40 AssociatorClass}]
if {[isNotEmptyRef $assocref]} {
    continue
}
log::warn "in domain, \"$refDomain\", class, \"$refClass\",\
    reference for relationship, \"$refRelationship\", is ignored:\
    may be part of a union generalization"
----

==== Resolving Association References

Association references are the most complicated because they come in the
widest variety of types and storage choices.
We structure the code in the same way as above,
using a separate procedure for each possible case of navigating *R38*
in the platform model.

(((micca,Helpers,ResolveParticipantReference)))
[source,tcl]
----
<<config commands>>=
proc ResolveParticipantReference {crref} {
    set apcref [findRelated $crref {~R40 AssociationParticipantClass}] ; # <1>
    if {[isEmptyRef $apcref]} {
        return false
    }

    # Now try each of the four cases stemming from R38
    if {[ResolveSimpleReferring $apcref]} {
        return true
    }
    if {[ResolveSimpleReferenced $apcref]} {
        return true
    }
    if {[ResolveSource $apcref]} {
        return true
    }
    if {[ResolveTarget $apcref]} {
        return true
    }
    return false
}
----
<1> First we must check if the Class Role instance is related to an
Association Participant Class.

A Simple Referring Class role always has a singular reference to its
related instance.

(((micca,Helpers,ResolveSimpleReferring)))
[source,tcl]
----
<<config commands>>=
proc ResolveSimpleReferring {apcref} {
    set srcref [findRelated $apcref {~R38 SimpleReferringClass}]
    if {[isEmptyRef $srcref]} {
        return false
    }
    assignAttribute $srcref
    CreateDirectionalReference $Domain $Class $Relationship $Role singular
    return true
}
----

In the case of a reflexive association,
there will be multiple instances of Direction Reference related to the
same instance of Association Reference.
Hence it is necessary to test if we need to create the Association Reference
instance as we may have been through this code path before when dealing
with the other direction of the reflexive association.

(((micca,Helpers,CreateDirectionalReference)))
[source,tcl]
----
<<config commands>>=
proc CreateDirectionalReference {domain class relationship role type} {
    set drref [DirectionalReference create Domain $domain Class $class\
            Name $relationship Role $role ReferenceType $type]
    if {[isEmptyRef [findRelated $drref R25]]} {
        AssociationReference create Domain $domain Class $class\
            Name $relationship
        Reference create Domain $domain Class $class Name $relationship
        ClassComponent create Domain $domain Class $class Name $relationship
    }
    return
}
----

For a Simple Referenced Class,
it is possible to refer to multiple instances.
We will assume all multiple references are dynamic.
Later during domain population,
we can determine if the reference is static and if so, we will
update the *ReferenceType* attribute

(((micca,Helpers,ResolveSimpleReferenced)))
[source,tcl]
----
<<config commands>>=
proc ResolveSimpleReferenced {apcref} {
    set srcref [findRelated $apcref {~R38 SimpleReferencedClass}]
    if {[isEmptyRef $srcref]} {
        return false
    }
    # Find multiplicity in Simple Referring Class
    set targetref [findRelated $srcref R33 ~R32]
    assignAttribute $targetref Multiplicity {Class target}

    CreateAssociationReferences $srcref $Multiplicity $target

    return true
}
----

We can factor all the heavy lifting for creating all the different
types platform model instances into a single procedure.
In the end,
we are creating pointer storage components to point from a source class
to a target class.

(((micca,Helpers,CreateAssociationReferences)))
[source,tcl]
----
<<config commands>>=
proc CreateAssociationReferences {srcref multiplicity target} {
    assignAttribute $srcref Domain Class Relationship Role

    CreateDirectionalReference $Domain $Class $Relationship $Role\
        [expr {$multiplicity ? "dynamic" : "singular"}]
}
----

For classes that serve a Source Class role,
we encounter how to deal with class based associations.
It may be helpful to recall the way class based associations are
<<class-base-association-conventions,decomposed>>.
This effectively causes us to use the multiplicity from the Target Class
side of the association to control the storage on the Source Class side
and _vice versa_.
We also have to find the Associator Class since that is the class
to which the references will point.

(((micca,Helpers,ResolveSource)))
[source,tcl]
----
<<config commands>>=
proc ResolveSource {apcref} {
    set scref [findRelated $apcref {~R38 SourceClass}]
    if {[isEmptyRef $scref]} {
        return false
    }
    set cbaref [findRelated $scref R34]
    set multiplicity [readAttribute [findRelated $cbaref ~R35] Multiplicity]
    set assocclass [readAttribute [findRelated $cbaref ~R42] Class]

    CreateAssociationReferences $scref $multiplicity $assocclass

    return true
}
----

The same reasoning applies to Target Classes.
We find the multiplicity from the Source Class attributes and we need
to know the Associator Class since that is where the references point.

(((micca,Helpers,ResolveTarget)))
[source,tcl]
----
<<config commands>>=
proc ResolveTarget {apcref} {
    set tcref [findRelated $apcref {~R38 TargetClass}]
    if {[isEmptyRef $tcref]} {
        return false
    }
    set cbaref [findRelated $tcref R35]
    set multiplicity [readAttribute [findRelated $cbaref ~R34] Multiplicity]
    set assocclass [readAttribute [findRelated $cbaref ~R42] Class]

    CreateAssociationReferences $tcref $multiplicity $assocclass

    return true
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test reference-1.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1
            }
            class c2 {
                attribute b1 uint8
                attribute b2 float

                reference R1
            }

            association R1 c1 1..*--1 c2
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass DirectionalReference]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 2}\
        {[refMultiplicity [DirectionalReference findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-2.0 {
    Define class with singular reflexive association reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 -path forward
                reference R1 -path backward
            }

            association R1 c1 0..1--0..1 c1
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass DirectionalReference]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 1}\
        {[refMultiplicity [DirectionalReference findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-2.1 {
    Define class with many to many reflexive association reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 -path forward
                reference R1 -path backward
            }
            class a {}

            association R1 -associator a c1 0..*--0..* c1
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass DirectionalReference]
    log::debug [formatMiccaClass AssociatorReference]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 1}\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [DirectionalReference findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-2.2 {
    Define class with multiple reflexive association reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 -path forward
                reference R1 -path backward
            }

            association R1 c1 1..*--1 c1
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass DirectionalReference]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 1}\
        {[refMultiplicity [DirectionalReference findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-3.0 {
    Define class many to many association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1
            }
            class c2 {
                attribute a1 int
                attribute b1 float

                reference R1
            }
            class a {
            }

            association R1 -associator a c1 0..*--1..* c2
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass DirectionalReference]
    log::debug [formatMiccaClass AssociatorReference]
    testConditions\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [AssociationReference findAll]] == 2}\
        {[refMultiplicity [DirectionalReference findAll]] == 2}
} -result {1}
----

==== Resolving Generalization References

Generalization references are much easier to resolve that those for
associations.
Because a generalization relationship is one-to-one we need only hold
single pointers for the references.
The only minor complication is that references from a superclass to a subclass
need to also store an indication of which subclass the superclass is
currently related.
This saves searching the various subclass storage arrays for the related
instance.
That minor twist is handled by have superclass with a Subclass Reference
type of Class Component.
The Subclass Reference component will be turned into two structure members
at code generation time.

For a Referenced Superclass,
we need only create a Subclass Reference instance.

(((micca,Helpers,ResolveSuper)))
[source,tcl]
----
<<config commands>>=
proc ResolveSuper {crref} {
    set rscref [findRelated $crref {~R40 Superclass} {~R46 ReferencedSuperclass}]
    if {[isEmptyRef $rscref]} {
        return false
    }

    assignAttribute $rscref
    SubclassReference create Domain $Domain Class $Class Name $Relationship\
            Role $Role
    Reference create Domain $Domain Class $Class Name $Relationship
    ClassComponent create Domain $Domain Class $Class Name $Relationship

    return true
}
----

And similarly for a Referring Subclass,
it needs a Superclass Reference instance to hold the pointer to the superclass
instance.

(((micca,Helpers,ResolveSub)))
[source,tcl]
----
<<config commands>>=
proc ResolveSub {crref} {
    set rscref [findRelated $crref {~R40 Subclass} {~R47 ReferringSubclass}]
    if {[isEmptyRef $rscref]} {
        return false
    }

    assignAttribute $rscref
    SuperclassReference create Domain $Domain Class $Class Name $Relationship\
            Role $Role
    Reference create Domain $Domain Class $Class Name $Relationship
    ClassComponent create Domain $Domain Class $Class Name $Relationship

    return true
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test reference-4.0 {
    Define class with reference generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super {
                attribute a1 char

                reference R1
            }
            class sub1 {
                attribute a1 char

                reference R1
            }
            class sub2 {
                attribute a1 int

                reference R1
            }

            generalization R1 super sub1 sub2
        }
    }
    log::debug [formatMiccaClass SuperclassReference]
    log::debug [formatMiccaClass SubclassReference]
    testConditions\
        {[refMultiplicity [SuperclassReference findAll]] == 2}\
        {[refMultiplicity [SubclassReference findAll]] == 1}
} -result {1}
----

=== Polymorphic Events

Polymorphic events are defined in a superclass and when dispatched
to the superclass are mapped into events in the subclass state models.
The `polymorphic` commands defines a polymorphic event and optionally
the signature of event parameters that the event carries.

*****
`polymorphic` _event_ ?_argname argtype_ ...?

`event`::
    The name of an event that will be deemed polymorphic across
    any generalization relationships in which the class participates.

`argname argtype ...`::
    The argument signature of the event. Arguments must be given in
    name / type pairs. Argument names must be ``C'' identifiers and
    argument types must be ``C'' type names.

The `polymorphic` command defines _event_ as being polymorphic with
optional event arguments given by _argname_ / _argtype_ pairs.
*****


[float]
==== Implementation

For a polymorphic event,
we simply create instances of the PolymorphicEvent class and its
related classes.
At the end of a domain configuration script we will find it necessary to
rationalize the polymorphic events and the transition events defined
locally in a state model.

(((micca,Config,polymorphic)))
[source,tcl]
----
<<class config commands>>=
proc polymorphic {name args} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    set psigid [expr {[llength $args] != 0 ?\
            [FindParameterSignature $args] : {}}]

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $name\
    ]
    Event create {*}$eventtuple PSigID $psigid
    DeferredEvent create {*}$eventtuple
    PolymorphicEvent create {*}$eventtuple

    return
}
----

==== Propagating Polymorphic Events

[[domain-propagate-polymorphic-events]]
<<post-config-domain,Previously>>,
we indicated that polymorphic event rules require that we perform
some other processing once the configuration script for a domain
has been executed.
Now we are prepared to show that processing.
It will be helpful to refer to the Event subsystem of the platform model
above to follow the description.

The `polymorphic` command above inserts the argument event names into the
model classes simply as a deferred event that is polymorphic.
We must resolve two issues.

. For classes that are super classes for generalizations,
we must have corresponding instances of *Deferral Path* for each of the
generalization hierarchies.
. For classes that are sub classes,
they either consume the polymorphic event in a state model or
it continues to be inherited by any sub classes further down the
generalization hierarchy.

To solve the first issue we know that
relationship, *R86*, specifies how a polymorphic event may be propagated along
multiple generalizations when it is signaled to a given superclass.
After the configuration script has been executed,
we will have all the *Superclass* instances and all the *Deferred Event*
instances and can now make up the correlation between them.

Starting with the *Polymorphic Event* class we can navigate *R81* to
find the corresponding *Deferred Event* and then join to the *Superclass*.
This gives the set of paths along which the polymorphic event must
be propagated.

[source,tcl]
----
<<domain: propagate polymorphic events>>=
# Create Deferral Path instances corresponding to polymorphic events

set paths [pipe {
    PolymorphicEvent findWhere {$Domain eq $name} |
    findRelated ~ R81 |
    deRef ~ Domain Model Event |
    relation join ~ [deRef [Superclass findAll]]\
        -using {Domain Domain Model Class}
}]

foreach path [relation body $paths] {
    DeferralPath create {*}$path
}
----

To solve the second issue,
we must walk the generalization hierarchy and determine if events
are being consummed or inherited down the hierarchy.
We want to start the walk only on the ultimate super classes,
_i.e._ those super classes that are 'not' themselves the sub class of
some other generalization.

[source,tcl]
----
<<domain: propagate polymorphic events>>=
set subs [deRef [Subclass findAll]]
set supers [deRef [Superclass findAll]]
set ultimates [pipe {
    relation semiminus $subs $supers -using {Domain Domain Class Class} |
    ::rosea::Helpers::ToRef ::micca::Superclass ~
}] ; # <1>

forAllRefs super $ultimates {
    PropagatePolyEvents $super
}
----
<1> This is where a little relational algebra can go a long way.
The `semiminus` command finds all the tuples that are *not* related.
In this case we find the Superclass instances that do *not* have a
correspondence to a Subclass instance.
The `semiminus` operation is done only across the same domain and
class, _i.e._ without respect to any relationship.
This yields the Superclass instances that are *not* Subclass
instances of any relationship.

So we find all *Superclass* instances that have no corresponding
*Subclass* role and propagate any polymorphic events down the generalization
hierarchy.

The problem we are trying to solve in the propagation of polymorphic events
arises from the way in which we attempt to minimize the amount
of input from the user when specifying the events.
Recall that the `polymorphic` command simply inserts instances into the
*Polymorphic Event* class (and corresponding instances in *Deferred Event*
and *Event* classes).
Events found when defining a state model are simply created as instances of
the *Local Event* class (and again the corresponding *Transitioning Event* and
*Event* instances).
At the end of the configuration process we can now deduce which events
were inherited down the generalization hierarchy and which were truly
local events.

For sub classes that are leafs of generalization hierarchy,
polymorphic events inherited from the super class are migrated to
be *Mapped Events*.
For sub classes that are intermediate in the hierarchy,
polymorhphic events are migrated to instances of *Inherited Event*.
Both *Inherited Event* and *Mapped Event* are types of *Non-Local Event*
and *R85* insures that they affect only *Subclass* instances.

There are two other twists to be accounted.
It is possible for a mid-level class to consume an inherited polymorphic
event in a state transition.
In that case, the event is no longer available to any subclasses of
the consuming class.
We want to detect if a user mistakenly used an event by the same name
in a subclass state model.
Second,
inherited polymorphic events may not be explicitly consumed in a leaf
subclass.
In this case, the event is subject to the default transition rule for
the state model.
However, we want to warn the user of such events as it may indicate
a problem in specifying the state model (_e.g._ a polymorphic event was
added to a superclass and not accounted for in the subclasses).

The `PropagatePolyEvents` procedure below accomplishes this reclassification
operation.
By doing it this way,
we do not burden the user with all the subtle characteristics
of polymorphic events.
We need only specify which events are polymorphic and which events
cause a state model transition and then we can deduce the intent
to inherit down the generalization hierarchy.
Of course, what is unburdened from the user will be placed upon the
code and in this case there are some subtle twists and turns.

The `PropagatePolyEvents` procedure takes a singular instance reference to a
*Superclass* and tracks the polymorphic event inheritance down the hierarchy.

[[propagate-polyevents,propagate polymorphic events]]
(((micca,Helpers,PropagatePolyEvents)))
[source,tcl]
----
<<config commands>>=
proc PropagatePolyEvents {super} {
    # Starting at the superclass, find all the subclasses along the
    # generalization.
    set subs [instop $super findSubclasses]

    # Find the events that are deferred by the superclass. These could be
    # either polymorphic events defined in the superclass or inherited events
    # from another generalization.
    set defrdevents [findRelated $super R86 R80]

    # Set up some variables with the superclass attribute values.
    assignAttribute $super {Domain supDomain} {Class supClass}\
        {Relationship supRelationship}

    # Iterate over each subclass of the generalization.
    forAllRefs sub $subs {
        assignAttribute $sub {Domain subDomain} {Class subClass}\
            {Relationship subRelationship} {Role subRole}

        # We need to know if this subclass is also a superclass for another
        # generalization. We find that out by querying the ClassRole for all
        # the other relationships the subclass participates in and then
        # filtering those where it serves as a Superclass.
        set multigens [pipe {
            ClassRole findWhere {$Domain eq $subDomain &&\
                $Class eq $subClass && $Relationship ne $subRelationship} |
            findRelated % {~R40 Superclass}
        } {} |%]

        # Iterate over the deferred events
        forAllRefs defrdevent $defrdevents {
            # We need the event name and argument signature
            assignAttribute $defrdevent {Event event} {PSigID psigid}

            # Check if the event already exists
            set evt [Event findById Domain $subDomain Model $subClass\
                    Event $event]
            if {[isEmptyRef $evt]} {
                <<PropagatePolyEvents: inherit missing deferred event>>
            } else {
                <<PropagatePolyEvents: resolve found deferred event>>
            }
        }
        # Recursively descend any generalization hierarchies repeating the
        # process for them.
        forAllRefs multigen $multigens {
            PropagatePolyEvents $multigen
        }
    }
}
----

If an event has been deferred to a subclass,
then we need to know if a given subclass is a leaf subclass in the
generalization hierarchy or if it is part of a repeated generalization.
A leaf subclass has no generalizations for which it is the superclass.
This tells us if we must consume any inherited events or if they will
be allowed to be inherited further down the hierarchy.
Subclasses that are part of a repeated generation will have
instances of *Superclass* to show their role in that generalization.

[source,tcl]
----
<<PropagatePolyEvents: inherit missing deferred event>>=
if {[isEmptyRef $multigens]} {
    <<PropagatePolyEvents: leaf missing deferred event>>
} else {
    <<PropagatePolyEvents: non-leaf missing deferred event>>
}
----

If an event has been deferred to a leaf subclass and there is no
corresponding defined event for the leaf subclass,
then it must be that the event was never found in a transition statement
or declared in the subclass.
We create a new Mapped Event for it, but also issue a warning.

From the Events subsystem of the platform model,
we can see that creating a Mapped Event requires creating a number of
other related class instances.

[source,tcl]
----
<<PropagatePolyEvents: leaf missing deferred event>>=
Event create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    PSigID $psigid
TransitioningEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event
MappedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    ParentModel $supClass
Non-LocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole

<<PropagatePolyEvents: warn of missing deferred event>>
----

When we warn about the fact that a deferred event was not explicitly
consumed in a state model, we look up the default transition so that
we can say what will happen if the event is ever dispatched to the
subclass.
The analyst will then have to decide if that is acceptable behavior.

[source,tcl]
----
<<PropagatePolyEvents: warn of missing deferred event>>=
set trule [findRelated $sub R40 R41 ~R51 R50 R59]
switch -exact -- [readAttribute $trule Name] {
    IG {
        set phrase "ignoring the event"
    }
    CH {
        set phrase "a system error"
    }
    default {
        set phrase "unknown behavior"
    }
}

log::warn "In domain, \"$subDomain\", class, \"$subClass\", event, \"$event\"\
    is polymorphic across, \"$subRelationship\",\
    and was not consumed in the state model: signalling $event to\
    $subClass or its related superclasses will result in $phrase"
----

When an event is deferred to a subclass that is subject to repeated
generalization,
then the event is inherited down the generalization hierarchy.
Again, creating a Deferred Event requires creating a number of other
class instances.

[source,tcl]
----
<<PropagatePolyEvents: non-leaf missing deferred event>>=
Event create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    PSigID $psigid
DeferredEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event
InheritedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event
Non-LocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole

# Note that we need to provide a Deferral Path for all the generalizations that
# may stem from this subclass.  So we iterate over all the superclass
# relationships this subclass participates in.
forAllRefs multigen $multigens {
    DeferralPath create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        Relationship [readAttribute $multigen Relationship]\
        Role target
}
----

If the deferred event is found to already have been defined,
then there are several cases that must be dealt with.

. The event could be a Local Event that was defined as part of a State Model.
. The event could be inherited from a superclass.
. The event could be polymorphic. This would be the case if a user
redefined an inherited polymorphic event in one of the subclasses of the
generalization.
That is not necessary to do (that is what this code is actually doing),
but neither is it wrong.

We handle these cases, starting with the Local Event.

[source,tcl]
----
<<PropagatePolyEvents: resolve found deferred event>>=
updateAttribute $evt PSigID $psigid
set local [findRelated $evt {~R80 TransitioningEvent} {~R82 LocalEvent}]
if {[isNotEmptyRef $local]} {
    <<PropagatePolyEvents: migrate local event to mapped event>>
} else {
    <<PropagatePolyEvents: migrate inherited event to mapped event>>
}
----

Migrating a Local Event to a Mapped Event implies deleting the
Local Event and creating a new instance of Mapped Event.
*R83* implies that we need to create a new instance of Non-Local Event.

One further concern here is whether this subclass is a leaf subclass.
If it is, then this is just the normal consumption of an inherited
event as a transition in the state model of the subclass.
However,
if the subclass is subject to repeated generalization,
then the event may no longer be inherited by the lower level generalizations.
It is an easy mistake for a user to make,
so we do some checking.

[source,tcl]
----
<<PropagatePolyEvents: migrate local event to mapped event>>=
delete $local
MappedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    ParentModel $supClass
Non-LocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole

<<PropagatePolyEvents: check for non-leaf consumption>>
----

We deem it an error to consume an event at a mid-level subclass and then
have lower level subclasses also handle the event as if it were
inherited to them.
It doesn't make any sense.
The test fundamentally depends upon whether there are any
superclass roles played by this subclass.
We have already computed that and need to test it here.
The added complexity is that we need to find all the subclasses down
all the generalizations that may stem from this subclass.
This is effectively the transitive closure of the generalization
hierarchy.

[source,tcl]
----
<<PropagatePolyEvents: check for non-leaf consumption>>=
if {[isNotEmptyRef $multigens]} {
    <<PropagatePolyEvents: compute subclasses using event>>

    if {[llength $usingevent] != 0} {
        error "In domain, \"$subDomain\", class, \"$subClass\",\
            event, \"$event\", is inherited across, \"$subRelationship\"\
            and is consumed in the $subClass state model:\
            yet class(es), \"[join $usingevent {, }]\", assume \"$event\"\
            is deferred to them"
    }
}
----

To compute the entire set of subclasses that may be contained in
generalizations rooted at the current subclass,
we will build a binary relation that can be used to compute
the transitive closure.
We define a helper procedure that can be called recursively to
descend the generalization hierarchy.
The strategy is to build a relation that is the Cartesian product of
a relation that holds the names of superclasses and one that holds
the names of the subclasses on the next level.
Then, we find superclasses that are immediately related to the subclasses
and recursively compute the binary relation again.
By taking the union of this binary relation at each level in the
generalization,
we have the entire hierarchy and can pass that off to compute the
transitive closure.

[source,tcl]
----
<<helper commands>>=
proc findSubclassesOf {supers} {
    if {[isEmptyRef $supers]} {# <1>
        return [relation create {Super string Sub string}]
    }
    set supnames [pipe {
        deRef $supers |
        relation project ~ Class |
        relation rename ~ Class Super
    }] ; # <2>
    set subclasses [instop $supers findSubclasses] ; # <3>
    set subnames [pipe {
        deRef $subclasses |
        relation project ~ Class |
        relation rename ~ Class Sub
    }] ; # <4>

    set uses [relation times $supnames $subnames]

    set nextsupers [pipe {
        deRef $subclasses |
        relation semijoin ~ [deRef [ClassRole findAll]]\
            -using {Domain Domain Class Class} |
        relation semijoin ~ [deRef [Superclass findAll]] |
        ::rosea::Helpers::ToRef ::micca::Superclass ~
    }] ; # <5>

    return [relation union $uses [findSubclassesOf $nextsupers]] ; # <6>
}
----
<1> Stop if there are no further generalizations.
<2> Superclass names in a relation with one attribute, `Super`.
<3> Find the immediate subclasses.
<4> Subclass names in a relation with one attribute, `Sub`.
<5> Step down the hierarchy to those superclasses that have the same
name as the subclasses.
<6> Recursively descend to the next level and union the results from there.

Given a relation value that has the Superclasses and Subclasses at each
level in a generalization hierarchy,
we can compute the transitive closure of this relation.
The `relation tclose` command computes all possible paths and
we we restrict the result to being just paths from our current subclass.

[source,tcl]
----
<<PropagatePolyEvents: compute subclasses using event>>=
set subsusing [pipe {
    findSubclassesOf $multigens|
    relation tclose ~ |
    relation restrictwith ~ {$Super eq $subClass} |
    relation project ~ Sub |
    relation list ~ Sub
}] ; # <1>
set usingevent [pipe {
    Event findWhere {$Domain eq $subDomain && $Model in $subsusing &&\
            $Event == $event} |
    deRef ~ |
    relation project ~ Model |
    relation list ~ Model
}] ; # <2>
----
<1> We are only interested in the names of the subclasses that are ultimately
related to the current subclass.
That is sufficient for the next query.
<2> We get the names of the subclasses that use the event by querying
the Events to see which ones have Model attributes present in our
list of using subtypes.

If the deferred event was not local,
then two other possiblities exist.
First, it could be inherited.
If so, then for leaf subclasses we want to migrate the event to be a
Mapped Event.
If we aren't at a leaf, then the event passed further down.
The second possibility is that the event is classified as a Polymorphic
Event.
This can happen when a user redeclares an event as Polymorphic
at a mid-level subclass.
It is not necessary to do but it's not wrong.

[source,tcl]
----
<<PropagatePolyEvents: migrate inherited event to mapped event>>=
set inherit [findRelated $evt {~R80 DeferredEvent} {~R81 InheritedEvent}]
if {[isNotEmptyRef $inherit]} {
    <<PropagatePolyEvents: create mapped event at leaf>>
} else {
    <<PropagatePolyEvents: handle superfluous polymorphic event>>
}
----

If we have found an inherited event at a leaf subclass,
we want to migrate it to be a mapped event.

[source,tcl]
----
<<PropagatePolyEvents: create mapped event at leaf>>
if {[isEmptyRef $multigens]} {
    delete $inherit
    MappedEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        ParentModel $supClass
}
----

If we find a superfluous polymorphic event declaration,
we patch things up by simply migrating it to be an Inherited Event
as it would have been if the user had not inserted the extra
polymorphic statement in the configuration.
Also note, that the case were we define a polymorphic event in a
leaf subclass does not arise though this code path.
Because a leaf subclass never plays a Superclass role,
then no Deferral Path instance will be created that is associated with
the Polymorphic Event defined by the leaf subclass.
In other words, the error is detected because referential integrity
checks will fail.

[source,tcl]
----
<<PropagatePolyEvents: handle superfluous polymorphic event>>=
set poly [findRelated $evt {~R80 DeferredEvent} {~R81 PolymorphicEvent}]
if {[isNotEmptyRef $poly] && [isNotEmptyRef $multigens]} {
    delete $poly
    InheritedEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event
    Non-LocalEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        Relationship $subRelationship\
        Role $subRole
}
----

[float]
===== Tests

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.0 {
    Define polymorphic events
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                reference R1
                polymorphic e1 a int
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {d int} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                }
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {d int} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                }
            }
            generalization R1 S X Y
        }
    }
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 4}\
        {[refMultiplicity [MappedEvent findAll]] == 4}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.1 {
    Define polymorphic events -- inherit across one level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.2 {
    Define polymorphic events -- new event in leaf subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int

                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - e3 -> s2 ; # New local event!
                }
            }
            class Y {
                attribute id int
                reference R1

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            generalization R1 S X Y
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 4}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 4}\
        {[refMultiplicity [LocalEvent findAll]] == 1}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.3 {
    Define polymorphic events -- inject polymorphic event mid-level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                polymorphic e3
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 10}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 8}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.4 {
    Define polymorphic events -- multiple hierarchies
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 S A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 8}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.5 {
    Define polymorphic events -- common subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e3 -> s1
                }
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                }
            }
            generalization R1 S X Y

            class Z {
                attribute zid int
                polymorphic e3
            }
            class A {
                attribute zid int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                }
            }
            generalization R2 Z A X
        }
    }
    log::debug [formatMiccaClass DeferralPath]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 6}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.6 {
    Define polymorphic events -- consume mid level event
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                }
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 6}\
        {[refMultiplicity [InheritedEvent findAll]] == 1}\
        {[refMultiplicity [MappedEvent findAll]] == 5}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.7 {
    Define polymorphic events -- compound generalization at mid level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                polymorphic e3
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B

            class C {
                attribute id int
                reference R3
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e3 -> s1
                }
            }
            class D {
                attribute id int
                reference R3
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e4 -> s1
                }
            }
            generalization R3 X C D
        }
    }
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 16}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 14}\
        {[refMultiplicity [LocalEvent findAll]] == 1}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.8 {
    polymorphic events -- consume mid level event and use lower down
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # consume e1 here
                }
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # use e1 across R2 -- error
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1 ; # no e1 used -- correct
                }
            }
            generalization R2 X A B

            class C {
                attribute id int
                reference R3
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # use e1 across R3 -- error
                    transition s1 - e2 -> s1
                }
            }

            class D {
                attribute id int
                reference R3
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1 ; # no e1 used -- correct
                }
            }
            generalization R3 A C D
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.9 {
    Define polymorphic event in leaf subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                reference R1
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class Y {
                attribute id int
                reference R1
                polymorphic e3
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.10 {
    Define polymorphic events -- superfluous polymorphic definitions
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                reference R1
                polymorphic e2 ; # e2 is inherited along R1 and declared poly here
            }
            class Y {
                attribute id int
                reference R1
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                reference R2
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass Non-LocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    testConditions\
        {[refMultiplicity [Non-LocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

=== Class Operation

A class operation is a body of code that associated to a particular class.
Class operations at the analysis level are rare,
but when translating they are often useful.
For example,
if you wish to implement some search or sort algorithm on the instances
of a class that could be defined as a class operation.
Also operations that summarize information across multiple class
instances are often implemented easiestly using a class operation.

*****
+classop+ _rettype_ _name_ _parameters_ _body_

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the class operation.
`name`::
    The name of the class operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
*****

[float]
==== Implementation

(((micca,Config,classop)))
[source,tcl]
----
<<class config commands>>=
proc classop {rettype name parameters body} {
    DefineOperation false $rettype $name $parameters $body
}
----

=== Instance Operation

An instance operation is a body of code executed on a particular class instance.

*****
+instop+ _rettype_ _name_ _parameters_ _body_

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the instance operation.
`name`::
    The name of the instance operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the instance operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
    The code in _body_ may refer to a variable named `self` which holds
    a reference to the class instance on which the operation was invoked.
*****

[float]
==== Implementation

(((micca,Config,instop)))
[source,tcl]
----
<<class config commands>>=
proc instop {rettype name parameters body} {
    DefineOperation true $rettype $name $parameters $body
}
----

==== Define Operation

Defining class and instance operations is easily factored into
common code.

[float]
==== Implementation

(((micca,Config,DefineOperation)))
[source,tcl]
----
<<class config commands>>=
proc DefineOperation {isinst rettype name parameters body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    Operation create Domain $DomainName Class $ClassName Name $name Body $body\
        ReturnDataType $rettype IsInstance $isinst
    set paramtuple [dict create Domain $DomainName Class $ClassName\
            Operation $name]

    if {$isinst} {
        dict set paramtuple Name self
        dict set paramtuple DataType "struct $ClassName *"
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test classop-1.0 {
    Define a class operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c4 {
                attribute a1 int

                classop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation ReturnDataType Domain foo Class c4 Name color
} -result {float}
----

[source,tcl]
----
<<config command tests>>=
test instop-1.0 {
    Define an instance operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c5 {
                attribute a1 int

                instop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation IsInstance Domain foo Class c5 Name color
} -result {true}
----

=== Constructor

A constructor for a class is another concept that is occasionally useful
in an implementation but not needed at the model level.
When we create class instances, we will insist that a value for every
attribute be supplied.
This will insure that there are no uninitialized attributes.
Sometimes, we will find it convenient to have attribute data types that
are user defined and encapsulated.
It may require a constructor to initialize such encapsulated data types.
Note that constructors do not take arguments and so are not particularly
useful for setting attribute values.

*****
+constructor+ _body_

`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.

The `constructor` command defines a _body_ of code that is executed
when an instance of a class is created.
*****

[float]
==== Implementation

(((micca,Config,constructor)))
[source,tcl]
----
<<class config commands>>=
proc constructor {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName
    Constructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

=== Destructor

By analogy to a constructor,
a class may have a destructor that is called when an instance is deleted.

*****
+destructor+ _body_

`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.

The `destructor` command defines a _body_ of code that is executed
when an instance of a class is deleted.
*****

[float]
==== Implementation

(((micca,Config,destructor)))
[source,tcl]
----
<<class config commands>>=
proc destructor {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName
    Destructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

== Defining Class State Models

State models in XUML are used to specify the sequence of computations
associated with the life cycle of class instances.
All instances of a class have the same behavior,
yet each instance has it own notion of current state and so may progress
through its life cycle independently of any other instance.

Traditionally,
http://en.wikipedia.org/wiki/Moore_machine[Moore]
type state models are used in XUML to define the life cycle behavior.
The other alternative is a
http://en.wikipedia.org/wiki/Mealy_machine[Mealy]
type state model.
They are mathematically equivalent in the sense that any problem that
can be solved by one formulation can also be solved by the other.
Individuals have their preferences over which formulation is better
and we will not indulge in that discussion here.
We only point out that hierarchical state models are _not_
supported in the this translation scheme.
Hierarchical state models are an unnecessary abomination.

As usual, we need a namespace in which to hold the state model definition
commands.

[source,tcl]
----
<<state model config namespace layout>>=
namespace eval StateModelDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<state model config commands>>
}
----

=== Statemodel

The `statemodel` command is used to define a state model for a class
or an assigner.
Both use the same command and support the same commands in the
script body for defining states, events and transitions.

*****
+statemodel+ _body_

+body+::
    A Tcl Script that is evaluated in a context to allow the definition
    of the properties of the class state model.
*****

[float]
==== Implementation

The implementation of the `statemodel` command follows the usual pattern.
We evaluate `body` in the proper context and then
insert the argument data into the proper relvars that are used to
collect the state model specifications.

(((micca,Config,statemodel)))
[source,tcl]
----
<<class config commands>>=
proc statemodel {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    namespace upvar StateModelDef\
        InitialState InitialState\
        DefaultTrans DefaultTrans\
        Terminals Terminals

    set InitialState {}
    set DefaultTrans {}
    set Terminals [list]

    ConfigEvaluate [namespace current]::StateModelDef $body

    if {$DefaultTrans eq {}} {
        set DefaultTrans CH
    }
    StateModel create\
        Domain          $DomainName\
        Model           $ClassName\
        InitialState    $InitialState\
        DefaultTrans    $DefaultTrans
    InstanceStateModel create\
        Domain          $DomainName\
        Class           $ClassName

    foreach terminal $Terminals {
        set sref [State findWhere Domain $DomainName Model $ClassName\
                Name $terminal]
        updateAttribute $sref IsFinal true
    }
}
----

=== State

The `state` command defines code that is executed when the state is entered
and any parameters that are passed in from the event that caused the
transition.

*****
+state+ _name_ _parameters_ _body_

`name`::
    The name of the state. Name must not be the empty string or one of
    the reserved names of *@*, *CH* or *IG*.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
    A list of the formal parameters of the state.
    Parameters are specified in the same manner as for the `::proc` command.
`body`::
    A string containing the code that is executed when the state is
    entered.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
*****

[float]
==== Implementation

(((micca,Config,state)))
[source,tcl]
----
<<state model config commands>>=
proc state {name params body} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME state
    }
    if {$name eq "@" || [isNotEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    variable InitialState

    if {$InitialState eq {}} {
        set InitialState $name
    }

    set psigid [FindParameterSignature $params]
    set stateref [State create\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Activity        $body\
        IsTerminal      false\
        PSigID          $psigid\
    ]
    StatePlace create\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Number          [GenNumber $DomainName StatePlace\
                            [list $DomainName $ClassName]]

    if {$psigid ne {}} {
        set asigid [pipe {
            findRelated $stateref R78 |
            readAttribute ~ ASigID
        }]
        StateTransition update [pipe {
            findRelatedWhere $stateref ~R72 {$ASigID eq {}} |
            deRef ~ ASigID |
            relation update ~ sttuple {1} {
                tuple update $sttuple ASigID $asigid
            }
        }]
    }

    return
}
----

(((error code,BAD_STATE_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_STATE_NAME    {"%s" is not a valid state name}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test state-1.0 {
    Define a state with parameters
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 int

                statemodel {
                    transition s1 - e1 -> s2
                    event e1 e int f float

                    state s1 {a int b float} {
                        printf("in state s1\n") ;
                    }
                    state s2 {c int d float} {
                        printf("in state s2\n") ;
                    }

                    state s3 {i char j double} {
                    }
                    event e2 e char f double

                    transition s2 - e2 -> s3
                    transition s3 - e1 -> s1
                }
            }
        }
    }
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    log::debug [formatMiccaClass ParameterSignature]
    log::debug [formatMiccaClass Parameter]
    log::debug [formatMiccaClass ArgumentSignature]
    log::debug [formatMiccaClass Argument]
    testConditions\
        {[refMultiplicity [State findAll]] == 3}\
        {[refMultiplicity [Event findAll]] == 2}\
        {[refMultiplicity [ParameterSignature findAll]] == 5}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test state-2.0 {
    State / event parameter mismatch
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 int

                statemodel {
                    event e1 a float b int

                    transition s1 - e1 -> s1

                    state s1 {a int b float} {
                    }

                    state s2 {a int b float} {
                    }

                    event e2 f int g float
                    transition s1 - e2 -> s2

                    transition s2 - e3 -> s1
                    event e3 h char i unsigned
                }
            }
        }
    }
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    log::debug [formatMiccaClass ParameterSignature]
    log::debug [formatMiccaClass Parameter]
    log::debug [formatMiccaClass ArgumentSignature]
    log::debug [formatMiccaClass Argument]
} -result {encountered 2 configuration script errors} -returnCodes error
----

=== State Parameters

In XUML,
a state may define a set of parameters that are passed to the activity
of the state when the activity is executed.
Most of the time,
states do not define any parameters and so there is nothing else to
understand about how the parameter passing works.

If a state does define parameters,
then it is a corollary of the Moore machine formulation that
any event that causes a transition into a state with parameters must
carry a matching set of arguments whose values were determined when the
event was signalled.
So if an event causes a transition to different states,
then each state must have the same parameter signature.
Conversely, if different event cause a transition into the same state,
the events must have the same parameter signature.

What determines the matching of event and state parameters is
the position and data type of the parameters.
Specifically,
the parameter names don't matter when we are trying to decide if
the parameters of an event and the parameters of the state into which
the event causes a transition match.
For example an event may view its parameters as `int size, float incr` and a
corresponding state may view its parameters as `int count, float prec`.
In this case the signature of position and type is the same despite the
difference in the parameter naming.
Seen another way, states and events may have a different semantic
view of their parameters as given by the parameter names, but have
matching syntax of parameter position and data type.

In our attempt so minimize the amount of specification of information
in the configuration DSL,
the declaration of events is optional.
Here are the rules:

. An event and its parameters may be declared with the `event` command
and that is the signature it is given.
. A polymorphic event that has parameters must declare them as part
of the `polymorphic` command.
. If there is no event declaration, the event name and signature is
assumed from the state into which the event causes a transition.
Its parameter naming, position and type information is assumed from that
of the state.

The rules outlined in this discussion are not the only possiblity.
It is the one that has been chosen for `micca` as it matches the
function invocation rules of ``C'' while still allowing flexiblity
in parameter name specification.
We deem this approach more consistent with ``C'' implementation concepts
and more flexible than one that is based strictly on parameter names
and the need to declare event parameter signatures.

The helper procedures in this section do the work of setting up parameter
signatures and the underlying argument signatures.
Here is where signature equality is determined.

==== FindParameterSignature

The `FindParameterSignature` procedure searches for an existing parameter
signature that matches the parameter list argument and returns the
parameter signature ID.
If none exists that matches,
it creates a new one and returns the ID of the new one.

[float]
==== Implementation

The tricky part in determining the equality of two parameter signatures
is that we want to find that Parameter Signature where all the
related Parameter instances have the correct values for the parameter
name, position and data type.
The information about position and data type is held in the Argument Signature
and we will cover that next.

Again this is a situation where some relational algebra can come to the
rescue.
In this case we will create a relation value that holds the parameter
name, position and data type.
We then use the `relation group` command to create a relation valued
attribute that groups together the parameter name, position and
data type for the existing instances of Parameter.
Equality can then be determined by the equality of two relations.

(((micca,Helpers,FindParameterSignature)))
[source,tcl]
----
<<helper commands>>=
proc FindParameterSignature {params} {
    if {[dict size $params] == 0} {
        return
    }

    set asigid [FindArgumentSignature $params] ; # <1>
    if {$asigid eq {}} {
        error "panic: did not create an argument signature for \"$params\""
    }

    set poscounter -1
    set parampos [relation create {Name string Position int ASigID string}]
    dict for {pname ptype} $params {
        set parampos [relation insert $parampos [list\
            Name $pname\
            Position [incr poscounter]\
            ASigID $asigid\
        ]]
    } ; # <2>
    set psigref [pipe {
        Parameter findAll | deRef ~ |
        relation group ~ ParamNames Name Position ASigID |
        relation restrictwith ~ {[relation is $ParamNames == $parampos]} |
        relation semijoin ~ [deRef [ParameterSignature findAll]]
        ::rosea::Helpers::ToRef ::micca::ParameterSignature ~
    }] ; # <3>

    if {[isEmptyRef $psigref]} {# <4>
        namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

        set psigid psig[GenNumber $DomainName ParameterSignature\
                [list $DomainName]]
        ParameterSignature create\
            Domain $DomainName\
            PSigID $psigid\
            ASigID $asigid
        set poscounter -1
        dict for {pname ptype} $params {
            Parameter create\
                Domain $DomainName\
                PSigID $psigid\
                Name $pname\
                Position [incr poscounter]\
                ASigID $asigid
        }
    } else {
        set psigid [readAttribute $psigref PSigID]
    }

    return $psigid
}
----
<1> The argument signature encodes the position and data type information.
<2> The heading of this relation matches the attribute names in the
Parameter class.
<3> Step by step:
    . Get all the Parameter instances as a relation value.
    . Group together the Name, Position and ASigID attributes. This leaves
      us with a relation value with the attributes Domain, PSigID and
      ParamNames, where ParamName is relation valued.
    . Find the one matching the information in the parameters argument.
    . Find the corresponding Parameter Signature.
    . Turn it into an instance reference for later use.
<4> If we fail to find a match, then create the Parameter Signature and
Parameter instances. Otherwise, we can return the PSigID value.

==== FindArgumentSignature

To separate parameter names from their position and data type,
we introduce the concept of an Argument Signature.
Here equality is based solely on positions` and data types of the
arguments.
This concept is useful when considering how argument values carried by an
event are transferred to the formal parameter of a state activity.
In that situation,
the names don't matter in ``C'', only order and data type.

[float]
==== Implementation

The implementation here follows the same strategy used for
`FindParameterSignature`.
We create a relation value that contains the Position and DataType information
that corresponds to the parameters.
The grouping and comparing is similar.

[source,tcl]
----
<<helper commands>>=
proc FindArgumentSignature {params} {
    if {[llength $params] == 0} {
        return
    }

    set poscounter -1
    set parampos [dict create]
    dict for {pname ptype} $params {
        dict set parampos [incr poscounter] $ptype
    }
    set argpos [relation fromdict $parampos Position int DataType string] ; # <1>
    set asigref [pipe {
        Argument findAll | deRef ~ |
        relation group ~ ArgPositions Position DataType |
        relation restrictwith ~ {[relation is $ArgPositions == $argpos]} |
        relation semijoin ~ [deRef [ArgumentSignature findAll]] |
        ::rosea::Helpers::ToRef ::micca::ArgumentSignature ~
    }]

    if {[isEmptyRef $asigref]} {
        namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

        set asigid asig[GenNumber $DomainName ArgumentSignature\
                [list $DomainName]]
        ArgumentSignature create\
            Domain  $DomainName\
            ASigID   $asigid
        set poscounter -1
        dict for {pname ptype} $params {
            Argument create\
                Domain      $DomainName\
                ASigID      $asigid\
                Position    [incr poscounter]\
                DataType    $ptype
        }
    } else {
        set asigid [readAttribute $asigref ASigID]
    }

    return $asigid
}
----
<1> Since there are only two attributes in the relation value of position
and data type information, we can use a Tcl `dict` to accumulate the
information and then TclRAL has convenience methods to move between
relation values and Tcl dictionaries.

=== Event

Event definitions are optional,
but in the case of events with parameters may make the parameter set
clearer by declaring the event.

*****
`event` _name_ ?_argname argtype_ ...?

`name`::
    The name of the event.

`argname argtype ...`::
    The argument signature of the event. Arguments must be given in
    name / type pairs. Argument names must be ``C'' identifiers and
    argument types must be ``C'' type names.

The `event` command defines _name_ as being an event with
optional event arguments given by _argname_ / _argtype_ pairs.
*****

[float]
==== Implementation

The implementation does the usual platform class instance creation to
store away the data in the command arguments.
However,
since events may be defined simply by their appearance in a
`transition` command, we need to check if we have already seen the
event.
If we have, then we want to update the parameter signature to match
what was defined in this command.
Further,
if this event causes any state transition where the argument signature
has not already been determined,
then we need to update the StateTransition instances to reflect the
argument signature implied by this event.
This processing is done here to make the order of event and transition
specification arbitrary.

(((micca,Config,event)))
[source,tcl]
----
<<state model config commands>>=
proc event {name args} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set psigid [expr {[llength $args] != 0 ?\
            [FindParameterSignature $args] : {}}]

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $name\
    ]
    set evtref [Event findById {*}$eventtuple]
    if {[isEmptyRef $evtref]} {
        set evtref [Event create {*}$eventtuple PSigID $psigid]
        TransitioningEvent create {*}$eventtuple
        LocalEvent create {*}$eventtuple
    } elseif {[readAttribute $evtref PSigID] eq {}} {
        updateAttribute $evtref PSigID $psigid
    }

    if {$psigid ne {}} {
        set asigid [pipe {
            findRelated $evtref R69 |
            readAttribute ~ ASigID
        }] ; # <1>
        StateTransition update [pipe {
            findRelatedWhere $evtref\
                {{~R80 TransitioningEvent} {~R70 TransitionPlace}\
                {~R71 StateTransition}} {$ASigID eq {}} |
            deRef ~ ASigID |
            relation update ~ sttuple {1} {
                tuple update $sttuple ASigID $asigid
            }
        }] ; # <2>
    }
}
----
<1> If we have a parameter signature, then get the corresponding
argument signatureu.
<2> Update the argument signature for any StateTransition instance where
this event caused a transition and which does not already have a value
for its argument signature.

=== Transition

For Moore type state models,
one can conceive of the mapping of states to events as a transition
matrix with a row for each state and a column for each event.
Each matrix cell has a value of the new state for the transition.
The `transition` command is used to define the values of cells
in the conceptual transition matrix.

*****
+transition+ _source_ `-` _event_ `->` _target_

+source+::
    The name of a state in the state model being defined or the
    special reserved name, `@`.
+event+::
    The name of an event that causes the transition.
+target+::
    The name of a state in the state model being defined or one of the
    special non-transitioning states, `IG` or `CH`.

The `transition` command defines the transition that is to happen
when _event_ is dispatched to a state machine when the current
state is _source_, causing the new state to be _target_.
*****

[float]
==== Implementation

The implementation of the `transition` command consists mainly of
inserting tuples into the event classes using the data from the command
arguments.
Note however, that all the events defined by invoking `transition` are
deemed to be a *LocalEvent*.
This certainly may not be true for classes that are leaf subclass of
a generalization hierarchy.
When the domain configuration is completed we will propagate the
polymorphic events down the generalization hierarchies and in that
process recategorize any inherited events properly.

One other minor concern is dealing with the initial pseudo-state, *@*.
This state is where an instance resides if it has been created
asynchronously.
One may not define the `@` state in a `state` command
(it cannot have an activity)
and the only valid place it can appear is as the `source` state in a
`transition` command.

We also have to handle the argument signature of the transition.
If the new state or the event already has an argument signature
we will use it here when the State Transition is created.

(((micca,Config,transition)))
[source,tcl]
----
<<state model config commands>>=
proc transition {source - event -> target} {
    if {$event eq {}} {
        tailcall DeclError BAD_NAME event
    }
    if {[isNotEmptyRef [TransitionRule findById Name $source]]} {# <1>
        tailcall DeclError BAD_STATE_NAME $name
    }
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    if {$source eq "@"} {
        if {[isNotEmptyRef [TransitionRule findById Name $target]]} {
            tailcall DeclError BAD_CREATION_TARGET $target
        }
        set cstuple [list\
            Domain          $DomainName\
            Model           $ClassName\
            Name            @\
        ]
        # We have to conditionally create the CreationState instance since we
        # can have multiple transition commands that use @ as the source state.
        if {[isEmptyRef [CreationState findById {*}$cstuple]]} {
            CreationState create {*}$cstuple
        }
        if {[isEmptyRef [StatePlace findById {*}$cstuple]]} {
            StatePlace create {*}$cstuple
        }
    }

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $event\
    ]
    set eventref [Event findById {*}$eventtuple]
    if {[isEmptyRef $eventref]} {
        Event create {*}$eventtuple PSigID {}
        TransitioningEvent create {*}$eventtuple
        LocalEvent create {*}$eventtuple
    }

    set transtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        State   $source\
        Event   $event\
    ]
    TransitionPlace create {*}$transtuple

    set trref [TransitionRule findById Name $target]
    if {[isNotEmptyRef $trref]} {
        Non-StateTransition create {*}$transtuple TransRule $target
    } else {
        # Create the state transition instance. If the state or event has
        # already been created, then use the argument signature from them, else
        # just leave it empty. Note we only look for states or events that
        # a non-empty parameter signature.
        
        set asigid {}
        set stateref [State findWhere {$Domain eq $DomainName &&\
            $Model eq $ClassName && $Name eq $target && $PSigID ne {}}]
        if {[isNotEmptyRef $stateref]} {
            set asigid [pipe {
                findRelated $stateref R78 |
                readAttribute ~ ASigID
            }]
        } else {
            set eventref [Event findWhere {$Domain eq $DomainName &&\
                $Model eq $ClassName && $Event eq $event && $PSigID ne {}}]
            if {[isNotEmptyRef $eventref]} {
                set asigid [pipe {
                    findRelated $eventref R69 |
                    readAttribute ~ ASigID
                }]
            }
        }

        set stref [StateTransition create {*}$transtuple\
                NewState $target ASigID $asigid]
    }

    return
}
----
<1> Ignoring a transition out of the pseudo-initial state is not allowed
and any transition out of the pseudo-initial state not mentioned in a
`transition` command will be set to CH anyway. So just don't let
transition out of the pseudo-initial state go anywhere except a real state.

(((error code,BAD_CREATION_TARGET)))
[source,tcl]
----
<<error code formats>>=
BAD_CREATION_TARGET {the target of a creation event must be a state,\
        got "%s"}
----

=== Initialstate

By default,
instances created from classes that have a state model are placed in
the first state that was defined for the model.
The `initialstate` command is used to specify explicitly the inital state
for newly created instances.

*****
+initialstate+ _name_

+name+::
    The name of at state in the state model being defined.
    Instances of the class that are created synchronously using
    the `create` class command will be placed in this state.

The `initialstate` command sets the default state that an instance will be
created in. If no `initialstate` command is encountered in the definition
of a state model, then the first state defined to the state model is used
as the initial state.
*****

[float]
==== Implementation

(((rosea,Config,initialstate)))
[source,tcl]
----
<<state model config commands>>=
proc initialstate {name} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME initialstate
    }
    if {$name eq "@" || [isNotEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }
    variable InitialState $name
    return
}
----

=== Defaulttrans

It is customary to write `transition` commands only for outgoing
transition that appear on the state model graphic.
For any entries in transition matrix that are not set by a `transition`
command,
a default value is supplied.
That default is either `IG` or `CH` depending upon the argument to the
`defaulttrans` command.
If no `defaulttrans` command is invoked when a state model is defined,
then the default transition will be `CH`.

*****
+defaulttrans+ _trans_

+trans+::
    Either the string *IG* or *CH*.
    For all transitions not explicitly mentioned in a `transition` command,
    the default transition is defined as _trans_.
    If `defaulttrans` is not invoked during a state model definition
    then the default transition is *CH*.
*****

[float]
==== Implementation

(((rosea,Config,defaulttrans)))
[source,tcl]
----
<<state model config commands>>=
proc defaulttrans {name} {
    if {[isEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError EXPECTED_PSEUDO_STATE $name
    }
    variable DefaultTrans $name
    return
}
----

(((error code,EXPECTED_PSEUDO_STATE)))
[source,tcl]
----
<<error code formats>>=
EXPECTED_PSEUDO_STATE    {expected CH or IG, got "%s"}
----

==== Terminal

Terminal states are those where the class instance is deleted after
the state activity is executed.
This allows for asynchronous deletion of class instances.

*****
+terminal+ _?state ...?_

+state+::
    The name of a state in the state model that will be marked as a
    terminal state.
    If a state machine transitions into a terminal state,
    the associated instance is deleted after the state activity is
    executed.
*****

[float]
===== Implementation

(((rosea,Config,terminal)))
[source,tcl]
----
<<state model config commands>>=
proc terminal {args} {
    variable Terminals
    ::struct::set add Terminals $args
    return
}
----

== Defining Assigners

The assigner concept is not frequently used in XUML models
but is an essential concept in modeling competitive relationships.
Some associations model competitive behavior such as allocating
resources.
For such situations,
instances of the relationships must be created and deleted,
'i.e.' linked and unlinked,
according to some protocol and in some fashion that serializes
the relationship lifecycle between competing classes.
Lifecycle behavior of associations is accomplished in XUML models by
associating a state model and having the state model
activities insure the proper creation of relationship instances.
Such state models are known as _assigners_.

Note that we associate the assigner with the relationship.
We do *not* require factoring the relationships into a class based association
and then attach the assigner to the associator class.
In `micca`,
the relationship may or may not be class based and if it is the associator class
may or may not have a state model.
The assigner state model is independent of any class and its state model.
It is, after all, a state model to deal with the application semantics
of forming and dissolving the relationship.

Also note that only associative relationships may have an assigner.
Assigners are not meaningful for generalization relationships given
the disjoint union nature of a generalization.

There is a further complication.
Usually,
there is a single state machine associated with the association assigner.
However,
some assigners have more complicated competitive protocols.
In those cases the association may have multiple assigners
that are partitioned by another class.
The archetypal example is that of assigning department store clerks
to customers.
If any clerk can service any customer,
then a single assigner is used to sequence properly the assignment of
available clerks to waiting customers.
If the store policy is that a customer can only be served by a clerk working in
a particular department,
then there will be as many assigners as there are departments and
the identity of the department class serves to identify the assigner instances
needed to insure that clerks, within the department, are not over allocated
and that customers, visiting the department, are not over served by
clerks from the wrong department.
This is the essential concept behind a multiple assigner.

Assigners and multi-assigners fall into the XUML semantics category of
not-that-common but essential to express the proper execution semantics.
As we will see,
the specifications required for assigners is almost the same as that
for ordinary class state models.

Assigners are defined by a script specified as part of an
`association` command.
In this section we show the command that may be executed in that script.
We will need to define a namespace in which the script can be evaluated.

[source,tcl]
----
<<assigner config namespace layout>>=
namespace eval AssignerDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<assigner config commands>>
}
----

=== Assigner State Model

The `statemodel` command for assigners takes the same commands as
that for classes.
Indeed, much of the same code is in common.

*****
+statemodel+ _body_

+body+::
    A Tcl Script that is evaluated in a context to allow the definition
    of the properties of the assigner state model.
*****

[float]
==== Implementation

The difference between assigner state model and class state models is
only in a few class instances and relationships, notably, R50 and R53.

(((micca,Config,statemodel)))
[source,tcl]
----
<<assigner config commands>>=
proc statemodel {body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName AssocName

    namespace upvar ::micca::@Config@::DomainDef::ClassDef::StateModelDef\
        InitialState InitialState\
        DefaultTrans DefaultTrans\
        Terminals Terminals

    set InitialState {}
    set DefaultTrans {}
    set Terminals [list]

    ConfigEvaluate ::micca::@Config@::DomainDef::ClassDef::StateModelDef $body ; # <1>

    if {$DefaultTrans eq {}} {
        set DefaultTrans CH
    }
    StateModel create\
        Domain          $DomainName\
        Model           $AssocName\
        InitialState    $InitialState\
        DefaultTrans    $DefaultTrans

    set assoctuple [list\
        Domain          $DomainName\
        Association     $AssocName
    ]
    AssignerStateModel create {*}$assoctuple

    variable IdClassName
    if {$IdClassName eq {}} {
        SingleAssigner create {*}$assoctuple
    } else {
        MultipleAssigner create {*}$assoctuple Class $IdClassName
        ValueElement create Domain $DomainName Name $AssocName
    }

    foreach terminal $Terminals {
        set sref [State findWhere Domain $DomainName Model $ClassName\
                Name $terminal]
        updateAttribute $sref IsFinal true
    }
}
----
<1> We evaluate the assigner state model script in the same namespace as for
the class state models.
Other than setting up a few variables differently,
the configuration data for assigners is the same as for classes.

=== Identify By Class

For multiple assigners we need to specify which class serves to partition
the assigners into multiple instances.
Defining such a class signifies that the assigner is to be multiple rather
than singular.

*****
`identifyby` _class_

`class`::
    The name of a class that serves to partition the instances of a multiple
    assigner.

The `identifyby` command defines an assigner to be a multiple assigner and
specifies _class_ as the partitioning class.
*****

[float]
==== Implementation

(((micca,Config,identifyby)))
[source,tcl]
----
<<assigner config commands>>=
proc identifyby {class} {
    variable IdClassName $class
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test assigner-1.0 {
    Define a single assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
                reference R1
            }
            class client {
                reference R1
            }
            association R1 clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
        }
    }
    log::debug [formatMiccaClass AssignerStateModel]
    log::debug [formatMiccaClass SingleAssigner]
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    testConditions\
        {[refMultiplicity [AssignerStateModel findAll]] == 1}\
        {[refMultiplicity [SingleAssigner findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test assigner-1.1 {
    Define a multiple assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
                reference R1
                reference R2
            }
            class client {
                reference R1
            }
            association R1 clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {
                reference R2
            }
            association R2 department 1..*--1 clerk
        }
    }
    log::debug [formatMiccaClass AssignerStateModel]
    log::debug [formatMiccaClass MultipleAssigner]
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    testConditions\
        {[refMultiplicity [AssignerStateModel findAll]] == 1}\
        {[refMultiplicity [MultipleAssigner findAll]] == 1}
} -result {1}
----

== Populating a Domain

At this point we have covered all the commands that are used to
define the configuration of a domain.
We now turn our attention to specifying an initial instance population.
The initial instances of a domain are those class (and assigner) instances
that will exist when the domain start running.

For many systems, particularly small embedded systems,
much of the class instance data can be specified as part of the initial
instance population.
This has a substantial benefit to the implementation.
Since class data is held in ``C'' arrays, initial instances can be
specified as initializers for those class storage arrays.
The ``C'' language then guarantees that initializer values are in
place before `main` begins execution.
This usually requires much less memory space than having initialiation code to
create the initial instances and that code is executed only once.

In our population scheme, we allow for several populations to be defined
for a domain.
In practice,
development of a domain will usually entail creating multiple populations
for both testing and deployment.
Populations can be managed by keeping them in separate files and then
assembling the domain using Tcl `source` commands.

Following our usual pattern,
we define a namespace in which to evaluate the population commands.

[source,tcl]
----
<<population config namespace layout>>=
namespace eval PopDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<population config commands>>

    <<class instance config namespace layout>>
    <<assigner instance config namespace layout>>
}
----

=== Population

The `population` command gives a collection of class component values a
name.
The complete domain population must be given by the invocation of `population`.

*****
`population` _name_ _domain_ _script_

`name`::
    The name of the population.
`domain`::
    The name of the domain to which the population applies.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of initial instance values for a domain.

The `population` command is used to define initial instance values for
the classes and assigners in _domain_.
*****

[float]
==== Implementation

(((micca,Config,population)))
[source,tcl]
----
<<config commands>>=
proc population {name domain script} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name population
    }

    namespace upvar PopDef PopulationName PopulationName DomainName DomainName
    set PopulationName $name
    set DomainName $domain

    set popref [Population create Name $name Domain $DomainName]

    ConfigEvaluate [namespace current]::PopDef $script

    upvar #0 ::micca::@Config@::errcount errcount

    <<population: check completeness>>
    <<population: check static populations>>
    <<population: check dynamic populations>>
    <<population: update storage types>>
    <<population: check reference values>>
    <<population: check referential integrity>>
}
----

==== Validating a Population

Once a population has been gather by the `population` command,
we perform some validation on the population to make sure it
is correct and we will be able to proceed to code generations.
We inspect several factors:

* We insist that there be some population for every domain element
that can have values.
* All Static Class Populations must have at least one Class Instance.
* All Dynamic Class Population with Allocation of 0 must have at least
one Class Instance.
* At the end of population, we know which classes are static and can
then make the final decision about reference storage.
* All initial instances have their references define so we can make sure
there is no referential integrity problems with the initial instance
population.

==== Checking Completeness

We want to query all the Value Elements that have no Element Population
in the Population.
These are the missing elements that were not included in the population.

[source,tcl]
----
<<population: check completeness>>=
set missing [pipe {
    findRelated $popref {R101 ElementPopulation} |
    findUnrelated ~ R101
}]
if {[isNotEmptyRef $missing]} {
    set elements [pipe {
        deRef $missing |
        relation list ~ Name
    }]
    log::error "in population, \"$name\", for domain, \"$domain\",\
        the following elements are missing any population values:\
        [join $elements {, }]"
    incr errcount
}
----

[source,tcl]
----
<<config command tests>>=
test populate-4.0 {
    Population missing elements
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class c1 {
                attribute c1_id int
                attribute c1_color {char const*}
            }
            class c2 {
                attribute c2_id int
                attribute temp int -default 25
            }
        }

        population p1 bar {
            class c1 {
                instance fred1 c1_id 20 c1_color {"blue"}
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

==== Checking Populations Declared Static

Part of populating a domain includes the ability to declare that the
instances of a class are static.
This means that during the run time of the domain,
no instances of a static class are created or deleted and all the
instances of the class are defined by the initial instance population.

[source,c]
----
<<population: check static populations>>=
set noinsts [pipe {
    StaticClassPopulation findWhere\
            {$Population eq $name && $Domain eq $domain} |
    findRelated ~ R109 |
    deRef ~ |
    ralutil::rvajoin ~ [deRef [ClassInstance findAll]] Instances |
    relation restrictwith ~ {[relation isempty $Instances]}
}]

if {[relation isnotempty $noinsts]} {
    log::error "in population, \"$name\", for domain, \"$domain\",\
        the following classes have a static population but no defined\
        instances: [join [relation list $noinsts Class] {, }]"
    incr errcount
}
----

[source,tcl]
----
<<config command tests>>=
test populate-4.1 {
    static population with no instances
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class c1 {
                attribute c1_id int
                attribute c1_color {char const*}
            }
            class c2 {
                attribute c2_id int
                attribute temp int -default 25
            }
        }

        population p1 bar {
            class c1 {
                instance fred1 c1_id 20 c1_color {"blue"}
            }
            class c2 {
                static
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

==== Checking Populations Declared Dynamic

The counter point to a static population is a dynamic one.
For dynamic populations,
the maximum number of simultaneous instances is the sum of the
initial instance population plus the number of additional storage locations
allocated in the `dynamic` command.
If both these quantities sum to zero,
then it is not possible to ever have an instance of the class.

[source,c]
----
<<population: check dynamic populations>>=
set noinsts [pipe {
    DynamicClassPopulation findWhere\
        {$Population eq $name && $Domain eq $domain && $Allocation == 0} |
    findRelated ~ R109 |
    deRef ~ |
    ralutil::rvajoin ~ [deRef [ClassInstance findAll]] Instances |
    relation restrictwith ~ {[relation isempty $Instances]}
}]

if {[relation isnotempty $noinsts]} {
    log::error "in population, \"$name\", for domain, \"$domain\",\
        the following classes have no defined instances and a zero allocation:\
        [join [relation list $noinsts Class] {, }]"
    incr errcount
}
----

[source,tcl]
----
<<config command tests>>=
test populate-4.2 {
    dynamic population with no instances and 0 allocation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class c1 {
                attribute c1_id int
                attribute c1_color {char const*}
            }
            class c2 {
                attribute c2_id int
                attribute temp int -default 25
            }
        }

        population p1 bar {
            class c1 {
                instance fred1 c1_id 20 c1_color {"blue"}
            }
            class c2 {
                dynamic 0
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

==== Updating Direction Reference Types

During the configuration process,
all directional reference instances were assumed to be dynamic.
Now that we have populated the domain,
the dynamic characteristics of the class are known.
If a population has been declared as static, then all of its associated
Directional Reference instances that are of Reference Type, "dynamic",
need to be updated to be, "static".
This change in reference type results in different data structures for holding
the reference pointers being chosen by the code generation phase.

[source,c]
----
<<population: update storage types>>=
DirectionalReference update [pipe {
    StaticClassPopulation findWhere\
        {$Population eq $name && $Domain eq $domain} |
    findRelated % R109 ~R102 R103 {~R21 Reference} {~R23 AssociationReference}\
        ~R25 |
    deRef % ReferenceType |
    relation restrictwith % {$ReferenceType eq "dynamic"} |
    relation update % drtup {1} {tuple update $drtup ReferenceType static}
} {} |%]
----

[source,tcl]
----
<<config command tests>>=
test populate-4.3 {
    static population with directional reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class c1 {
                attribute c1_id int
                attribute c1_color {char const*}
                reference R1
            }
            class c2 {
                attribute c2_id int
                attribute temp int -default 25
            }

            association R1 c2 1..*--1 c1
        }

        population p1 bar {
            class c1 {
                static
                instance fred1 c1_id 20 c1_color {"blue"} R1 alice1
            }
            class c2 {
                instance alice1 c2_id 15
            }
        }
    }
    log::debug [formatMiccaClass DirectionalReference]
    testConditions\
        {[refMultiplicity [DirectionalReference findWhere\
            {$ReferenceType eq "static"}]] == 1}
} -result {1}
----

==== Checking Reference Values

The values given to reference components for a population are
simply strings that must refer to instances names of the proper
class.
We need to go though all the values for the various types of references
and make sure they were specified correctly.

[source,c]
----
<<population: check reference values>>=
<<population: check superclass references>>
<<population: check subclass references>>
<<population: check associator references>>
<<population: check association references>>
----

==== Checking Superclass Reference Values

When a subclass defines a reference to its superclass,
we must make sure that the superclass instance actually exists.

[source,c]
----
<<population: check superclass references>>=
set supers [pipe {
    ReferencedSuperclass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation project ~ Domain Class Relationship |
    relation rename ~ Class Superclass
}]
set popinsts [pipe {
    ClassInstance findWhere {$Population eq $name} |
    deRef ~
}]
puts [relformat $popinsts popinsts]

# We can save ourselves some substantial computation if there are no
# ReferencedSuperclass instances in the domain.
# Note that the computation works properly without this test, we are
# just skipping things is we know at this point the result will be empty.
if {[relation isnotempty $supers]} {
    #puts [relformat $supers supers]
    set badrefs [pipe {
        SuperclassReference findWhere {$Domain eq $domain} |
        findRelatedWhere % {R23 R21 {~R103 ClassComponentValue}}\
            {$Population eq $name} |
        deRef % |
        relation rename % Component Relationship |
        relation join % $supers |
        relation rename % Class Subclass Superclass Class Instance Subinstance\
            Value Instance |
        ralutil::rvajoin % $popinsts ValueMatch |
        relation restrictwith % {[relation isempty $ValueMatch]}
    } {} |%]
    #puts [relformat $badrefs badsuperrefs]

    relation foreach badref $badrefs {
        relation assign $badref
        log::error "in population, \"$Population\", for domain, \"$Domain\",\
            subclass instance, \"$Subclass.$Subinstance\", references\
            superclass instance, \"$Class.$Instance\" across,\
            \"$Relationship\", but $Instance does not exist"
        incr errcount
    }
}
----

[source,tcl]
----
<<config command tests>>=
test populate-4.4 {
    bad superclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {
                attribute s_id int
            }
            class sub1 {
                attribute temp int -default 25
                reference R1
            }
            class sub2 {
                attribute color int -default 25
                reference R1
            }

            generalization R1 super sub1 sub2
        }

        population p1 bar {
            class super {
                instance super1 s_id 20
                instance super2 s_id 40
            }
            class sub1 {
                instance fred1 R1 super1
            }
            class sub2 {
                instance alice1 R1 super3 ; # There is no "super3" instance.
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

==== Checking Subclass Reference Values

When a superclass instance refers to its subclass,
the population value is a list of the form {<subclass> <instance>},
where <subclass> must be one of the subclasses of the generalization
and <instance> must be an instance of <subclass>.
Here we check both conditions.

[source,c]
----
<<population: check subclass references>>=
set subs [pipe {
    ReferringSubclass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation project ~ Domain Class Relationship
}]
# puts [relformat $subs subs]

# HERE check for the Value to be a list of length 2
set subrefs [pipe {
    SubclassReference findWhere {$Domain eq $domain} |
    findRelatedWhere % {R23 R21 {~R103 ClassComponentValue}}\
        {$Population eq $name} |
    deRef % |
    relation rename % Class Superclass Component Relationship\
            Instance Superinstance |
    relation extend % brtuple\
        Class string {[lindex [tuple extract $brtuple Value] 0]}\
        Instance string {[lindex [tuple extract $brtuple Value] 1]} |
    relation eliminate % Value
} {} |%]
# puts [relformat $subrefs subrefs]

set nonparts [relation semiminus $subs $subrefs]
# puts [relformat $nonparts nonparts]

relation foreach nonpart $nonparts {
    relation assign $nonpart
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        superclass instance, \"$Superclass.$Superinstance\", references\
        subclass instance, \"$Class.$Instance\" across,\
        \"$Relationship\", but $Class is not a subclass of $Relationship"
    incr errcount
}

set badrefs [pipe {
    relation minus $subrefs $nonparts |
    ralutil::rvajoin ~ $popinsts ValueMatch |
    relation restrictwith ~ {[relation isempty $ValueMatch]}
}]

relation foreach badref $badrefs {
    relation assign $badref
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        superclass instance, \"$Superclass.$Superinstance\", references\
        subclass instance, \"$Class.$Instance\" across,\
        \"$Relationship\", but $Instance does not exist"
    incr errcount
}
----

[source,tcl]
----
<<config command tests>>=
test populate-4.5 {
    bad subclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {
                attribute s_id int
                reference R1
            }
            class sub1 {
                attribute temp int -default 25
            }
            class sub2 {
                attribute color int -default 25
            }

            generalization R1 super sub1 sub2
        }

        population p1 bar {
            class super {
                instance super1 s_id 20 R1 {sub1 fred1}
                instance super2 s_id 40 R1 {sub2 alice2} ; # there is no alice2
                instance super3 s_id 40 R1 {sub3 foo} ; # there is no sub3
            }
            class sub1 {
                instance fred1
            }
            class sub2 {
                instance alice1
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

==== Checking Associator Reference Values

// This does not handle the reflexive case.
// In that case we expect the reference value to be {forward xx backward yy}
// where xx and yy are instances names of the reflexive class.

[source,c]
----
<<population: check associator references>>=
set assocref [AssociatorClass findWhere {$Domain eq $domain}]
set srcrefs [findRelated $assocref R42 ~R34]
set targetrefs [findRelated $assocref R42 ~R35]

set assocs [pipe {
    deRef $assocref |
    relation project ~ Domain Class Relationship
}]
# puts [relformat $assocs assocs]

set sources [pipe {
    deRef $srcrefs |
    relation project ~ Domain Class Relationship
}]
# puts [relformat $sources sources]

set targets [pipe {
    deRef $targetrefs |
    relation project ~ Domain Class Relationship
}]
# puts [relformat $targets targets]

set participants [relation union $sources $targets]

set assocvalues [pipe {
    AssociatorReference findWhere {$Domain eq $domain} |
    findRelatedWhere % {R23 R21 {~R103 ClassComponentValue}}\
        {$Population eq $name} |
    deRef % |
    relation rename % Class Assocclass Component Relationship\
        Instance Associnstance
} {} |%]
# puts [relformat $assocvalues assocvalues]

set onerefs [pipe {
    relation extend $assocvalues atup\
        Class string {[lindex [tuple extract $atup Value] 0]}\
        Instance string {[lindex [tuple extract $atup Value] 1]} |
    relation eliminate ~ Value
}]
# puts [relformat $onerefs onerefs]

set otherrefs [pipe {
    relation extend $assocvalues atup\
        Class string {[lindex [tuple extract $atup Value] 2]}\
        Instance string {[lindex [tuple extract $atup Value] 3]} |
    relation eliminate ~ Value
}]
# puts [relformat $otherrefs otherrefs]

set allrefs [relation union $onerefs $otherrefs]
# puts [relformat $allrefs allrefs]

set nonparts [relation semiminus $participants $allrefs]
# puts [relformat $nonparts nonparts]

relation foreach nonpart $nonparts {
    relation assign $nonpart
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        associator instance, \"$Assocclass.$Associnstance\", references\
        class instance, \"$Class.$Instance\" across,\
        \"$Relationship\", but $Class does not participate in $Relationship"
    incr errcount
}

set allrefs [relation minus $allrefs $nonparts]
# puts [relformat $allrefs allrefs]

set badrefs [pipe {
    ralutil::rvajoin $allrefs $popinsts ValueMatch |
    relation restrictwith ~ {[relation isempty $ValueMatch]}
}]
# puts [relformat $badrefs badrefs]

relation foreach badref $badrefs {
    relation assign $badref
    log::error "in population, \"$Population\", for domain, \"$Domain\",\
        associator instance, \"$Assocclass.$Associnstance\", references\
        instance, \"$Class.$Instance\" across,\
        \"$Relationship\", but $Instance does not exist"
    incr errcount
}

----

[source,tcl]
----
<<config command tests>>=
test populate-4.6 {
    bad associator class reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {
                attribute date int -default 0
                reference R1
            }
            class X {
                attribute temp int -default 25
                reference R1
            }
            class Y {
                attribute color int -default 25
                reference R1
            }

            association R1 -associator A X 1--1 Y
        }

        population p1 bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2} ; # instance y2 is not defined
                instance a3 R1 {Z x2 Q y2} ; # neither Z nor Q participate in R1
            }
            class X {
                instance x1 R1 a1
                instance x2 R1 a2
            }
            class Y {
                instance y1 R1 a1
            }
        }
    }
} -result {encountered 3 configuration script errors} -returnCodes error
----

==== Checking Association Reference Values

[source,c]
----
<<population: check association references>>=
----

=== Class

The `class` command (in the context of a population) is used to specify
the initial instances of a class.

*****
`class` _name_ _script_

`name`::
    The name of the class.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of class component values for a class.

The `class` command is used to define initial instances for a class.
*****

Populating a class entails specifying attribute and reference values
as well as setting space allocation and storage characteristics of the class.
As we said before,
the `micca` architecture allocates a fixed amount of space for each class.
This determines the maximum number of instances that may exist
simultaneously.
A class population can consist of initial instances as well as those
created at run time.
Initial instances may be deleted at run time and their space
is then available for newly created instances.
To control the amount of space allocated,
the `allocation` command can be used to set the additional number of instances
beyond the initial instances that are allocated.
The total number of simultaneous instances is then the sum of the
allocation amount and the initial instances.

Classes can also be allocated to read-only memory.
If there is no dynamic activity on a class, such as state models or
attribute updates,
then the attributes and references can be placed in constant memory.
For small embedded system this can be a significant saving of read/write
memory which is usually in shorter supply.

To accommodate the class population commands we need a namespace
in which to evaluate the script.

[source,tcl]
----
<<class instance config namespace layout>>=
namespace eval ClassInstDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class instance commands>>
}
----

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<population config commands>>=
proc class {name script} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name class
    }

    variable PopulationName
    variable DomainName

    namespace upvar ClassInstDef ClassName ClassName IsDynamic IsDynamic\
        Allocation Allocation IsConstant IsConstant
    set ClassName $name
    set IsDynamic {}
    set Allocation 0
    set IsConstant false

    ConfigEvaluate [namespace current]::ClassInstDef $script

    if {$IsDynamic eq {}} {
        set IsDynamic true
    }
    ElementPopulation create Population $PopulationName\
        Domain $DomainName Element $name
    ClassPopulation create Population $PopulationName Domain $DomainName\
            Class $name
    if {$IsDynamic} {
        DynamicClassPopulation create Population $PopulationName\
            Domain $DomainName Class $name Allocation $Allocation\
    } else {
        StaticClassPopulation create Population $PopulationName\
            Domain $DomainName Class $name IsConstant $IsConstant
    }

    return
}
----

=== Dynamic Class Population

*****
`dynamic` ?_size_?

`size`::
    The number of additional class instances beyond those defined
    by the initial instances for which storage is allocated.

The `dynamic` command is used declare that a class population is dynamic and
optionally to allocate space for additional class instances that will be
created at run time.
If no `dynamic` command is invoked for a class,
then the class is assumed to be dynamic with zero additional instances
allocated.
*****

[float]
==== Implementation

[source,tcl]
----
<<class instance commands>>=
proc dynamic {{size 0}} {
    variable IsDynamic
    if {$IsDynamic eq {}} {
        set IsDynamic true
        variable Allocation $size
    } elseif {$IsDynamic} {
        variable ClassName
        error "$ClassName is already declared as a dynamic population"
    } else {
        variable ClassName
        error "$ClassName is already declared as a static population"
    }

    return
}
----

=== Static Class Population

*****
`static` ?_isconstant_?

`isconstant`::
    A boolean value that determines if the population of the class will
    be placed in read only memory.
    If missing, then _isconstant_ is assumed to be false.

The `static` command declares that the population of a class is
static and optionally whether the class is stored in read only memory.
It is an error to declare classes that have state models as constant.
Attempting to update attributes at run time for a constant class will
result in undefined behavior.
*****

[float]
==== Implementation

[source,tcl]
----
<<class instance commands>>=
proc static {{isconstant false}} {
    variable IsDynamic
    if {$IsDynamic eq {}} {
        set IsDynamic false
        variable IsConstant $isconstant
    } elseif {$IsDynamic} {
        variable ClassName
        error "$ClassName is already declared as a dynamic population"
    } else {
        variable ClassName
        error "$ClassName is already declared as a static population"
    }
}
----

=== Specifying Instance Values

Instances are populated according to their class components.
Class components are of several types but primarily are either
attributes or references.

Attribute values are specified using strings in ``C'' syntax.
The attribute value will be passed along to the generated code file
and must be valid ``C'' initializers.
For example the value for an `int` attribute can be specified as
0x20 or 32 and the ``C'' compiler will handle either.

Reference components present a bigger challenge to specify.
Since fundamentally references will resolve down to object addresses,
initializing references uses instance names as the place holder for
the class instance address.
Different reference types require some additional structure.

* Single references just require a single instance name. The instance
name must be one that is defined for the class to which the reference
refers.
* Multiple reference situation take a list of instance names.
So a reference that refers to many instances must specify a list
of instance names as its initial value.
* References to subclasses are of the form of a two element list,
the first element being the name of the subclass and the second
being the name of the instance.
It is required that the subclass name be one of the subclasses in the
generalization and the instance must be defined for that subclass.
* Reflexive associations require additional path specification
if both directions of the relationship have references defined.
In this case the references are in the form of a dictionary
with keys `forward` and `backward` to indicate the references
in the direction of traversal.
The values of the dictionary are lists of instance names.
The length of the instance names list must be appropriate to the
multiplicity of the reference.

The default value for an attribute or reference is specified by the
literal string, "-".
It is an error to specify a default value for an attribute for which
not default was define during the domain configuration.
The default value of a reference is the _nil_ reference,
which refers to no instance.
It is an error to specify the _nil_ value for a reference representing
an unconditional side of a relationship.
If an attribute value needs to be set to "-", then it must be escaped
and written as, "\-".

=== Setting Instance Values

The `instance` command defines the class component values for an instance
and gives the instance a name.
It is a convenient way to specify a small number of class instances.

*****
`instance` _name_ _comp1 value1 comp2 value2 ..._

`name`::
    The name of the instance. Instance names must be unique within a
    class.
`compN valueN`::
    The remaining arguments are in the form of component name / component
    value pairs. All components of a class must be present except for
    those which have defined default values.

The `instance` command defines a class instance named, _name_, and
gives the class components given by the _compN_ arguments the
corresponding _valueN_ value.
*****

[float]
==== Implementation

We want the `instance` command to set the values for every class component
that can be set, _i.e._ we don't want any underdefined instances.
To do that,
we will determine if the component names provided are sufficient.
If they are, then we can create the Class Instance and the set
of Class Component Value instances.
The latter fall into two types,
those provided as arguments and those which are missing from the arguments but
for which a default value can be deduced.


[source,tcl]
----
<<class instance commands>>=
proc instance {name args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 [namespace parent]::PopulationName PopulationName
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    <<instance: determine correct components>>

    set insttuple [list\
        Population $PopulationName\
        Domain $DomainName\
        Class $ClassName\
        Instance $name\
    ]
    ClassInstance create {*}$insttuple\
        Number [GenNumber $DomainName ClassInstance\
            [list $PopulationName $DomainName $ClassName]]

    <<instance: set values from arguments>>

    <<instance: set remaining defaulted values>>

    return
}
----

To determine if we have the correct components as arguments,
we need to find those components that must be set,
_i.e._ they have no reasonable default.
That set component names must be a subset of those provided as arguments.

[source,tcl]
----
<<instance: determine correct components>>=
set compnames [FindComponentNames $DomainName $ClassName]
set argcomps [dict keys $args]
set compdiff [struct::set difference $compnames $argcomps]
if {![struct::set empty $compdiff]} {
    error "for domain, \"$DomainName\",\
        population, \"$PopulationName\", class, \"$ClassName\",\
        instance, \"$name\", values for class components,\
        \"[join $compdiff {, }]\", are not provided\
        and have no default values"
    return
}
----

All class components must be set to a value _except_ attributes that
have a default value, association references that can be set to _nil_
and link containers which are not set by the user.

[source,tcl]
----
<<helper commands>>=
proc FindComponentNames {domain class} {
    set assocrefs [pipe {
        AssociationReference findWhere {$Domain eq $domain && $Class eq $class} |
        findRelated ~ R23 R21
    }]
    set defcomps [pipe {
        DefaultValue findWhere {$Domain eq $domain && $Class eq $class} |
        findRelated ~ R22 R21
    }]
    set lcont [pipe {
        LinkContainer findWhere {$Domain eq $domain && $Class eq $class} |
        findRelated ~ R21
    }]
    set compnames [ClassComponent findWhere\
        {$Domain eq $domain && $Class eq $class}]

    set settable [pipe {
        refMinus $compnames $assocrefs |
        refMinus ~ $defcomps |
        refMinus ~ $lcont |
        deRef ~ |
        relation project ~ Name |
        relation list ~ Name
    }]
}
----

Create a Class Component Value instance for all the provided component
name / component values provided as arguments to the `instance` command.

[source,tcl]
----
<<instance: set values from arguments>>=
dict for {compname value} $args {
    set value [ResolveInitialValue $DomainName $ClassName $compname $value]
    ClassComponentValue create {*}$insttuple\
        Component $compname Value $value
}

----

The class components that remain to be set to default values are
those class components that are *not* link containers (these are always set
as part of setting a linked reference) and have not already been set
from the provided arguments.

[source,tcl]
----
<<instance: set remaining defaulted values>>=
set defaultcomps [FindRemainingComponents $DomainName $ClassName $argcomps]
foreach compname $defaultcomps {
    set value [ResolveInitialValue $DomainName $ClassName $compname -]
    ClassComponentValue create {*}$insttuple\
        Component $compname Value $value
}
----

[source,tcl]
----
<<helper commands>>=
proc FindRemainingComponents {domain class except} {
    set lcont [pipe {
        LinkContainer findWhere {$Domain eq $domain && $Class eq $class} |
        findRelated ~ R21
    }]
    set remcomps [ClassComponent findWhere {$Domain eq $domain &&\
        $Class eq $class && $Name ni $except}]
    return [pipe {
        refMinus $remcomps $lcont |
        deRef ~ |
        relation list ~ Name
    }]
}
----

==== Resolving Initial Values

Because we introduced the "-" syntax for specifying default values,
we need to look up any defaults at instance population time.
This procedure does the work of insuring that the component exists
and if the default value was specified, makes sure such a default was defined
for the attribute or is the _nil_ reference value.

[source,tcl]
----
<<helper commands>>=
proc ResolveInitialValue {domain class component value} {
    if {$value eq "-"} {
        set compref [ClassComponent findById\
            Domain $domain\
            Class $class\
            Name $component]
        if {[isNotEmptyRef $compref]} {
            # Check for default attribute value
            set attrref [findRelated $compref {~R21 Attribute}]
            if {[isNotEmptyRef $attrref]} {
                set defref [findRelated $attrref ~R22]
                if {[isNotEmptyRef $defref]} {
                    return [readAttribute $defref Value]
                }
                error "attribute $component does not have a default value"
            }
            # Check for an association reference we can set to nil
            set refref [findRelated $compref {~R21 Reference}\
                    {~R23 AssociationReference}]
            if {[isNotEmptyRef $refref]} {
                return @nil@
            }
            error "component, \"$component\", cannot be set to a default value"
        }
    } else {
        set value [subst -nocommands -novariables $value]
    }

    return $value
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test populate-1.0 {
    population instances
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                reference R1
            }
            class c2 {
                attribute c2_id int
                reference R1
            }
            association R1 c1 1..*--1 c2
        }

        population p1 foo {
            class c1 {
                instance chuck1 c1_id 5 R1 fred1
                instance chuck2 c1_id 7 R1 fred1
            }
            class c2 {
                static
                instance fred1 c2_id 20 R1 {chuck1 chuck2}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 3}\
        {[refMultiplicity [ClassComponentValue findAll]] == 6}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.1 {
    population instances using default values
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int -default 5
                reference R1
            }
            class c2 {
                attribute c2_id int
                reference R1
            }
            association R1 c1 1..*--0..1 c2
        }

        population p1 foo {
            class c1 {
                # color attribute is defaulted
                instance chuck1 c1_id 5 R1 fred1
                instance chuck2 c1_id 7 ; # leave off R1 ==> set to nil
            }
            class c2 {
                static
                instance fred1 c2_id 20 R1 {chuck1 chuck2}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 3}\
        {[refMultiplicity [ClassComponentValue findAll]] == 8}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.2 {
    population fails for under specifying components
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int
                reference R1
            }
            class c2 {
                attribute c2_id int
                reference R1
            }
            association R1 c1 1..*--0..1 c2
        }

        population p1 foo {
            class c1 {
                instance chuck1 c1_id 5 R1 fred1 ; # missing color
                instance chuck2 c1_id 7 color 10
                instance chuck3 R1 fred1 ; # missing c1_id and color
            }
            class c2 {
                static
                instance fred1 c2_id 20 R1 {chuck1 chuck2}
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

=== Tables of Instance Values

The `instance` command is useful for defining a small number of
initial instances, but can become tedious when larger number of instances
are involved.
For that case,
the `table` command is provided which allows class component values to
be specified in a more tabular layout without having to repeat the
class component names.

*****
`table` _heading_ _name1 values1 name2 values2 ..._

`heading`::
    A list of class component names that are to be specified in
    the remaining arguments
`nameN valuesN`::
    A list of instance names / instance value set pairs.
    Each _nameN_ argument gives the name of an instance to be initialized.
    Each corresponding _valueN_ argument is a list of values to be
    given the the instance.
    The number of values must match the number of component names in the
    _heading_ argument.
    Values are assigned to class components from the _valueN_ argument
    in the same order as the component names in the _heading_.

The `table` command is used to define initial instance values for
the class components.
The components to be initialized are given as a list in the _heading_ argument.
Subsequent arguments then give a name to the instance and a
list of class component values that correspond to _heading_.
Appropriately formatted,
the `table` command can show instance values in a more orderly tablular fashion
than the `instance` command and saves repeating class component names.
*****

[float]
==== Implementation

Our implementation of the `table` command follows from that of
the `instance` command.
The difference is that there is another iteration that allows multiple
instances to be created.

[source,tcl]
----
<<class instance commands>>=
proc table {heading args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 ::micca::@Config@::DomainDef::DomainName DomainName
    upvar #0 [namespace parent]::PopulationName PopulationName
    variable ClassName

    <<table: determine correct components>>

    set insttuple [list\
        Population $PopulationName\
        Domain $DomainName\
        Class $ClassName\
    ]

    dict for {instname compvalues} $args {
        if {[llength $heading] != [llength $compvalues]} {# <1>
            error "number of component values does not match heading:\
                got [llength $compvalues], expected [llength $heading]"
        }
        dict set insttuple Instance $instname ; # <2>

        <<table: set values from arguments>>

        <<table: set remaining defaulted values>>
    }

    return
}
----
<1> The number values associated with each instance have to match the
heading.
<2> Each time through the loop, set up a new instance name.

The `heading` argument must have all the component names that
cannot be defaulted in some way.

[source,tcl]
----
<<table: determine correct components>>=
set compnames [FindComponentNames $DomainName $ClassName]
set compdiff [struct::set difference $compnames $heading]
if {![struct::set empty $compdiff]} {
    error "for domain, \"$DomainName\",\
        population, \"$PopulationName\", class, \"$ClassName\",\
        instance, \"$name\", values for class components,\
        \"[join $compdiff {, }]\", are not provided\
        and have no default values"
    return
}
----

We start by creating the Class Instance and setting up
Class Component Values that match the arguments.

[source,tcl]
----
<<table: set values from arguments>>=
ClassInstance create {*}$insttuple\
    Number [GenNumber $DomainName ClassInstance\
        [list $PopulationName $DomainName $ClassName]]
foreach compname $heading compvalue $compvalues {
    set compvalue [ResolveInitialValue $DomainName $ClassName $compname\
            $compvalue]
    ClassComponentValue create {*}$insttuple\
        Component $compname Value $compvalue
}
----

Finally, Class Component Value instances are created for any missing components
that can have a default value.

[source,tcl]
----
<<table: set remaining defaulted values>>=
set defaultcomps [FindRemainingComponents $DomainName $ClassName\
        $heading]
foreach compname $defaultcomps {
    set compvalue [ResolveInitialValue $DomainName $ClassName\
            $compname -]
    ClassComponentValue create {*}$insttuple\
        Component $compname Value $compvalue
}
----

[source,tcl]
----
<<config command tests>>=
test populate-2.0 {
    Population using tables
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                reference R1
            }
            class c2 {
                attribute c2_id int
                reference R1
            }
            association R1 c1 1..*--1 c2
        }

        population p1 foo {
            class c1 {
                dynamic 10
                table   {c1_id      R1}\
                chuck1  {5          fred1}\
                chuck2  {7          fred1}
            }
            class c2 {
                static
                table       {c2_id      R1}\
                fred1       {20         {chuck1 chuck2}}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 3}\
        {[refMultiplicity [ClassComponentValue findAll]] == 6}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-2.1 {
    Population using tables and default values
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int -default 42
                reference R1
            }
            class c2 {
                attribute c2_id int
                reference R1
            }
            association R1 c1 1..*--0..1 c2
        }

        population p1 foo {
            class c1 {
                dynamic 10
                table   {c1_id      R1}\
                chuck1  {5          fred1}\
                chuck2  {7          fred1}\
                chuck3  {7          -}
            }
            class c2 {
                static
                table       {c2_id      R1}\
                fred1       {20         {chuck1 chuck2 chuck3}}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 4}\
        {[refMultiplicity [ClassComponentValue findAll]] == 11}
} -result {1}
----

=== Populating Multiple Assigners

For multiple assigners,
it is necessary to specify which instances of the identifying class
is associated to the assigner.
The only information needed to define an assigner is its name
and the name of the instance of the identifying class corresponding to the
assigner.

We start with the now familiar namespace definition.

[source,tcl]
----
<<assigner instance config namespace layout>>=
namespace eval AssignerInstDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<assigner instance commands>>
}
----

=== Assigner

The `assigner` command (in the context of a population) is used to specify
the initial instances of an assigner

*****
`assigner` _association_ _script_

`association`::
    The name of the assocition which has a multiple assigner.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of assigner values.

The `assigner` command is used to define initial instances for an assigner.
*****

[float]
==== Implementation

(((micca,Config,assigner)))
[source,tcl]
----
<<population config commands>>=
proc assigner {assoc script} {
    variable PopulationName
    variable DomainName

    set maref [MultipleAssigner findById Domain $DomainName Association $assoc]
    if {[isEmptyRef $maref]} {# <1>
        tailcall DeclError UNKNOWN_MULT_ASSIGNER $assoc
    }

    namespace upvar AssignerInstDef AssocName AssocName IdClass IdClass
    set AssocName $assoc
    set IdClass [readAttribute $maref Class]

    ConfigEvaluate [namespace current]::AssignerInstDef $script

    if {[isEmptyRef [ElementPopulation findById Population $PopulationName\
            Domain $DomainName Element $assoc]]} {
        ElementPopulation create Population $PopulationName\
            Domain $DomainName Element $assoc
        AssignerPopulation create Population $PopulationName\
            Domain $DomainName Association $assoc
    }

    return
}
----
<1> We need to know the identifying class and insist it is define by this
point.

=== Populating An Assigner Instance

The `instance` command (in the context of an assigner) is used to specify
the initial instance of the identifying class assocated with the assigner
instance.

*****
`instance` _name_ _script_

`name`::
    The name of the assigner instance.
`idinstance`::
    The name of the identifying instance associated with the assigner.
    The _idinstance_ must be an instance defined for the identifying
    class associated with the multiple assigner.

The `instance` command is used to define initial instances for an assigner.
*****

[float]
==== Implementation

[source,tcl]
----
<<assigner instance commands>>=
proc instance {name idinstance} {

    upvar #0 [namespace parent]::PopulationName PopulationName
    upvar #0 [namespace parent]::DomainName DomainName
    variable AssocName
    variable IdClass

    MultipleAssignerInstance create\
        Population $PopulationName\
        Domain $DomainName\
        Association $AssocName\
        Instance $name\
        Number [GenNumber $DomainName MultipleAssignerInstance\
            [list $PopulationName $DomainName $AssocName]]\
        IdClass $IdClass\
        IdInstance $idinstance

    return
}
----

[source,tcl]
----
<<config command tests>>=
test populate-3.0 {
    Populate a multiple assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
                reference R1
                reference R2
            }
            class client {
                reference R1
            }
            association R1 clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {
                reference R2
            }
            association R2 department 1..*--1 clerk
        }

        population p1 foo {
            class clerk {
                instance fred R2 shoes
                instance alice R2 mens
                instance john R2 housewares
            }
            class client {
                dynamic 10
            }
            class department {
                instance shoes R2 fred
                instance mens R2 alice
                instance housewares R2 john
            }
            assigner R1 {
                instance shoeclerks shoes
                instance mensclerks mens
                instance housewaresclerks housewares
            }
        }
    }
    log::debug [formatMiccaClass AssignerPopulation]
    log::debug [formatMiccaClass MultipleAssignerInstance]
    log::debug [formatMiccaClass ClassInstance]
    testConditions\
        {[refMultiplicity [AssignerPopulation findAll]] == 1}\
        {[refMultiplicity [MultipleAssignerInstance findAll]] == 3}\
} -result {1}
----

== Handling Configuration Errors

One of the design elements of the configuration DSL is the use of
the `micca` platform model to hold the configuration information.
This design approach allows us to encode the rules for what is a valid
domain configuration into the constraints.
Any attempt to define domain elements that violate those rules
will be caught at the end of the relvar transaction that end
the `configure` command.

The problem with this approach is that the error messages the are
returned refer to the classes of the platform model not those of
the domain we were attempting to define.

We will mitigate this problem by capturing the result returned by
TclRAL and turning it into error messages that are more meaningful
to the task of configuring a domain.
Unfortunately,
the messages produced by TclRAL are intended to be human readable,
so we will have to parse them into a form that is easier to deal
with programmatically.
Fortunately, the messages are very regular in structure so
the parsing code need not be very sophisticated.

Our strategy is to extract only the essential information from the
error message and then map the information onto a more meaningful error
message.
Part of what we want to include in the error message is the values
from the tuples failing the constraint.
These values contain information the user entered rather than the
abstractions of the platform model.

The essential information mapping is shown below.
Naturally enough, we hold it in a relvar.

[source,tcl]
----
<<config data>>=
relvar create Config_DataError {
    Relationship        string
    RefClass            string
    RefType             string
    Format              string
} {Relationship RefClass RefType}
----

The *Relationship* attribute is the name of the relationship in the
platform model that failed the constraint check.
The *RefClass* attribute is the platform model class that has the tuples
that failed the constraint check.
The *RefType* attribute defines the way in which the constraint failed.
The *Format* attribute is a string that contains the text of the
error message that we want to display.
The text in the *Format* attribute may also contain variable references
to attributes in the tuple of *RefClass* that failed.
The variable references in the *Format* will be substituted
with the values from the failing tuples in order to give specifics of
the error back to the user.

[float]
===== Implementation

The design of the `HandleConfigError` procedure is shown below.
It is a nested iteration over the lines of the error result, pulling
off the constraint violation details and then iterating over the
tuples that were found in the violation.

(((micca,Config,HandleConfigError)))
[source,tcl]
----
<<config commands>>=
proc HandleConfigError {result} {
    set lines [split [string trimright $result] \n]
    set nlines [llength $lines]
    set lineno 0
    upvar #0 ::micca::@Config@::errcount errcount
    while {$lineno < $nlines} {
        <<HandleConfigError: examine one failure>>
    }

    return
}
----

The information in the TclRAL error message is simple enough
and well structured enough that a regular expression can be used
to match and extract the interesting parts.

[source,tcl]
----
<<HandleConfigError: examine one failure>>=
set line [lindex $lines $lineno]
incr lineno
if {[regexp {^for[^:]+([^(]+)\(.+\), in relvar (.+)$} $line\
        match rnum refclass]} {
    set rnum [namespace tail $rnum]
    set refclass [namespace tail $refclass]

    # Now iterate over the "tuple" lines that follow the constraint message.
    while {$lineno < $nlines} {
        set tupline [lindex $lines $lineno]
        if {[regexp {^tuple {(.+)} (.+)$} $tupline match tuple phrase]} {
            incr lineno
            incr errcount
            <<HandleConfigError: examine one tuple>>
            <<HandleConfigError: format error message>>
        } else {
            break
        }
    }
} elseif {[regexp {procedural contraint, "([^"]+)", failed} $line match\
        constraint]} {
    # There is only one procedural constraint, R74C.
    # If an error is detected in the procedural constraint script,
    # messages will be printed there.
    # If anything other than R74C come along, we will just log it.
    if {[namespace tail $constraint] ne "R74C"} {
        log::error $result
        incr errcount
    }
} else {
    log::error $result
    incr errcount
}
----

We match the phrase in the tuple message to create an enumeration of
the types of constraint violations.
These are just a bit simpler to handle and look up.

[source,tcl]
----
<<HandleConfigError: examine one tuple>>=
if {[string match {is not referenced*} $phrase]} {
    set reftype notrefed
} elseif {[string match {references no*} $phrase]} {
    set reftype refnone
} elseif {[string match {*to by multiple*} $phrase]} {
    set reftype multrefed
} elseif {[string match {is not referred to*} $phrase]} {
    set reftype notrefto
} else {
    log::error "unknown constraint phrasing, \"$phrase\""
    continue
}
----

Finally, we look up the format information and generate an error message.
Using the `dict with` command allows us to take the tuple value from the
error message, treat it like a dictionary and get the values into
Tcl variable.
The `subst` command then will perform the variable substitutions in the
format string.

[source,tcl]
----
<<HandleConfigError: format error message>>=
set cde [relvar restrictone Config_DataError Relationship $rnum RefClass\
        $refclass RefType $reftype]
if {[relation isnotempty $cde]} {
    dict with tuple {
        log::error [subst -nocommands [relation extract $cde Format]]
    }
} else {
    log::error "$line\n$tupline"
}
----

We now need to enumerate all the platform model constraints that can be violated
and supply messages that provide less abstract and more useful user error
messages.
Because of the way the configuration data is stored into the platform model
classes,
not all violations are even possible.

[source,tcl]
----
<<config data>>=
relvar insert Config_DataError {
    Relationship        R20
    RefClass            Class
    RefType             notrefed
    Format              {in domain, \"$Domain\", class, \"$Name\",\
                        has no class components}
} {
    Relationship        R21
    RefClass            ClassComponent
    RefType             notrefto
    Format              {in domain, \"$Domain\", class, \"$Class\",\
                         component, \"$Name\", failed to be completed created}
} {
    Relationship        R86
    RefClass            DeferredEvent
    RefType             notrefed
    Format              {in domain, \"$Domain\", class, \"$Model\",\
                        defines event, \"$Event\" as polymorphic, yet\
                        $Model is not a superclass}
} {
    Relationship        R101
    RefClass            ElementPopulation
    RefType             refnone
    Format              {in population, \"$Population\",\
                         for domain, \"$Domain\", class or assigner,\
                         \"$Element\", does not exist}
} {
    Relationship        R72
    RefClass            StateTransition
    RefType             refnone
    Format              {in domain, \"$Domain\", class or assigner,\
                         \"$Model\", for the transition,\
                         \"$State - $Event -> $NewState\", state $NewState does\
                         not exist}
} {
    Relationship        R70
    RefClass            TransitionPlace
    RefType             refnone
    Format              {in domain, \"$Domain\", class or assigner,\
                         \"$Model\", event, \"$Event\", causes a transition\
                         out of state, \"$State\", but state $State does not\
                         exist}
} {
    Relationship        R103
    RefClass            ClassComponentValue
    RefType             refnone
    Format              {in population, \"$Population\", for domain,\
                         \"$Domain\", class, \"$Class\", instance,\
                         \"$Instance\" sets the value of \"$Component\" to\
                         \"$Value\", but $Component is not a known\
                         element of $Class"}
}
----

== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path {::micca ::rosea::InstCmds}

    <<helper data>>
    <<helper commands>>
}
----

=== DeclError

All error notification in the package is consolidated in
the +DeclError+ procedure.

[float]
==== Implementation

The +DeclError+ procedure locates a format string based on the error code
and applies its arguments to it.
We use the +::throw+ command to raise the error to insure that we have
consistent error code information for the package.

(((micca,Helpers,DeclError)))
[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list MICCA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

=== Generate Numbers

There are a number of classes that have attributes that are
zero based sequential numbers.
We want a convenient way to generate these ordinal numbers.
Many times we want the number to start at zero within a set of
attributes.

[float]
==== Implementation

[source,tcl]
----
<<helper data>>=
relvar create SeqNumbers {
    Domain string
    ClassName string
    Attrs list
    Number int
} {Domain ClassName Attrs}
----

(((micca,Helpers,GenNumber)))
[source,tcl]
----
<<helper commands>>=
proc GenNumber {domain class args} {
    set num [relvar restrictone SeqNumbers Domain $domain ClassName $class\
        Attrs $args]
    if {[relation isempty $num]} {
        relvar insert SeqNumbers [list\
            Domain $domain\
            ClassName $class\
            Attrs $args\
            Number 0\
        ]
        return 0
    } else {
        set result [expr {[relation extract $num Number] + 1}]
        relvar updateone SeqNumbers sn [list Domain $domain ClassName $class\
            Attrs $args] {
            tuple update $sn Number $result
        }
        return $result
    }
}
----

=== Parse C Type Names

There a number of places where we require a ``C'' type name.
We have adopted the strategy to separate out ``C'' identifiers from
type names when parameters and other such things are required.
In ``C'' itself, parameter and variables follow a declaration
type syntax that is meant to be mnemonic of the way a variable is used.
We find it easier to keep identifiers and types separate,
but it means we need to be able to verify that a given type name is
syntactically correct and to compose a type name and identfier into
a variable or parameter declaration.

Since this is strictly a parsing problem,
we will rely on the parser tools that are part of `tcllib`.
The parser tools take a PEG specification and generate a parser in Tcl.
We will not discuss the grammar and other details of this parsing.
Suffice it to say that we have formulated a PEG for parsing standard
``C'' type names.
The output of the parser tools is a Tcl OO class that can parse a text
string and return an AST of the type name.
We will use the Tcl OO class as a superclass and provide two methods
in our derived class that perform the required type name validation
and generate a variable declaration from a type name and identifier.

[float]
==== Implementation

[source,tcl]
----
<<required packages>>=
package require oo::util
----

(((micca,Helpers,typeverifier)))
[source,tcl]
----
<<helper commands>>=
source [file dirname [info script]]/typename/typeparser.tcl

oo::class create typeverifier {
    superclass typeparser

    method verifyTypeName {typename} {
        try {
            my parset $typename
            return true
        } on error {result} {
            return false
        }
    }

    method composeDeclaration {typename identifier} {
        my variable node
        set node {}

        set ast [my parset $typename]
        ::pt::ast topdown [mymethod TopWalker] $ast

        while {[llength $node] == 4} {
            set node [lindex $node end]
        }
        lassign $node nodetype start end
        return "[string range $typename 0 $end]\
            ${identifier}[string range $typename $end+1 end]"
    }

    method TopWalker {ast} {
        my variable node

        set nodetype [lindex $ast 0]
        if {$nodetype eq "specifier_qualifier_list" ||\
                $nodetype eq "abstract_declarator"} {
            set node $ast
        }
    }
}

typeverifier create typeCheck
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typecheck-1.0 {
    attribute with bad data type
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id {* int}
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test typecheck-1.1 {
    compose a variable declaration
} -setup {
} -cleanup {
} -body {
    ::micca::@Config@::Helpers::typeCheck composeDeclaration\
        {int (*)(int, int)} xx
} -result {int (* xx)(int, int)}
----

=== Checking for Duplicates

(((micca,Helpers,CheckDuplicate)))
[source,tcl]
----
<<helper commands>>=
proc CheckDuplicate {class args} {
    set ref [$class findById {*}$args]
    if {[isNotEmptyRef $ref]} {
        tailcall DeclError DUP_INSTANCE_NAME $class $args
    }
    return
}
----

(((error code,DUP_ELEMENT_NAME)))
[source,tcl]
----
<<error code formats>>=
DUP_INSTANCE_NAME    {an element of class, "%s", already exists with\
        attributes, "%s"}
----

== Test Utility Commands

There are number of utility commands that are part of the testing
infrastructure.
We present them here without additional commentary.

[source,tcl]
----
<<test utility commands>>=
namespace export getMiccaClass
proc getMiccaClass {class} {
    return [deRef [$class findAll]]
}
----

[source,tcl]
----
<<test utility commands>>=
namespace export formatMiccaClass
proc formatMiccaClass {class} {
    return \n[ral relformat [getMiccaClass $class] $class]
}
----

[source,tcl]
----
<<test utility commands>>=
namespace export readMiccaAttribute
proc readMiccaAttribute {class attr args} {
    return [rosea tunnel [$class findById {*}$args] readAttribute $attr]
}
----

[source,tcl]
----
<<test utility commands>>=
proc cleanupDomain {} {
    set preserve {
        ::micca::TransitionRule
    }
    relvar eval {
        foreach var [relvar names {::micca::[A-Z]*}] {
            if {$var ni $preserve} {
                relvar set $var [relation empty [relvar set $var]]
            }
        }
    }

    set config {
        ::micca::@Config@::Class_Reference
        ::micca::@Config@::Helpers::SeqNumbers
    }
    foreach var $config {
        relvar set $var [relation empty [relvar set $var]]
    }
}
----

[source,tcl]
----
<<test utility commands>>=
proc testConditions {args} {
    set result 1
    foreach exp $args {
        set passed [uplevel 1 [list expr $exp]]
        if {!$passed} {
            log::error "\"$exp\" failed"
            set result 0
        }
    }
    return $result
}
----
