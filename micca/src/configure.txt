// vim:set syntax=asciidoc:

= Configuring a Domain

[partintro]
--
In the last part of the book,
we showed the platform specific model that `micca` uses.
To translate a domain it is necessary to populate the platform
specific model with the specific characteristics of the domain to be translated.
Since the platform model is implemented in `rosea`,
we could populate it using the `rosea populate` command.
This would be a difficult and tedious way to populate the platform
model for a human.
It might be perfectly acceptable to create a `rosea` population
programmatically, but it requires detailed knowledge of the platform model.
We will provide a much more convenient interface for humans by using
a domain specific language (DSL).

The DSL in this case is also a Tcl script and we will build the
DSL processing directly into the `micca` domain.
We will use the Tcl interpreter to parse the DSL.
The code that reads the DSL arranges for the script to be executed in
a context where command names resolve to procedures that populate the
`micca` platform specific model.

In this part,
we describe the commands that make up the DSL to populate the
platform model.
--

== Configuration Operations

Configuring a domain in `micca` happens as a domain operation.
When we parse the various portions of a domain description,
we will use namespaces to confine the script execution and to expose
the appropriate commands to the configuration scripts.
This requires us to define child namespaces for the `micca` domain.
We must use some care in this because a `rosea` domain already has some
child namespaces defined on it. We will use a naming convention to
avoid any possible naming collisions.

In this part,
we first present the commands that are used to configure a domain under
`micca`.
These will be domain operations of the `micca` domain.
Afterwards,
we will define further child namespaces and commands within them that
accomplish gathering all the information needed to define the characteristics
of a domain.

=== Configure

One of our top level +micca+ commands is to configure a domain from
a script.

*****
+::micca configure+ _script_

+script+::
    A Tcl script that is executed in an environment that will resolve
    _domain configuration_ commands that may be used to define
    the characteristics of a domain to be translated by `micca`.
*****

[float]
==== Implementation

(((micca,operation,configure)))
[source,tcl]
----
<<micca configuration>>=
operation configure {script} {
    return [@Config@::miccaConfigure $script]
}
----

=== ConfigureFromChan

It is often convenient to obtain the +configure+ script from an I/O channel.
The +micca configureFromChan+ command supports reading the configure
script directly from a channel.

*****
+::micca configureFromChan+ _channel_

+channel+::
    A Tcl channel handle that has been opened for reading.

The `configureFromChan` command invokes `configure` on the script
obtained by reading _channel_ until end of file is reached.
*****

[float]
==== Implementation

(((micca,operation,configureFromChan)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromChan {chan} {
    return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
}
----

=== ConfigureFromFile

It is often convenient to hold the +configure+ script in a file.
The +micca configureFromFile+ command supports reading the configure
script directly from a file.

*****
+::micca configureFromFile+ _filename_

+filename+::
    The name of a file containing a domain configuration script.

The `configureFromFile` command invokes `configure` on the script
obtained by reading the contents of the file named, _filename_.
*****

[float]
==== Implementation

(((micca,operation,configureFromFile)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromFile {filename} {
    set chan [::open $filename r]
    try {
        return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
    } finally {
        ::chan close $chan
    }
}
----

== Configuration Namespace Layout

The +::micca::@Config@+ namespace holds all the procedures and data that
correspond to the DSL to populate the platform model.
We want to create a set of child namespaces
that mirror the nesting of the configuration language statements.
At the top level,
the +domain+ command is used to define each domain.
The +domain+ command accepts a script body that then defines the
components of the domain.
That script will be evaluated in a namespace where the commands that
define the domain components, _e.g._ +class+ and relationship commands,
resolve appropriately.
This lets us put commands for the body specifying a particular component into a
namespace which prevents any problems of accidentally invoking commands that
are inappropriate for that context.

We will use this technique for other child namespaces that correspond to
the nesting of DSL statements.
We layout the +::micca::@Config@+ namespace as shown below.

[source,tcl]
----
<<configuration commands namespace>>=
namespace eval @Config@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    <<helper commands namespace>>

    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds} ; # <1>
    <<config data>>
    <<config commands>>

    <<domain config namespace layout>>
}
----
<1> We are evaluating the configuration DSL outside of the
main body of the `micca` domain, but we are trying to populate
`micca` classes.
We find it convenient to resolve commands through the main `micca` namespace
as well as others that help things along.

=== Evaluating Configuration Scripts

The top level domain operations of `micca` that configure domains
all invoke `miccaConfigure` as the common entry point into the configuration
DSL code.

[float]
==== Implementation

(((micca,ensemble,configure)))
[source,tcl]
----
<<config commands>>=
proc miccaConfigure {script} {
    variable errcount
    set errcount 0

    variable configlineno
    set configlineno 1

    ConfigEvaluate ::micca::@Config@ $script

    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
CONFIG_ERRORS     {encountered %d configuration script errors}
----

You could evaluate the configuration script by simply gathering it together
and passing it to the core +namespace eval+ command.
Unfortunately,
the first error that is encountered will terminate the evaluation.
This is decidedly inconvenient as you would prefer to continue on and
come up with a list of errors for the evaluation much like a
conventional language compiler would do when compiling a source file.
Discovering errors one at a time is tediously unproductive.

Of course, it is possible to continue evaluating after an error but
that requires a bit more code.
We will also want to be able to evaluate scripts in different namespace
contexts as we described above.
We will accomplish all this by taking advantage of the core +::apply+ command
and its ability to execute a lambda function in a given namespace.
So given a script body and an namespace we can evaluate it as shown below.

(((micca,Config,ConfigEvaluate)))
[source,tcl]
----
<<config commands>>=
namespace export ConfigEvaluate

proc ConfigEvaluate {ns body} {
    variable evalLambda
    tailcall ::apply [concat $evalLambda [list $ns]] $body ; # <1>
}
----
<1> The `concat` command treats its arguments as a list.
On the off chance that the `ns` argument contains embedded whitespace,
we need to insure that it is treated as a single element list.
Hence the need to include the invocation of the `list` command.

The lambda function that performs the command evaluation is given below.
We hold the evaluation lambda as a piece of data.

[source,tcl]
----
<<config data>>=
variable evalLambda {{body} {
    upvar #0 ::micca::@Config@::errcount errcount ; # <1>
    upvar #0 ::micca::@Config@::configlineno configlineno
    set lineno $configlineno
    set command {}
    foreach line [split $body \n] { # <2>
        append command $line \n
        incr lineno ; # <3>
        if {[info complete $command]} {
            try {
                eval $command
            } on error {result} {
                puts $::errorInfo
                log::error "line $configlineno: \"$result\""
                incr errcount
            }
            set command {} ; # <4>
            set configlineno $lineno
        }
    }
    return $errcount
}}
----
<1> We need to keep track of all the errors encountered and
what line of the script we are currently dealing with.
<2> We split the body along lines and then reassemble the lines
into a complete command. The +info complete+ command tells us when
we have something that has some chance of being a real command.
<3> We need to keep track of where we are in the +body+.
<4> After evaluating a command we begin to assemble another one and
set our location counter to where that command starts.

== Defining a Domain

As we described above,
the domain configuration commands will take the data in their
arguments and store it away.
After we have finished all the configuration scripts,
then the +generate+ command is used to layout the data structures
and namespace as needed.

When configuring a domain,
we will evaluate the configuration script in the +DomainDef+ child namespace.
That namespace will define commands for all the components of the
domain.
We will use a similar arrangement for other nested aspects of
domain definitions.

=== Domain

*****
+domain+ _name_ _body_

+name+::
    The name of the domain. A domain name must be a non-empty string.
+body+::
    A Tcl script containing invocation of the domain definition commands
    to specify the details of the domain configuration.

The `domain` command defines a domain named, _name_, and evaluates
_body_ in a context where commands in _body_ may be used to define
the characteristics of a domain.
A domain is an open ended and extensible definition.
The `domain` command may be executed with the same named domain and the
addition configuration information is simply added to it.
*****

[float]
==== Implementation

(((micca,Config,domain)))
[source,tcl]
----
<<config commands>>=
proc domain {name body} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name domain
    }

    namespace upvar DomainDef DomainName DomainName ; # <1>
    set DomainName $name

    try {
        if {[isEmptyRef [Domain findById Name $name]]} {# <2>
            Domain create Name $name
        }

        ConfigEvaluate [namespace current]::DomainDef $body

        # At this point we have the definition of the domain and enough
        # information to tie together the class references and
        # the association definitions.
        <<domain: bind relationship references>>

        # We must also compute how polymorphic events are inherited
        # down generalization hierarchies.
        <<domain: propagate polymorphic events>>
    } on error {result} {
        puts $::errorInfo
        # ::micca::@Config@::HandleConfigError $result
    }
}
----
<1> We place the domain name into a variable in the child namespace where the
context implies that all the components defined are to be part of this domain.
<2> We allow the +domain+ command to be invoked more than once.
Domains are open ended definitions so we test to make sure we do not
attempt to create a duplicate domain.

(((error code,BAD_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_NAME      {"%s" is not a valid name for a %s}
----

[[post-config-domain]]
After evaluating the domain configuration script,
it is necessary to perform some additional clean up and evaluation.
For now,
we will say that there are semantic evaluations and checks that can only
be done after the entire domain configuration script has been processed.
The reason for this lies mainly with the way the DSL script commands
were defined to make them more convenient to use when translating an XUML model.

One such action is to bind the association references to the proper
class components.
We discuss this process <<bind-relationship-references,later>>.

Polymorphic events also must be dealt with after the domain configuration
is in place.
Again we will discuss this further below.
// <<domain-propagate-polymorphic-events,below>>.

Although we have said that domain configurations are cumulative,
clearly the need to resolve association bindings and polymorphic event
inheritance means that domain configurations cannot be split arbitrarily.
You will need to be aware that certain divisions of domain configuration
will end up separating information that is needed at the end of the
configuration process.

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-1.0 {
    Define an empty domain
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            # A domain may be empty of components.
        }
    }
    readMiccaAttribute Domain Name Name foo
} -result {foo}
----

== Defining Domain Components

In this section we discuss the commands that are used to define
the components of a domain.
We define child namespaces for those domain component commands
that have a nested structure.

We start with the namespace layout for the +DomainDef+ namespace.

[source,tcl]
----
<<domain config namespace layout>>=
namespace eval DomainDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}
    <<domain config commands>>

    <<class config namespace layout>>
    <<assigner config namespace layout>>
}
----

We see that there are two child namespaces defined with `DomainDef`.
These correspond to commands that have script bodies associated with them.

=== Interface

*****
`interface` _text_

`text`::
    Arbitrary text to be placed in the output interface file.

The `interface` command adds the string of the _text_ argument to
the interface file generated for the domain.
*****

[float]
==== Implementation

(((micca,Config,interface)))
[source,tcl]
----
<<domain config commands>>=
proc interface {text} {
    AppendToDomainAttribute Interface $text
}
----

=== Prologue

*****
`prologue` _text_

`text`::
    Arbitrary text to be placed in the output code file before any generated
    code.

The `prologue` command adds the string of the _text_ argument to
the generated code file for the domain.
The `prologue` command may be invoked multiple times and the value of
all the _text_ arguments is concatenated in the order encountered.
The accumulated prologue text is emitted into the generated code file
before any `micca` generated code.
*****

[float]
==== Implementation

(((micca,Config,prologue)))
[source,tcl]
----
<<domain config commands>>=
proc prologue {text} {
    AppendToDomainAttribute Prologue $text
}
----

=== Epilogue

*****
`epilogue` _text_

`text`::
    Arbitrary text to be placed in the output code file after any generated
    code.

The `epilogue` command adds the string of the _text_ argument to
the generated code file for the domain.
The `epilogue` command may be invoked multiple times and the value of
all the _text_ arguments is concatenated in the order encountered.
The accumulated epilogue text is emitted into the generated code file
after any `micca` generated code.
*****

[float]
==== Implementation

(((micca,Config,epilogue)))
[source,tcl]
----
<<domain config commands>>=
proc epilogue {text} {
    AppendToDomainAttribute Epilogue $text
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-2.0 {
    Define a domain with a non-empty interface
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            prologue "#include <stdio.h>"
        }
    }
    log::debug [formatMiccaClass Domain]
    string trimright [readMiccaAttribute Domain Prologue Name foo]
} -result {#include <stdio.h>}
----

=== Append To Domain Attribute

The operations for the `interface`, `prologue` and `epilogue` commands
can be factored into common code.

[float]
==== Implementation

(((micca,Config,AppendToDomainAttribute)))
[source,tcl]
----
<<helper commands>>=
proc AppendToDomainAttribute {attr text} {
    upvar #0 ::micca::@Config@::DomainDef::DomainName DomainName

    set domref [Domain findById Name $DomainName]
    withAttribute $domref $attr {
        append $attr $text
        if {[string index [set $attr] end] ne "\n"} {
            append $attr \n ; # <1>
        }
    }
    return
}
----
<1> We make sure that the text of these attributes ends in a newline.
This will prevent any problems when the text is emitted into the generated
header file.

=== Class

The class command is used to define classes and specify their characteristics.

*****
+class+ _name_ _script_

+name+::
    The name of the class. A class name must be the form of a ``C''
    identifier.
+script+::
    A Tcl script containing invocations of the class definition commands
    to specify the details of the class configuration.

The `class` command defines a class named, _name_, and evaluates _script_
to configure the class.
Class definitions are open ended and extensible.
If the `class` command is invoked on a previously defined class,
then any additional configuration is added to the definition of the class.
*****

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<domain config commands>>=
proc class {name body} {
    namespace upvar [namespace current] DomainName DomainName ; # <1>

    if {[isEmptyRef [DomainElement findById Domain $DomainName Name $name]]} {# <2>
        DomainElement create Domain $DomainName Name $name
        Class create Domain $DomainName Name $name\
            Number [GenNumber $DomainName Class [list $DomainName]]
        ValueElement create Domain $DomainName Name $name
    }

    namespace upvar ClassDef ClassName ClassName
    set ClassName $name
    ConfigEvaluate [namespace current]::ClassDef $body

    return
}
----
<1> Again we arrange for namespace variables to hold the current
domain and class names to provide the context of the definition.
<2> We allow the `class` command to be invoked multiple times with the
same name.
This makes extending class definitions (_e.g._ adding a state model to
a class) much easier.

=== Association

The +association+ command is used to define both simple and class based
associations depending upon arguments.

*****
`association` _name_ _source_ _spec_ _target_ _?option value ...?_

`name`::
    The name of the association. Conventionally, relationships names are of the
    form *R<d>* where _<d>_ is one or more decimal digits but any
    non-empty string which does not start with a tilde (\~) can be used.
`source`::
    The name of the class that defines the starting class for a forward
    traversal of the relationship.
`spec`::
    The specifier of the relationship conditionality and multiplicity.
    The _spec_ argument is one of the following strings.
    We allow two forms for some of the specifiers.
    The first form follows UML notation and the second form follows
    TclRAL notation which is patterned after regular expression notation.
        `1--1`:::
            The association is _one to one_.
        `0..1--1` or `?--1`:::
            The association is _at most one to one_.
        `0..1--0..1` or `?--?`:::
            The association is _at most one to at most one_.
        `1..*--1` or `+--1`:::
            The association is _one or more to one_.
        `0..*--1` or `*--1`:::
            The association is _zero or more to one_.
        `1..*--0..1` or `+--?`:::
            The association is _one or more to at most one_.
        `0..*--0..1` or `*--?`:::
            The association is _zero or more to at most one_.
        `1..*--1..*` or `+--+`:::
            The association is _one or more to one or more_.
        `0..*--1..*` or `*--+`:::
            The association is _zero or more to one or more_.
        `1..*--0..*` or `+--*`:::
            The association is _one or more to zero or more_.
        `0..*--0..*` or `*--*`:::
            The association is _zero or more to zero or more_.
`target`::
    The name of the class that defines the ending class for a forward
    traversal of the relationship.
`option value ...`::
    Options to the `association` command are given as argument
    option / value pairs:
    Valid options and their values are:
    `-associator` _class_:::
    The `-associator` option defines the association to be
    *class based* and specifies _class_ as the association class.

The `association` command defines an association relationship between a
_source_ class and a _target_class.
The forward direction of navigating the relationship is from _source_
to _target_.
The conditionality and multiplicity of the association is given by the
_spec_ argument.
A class bases association is indicated by the `-associator` option.
*****

In the command,
we are using the _spec_ string to encode several distinct pieces of information.
Each different association specifier implies the conditionality,
multiplicity and other properties of the association.
We encode those properties in data whose identifier is the _spec_ string
itself.

[source,tcl]
----
<<config data>>=
relvar create Config_AssocSpec {
    Spec                string
    NeedsAssociator     boolean
    ReflexiveAllowed    boolean
    ReferringCond       boolean
    ReferringMult       boolean
    ReferencedCond      boolean
    ReferencedMult      boolean
} Spec

relvar insert Config_AssocSpec {
    Spec 1--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec 0..1--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec 0..1--0..1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult false
        ReferencedCond true ReferencedMult false
} {
    Spec 1..*--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec 0..*--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec 1..*--0..1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec 0..*--0..1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec 1..*--1..* NeedsAssociator true ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec 0..*--1..* NeedsAssociator true ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec 1..*--0..* NeedsAssociator true ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec 0..*--0..* NeedsAssociator true ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec ?--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult false
        ReferencedCond false ReferencedMult false
} {
    Spec ?--? NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult false
        ReferencedCond true ReferencedMult false
} {
    Spec +--1 NeedsAssociator false ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec *--1 NeedsAssociator false ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult false
} {
    Spec +--? NeedsAssociator false ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec *--? NeedsAssociator false ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult false
} {
    Spec +--+ NeedsAssociator true ReflexiveAllowed true
        ReferringCond false ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec *--+ NeedsAssociator true ReflexiveAllowed false
        ReferringCond true ReferringMult true
        ReferencedCond false ReferencedMult true
} {
    Spec +--* NeedsAssociator true ReflexiveAllowed false
        ReferringCond false ReferringMult true
        ReferencedCond true ReferencedMult true
} {
    Spec *--* NeedsAssociator true ReflexiveAllowed true
        ReferringCond true ReferringMult true
        ReferencedCond true ReferencedMult true
}
----

[float]
===== Implementation

Like most of the commands in the configuration language,
the bulk of the code is involved with populating the relvars
holding the essential data provided in the command arguments.
For the `association` command,
there is some argument parsing to determine whether the association
is simple or class based.
Then it is a matter of filling in the correct information based on the
type of the association.

(((micca,Config,association)))
[source,tcl]
----
<<domain config commands>>=
proc association {name source spec target args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }
    if {$name eq {}} {
        tailcall DeclError BAD_NAME association
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    # Obtain references to the domain and class context.
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

    if {[llength $args] > 2} {
        tailcall DeclError ASSOC_OPTIONS $args
    } elseif {[llength $args] == 2} {
        lassign $args option associator
        if {$option ne "-associator"} {
            tailcall DeclError UNKNOWN_OPTION association $option
        }
    } else {
        set associator {}
    }

    <<association: check arguments>>

    # Many relvars have tuples with the same heading, so we construct it
    # once here.
    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple

    # Populate the data for a Relationship and Association since that
    # is what this command defines.
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Association create {*}$reltuple

    # Populate the type of association we are dealing with.
    if {$associator eq {}} {
        <<association: populate simple association>>
    } else {
        <<association: populate class based association>>
    }

    return
}
----

(((error code,TILDE_NAME)))
(((error code,ASSOC_OPTIONS)))
[source,tcl]
----
<<error code formats>>=
TILDE_NAME {names beginning with the tilde character are not allowed\
    in this context, "%s"}
ASSOC_OPTIONS {association options error, expected "-associator <class>",\
            got "%s"}
----

Here we use the data that we supplied above to make sure the
`spec` association specifier and the supplied arguments make sense together.
Certain forms of reflexiveness are not allowed and certain specifiers
imply that you must define a class based association.
Such rules are easier to express in data rather than long sequences
of checking code.

[source,tcl]
----
<<association: check arguments>>=
set cas [relvar restrictone ::micca::@Config@::Config_AssocSpec Spec $spec]
if {[relation isempty $cas]} {
    tailcall DeclError BAD_RELATIONSHIP_SPEC $spec
}
set needsassoc [relation extract $cas NeedsAssociator]
if {$needsassoc && $associator eq {}} {
    tailcall DeclError NEED_ASSOCIATOR $spec
}
if {$source eq $target} {
    if {![relation extract $cas ReflexiveAllowed]} {
        tailcall DeclError REFLEXIVE_NOT_ALLOWED $spec
    }
}
----

(((error code,BAD_RELATIONSHIP_SPEC)))
(((error code,NEED_ASSOCIATOR)))
(((error code, REFLEXIVE_NOT_ALLOWED)))
[source,tcl]
----
<<error code formats>>=
BAD_RELATIONSHIP_SPEC  {bad relationship specifier, "%s"}
NEED_ASSOCIATOR {relationship of type, "%s", requires associative class}
REFLEXIVE_NOT_ALLOWED   {associations of type, "%s", cannot be reflexive}
----

For simple associations,
the `association` command arguments supply what we need and we
perform a series of inserts into the configuration language data model.

[source,tcl]
----
<<association: populate simple association>>=
SimpleAssociation create {*}$reltuple

SimpleReferringClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source\
    Conditionality  [relation extract $cas ReferringCond]\
    Multiplicity    [relation extract $cas ReferringMult]
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
ClassRole create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source

SimpleReferencedClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target\
    Conditionality  [relation extract $cas ReferencedCond]
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
ClassRole create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
----

For class based associations we have a few more class instances to create
as we populate that branch of the `micca` model.

[source,tcl]
----
<<association: populate class based association>>=
ClassBasedAssociation create {*}$reltuple

SourceClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source\
    Conditionality  [relation extract $cas ReferringCond]\
    Multiplicity    [relation extract $cas ReferringMult]
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source
ClassRole create\
    Domain          $DomainName\
    Class           $source\
    Relationship    $name\
    Role            source

TargetClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target\
    Conditionality  [relation extract $cas ReferencedCond]\
    Multiplicity    [relation extract $cas ReferencedMult]
AssociationParticipantClass create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target
ClassRole create\
    Domain          $DomainName\
    Class           $target\
    Relationship    $name\
    Role            target

AssociatorClass create\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator
ClassRole create\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator
# We create the class component that will hold the associator class reference
# pointers here. This relationship is unconditional in the micca platform
# model, so we need to create the related instances while we have all the
# information.
AssociatorReference create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
Reference create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
ClassComponent create\
    Domain          $DomainName\
    Class           $associator\
    Name            $name
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test association-1.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class x {
                attribute a1 string
                attribute a2 string
            }
            class y {
                attribute a1 string
            }
            association R10 y 1--1 x
        }
    }
    log::debug [formatMiccaClass SimpleAssociation]
    log::debug [formatMiccaClass SimpleReferringClass]
    log::debug [formatMiccaClass SimpleReferencedClass]
    testConditions\
        {[refMultiplicity [SimpleAssociation findAll]] == 1}\
        {[refMultiplicity [SimpleReferringClass findAll]] == 1}\
        {[refMultiplicity [SimpleReferencedClass findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test association-2.0 {
    Define class based association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class a {
                attribute a1 string
            }
            class e {
                attribute a1 string
                attribute a2 string
            }
            class f {
                attribute a1 string
            }
            association R11 f 1..*--1..* e -associator a
        }
    }
    log::debug [formatMiccaClass AssociatorClass]
    log::debug [formatMiccaClass AssociatorReference]
    log::debug [formatMiccaClass SourceClass]
    log::debug [formatMiccaClass TargetClass]
    testConditions\
        {[refMultiplicity [AssociatorClass findAll]] == 1}\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [SourceClass findAll]] == 1}\
        {[refMultiplicity [TargetClass findAll]] == 1}
} -result {1}
----

=== Generalization

Defining a generalization relationship is quite a bit simpler than
the effort we just saw in defining associations.
For generalizations,
it is necessary to specify the superclass and the set of subclasses.
Also for generalizations,
the type of subclass storage is specified.

*****
`generalization` _name_ _?-union | -reference?_ _super_ _sub1_ _sub2_ _?...?_

`name`::
    The name of the generalization. Conventionally, relationships names are of
    the form *R<d>* where _<d>_ is one or more decimal digits but any non-empty
    string can be used.
`-union | -reference`::
    An option to specify if subclasses of the generalization are to be
    held as a discriminated union in the same structure as the superclass
    or held in separate storage having the relationship navigation implemented
    using reference pointers.
    If no option is given, the `-reference` is assumed.
    This option may also be specified as, `--` to indicate the end of options
    and that the next argument is to be taken as the superclass name.
`super`::
    The name of the class that serves as the superclass of the generalization.
`subN`::
    The names of the classes that serve as the subclasses of the generalization.
    You must specify at least two subclasses to define a generalization.
*****

[float]
==== Implementation

(((micca,Config,generalization)))
[source,tcl]
----
<<domain config commands>>=
proc generalization {name args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME generalization
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    set type reference
    while {1} {
        set args [lassign $args arg]

        if {$arg eq "-reference"} {
            set type reference
        } elseif {$arg eq "-union"} {
            set type union
        } elseif {$arg eq "--"} {
            set args [lassign $args super]
            break
        } else {
            set super $arg
            break
        }
    }

    if {[llength $args] < 2} {
        tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
    }
    if {$super in $args} {
        tailcall DeclError SUPER_AS_SUBCLASS $super [join $args {, }]
    }
    if {[llength [lsort -unique $args]] != [llength $args]} {
        tailcall DeclError DUPLICATE_SUBCLASS $args
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]

    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Generalization create {*}$reltuple

    set supertuple [list\
        Domain          $DomainName\
        Class           $super\
        Relationship    $name\
        Role            target\
    ]
    set subtuple [dict create\
        Domain          $DomainName\
        Relationship    $name\
        Role            source\
    ]
    if {$type eq "reference"} {
        ReferenceGeneralization create {*}$reltuple
        ReferencedSuperclass create {*}$supertuple
        foreach sub $args {
            dict set subtuple Class $sub
            ReferringSubclass create {*}$subtuple
        }
    } elseif {$type eq "union"} {
        UnionGeneralization create {*}$reltuple
        UnionSuperclass create {*}$supertuple
        SubclassContainer create Domain $DomainName Class $super Name $name ; # <1>
        ClassComponent create Domain $DomainName Class $super Name $name
        foreach sub $args {
            dict set subtuple Class $sub
            UnionSubclass create {*}$subtuple
        }
    }
    Superclass create {*}$supertuple
    ClassRole create {*}$supertuple

    foreach sub $args {
        dict set subtuple Class $sub
        Subclass create {*}$subtuple
        ClassRole create {*}$subtuple
    }

    return
}
----
<1> For union based subclass storage,
we create the container as a class component in the superclass.
This is done here since we have the information and the relationship is
unconditional. Union superclasses always have a subclass container.

(((error code,TOO_FEW_SUBCLASSES)))
(((error code,SUPER_AS_SUBCLASS)))
(((error code,DUPLICATE_SUBCLASS)))
[source,tcl]
----
<<error code formats>>=
TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
SUPER_AS_SUBCLASS   {super class, "%s", cannot be included in subclasses, "%s"}
DUPLICATE_SUBCLASS  {subclass set contains a duplicate subclass name, "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-1.0 {
    Define reference generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int
            }
            generalization R1 -reference super sub1 sub2
        }
    }
    log::debug [formatMiccaClass ReferenceGeneralization]
    log::debug [formatMiccaClass ReferencedSuperclass]
    log::debug [formatMiccaClass ReferringSubclass]
    testConditions\
        {[refMultiplicity [ReferenceGeneralization findAll]] == 1}\
        {[refMultiplicity [ReferencedSuperclass findAll]] == 1}\
        {[refMultiplicity [ReferringSubclass findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test generalization-2.0 {
    Define union generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class usuper {
                attribute sid int
            }
            class usub1 {
                attribute sid int
            }
            class usub2 {
                attribute sid int
            }
            generalization R2 -union usuper usub1 usub2
        }
    }
    log::debug [formatMiccaClass UnionGeneralization]
    log::debug [formatMiccaClass UnionSuperclass]
    log::debug [formatMiccaClass UnionSubclass]
    log::debug [formatMiccaClass SubclassContainer]
    testConditions\
        {[refMultiplicity [UnionGeneralization findAll]] == 1}\
        {[refMultiplicity [UnionSuperclass findAll]] == 1}\
        {[refMultiplicity [UnionSubclass findAll]] == 2}\
        {[refMultiplicity [SubclassContainer findAll]] == 1}
} -result {1}
----

=== Type Alias

*****
`typealias` _definition_ _name_

`definition`::
    A ``C'' typename.
`name`::
    The name of the type alias.

The `typealias` command defines an alias _name_ for a ``C'' typename given
by, _definition_.
Type alias helps map model level type information to ``C'' `typedef` statements
that are included in the generated code.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc typealias {typedef aliasname} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    TypeAlias create Domain $DomainName TypeName $aliasname\
        TypeDefinition $typedef

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typealias-1.0 {
    Define a type alias
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            typealias uint8_t rawbyte
        }
    }
    log::debug [formatMiccaClass TypeAlias]
    readMiccaAttribute TypeAlias TypeDefinition Domain foo TypeName rawbyte
} -result {uint8_t}
----

=== Domain Operation

*****
`domainop` _rettype_ _name_ _parameters_ _body_

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the domain operation.
`name`::
    The name of the domain operation.
`parameters`::
    A Tcl dictionary of parameter names and types.
    The keys to the dictionary are domain operation parameter names
    and the values are the corresponding ``C'' type names for the parameters.
`body`::
    A string containing the code that is executed when the domain operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc domainop {rettype name parameters body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

    DomainOperation create Domain $DomainName Name $name Body $body\
        ReturnDataType $rettype
    set paramtuple [dict create Domain $DomainName Operation $name]
    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName DomainOperationParameter\
                [list $DomainName $name]]
        DomainOperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domainop-1.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }
        }
    }
    log::debug [formatMiccaClass DomainOperation]
    log::debug [formatMiccaClass DomainOperationParameter]
    testConditions\
        {[refMultiplicity [DomainOperation findAll]] == 1}\
        {[refMultiplicity [DomainOperationParameter findAll]] == 2}\
} -result {1}
----

== Defining Class Components

Since there are several aspects of classes,
the +class+ command takes a _script_ argument which should
invoke the commands we discuss in this section.
Following our pattern,
we define a namespace where the class body script is evaluated.

[source,tcl]
----
<<class config namespace layout>>=
namespace eval ClassDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class config commands>>

    <<state model config namespace layout>>
}
----

=== Attribute

Within a class definition,
the `attribute` command specifies the attributes of the class.

*****
`attribute` _name_ _type_ ? `-default` _value_ ?

`name`::
    The name of the attribute. Attributes names may not be the empty string.
`type`::
    The type of the attribute. The _type_ may be any valid ``C'' type name.
`-default` _value_::
    If specified, the `-default` option specifies a default value for the
    attribute. If no value is supplied when a class instance is created
    or populated, then the default value is used.
*****

The implementation of the `attribute` command simply creates tuples
in the relvars to hold the attribute characteristics.

[float]
==== Implementation

(((micca,Config,attribute)))
[source,tcl]
----
<<class config commands>>=
proc attribute {name type args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME attribute
    }
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    ClassComponent create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name
    Attribute create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name\
        DataType    $type

    if {[llength $args] > 2} {
        tailcall DeclError ATTRIBUTE_OPTIONS $args
    } elseif {[llength $args] == 2} {
        lassign $args option defvalue
        if {$option ne "-default"} {
            tailcall DeclError UNKNOWN_OPTION attribute $option
        } else {
            DefaultValue create\
                Domain      $DomainName\
                Class       $ClassName\
                Attribute   $name\
                Value       $defvalue
        }
    }
}
----

(((error code,ATTRIBUTE_OPTIONS)))
[source,tcl]
----
<<error code formats>>=
ATTRIBUTE_OPTIONS {attribute options error, expected "-default <value>",\
            got "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test attribute-1.0 {
    Define class with attributes
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20
            }
            class c2 {
                attribute b1 uint8
                attribute b2 float
            }
        }
    }
    log::debug [formatMiccaClass Attribute]
    log::debug [formatMiccaClass DefaultValue]
    testConditions\
        {[refMultiplicity [Attribute findAll]] == 4}\
        {[refMultiplicity [DefaultValue findAll]] == 1}
} -result {1}
----

=== Reference

The `reference` command defines the paths along a association by
which related class instances may be found by navigating the
relationship.
Any processing associated with a class that intends to navigate
a particular relationship must include a `reference` command
for that relationship which specifies the characteristics of how
reference pointers are stored to enable the navigation.

*****
`reference` _relationship_ ?_option value_ ...?

`relationship`::
    The name of an association or generalization in which the class
    participates.

`option value`::
    Option / value pairs define the characteristics of the storage for
    the reference.
    Valid options are:
    `-type linked | vector | constant`:::
        The `-type` option specifies the type of storage to be used for
        the reference pointers.
        This option only applies when the multiplicity of the relationship
        is greater than one in the direction of traversal implied by the
        reference.
        Singular references are all stored the same, namely as a single
        pointer.
        The choices for the `-type` option allow for different space / speed
        trade offs depending upon the dynamic nature of the instances
        of the relationship.
        The value of the `-type` option may be one of:
        `linked`::::
            Referenced instances are stored on a linked list.
        `vector`::::
            Referenced instances are stored in a vector.
        `constant`::::
            Referenced instances are stored in an array placed in read-only
            memory.
    `-capacity` _size_::
        When `-type` is specified as `vector`, the `-capacity` option
        defines the maxiumum number of reference pointers to be held in
        the relationship storage. The _size_ must be specified as a
        positive integer.
    `-path forward | backward`::
        When an association is reflexive, _i.e._ the source and target
        classes are the same class,
        the `-path` option must be given to indicated if the navigation
        is `forward` from source to target or `backward` from target to source.
        Multiple `-path` options may be given if both forward and backward
        traversal of the association is needed.

The `reference` command defines the intent to navigate from the class
along _relationship_ and defines the characteristics of storage needed
to support that navigation.
*****

[float]
==== Implementation

The definitions of relationship, both associations and generalizations,
and the definitions of how relationship information is to be stored
to support navigating the relationship are intertwined.
We have made the decision to allow the DSL to specify relationships
and references in an arbitrary order.
That decision has two consequences:

. Information must be temporarily stored away outside of the platform model
to support completing the population of the model at a time
when all the required data is available.
For example,
it is possible to specify a reference to a relationship before the
relationship is defined.
It is not possible, in this case, to directly populate the platform
model as there is not enough information about the relationship.
. At an appropriate time in the domain definition,
we must process the temporary information to link up the relationship
definitions to the storage requirements for the reference pointers.
We discuss this processing <<bind-relationship-references,later>>.

Here we consider the information that must be accumulated about the
references. The following relvar captures the information contained in
a `reference` command invocation.

[source,tcl]
----
<<config data>>=
relvar create Class_Reference {
    Domain              string
    Class               string
    Relationship        string
    Role                string
    ReferenceType       string
    Capacity            int
} {Domain Class Relationship Role}
----

As we see below,
the implementation for the `reference` command simply adds tuples to
the above relvar after validating the arguments to the command.

(((micca,Config,reference)))
[source,tcl]
----
<<class config commands>>=
proc reference {relname args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set reftype {}
    set role {}
    set capacity 0

    foreach {option value} $args {
        switch -exact -- $option {
            -type {
                if {$value ni {linked vector constant}} {
                    tailcall DeclError BAD_REF_TYPE $value
                }
                set reftype $value
            }
            -capacity {
                set capacity $value
            }
            -path {
                if {$value ni {forward backward}} {
                    tailcall DeclError BAD_PATH $value
                }
                set role [expr {$value eq "forward" ? "source" : "target"}]
            }
            default {
                tailcall DeclError UNKNOWN_OPTION reference $option
            }
        }
    }

    if {$reftype eq "vector" && $capacity <= 0} {
        tailcall DeclError BAD_CAPACITY
    }

    relvar insert ::micca::@Config@::Class_Reference [list\
        Domain              $DomainName\
        Class               $ClassName\
        Relationship        $relname\
        Role                $role\
        ReferenceType       $reftype\
        Capacity            $capacity\
    ]
}
----

(((error code,BAD_REF_TYPE)))
(((error code,BAD_PATH)))
[source,tcl]
----
<<error code formats>>=
BAD_REF_TYPE    {unknown reference type value, "%s": should be linked,\
                array or constant}
BAD_PATH        {unknown path value, "%s": should be forward or backward}
BAD_CAPCITY     {vector references require a non-zero "-capacity" option}
----


[float]
==== Binding Relationship References
[[bind-relationship-references]]
We now have all the information needed to link up the relationship
definitions with the references made by the participating classes.
The code below is run at the end of the processing in a `domain` command.
The intent is to turn the intend of the relationship and any navigation
references into Class Components that are used to store class pointers
that implement the relationship navigation.

Algorithmically, we simply iterate over each instance of `Class_Reference`
that was created by the invocations of the `reference` command.

[source,tcl]
----
<<domain: bind relationship references>>=
set errcount 0
relation foreach ref [relvar set Class_Reference] {
    <<domain: link one reference>>
}

if {$errcount > 0} {# <1>
    tailcall DeclError REFERENCE_ERRORS $errcount
}
----
<1> We accumulate errors in the iteration loop and then report at the end.
Detected error result in a logged error message.

(((error code,REFERENCE_ERRORS)))
[source,tcl]
----
<<error code formats>>=
REFERENCE_ERRORS    {%d reference errors found}
----

The first item of business is to deal with reflexive associations.
If an association is reflexive,
then there will be two instances of *Class Role*,
one for its role as the source of navigation and the other as the target.
If the `reference` command was invoked with a `-path` option,
then the *Role* attribute will have the value of either `source` or
`target` and we can use that to select a particular instance of *Class Role*.
Otherwise, we select *Class Role* instances based on the information
we have, without resorting to its role.
In either case we need to find the set of *Class Role* instances
associated with the relationship.
That is accomplished as shown below

[source,tcl]
----
<<domain: link one reference>>=
relation assign $ref {Domain refDomain} {Class refClass}\
    {Relationship refRelationship} {Role refRole} ReferenceType Capacity
if {$refRole ne {}} {
    set crref [ClassRole findById Domain $refDomain Class $refClass\
        Relationship $refRelationship Role $refRole]
} else {
    set crref [ClassRole findWhere {$Domain eq $refDomain &&\
        $Class eq $refClass && $Relationship eq $refRelationship}]
}
----

The first case we come upon is whether the relationship specified in
the `reference` command was correct.
It's possible that the class being configured by the `reference` command
does not even participate in the relationship.

[source,tcl]
----
<<domain: link one reference>>=
if {[isNotEmptyRef $crref]} {
    <<domain: resolve class role>>
} else {
    log::error "class, \"$Class\", does not participate in relationship,\
            \"$Relationship\""
    incr errcount
}
----

Next we must determine if the relationship was reflexive but no
path information was given.
This is the circumstance where we find multiple class roles with
no way to distinguish them.

[source,tcl]
----
<<domain: resolve class role>>=
if {[isRefSingular $crref]} {
    <<domain: resolve single class role>>
} else {
    log::error "relationship, \"$Relationship\", is reflexive for\
        class, \"$Class\", and no \"-path\" option was specified"
    incr errcount
}
----

Now we can deal with the various cases that arise from *R40* in
the platform model.
There are three cases where a reference is appropriate,
an association, a reference superclass and a reference subclass.
Reference statements for union generalizations are not necessary
since navigating a generalization stored as a union can be accomplished
by pointer arithmetic.
The code below is structured into procedures that examine each type
of relationship.
The procedures return true if they successfully resolved the reference.

[source,tcl]
----
<<domain: resolve single class role>>=
if {[ResolveParticipantReference $crref $ReferenceType $Capacity]} {
    continue
}
if {[ResolveSuper $crref]} {
    continue
}
if {[ResolveSub $crref]} {
    continue
}
log::warn "in class, \"$refClass\", reference for relationship,\
    \"$refRelationship\", is ignored: may be part of a union generalization"
----

==== Resolving Association References

Association references are the most complicated because they come in the
widest variety of types and storage choices.
We structure the code in the same way as above,
using a separate procedure for each possible case of navigating *R38*
in the platform model.

[source,tcl]
----
<<helper commands>>=
proc ResolveParticipantReference {crref reftype capacity} {
    set apcref [findRelated $crref {~R40 AssociationParticipantClass}] ; # <1>
    if {[isEmptyRef $apcref]} {
        return false
    }

    # Now try each of the four cases stemming from R38
    if {[ResolveSimpleReferring $apcref $reftype]} {
        return true
    }
    if {[ResolveSimpleReferenced $apcref $reftype $capacity]} {
        return true
    }
    if {[ResolveSource $apcref $reftype $capacity]} {
        return true
    }
    if {[ResolveTarget $apcref $reftype $capacity]} {
        return true
    }
    return false
}
----
<1> First we must check if the Class Role instance is related to an
Association Participant Class.

A Simple Referring Class role always has a singular reference to its
related instance.

[source,tcl]
----
<<helper commands>>=
proc ResolveSimpleReferring {apcref reftype} {
    set srcref [findRelated $apcref {~R38 SimpleReferringClass}]
    if {[isEmptyRef $srcref]} {
        return false
    }

    assignAttribute $srcref
    if {$reftype ne {}} {# <1>
        log::warn "reference type, \"$reftype\", is ignored for the\
            singular reference from \"$Class\" along \"$Relationship\""
    }
    SingularReference create Domain $Domain Class $Class Name $Relationship\
            Role $Role
    CreateDirectionalReference $Domain $Class $Relationship $Role
    return true
}
----
<1> In case a reference type was specified in the `reference` command
for this direction of the association, we warn that it is being ignored.

In the case of a reflexive association,
there will be multiple instances of Direction Reference related to the
same instance of Association Reference.
Hence it is necessary to test if we need to create the Association Reference
instance as we may have been through this code path before when dealing
with the other direction of the reflexive association.

[source,tcl]
----
<<helper commands>>=
proc CreateDirectionalReference {domain class relationship role} {
    set drref [DirectionalReference create Domain $domain Class $class\
            Name $relationship Role $role]
    if {[isEmptyRef [findRelated $drref R25]]} {
        AssociationReference create Domain $domain Class $class\
            Name $relationship
        Reference create Domain $domain Class $class Name $relationship
        ClassComponent create Domain $domain Class $class Name $relationship
    }
    return
}
----

For a Simple Referenced Class,
it is possible to refer to multiple instances.
This is where the choice of pointer storage comes into play.

[source,tcl]
----
<<helper commands>>=
proc ResolveSimpleReferenced {apcref reftype capacity} {
    set srcref [findRelated $apcref {~R38 SimpleReferencedClass}]
    if {[isEmptyRef $srcref]} {
        return false
    }
    # Find multiplicity in Simple Referring Class
    set targetref [findRelated $srcref R33 ~R32]
    assignAttribute $targetref Multiplicity {Class target}

    CreateAssociationReferences $srcref $Multiplicity $target $reftype $capacity

    return true
}
----

We can factor all the heavy lifting for creating all the different
types platform model instances into a single procedure.
In the end,
we are creating pointer storage components to point from a source class
to a target class.

[source,tcl]
----
<<helper commands>>=
proc CreateAssociationReferences {srcref multiplicity target reftype capacity} {
    assignAttribute $srcref Domain Class Relationship Role

    if {$multiplicity} {
        if {$reftype eq {}} {
            log::info "multiple reference by \"$Class\" along\
                \"$Relationship\" defaults to \"linked\" type"
        }
        switch -exact -- $reftype {
            vector {
                VectorReference create Domain $Domain Class $Class\
                    Name $Relationship Role $Role Capacity $capacity
            }
            constant {
                ConstantReference create Domain $Domain Class $Class\
                    Name $Relationship Role $Role
            }
            linked -
            default {
                LinkedReference create Domain $Domain Class $Class\
                    Name $Relationship Role $Role ; # <1>
                LinkContainer create Domain $Domain Class $target\
                    Name ${Relationship}_${Role}_links
                ClassComponent create Domain $Domain Class $target\
                    Name ${Relationship}_${Role}_links
            }
        }
    } else {
        if {$reftype ne {}} {
            log::warn "reference type, \"$reftype\", is ignored for the\
                singular reference by \"$Class\" along \"$Relationship\""
        }
        SingularReference create Domain $Domain Class $Class\
            Name $Relationship Role $Role
    }

    CreateDirectionalReference $Domain $Class $Relationship $Role
}
----
<1> Creating a Linked Reference involves additional work.
We must create the Class Component in the target class to hold the links.
Linked list storage for association uses a doubly linked list to make
insertion and deletion fast.
We choose to allocate the memory for the links in the classes that
reside in the lists.
This makes the memory allocation easier and means that a given instance
may be threaded onto as many lists as necessary for its relationships.

For classes that serve a Source Class role,
we encounter how to deal with class based associations.
It may be helpful to recall the way class based associations are
<<class-base-association-conventions,decomposed>>.
This effectively causes us to use the multiplicity from the Target Class
side of the association to control the storage on the Source Class side
and _vice versa_.
We also have to find the Associator Class since that is the class
to which the references will point.

[source,tcl]
----
<<helper commands>>=
proc ResolveSource {apcref reftype capacity} {
    set scref [findRelated $apcref {~R38 SourceClass}]
    if {[isEmptyRef $scref]} {
        return false
    }
    set cbaref [findRelated $scref R34]
    set multiplicity [readAttribute [findRelated $cbaref ~R35] Multiplicity]
    set assocclass [readAttribute [findRelated $cbaref ~R42] Class]

    CreateAssociationReferences $scref $multiplicity $assocclass $reftype $capacity

    return true
}
----

The same reasoning applies to Target Classes.
We find the multiplicity from the Source Class attributes and we need
to know the Associator Class since that is where the references point.

[source,tcl]
----
<<helper commands>>=
proc ResolveTarget {apcref reftype capacity} {
    set tcref [findRelated $apcref {~R38 TargetClass}]
    if {[isEmptyRef $tcref]} {
        return false
    }
    set cbaref [findRelated $tcref R35]
    set multiplicity [readAttribute [findRelated $cbaref ~R34] Multiplicity]
    set assocclass [readAttribute [findRelated $cbaref ~R42] Class]

    CreateAssociationReferences $tcref $multiplicity $assocclass $reftype $capacity

    return true
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test reference-1.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1
            }
            class c2 {
                attribute b1 uint8
                attribute b2 float

                reference R1
            }

            association R1 c1 1..*--1 c2
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass LinkedReference]
    log::debug [formatMiccaClass LinkContainer]
    log::debug [formatMiccaClass SingularReference]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 2}\
        {[refMultiplicity [LinkedReference findAll]] == 1}\
        {[refMultiplicity [LinkContainer findAll]] == 1}\
        {[refMultiplicity [SingularReference findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-2.0 {
    Define class with singular reflexive association reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 -path forward
                reference R1 -path backward
            }

            association R1 c1 0..1--0..1 c1
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass SingularReference]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 1}\
        {[refMultiplicity [SingularReference findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-2.1 {
    Define class with many to many reflexive association reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 -path forward
                reference R1 -path backward
            }
            class a {}

            association R1 c1 0..*--0..* c1 -associator a
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass AssociatorReference]
    log::debug [formatMiccaClass LinkedReference]
    log::debug [formatMiccaClass LinkContainer]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 1}\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [LinkedReference findAll]] == 2}\
        {[refMultiplicity [LinkContainer findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-2.2 {
    Define class with multiple reflexive association reference using vector
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 -path forward
                reference R1 -path backward -type vector -capacity 20
            }

            association R1 c1 1..*--1 c1
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass SingularReference]
    log::debug [formatMiccaClass VectorReference]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 1}\
        {[refMultiplicity [SingularReference findAll]] == 1}\
        {[refMultiplicity [VectorReference findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-2.3 {
    Define class with multiple reflexive association reference using linked
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 -path forward
                reference R1 -path backward -type linked
            }

            association R1 c1 1..*--1 c1
        }
    }
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass SingularReference]
    log::debug [formatMiccaClass LinkedReference]
    log::debug [formatMiccaClass LinkContainer]
    testConditions\
        {[refMultiplicity [AssociationReference findAll]] == 1}\
        {[refMultiplicity [SingularReference findAll]] == 1}\
        {[refMultiplicity [LinkedReference findAll]] == 1}\
        {[refMultiplicity [LinkContainer findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-3.0 {
    Define class many to many association using links
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1
            }
            class c2 {
                attribute a1 int
                attribute b1 float

                reference R1
            }
            class a {
            }

            association R1 c1 0..*--1..* c2 -associator a
        }
    }
    log::debug [formatMiccaClass AssociatorReference]
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass LinkedReference]
    log::debug [formatMiccaClass LinkContainer]
    testConditions\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [AssociationReference findAll]] == 2}\
        {[refMultiplicity [LinkedReference findAll]] == 2}\
        {[refMultiplicity [LinkContainer findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test reference-3.1 {
    Define class many to many association using vectors
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20

                reference R1 -type vector -capacity 10
            }
            class c2 {
                attribute a1 int
                attribute b1 float

                reference R1 -type vector -capacity 10
            }
            class a {
            }

            association R1 c1 0..*--1..* c2 -associator a
        }
    }
    log::debug [formatMiccaClass AssociatorReference]
    log::debug [formatMiccaClass AssociationReference]
    log::debug [formatMiccaClass VectorReference]
    testConditions\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [AssociationReference findAll]] == 2}\
        {[refMultiplicity [VectorReference findAll]] == 2}
} -result {1}
----

==== Resolving Generalization References

Generalization references are much easier to resolve that those for
associations.
Because a generalization relationship is one-to-one we need only hold
single pointers for the references.
The only minor complication is that references from a superclass to a subclass
need to also store an indication of which subclass the superclass is
currently related.
This saves searching the various subclass storage arrays for the related
instance.
That minor twist is handled by have superclass with a Subclass Reference
type of Class Component.
The Subclass Reference component will be turned into two structure members
at code generation time.

For a Referenced Superclass,
we need only create a Subclass Reference instance.

[source,tcl]
----
<<helper commands>>=
proc ResolveSuper {crref} {
    set rscref [findRelated $crref {~R40 Superclass} {~R46 ReferencedSuperclass}]
    if {[isEmptyRef $rscref]} {
        return false
    }

    assignAttribute $rscref
    SubclassReference create Domain $Domain Class $Class Name $Relationship\
            Role $Role
    Reference create Domain $Domain Class $Class Name $Relationship
    ClassComponent create Domain $Domain Class $Class Name $Relationship

    return true
}
----

And similarly for a Referring Subclass,
it needs a Superclass Reference instance to hold the pointer to the superclass
instance.

[source,tcl]
----
<<helper commands>>=
proc ResolveSub {crref} {
    set rscref [findRelated $crref {~R40 Subclass} {~R47 ReferringSubclass}]
    if {[isEmptyRef $rscref]} {
        return false
    }

    assignAttribute $rscref
    SuperclassReference create Domain $Domain Class $Class Name $Relationship\
            Role $Role
    Reference create Domain $Domain Class $Class Name $Relationship
    ClassComponent create Domain $Domain Class $Class Name $Relationship

    return true
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test reference-4.0 {
    Define class with reference generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super {
                attribute a1 char

                reference R1
            }
            class sub1 {
                attribute a1 char

                reference R1
            }
            class sub2 {
                attribute a1 int

                reference R1
            }

            generalization R1 super sub1 sub2
        }
    }
    log::debug [formatMiccaClass SuperclassReference]
    log::debug [formatMiccaClass SubclassReference]
    testConditions\
        {[refMultiplicity [SuperclassReference findAll]] == 2}\
        {[refMultiplicity [SubclassReference findAll]] == 1}
} -result {1}
----

=== Constructor

*****
+constructor+ _body_
*****

[float]
==== Implementation

(((micca,Config,constructor)))
[source,tcl]
----
<<class config commands>>=
proc constructor {body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName
    Constructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

=== Destructor

*****
+destructor+ _body_
*****

[float]
==== Implementation

(((micca,Config,destructor)))
[source,tcl]
----
<<class config commands>>=
proc destructor {body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName
    Destructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

=== Class Operation

*****
+classop+ _rettype_ _name_ _parameters_ _body_
*****

[float]
==== Implementation

(((micca,Config,classop)))
[source,tcl]
----
<<class config commands>>=
proc classop {rettype name parameters body} {
    DefineOperation false $rettype $name $parameters $body
}
----

=== Instance Operation

*****
+instop+ _rettype_ _name_ _parameters_ _body_
*****
[float]
==== Implementation

(((micca,Config,instop)))
[source,tcl]
----
<<class config commands>>=
proc instop {rettype name parameters body} {
    DefineOperation true $rettype $name $parameters $body
}
----

=== Define Operation

[float]
==== Implementation

(((micca,Config,DefineOperation)))
[source,tcl]
----
<<class config commands>>=
proc DefineOperation {isinst rettype name parameters body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    Operation create Domain $DomainName Class $ClassName Name $name Body $body\
        ReturnDataType $rettype IsInstance $isinst
    set paramtuple [dict create Domain $DomainName Class $ClassName\
            Operation $name]

    if {$isinst} {
        dict set paramtuple Name self
        dict set paramtuple DataType "struct $ClassName *"
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test classop-1.0 {
    Define a class operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c4 {
                attribute a1 int

                classop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation ReturnDataType Domain foo Class c4 Name color
} -result {float}
----

[source,tcl]
----
<<config command tests>>=
test instop-1.0 {
    Define an instance operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c5 {
                attribute a1 int

                instop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation IsInstance Domain foo Class c5 Name color
} -result {true}
----

== Defining Class State Models

State models in XUML are used to specify the sequence of computations
associated with the life cycle of class instances.
All instances of a class have the same behavior,
yet each instance has it own notion of current state and so may progress
through its life cycle independently of any other instance.

Traditionally,
http://en.wikipedia.org/wiki/Moore_machine[Moore]
type state models are used in XUML to define the life cycle behavior.
The other alternative is a
http://en.wikipedia.org/wiki/Mealy_machine[Mealy]
type state model.
They are mathematically equivalent in the sense that any problem that
can be solved by one formulation can also be solved by the other.
Individuals have their preferences over which formulation is better
and we will not indulge in that discussion here.
We only point out that hierarchical state models are _not_
supported in the this translation scheme.
Hierarchical state models are an unnecessary abomination.

As usual, we need a namespace in which to hold the state model definition
commands.

[source,tcl]
----
<<state model config namespace layout>>=
namespace eval StateModelDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<state model config commands>>
}
----

=== Statemodel

*****
+statemodel+ _body_

+body+::
    A Tcl Script that is evaluated in a context to allow the definition
    of the properties of the class state model.
*****

///////
----
<<manual class configuration commands>>=
[call [cmd statemodel] [arg body]]

The [cmd statemodel] command specifies that the enclosing class is to
also have a state model.
The [arg body] argument is a Tcl script that should invoke
the State Model Configuration commands given
[sectref "State Model Configuration Commands" below]
to define the characteristics of the class state model.
[para]
[example {
class Vessel {
    # ... attribute definitions
    statemodel {
        # State model defined here
    }
}
}]
----
///////

[float]
==== Implementation

The implementation of the `statemodel` command follows the usual pattern.
We evaluate +body+ in the proper context and then
insert the argument data into the proper relvars that are used to
collect the state model specifications.

(((micca,Config,statemodel)))
[source,tcl]
----
<<class config commands>>=
proc statemodel {body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    variable ClassName

    namespace upvar StateModelDef\
        InitialState InitialState\
        DefaultTrans DefaultTrans\
        Terminals Terminals

    set InitialState {}
    set DefaultTrans {}
    set Terminals [list]

    try {
        ConfigEvaluate [namespace current]::StateModelDef $body

        if {$DefaultTrans eq {}} {
            set DefaultTrans CH
        }
        StateModel create\
            Domain          $DomainName\
            Model           $ClassName\
            InitialState    $InitialState\
            DefaultTrans    $DefaultTrans
        InstanceStateModel create\
            Domain          $DomainName\
            Class           $ClassName

        foreach terminal $Terminals {
            set sref [State findWhere Domain $DomainName Model $ClassName\
                    Name $terminal]
            updateAttribute $sref IsFinal true
        }
    } on error {result opts} {
        log::error $result
        upvar #0 ::micca::@Config@::errcount errcount
        incr errcount
    }
}
----

=== State

*****
+state+ _name_ _parameters_ _body_

+name+::
    The name of the state. Name must not be the empty string or one of
    the reserved names of *@*, *CH* or *IG*.
+parameters+::
    A list of the formal parameters of the state.
    Parameters are specified in the same manner as for the `::proc` command.
+body+::
    A Tcl script that is to be executed when the class instance enters
    this state.
*****

///////
----
<<manual statemodel configuration commands>>=
[call [cmd state] [arg name] [arg parameters] [arg body]]

The [cmd state] command defines a state named, [arg name], in the enclosing
state model.
The [arg name] argument may not be [emph @], [emph IG] or [emph CH]
nor is it allowed to be the empty string.
The [arg parameters] argument gives the parameters to the state the
are carried with the event that causes a transition into [arg state].
The [arg parameters] are specified in the same manner as for the [cmd ::proc]
command.
The [arg body] argument is a Tcl script that is executed when the
instance to which the state machine is associated enters [arg state].
Every state has an implicit [var self] parameter that is automatically
defined for the state and when [arg body] is invoked will have the value
of an instance reference to the instance receiving the event.
[para]
[example {
state Idle {speed} {
    # Idle state activity code here
}
}]
----
///////

[float]
==== Implementation

(((micca,Config,state)))
[source,tcl]
----
<<state model config commands>>=
proc state {name params body} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME state
    }
    if {$name eq "@" || [isNotEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    variable InitialState

    if {$InitialState eq {}} {
        set InitialState $name
    }

    set sigid [FindActivitySignature $name $params]
    set stateref [State create\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Activity        $body\
        IsTerminal      false\
        SigID           $sigid\
    ]
    StatePlace create\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Number          [GenNumber $DomainName StatePlace\
                            [list $DomainName $ClassName]]

    if {$sigid ne {}} {
        StateTransition update [pipe {
            findRelatedWhere $stateref ~R72 {$SigID eq {}} |
            deRef ~ SigID |
            relation update ~ sttuple {1} {
                tuple update $sttuple SigID $sigid
            }
        }]
    }

    return
}
----

(((error code,BAD_STATE_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_STATE_NAME    {"%s" is a valid state name}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test state-1.0 {
    Define a state with parameters
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 int

                statemodel {
                    transition s1 - e1 -> s2
                    event e1 e int f float

                    state s1 {a int b float} {
                        printf("in state s1\n") ;
                    }
                    state s2 {c int d float} {
                        printf("in state s2\n") ;
                    }

                    state s3 {i char j double} {
                    }
                    event e2 e char f double

                    transition s2 - e2 -> s3
                    transition s3 - e1 -> s1
                }
            }
        }
    }
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass ActivityParameter]
    log::debug [formatMiccaClass ArgumentSignature]
    log::debug [formatMiccaClass ActivityArgument]
    log::debug [formatMiccaClass EventParameter]
    log::debug [formatMiccaClass StateTransition]
} -result {}
----

[source,tcl]
----
<<state model config commands>>=
proc FindActivitySignature {state params} {
    if {[dict size $params] == 0} {
        return
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set sigid [FindArgumentSignature $params]
    set pos -1
    dict for {pname ptype} $params {
        ActivityParameter create\
            Domain      $DomainName\
            Model       $ClassName\
            State       $state\
            SigID       $sigid\
            Position    [incr pos]\
            Name        $pname
    }

    return $sigid
}
----

[source,tcl]
----
<<state model config commands>>=
proc FindArgumentSignature {params} {
    if {[llength $params] == 0} {
        return
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set pos -1
    set parampos [dict create]
    dict for {pname ptype} $params {
        dict set parampos [incr pos] $ptype
    }
    set argpos [relation fromdict $parampos Position int DataType string]
    set sigref [pipe {
        ActivityArgument findAll | deRef ~ |
        relation group ~ ArgPositions Position DataType |
        relation restrictwith ~ {[relation is $ArgPositions == $argpos]} |
        relation semijoin ~ [deRef [ArgumentSignature findAll]] |
        ::rosea::Helpers::ToRef ::micca::ArgumentSignature ~
    }]

    if {[isEmptyRef $sigref]} {
        set sigid [GenNumber $DomainName ArgumentSignature\
                [list $DomainName $ClassName]]
        set sigref [ArgumentSignature create\
            Domain  $DomainName\
            Model   $ClassName\
            SigID   $sigid]
        set pos -1
        dict for {pname ptype} $params {
            ActivityArgument create\
                Domain      $DomainName\
                Model       $ClassName\
                SigID       $sigid\
                Position    [incr pos]\
                DataType    $ptype
        }
    } else {
        set sigid [readAttribute $sigref SigID]
    }

    return $sigid
}
----

=== Event

==== Implementation

[source,tcl]
----
<<state model config commands>>=
proc event {name args} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set sigid [expr {[llength $args] != 0 ?\
        [FindEventSignature $name $args] : {}}]

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $name\
    ]
    set evtref [Event findById {*}$eventtuple]
    if {[isEmptyRef $evtref]} {
        set evtref [Event create {*}$eventtuple SigID $sigid]
        TransitioningEvent create {*}$eventtuple\
            Number [GenNumber $DomainName TransitioningEvent\
                [list $DomainName $ClassName]]
        LocalEvent create {*}$eventtuple
    } elseif {[readAttribute $evtref SigID] eq {}} {
        updateAttribute $evtref SigID $sigid
    }

    if {$sigid ne {}} {
        StateTransition update [pipe {
            findRelatedWhere $evtref\
                {{~R80 TransitioningEvent} {~R70 TransitionPlace}\
                {~R71 StateTransition}} {$SigID eq {}} |
            deRef ~ SigID |
            relation update ~ sttuple {1} {
                tuple update $sttuple SigID $sigid
            }
        }]
    }
}
----

[source,tcl]
----
<<state model config commands>>=
proc FindEventSignature {event params} {
    if {[dict size $params] == 0} {
        return
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set pos -1
    set sigid [FindArgumentSignature $params]
    dict for {pname ptype} $params {
        EventParameter create\
            Domain      $DomainName\
            Model       $ClassName\
            Event       $event\
            SigID       $sigid\
            Position    [incr pos]\
            Name        $pname
    }

    return $sigid
}
----

=== Transition

*****
+transition+ _source_ `-` _event_ `->` _target_

+source+::
    The name of a state in the state model being defined or the
    special reserved name, `@`.
+event+::
    The name of an event that causes the transition.
+target+::
    The name of a state in the state model being defined or one of the
    special non-transitioning states, `IG` or `CH`.
*****

///////
----
<<manual statemodel configuration commands>>=
[call [cmd transition] [arg source] [arg -] [arg event] [arg ->] [arg target]]

The [cmd transition] command specifies that when an instance is currently
in the [arg source] state and receives [arg event] that it
will transition to the [arg target] state.
The [arg -] and [arg ->] arguments are syntactic sugar and are ignored.
The [arg source] argument may be any state of the state model being defined
or the [arg @] state, signifying the pseudo-initial state used for
asynchronous instance creation.
The [arg target] argument may be any state of the state model or
one of the non-transitioning states, [emph IG] or [emph CH].
If [arg target] is [emph IG] then the event is ignored.
If [arg target] is [emph CH] then the event is deemed as logically impossible
to happen in the [arg source] state and an error condition is raised.
The [arg event] argument is the name of an event and the set of events
to which the state model responds is taken as the union of all the
[arg event] names encountered in the [cmd transition] commands defining the
state model.
[para]
[example {
transition Idle - Run -> Running
transition Running - Stop -> Idle
}]
----
///////

[float]
==== Implementation

The implementation of the `transition` command consists mainly of
inserting tuples into the event classes using the data from the command
arguments.
Note however, that all the events defined by invoking `transition` are
deemed to be a *LocalEvent*.
This certainly may not be true for classes that are leaf subclass of
a generalization hierarchy.
When the domain configuration is completed we will propagate the
polymorphic events down the generalization hierarchies and in that
process recategorize any inherited events properly.

One other minor concern is dealing with the initial pseudo-state, *@*.
This state is where an instance resides if it has been created
asynchronously.
One may not define the `@` state in a `state` command
(it cannot have an activity)
and the only valid place it can appear is as the `source` state in a
`transition` command.

(((micca,Config,transition)))
[source,tcl]
----
<<state model config commands>>=
proc transition {source - event -> target} {
    if {$event eq {}} {
        tailcall DeclError BAD_NAME event
    }
    if {[isNotEmptyRef [TransitionRule findById Name $source]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    if {$source eq "@"} {
        if {[isNotEmptyRef [TransitionRule findById Name $target]]} {
            tailcall DeclError BAD_CREATION_TARGET $target
        }
        set cstuple [list\
            Domain          $DomainName\
            Model           $ClassName\
            Name            @\
        ]
        if {[isEmptyRef [CreationState findById {*}$cstuple]]} {
            CreationState create {*}$cstuple
        }
        if {[isEmptyRef [StatePlace findById {*}$cstuple]]} {
            StatePlace create {*}$cstuple
        }
    }

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $event\
    ]
    if {[isEmptyRef [Event findById {*}$eventtuple]]} {
        Event create {*}$eventtuple SigID {}
        TransitioningEvent create {*}$eventtuple\
            Number [GenNumber $DomainName TransitioningEvent\
                [list $DomainName $ClassName]]
        LocalEvent create {*}$eventtuple
    }

    set transtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        State   $source\
        Event   $event\
    ]
    TransitionPlace create {*}$transtuple

    set trref [TransitionRule findById Name $target]
    if {[isNotEmptyRef $trref]} {
        Non-StateTransition create {*}$transtuple TransRule $target
    } else {
        set stref [StateTransition create {*}$transtuple\
                NewState $target SigID {}]
        set newref [findRelatedWhere $stref R72 {$SigID ne {}}]
        if {[isNotEmptyRef $newref]} {
            updateAttribute $stref SigID [readAttribute $newref SigID]
        } else {
            set evtref [findRelatedWhere $stref\
                {R71 {R70 TransitioningEvent} R80} {$SigID ne {}}]
            if {[isNotEmptyRef $evtref]} {
                updateAttribute $stref SigID [readAttribute $evtref SigID]
            }
        }
    }

    return
}
----

(((error code,BAD_CREATION_TARGET)))
[source,tcl]
----
<<error code formats>>=
BAD_CREATION_TARGET {the target of a creation event must be a state,\
        got "%s"}
----

==== Initialstate

By default,
instances created from classes that have a state model are placed in
the first state that was defined for the model.
The `initialstate` command is used to specify explicitly the inital state
for newly created instances.

*****
+initialstate+ _name_

+name+::
    The name of at state in the state model being defined.
    Instances of the class that are created synchronously using
    the `create` class command will be placed in this state.
*****

///////
----
<<manual statemodel configuration commands>>=
[call [cmd initialstate] [arg name]]

The [cmd initialstate] command set the state named, [arg name], to be
the initial state of the state model.
If no [cmd initialstate] command is invoked in the body of a [cmd statemodel],
then name of the state given in the first invocation of the [cmd state]
command is deemed to be the initial state.
----
///////

[float]
===== Implementation

(((rosea,Config,initialstate)))
[source,tcl]
----
<<state model config commands>>=
proc initialstate {name} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME initialstate
    }
    if {$name eq "@" || [isNotEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }
    variable InitialState $name
    return
}
----

==== Defaulttrans

It is customary to write `transition` commands only for outgoing
transition that appear on the state model graphic.
For any entries in transition matrix that are not set by a `transition`
command,
a default value is supplied.
That default is either `IG` or `CH` depending upon the argument to the
`defaulttrans` command.
If no `defaulttrans` command is invoked when a state model is defined,
then the default transition will be `CH`.

*****
+defaulttrans+ _trans_

+trans+::
    Either the string *IG* or *CH*.
    For all transitions not explicitly mentioned in a `transition` command,
    the default transition is defined as _trans_.
    If `defaulttrans` is not invoked during a state model definition
    then the default transition is *CH*.
*****

///////
----
<<manual statemodel configuration commands>>=
[call [cmd defaulttrans] [arg "CH | IG"]]

The [cmd defaulttrans] command define the default transition target
for all state transition that are not explicitly defined using the
[cmd transition] command.
This allows for a minimal number of invocations of the [cmd transition]
command with all other transition target set to the default.
If the [cmd defaulttrans] command is not invoked in the body of a
[cmd statemodel], then [emph CH] is deemed to be the default transition.
----
///////

[float]
===== Implementation

(((rosea,Config,defaulttrans)))
[source,tcl]
----
<<state model config commands>>=
proc defaulttrans {name} {
    if {[isEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError EXPECTED_PSEUDO_STATE $name
    }
    variable DefaultTrans $name
    return
}
----

(((error code,EXPECTED_PSEUDO_STATE)))
[source,tcl]
----
<<error code formats>>=
EXPECTED_PSEUDO_STATE    {expected CH or IG, got "%s"}
----

==== Terminal

Terminal states are those where the class instance is deleted after
the state activity is executed.
This allows for asynchronous deletion of class instances.

*****
+terminal+ _?state ...?_

+state+::
    The name of a state in the state model that will be marked as a
    terminal state.
    If a state machine transitions into a terminal state,
    the associated instance is deleted after the state activity is
    executed.
*****

///////
----
<<manual statemodel configuration commands>>=
[call [cmd terminal] [opt [arg "state ..."]]]

The [cmd terminal] command specifies that [arg states] given as arguments
are to be deemed [emph "terminal states"].
When an instance transitions into a terminal state and
after the execution of the state activity,
the instance is automatically deleted.
----
///////

[float]
===== Implementation

(((rosea,Config,terminal)))
[source,tcl]
----
<<state model config commands>>=
proc terminal {args} {
    variable Terminals
    ::struct::set add Terminals $args
    return
}
----

== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path {::micca ::rosea::InstCmds}

    <<helper data>>
    <<helper commands>>
}
----

=== DeclError

All error notification in the package is consolidated in
the +DeclError+ procedure.

[float]
==== Implementation

The +DeclError+ procedure locates a format string based on the error code
and applies its arguments to it.
We use the +::throw+ command to raise the error to insure that we have
consistent error code information for the package.

(((micca,Helpers,DeclError)))
[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list MICCA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

=== Generate Numbers

There are a number of classes that have attributes that are
zero based sequential numbers.
We want a convenient way to generate these ordinal numbers.
Many times we want the number to start at zero within a set of
attributes.

[float]
==== Implementation

[source,tcl]
----
<<helper data>>=
relvar create SeqNumbers {
    Domain string
    ClassName string
    Attrs list
    Number int
} {Domain ClassName Attrs}
----

[source,tcl]
----
<<helper commands>>=
proc GenNumber {domain class args} {
    set num [relvar restrictone SeqNumbers Domain $domain ClassName $class\
        Attrs $args]
    if {[relation isempty $num]} {
        relvar insert SeqNumbers [list\
            Domain $domain\
            ClassName $class\
            Attrs $args\
            Number 0\
        ]
        return 0
    } else {
        set result [expr {[relation extract $num Number] + 1}]
        relvar updateone SeqNumbers sn [list Domain $domain ClassName $class\
            Attrs $args] {
            tuple update $sn Number $result
        }
        return $result
    }
}
----

[source,tcl]
----
<<helper commands>>=
proc CheckDuplicate {class args} {
    set ref [$class findById {*}$args]
    if {[isNotEmptyRef $ref]} {
        tailcall DeclError DUP_INSTANCE_NAME $class $args
    }
    return
}
----

(((error code,DUP_ELEMENT_NAME)))
[source,tcl]
----
<<error code formats>>=
DUP_INSTANCE_NAME    {an element of class, "%s", already exists with\
        attributes, "%s"}
----

[source,tcl]
----
<<helper commands>>=
proc GetMiccaClass {class} {
    return [deRef [$class findAll]]
}
----

== Test Utility Commands

[source,tcl]
----
<<test utility commands>>=
namespace export formatMiccaClass
proc formatMiccaClass {class} {
    return \n[ral relformat [GetMiccaClass $class] $class]
}

namespace export readMiccaAttribute
proc readMiccaAttribute {class attr args} {
    return [rosea tunnel [$class findById {*}$args] readAttribute $attr]
}

proc cleanupDomain {} {
    set preserve {
        ::micca::TransitionRule
    }
    relvar eval {
        foreach var [relvar names {::micca::[A-Z]*}] {
            if {$var ni $preserve} {
                relvar set $var [relation empty [relvar set $var]]
            }
        }

        relvar set ::micca::@Config@::Class_Reference\
            [relation empty [relvar set ::micca::@Config@::Class_Reference]]
    }
}

proc testConditions {args} {
    set result 1
    foreach exp $args {
        set passed [uplevel 1 [list expr $exp]]
        if {!$passed} {
            log::error "\"$exp\" failed"
            set result 0
        }
    }
    return $result
}
----
