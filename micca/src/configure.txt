// vim:set syntax=asciidoc:

= Configuring a Domain

[partintro]
--
In the last part of the book,
we showed the platform specific model that `micca` uses.
To translate a domain it is necessary to populate the platform
specific model with the specific characteristics of the translated domain.
Since the platform model is implemented in `rosea`,
we could populate it using the `rosea populate` command.
This would be a difficult and tedious way to populate the platform
model for a human.
It might be perfectly acceptable to create a `rosea` population
programmatically, but it requires detailed knowledge of the platform model.
We will provide a much more convenient interface for humans by using
a domain specific language (DSL).

The DSL in this case is also a Tcl script and we will build the
DSL processing directly into the `micca` domain.
We will use the Tcl interpreter to parse the DSL.
The code that reads the DSL arranges for the script to be executed in
a context where command names resolve to procedures that populate the
`micca` platform specific model.
--

== Configuration Operations

Configuring a domain in `micca` will happen as a domain operation.
When we parse the various portions of a domain description,
we will use namespaces to confine the script execution and to expose
the appropriate commands to the configuration scripts.
This requires us to define child namespaces for the `micca` domain.
We must use some care in this because a `rosea` domain already has some
child namespaces defined on it. We will use a naming convention to
avoid any possible naming collisions.

In this part,
we first present the commands that are used to configure a domain under
`micca`.
These will be domain operations of the `micca` domain.
Afterwards,
we will define further child namespaces and commands within them that
accomplish gathering all the information needed to define the characteristics
of a domain.

=== Configure

One of our top level +micca+ commands is to configure a domain from
a script.

*****
+::micca configure+ _script_

+script+::
    A Tcl script that is executed in an environment that will resolve
    _domain configuration_ commands that may be used to define
    the characteristics of a domain.
*****

[float]
==== Implementation

(((micca,operation,configure)))
[source,tcl]
----
<<micca configuration>>=
operation configure {script} {
    return [@Config@::miccaConfigure $script]
}
----

=== ConfigureFromChan

It is often convenient to obtain the +configure+ script from an I/O channel.
The +micca configureFromChan+ command supports reading the configure
script directly from a channel.

*****
+::micca configureFromChan+ _channel_

+channel+::
    A Tcl channel handle that is readable.

The `configureFromChan` command invokes `configure` on the script
obtained by reading _channel_ until end of file is reached.
*****

[float]
==== Implementation

(((micca,operation,configureFromChan)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromChan {chan} {
    return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
}
----

=== ConfigureFromFile

It is often convenient to hold the +configure+ script in a file.
The +micca configureFromFile+ command supports reading the configure
script directly from a file.

*****
+::micca configureFromFile+ _filename_

+filename+::
    The name of a file containing a domain configuration script.

The `configureFromFile` command invokes `configure` on the script
obtained by reading the contents of the file named, _filename_.
*****

[float]
==== Implementation

(((micca,operation,configureFromFile)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromFile {filename} {
    set chan [::open $filename r]
    try {
        return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
    } finally {
        ::chan close $chan
    }
}
----

== Configuration Namespace Layout

The +::micca::@Config@+ namespace holds all the procedures that
perform the configuration of a `micca` domain.
We want to create a set of child namespaces
that mirror the nesting of the configuration language statements.
At the top level,
the +domain+ command is used to define each domain.
The +domain+ command accepts a script body that then defines the
components of the domain.
That script will be evaluated in a namespace where the commands that
define the domain components, _e.g._ +class+ and relationship commands,
resolve appropriately.
This lets us put commands for the body specifying a particular component into a
namespace which prevents any problems of accidentally invoking commands that
are inappropriate for that context.

We layout the +::micca::@Config@+ namespace as shown below.

[source,tcl]
----
<<configuration commands namespace>>=
namespace eval @Config@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    <<helper commands namespace>>

    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}
    <<config data>>
    <<config commands>>

    <<domain config namespace layout>>
}
----

=== Evaluating Configuration Scripts

The top level domain operations of `micca` that configure domains
all invoke `miccaConfigure` as the common entry point into the configuration
DSL code.

[float]
==== Implementation

(((micca,ensemble,configure)))
[source,tcl]
----
<<config commands>>=
proc miccaConfigure {script} {
    variable errcount
    set errcount 0

    variable configlineno
    set configlineno 1

    ConfigEvaluate ::micca::@Config@ $script

    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
CONFIG_ERRORS     {encountered %d configuration script errors}
----

You could evaluate the configuration script by simply gathering it together
and passing it to the core +namespace eval+ command.
Unfortunately,
the first error that is encountered will terminate the evaluation.
This is decidedly inconvenient as you would prefer to continue on and
come up with a list of errors for the evaluation much like a
conventional language compiler would do when compiling a source file.
Discovering errors one at a time is tediously unproductive.

Of course, it is possible to continue evaluating after an error but
that requires a bit more code.
We will also want to be able to evaluate scripts in different namespace
contexts as we described above.
We will accomplish all this by taking advantage of the core +::apply+ command
and its ability to execute a lambda function in a given namespace.
So given a script body and an namespace we can evaluate it as shown below.

(((micca,Config,ConfigEvaluate)))
[source,tcl]
----
<<config commands>>=
namespace export ConfigEvaluate

proc ConfigEvaluate {ns body} {
    variable evalLambda
    tailcall ::apply [concat $evalLambda [list $ns]] $body ; # <1>
}
----
<1> The `concat` command treats its arguments as a list.
On the off chance that the `ns` argument contains embedded whitespace,
we need to insure that it is treated as a single element list.
Hence the need to include the invocation of the `list` command.

The lambda function that performs the command evaluation is given below.
We hold the evaluation lambda as a piece of data.

[source,tcl]
----
<<config data>>=
variable evalLambda {{body} {
    upvar #0 ::micca::@Config@::errcount errcount ; # <1>
    upvar #0 ::micca::@Config@::configlineno configlineno
    set lineno $configlineno
    set command {}
    foreach line [split $body \n] { # <2>
        append command $line \n
        incr lineno ; # <3>
        if {[info complete $command]} {
            try {
                eval $command
            } on error {result} {
                puts $::errorInfo
                log::error "line $configlineno: \"$result\""
                incr errcount
            }
            set command {} ; # <4>
            set configlineno $lineno
        }
    }
    return $errcount
}}
----
<1> We need to keep track of all the errors encountered and
what line of the script we are currently dealing with.
<2> We split the body along lines and then reassemble the lines
into a complete command. The +info complete+ command tells us when
we have something that has some chance of being a real command.
<3> We need to keep track of where we are in the +body+.
<4> After evaluating a command we begin to assemble another one and
set our location counter to where that command starts.

== Defining a Domain

As we described above,
the domain configuration commands will take the data in their
arguments and store it away.
After we have finished all the configuration scripts,
then the +generate+ command is used to layout the data structures
and namespace as needed.

When configuring a domain,
we will evaluate the configuration script in the +DomainDef+ child namespace.
That namespace will define commands for all the components of the
domain.
We will use a similar arrangement for other nested aspects of
domain definitions.

=== Domain

*****
+domain+ _name_ _body_

+name+::
    The name of the domain. A domain name must be a non-empty string.
+body+::
    A Tcl script containing invocation of the domain definition commands
    to specify the details of the domain configuration.
*****

[float]
==== Implementation

(((micca,Config,domain)))
[source,tcl]
----
<<config commands>>=
proc domain {name body} {
    namespace upvar DomainDef DomainName DomainName ; # <1>
    set DomainName $name

    try {
        set domref [Domain findById Name $name] ; # <2>
        if {[isEmptyRef $domref]} {
            Domain create Name $name
        }

        ConfigEvaluate [namespace current]::DomainDef $body

        # At this point we have the definition of the domain and enough
        # information to tie together the class references and
        # the association definitions.
        <<domain: bind association references>>

        # We must also compute how polymorphic events are inherited
        # down generalization hierarchies.
        <<domain: propagate polymorphic events>>
    } on error {result} {
        puts $::errorInfo
        # ::micca::@Config@::HandleConfigError $result
    }
}
----
<1> We place the domain name into the child namespace where the context
implies that all the components defined are to be part of this domain.
<2> We allow the +domain+ command to be invoked more than once.
Domains are open ended definitions so we test to make sure we do not
attempt to create a duplicate domain.

(((error code,EMPTY_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_NAME      {"%s" is not a valid name for a %s}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-1.0 {
    Define an empty domain
} -setup {
} -cleanup {
    #cleanupConfigData
} -body {
    micca configure {
        domain foo {
            # A domain may be empty of components.
        }
    }
    set domains [micca::Domain findAll]
    rosea tunnel $domains readAttribute Name
} -result {foo}
----

== Defining Domain Components

In this section we discuss the commands that are used to define
the components of a domain.
We define child namespaces for those domain component commands
that have a nested structure.
In this case,
it is the +class+ command that requires additional configuration commands.

We start with the namespace layout for the +DomainDef+ namespace.

[source,tcl]
----
<<domain config namespace layout>>=
namespace eval DomainDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}
    <<domain config commands>>

    <<class config namespace layout>>
    <<assigner config namespace layout>>
}
----

=== Class

The class command is used to define classes and specify their characteristics.

*****
+class+ _name_ _script_

+name+::
    The name of the class. A class name must be a non-empty string.
+script+::
    A Tcl script containing invocation of the class definition commands
    to specify the details of the class configuration.
*****

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<domain config commands>>=
proc class {name body} {
    namespace upvar [namespace current] DomainName DomainName ; # <1>
    namespace upvar ClassDef ClassName ClassName
    set ClassName $name

    set delem [DomainElement findById Domain $DomainName Name $name]
    if {[isNotEmptyRef $delem]} {
        tailcall DeclError DUP_ELEMENT_NAME $name
    }
    DomainElement create Domain $DomainName Name $name
    Class create Domain $DomainName Name $name\
        Number [GenNumber $DomainName Class [list $DomainName]]
    ValueElement create Domain $DomainName Name $name

    ConfigEvaluate [namespace current]::ClassDef $body
}
----
<1> Again we arrange for namespace variables to hold the current
domain and class names to provide the context of the definition.

(((error code,BAD_CLASS_NAME)))
(((error code,DUP_ELEMENT_NAME)))
[source,tcl]
----
<<error code formats>>=
DUP_ELEMENT_NAME    {a class or relationship named, "%s", already exists}
----

=== Generalization

Defining a generalization relationship is quite a bit simpler than
the effort we just saw in defining associations.
For generalizations,
it is necessary to specify the superclass and the set of subclasses.

*****
+generalization+ _name_ _?-union | -reference?_ _super_ _sub1_ _sub2_ _?...?_

+name+::
    The name of the generalization. Conventionally, relationships names are of
    the form *R<d>* where _<d>_ is one or more decimal digits but any non-empty
    string can be used.
+super+::
    The name of the class that serves as the superclass of the generalization.
+subN+::
    The names of the classes that serve as the subclasses of the generalization.
    You must have at least two subclasses to define a generalization.
*****

[float]
==== Implementation

(((micca,Config,generalization)))
[source,tcl]
----
<<domain config commands>>=
proc generalization {name args} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME generalization
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    set type reference
    while {1} {
        set args [lassign $args arg]

        if {$arg eq "-reference"} {
            set type reference
        } elseif {$arg eq "-union"} {
            set type union
        } elseif {$arg eq "--"} {
            set args [lassign $args super]
            break
        } else {
            set super $arg
            break
        }
    }

    if {[llength $args] < 2} {
        tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]

    set delem [DomainElement findById {*}$reltuple]
    if {[isNotEmptyRef $delem]} {
        tailcall DeclError DUP_ELEMENT_NAME $name
    }

    DomainElement create {*}$reltuple
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Generalization create {*}$reltuple

    set supertuple [list\
        Domain          $DomainName\
        Class           $super\
        Relationship    $name\
        Role            target\
    ]
    set subtuple [dict create\
        Domain          $DomainName\
        Relationship    $name\
        Role            source\
    ]

    if {$type eq "reference"} {
        ReferenceGeneralization create {*}$reltuple
        ReferencedSuperclass create {*}$supertuple
        foreach sub $args {
            dict set subtuple Class $sub
            ReferringSubclass create {*}$subtuple
        }
    } elseif {$type eq "union"} {
        UnionGeneralization create {*}$reltuple
        UnionSuperclass create {*}$supertuple
        SubclassContainer create Domain $DomainName Class $super Name $name
        ClassComponent create Domain $DomainName Class $super Name $name
        foreach sub $args {
            dict set subtuple Class $sub
            UnionSubclass create {*}$subtuple
        }
    }
    Superclass create {*}$supertuple
    ClassRole create {*}$supertuple

    foreach sub $args {
        dict set subtuple Class $sub
        Subclass create {*}$subtuple
        ClassRole create {*}$subtuple
    }

    return
}
----

(((error code,TOO_FEW_SUBCLASSES)))
[source,tcl]
----
<<error code formats>>=
TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-1.0 {
    Define reference generalization
} -setup {
} -cleanup {
} -body {
    micca configure {
        domain foo {
            class super {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int
            }
            generalization R1 -reference super sub1 sub2
        }
    }
    log::debug [formatMiccaClass ReferenceGeneralization]
    log::debug [formatMiccaClass ReferencedSuperclass]
    log::debug [formatMiccaClass ReferringSubclass]
    relation cardinality\
        [lindex [micca::Generalization findById Domain foo Name R1] 1]
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test generalization-2.0 {
    Define union generalization
} -setup {
} -cleanup {
} -body {
    micca configure {
        domain foo {
            class usuper {
                attribute sid int
            }
            class usub1 {
                attribute sid int
            }
            class usub2 {
                attribute sid int
            }
            generalization R2 -union usuper usub1 usub2
        }
    }
    log::debug [formatMiccaClass UnionGeneralization]
    log::debug [formatMiccaClass UnionSuperclass]
    log::debug [formatMiccaClass UnionSubclass]
    log::debug [formatMiccaClass ClassComponent]
    relation cardinality\
        [lindex [micca::Generalization findById Domain foo Name R2] 1]
} -result {1}
----

=== Type Alias

*****
+typealias+ _definition_ _name_

+definition+::
    A ``C'' typename.
+name+::
    The name of the type alias.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc typealias {typedef aliasname} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    TypeAlias create Domain $DomainName TypeName $aliasname\
        TypeDefinition $typedef

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typealias-1.0 {
    Define a type alias
} -setup {
} -cleanup {
} -body {
    micca configure {
        domain foo {
            typealias uint8 rawbyte
        }
    }
    log::debug [formatMiccaClass TypeAlias]
    readMiccaAttribute TypeAlias TypeDefinition Domain foo TypeName rawbyte
} -result {uint8}
----

=== Domain Operation

*****
+domainop+ _rettype_ _name_ _parameters_ _body_

+definition+::
    A ``C'' typename.
+name+::
    The name of the type alias.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc domainop {rettype name parameters body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

    DomainOperation create Domain $DomainName Name $name Body $body\
        ReturnDataType $rettype
    set paramtuple [dict create Domain $DomainName Operation $name]
    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName DomainOperationParameter\
                [list $DomainName $name]]
        DomainOperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domainop-1.0 {
    Define a domain operation
} -setup {
} -cleanup {
} -body {
    micca configure {
        domain foo {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }
        }
    }
    log::debug [formatMiccaClass DomainOperation]
    log::debug [formatMiccaClass DomainOperationParameter]
    readMiccaAttribute DomainOperation ReturnDataType Domain foo Name color
} -result {void}
----

== Defining Classes Components

Since there are several aspects of classes,
the +class+ command takes a _script_ argument which should
invoke the commands we discuss in this section.
Following our pattern,
we define a namespace where the class body script is evaluated.

[source,tcl]
----
<<class config namespace layout>>=
namespace eval ClassDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class config commands>>

    <<state model config namespace layout>>
}
----

=== Attribute

Within a class definitions,
the +attribute+ command specifies the attributes of the class.

*****
+attribute+ _name_ _type_ ?_option value_ ...?

+name+::
    The name of the attribute. Attributes names may not be the empty string.
+type+::
    The type of the attribute. The _type_ may be any valid ``C'' type name.
*****

The implementation of the +attribute+ command simply creates tuples
in the relvars to hold the attribute characteristics.

[float]
==== Implementation

(((micca,Config,attribute)))
[source,tcl]
----
<<class config commands>>=
proc attribute {name type args} {
    if {$name eq {}} {
        tailcall DeclError EMPTY_NAME attribute
    }
    if {[string range $name 0 1] eq "__"} {
        tailcall DeclError RESERVED_NAME $name
    }
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    ClassComponent create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name
    Attribute create\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name\
        DataType    $type

    foreach {option value} $args {
        switch -exact -- $option {
            -default {
                DefaultValue create\
                    Domain      $DomainName\
                    Class       $ClassName\
                    Attribute   $name\
                    Value       $value
            }
            default {
                tailcall DeclError UNKNOWN_OPTION attribute $option
            }
        }
    }
}
----

(((error code,RESERVED_NAME)))
(((error code,INT_TYPE_REQUIRED)))
(((error code,INT_VALUE_REQUIRED)))
[source,tcl]
----
<<error code formats>>=
RESERVED_NAME {names beginning with two underscore characters are reserved,\
        "%s" cannot be used as a name in this context}
INT_TYPE_REQUIRED   {attribute must be of "int" type, got "%s"}
INT_VALUE_REQUIRED  {an integer value is required, got "%s"}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test attribute-1.0 {
    Define class with attributes
} -setup {
} -cleanup {
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20
            }
            class c2 {
                attribute b1 uint8
                attribute b2 float
            }
        }
    }
    relation cardinality [lindex\
        [micca::Attribute findWhere {$Domain eq "foo" && $Class eq "c2"}] 1]
} -result {2}
----

=== Class Operation

*****
+classop+ _rettype_ _name_ _parameters_ _body_

*****
[float]
==== Implementation

(((micca,Config,attribute)))
[source,tcl]
----
<<class config commands>>=
proc classop {rettype name parameters body} {
    DefineOperation false $rettype $name $parameters $body
}
----

=== Instance Operation

*****
+classop+ _rettype_ _name_ _parameters_ _body_

*****
[float]
==== Implementation

(((micca,Config,attribute)))
[source,tcl]
----
<<class config commands>>=
proc instop {rettype name parameters body} {
    DefineOperation true $rettype $name $parameters $body
}
----

=== Define Operation

[float]
==== Implementation

(((micca,Config,DefineOperation)))
[source,tcl]
----
<<class config commands>>=
proc DefineOperation {isinst rettype name parameters body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    Operation create Domain $DomainName Class $ClassName Name $name Body $body\
        ReturnDataType $rettype IsInstance $isinst
    set paramtuple [dict create Domain $DomainName Class $ClassName\
            Operation $name]

    if {$isinst} {
        dict set paramtuple Name self
        dict set paramtuple DataType "struct $ClassName *"
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    return
}
----

[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test classop-1.0 {
    Define a class operation
} -setup {
} -cleanup {
} -body {
    micca configure {
        domain foo {
            class c4 {
                attribute a1 int

                classop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation ReturnDataType Domain foo Class c4 Name color
} -result {float}
----

[source,tcl]
----
<<config command tests>>=
test instop-1.0 {
    Define an instance operation
} -setup {
} -cleanup {
} -body {
    micca configure {
        domain foo {
            class c5 {
                attribute a1 int

                instop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation IsInstance Domain foo Class c5 Name color
} -result {true}
----

== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path {::micca ::rosea::InstCmds}
    <<helper data>>
    <<helper commands>>
}
----

=== DeclError

All error notification in the package is consolidated in
the +DeclError+ procedure.

[float]
==== Implementation

The +DeclError+ procedure locates a format string based on the error code
and applies its arguments to it.
We use the +::throw+ command to raise the error to insure that we have
consistent error code information for the package.

(((micca,Helpers,DeclError)))
[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list MICCA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

=== Generate Numbers

There are a number of classes that have attributes that are
zero based sequential numbers.
We want a convenient way to generate these ordinal numbers.
Many times we want the number to start at zero within a set of
attributes.

[float]
==== Implementation

[source,tcl]
----
<<helper data>>=
relvar create SeqNumbers {
    Domain string
    ClassName string
    Attrs list
    Number int
} {Domain ClassName Attrs}
----

[source,tcl]
----
<<helper commands>>=
proc GenNumber {domain class args} {
    set num [relvar restrictone SeqNumbers Domain $domain ClassName $class\
        Attrs $args]
    if {[relation isempty $num]} {
        relvar insert SeqNumbers [list\
            Domain $domain\
            ClassName $class\
            Attrs $args\
            Number 0\
        ]
        return 0
    } else {
        set result [expr {[relation extract $num Number] + 1}]
        relvar updateone SeqNumbers sn [list Domain $domain ClassName $class\
            Attrs $args] {
            tuple update $sn Number $result
        }
        return $result
    }
}
----

[source,tcl]
----
<<test utility commands>>=
namespace export getMiccaClass
proc getMiccaClass {class} {
    return [deRef [$class findAll]]
}

namespace export formatMiccaClass
proc formatMiccaClass {class} {
    return \n[ral relformat [getMiccaClass $class] $class]
}

namespace export readMiccaAttribute
proc readMiccaAttribute {class attr args} {
    return [rosea tunnel [$class findById {*}$args] readAttribute $attr]
}

----
