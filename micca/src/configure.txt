// vim:set syntax=asciidoc:

= Configuring a Domain

[partintro]
--
In the last part of the book,
we showed the platform specific model that `micca` uses.
To translate a domain it is necessary to populate the platform
specific model with the specific characteristics of the domain to be translated.
Since the platform model is implemented in `rosea`,
we could populate it using the `rosea populate` command.
This would be a difficult and tedious way to populate the platform
model for a human.
It might be perfectly acceptable to create a `rosea` population
programmatically, but it requires detailed knowledge of the platform model.
We will provide a much more convenient interface for humans by using
a domain specific language (DSL).

The DSL in this case is also a Tcl script and we will build the
DSL processing directly into the `micca` domain.
We will use the Tcl interpreter to parse the DSL.
The code that reads the DSL arranges for the script to be executed in
a context where command names resolve to procedures that populate the
`micca` platform specific model.

In this part,
we describe the commands that make up the DSL used to populate the
platform model.
--

== Configuration Commands

Configuring a domain in `micca` happens as a domain operation.
When we parse the various portions of a domain description,
we will use namespaces to confine the script execution and to expose
the appropriate commands to the configuration scripts.
This requires us to define child namespaces for the `micca` domain.
We must use some care in this because a `rosea` domain already has some
child namespaces defined on it. We will use a naming convention to
avoid any possible naming collisions.

The configuration script is a Tcl script and the full resources of
Tcl are available.
In particular, the `source` command is useful for organizing
configuration scripts into smaller pieces that can be included,
using the `source` command, into a configuration.

In this part,
we first present the commands that are used to configure a domain under
`micca`.
These will be domain operations of the `micca` domain.
Afterwards,
we will define further child namespaces and commands within them that
accomplish gathering all the information needed to define the characteristics
of a domain.

=== Configure

One of our top level +micca+ commands is to configure a domain from
a script.

*****
+::micca configure+ _script_

+script+::
    A Tcl script that is executed in an environment that will resolve
    _domain configuration_ commands that may be used to define
    the characteristics of a domain to be translated by `micca`.
*****

[float]
==== Implementation

(((micca,operation,configure)))
[source,tcl]
----
<<micca configuration>>=
operation configure {script} {
    return [@Config@::miccaConfigure $script]
}
----

=== ConfigureFromChan

It is often convenient to obtain the +configure+ script from an I/O channel.
The +micca configureFromChan+ command supports reading the configure
script directly from a channel.

*****
+::micca configureFromChan+ _channel_

+channel+::
    A Tcl channel handle that has been opened for reading.

The `configureFromChan` command invokes `configure` on the script
obtained by reading _channel_ until end of file is reached.
*****

[float]
==== Implementation

(((micca,operation,configureFromChan)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromChan {chan} {
    return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
}
----

=== ConfigureFromFile

It is often convenient to hold the +configure+ script in a file.
The +micca configureFromFile+ command supports reading the configure
script directly from a file.

*****
+::micca configureFromFile+ _filename_

+filename+::
    The name of a file containing a domain configuration script.

The `configureFromFile` command invokes `configure` on the script
obtained by reading the contents of the file named, _filename_.
*****

[float]
==== Implementation

(((micca,operation,configureFromFile)))
[source,tcl]
----
<<micca configuration>>=
operation configureFromFile {filename} {
    set chan [::open $filename r]
    try {
        return [@Config@::miccaConfigure [::chan read -nonewline $chan]]
    } finally {
        ::chan close $chan
    }
}
----

== Configuration Namespace Layout

The +::micca::@Config@+ namespace holds all the procedures and data that
correspond to the DSL to populate the platform model.
We will create a set of child namespaces that mirror the nesting of the
configuration language statements.
At the top level,
the +domain+ command is used to define each domain.
The +domain+ command accepts a script body that then defines the
components of the domain.
That script will be evaluated in a namespace where the commands that
define the domain components, _e.g._ `class` and relationship commands,
resolve appropriately.
This lets us put commands for the body specifying a particular component into a
namespace which prevents any problems of accidentally invoking commands that
are inappropriate for that context.

We will use this technique for other child namespaces that correspond to
the nesting of DSL statements.
We layout the +::micca::@Config@+ namespace as shown below.

[source,tcl]
----
<<configuration commands namespace>>=
namespace eval @Config@ {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    <<helper commands namespace>>

    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds} ; # <1>
    <<config data>>
    <<config commands>>

    <<domain config namespace layout>>
    <<population config namespace layout>>
}
----
<1> We are evaluating the configuration DSL inside a child namespace of
of the `micca` domain, but we are trying to populate `micca` classes.
We find it convenient to resolve commands through the main `micca` namespace
as well as others that help things along.

=== Evaluating Configuration Scripts

The top level domain operations of `micca` that configure domains
all invoke `miccaConfigure` as the common entry point into the configuration
DSL code.

[float]
==== Implementation

(((micca,Config,miccaConfigure)))
[source,tcl]
----
<<config commands>>=
proc miccaConfigure {script} {
    variable errcount
    set errcount 0

    variable configlineno
    set configlineno 1

    ConfigEvaluate [namespace current] $script

    if {$errcount > 0} {
        tailcall DeclError CONFIG_ERRORS $errcount
    }
    return $errcount
}
----

(((error code,CONFIG_ERRORS)))
[source,tcl]
----
<<error code formats>>=
CONFIG_ERRORS     {encountered %d configuration script errors}
----

You could evaluate the configuration script by simply gathering it together
and passing it to the core `namespace eval` command.
Unfortunately,
the first error that is encountered will terminate the evaluation.
This is decidedly inconvenient as you would prefer to continue on and
come up with a list of errors for the evaluation much like a
conventional language compiler does when compiling a source file.
Discovering errors one at a time is tediously unproductive.

Of course, it is possible to continue evaluating after an error but
that requires a bit more code.
We will also want to be able to evaluate scripts in different namespace
contexts as we described above.
We will accomplish all this by taking advantage of the core +::apply+ command
and its ability to execute a lambda function in a given namespace.
So given a script body and an namespace we can evaluate it as shown below.

(((micca,Config,ConfigEvaluate)))
[source,tcl]
----
<<config commands>>=
namespace export ConfigEvaluate

proc ConfigEvaluate {ns body} {
    variable evalLambda
    tailcall ::apply [concat $evalLambda [list $ns]] $body ; # <1>
}
----
<1> The `concat` command treats its arguments as a list.
On the off chance that the `ns` argument contains embedded whitespace,
we need to insure that it is treated as a single element list.
Hence the need to include the invocation of the `list` command.

The lambda function that performs the command evaluation is given below.
We hold the evaluation lambda as a piece of data.

[source,tcl]
----
<<config data>>=
variable evalLambda {{body} {
    upvar #0 ::micca::@Config@::errcount errcount ; # <1>
    upvar #0 ::micca::@Config@::configlineno configlineno
    set lineno $configlineno
    set command {}
    foreach line [split $body \n] { # <2>
        append command $line \n
        incr lineno ; # <3>
        if {[info complete $command]} {
            try {
                eval $command
            } on error {result} {
                # puts $::errorInfo
                log::error "line $configlineno:\
                    \"[string trim $command]\":\n\"$result\""
                incr errcount
            }
            set command {} ; # <4>
            set configlineno $lineno
        }
    }
    return $errcount
}}
----
<1> We need to keep track of all the errors encountered and
what line of the script we are currently dealing with.
<2> We split the body along lines and then reassemble the lines
into a complete command. The +info complete+ command tells us when
we have something that has some chance of being a real command.
<3> We need to keep track of where we are in the +body+.
<4> After evaluating a command we begin to assemble another one and
set our location counter to where that command starts.

== Defining a Domain

As we described above,
the domain configuration commands will take the data in their
arguments and store it away.
After we have finished all the configuration scripts,
then the `generate` command is used to produce the ``C'' code and header files.

When configuring a domain,
we will evaluate the configuration script in the +DomainDef+ child namespace.
That namespace will define commands for all the components of the
domain.
We will use a similar arrangement for other nested aspects of
domain definitions.

=== Domain

*****
+domain+ _name_ _body_

+name+::
    The name of the domain. A domain name must be a non-empty string.
    The domain is used as a component for the file name of the generated
    code files, so domain names must be compatible with file name
    path components for the operating platform where `micca` is run.
+body+::
    A Tcl script containing invocation of the domain definition commands
    to specify the details of the domain configuration.

The `domain` command defines a domain named, _name_, and evaluates
_body_ in a context where commands in _body_ may be used to define
the characteristics of a domain.
*****

[float]
==== Implementation

(((micca,Config,domain)))
[source,tcl]
----
<<config commands>>=
proc domain {name body} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name domain
    }

    namespace upvar DomainDef DomainName DomainName ; # <1>
    set DomainName $name

    CheckDuplicate Domain Name $name ; # <2>
    Domain create Name $name

    try {
        ral relvar eval {
            ConfigEvaluate [namespace current]::DomainDef $body

            upvar #0 ::micca::@Config@::errcount errcount

            # We must compute how polymorphic events are inherited down
            # generalization hierarchies.
            <<domain: propagate polymorphic events>>
            <<domain: union subclass semantics>>
        }
    } on error {result opts} {
        # puts $::errorInfo
        HandleConfigError $result
    }
}
----
<1> We place the domain name into a variable in the child namespace where the
context implies that all the components defined are to be part of this domain.
<2> We do not allow the +domain+ command to be invoked more than once.
To configure a domain properly we need to be able to see its entire
definition at once.

(((error code,BAD_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_NAME      {"%s" is not a valid name for a %s}
----

[[post-config-domain]]
After evaluating the domain configuration script,
it is necessary to perform some additional clean up and evaluation.
For now,
we will say that there are semantic evaluations and checks that can only
be done after the entire domain configuration script has been processed.
The reason for this lies mainly with the way the DSL script commands
were defined to make them more convenient to use when translating an XUML model.
Polymorphic events must be dealt with after the domain configuration
is in place.
Again we will discuss this further
<<domain-propagate-polymorphic-events,below>>.

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-1.0 {
    Define an empty domain
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            # A domain may be empty of components.
        }
    }
    readMiccaAttribute Domain Name Name foo
} -result {foo}
----

[source,tcl]
----
<<config command tests>>=
test domain-1.1 {
    Badly named domain
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain {} {}
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

== Defining Domain Components

In this section we discuss the commands that are used to define
the components of a domain.
Following our established pattern,
we define child namespaces for those domain component commands
that have a nested structure.

We start with the namespace layout for the +DomainDef+ namespace.

[source,tcl]
----
<<domain config namespace layout>>=
namespace eval DomainDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace import ::micca::@Config@::Helpers::DeclError
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}
    <<domain config commands>>

    # Child namespaces for domain commands with additional structure
    <<class config namespace layout>>
    <<assigner config namespace layout>>
}
----

We see that there are two child namespaces defined with `DomainDef`.
These correspond to commands that have script bodies associated with them.

=== Interface

It is sometimes useful to include additional output in the header file
generated for a domain.
For example,
the domain may define operation parameters that are of a type already
defined in a header file.
That header file needs to be included in the generated header for the
domain.
The `interface` command provides a means to include arbitrary text into
the header file generated for the domain.

*****
`interface` _text_

`text`::
    Arbitrary text to be placed in the output of the generated interface file.

The `interface` command adds the string of the _text_ argument to
the interface file generated for the domain.
*****

[float]
==== Implementation

(((micca,Config,interface)))
[source,tcl]
----
<<domain config commands>>=
proc interface {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Interface $text
}
----

=== Prologue

It is also convenient to be able to include arbitrary text into the
generated code file for a domain.
The `prologue` command includes that text before any of the generated code.

*****
`prologue` _text_

`text`::
    Arbitrary text to be placed in the output code file before any generated
    code.

The `prologue` command adds the string of the _text_ argument to
the generated code file for the domain.
The `prologue` command may be invoked multiple times and the value of
all the _text_ arguments is concatenated in the order encountered.
The accumulated prologue text is emitted into the generated code file
before any `micca` generated code.
*****

[float]
==== Implementation

(((micca,Config,prologue)))
[source,tcl]
----
<<domain config commands>>=
proc prologue {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Prologue $text
}
----

=== Epilogue

The `epilogue` command includes text into the domain code file after
any generated code.
This can be use for small functions defined to handle the particulars
of user defined data types.

*****
`epilogue` _text_

`text`::
    Arbitrary text to be placed in the output code file after any generated
    code.

The `epilogue` command adds the string of the _text_ argument to
the generated code file for the domain.
The `epilogue` command may be invoked multiple times and the value of
all the _text_ arguments is concatenated in the order encountered.
The accumulated epilogue text is emitted into the generated code file
after any `micca` generated code.
*****

[float]
==== Implementation

(((micca,Config,epilogue)))
[source,tcl]
----
<<domain config commands>>=
proc epilogue {text} {
    variable DomainName
    AppendToDomainAttribute $DomainName Epilogue $text
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domain-2.0 {
    Define a domain with a non-empty interface
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            prologue "#include <stdio.h>"
        }
    }
    log::debug [formatMiccaClass Domain]
    string trimright [readMiccaAttribute Domain Prologue Name foo]
} -result {#include <stdio.h>}
----
endif::showtests[]

==== Append To Domain Attribute

The operations for the `interface`, `prologue` and `epilogue` commands
can be factored into common code.

[float]
==== Implementation

(((micca,Config,AppendToDomainAttribute)))
[source,tcl]
----
<<domain config commands>>=
proc AppendToDomainAttribute {domainname attrname text} {
    set domref [Domain findById Name $domainname]
    set value [readAttribute $domref $attrname]
    if {$value ne {} && [string index $value end] ne "\n"} {
        append value \n ; # <1>
    }
    append value $text
    updateAttribute $domref $attrname $value
    return
}
----
<1> We make sure that the text appended to the domain attribute is done
as a line. In case the previous line didn't have a new line in it,
we will add one.
This will prevent any problems where continuing on the same line
could be misinterpreted.

=== Class

The class command is used to define classes and specify their characteristics.

*****
+class+ _name_ _script_

+name+::
    The name of the class. A class name must be a valid ``C'' identifier.
+script+::
    A Tcl script containing invocations of the class definition commands
    to specify the details of the class configuration.

The `class` command defines a class named, _name_, and evaluates _script_
to configure the class.
Class definitions are open ended and extensible.
If the `class` command is invoked on a previously defined class,
then any additional configuration is added to the definition of the class.
*****

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<domain config commands>>=
proc class {name body} {
    variable DomainName ; # <1>

    if {[isEmptyRef [DomainElement findById Domain $DomainName Name $name]]} {# <2>
        DomainElement create Domain $DomainName Name $name
        Class create Domain $DomainName Name $name\
            Number [GenNumber $DomainName Class [list $DomainName]]
        ValueElement create Domain $DomainName Name $name
    }

    namespace upvar ClassDef ClassName ClassName ; # <3>
    set ClassName $name
    ConfigEvaluate [namespace current]::ClassDef $body

    return
}
----
<1> We have arranged for a namespace variable to hold the current
domain context.
This is a convenient way to pass the domain name to where it is needed
by the configuration commands.
<2> We allow the `class` command to be invoked multiple times with the
same name.
This makes extending class definitions (_e.g._ adding a state model to
a class) much easier.
<3> Provide the class name to the body of the class definition script.

[float]
==== Tests

ifdef::showtests[]
[source,tcl]
----
<<config command tests>>=
test class-1.0 {
    Define class with a bad name
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class @%x {}
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

=== Association

The +association+ command is used to define both simple and class based
associations depending upon arguments.
In the `association` command we use some syntax conventions to mirror
the UML graphical notation to make the clerical aspects of the
translation easier.

*****
`association` _name_  _?option value ...?_ _source_ _spec_ _target_ ?_script_?

`name`::
    The name of the association. Conventionally, relationships names are of the
    form *R<d>* where _<d>_ is one or more decimal digits but any
    non-empty string which does not start with a tilde (\~) can be used.
`option value ...`::
    Options to the `association` command are given as argument
    option / value pairs:
    Valid options and their values are:
    `-associator` _class_:::
    The `-associator` option defines the association to be
    *class based* and specifies _class_ as the association class.
`source`::
    The name of the class that defines the starting class for a forward
    traversal of the relationship.
`spec`::
    The specifier of the relationship conditionality and multiplicity.
    The _spec_ argument is one of the following strings.
    We allow two forms for some of the specifiers.
    The first form follows UML notation and the second form follows
    TclRAL notation which is patterned after regular expression notation.
        `1--1`:::
            The association is _one to one_.
        `0..1--1` or `?--1`:::
            The association is _at most one to one_.
        `0..1--0..1` or `?--?`:::
            The association is _at most one to at most one_.
        `1..*--1` or `+--1`:::
            The association is _one or more to one_.
        `0..*--1` or `*--1`:::
            The association is _zero or more to one_.
        `1..*--0..1` or `+--?`:::
            The association is _one or more to at most one_.
        `0..*--0..1` or `*--?`:::
            The association is _zero or more to at most one_.
        `1..*--1..*` or `+--+`:::
            The association is _one or more to one or more_.
        `0..*--1..*` or `*--+`:::
            The association is _zero or more to one or more_.
        `1..*--0..*` or `+--*`:::
            The association is _one or more to zero or more_.
        `0..*--0..*` or `*--*`:::
            The association is _zero or more to zero or more_.
`target`::
    The name of the class that defines the ending class for a forward
    traversal of the relationship.
`script`::
    An optional _script_ that is evaluated to define an assigner on the
    association.

The `association` command defines an association relationship between a
_source_ class and a _target_class_.
The forward direction of navigating the relationship is from _source_
to _target_.
The conditionality and multiplicity of the association is given by the
_spec_ argument.
A class based association is indicated by the `-associator` option.
The association command may have an optional _script_ argument that is
used to define an assigner on the association.
*****

In the command,
we are using the _spec_ string to encode several distinct pieces of information.
Each different association specifier implies the conditionality,
multiplicity and other properties of the association.
We encode those properties in data whose identifier is the _spec_ string
itself.

[source,tcl]
----
<<config data>>=
# Since we allow two different techniques to identify the association
# specifics, we will factor away the specification data from its name.
relvar create Config_AssocSpec {
    SpecName    string
    SpecID      string
} SpecName

relvar create Config_SpecDetail {
    SpecID              string
    NeedsAssociator     boolean
    ReflexiveAllowed    boolean
    ReferringCond       boolean
    ReferringMult       boolean
    ReferencedCond      boolean
    ReferencedMult      boolean
} SpecID

relvar association C1\
    Config_AssocSpec SpecID +\
    Config_SpecDetail SpecID 1

relvar eval {
    relvar insert Config_AssocSpec {
        SpecName    1--1
        SpecID      sp0
    } {
        SpecName    0..1--1
        SpecID      sp1
    } {
        SpecName    ?--1
        SpecID      sp1
    } {
        SpecName    0..1--0..1
        SpecID      sp2
    } {
        SpecName    ?--?
        SpecID      sp2
    } {
        SpecName    1..*--1
        SpecID      sp3
    } {
        SpecName    +--1
        SpecID      sp3
    } {
        SpecName    0..*--1
        SpecID      sp4
    } {
        SpecName    *--1
        SpecID      sp4
    } {
        SpecName    1..*--0..1
        SpecID      sp5
    } {
        SpecName    +--?
        SpecID      sp5
    } {
        SpecName    0..*--0..1
        SpecID      sp6
    } {
        SpecName    *--?
        SpecID      sp6
    } {
        SpecName    1..*--1..*
        SpecID      sp7
    } {
        SpecName    +--+
        SpecID      sp7
    } {
        SpecName    0..*--1..*
        SpecID      sp8
    } {
        SpecName    *--+
        SpecID      sp8
    } {
        SpecName    1..*--0..*
        SpecID      sp9
    } {
        SpecName    +--*
        SpecID      sp9
    } {
        SpecName    0..*--0..*
        SpecID      sp10
    } {
        SpecName    *--*
        SpecID      sp10
    }

    relvar insert Config_SpecDetail {
        SpecID sp0  NeedsAssociator false ReflexiveAllowed true
            ReferringCond false ReferringMult false
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp1 NeedsAssociator false ReflexiveAllowed false
            ReferringCond true ReferringMult false
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp2 NeedsAssociator true ReflexiveAllowed true
            ReferringCond true ReferringMult false
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp3 NeedsAssociator false ReflexiveAllowed true
            ReferringCond false ReferringMult true
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp4 NeedsAssociator false ReflexiveAllowed false
            ReferringCond true ReferringMult true
            ReferencedCond false ReferencedMult false
    } {
        SpecID sp5 NeedsAssociator true ReflexiveAllowed false
            ReferringCond false ReferringMult true
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp6 NeedsAssociator true ReflexiveAllowed true
            ReferringCond true ReferringMult true
            ReferencedCond true ReferencedMult false
    } {
        SpecID sp7 NeedsAssociator true ReflexiveAllowed true
            ReferringCond false ReferringMult true
            ReferencedCond false ReferencedMult true
    } {
        SpecID sp8 NeedsAssociator true ReflexiveAllowed false
            ReferringCond true ReferringMult true
            ReferencedCond false ReferencedMult true
    } {
        SpecID sp9 NeedsAssociator true ReflexiveAllowed false
            ReferringCond false ReferringMult true
            ReferencedCond true ReferencedMult true
    } {
        SpecID sp10 NeedsAssociator true ReflexiveAllowed true
            ReferringCond true ReferringMult true
            ReferencedCond true ReferencedMult true
    }
}
----

[float]
===== Implementation

Like most of the commands in the configuration language,
the bulk of the code is involved with populating the relvars
holding the essential data provided in the command arguments.
For the `association` command,
there is some argument parsing to determine whether the association
is simple or class based.
Then it is a matter of filling in the correct information based on the
type of the association.

(((micca,Config,association)))
[source,tcl]
----
<<domain config commands>>=
proc association {name args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME association
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    if {[llength $args] < 3} {
        tailcall DeclError ASSOC_OPTIONS $args
    }

    set associator {}
    set isstatic false
    set cmdargs $args
    while {1} {
        set arg [lindex $cmdargs 0]

        if {$arg eq "-associator"} {
            set associator [lindex $cmdargs 1]
            set cmdargs [lrange $cmdargs 2 end]
        } elseif {$arg eq "-static"} {
            set isstatic true
            set cmdargs [lrange $cmdargs 1 end]
        } elseif {$arg eq "-dynamic"} {
            set isstatic false
            set cmdargs [lrange $cmdargs 1 end]
        } elseif {$arg eq "--"} {
            break
            set cmdargs [lrange $cmdargs 1 end]
        } else {
            break
        }
    }
    if {[llength $cmdargs] < 3 || [llength $cmdargs] > 4} {
        tailcall DeclError ASSOC_OPTIONS $args
    }
    lassign $cmdargs source spec target script

    # Obtain references to the domain name
    variable DomainName

    <<association: check arguments>>

    # Many relvars have tuples with the same heading, so we construct it
    # once here.
    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]
    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple

    # Populate the data for a Relationship and Association since that
    # is what this command defines.
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Association create {*}$reltuple IsStatic $isstatic

    # Set up tuple values for later use.
    set sourcetuple [list\
        Domain          $DomainName\
        Class           $source\
        Relationship    $name\
        Role            source\
    ]
    set targettuple [list\
        Domain          $DomainName\
        Class           $target\
        Relationship    $name\
        Role            target\
    ]

    # Populate the type of association we are dealing with.
    if {$associator eq {}} {
        <<association: populate simple association>>
    } else {
        <<association: populate class based association>>
    }

    if {$script ne {}} {
        namespace upvar ClassDef ClassName ClassName
        set ClassName $name

        namespace upvar AssignerDef IdClassName IdClassName
        set IdClassName {}

        ConfigEvaluate [namespace current]::AssignerDef $script
    }

    return
}
----

(((error code,TILDE_NAME)))
(((error code,ASSOC_OPTIONS)))
[source,tcl]
----
<<error code formats>>=
TILDE_NAME {names beginning with the tilde character are not allowed\
    in this context, "%s"}
ASSOC_OPTIONS {association options error, expected\
    "?-associator <class> -static -dynamic? source spec target ?script?",\
    got "%s"}
----

Here we use the data that we supplied above to make sure the
`spec` association specifier and the supplied arguments make sense together.
Certain forms of reflexiveness are not allowed and certain specifiers
imply that you must define a class based association.
Such rules are easier to express in data rather than long sequences
of checking code.

[source,tcl]
----
<<association: check arguments>>=
set csd [pipe {
    relvar restrictone ::micca::@Config@::Config_AssocSpec SpecName $spec |
    relation semijoin ~ [relvar set ::micca::@Config@::Config_SpecDetail]
}]
if {[relation isempty $csd]} {
    tailcall DeclError BAD_RELATIONSHIP_SPEC $spec
}
relation assign $csd
if {$NeedsAssociator && $associator eq {}} {
    tailcall DeclError NEED_ASSOCIATOR $spec
}
if {$source eq $target && !$ReflexiveAllowed} {
    tailcall DeclError REFLEXIVE_NOT_ALLOWED $spec
}
----

(((error code,BAD_RELATIONSHIP_SPEC)))
(((error code,NEED_ASSOCIATOR)))
(((error code, REFLEXIVE_NOT_ALLOWED)))
[source,tcl]
----
<<error code formats>>=
BAD_RELATIONSHIP_SPEC  {bad relationship specifier, "%s"}
NEED_ASSOCIATOR {relationship of type, "%s", requires an associative class}
REFLEXIVE_NOT_ALLOWED   {associations of type, "%s", cannot be reflexive}
----

For simple associations,
the `association` command arguments supply what we need and we
perform a series of inserts into the platform data model.

[source,tcl]
----
<<association: populate simple association>>=

SimpleAssociation create {*}$reltuple

SimpleReferringClass create {*}$sourcetuple\
        Conditionality  $ReferringCond\
        Multiplicity    $ReferringMult
ClassRole create {*}$sourcetuple

set poptuple [list\
    Domain          $DomainName\
    Class           $source\
    Name            $name\
]
AssociationReference create {*}$poptuple
Reference create {*}$poptuple
PopulatedComponent create {*}$poptuple
ClassComponent create {*}$poptuple

SimpleReferencedClass create {*}$targettuple
DestinationClass create {*}$targettuple
ClassRole create {*}$targettuple

set gentuple [list\
    Domain          $DomainName\
    Class           $target\
    Name            ${name}__BACK\
]
ComplementaryReference create {*}$gentuple
BackwardReference create {*}$gentuple Relationship $name
if {!$ReferringMult} {
    SingularReference create {*}$gentuple
} elseif {$isstatic} {
    ArrayReference create {*}$gentuple
} else {
    LinkReference create {*}$gentuple
    set conttuple [list\
        Domain      $DomainName\
        Class       $source\
        Name        ${name}__BLINKS\
    ]
    LinkContainer create {*}$conttuple LinkClass $target LinkComp ${name}__BACK
    GeneratedComponent create {*}$conttuple
    ClassComponent create {*}$conttuple
}
GeneratedComponent create {*}$gentuple
ClassComponent create {*}$gentuple
----

For class based associations we have a few more class instances to create
as we populate that branch of the `micca` platform model.

[source,tcl]
----
<<association: populate class based association>>=
ClassBasedAssociation create {*}$reltuple

SourceClass create {*}$sourcetuple\
        Conditionality  $ReferringCond\
        Multiplicity    $ReferringMult
ClassRole create {*}$sourcetuple

set srccomp [list\
    Domain          $DomainName\
    Class           $source\
    Name            ${name}__FORW\
]
ComplementaryReference create {*}$srccomp
ForwardReference create {*}$srccomp Relationship $name
if {!$ReferencedMult} {
    SingularReference create {*}$srccomp
} elseif {$isstatic} {
    ArrayReference create {*}$srccomp
} else {
    LinkReference create {*}$srccomp
    set conttuple [list\
        Domain      $DomainName\
        Class       $associator\
        Name        ${name}__FLINKS\
    ]
    LinkContainer create {*}$conttuple LinkClass $source LinkComp ${name}__FORW
    GeneratedComponent create {*}$conttuple
    ClassComponent create {*}$conttuple
}
GeneratedComponent create {*}$srccomp
ClassComponent create {*}$srccomp

TargetClass create {*}$targettuple\
    Conditionality  $ReferencedCond\
    Multiplicity    $ReferencedMult
DestinationClass create {*}$targettuple
ClassRole create {*}$targettuple

set trgcomp [list\
    Domain          $DomainName\
    Class           $target\
    Name            ${name}__BACK\
]
ComplementaryReference create {*}$trgcomp
BackwardReference create {*}$trgcomp Relationship $name
if {!$ReferringMult} {
    SingularReference create {*}$trgcomp
} elseif {$isstatic} {
    ArrayReference create {*}$trgcomp
} else {
    LinkReference create {*}$trgcomp
    set conttuple [list\
        Domain      $DomainName\
        Class       $associator\
        Name        ${name}__BLINKS\
    ]
    LinkContainer create {*}$conttuple LinkClass $target LinkComp ${name}__BACK
    GeneratedComponent create {*}$conttuple
    ClassComponent create {*}$conttuple
}
GeneratedComponent create {*}$trgcomp
ClassComponent create {*}$trgcomp

set assoctuple [list\
    Domain          $DomainName\
    Class           $associator\
    Relationship    $name\
    Role            associator\
]
set assoccomp [list\
    Domain          $DomainName\
    Class           $associator\
    Name            $name\
]

AssociatorClass create {*}$assoctuple
ClassRole create {*}$assoctuple
AssociatorReference create {*}$assoccomp
Reference create {*}$assoccomp
PopulatedComponent create {*}$assoccomp
ClassComponent create {*}$assoccomp
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test association-1.0 {
    Define simple association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class x {
                attribute a1 {char[32]}
                attribute a2 {char[32]}
            }
            class y {
                attribute a1 {char[32]}
            }
            association R10 y 1--1 x
        }
    }
    log::debug [formatMiccaClass SimpleAssociation]
    log::debug [formatMiccaClass SimpleReferringClass]
    log::debug [formatMiccaClass SimpleReferencedClass]
    testConditions\
        {[refMultiplicity [SimpleAssociation findAll]] == 1}\
        {[refMultiplicity [SimpleReferringClass findAll]] == 1}\
        {[refMultiplicity [SimpleReferencedClass findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test association-2.0 {
    Define class based association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class a {
                attribute a1 {char[32]}
            }
            class e {
                attribute a1 {char[32]}
                attribute a2 {char[32]}
            }
            class f {
                attribute a1 {char[32]}
            }
            association R11 -associator a f 1..*--1..* e
        }
    }
    log::debug [formatMiccaClass AssociatorClass]
    log::debug [formatMiccaClass AssociatorReference]
    log::debug [formatMiccaClass SourceClass]
    log::debug [formatMiccaClass TargetClass]
    testConditions\
        {[refMultiplicity [AssociatorClass findAll]] == 1}\
        {[refMultiplicity [AssociatorReference findAll]] == 1}\
        {[refMultiplicity [SourceClass findAll]] == 1}\
        {[refMultiplicity [TargetClass findAll]] == 1}
} -result {1}
----
endif::showtests[]

=== Generalization

Defining a generalization relationship is quite a bit simpler than
the effort we just saw in defining associations.
For generalizations,
it is necessary to specify the superclass and the set of subclasses.
The only complexity is that `micca` allows two choices for how to
store subclasses of a generalization.
The simplest is to use references to store the relationship pointers
in much the same manner as used for associations.
Because of the nature of a generalization relationship,
the other possibility is to store the subclass as a discriminated union.
The alternatives are specified as options to the generalization command.

*****
`generalization` _name_ _?-union | -reference?_ _super_ _sub1_ _sub2_ _?...?_

`name`::
    The name of the generalization. Conventionally, relationships names are of
    the form *R<d>* where _<d>_ is one or more decimal digits but any non-empty
    string can be used.
`-union | -reference`::
    An option to specify if subclasses of the generalization are to be
    held as a discriminated union in the same structure as the superclass
    or held in separate storage having the relationship navigation implemented
    using reference pointers.
    If no option is given, the `-reference` is assumed.
`super`::
    The name of the class that serves as the superclass of the generalization.
`subN`::
    The names of the classes that serve as the subclasses of the generalization.
    You must specify at least two subclasses to define a generalization.
*****

[float]
==== Implementation

(((micca,Config,generalization)))
[source,tcl]
----
<<domain config commands>>=
proc generalization {name args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME generalization
    }
    if {[string index $name 0] eq "~"} {
        tailcall DeclError TILDE_NAME $name
    }

    set type reference
    while {1} {
        set args [lassign $args arg]

        if {$arg eq "-reference"} {
            set type reference
        } elseif {$arg eq "-union"} {
            set type union
        } else {
            set super $arg
            break
        }
    }

    if {[llength $args] < 2} {
        tailcall DeclError TOO_FEW_SUBCLASSES [llength $args]
    }
    if {$super in $args} {
        tailcall DeclError SUPER_AS_SUBCLASS $super [join $args {, }]
    }
    if {[llength [lsort -unique $args]] != [llength $args]} {
        tailcall DeclError DUPLICATE_SUBCLASS $args
    }

    variable DomainName

    set reltuple [list\
        Domain  $DomainName\
        Name $name\
    ]

    CheckDuplicate DomainElement {*}$reltuple
    DomainElement create {*}$reltuple
    Relationship create {*}$reltuple\
        Number [GenNumber $DomainName Relationship [list $DomainName]]
    Generalization create {*}$reltuple

    set supertuple [list\
        Domain          $DomainName\
        Class           $super\
        Relationship    $name\
        Role            target\
    ]
    set subtuple [dict create\
        Domain          $DomainName\
        Relationship    $name\
        Role            source\
    ]
    set reftuple [list\
        Domain          $DomainName\
        Class           $super\
        Name            $name
    ]
    if {$type eq "reference"} {
        ReferenceGeneralization create {*}$reltuple
        ReferencedSuperclass create {*}$supertuple
        SubclassReference create {*}$reftuple
        GeneratedComponent create {*}$reftuple
        ClassComponent create {*}$reftuple

        foreach sub $args {
            dict set subtuple Class $sub
            ReferringSubclass create {*}$subtuple
        }
    } elseif {$type eq "union"} {
        UnionGeneralization create {*}$reltuple
        UnionSuperclass create {*}$supertuple
        SubclassContainer create {*}$reftuple
        GeneratedComponent create {*}$reftuple
        ClassComponent create {*}$reftuple

        foreach sub $args {
            set usubRef [UnionSubclass findWhere {$Domain eq $DomainName &&\
                $Class eq $sub}] ; # <1>
            if {[isNotEmptyRef $usubRef]} {
                tailcall DeclError UNION_SUBCLASS_EXISTS $sub\
                    [readAttribute $usubRef Relationship]
            }
            dict set subtuple Class $sub
            UnionSubclass create {*}$subtuple
        }
    }
    Superclass create {*}$supertuple
    ClassRole create {*}$supertuple

    foreach sub $args {
        dict set subtuple Class $sub
        Subclass create {*}$subtuple
        ClassRole create {*}$subtuple
        dict set reftuple Class $sub
        SuperclassReference create {*}$reftuple
        Reference create {*}$reftuple
        PopulatedComponent create {*}$reftuple
        ClassComponent create {*}$reftuple
    }

    return
}
----
<1> A union subclass cannot be a subclass of two independent generalizations.
This is just another way of saying that a component of a ``C'' structure
cannot be a component of a different ``C'' structure at the same time.
If a subclass is to be a subclass in multiple generalizations,
only one can be a union subclass and the others must be reference subclasses.

(((error code,TOO_FEW_SUBCLASSES)))
(((error code,SUPER_AS_SUBCLASS)))
(((error code,DUPLICATE_SUBCLASS)))
(((error code,UNION_SUBCLASS_EXISTS)))
[source,tcl]
----
<<error code formats>>=
TOO_FEW_SUBCLASSES  {at least 2 subclasses must be specified, got %d}
SUPER_AS_SUBCLASS   {super class, "%s", cannot be included in subclasses, "%s"}
DUPLICATE_SUBCLASS  {subclass set contains a duplicate subclass name, "%s"}
UNION_SUBCLASS_EXISTS {subclass, "%s", is already a union subclass for\
                    relationship, "%s"}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-1.0 {
    Define reference generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int
            }
            generalization R1 -reference super sub1 sub2
        }
    }
    log::debug [formatMiccaClass ReferenceGeneralization]
    log::debug [formatMiccaClass ReferencedSuperclass]
    log::debug [formatMiccaClass ReferringSubclass]
    testConditions\
        {[refMultiplicity [ReferenceGeneralization findAll]] == 1}\
        {[refMultiplicity [ReferencedSuperclass findAll]] == 1}\
        {[refMultiplicity [ReferringSubclass findAll]] == 2}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test generalization-2.0 {
    Define union generalization
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class usuper {
                attribute sid int
            }
            class usub1 {
                attribute sid int
            }
            class usub2 {
                attribute sid int
            }
            generalization R2 -union usuper usub1 usub2
        }
    }
    log::debug [formatMiccaClass UnionGeneralization]
    log::debug [formatMiccaClass UnionSuperclass]
    log::debug [formatMiccaClass UnionSubclass]
    log::debug [formatMiccaClass SubclassContainer]
    testConditions\
        {[refMultiplicity [UnionGeneralization findAll]] == 1}\
        {[refMultiplicity [UnionSuperclass findAll]] == 1}\
        {[refMultiplicity [UnionSubclass findAll]] == 2}\
        {[refMultiplicity [SubclassContainer findAll]] == 1}
} -result {1}
----
endif::showtests[]

==== Union Subclass Semantic Checks

The choice to store subclass instances as a union within the class
structure of its superclass has a number of advantages from an implementation
point of view.
But the choice also places restrictions on how subclasses may be treated.
The union subclass is less general than the reference subclass and so
we need to restrict the uses of union subclasses.
In most simple situations where union subclasses are most frequently used,
these restrictions do not apply.
But there are situations where the inclusion of the subclass as part of the
structure of the superclass instance means a certain configuration cannot
be supported.
We have already seen that a union subclass cannot be a subclass of two
independent generalizations.
This is just another way of saying that a component of a ``C'' structure
cannot be a component of a different ``C'' structure at the same time.
If a subclass is to be a subclass in multiple generalizations,
only one can be a union subclass and the others must be reference subclasses.

Here we check the following:

* Creation events cannot be sent to union subclasses.
There is no independent storage for union subclasses as it is contained
in the storage allocated to the superclass.

[source,c]
----
<<domain: union subclass semantics>>=
set unioncreates [pipe {
    UnionSubclass findWhere {$Domain eq $name} |
    findRelated % R47 R40 R41 ~R51 R50 ~R56
} {} |%]
forAllRefs unioncreate $unioncreates {
    assignAttribute $unioncreate
    log::error "In domain, $Domain, union subclass, $Model,\
        accepts creation events: this is not allowed for union subclasses"
    incr errcount
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test union-subclasses-1.0 {
    Union subclass in multiple generalizations
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super1 {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int
            }
            class super2 {
                attribute sid int
            }
            class sub3 {
                attribute sid int
            }
            generalization R1 -union super1 sub1 sub2
            generalization R2 -union super2 sub1 sub3
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test union-subclasses-2.0 {
    Union subclass with creation state
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class super1 {
                attribute sid int
            }
            class sub1 {
                attribute sid int
            }
            class sub2 {
                attribute sid int

                statemodel {
                    state s1 {} {
                    }

                    transition @ - e1 -> s1
                }
            }
            generalization R1 -union super1 sub1 sub2
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

=== Type Alias

*****
`typealias` _name_ _definition_

`name`::
    The name of the type alias.
`definition`::
    A ``C'' typename.

The `typealias` command defines an alias _name_ for a ``C'' typename given
by, _definition_.
Type alias helps map model level type information to ``C'' `typedef` statements
that are included in the generated code.
*****

[float]
==== Implementation

(((micca,Config,typealias)))
[source,tcl]
----
<<domain config commands>>=
proc typealias {aliasname typename} {
    variable DomainName
    TypeAlias create Domain $DomainName TypeName $aliasname\
        TypeDefinition $typename

    return
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typealias-1.0 {
    Define a type alias
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            typealias rawbyte uint8_t
        }
    }
    log::debug [formatMiccaClass TypeAlias]
    readMiccaAttribute TypeAlias TypeDefinition Domain foo TypeName rawbyte
} -result {uint8_t}
----
endif::showtests[]

=== Domain Operation

The `domainop` command is used to define domain operations.
The set of domain operations defined for a domain constitute the
external callable interface to the domain.
Typically, domain operations are defined to allow other domains
to access major services of the domain.

*****
`domainop` _rettype_ _name_ _parameters_ _body_ ?_comment_?

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the domain operation.
`name`::
    The name of the domain operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the domain operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
`comment`::
    An optional string that is passed along by the code generated to the
    generated header file.
*****

[float]
==== Implementation

(((micca,Config,domainop)))
[source,tcl]
----
<<domain config commands>>=
proc domainop {rettype name parameters body {comment {}}} {
    variable DomainName

    DomainOperation create\
        Domain $DomainName\
        Name $name\
        Body $body\
        ReturnDataType $rettype\
        Comment [string trim $comment]

    set paramtuple [dict create Domain $DomainName Operation $name]
    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName DomainOperationParameter\
                [list $DomainName $name]]
        DomainOperationParameter create {*}$paramtuple
    }

    return
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test domainop-1.0 {
    Define a domain operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            domainop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }
        }
    }
    log::debug [formatMiccaClass DomainOperation]
    log::debug [formatMiccaClass DomainOperationParameter]
    testConditions\
        {[refMultiplicity [DomainOperation findAll]] == 1}\
        {[refMultiplicity [DomainOperationParameter findAll]] == 2}\
} -result {1}
----
endif::showtests[]

=== External Operation

The `externalop` command is used to define external operations.
External operations are functionality the domain has delegated to
an entity outside of the domain itself.

*****
`externalop` _rettype_ _name_ _parameters_ _body_ ?_comment_?

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the external operation.
`name`::
    The name of the external operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the external operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing code.
    Normally the external operation code is _not_ included in the generated
    output for the domain.
    However, the code generate can be requested to generate the external
    operation code.
    This simplifies certain test situation and makes it easier to generate
    an executable for the domain by resolving the external operations
    via the code generateor.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
`comment`::
    An optional string that is passed along by the code generated to the
    generated header file.
*****

[float]
==== Implementation

(((micca,Config,domainop)))
[source,tcl]
----
<<domain config commands>>=
proc externalop {rettype name parameters {body {}} {comment {}}} {
    variable DomainName

    ExternalOperation create\
        Domain $DomainName\
        Name $name\
        Body $body\
        ReturnDataType $rettype\
        Comment [string trim $comment]

    set paramtuple [dict create Domain $DomainName Operation $name]
    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName ExternalOperationParameter\
                [list $DomainName $name]]
        ExternalOperationParameter create {*}$paramtuple
    }

    return
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test externalop-1.0 {
    Define a external operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            externalop void temp {t int}
            externalop void color {a int b {char *const}} {
                printf("a = %d, b = %s", a, b) ;
            }
        }
    }
    log::debug [formatMiccaClass ExternalOperation]
    log::debug [formatMiccaClass ExternalOperationParameter]
    testConditions\
        {[refMultiplicity [ExternalOperation findAll]] == 2}\
        {[refMultiplicity [ExternalOperationParameter findAll]] == 3}\
} -result {1}
----
endif::showtests[]

== Defining Class Components

Since there are several aspects of classes,
the +class+ command takes a _script_ argument which should
invoke the commands we discuss in this section.
Following our pattern,
we define a namespace where the class body script is evaluated.

[source,tcl]
----
<<class config namespace layout>>=
namespace eval ClassDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class config commands>>

    <<state model config namespace layout>>
}
----

=== Attribute

Within a class definition,
the `attribute` command specifies the attributes of the class.
In this context,
attributes are a slightly different concept than the attributes
seen on a class diagram.
As part of the translation process,
some attributes found on the XUML class diagram are elided from
the implementation.
For example,
attributes that are used solely for referential or identifying purposes
need not be included as attributes in the implementation.
This is because the translation is using the address of a class
instance as an architecturally supplied identifier and in implementing
relationship traversal.
So the attributes defined here are descriptive in nature and define
the logical parameters of the class rather than the structural aspects
of the class.

*****
`attribute` _name_ _type_ ? _-option_ _value_ ... ?

? `-default` _value_ `-dependent` _formula_?

`name`::
    The name of the attribute. Attributes names may not be the empty string.
`type`::
    The type of the attribute. The _type_ may be any valid ``C'' type name.
-option / value::
    Valid attribute command options are:
    `-default` _value_;;
        If specified, the `-default` option specifies a default value for the
        attribute. If no value is supplied when a class instance is created
        or populated, then the default value is used.
    `-dependent` _formula_;;
        If the `-dependent` option is specified, then the attribute is
        considered to be mathematically dependent.
        Such attributes may only be read and the value of the attribute
        will be the return value of the ``C'' code contained in
        _formula_. The _formula_ argument is a string containing
        ``C'' code that is invoked when the attribute is read.
        If the dimension of the attribute is 0 (_i.e._ the attribute
        is a single value of a given data type),
        the code will be invoked with a single argument called, `self`,
        which is an instance reference to the class containing the
        attribute.
        If the dimention of the attribute is greater than zero,
        the code is invoked with as `self` argument and two more arguments
        which are a pointer to where the result is to be placed and
        the number of elements in the result.
        It is not allowed to specify the `-dependent` option and
        the `-default` option for the same attribute.
*****

The implementation of the `attribute` command simply creates tuples
in the relvars to hold the attribute characteristics.

[float]
==== Implementation

(((micca,Config,attribute)))
[source,tcl]
----
<<class config commands>>=
proc attribute {name type args} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME attribute
    }
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    set options [dict create]
    while {[llength $args] != 0} {
        set args [lassign $args opt value]
        if {$opt in {-default -dependent}} {
            dict set options $opt $value
        } else {
            tailcall DeclError UNKNOWN_OPTION attribute $opt
        }
    }
    if {[dict exists $options -default] && [dict exists $options -dependent]} {
        error "for attribute, $name, \"-default\" and \"-dependent\" options\
            may not be specified for the same attribute"
    }

    set attrtuple [list\
        Domain      $DomainName\
        Class       $ClassName\
        Name        $name\
    ]
    if {[dict exists $options -dependent]} {
        DependentAttribute create {*}$attrtuple\
            Formula [dict get $options -dependent]
    } else {
        IndependentAttribute create {*}$attrtuple
    }
    Attribute create {*}$attrtuple DataType $type
    PopulatedComponent create {*}$attrtuple
    ClassComponent create {*}$attrtuple

    if {[dict exists $options -default]} {
        DefaultValue create\
            Domain      $DomainName\
            Class       $ClassName\
            Attribute   $name\
            Value       [dict get $options -default]
    }
}
----

(((error code,ARG_FORMAT)))
[source,tcl]
----
<<error code formats>>=
ARG_FORMAT      {options and values must come in pairs, got "%s"}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test attribute-1.0 {
    Define class with attributes
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 char
                attribute a2 int -default 20
            }
            class c2 {
                attribute b1 uint8_t
                attribute b2 float
            }
        }
    }
    log::debug [formatMiccaClass IndependentAttribute]
    log::debug [formatMiccaClass DefaultValue]
    testConditions\
        {[refMultiplicity [Attribute findAll]] == 4}\
        {[refMultiplicity [DefaultValue findAll]] == 1}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test attribute-1.1 {
    Define class with dependent attribute
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute height int
                attribute width int
                attribute area int -dependent {
                    return self->height * self->width ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Attribute]
    log::debug [formatMiccaClass DependentAttribute]
    testConditions\
        {[refMultiplicity [Attribute findAll]] == 3}\
        {[refMultiplicity [DependentAttribute findAll]] == 1}
} -result {1}
----
endif::showtests[]

=== Polymorphic Events

Polymorphic events are defined in a superclass and when dispatched
to the superclass are mapped into events in the subclass state models.
The `polymorphic` commands defines a polymorphic event and optionally
the signature of event parameters that the event carries.

*****
`polymorphic` _event_ ?_argname argtype_ ...?

`event`::
    The name of an event that will be deemed polymorphic across
    any generalization relationships in which the class participates.

`argname argtype ...`::
    The argument signature of the event. Arguments must be given in
    name / type pairs. Argument names must be ``C'' identifiers and
    argument types must be ``C'' type names.

The `polymorphic` command defines _event_ as being polymorphic with
optional event arguments given by _argname_ / _argtype_ pairs.
Note that the signature of event arguments of a polymorphic event
is inherited down the generalization hierarchy.
If when the polymorphic event is mapped onto a local state machine
any event parameters required by the state must have been defined
using this command.
Unlike a non-polymorphic event which will assume the parameter signature
of a state unless otherwise defined,
polymorphic event parameters must be defined in this command.
*****


[float]
==== Implementation

For a polymorphic event,
we simply create instances of the PolymorphicEvent class and its
related classes.
At the end of a domain configuration script we will find it necessary to
rationalize the polymorphic events and the transition events defined
locally in a state model.

(((micca,Config,polymorphic)))
[source,tcl]
----
<<class config commands>>=
proc polymorphic {name args} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    set psigid [expr {[llength $args] != 0 ?\
            [FindParameterSignature $args] : {}}]

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $name\
    ]
    Event create {*}$eventtuple PSigID $psigid Number -1
    DeferredEvent create {*}$eventtuple
    PolymorphicEvent create {*}$eventtuple

    return
}
----

==== Propagating Polymorphic Events

[[domain-propagate-polymorphic-events]]
<<post-config-domain,Previously>>,
we indicated that polymorphic event rules require that we perform
some other processing once the configuration script for a domain
has been executed.
Now we are prepared to show that processing.
It will be helpful to refer to the Event subsystem of the platform model
above to follow the description.

The `polymorphic` command above inserts the argument event names into the
model classes simply as a deferred event that is polymorphic.
We must resolve two issues.

. For classes that are super classes for generalizations,
we must have corresponding instances of *Deferral Path* for each of the
generalization hierarchies.
. For classes that are sub classes,
they either consume the polymorphic event in a state model or
it continues to be inherited by any sub classes further down the
generalization hierarchy.

To solve the first issue we know that
relationship, *R86*, specifies how a polymorphic event may be propagated along
multiple generalizations when it is signaled to a given superclass.
After the configuration script has been executed,
we will have all the *Superclass* instances and all the *Deferred Event*
instances and can now make up the correlation between them.

Starting with the *Polymorphic Event* class we can navigate *R81* to
find the corresponding *Deferred Event* and then join to the *Superclass*.
This gives the set of paths along which the polymorphic event must
be propagated.

[source,tcl]
----
<<domain: propagate polymorphic events>>=
# Create Deferral Path instances corresponding to polymorphic events

set paths [pipe {
    PolymorphicEvent findWhere {$Domain eq $name} |
    findRelated ~ R81 |
    deRef ~ Domain Model Event |
    relation join ~ [deRef [Superclass findAll]]\
        -using {Domain Domain Model Class}
}]

foreach path [relation body $paths] {
    DeferralPath create {*}$path
}
----

To solve the second issue,
we must walk the generalization hierarchy and determine if events
are being consummed or inherited down the hierarchy.
We want to start the walk only on the ultimate super classes,
_i.e._ those super classes that are 'not' themselves the sub class of
some other generalization.

[source,tcl]
----
<<domain: propagate polymorphic events>>=
forAllRefs super [FindUltimateSuperclasses $name] {
    PropagatePolyEvents $super
}
----

After all the polymorphic events have been rearranged,
we can now number the events.
There is one continuous set of event numbers for any class,
but we want them separated into two groups.
Each group will be sequentially ordered so that the event
number can be used as an index by the run time code.
We group Transitioning Events first followed by Deferred Events.

[source,tcl]
----
<<domain: propagate polymorphic events>>=
set trevents [pipe {
    TransitioningEvent findAll |
    deRef ~ |
    relation tag ~ Number -ascending Event -within {Domain Model}
}]
# puts [relformat $trevents trevents]

set trcounts [relation summarizeby $trevents {Domain Model} evts\
        EventCount int {[relation cardinality $evts]}]
# puts [relformat $trcounts trcounts]

set dfevents [pipe {
    DeferredEvent findAll |
    deRef ~ |
    relation tag ~ DfNumber -ascending Event -within {Domain Model} |
    ralutil::rvajoin ~ $trcounts TEvents |
    relation extend ~ dftup Number int {
        [relation isempty [tuple extract $dftup TEvents]] ?\
        [tuple extract $dftup DfNumber] :\
        [tuple extract $dftup DfNumber] +\
        [relation extract [tuple extract $dftup TEvents] EventCount]} |
    relation eliminate ~ DfNumber TEvents
}]
# puts [relformat $dfevents dfevents]

Event update [relation union $trevents $dfevents]
# puts [relformat $::micca::Event Event]
----

So we find all *Superclass* instances that have no corresponding
*Subclass* role and propagate any polymorphic events down the generalization
hierarchy.

[source,tcl]
----
<<helper commands>>=
proc FindUltimateSuperclasses {domain} {
    set subs [Subclass findWhere {$Domain eq $domain}]
    set supers [Superclass findWhere {$Domain eq $domain}]
    return [pipe {
        relation semiminus [deRef $subs] [deRef $supers]\
            -using {Domain Domain Class Class} |
        ::rosea::Helpers::ToRef ::micca::Superclass ~
    }] ; # <1>
}
----
<1> This is where a little relational algebra can go a long way.
The `semiminus` command finds all the tuples that are *not* related.
In this case we find the Superclass instances that do *not* have a
correspondence to a Subclass instance.
The `semiminus` operation is done only across the same domain and
class, _i.e._ without respect to any relationship.
This yields the Superclass instances that are *not* Subclass
instances of any relationship.

The problem we are trying to solve in the propagation of polymorphic events
arises from the way in which we attempt to minimize the amount
of input from the user when specifying the events.
Recall that the `polymorphic` command simply inserts instances into the
*Polymorphic Event* class (and corresponding instances in *Deferred Event*
and *Event* classes).
Events found when defining a state model are simply created as instances of
the *Local Event* class (and again the corresponding *Transitioning Event* and
*Event* instances).
At the end of the configuration process we can now deduce which events
were inherited down the generalization hierarchy and which were truly
local events.

For sub classes that are leafs of generalization hierarchy,
polymorphic events inherited from the super class are migrated to
be *Mapped Events*.
For sub classes that are intermediate in the hierarchy,
polymorhphic events are migrated to instances of *Inherited Event*.
Both *Inherited Event* and *Mapped Event* are types of *NonLocal Event*
and *R85* insures that they affect only *Subclass* instances.

There are two other twists to be accounted.
It is possible for a mid-level class to consume an inherited polymorphic
event in a state transition.
In that case, the event is no longer available to any subclasses of
the consuming class.
We want to detect if a user mistakenly used an event by the same name
in a subclass state model.
Second,
inherited polymorphic events may not be explicitly consumed in a leaf
subclass.
In this case, the event is subject to the default transition rule for
the state model.
However, we want to warn the user of such events as it may indicate
a problem in specifying the state model (_e.g._ a polymorphic event was
added to a superclass and not accounted for in the subclasses).

The `PropagatePolyEvents` procedure below accomplishes this reclassification
operation.
By doing it this way,
we do not burden the user with all the subtle characteristics
of polymorphic events.
We need only specify which events are polymorphic and which events
cause a state model transition and then we can deduce the intent
to inherit down the generalization hierarchy.
Of course, what is unburdened from the user will be placed upon the
code and in this case there are some subtle twists and turns.

The `PropagatePolyEvents` procedure takes a singular instance reference to a
*Superclass* and tracks the polymorphic event inheritance down the hierarchy.

[[propagate-polyevents,propagate polymorphic events]]
(((micca,Helpers,PropagatePolyEvents)))
[source,tcl]
----
<<config commands>>=
proc PropagatePolyEvents {super} {
    variable errcount
    # Starting at the superclass, find all the subclasses along the
    # generalization.
    set subs [instop $super findSubclasses]

    # Find the events that are deferred by the superclass. These could be
    # either polymorphic events defined in the superclass or inherited events
    # from another generalization.
    set defrdevents [findRelated $super R86 R80]

    # Set up some variables with the superclass attribute values.
    assignAttribute $super {Domain supDomain} {Class supClass}\
        {Relationship supRelationship}

    # Iterate over each subclass of the generalization.
    forAllRefs sub $subs {
        assignAttribute $sub {Domain subDomain} {Class subClass}\
            {Relationship subRelationship} {Role subRole}

        # We need to know if this subclass is also a superclass for another
        # generalization. We find that out by querying the ClassRole for all
        # the other relationships the subclass participates in and then
        # filtering those where it serves as a Superclass.
        set multigens [Superclass findWhere {$Domain eq $subDomain &&\
                $Class eq $subClass && $Relationship ne $subRelationship}]

        # Iterate over the deferred events
        forAllRefs defrdevent $defrdevents {
            # We need the event name and argument signature
            assignAttribute $defrdevent {Event event} {PSigID psigid}

            # Check if the event already exists
            set evt [Event findById Domain $subDomain Model $subClass\
                    Event $event]
            if {[isEmptyRef $evt]} {
                <<PropagatePolyEvents: inherit missing deferred event>>
            } else {
                <<PropagatePolyEvents: resolve found deferred event>>
            }
        }
        # Recursively descend any generalization hierarchies repeating the
        # process for them.
        forAllRefs multigen $multigens {
            PropagatePolyEvents $multigen
        }
    }
}
----

If an event has been deferred to a subclass,
then we need to know if a given subclass is a leaf subclass in the
generalization hierarchy or if it is part of a repeated generalization.
A leaf subclass has no generalizations for which it is the superclass.
This tells us if we must consume any inherited events or if they will
be allowed to be inherited further down the hierarchy.
Subclasses that are part of a repeated generation will have
instances of *Superclass* to show their role in that generalization.

[source,tcl]
----
<<PropagatePolyEvents: inherit missing deferred event>>=
if {[isEmptyRef $multigens]} {
    <<PropagatePolyEvents: leaf missing deferred event>>
} else {
    <<PropagatePolyEvents: non-leaf missing deferred event>>
}
----

If an event has been deferred to a leaf subclass and there is no
corresponding defined event for the leaf subclass,
then it must be that the event was never found in a transition statement
or declared in the subclass.
We create a new Mapped Event for it, but also issue a warning.

From the Events subsystem of the platform model,
we can see that creating a Mapped Event requires creating a number of
other related class instances.

[source,tcl]
----
<<PropagatePolyEvents: leaf missing deferred event>>=
Event create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    PSigID $psigid\
    Number -1
TransitioningEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event
MappedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    ParentModel $supClass
NonLocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole

<<PropagatePolyEvents: warn of missing deferred event>>
----

When we warn about the fact that a deferred event was not explicitly
consumed in a state model, we look up the default transition so that
we can say what will happen if the event is ever dispatched to the
subclass.
The analyst will then have to decide if that is acceptable behavior.

[source,tcl]
----
<<PropagatePolyEvents: warn of missing deferred event>>=
set trule [findRelated $sub R40 R41 ~R51 R50 R59]
switch -exact -- [readAttribute $trule Name] {
    IG {
        set phrase "ignoring the event"
    }
    CH {
        set phrase "a system error"
    }
    default {
        set phrase "unknown behavior"
    }
}

log::warn "In domain, \"$subDomain\", class, \"$subClass\", event, \"$event\"\
    is polymorphic across, \"$subRelationship\",\
    and was not consumed in the state model: signalling $event to\
    $subClass or its related superclasses will result in $phrase"
----

When an event is deferred to a subclass that is subject to repeated
generalization,
then the event is inherited down the generalization hierarchy.
Again, creating a Deferred Event requires creating a number of other
class instances.

[source,tcl]
----
<<PropagatePolyEvents: non-leaf missing deferred event>>=
Event create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    PSigID $psigid\
    Number -1
DeferredEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event
InheritedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event
NonLocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole

# Note that we need to provide a Deferral Path for all the generalizations that
# may stem from this subclass.  So we iterate over all the superclass
# relationships this subclass participates in.
forAllRefs multigen $multigens {
    DeferralPath create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        Relationship [readAttribute $multigen Relationship]\
        Role target
}
----

If the deferred event is found to already have been defined,
then there are several cases that must be dealt with.

. The event could be a Local Event that was defined as part of a State Model.
. The event could be inherited from a superclass.
. The event could be polymorphic. This would be the case if a user
redefined an inherited polymorphic event in one of the subclasses of the
generalization.
That is not necessary to do (that is what this code is actually doing),
but neither is it wrong.

We handle these cases, starting with the Local Event.

[source,tcl]
----
<<PropagatePolyEvents: resolve found deferred event>>=
set local [findRelated $evt {~R80 TransitioningEvent} {~R82 LocalEvent}]
if {[isNotEmptyRef $local]} {
    <<PropagatePolyEvents: migrate local event to mapped event>>
} else {
    <<PropagatePolyEvents: migrate inherited event to mapped event>>
}
----

Migrating a Local Event to a Mapped Event implies deleting the
Local Event and creating a new instance of Mapped Event.
*R83* implies that we need to create a new instance of NonLocal Event.

One further concern here is whether this subclass is a leaf subclass.
If it is, then this is just the normal consumption of an inherited
event as a transition in the state model of the subclass.
However,
if the subclass is subject to repeated generalization,
then the event may no longer be inherited by the lower level generalizations.
It is an easy mistake for a user to make,
so we do some checking.

[source,tcl]
----
<<PropagatePolyEvents: migrate local event to mapped event>>=
delete $local
MappedEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    ParentModel $supClass
NonLocalEvent create\
    Domain $subDomain\
    Model $subClass\
    Event $event\
    Relationship $subRelationship\
    Role $subRole
updateAttribute $evt PSigID $psigid

<<PropagatePolyEvents: check for non-leaf consumption>>
----

We deem it an error to consume an event at a mid-level subclass and then
have lower level subclasses also handle the event as if it were
inherited to them.
It doesn't make any sense.
The test fundamentally depends upon whether there are any
superclass roles played by this subclass.
We have already computed that and need to test it here.
The added complexity is that we need to find all the subclasses down
all the generalizations that may stem from this subclass.
This is effectively the transitive closure of the generalization
hierarchy.

[source,tcl]
----
<<PropagatePolyEvents: check for non-leaf consumption>>=
if {[isNotEmptyRef $multigens]} {
    <<PropagatePolyEvents: compute subclasses using event>>

    if {[llength $usingevent] != 0} {
        log::error "In domain, \"$subDomain\", class, \"$subClass\",\
            event, \"$event\", is inherited across, \"$subRelationship\"\
            and is consumed in the $subClass state model:\
            yet class(es), \"[join $usingevent {, }]\", assume \"$event\"\
            is deferred to them"
        incr errcount
    }
}
----

To compute the entire set of subclasses that may be contained in
generalizations rooted at the current subclass,
we will build a binary relation that can be used to compute
the transitive closure.
We define a helper procedure that can be called recursively to
descend the generalization hierarchy.
The strategy is to build a relation that is the Cartesian product of
a relation that holds the names of superclasses and one that holds
the names of the subclasses on the next level.
Then, we find superclasses that are immediately related to the subclasses
and recursively compute the binary relation again.
By taking the union of this binary relation at each level in the
generalization,
we have the entire hierarchy and can pass that off to compute the
transitive closure.

[source,tcl]
----
<<helper commands>>=
proc findSubclassesOf {supers} {
    if {[isEmptyRef $supers]} {# <1>
        return [relation create {Super string Sub string}]
    }
    set supnames [pipe {
        deRef $supers |
        relation project ~ Class |
        relation rename ~ Class Super
    }] ; # <2>
    set subclasses [instop $supers findSubclasses] ; # <3>
    set subnames [pipe {
        deRef $subclasses |
        relation project ~ Class |
        relation rename ~ Class Sub
    }] ; # <4>

    set uses [relation times $supnames $subnames]

    set nextsupers [pipe {
        deRef $subclasses |
        relation semijoin ~ [deRef [ClassRole findAll]]\
            -using {Domain Domain Class Class} |
        relation semijoin ~ [deRef [Superclass findAll]] |
        ::rosea::Helpers::ToRef ::micca::Superclass ~
    }] ; # <5>

    return [relation union $uses [findSubclassesOf $nextsupers]] ; # <6>
}
----
<1> Stop if there are no further generalizations.
<2> Superclass names in a relation with one attribute, `Super`.
<3> Find the immediate subclasses.
<4> Subclass names in a relation with one attribute, `Sub`.
<5> Step down the hierarchy to those superclasses that have the same
name as the subclasses.
<6> Recursively descend to the next level and union the results from there.

Given a relation value that has the Superclasses and Subclasses at each
level in a generalization hierarchy,
we can compute the transitive closure of this relation.
The `relation tclose` command computes all possible paths and
we we restrict the result to being just paths from our current subclass.

[source,tcl]
----
<<PropagatePolyEvents: compute subclasses using event>>=
set subsusing [pipe {
    findSubclassesOf $multigens|
    relation tclose ~ |
    relation restrictwith ~ {$Super eq $subClass} |
    relation project ~ Sub |
    relation list ~ Sub
}] ; # <1>
set usingevent [pipe {
    Event findWhere {$Domain eq $subDomain && $Model in $subsusing &&\
            $Event == $event} |
    deRef ~ |
    relation project ~ Model |
    relation list ~ Model
}] ; # <2>
----
<1> We are only interested in the names of the subclasses that are ultimately
related to the current subclass.
That is sufficient for the next query.
<2> We get the names of the subclasses that use the event by querying
the Events to see which ones have Model attributes present in our
list of using subtypes.

If the deferred event was not local,
then two other possiblities exist.
First, it could be inherited.
If so, then for leaf subclasses we want to migrate the event to be a
Mapped Event.
If we aren't at a leaf, then the event passed further down.
The second possibility is that the event is classified as a Polymorphic
Event.
This can happen when a user redeclares an event as Polymorphic
at a mid-level subclass.
It is not necessary to do but it's not wrong.

[source,tcl]
----
<<PropagatePolyEvents: migrate inherited event to mapped event>>=
set inherit [findRelated $evt {~R80 DeferredEvent} {~R81 InheritedEvent}]
if {[isNotEmptyRef $inherit]} {
    <<PropagatePolyEvents: create mapped event at leaf>>
} else {
    <<PropagatePolyEvents: handle superfluous polymorphic event>>
}
----

If we have found an inherited event at a leaf subclass,
we want to migrate it to be a mapped event.

[source,tcl]
----
<<PropagatePolyEvents: create mapped event at leaf>>
if {[isEmptyRef $multigens]} {
    delete $inherit
    MappedEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        ParentModel $supClass
}
----

If we find a superfluous polymorphic event declaration,
we patch things up by simply migrating it to be an Inherited Event
as it would have been if the user had not inserted the extra
polymorphic statement in the configuration.
Also note, that the case were we define a polymorphic event in a
leaf subclass does not arise though this code path.
Because a leaf subclass never plays a Superclass role,
then no Deferral Path instance will be created that is associated with
the Polymorphic Event defined by the leaf subclass.
In other words, the error is detected because referential integrity
checks will fail.

[source,tcl]
----
<<PropagatePolyEvents: handle superfluous polymorphic event>>=
set poly [findRelated $evt {~R80 DeferredEvent} {~R81 PolymorphicEvent}]
if {[isNotEmptyRef $poly] && [isNotEmptyRef $multigens]} {
    delete $poly
    InheritedEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event
    NonLocalEvent create\
        Domain $subDomain\
        Model $subClass\
        Event $event\
        Relationship $subRelationship\
        Role $subRole
}
----

ifdef::showtests[]
[float]
===== Tests

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.0 {
    Define polymorphic events
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2 a int
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {d int} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {d int} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s2
                }
            }
            generalization R1 S X Y
        }
    }
    log::debug [formatMiccaClass NonLocalEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 4}\
        {[refMultiplicity [MappedEvent findAll]] == 4}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.1 {
    Define polymorphic events -- inherit across one level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.2 {
    Define polymorphic events -- new event in leaf subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int

                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                    transition s2 - e3 -> s2 ; # New local event!
                }
            }
            class Y {
                attribute id int

                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    state s2 {} {
                        puts "in s2"
                    }
                    transition s1 - e1 -> s2
                    transition s2 - e2 -> s1
                }
            }
            generalization R1 S X Y
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 4}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 4}\
        {[refMultiplicity [LocalEvent findAll]] == 1}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.3 {
    Define polymorphic events -- inject polymorphic event mid-level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                polymorphic e3
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass NonLocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 10}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 8}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.4 {
    Define polymorphic events -- multiple hierarchies
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 S A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 8}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.5 {
    Define polymorphic events -- common subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e3 -> s1
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                }
            }
            generalization R1 S X Y

            class Z {
                attribute zid int
                polymorphic e3
            }
            class A {
                attribute zid int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                }
            }
            generalization R2 Z A X
        }
    }
    log::debug [formatMiccaClass DeferralPath]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 6}\
        {[refMultiplicity [InheritedEvent findAll]] == 0}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.6 {
    Define polymorphic events -- consume mid level event
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass NonLocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 6}\
        {[refMultiplicity [InheritedEvent findAll]] == 1}\
        {[refMultiplicity [MappedEvent findAll]] == 5}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.7 {
    Define polymorphic events -- compound generalization at mid level
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                polymorphic e3
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B

            class C {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e3 -> s1
                }
            }
            class D {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                    transition s1 - e4 -> s1
                }
            }
            generalization R3 X C D
        }
    }
    log::debug [formatMiccaClass NonLocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    log::debug [formatMiccaClass LocalEvent]
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 16}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 14}\
        {[refMultiplicity [LocalEvent findAll]] == 1}\
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.8 {
    polymorphic events -- consume mid level event and use lower down
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # consume e1 here
                }
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # use e1 across R2 -- error
                    transition s1 - e2 -> s1 ; # use e2 across R3 -- error
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1 ; # no e1 used -- correct
                }
            }
            generalization R2 X A B

            class C {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1 ; # use e1 across R3 -- error
                    transition s1 - e2 -> s1
                }
            }

            class D {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e2 -> s1 ; # no e1 used -- correct
                }
            }
            generalization R3 A C D
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.9 {
    Define polymorphic event in leaf subclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class Y {
                attribute id int
                polymorphic e3
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test polymorphic-1.10 {
    Define polymorphic events -- superfluous polymorphic definitions
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class S {
                attribute id int
                polymorphic e1
                polymorphic e2
            }
            class X {
                attribute id int
                polymorphic e2 ; # e2 is inherited along R1 and declared poly here
            }
            class Y {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R1 S X Y

            class A {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            class B {
                attribute id int
                statemodel {
                    state s1 {} {
                        puts "in s1"
                    }
                    transition s1 - e1 -> s1
                    transition s1 - e2 -> s1
                }
            }
            generalization R2 X A B
        }
    }
    log::debug [formatMiccaClass TransitioningEvent]
    log::debug [formatMiccaClass DeferredEvent]
    log::debug [formatMiccaClass NonLocalEvent]
    log::debug [formatMiccaClass InheritedEvent]
    log::debug [formatMiccaClass MappedEvent]
    testConditions\
        {[refMultiplicity [NonLocalEvent findAll]] == 8}\
        {[refMultiplicity [InheritedEvent findAll]] == 2}\
        {[refMultiplicity [MappedEvent findAll]] == 6}\
        {[refMultiplicity [LocalEvent findAll]] == 0}\
} -result {1}
----
endif::showtests[]

=== Class Operation

A class operation is a body of code that associated to a particular class.
Class operations at the analysis level are rare,
but when translating they are often useful.
For example,
if you wish to implement some search or sort algorithm on the instances
of a class that could be defined as a class operation.
Also operations that summarize information across multiple class
instances are often implemented easiestly using a class operation.

*****
+classop+ _rettype_ _name_ _parameters_ _body_

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the class operation.
`name`::
    The name of the class operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
*****

[float]
==== Implementation

(((micca,Config,classop)))
[source,tcl]
----
<<class config commands>>=
proc classop {rettype name parameters body} {
    DefineOperation false $rettype $name $parameters $body
}
----

=== Instance Operation

An instance operation is a body of code executed on a particular class instance.

*****
+instop+ _rettype_ _name_ _parameters_ _body_

`rettype`::
    A ``C'' typename that gives the type of the value returned from
    the instance operation.
`name`::
    The name of the instance operation. `Name` must be a valid ``C'' identifier.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
`body`::
    A string containing the code that is executed when the instance operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
    The code in _body_ may refer to a variable named `self` which holds
    a reference to the class instance on which the operation was invoked.
*****

[float]
==== Implementation

(((micca,Config,instop)))
[source,tcl]
----
<<class config commands>>=
proc instop {rettype name parameters body} {
    DefineOperation true $rettype $name $parameters $body
}
----

==== Define Operation

Defining class and instance operations is easily factored into
common code.

[float]
==== Implementation

(((micca,Config,DefineOperation)))
[source,tcl]
----
<<class config commands>>=
proc DefineOperation {isinst rettype name parameters body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    Operation create\
        Domain $DomainName\
        Class $ClassName\
        Name $name\
        Body $body\
        ReturnDataType $rettype\
        IsInstance $isinst

    set paramtuple [dict create Domain $DomainName Class $ClassName\
            Operation $name]

    if {$isinst} {
        dict set paramtuple Name self
        dict set paramtuple DataType "struct $ClassName *const"
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    dict for {paramname paramtype} $parameters {
        dict set paramtuple Name $paramname
        dict set paramtuple DataType $paramtype
        dict set paramtuple Number\
                [GenNumber $DomainName OperationParameter\
                [list $DomainName $ClassName $name]]
        OperationParameter create {*}$paramtuple
    }

    return
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test classop-1.0 {
    Define a class operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c4 {
                attribute a1 int

                classop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation ReturnDataType Domain foo Class c4 Name color
} -result {float}
----

[source,tcl]
----
<<config command tests>>=
test instop-1.0 {
    Define an instance operation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c5 {
                attribute a1 int

                instop float color {a char b {int *const}} {
                    printf("a = %d, b = %s", a, b) ;
                }
            }
        }
    }
    log::debug [formatMiccaClass Operation]
    log::debug [formatMiccaClass OperationParameter]
    readMiccaAttribute Operation IsInstance Domain foo Class c5 Name color
} -result {true}
----
endif::showtests[]

=== Constructor

A constructor for a class is another concept that is occasionally useful
in an implementation but not needed at the model level.
When we create class instances, we will insist that a value for every
attribute be supplied.
This will insure that there are no uninitialized attributes.
Sometimes, we will find it convenient to have attribute data types that
are user defined and encapsulated.
It may require a constructor to initialize such encapsulated data types.
Note that constructors do not take arguments and so are not particularly
useful for setting attribute values.

*****
+constructor+ _body_

`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.

The `constructor` command defines a _body_ of code that is executed
when an instance of a class is created.
*****

[float]
==== Implementation

(((micca,Config,constructor)))
[source,tcl]
----
<<class config commands>>=
proc constructor {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName
    Constructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

=== Destructor

By analogy to a constructor,
a class may have a destructor that is called when an instance is deleted.

*****
+destructor+ _body_

`body`::
    A string containing the code that is executed when the class operation
    is invoked.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.

The `destructor` command defines a _body_ of code that is executed
when an instance of a class is deleted.
*****

[float]
==== Implementation

(((micca,Config,destructor)))
[source,tcl]
----
<<class config commands>>=
proc destructor {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName
    Destructor create\
        Domain $DomainName\
        Class $ClassName\
        Body $body
}
----

== Defining Class State Models

State models in XUML are used to specify the sequence of computations
associated with the life cycle of class instances.
All instances of a class have the same behavior,
yet each instance has it own notion of current state and so may progress
through its life cycle independently of any other instance.

Traditionally,
http://en.wikipedia.org/wiki/Moore_machine[Moore]
type state models are used in XUML to define the life cycle behavior.
The other alternative is a
http://en.wikipedia.org/wiki/Mealy_machine[Mealy]
type state model.
They are mathematically equivalent in the sense that any problem that
can be solved by one formulation can also be solved by the other.
Individuals have their preferences over which formulation is better
and we will not indulge in that discussion here.
We only point out that hierarchical state models are _not_
supported in the this translation scheme.
Hierarchical state models are an unnecessary abomination.

As usual, we need a namespace in which to hold the state model definition
commands.

[source,tcl]
----
<<state model config namespace layout>>=
namespace eval StateModelDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<state model config commands>>
}
----

=== Statemodel

The `statemodel` command is used to define a state model for a class
or an assigner.
Both use the same command and support the same commands in the
script body for defining states, events and transitions.

*****
+statemodel+ _body_

+body+::
    A Tcl Script that is evaluated in a context to allow the definition
    of the properties of the class state model.
*****

[float]
==== Implementation

The implementation of the `statemodel` command follows the usual pattern.
We evaluate `body` in the proper context and then
insert the argument data into the proper relvars that are used to
collect the state model specifications.

(((micca,Config,statemodel)))
[source,tcl]
----
<<class config commands>>=
proc statemodel {body} {
    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    namespace upvar StateModelDef\
        InitialState InitialState\
        DefaultTrans DefaultTrans\
        Terminals Terminals

    set InitialState {}
    set DefaultTrans {}
    set Terminals [list]

    ConfigEvaluate [namespace current]::StateModelDef $body

    if {$DefaultTrans eq {}} {
        set DefaultTrans CH
    }
    StateModel create\
        Domain          $DomainName\
        Model           $ClassName\
        InitialState    $InitialState\
        DefaultTrans    $DefaultTrans
    InstanceStateModel create\
        Domain          $DomainName\
        Class           $ClassName

    foreach terminal $Terminals {
        set sref [State findWhere {$Domain eq $DomainName &&\
                $Model eq $ClassName && $Name eq $terminal}]
        updateAttribute $sref IsTerminal true
    }
}
----

=== State

The `state` command defines code that is executed when the state is entered
and any parameters that are passed in from the event that caused the
transition.

*****
+state+ _name_ _parameters_ _body_

`name`::
    The name of the state. Name must not be the empty string or one of
    the reserved names of *@*, *CH* or *IG*.
`parameters`::
    A list of parameter name / parameter type pairs giving the
    names of the domain operation parameters and their corresponding
    ``C'' data type names.
    A list of the formal parameters of the state.
    Parameters are specified in the same manner as for the `::proc` command.
`body`::
    A string containing the code that is executed when the state is
    entered.
    This string is presumed to be ``C'' code optionally interspersed with
    architecture macros.
*****

[float]
==== Implementation

(((micca,Config,state)))
[source,tcl]
----
<<state model config commands>>=
proc state {name params body} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME state
    }
    if {$name eq "@" || [isNotEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }

    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    variable InitialState

    if {$InitialState eq {}} {
        set InitialState $name
    }

    set psigid [FindParameterSignature $params]
    set stateref [State create\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Activity        $body\
        IsTerminal      false\
        PSigID          $psigid\
    ]
    StatePlace create\
        Domain          $DomainName\
        Model           $ClassName\
        Name            $name\
        Number          [GenNumber $DomainName StatePlace\
                            [list $DomainName $ClassName]]

    if {$psigid ne {}} {
        set asigid [pipe {
            findRelated $stateref R78 |
            readAttribute ~ ASigID
        }]
        StateTransition update [pipe {
            findRelatedWhere $stateref ~R72 {$ASigID eq {}} |
            deRef % ASigID |
            relation update % sttuple {1} {
                tuple update $sttuple ASigID $asigid
            }
        } {} |%]
        Event update [pipe {
            findRelatedWhere $stateref {~R72 R71 R70 R80} {$PSigID eq {}} |
            deRef % PSigID |
            relation update % utup {1} {
                tuple update $utup PSigID $psigid
            }
        } {} |%]
    }

    return
}
----

(((error code,BAD_STATE_NAME)))
[source,tcl]
----
<<error code formats>>=
BAD_STATE_NAME    {"%s" is not a valid state name}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test state-1.0 {
    Define a state with parameters
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 int

                statemodel {
                    transition s1 - e1 -> s2
                    event e1 e int f float

                    state s1 {a int b float} {
                        printf("in state s1\n") ;
                    }
                    state s2 {c int d float} {
                        printf("in state s2\n") ;
                    }

                    state s3 {i char j double} {
                    }
                    event e2 e char f double

                    transition s2 - e2 -> s3
                    transition s3 - e1 -> s1
                }
            }
        }
    }
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    log::debug [formatMiccaClass ParameterSignature]
    log::debug [formatMiccaClass Parameter]
    log::debug [formatMiccaClass ArgumentSignature]
    log::debug [formatMiccaClass Argument]
    testConditions\
        {[refMultiplicity [State findAll]] == 3}\
        {[refMultiplicity [Event findAll]] == 2}\
        {[refMultiplicity [ParameterSignature findAll]] == 5}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test state-1.1 {
    Define a state with parameters
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 int

                statemodel {
                    state Empty {} {
                    }
                    transition Empty - Fill -> Filling

                    state Filling {temp WaterTemp_t} {
                    }
                    transition Filling - TubEmpty -> Empty
                }
            }
        }
    }
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    log::debug [formatMiccaClass ParameterSignature]
    log::debug [formatMiccaClass Parameter]
    log::debug [formatMiccaClass ArgumentSignature]
    log::debug [formatMiccaClass Argument]
    testConditions\
        {[refMultiplicity [State findAll]] == 2}\
        {[refMultiplicity [Event findAll]] == 2}\
        {[refMultiplicity [ParameterSignature findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test state-2.0 {
    State / event parameter mismatch
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute a1 int

                statemodel {
                    event e1 a float b int

                    transition s1 - e1 -> s1 ; # e1 and s1, different signatures

                    state s1 {a int b float} {
                    }

                    state s2 {a int b float} {
                    }

                    event e2 f int g float
                    transition s1 - e2 -> s2
                    # e2 and s2, same signature, different parameter names

                    transition s2 - e3 -> s1
                    event e3 h char i unsigned ; # e3 and s1, different
                }
            }
        }
    }
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    log::debug [formatMiccaClass ParameterSignature]
    log::debug [formatMiccaClass Parameter]
    log::debug [formatMiccaClass ArgumentSignature]
    log::debug [formatMiccaClass Argument]
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

=== State Parameters

In XUML,
a state may define a set of parameters that are passed to the activity
of the state when the activity is executed.
Most of the time,
states do not define any parameters and so there is nothing else to
understand about how the parameter passing works.

If a state does define parameters,
then it is a corollary of the Moore machine formulation that
any event that causes a transition into a state with parameters must
carry a matching set of arguments whose values were determined when the
event was signalled.
So if an event causes a transition to different states,
then each state must have the same parameter signature.
Conversely, if different event cause a transition into the same state,
the events must have the same parameter signature.

What determines the matching of event and state parameters is
the position and data type of the parameters.
Specifically,
the parameter names don't matter when we are trying to decide if
the parameters of an event and the parameters of the state into which
the event causes a transition match.
For example an event may view its parameters as `int size, float incr` and a
corresponding state may view its parameters as `int count, float prec`.
In this case the signature of position and type is the same despite the
difference in the parameter naming.
Seen another way, states and events may have a different semantic
view of their parameters as given by the parameter names, but have
matching syntax of parameter position and data type.

In our attempt so minimize the amount of specification of information
in the configuration DSL,
the declaration of events is optional.
Here are the rules:

. An event and its parameters may be declared with the `event` command
and that is the signature it is given.
. A polymorphic event that has parameters must declare them as part
of the `polymorphic` command.
. If there is no event declaration, the event name and signature is
assumed from the state into which the event causes a transition.
Its parameter naming, position and type information is assumed from that
of the state.

The rules outlined in this discussion are not the only possiblity.
It is the one that has been chosen for `micca` as it matches the
function invocation rules of ``C'' while still allowing flexiblity
in parameter name specification.
We deem this approach more consistent with ``C'' implementation concepts
and more flexible than one that is based strictly on parameter names
and the need to declare event parameter signatures.

The helper procedures in this section do the work of setting up parameter
signatures and the underlying argument signatures.
Here is where signature equality is determined.

==== FindParameterSignature

The `FindParameterSignature` procedure searches for an existing parameter
signature that matches the parameter list argument and returns the
parameter signature ID.
If none exists that matches,
it creates a new one and returns the ID of the new one.

[float]
==== Implementation

The tricky part in determining the equality of two parameter signatures
is that we want to find that Parameter Signature where all the
related Parameter instances have the correct values for the parameter
name, position and data type.
The information about position and data type is held in the Argument Signature
and we will cover that next.

Again this is a situation where some relational algebra can come to the
rescue.
In this case we will create a relation value that holds the parameter
name, position and data type.
We then use the `relation group` command to create a relation valued
attribute that groups together the parameter name, position and
data type for the existing instances of Parameter.
Equality can then be determined by the equality of two relations.

(((micca,Helpers,FindParameterSignature)))
[source,tcl]
----
<<helper commands>>=
proc FindParameterSignature {params} {
    if {[dict size $params] == 0} {
        return
    }

    set asigid [FindArgumentSignature $params] ; # <1>
    if {$asigid eq {}} {
        error "panic: did not create an argument signature for \"$params\""
    }

    set poscounter -1
    set parampos [relation create {Name string Position int ASigID string}]
    dict for {pname ptype} $params {
        set parampos [relation insert $parampos [list\
            Name $pname\
            Position [incr poscounter]\
            ASigID $asigid\
        ]]
    } ; # <2>
    set psigref [pipe {
        Parameter findAll | deRef ~ |
        relation group ~ ParamNames Name Position ASigID |
        relation restrictwith ~ {[relation is $ParamNames == $parampos]} |
        relation semijoin ~ [deRef [ParameterSignature findAll]]
        ::rosea::Helpers::ToRef ::micca::ParameterSignature ~
    }] ; # <3>

    if {[isEmptyRef $psigref]} {# <4>
        namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

        set psigid psig[GenNumber $DomainName ParameterSignature\
                [list $DomainName]]
        ParameterSignature create\
            Domain $DomainName\
            PSigID $psigid\
            ASigID $asigid
        set poscounter -1
        dict for {pname ptype} $params {
            Parameter create\
                Domain $DomainName\
                PSigID $psigid\
                Name $pname\
                Position [incr poscounter]\
                ASigID $asigid
        }
    } else {
        set psigid [readAttribute $psigref PSigID]
    }

    return $psigid
}
----
<1> The argument signature encodes the position and data type information.
<2> The heading of this relation matches the attribute names in the
Parameter class.
<3> Step by step:
    . Get all the Parameter instances as a relation value.
    . Group together the Name, Position and ASigID attributes. This leaves
      us with a relation value with the attributes Domain, PSigID and
      ParamNames, where ParamName is relation valued.
    . Find the one matching the information in the parameters argument.
    . Find the corresponding Parameter Signature.
    . Turn it into an instance reference for later use.
<4> If we fail to find a match, then create the Parameter Signature and
Parameter instances. Otherwise, we can return the PSigID value.

==== FindArgumentSignature

To separate parameter names from their position and data type,
we introduce the concept of an Argument Signature.
Here equality is based solely on positions` and data types of the
arguments.
This concept is useful when considering how argument values carried by an
event are transferred to the formal parameter of a state activity.
In that situation,
the names don't matter in ``C'', only order and data type.

[float]
==== Implementation

The implementation here follows the same strategy used for
`FindParameterSignature`.
We create a relation value that contains the Position and DataType information
that corresponds to the parameters.
The grouping and comparing is similar.

[source,tcl]
----
<<helper commands>>=
proc FindArgumentSignature {params} {
    if {[llength $params] == 0} {
        return
    }

    set poscounter -1
    set parampos [dict create]
    dict for {pname ptype} $params {
        dict set parampos [incr poscounter] $ptype
    }
    set argpos [relation fromdict $parampos Position int DataType string] ; # <1>
    set asigref [pipe {
        Argument findAll | deRef ~ |
        relation group ~ ArgPositions Position DataType |
        relation restrictwith ~ {[relation is $ArgPositions == $argpos]} |
        relation semijoin ~ [deRef [ArgumentSignature findAll]] |
        ::rosea::Helpers::ToRef ::micca::ArgumentSignature ~
    }]

    if {[isEmptyRef $asigref]} {
        namespace upvar ::micca::@Config@::DomainDef DomainName DomainName

        set asigid asig[GenNumber $DomainName ArgumentSignature\
                [list $DomainName]]
        ArgumentSignature create\
            Domain  $DomainName\
            ASigID   $asigid
        set poscounter -1
        dict for {pname ptype} $params {
            Argument create\
                Domain      $DomainName\
                ASigID      $asigid\
                Position    [incr poscounter]\
                DataType    $ptype
        }
    } else {
        set asigid [readAttribute $asigref ASigID]
    }

    return $asigid
}
----
<1> Since there are only two attributes in the relation value of position
and data type information, we can use a Tcl `dict` to accumulate the
information and then TclRAL has convenience methods to move between
relation values and Tcl dictionaries.

=== Event

Event definitions are optional,
but in the case of events with parameters may make the parameter set
clearer by declaring the event.

*****
`event` _name_ ?_argname argtype_ ...?

`name`::
    The name of the event.

`argname argtype ...`::
    The argument signature of the event. Arguments must be given in
    name / type pairs. Argument names must be ``C'' identifiers and
    argument types must be ``C'' type names.

The `event` command defines _name_ as being an event with
optional event arguments given by _argname_ / _argtype_ pairs.
*****

[float]
==== Implementation

The implementation does the usual platform class instance creation to
store away the data in the command arguments.
However,
since events may be defined simply by their appearance in a
`transition` command, we need to check if we have already seen the
event.
If we have, then we want to update the parameter signature to match
what was defined in this command.
Further,
if this event causes any state transition where the argument signature
has not already been determined,
then we need to update the StateTransition instances to reflect the
argument signature implied by this event.
This processing is done here to make the order of event and transition
specification arbitrary.

(((micca,Config,event)))
[source,tcl]
----
<<state model config commands>>=
proc event {name args} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    set psigid [expr {[llength $args] != 0 ?\
            [FindParameterSignature $args] : {}}]

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $name\
    ]
    set evtref [Event findById {*}$eventtuple]
    if {[isEmptyRef $evtref]} {
        set evtref [Event create {*}$eventtuple PSigID $psigid Number -1]
        TransitioningEvent create {*}$eventtuple
        LocalEvent create {*}$eventtuple
    } else {
        updateAttribute $evtref PSigID $psigid
    }

    if {$psigid ne {}} {
        set asigid [pipe {
            findRelated $evtref R69 |
            readAttribute ~ ASigID
        }] ; # <1>
        StateTransition update [pipe {
            findRelatedWhere $evtref\
                {{~R80 TransitioningEvent} {~R70 TransitionPlace}\
                {~R71 StateTransition}} {$ASigID eq {}} |
            deRef % ASigID |
            relation update % sttuple {1} {
                tuple update $sttuple ASigID $asigid
            }
        } {} |%] ; # <2>
    }
}
----
<1> If we have a parameter signature, then get the corresponding
argument signature.
<2> Update the argument signature for any StateTransition instance where
this event caused a transition and which does not already have a value
for its argument signature.

=== Transition

For Moore type state models,
one can conceive of the mapping of states to events as a transition
matrix with a row for each state and a column for each event.
Each matrix cell has a value of the new state for the transition.
The `transition` command is used to define the values of cells
in the conceptual transition matrix.

*****
+transition+ _source_ `-` _event_ `->` _target_

+source+::
    The name of a state in the state model being defined or the
    special reserved name, `@`.
+event+::
    The name of an event that causes the transition.
+target+::
    The name of a state in the state model being defined or one of the
    special non-transitioning states, `IG` or `CH`.

The `transition` command defines the transition that is to happen
when _event_ is dispatched to a state machine when the current
state is _source_, causing the new state to be _target_.
*****

[float]
==== Implementation

The implementation of the `transition` command consists mainly of
inserting tuples into the event classes using the data from the command
arguments.
Note however, that all the events defined by invoking `transition` are
deemed to be a *LocalEvent*.
This certainly may not be true for classes that are leaf subclass of
a generalization hierarchy.
When the domain configuration is completed we will propagate the
polymorphic events down the generalization hierarchies and in that
process recategorize any inherited events properly.

One other minor concern is dealing with the initial pseudo-state, *@*.
This state is where an instance resides if it has been created
asynchronously.
One may not define the `@` state in a `state` command
(it cannot have an activity)
and the only valid place it can appear is as the `source` state in a
`transition` command.

We also have to handle the argument signature of the transition.
If the new state or the event already has an argument signature
we will use it here when the State Transition is created.

(((micca,Config,transition)))
[source,tcl]
----
<<state model config commands>>=
proc transition {source - event -> target} {
    if {$event eq {}} {
        tailcall DeclError BAD_NAME event
    }
    if {[isNotEmptyRef [TransitionRule findById Name $source]]} {# <1>
        tailcall DeclError BAD_STATE_NAME $name
    }
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName ClassName

    if {$source eq "@"} {
        if {[isNotEmptyRef [TransitionRule findById Name $target]]} {
            tailcall DeclError BAD_CREATION_TARGET $target
        }
        set cstuple [list\
            Domain          $DomainName\
            Model           $ClassName\
            Name            @\
        ]
        # We have to conditionally create the CreationState instance since we
        # can have multiple transition commands that use @ as the source state.
        if {[isEmptyRef [CreationState findById {*}$cstuple]]} {
            CreationState create {*}$cstuple
        }
        if {[isEmptyRef [StatePlace findById {*}$cstuple]]} {
            StatePlace create {*}$cstuple\
                Number [GenNumber $DomainName StatePlace\
                        [list $DomainName $ClassName]]
        }
    }

    set eventtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        Event   $event\
    ]
    set eventref [Event findById {*}$eventtuple]
    if {[isEmptyRef $eventref]} {
        set stateref [State findWhere {$Domain eq $DomainName &&\
            $Model eq $ClassName && $Name eq $target}]
        set psigid [expr {[isNotEmptyRef $stateref] ?\
                [readAttribute $stateref PSigID] : {}}]
        Event create {*}$eventtuple PSigID $psigid Number -1
        TransitioningEvent create {*}$eventtuple
        LocalEvent create {*}$eventtuple
    }

    set transtuple [list\
        Domain  $DomainName\
        Model   $ClassName\
        State   $source\
        Event   $event\
    ]
    TransitionPlace create {*}$transtuple

    set trref [TransitionRule findById Name $target]
    if {[isNotEmptyRef $trref]} {
        NonStateTransition create {*}$transtuple TransRule $target
    } else {
        # Create the state transition instance. If the state or event has
        # already been created, then use the argument signature from them, else
        # just leave it empty. Note we only look for states or events that
        # a non-empty parameter signature.
        
        set asigid {}
        set stateref [State findWhere {$Domain eq $DomainName &&\
            $Model eq $ClassName && $Name eq $target && $PSigID ne {}}]
        if {[isNotEmptyRef $stateref]} {
            set asigid [pipe {
                findRelated $stateref R78 |
                readAttribute ~ ASigID
            }]
        } else {
            set eventref [Event findWhere {$Domain eq $DomainName &&\
                $Model eq $ClassName && $Event eq $event && $PSigID ne {}}]
            if {[isNotEmptyRef $eventref]} {
                set asigid [pipe {
                    findRelated $eventref R69 |
                    readAttribute ~ ASigID
                }]
            }
        }

        set stref [StateTransition create {*}$transtuple\
                NewState $target ASigID $asigid]
    }

    return
}
----
<1> Ignoring a transition out of the pseudo-initial state is not allowed
and any transition out of the pseudo-initial state not mentioned in a
`transition` command will be set to CH anyway. So just don't let
transition out of the pseudo-initial state go anywhere except a real state.

(((error code,BAD_CREATION_TARGET)))
[source,tcl]
----
<<error code formats>>=
BAD_CREATION_TARGET {the target of a creation event must be a state,\
        got "%s"}
----

=== Initialstate

By default,
instances created from classes that have a state model are placed in
the first state that was defined for the model.
The `initialstate` command is used to specify explicitly the inital state
for newly created instances.

*****
+initialstate+ _name_

+name+::
    The name of at state in the state model being defined.
    Instances of the class that are created synchronously using
    the `create` class command will be placed in this state.

The `initialstate` command sets the default state that an instance will be
created in. If no `initialstate` command is encountered in the definition
of a state model, then the first state defined to the state model is used
as the initial state.
*****

[float]
==== Implementation

(((micca,Config,initialstate)))
[source,tcl]
----
<<state model config commands>>=
proc initialstate {name} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME initialstate
    }
    if {$name eq "@" || [isNotEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError BAD_STATE_NAME $name
    }
    variable InitialState $name
    return
}
----

=== Defaulttrans

It is customary to write `transition` commands only for outgoing
transition that appear on the state model graphic.
For any entries in transition matrix that are not set by a `transition`
command,
a default value is supplied.
That default is either `IG` or `CH` depending upon the argument to the
`defaulttrans` command.
If no `defaulttrans` command is invoked when a state model is defined,
then the default transition will be `CH`.

*****
+defaulttrans+ _trans_

+trans+::
    Either the string *IG* or *CH*.
    For all transitions not explicitly mentioned in a `transition` command,
    the default transition is defined as _trans_.
    If `defaulttrans` is not invoked during a state model definition
    then the default transition is *CH*.
*****

[float]
==== Implementation

(((micca,Config,defaulttrans)))
[source,tcl]
----
<<state model config commands>>=
proc defaulttrans {name} {
    if {[isEmptyRef [TransitionRule findById Name $name]]} {
        tailcall DeclError EXPECTED_PSEUDO_STATE $name
    }
    variable DefaultTrans $name
    return
}
----

(((error code,EXPECTED_PSEUDO_STATE)))
[source,tcl]
----
<<error code formats>>=
EXPECTED_PSEUDO_STATE    {expected CH or IG, got "%s"}
----

==== Terminal

Terminal states are those where the class instance is deleted after
the state activity is executed.
This allows for asynchronous deletion of class instances.

*****
+terminal+ _?state ...?_

+state+::
    The name of a state in the state model that will be marked as a
    terminal state.
    If a state machine transitions into a terminal state,
    the associated instance is deleted after the state activity is
    executed.
*****

[float]
===== Implementation

(((micca,Config,terminal)))
[source,tcl]
----
<<state model config commands>>=
proc terminal {args} {
    variable Terminals
    if {"@" in $args} {
        tailcall DeclError BAD_STATE_NAME @
    }
    ::struct::set add Terminals $args
    return
}
----

== Defining Assigners

The assigner concept is not frequently used in XUML models
but is an essential concept in modeling competitive relationships.
Some associations model competitive behavior such as allocating
resources.
For such situations,
instances of the relationships must be created and deleted,
'i.e.' linked and unlinked,
according to some protocol and in some fashion that serializes
the relationship lifecycle between competing classes.
Lifecycle behavior of associations is accomplished in XUML models by
associating a state model and having the state model
activities insure the proper creation of relationship instances.
Such state models are known as _assigners_.

Note that we associate the assigner with the relationship.
We do *not* require factoring the relationships into a class based association
and then attach the assigner to the associator class.
In `micca`,
the relationship may or may not be class based and if it is the associator class
may or may not have a state model.
The assigner state model is independent of any class and its state model.
It is, after all, a state model to deal with the application semantics
of forming and dissolving the relationship.

Also note that only associative relationships may have an assigner.
Assigners are not meaningful for generalization relationships given
the disjoint union nature of a generalization.

There is a further complication.
Usually,
there is a single state machine associated with the association assigner.
However,
some assigners have more complicated competitive protocols.
In those cases the association may have multiple assigners
that are partitioned by another class.
The archetypal example is that of assigning department store clerks
to customers.
If any clerk can service any customer,
then a single assigner is used to sequence properly the assignment of
available clerks to waiting customers.
If the store policy is that a customer can only be served by a clerk working in
a particular department,
then there will be as many assigners as there are departments and
the identity of the department class serves to identify the assigner instances
needed to insure that clerks, within the department, are not over allocated
and that customers, visiting the department, are not over served by
clerks from the wrong department.
This is the essential concept behind a multiple assigner.

Assigners and multi-assigners fall into the XUML semantics category of
not-that-common but essential to express the proper execution semantics.
As we will see,
the specifications required for assigners is almost the same as that
for ordinary class state models.

Assigners are defined by a script specified as part of an
`association` command.
In this section we show the command that may be executed in that script.
We will need to define a namespace in which the script can be evaluated.

[source,tcl]
----
<<assigner config namespace layout>>=
namespace eval AssignerDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<assigner config commands>>
}
----

=== Assigner State Model

The `statemodel` command for assigners takes the same commands as
that for classes.
Indeed, much of the same code is in common.

*****
+statemodel+ _body_

+body+::
    A Tcl Script that is evaluated in a context to allow the definition
    of the properties of the assigner state model.
*****

[float]
==== Implementation

The difference between assigner state model and class state models is
only in a few class instances and relationships, notably, R50 and R53.

(((micca,Config,statemodel)))
[source,tcl]
----
<<assigner config commands>>=
proc statemodel {body} {
    namespace upvar ::micca::@Config@::DomainDef DomainName DomainName
    namespace upvar ::micca::@Config@::DomainDef::ClassDef ClassName AssocName

    namespace upvar ::micca::@Config@::DomainDef::ClassDef::StateModelDef\
        InitialState InitialState\
        DefaultTrans DefaultTrans\
        Terminals Terminals

    set InitialState {}
    set DefaultTrans {}
    set Terminals [list]

    ConfigEvaluate ::micca::@Config@::DomainDef::ClassDef::StateModelDef $body ; # <1>

    if {$DefaultTrans eq {}} {
        set DefaultTrans CH
    }
    StateModel create\
        Domain          $DomainName\
        Model           $AssocName\
        InitialState    $InitialState\
        DefaultTrans    $DefaultTrans

    set assoctuple [list\
        Domain          $DomainName\
        Association     $AssocName
    ]
    AssignerStateModel create {*}$assoctuple

    variable IdClassName
    if {$IdClassName eq {}} {
        SingleAssigner create {*}$assoctuple
    } else {
        MultipleAssigner create {*}$assoctuple Class $IdClassName
        ValueElement create Domain $DomainName Name $AssocName
    }

    foreach terminal $Terminals {
        set sref [State findWhere Domain $DomainName Model $ClassName\
                Name $terminal]
        updateAttribute $sref IsFinal true
    }
}
----
<1> We evaluate the assigner state model script in the same namespace as for
the class state models.
Other than setting up a few variables differently,
the configuration data for assigners is the same as for classes.

=== Identify By Class

For multiple assigners we need to specify which class serves to partition
the assigners into multiple instances.
Defining such a class signifies that the assigner is to be multiple rather
than singular.

*****
`identifyby` _class_

`class`::
    The name of a class that serves to partition the instances of a multiple
    assigner.

The `identifyby` command defines an assigner to be a multiple assigner and
specifies _class_ as the partitioning class.
*****

[float]
==== Implementation

(((micca,Config,identifyby)))
[source,tcl]
----
<<assigner config commands>>=
proc identifyby {class} {
    variable IdClassName $class
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test assigner-1.0 {
    Define a single assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
            }
            class client {
            }
            class service {
            }
            association R1 -associator service clerk 0..1--0..1 client {
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
        }
    }
    log::debug [formatMiccaClass AssignerStateModel]
    log::debug [formatMiccaClass SingleAssigner]
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    testConditions\
        {[refMultiplicity [AssignerStateModel findAll]] == 1}\
        {[refMultiplicity [SingleAssigner findAll]] == 1}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test assigner-1.1 {
    Define a multiple assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
            }
            class client {
            }
            class service {
            }
            association R1 -associator service clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {
            }
            association R2 department 1..*--1 clerk
        }
    }
    log::debug [formatMiccaClass AssignerStateModel]
    log::debug [formatMiccaClass MultipleAssigner]
    log::debug [formatMiccaClass Event]
    log::debug [formatMiccaClass State]
    log::debug [formatMiccaClass StateTransition]
    testConditions\
        {[refMultiplicity [AssignerStateModel findAll]] == 1}\
        {[refMultiplicity [MultipleAssigner findAll]] == 1}
} -result {1}
----
endif::showtests[]

== Populating a Domain

At this point we have covered all the commands that are used to
define the configuration of a domain.
We now turn our attention to specifying an initial instance population.
The initial instances of a domain are those class (and assigner) instances
that will exist when the domain start running.

For many systems, particularly small embedded systems,
much of the class instance data can be specified as part of the initial
instance population.
This has a substantial benefit to the implementation.
Since class data is held in ``C'' arrays, initial instances can be
specified as initializers for those class storage arrays.
The ``C'' language then guarantees that initializer values are in
place before `main` begins execution.
This usually requires much less memory space than having initialiation code to
create the initial instances and having that code executed only once.
So, we will specify the initial instance population in data
rather than procedurally.

We will insist that there be a population for a domain before
code is generated for it.
In practice,
development of a domain will usually entail creating multiple populations
for both testing and deployment.
Populations can be managed by keeping them in separate files and then
assembling the domain using Tcl `source` commands.

Following our usual pattern,
we define a namespace in which to evaluate the population commands.

[source,tcl]
----
<<population config namespace layout>>=
namespace eval PopDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<population config commands>>

    <<class instance config namespace layout>>
    <<assigner instance config namespace layout>>
}
----

=== Population

The `population` command gives values to the class components of the domain.
The complete domain population must be given by the invocation of `population`.

*****
`population` _domain_ _script_

`domain`::
    The name of the domain to which the population applies.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of initial instance values for a domain.

The `population` command is used to define initial instance values for
the classes and assigners in _domain_.
*****

[float]
==== Implementation

The implementation of the `population` procedure follows our general pattern.
The supplied script is evaluated in a namespace where the population commands
will resolve without further qualification.

(((micca,Config,population)))
[source,tcl]
----
<<config commands>>=
proc population {domain script} {
    variable errcount

    if {$errcount != 0} {
        error "cannot populate with configuration errors"
    }

    namespace upvar PopDef DomainName DomainName
    set DomainName $domain

    set popref [Population create Domain $domain]

    try {
        ral relvar transaction begin
        try {
            ConfigEvaluate [namespace current]::PopDef $script

            # At this point the population is complete and we can begin the
            # processing to validate that the population is correct.

            <<population: verify population integrity>>

            if {$errcount != 0} {
                ral relvar transaction rollback
                return
            }

            # Once we like the populated values supplied by the user we can use
            # them to set the values of the generated class components.

            <<population: set generated component values>>
            <<population: update union subclass numbering>>
        } on error {result opts} {
            ral relvar transaction rollback
            return -options $opts $result
        }
        ral relvar transaction end
    } on error {result} {
        # puts $::errorInfo
        HandleConfigError $result
        return
    }
}
----

There are two important other steps required for the initial instance
population.

. We must check that the specified population is correct and complete.
. There are a number of class components whose values are derived from
those specified in the population commands and we must calculate those
values in preparation for code generation.

These two steps are described <<verifying-population-integrity,later>>
after all the population commands have been considered.

=== Class

The `class` command (in the context of a population) is used to specify
the initial instances of a class.

*****
`class` _name_ _script_

`name`::
    The name of the class.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of class component values for a class.

The `class` command is used to define initial instances for a class.
*****

Populating a class entails specifying attribute and reference values
as well as setting space allocation and storage characteristics of the class.
As we said before,
the `micca` architecture allocates a fixed amount of space for each class.
This determines the maximum number of instances that may exist
simultaneously.
A class population can consist of initial instances as well as those
created at run time.
Initial instances may be deleted at run time and their space
is then available for newly created instances.
To control the amount of space allocated,
the `allocation` command can be used to set the additional number of instances
beyond the initial instances that are allocated.
The total number of simultaneous instances is then the sum of the
allocation amount and the initial instances.

Classes can also be allocated to read-only memory.
If there is no dynamic activity on a class, such as state models or
attribute updates,
then the attributes and references can be placed in constant memory.
For small embedded system this can be a significant saving of read/write
memory which is usually in shorter supply.

To accommodate the class population commands we need a namespace
in which to evaluate the script.

[source,tcl]
----
<<class instance config namespace layout>>=
namespace eval ClassInstDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<class instance commands>>
}
----

[float]
==== Implementation

(((micca,Config,class)))
[source,tcl]
----
<<population config commands>>=
proc class {name script} {
    if {$name eq {}} {
        tailcall DeclError BAD_NAME $name class
    }

    variable DomainName

    namespace upvar ClassInstDef ClassName ClassName Allocation Allocation
    set ClassName $name
    set Allocation 0

    ConfigEvaluate [namespace current]::ClassInstDef $script

    ElementPopulation create Domain $DomainName Element $name
    ClassPopulation create Domain $DomainName Class $name Allocation $Allocation

    return
}
----

=== Class Storage Allocation

*****
`allocate` ?_size_?

`size`::
    The number of additional class instances beyond those defined
    by the initial instances for which storage is allocated.

The `allocate` command is used declare that a class population is to have
_size_ additional storage slots allocated to it beyond those used
by the initial instance population.
If no `allocate` command is invoked for a class,
then the class will have zero additional instances allocated.
*****

[float]
==== Implementation

[source,tcl]
----
<<class instance commands>>=
proc allocate {{size 0}} {
    variable Allocation $size

    return
}
----

=== Specifying Instance Values [[specifying-instance-values]]

Instances are populated according to their class components.
Class components are of several types but primarily are either
attributes or references.

Attribute values are specified using strings in ``C'' syntax.
The attribute value will be passed along to the generated code file
and must be valid ``C'' initializers.
For example the value for an `int` attribute can be specified as
0x20 or 32 and the ``C'' compiler will handle either.

Reference components are more varied in how they are specified
but correspond to the way that referential attributes in the
analysis model refer to identifying attributes.
Since fundamentally references will resolve down to object addresses,
initializing references uses instance names as the place holder for
the class instance address.
The code generator then maps reference names to instance address expressions.
Different reference types require some additional structure.

* Simple associations require a single instance name.
The instance name must be one that is defined for the class to which the
reference refers.
It is specified using the name of the association followed by the
name of the referenced instance.
For example, an association defined as:
+
======
`association R27 X 1..*--1 Y`
======
+
would require that `X` instances specify a value for `R27`:
+
======
`instance x1 R27 y1`
======
+
which creates an instance named, `x1`, that references an instance of class,
`Y`, named, `y1`, across the `R27` association.

* Class based associations linkages is specified in the instances
of the association class.
Each associator class instance represents an instance of the association
itself and refers to both participants in the association.
For example, a class based association defined as:
+
======
`association R28 -associator A X 1..*--1..* Y`
======
+
would require that `A` instances specify a value for `R28` referring
to both an `X` instance and a `Y` instance:
+
======
`instance a1 R27 {X x1 Y y1}`
======
+
which creates an instance named, `a1`, that references an instance of class,
`X`, named `x1` and an instance of class, `Y`, named, `y1`,
across the `R28` association.
The order of specifying the participants does not matter.

* For class based associations that are reflexive, _i.e._ the same
class serves as both the source and target of the association,
we cannot use the class names to distinguish references.
In this case we use the words `forward` and `backward` to denote
which instances are reached by navigating the association in the
forward and backward directions.
For example, a reflexive class based association defined as:
+
======
`association R29 -associator A X 0..*--0..* X`
======
+
would require that `A` instances specify a value for `R28` referring
to which instance of `X` is reached when navigating forward and which
is reached navigating backward:
+
======
`instance a1 R27 {backward x1 forward x2}`
======
+
which creates an instance named, `a1`, that references an instance of class,
`X`, named `x2` when navigating forward and an instance of class, `X`,
named, `x1`, when navigating backward.
The order of specifying the forward and backward participants does not matter.

* For generalization relationships,
a reference to the superclass instance is specified in the subclass
instance.
For example, a generalization specified as:
+
======
`generalization R30 S A B C`
======
+
would require that `A`, `B`, or `C` instances specify a value for `R30`:
+
======
`instance c1 R30 s1`
======
+
which creates an instance named, `c1`, that references an instance of
the superclass, `S`, named, `s1`, across the `R30` generalization.
The specification of subclass to superclass references is the same
regardless of whether the generalization is a reference type or a
union type.

The default value for an attribute or reference is specified by the
literal string, "-".
It is an error to specify a default value for an attribute for which
no default was defined during the domain configuration.
The default value of a reference is the _nil_ reference,
which refers to no instance.
It is an error to specify the _nil_ value for a reference representing
an unconditional side of a relationship.
If an attribute value needs to be set to the literal "-" string,
then it must be escaped and written as, "\-".

=== Setting Instance Values

The `instance` command defines the class component values for an instance
and gives the instance a name.
It is a convenient way to specify a small number of class instances.

*****
`instance` _name_ _comp1 value1 comp2 value2 ..._

`name`::
    The name of the instance. Instance names must be unique within a
    class.
`compN valueN`::
    The remaining arguments are in the form of component name / component
    value pairs. All components of a class must be present except for
    those which have defined default values.

The `instance` command defines a class instance named, _name_, and
gives the class components given by the _compN_ arguments the
corresponding _valueN_ value.
*****

[float]
==== Implementation

We want the `instance` command to set the values for every class component
that can be set, _i.e._ we don't want any underdefined instances.
To do that,
we will determine if the component names provided are sufficient.
If they are, then we can create the Class Instance and the set
of Class Component Value instances.
The latter fall into two types,
those provided as arguments and those which are missing from the arguments but
for which a default value can be deduced.

[source,tcl]
----
<<class instance commands>>=
proc instance {name args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    <<instance: determine correct components>>

    set insttuple [list\
        Domain $DomainName\
        Class $ClassName\
        Instance $name\
    ]
    ClassInstance create {*}$insttuple\
        Number [GenNumber $DomainName ClassInstance [list $DomainName $ClassName]]

    <<instance: set values from arguments>>
    <<instance: set remaining defaulted values>>

    return
}
----

To determine if we have the correct components as arguments,
we need to find those components that must be set,
_i.e._ they have no reasonable default.
That set component names must be a subset of those provided as arguments.

[source,tcl]
----
<<instance: determine correct components>>=
set compnames [FindRequiredComponents $DomainName $ClassName]
set argcomps [dict keys $args]
set compdiff [struct::set difference $compnames $argcomps]
if {![struct::set empty $compdiff]} {
    tailcall DeclError MISSING_VALUES $DomainName $ClassName $name\
            [join $compdiff {, }]
}
----

(((error code,MISSING_VALUES)))
[source,tcl]
----
<<error code formats>>=
MISSING_VALUES  {for domain population, %s, class, %s,\
        instance, %s, values for class component(s),\
        "%s", is(are) not provided and have no default values}
----

All class components must be set to a value _except_ attributes that
have a default value, association references that can be set to _nil_
and dependent attributes.

[source,tcl]
----
<<helper commands>>=
proc FindRequiredComponents {domain class} {
    # The attributes that have default values do not require population values
    set defcomps [pipe {
        DefaultValue findWhere {$Domain eq $domain && $Class eq $class} |
        findRelated ~ R22 R29 R21
    }]
    # puts [relformat [deRef $defcomps] defcomps]

    # Dependent attributes require no population values
    set depattrs [pipe {
        DependentAttribute findWhere {$Domain eq $domain && $Class eq $class} |
        findRelated ~ R29 R21
    }]

    # Subtract from the set of populated components the components
    # that can be need not be supplied.
    return [pipe {
        PopulatedComponent findWhere {$Domain eq $domain && $Class eq $class} |
        refMinus ~ $defcomps |
        refMinus ~ $depattrs |
        deRef ~ |
        relation project ~ Name |
        relation list ~ Name
    }]
}
----

Create a Class Component Value instance for all the provided component
name / component values provided as arguments to the `instance` command.

[source,tcl]
----
<<instance: set values from arguments>>=
dict for {compname value} $args {
    set value [ResolveInitialValue $DomainName $ClassName $compname $value]
    ClassComponentValue create {*}$insttuple Component $compname Value $value
}

----

The class components that remain are to be set to default values.
So we specify "-" for those remaining components.

[source,tcl]
----
<<instance: set remaining defaulted values>>=
set defaultcomps [FindRemainingComponents $DomainName $ClassName $argcomps]
foreach compname $defaultcomps {
    set value [ResolveInitialValue $DomainName $ClassName $compname -]
    ClassComponentValue create {*}$insttuple Component $compname Value $value
}
----

[source,tcl]
----
<<helper commands>>=
proc FindRemainingComponents {domain class except} {
    set depattrs [pipe {
        DependentAttribute findWhere {$Domain eq $domain && $Class eq $class} |
        findRelated ~ R29 R21
    }]
    return [pipe {
        PopulatedComponent findWhere {$Domain eq $domain && $Class eq $class\
                && $Name ni $except} |
        refMinus ~ $depattrs |
        deRef ~ |
        relation list ~ Name
    }]
}
----

==== Resolving Initial Values

Because we introduced the "-" syntax for specifying default values,
we need to look up any defaults at instance population time.
This procedure does the work of insuring that the component exists
and if the default value was specified, makes sure such a default was defined
for the attribute or is the _nil_ reference value.

[source,tcl]
----
<<helper commands>>=
proc ResolveInitialValue {domain class component value} {
    set compref [PopulatedComponent findById\
        Domain $domain\
        Class $class\
        Name $component]
    if {[isEmptyRef $compref]} {
        error "component, \"$component\", is not a component that can be\
            populated"
    }
    if {$value eq "-"} {
        # Check for default attribute value
        set defref [findRelated $compref {~R21 Attribute}\
                {~R29 IndependentAttribute} ~R22]
        if {[isNotEmptyRef $defref]} {
            return [readAttribute $defref Value]
        }
        error "attribute $component does not have a default value"
    } else {
        set value [subst -nocommands -novariables $value]
    }

    return $value
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test populate-1.0 {
    population instances
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
            }
            class c2 {
                attribute c2_id int
            }
            association R1 -static c1 1..*--1 c2
        }

        population foo {
            class c1 {
                instance chuck1 c1_id 5 R1 fred1
                instance chuck2 c1_id 7 R1 fred1
            }
            class c2 {
                instance fred1 c2_id 20
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 3}\
        {[refMultiplicity [ClassComponentValue findAll]] == 6}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.1 {
    population instances using default values
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int -default 5
            }
            class c2 {
                attribute c2_id int
            }
            class ac {
            }
            association R1 -associator ac c1 1..*--0..1 c2
        }

        population foo {
            class c1 {
                # color attribute is defaulted
                instance chuck1 c1_id 5
                instance chuck2 c1_id 7 ; # not related to a c2
            }
            class c2 {
                instance fred1 c2_id 20
            }
            class ac {
                instance ac1 R1 {c1 chuck1 c2 fred1}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 3}\
        {[refMultiplicity [ClassInstance findAll]] == 4}\
        {[refMultiplicity [ClassComponentValue findAll]] == 10}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-1.2 {
    population fails for under specifying components
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int
            }
            class c2 {
                attribute c2_id int
            }
            class ac {
            }
            association R1 -associator ac c1 1..*--0..1 c2
        }

        population foo {
            class c1 {
                instance chuck1 c1_id 5 ; # missing color
                instance chuck2 c1_id 7 color 10
                instance chuck3 ; # missing c1_id and color
            }
            class c2 {
                instance fred1 c2_id 20
            }
            class ac {
                allocate 3
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----
endif::showtests[]

=== Tables of Instance Values

The `instance` command is useful for defining a small number of
initial instances, but can become tedious when larger number of instances
are involved.
For that case,
the `table` command is provided which allows class component values to
be specified in a more tabular layout without having to repeat the
class component names.

*****
`table` _heading_ _name1 values1 name2 values2 ..._

`heading`::
    A list of class component names that are to be specified in
    the remaining arguments
`nameN valuesN`::
    A list of instance names / instance value set pairs.
    Each _nameN_ argument gives the name of an instance to be initialized.
    Each corresponding _valueN_ argument is a list of values to be
    given the the instance.
    The number of values must match the number of component names in the
    _heading_ argument.
    Values are assigned to class components from the _valueN_ argument
    in the same order as the component names in the _heading_.

The `table` command is used to define initial instance values for
the class components.
The components to be initialized are given as a list in the _heading_ argument.
Subsequent arguments then give a name to the instance and a
list of class component values that correspond to _heading_.
Appropriately formatted,
the `table` command can show instance values in a more orderly tablular fashion
than the `instance` command and saves repeating class component names.
*****

[float]
==== Implementation

Our implementation of the `table` command follows from that of
the `instance` command.
The difference is that there is another iteration that allows multiple
instances to be created.

[source,tcl]
----
<<class instance commands>>=
proc table {heading args} {
    if {[llength $args] % 2 != 0} {
        tailcall DeclError ARG_FORMAT $args
    }

    upvar #0 [namespace parent]::DomainName DomainName
    variable ClassName

    <<table: determine correct components>>

    set insttuple [list\
        Domain $DomainName\
        Class $ClassName\
    ]

    dict for {instname compvalues} $args {
        if {[llength $heading] != [llength $compvalues]} {# <1>
            tailcall DeclError COMPONENT_MISMATCH $DomainName $ClassName\
                [llength $compvalues] [llength $heading]
        }
        dict set insttuple Instance $instname ; # <2>

        <<table: set values from arguments>>
        <<table: set remaining defaulted values>>
    }

    return
}
----
<1> The number values associated with each instance have to match the
heading.
<2> Each time through the loop, set up a new instance name.

(((error code,COMPONENT_MISMATCH)))
[source,tcl]
----
<<error code formats>>=
COMPONENT_MISMATCH  {for domain population, %s, class, %s,\
                    number of component values does not match heading:\
                    got %d values, expected %d values}
----

The `heading` argument must have all the component names that
cannot be defaulted in some way.

[source,tcl]
----
<<table: determine correct components>>=
set compnames [FindRequiredComponents $DomainName $ClassName]
set compdiff [struct::set difference $compnames $heading]
if {![struct::set empty $compdiff]} {
    tailcall DeclError COMPONENT_MISSING $DomainName $ClassName\
            [join $compdiff {, }]
}
----

(((error code,COMPONENT_MISSING)))
[source,tcl]
----
<<error code formats>>=
COMPONENT_MISSING   {for domain population, %s, class, %s,\
                    values for class component(s),\
                    "%s", is(are) not provided and have no default values}
----

We start by creating the Class Instance and setting up
Class Component Values that match the arguments.

[source,tcl]
----
<<table: set values from arguments>>=
ClassInstance create {*}$insttuple\
    Number [GenNumber $DomainName ClassInstance [list $DomainName $ClassName]]
foreach compname $heading compvalue $compvalues {
    set compvalue [ResolveInitialValue $DomainName $ClassName $compname\
            $compvalue]
    ClassComponentValue create {*}$insttuple Component $compname Value $compvalue
}
----

Finally, Class Component Value instances are created for any missing components
that can have a default value.

[source,tcl]
----
<<table: set remaining defaulted values>>=
set defaultcomps [FindRemainingComponents $DomainName $ClassName $heading]
foreach compname $defaultcomps {
    set compvalue [ResolveInitialValue $DomainName $ClassName $compname -]
    ClassComponentValue create {*}$insttuple Component $compname Value $compvalue
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test populate-2.0 {
    Population using tables
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
            }
            class c2 {
                attribute c2_id int
            }
            association R1 c1 1..*--1 c2
        }

        population foo {
            class c1 {
                allocate 10
                table   {c1_id      R1}\
                chuck1  {5          fred1}\
                chuck2  {7          fred1}
            }
            class c2 {
                table       {c2_id}\
                fred1       {20}
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 2}\
        {[refMultiplicity [ClassInstance findAll]] == 3}\
        {[refMultiplicity [ClassComponentValue findAll]] == 8}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test populate-2.1 {
    Population using tables and default values
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id int
                attribute color int -default 42
            }
            class c2 {
                attribute c2_id int
            }
            class ac {
            }
            association R1 -associator ac c1 1..*--0..1 c2
        }

        population foo {
            class c1 {
                allocate 10
                table   {c1_id}\
                chuck1  5\
                chuck2  7\
                chuck3  7
            }
            class c2 {
                table       {c2_id}\
                fred1       20
            }
            class ac {
                table       {R1}\
                ac1         {{c2 fred1 c1 chuck1}}\
                ac2         {{c2 fred1 c1 chuck2}}\
            }
        }
    }
    log::debug [formatMiccaClass ClassPopulation]
    log::debug [formatMiccaClass ClassInstance]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassPopulation findAll]] == 3}\
        {[refMultiplicity [ClassInstance findAll]] == 6}\
        {[refMultiplicity [ClassComponentValue findAll]] == 15}
} -result {1}
----
endif::showtests[]

=== Populating Multiple Assigners

For multiple assigners,
it is necessary to specify which instances of the identifying class
is associated to the assigner.
The only information needed to define an assigner is its name
and the name of the instance of the identifying class corresponding to the
assigner.

We start with the now familiar namespace definition.

[source,tcl]
----
<<assigner instance config namespace layout>>=
namespace eval AssignerInstDef {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::micca::@Config@::ConfigEvaluate
    namespace path {::micca ::micca::@Config@::Helpers ::rosea::InstCmds}

    <<assigner instance commands>>
}
----

=== Assigner

The `assigner` command (in the context of a population) is used to specify
the initial instances of an assigner

*****
`assigner` _association_ _script_

`association`::
    The name of the assocition which has a multiple assigner.
`script`::
    A Tcl Script that is evaluated in a context to allow the definition
    of assigner values.

The `assigner` command is used to define initial instances for an assigner.
*****

[float]
==== Implementation

(((micca,Config,assigner)))
[source,tcl]
----
<<population config commands>>=
proc assigner {assoc script} {
    variable DomainName

    set maref [MultipleAssigner findById Domain $DomainName Association $assoc]
    if {[isEmptyRef $maref]} {# <1>
        tailcall DeclError UNKNOWN_MULT_ASSIGNER $assoc
    }

    namespace upvar AssignerInstDef AssocName AssocName IdClass IdClass
    set AssocName $assoc
    set IdClass [readAttribute $maref Class]

    ConfigEvaluate [namespace current]::AssignerInstDef $script

    if {[isEmptyRef [ElementPopulation findById Domain $DomainName\
            Element $assoc]]} {
        ElementPopulation create Domain $DomainName Element $assoc
        AssignerPopulation create Domain $DomainName Association $assoc
    }

    return
}
----
<1> We need to know the identifying class and insist it is define by this
point.

=== Populating An Assigner Instance

The `instance` command (in the context of an assigner) is used to specify
the initial instance of the identifying class assocated with the assigner
instance.

*****
`instance` _name_ _idinstance_

`name`::
    The name of the assigner instance.
`idinstance`::
    The name of the identifying instance associated with the assigner.
    The _idinstance_ must be an instance defined for the identifying
    class associated with the multiple assigner.

The `instance` command is used to define initial instances for an assigner.
*****

[float]
==== Implementation

[source,tcl]
----
<<assigner instance commands>>=
proc instance {name idinstance} {

    upvar #0 [namespace parent]::DomainName DomainName
    variable AssocName
    variable IdClass

    MultipleAssignerInstance create\
        Domain $DomainName\
        Association $AssocName\
        Instance $name\
        Number [GenNumber $DomainName MultipleAssignerInstance\
            [list $DomainName $AssocName]]\
        IdClass $IdClass\
        IdInstance $idinstance

    return
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test populate-3.0 {
    Populate a multiple assigner
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class clerk {
            }
            class client {
            }
            class service {
            }
            association R1 -associator service clerk 0..1--0..1 client {
                identifyby department
                statemodel {
                    defaulttrans IG

                    state waitingForClerk {} {
                    }
                    transition waitingForClerk - clerkReady -> waitingForClient

                    state waitingForClient {} {
                    }
                    transition waitingForClient - clientReady -> assigningClerk

                    state assigningClerk {} {
                    }
                    transition assigningClerk - clerkAssigned -> waitingForClerk
                }
            }
            class department {
            }
            association R2 department 1..*--1 clerk
        }

        population foo {
            class clerk {
                instance fred
                instance alice
                instance john
            }
            class client {
                allocate 10
            }
            class service {
                allocate 3
            }
            class department {
                instance shoes R2 fred
                instance mens R2 alice
                instance housewares R2 john
            }
            assigner R1 {
                instance shoeclerks shoes
                instance mensclerks mens
                instance housewaresclerks housewares
            }
        }
    }
    log::debug [formatMiccaClass AssignerPopulation]
    log::debug [formatMiccaClass MultipleAssignerInstance]
    log::debug [formatMiccaClass ClassInstance]
    testConditions\
        {[refMultiplicity [AssignerPopulation findAll]] == 1}\
        {[refMultiplicity [MultipleAssignerInstance findAll]] == 3}\
} -result {1}
----
endif::showtests[]

=== Verifying Population Integrity [[verifying-population-integrity]]

Once a population has been gather by the `population` command,
we perform some verification on the population to make sure it
is correct and we will be able to proceed to code generations.
We inspect several factors:

* We insist that there be some population for every domain element
that can have values.
* All classes that are not union subclasses must have either a set
of initial instances or an allocation greater than 0 or both.
Since union subclasses are stored within their superclass,
they do not have a separate storage pool.
* We know which associations are static and can
make the final decision about reference storage.
* All initial instances that make references to other class instances must
have their references specified so we can make sure that the references
themselves are correct and that there is no referential integrity problems with
the initial instance population.

There is a substantial amount of code required to perform this verification.
This is the result of the different types of references that are
supported and the fact that the value of class component is taken
as a simple string.
The format and content of an initial value string depends upon the
context of the initialization and so each has to be examined.
The simple string nature of initial values means we cannot take
advantage of referential integrity and other declarative means to
insure correctness.
Hence, there will be a lot of code.

We verify the population in three steps.

[source,tcl]
----
<<population: verify population integrity>>=
<<population: check completeness>>
<<population: check class populations>>
<<population: check reference values>>
----

==== Checking Completeness

Value Elements in the platform model are the entities that can have
initial instance population values.
We want to query all the Value Elements that have no corresponding Element
Population in the Population.
These are the missing elements that were not included in the population.
Two types of values elements can remain unpopulated:

* A union subclass has no separate storage pool since its values are stored
as part of its related superclass instance.
This is true despite the fact that union subclass instances are defined
in the same manner as any other class instance.
* A multiple assigner initial instance population need not be specified
since the number of instances of a multiple assigner is bound by
the number of instances of its identifying class.

Note that instances of union superclasses must have related union subclasses,
so we will insist that referential integrity is preserved.
But if all the related instances of a union superclass happen to exclude
a particular union subclass, then that is not an error.
The case for reference subclasses is different.
Since they have memory allocated for them, we will insist that there be
space for at least one instance or else it would not be possible for
a reference superclass to be related to that particular reference subclass.

[source,tcl]
----
<<population: check completeness>>=
set usubs [pipe {
    UnionSubclass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation project ~ Domain Class |
    relation rename ~ Class Name
}] ; # <1>
set massigners [pipe {
    MultipleAssigner findWhere {$Domain eq $domain} |
    deRef ~ |
    relation project ~ Domain Association |
    relation rename ~ Association Name
}]
set missing [pipe {
    findRelated $popref {R101 ElementPopulation} |
    findUnrelated ~ R101 |
    deRef ~ |
    relation minus ~ $usubs |
    relation minus ~ $massigners
}] ; # <2>
if {[relation isnotempty $missing]} {
    tailcall DeclError MISSING_POPULATION $domain\
        [join [relation list $missing Name] {, }]
}
----
<1> Arrange for the union subclasses and multiple assigners
to have a heading that is compatible with the Value Element heading.
We will want to do a subtraction operation in the next step and need
a compatible heading.
<2> Here we are looking for the Value Elements that are _unrelated_
to the population. They are the ones for which no values were specified.
We subtract off the union subclasses and multiple assigners
so they are not diagnosed as missing.

(((error code,MISSING_POPULATION)))
[source,tcl]
----
<<error code formats>>=
MISSING_POPULATION    {for domain population, "%s", the following elements\
                       are missing any population values: "%s"}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test populate-4.0 {
    Population missing elements
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class c1 {
                attribute c1_id int
                attribute c1_color {char const*}
            }
            class c2 {
                attribute c2_id int
                attribute temp int -default 25
            }
        }

        population bar {
            class c1 {
                instance fred1 c1_id 20 c1_color {"blue"}
            }
            # no population for "c2"
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

==== Checking Class Allocation

For class populations,
the maximum number of simultaneous instances is the sum of the
initial instance population plus the number of additional storage locations
allocated in the `allocate` command.
If both these quantities sum to zero,
then it is not possible to ever have an instance of the class and
the ``C'' compiler will not let us declare an array variable with 0 elements.

[source,tcl]
----
<<population: check class populations>>=
# First, we need the set of class component values and class
# instances that are part of the population of this domain.
set popinstrefs [ClassInstance findWhere {$Domain eq $domain}]
set popinsts [deRef $popinstrefs]
# puts [relformat $popinsts popinsts]
set popvalues [pipe {
    findRelated $popinstrefs {R103 ClassComponentValue} |
    deRef ~
}]

# puts [relformat $popvalues popvalues]
set noinsts [pipe {
    ClassPopulation findWhere {$Domain eq $domain && $Allocation == 0} |
    deRef ~ |
    ralutil::rvajoin ~ $popinsts Instances |
    relation restrictwith ~ {[relation isempty $Instances]}
}] ; # <1>

if {[relation isnotempty $noinsts]} {
    tailcall DeclError NO_INSTANCES $domain\
        [join [relation list $noinsts Class] {, }]
}
----
<1> The `rvajoin` command performs the relational equivalent of
an _outer join_ but with no `NUL` values.
The result has a relation valued attribute (hence the name `rvajoin`)
whose cardinality matches the number of matched tuples in the join.
In this case,
we are looking for where the relation valued attribute
(`Instances` in this case)
is empty, indicating that there were no matching instances in the population.
We will see this construct often in the population validation
code as we frequently are looking for when there are _no_ matches within
a set.

(((error code,NO_INSTANCES)))
[source,tcl]
----
<<error code formats>>=
NO_INSTANCES    {for domain population, "%s", the following classes have no\
                defined instances and a zero allocation: "%s"}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test populate-4.2 {
    class population with no instances and 0 allocation
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class c1 {
                attribute c1_id int
                attribute c1_color {char const*}
            }
            class c2 {
                attribute c2_id int
                attribute temp int -default 25
            }
        }

        population bar {
            class c1 {
                instance fred1 c1_id 20 c1_color {"blue"}
            }
            class c2 {
                allocate 0 ; # the allocate command insures we a c2 population
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

==== Checking Reference Values

The values given to reference components for a population are
<<specifying-instance-values,simply strings>>
that must refer to instances names of the proper class.
We need to go though all the values for the various types of references
and make sure they were specified correctly.
There are three distinct types of references in the platform model.

[source,tcl]
----
<<population: check reference values>>=
<<population: check association references>>
<<population: check associator references>>
<<population: check subclass references>>
----

==== Checking Association Reference Values

When a class is the referring class in a simple association,
the value corresponding to the class component for the association is the
name of an instance of the referenced class.

The first step in the check is to assemble a relation value whose
heading has all the information we need.
This information will include the classes that participate in the
association as well as the value of the reference from the referring
class to the referenced class.

[source,tcl]
----
<<population: check association references>>=
set simprefs [pipe {
    SimpleReferringClass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Role |
    relation rename ~ Class ReferringClass\
        Conditionality ReferringCond Multiplicity ReferringMult|
    relation join ~ $::micca::SimpleReferencedClass |
    relation eliminate ~ Role |
    relation rename ~ Class ReferencedClass Relationship Component |
    relation join ~ $popvalues -using\
        {Domain Domain ReferringClass Class Component Component} |
    relation rename ~ Instance ReferringInstance Value ReferencedInstance
}]
# puts [relformat $simprefs simprefs]
----

[float]
==== Checking Referenced Instances

First we check for references to instances that do not exist.

[source,tcl]
----
<<population: check association references>>=
set badrefs [pipe {
    relation rename $simprefs ReferencedClass Class ReferencedInstance Instance |
    ralutil::rvajoin ~ $popinsts Instances |
    relation restrictwith ~ {[relation isempty $Instances]}
}] ; # <1>
# puts [relformat $badrefs badrefs]
relation foreach badref $badrefs {
    relation assign $badref
    log::error "for domain population, $Domain,\
        instance, $ReferringClass.$ReferringInstance, refers to\
        instance, $Class.$Instance across,\
        $Component, but $Class.$Instance does not exist"
    incr errcount
}
----
<1> We join against the instances to determine the matches for
the `ReferencedClass` and `ReferencedInstance`.
If there is no match, then the relation valued attribute will have
a cardinality of zero and we have found a reference to an instance
that does not exist.

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test simpleassociation-1.0 {
    refer to non-existant instance
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }
            class Y {
            }
            association R1 X 1--1 Y
        }

        population bar {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2   ; # y2 does not exist
            }
            class Y {
                instance y1
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test simpleassociation-1.1 {
    refer to non-existant instance -- reflexive association
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }
            association R1 X 1--1 X
        }

        population bar {
            class X {
                instance x1 R1 y2
                instance x2 R1 x1
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----
endif::showtests[]

[float]
==== Removing Bad References

We subtract out the bad references so that we can continue the checking.
To do the subtraction, we need a compatible heading and that takes
a bit of manipulation of names and the effects of the `rvajoin`.

[source,tcl]
----
<<population: check association references>>=
set simprefs [pipe {
    relation eliminate $badrefs Instances |
    relation rename ~ Class ReferencedClass Instance ReferencedInstance |
    relation minus $simprefs ~
}]
# puts [relformat $simprefs simprefs]
----

[float]
==== Checking Referenced Multiplicity

For a simple association,
the referring class always refers to either _exactly one_ instance or
_at most one_ instance.
The conditionality of the reference is handled in the population code
by insisting that a value be given for the class component that represents
the association reference if the association is indeed unconditional.

It remains to check the multiplicity and conditionality of the
referring class in the association.
For the multiplicity,
we need to count the number of times an instance of the
referenced class shows up as a reference by the referring class.
If that number is greater than one,
the we insist the association be multiple on the referring side.

[source,tcl]
----
<<population: check association references>>=
set refedmults [pipe {
    relation eliminate $simprefs ReferringCond |
    relation group ~ ReferringInstances ReferringInstance |
    relation restrictwith ~ {!$ReferringMult &&\
        [relation cardinality $ReferringInstances] > 1}
}] ; # <1>
# puts [relformat $refedmults refedmults]
relation foreach refedmult $refedmults {
    relation assign $refedmult
    log::error "for domain population, $Domain,\
        relationship, $Component, is singular from\
        $ReferringClass to $ReferencedClass, but instance, $ReferencedInstance,\
        is referred to by multiple instances:\
        [join [relation list $ReferringInstances] {, }]"
    incr errcount
}
----
<1> By grouping the `ReferringInstance` attribute,
we are computing the set of instances of the referring class that
reference the same instance of the referenced class.
This is allowed to be greater than one only if multiplicity is true
on the referring side.

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test simpleassociation-2.0 {
    multiple reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }
            class Y {
            }
            association R1 X 1--1 Y
        }

        population bar {
            class X {
                instance x1 R1 y1
                instance x2 R1 y1 ; # y1 referred to multiple times
            }
            class Y {
                instance y1
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

[float]
==== Checking Referenced Conditionality

Checking the conditionality of the references requires a slightly
different strategy.
Here we are interested in determining if all the instances of
the referenced class in the association are actually referred to by
some instance of the referring class.
If some of the instances of the referenced class do not show up,
then the association must be conditional on the referring side.

The strategy for this query is to group the referenced instances as
a relation valued attribute.
Then we can perform an `rvajoin` against the instances in the population
to determine the total set of referenced instances.
The relation valued attributes from these two operation must be equal
if the association is unconditional on the referring side,
_i.e._ unconditionality implies that all possible instances of the
referenced class appear as an actual reference by the referring class
instances.
There is a minor complication in the query since to compare the two
relation values they must have the same heading, so some juggling of the
attribute names is required.

[source,tcl]
----
<<population: check association references>>=
set refingconds [pipe {
    relation project $simprefs Domain Component ReferringClass ReferringCond\
        ReferencedClass ReferencedInstance |
    relation rename ~ ReferencedClass Class ReferencedInstance Instance |
    relation group ~ ReferencedInstances Instance |
    ralutil::rvajoin ~ [relation eliminate $popinsts Number] Instances |
    relation restrictwith ~\
        {!$ReferringCond && [relation is $ReferencedInstances != $Instances]}
}]
# puts [relformat $refingconds refingconds]

relation foreach refingcond $refingconds {
    relation assign $refingcond
    set notrefed [relation minus $Instances $ReferencedInstances]
    log::error "for domain population, $Domain,\
        relationship, $Component, is unconditional from\
        $Class to $ReferringClass, but the\
        \"[join [relation list $notrefed] {, }]\" instance(s) of $Class\
        is(are) not referred to by any instance of $ReferringClass"
    incr errcount
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test simpleassociation-3.0 {
    unconditional reference -- many to one
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }
            class Y {
            }
            association R1 X 1..*--1 Y
        }

        population bar {
            class X {
                instance x1 R1 y1
                instance x2 R1 y2
            }
            class Y {
                instance y1
                instance y2
                instance y3 ; # not referenced
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test classassociation-3.1 {
    unconditional reference -- many to at most one
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {
            }
            class Y {
            }
            class A {
            }
            association R1 -associator A X 1..*--0..1 Y
        }

        population bar {
            class X {
                instance x1
                instance x2
                instance x3
            }
            class Y {
                instance y1
                instance y2
                instance y3 ; # not referenced
            }
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test simpleassociation-3.2 {
    reflexive unconditional reference -- many to one
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {}
            association R1 X 1..*--1 X
        }

        population bar {
            class X {
                instance x1 R1 x2
                instance x2 R1 x2
            }
            # x1 not referenced
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

==== Checking Associator Reference Values

The associator class in a class based association always makes
unconditional references to each of the participants in the association.
Since there is a one-to-one correspondence between the associator class
instances and instances of the association itself,
the references by an associator class cannot be `nil`.
There are a couple of complications when dealing with associator
references.
First, we are dealing with references to two classes and do not
want to impose any particular order on the mention of classes
in the instance value.
We are expecting a four element list of the form:
.....
{<oneclass> <oneinstance> <otherclass> <otherinstance>}
.....
where <oneclass> and <otherclass> are class names of the participants
in the association and <oneinstance> and <otherinstance> are instance
names of the corresponding classes.

The second complication arises with reflexive associations.
In this case, the references are both to the same class.
We resolve the directional ambiguity by expecting an initial value of the form:
.....
{forward <forwinstance> backward <backinstance>}
.....
where <forwinstance> is the instance reached when traversing the association
in its forward direction and <backinstance> is that reached when traversing
in the backward direction (reflexivity means we cannot determine direction
from the class names alone).
The order of the `forward` and `backward` pairs is arbitrary.

We start with a query that is analogous to the one for simple associations.
We gather all the information together in one relation value
and we will use this base relation value as the starting point for
other queries below.
In the case of class based association, we have information for
the associator class and both participants.

[source,tcl]
----
<<population: check associator references>>=
set assocs [pipe {
    AssociatorClass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Role |
    relation rename ~ Class AssocClass |
    relation join ~ $::micca::SourceClass |
    relation eliminate ~ Role |
    relation rename ~ Class SourceClass Conditionality SourceCond\
            Multiplicity SourceMult |
    relation join ~ $::micca::TargetClass |
    relation eliminate ~ Role |
    relation rename ~ Class TargetClass Conditionality TargetCond\
            Multiplicity TargetMult Relationship Component |
    relation join ~ $popvalues -using\
        {Domain Domain AssocClass Class Component Component} |
    relation rename ~ Instance AssocInstance
}]
# puts [relformat $assocs assocs]
----

The query starts with the Associator Class and then joins on the
relation values for the participants.
Attributes that are not needed, _e.g._ `Role`, are removed and
attributes must be renamed to avoid naming conflicts as the
relation value is built up.
Finally, we can join in the values of the association class instances
which have the references that we are attempting to validate.

We first check that the class component value is a proper four element list
as is required for associative references.

[source,tcl]
----
<<population: check associator references>>=
set badvalues [relation restrictwith $assocs {[llength $Value] != 4}]
relation foreach badvalue $badvalues {
    relation assign $badvalue
    log::error "for domain population, $Domain,\
        instance, $AssocClass.$AssocInstance, has a bad format for the\
        value of the associative reference for, $Component:\
        expected a four element list, got: \"$Value\""
    incr errcount
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test associator-1.0 {
    associator class reference -- bad format
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 1--1 Y
        }

        population bar {
            class A {
                instance a1 R1 {X x1} ; # bad format of R1 value
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

To continue checking,
we subtract out the references with badly formatted values.
Subsequent steps in the validation assume that the values have the
correct form.

[source,tcl]
----
<<population: check associator references>>=
set assocs [relation minus $assocs $badvalues]
----

Next we split out the reflexive and non-reflexive associations.
These must be treated differently.

[source,tcl]
----
<<population: check associator references>>=
set nrassocs [relation restrictwith $assocs {$SourceClass ne $TargetClass}]
set rassocs [relation minus $assocs $nrassocs]
----

For the non-reflexive case,
the value forms a four element list consisting of class name/instance name
pairs.
The class names must match the names of the association participants.

[source,tcl]
----
<<population: check associator references>>=
set nonparts [relation restrictwith $nrassocs {![::struct::set equal\
        [list [lindex $Value 0] [lindex $Value 2]]\
        [list $SourceClass $TargetClass]]}]
# puts [relformat $nonparts nonparts]
relation foreach nonpart $nonparts {
    relation assign $nonpart
    lassign $Value oneclass oneinst otherclass otherinst
    if {$oneclass eq $otherclass} {
        log::error "for domain population, $Domain,\
            associator instance, $AssocClass.$AssocInstance,
            the reference value, $Value, duplicates the reference\
            to class, $oneclass"
        incr errcount
    } else {
        set refedclasses [list $SourceClass $TargetClass]
        foreach {class instance} $Value {
            if {![::struct::set contains $refedclasses $class]} {
                log::error "for domain population, $Domain,\
                    associator instance, $AssocClass.$AssocInstance,\
                    references class instance, $class.$instance, across,\
                    $Component, but $class does not participate in $Component"
                incr errcount
            }
        }
    }
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test associator-2.0 {
    associator class reference to non-participating classes
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 1--1 Y
        }

        population bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {Z x2 Q y2} ; # Z nor Q participate in R1
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----
endif::showtests[]

Now we expand the `Value` attribute into separate attributes for
the two references.
We will do the same for reflexive associations later and
this will make it easier both to join the code flow back together
and to examine the references in both directions.

[source,tcl]
----
<<population: check associator references>>=
set nrassocs [pipe {
    relation minus $nrassocs $nonparts |
    relation extend ~ nrtup\
        TargetInstance string {[dict get [tuple extract $nrtup Value]\
            [tuple extract $nrtup TargetClass]]}\
        SourceInstance string {[dict get [tuple extract $nrtup Value]\
            [tuple extract $nrtup SourceClass]]} |
    relation eliminate ~ Value
}] ; # <1>
----
<1> In this query,
we treat the `Value` attribute as a dictionary.
We are allowed to do this since the `Value` string is of the form of
a proper dictionary.

Now we do the corresponding checks for reflexive associations.

[source,tcl]
----
<<population: check associator references>>=
set baddirs [relation restrictwith $rassocs\
    {![struct::set equal [dict keys $Value] {forward backward}]}]
relation foreach baddir $baddirs {
    relation assign $baddir
    log::error "for domain population, $Domain,\
        instance, $AssocClass.$AssocInstance, has a bad format for the\
        value of component, $Component: expected a dictionary\
        with \"forward\" and \"backward\" keys, got: \"$Value\""
    incr errcount
}

set rassocs [relation minus $rassocs $baddirs]
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test associator-1.1 {
    associator class reference -- bad format for reflexive reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {}
            class X {}

            association R1 -associator A X 1--1 X
        }

        population bar {
            class A {
                instance a1 R1 {forward x1 back x2} ; # bad format of R1 value
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

We can now expand the reflexive value into separate attributes.
Notice that the `forward` direction is a reference to an instance of the
`TargetClass`.

[source,tcl]
----
<<population: check associator references>>=
set rassocs [pipe {
    relation extend $rassocs rtup\
        TargetInstance string {[dict get [tuple extract $rtup Value] forward]}\
        SourceInstance string {[dict get [tuple extract $rtup Value] backward]} |
    relation eliminate ~ Value
}]
----

After expanding the `Value` attribute appropriately,
the headings for the non-reflexive and reflexive cases are the same
and so we can combine them back together for the remainder of the
processing.

[source,tcl]
----
<<population: check associator references>>=
set assocs [relation union $nrassocs $rassocs]
# puts [relformat $assocs assocs]
----

[float]
==== Checking Associator References

At this point we know the associator component values are of the proper
format and have split the value into separate attributes.
This makes it easier to check whether the associator references are to
actual instances.

[source,tcl]
----
<<population: check associator references>>=
set badsrcrefs [pipe {
    relation rename $assocs SourceClass Class SourceInstance Instance |
    relation project ~ Domain Class Component Instance AssocClass AssocInstance |
    ralutil::rvajoin ~ $popinsts Instances |
    relation restrictwith ~ {[relation isempty $Instances]}
}]
set badtrgrefs [pipe {
    relation rename $assocs TargetClass Class TargetInstance Instance |
    relation project ~ Domain Class Component Instance AssocClass AssocInstance |
    ralutil::rvajoin ~ $popinsts Instances |
    relation restrictwith ~ {[relation isempty $Instances]}
}] ; # <1>

set badrefs [relation union $badsrcrefs $badtrgrefs]
# puts [relformat $badrefs badrefs]
relation foreach badref $badrefs {
    relation assign $badref
    log::error "for domain population, $Domain,\
        instance, $AssocClass.$AssocInstance, refers to\
        instance, $Class.$Instance across,\
        $Component, but $Class.$Instance does not exist"
    incr errcount
}
----
<1> You might be tempted to factor the `rvajoin` statement in the
`badsrcrefs` and `badtrgrefs` expressions into the common code below.
However, such a refactoring will fail for the reflexive association
case.
Although we have changed the attribute names to make the two relation
union compatible,
what the attributes represent is quite different between the two
statements and the `relation union` operation ignores that
difference.
You might also be tempted to refactor the `relation restrictwith` operation.
However, the `badsrcrefs` and `badtrgrefs` values are used below to
remove those bad references.

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test associator-3.0 {
    associator class reference to non-existent instances
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 1--1 Y
        }

        population bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2} ; # x2 and y2 don't exist
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test associator-3.1 {
    reflexive associator class reference to non-existent instances
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {
            }
            class X {
            }

            association R1 -associator A X 0..*--0..* X
        }

        population bar {
            class A {
                instance a1 R1 {forward x2 backward x1}
                instance a2 R1 {forward x3 backward x2} ; # x3 doesn't exist
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

[float]
==== Removing Bad References

To continue checking,
we will remove any bad references.
Since we have modified the heading in the `badsrcrefs` and `badtrgrefs`
relations, we will use the `semiminus` operation to find the
good references.

[source,tcl]
----
<<population: check associator references>>=
set assocs [pipe {
    relation semiminus $badsrcrefs $assocs -using\
        {Domain Domain Component Component AssocClass AssocClass\
        AssocInstance AssocInstance Class SourceClass Instance SourceInstance} |
    relation semiminus $badtrgrefs ~ -using\
        {Domain Domain Component Component AssocClass AssocClass\
        AssocInstance AssocInstance Class TargetClass Instance TargetInstance}
}]
# puts [relformat $assocs assocs]
----

[float]
==== Checking Duplicate Associator References

The references made by an instance of an associator class must
form a set,
_i.e._ you cannot have two associator class instances that refer to
the same two participating class instances.

[source,tcl]
----
<<population: check associator references>>=
set duprefs [pipe {
    relation project $assocs Domain Component AssocClass AssocInstance\
        SourceClass SourceInstance TargetClass TargetInstance |
    relation group ~ References AssocInstance |
    relation restrictwith ~ {[relation cardinality $References] > 1}
}]
# puts [relformat $duprefs duprefs]
relation foreach dupref $duprefs {
    relation assign $dupref
    log::error "for domain population, $Domain,\
        associative class, $AssocClass, instances,\
        [join [relation list $References] {, }],\
        all refer to both $SourceClass.$SourceInstance and\
        $TargetClass.$TargetInstance across, $Component:\
        associative class reference pairs must be unique"
    incr errcount
}
# Remove duplicate references
set assocs [pipe {
    relation ungroup $duprefs References |
    relation semiminus ~ $assocs -using\
        {Domain Domain Component Component AssocClass AssocClass\
        AssocInstance AssocInstance}
}]
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test associator-4.0 {
    associator class -- duplicate references
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 1--1 Y
        }

        population bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x1 Y y1} ; # duplicate of a1
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

[float]
==== Checking Associative Multiplicity

We can now check the referential integrity of the class based association
references.
The pattern of the query is analogous to the one we used for simple
associations.
We want to count the number of times an instance of a Source Class or
Target Class is referenced by the Associator Class.
We then compare that to the multiplicity specified for the association.
Note,
the inversion of the multiplicity from source to target.
We have seen this before with class based association.
If you count the number of associator instances that refer to a particular
source class instance it is the target side multiplicity that determines
the allowed values for that count, and _vice versa_.

[source,tcl]
----
<<population: check associator references>>=
set srcreftos [pipe {
    relation project $assocs Domain Component AssocClass AssocInstance\
        SourceClass SourceInstance TargetMult |
    relation rename ~ SourceClass Class SourceInstance Instance\
        TargetMult Multiplicity |
    relation group ~ AssocInstances AssocInstance
}]
# puts [relformat $srcreftos srcreftos]

set trgreftos [pipe {
    relation project $assocs Domain Component AssocClass AssocInstance\
        TargetClass TargetInstance SourceMult |
    relation rename ~ TargetClass Class TargetInstance Instance\
        SourceMult Multiplicity |
    relation group ~ AssocInstances AssocInstance
}]
# puts [relformat $trgreftos trgreftos]

set reftos [pipe {
    relation union $srcreftos $trgreftos |
    relation restrictwith ~ {!$Multiplicity &&\
        [relation cardinality $AssocInstances] > 1}
}]
# puts [relformat $reftos reftos]
relation foreach refto $reftos {
    relation assign $refto
    log::error "for domain population, $Domain,\
        class based association, $Component, is singular to, $Class,\
        but instance, $Instance,\
        is referred to multiple times by associative class, $AssocClass,\
        instances: [join [relation list $AssocInstances] {, }]"
    incr errcount
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test associator-5.0 {
    class based association with multiple source class references
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {}
            class Y {}
            class A {}

            association R1 -associator A X 1--1 Y
        }

        population bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1} ; # multiple references to y1
            }
            class X {
                instance x1
                instance x2
            }
            class Y {
                instance y1
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test associator-5.1 {
    class based association with multiple target class references
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {}
            class Y {}
            class A {}

            association R1 -associator A X 1--1 Y
        }

        population bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x1 Y y2} ; # multiple references to x1
            }
            class X {
                instance x1
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test associator-5.2 {
    reflexive class based association with multiple target class references
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class X {}
            class A {}

            association R1 -associator A X 1--1 X
        }

        population bar {
            class A {
                instance a1 R1 {backward x1 forward x2}
                instance a2 R1 {backward x1 forward x3}
                instance a3 R1 {backward x2 forward x1}

                # multiple "backward" references to x1
                # x3 not referenced "backward"
            }
            class X {
                instance x1
                instance x2
                instance x3
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----
endif::showtests[]

[float]
==== Checking Associative Conditionality

Again, we use a query that is a counterpart to the one used for
simple associations.
We wish to find all the source and target instances that are referenced
by an associator class instance and then compare that to the total
set of instances of the participating class.
If the association is unconditional, then the two set must be the same.
Once again note the swap of source and target conditionality values
when performing the check.

[source,tcl]
----
<<population: check associator references>>=
set srcconds [pipe {
    relation project $assocs Domain Component AssocClass\
            SourceClass SourceInstance TargetCond |
    relation rename ~ SourceClass Class SourceInstance Instance\
            TargetCond Conditionality |
    relation group ~ ReferencedInstances Instance |
    ralutil::rvajoin ~ [relation eliminate $popinsts Number] Instances
}]
# puts [relformat $srcconds srcconds]

set trgconds [pipe {
    relation project $assocs Domain Component AssocClass\
            TargetClass TargetInstance SourceCond |
    relation rename ~ TargetClass Class TargetInstance Instance\
            SourceCond Conditionality |
    relation group ~ ReferencedInstances Instance |
    ralutil::rvajoin ~ [relation eliminate $popinsts Number] Instances
}]
# puts [relformat $trgconds trgconds]

set badconds [pipe {
    relation union $srcconds $trgconds |
    relation restrictwith ~ {!$Conditionality &&\
            [relation is $ReferencedInstances != $Instances]}
}]
# puts [relformat $badconds badconds]
relation foreach badcond $badconds {
    relation assign $badcond
    set notrefed [relation minus $Instances $ReferencedInstances]
    log::error "for domain population, $Domain,\
        class based association, $Component, requires all instances of $Class\
        to be referenced, but the \"[join [relation list $notrefed] {, }]\"\
        instance(s) of $Class is(are) not referenced by any instance\
        of $AssocClass"
    incr errcount
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test associator-6.0 {
    missing target class reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 1..*--0..1 Y
        }

        population bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
                instance y3 ; # y3 not referenced
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test associator-6.1 {
    missing source class reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class A {}
            class X {}
            class Y {}

            association R1 -associator A X 1..*--1..* Y
        }

        population bar {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
            }
            class Y {
                instance y1
                instance y2
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

==== Checking Subclass Reference Values

The generalization relationship represents a disjoint union of
the subclasses.
The implications of this are:

* Each subclass instance must unconditionally refer to exactly one
instance of the superclass of the generalization.
* Each superclass instance must be referenced by exactly one subclass
instance from among all the subclass instances in the generalization.

We follow the same query stategy as we used above.
First we construct a relation value that contains all the information
about the superclasses and subclasses in the generalization.

[source,tcl]
----
<<population: check subclass references>>=
set subrefs [pipe {
    Subclass findWhere {$Domain eq $domain} |
    deRef ~ |
    relation eliminate ~ Role |
    relation rename ~ Class SubClass |
    relation join ~ $::micca::Superclass |
    relation eliminate ~ Role |
    relation rename ~ Class SuperClass Relationship Component |
    relation join ~ $popvalues -using\
        {Domain Domain SubClass Class Component Component} |
    relation rename ~ Instance SubClassInstance Value SuperClassInstance
}]
# puts [relformat $subrefs subrefs]
----

We can now check to references to superclasses that don't exist.

[source,tcl]
----
<<population: check subclass references>>=
set badrefs [pipe {
    relation rename $subrefs SuperClass Class SuperClassInstance Instance |
    ralutil::rvajoin ~ $popinsts Instances |
    relation restrictwith ~ {[relation isempty $Instances]}
}]
# puts [relformat $badrefs badrefs]

relation foreach badref $badrefs {
    relation assign $badref
    log::error "for domain population, $Domain, generalization, $Component,\
        subclass instance, $SubClass.$SubClassInstance, references\
        superclass instance, $Class.$Instance, but $Instance does not exist"
    incr errcount
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-1.0 {
    subclass reference to bad superclass instance
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }

        population bar {
            class super {
                instance super1
            }
            class sub1 {
                instance sub1_1 R1 super1
            }
            class sub2 {
                instance sub2_1 R1 super3 ; # no "super3" instance
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

We subtract out the bad references so that we can proceed with the next
checks.

[source,tcl]
----
<<population: check subclass references>>=
set subrefs [pipe {
    relation eliminate $badrefs Instances |
    relation rename ~ Class SuperClass Instance SuperClassInstance |
    relation minus $subrefs ~
}]
# puts [relformat $subrefs subrefs]
----

[float]
==== Checking Subclass Reference Multiplicity

No superclass instance may be referenced multiple times.
Here we compute the multiplcity of the references.
This query is analogous to the ones we did for associative relationships
except here we know that it must be singular.

[source,tcl]
----
<<population: check subclass references>>=
set multirefs [pipe {
    relation group $subrefs SubClassReferences SubClass SubClassInstance |
    relation restrictwith ~ {[relation cardinality $SubClassReferences] > 1}
}]
# puts [relformat $multirefs multirefs]
relation foreach multiref $multirefs {
    relation assign $multiref
    relation foreach sref $SubClassReferences {
        relation assign $sref
        lappend screfs $SubClass.$SubClassInstance
    }
    log::error "for domain population, $Domain, generalization, $Component,\
        superclass instance, $SuperClass.$SuperClassInstance, is referenced by\
        multiple subclass instances, \"[join $screfs {, }]\":\
        this violates the referential integrity of generalizations"
    incr errcount
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-2.0 {
    multiple superclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }

        population bar {
            class super {
                instance super1
            }
            class sub1 {
                instance sub1_1 R1 super1
            }
            class sub2 {
                instance sub2_1 R1 super1 ; # Multiple reference to super1
            }
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

[float]
==== Checking Subclass Reference Conditionality

All superclass instances must be referred to by some subclass instance.
In that sense the generalization is unconditional.

[source,tcl]
----
<<population: check subclass references>>=
set unrefeds [pipe {
    relation rename $subrefs SuperClass Class SuperClassInstance Instance |
    relation eliminate ~ SubClass SubClassInstance |
    relation group ~ ReferencedSupers Instance |
    ralutil::rvajoin ~ [relation eliminate $popinsts Number] Instances |
    relation restrictwith ~ {[relation is $ReferencedSupers != $Instances]}
}]
# puts [relformat $unrefeds unrefeds]

relation foreach unrefed $unrefeds {
    relation assign $unrefed
    set notrefeds [pipe {
        relation minus $Instances $ReferencedSupers |
        relation list ~
    }]
    foreach notrefed $notrefeds {
        log::error "for domain population, $Domain, generalization, $Component,\
            superclass instance, $Class.$notrefed, is not referenced by any\
            subclass: this violates the referential integrity of\
            generalizations"
        incr errcount
    }
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test generalization-3.0 {
    unreferenced superclass
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {}
            class sub1 {}
            class sub2 {}
            generalization R1 super sub1 sub2
        }

        population bar {
            class super {
                instance super1
                instance super2
                instance super3
            }
            class sub1 {
                instance sub1 R1 super1
            }
            class sub2 {
                instance sub2 R1 super2
            }
            # super3 not referenced
        }
    }
} -result {encountered 1 configuration script errors} -returnCodes error
----
endif::showtests[]

=== Calculating Generated Component Values

The platform model has a number of classes that are subclasses of
*Generated Component*.
These classes all have the same characteristic that their values can
be calculated from the values of the class components specified in the
initial instance population.
All of these calculated component values are in some sense redundant.
They are all involved in generating the data required to navigate
relationships and enforce referential integrity.

Recall that the way `micca` deals with relationships is to store
pointer values in the instances of all participants in a relationship
so that the relationship can be navigated directly in either direction.
This is a space/speed tradeoff that makes it much easier to
both navigate relationships and to enforce referential integrity
at the end of a data transaction.
In the `population` command,
relationship references are specified only in their most fundamental form,
_i.e._ as references from referring classes to named instances.
That is sufficient information to compute the references in the opposite
direction.
This is what the *Generated Component* instances hold.
A further complication relates to two other factors:

. An association may be specified as static, in which case we choose
a more space efficient arrangement to store the reference pointer values.
. A generalization may be held as a union, in which case its related
instance is stored directly in the memory slot allocated to the superclass
instance.

Examining the platform model,
we see that there are four primary generated components whose values
we must calculate.
Of the four,
values for the *Link Container* are computed when the values for the
*Link Reference* are computed since the two components form a doubly linked
list.

[source,tcl]
----
<<population: set generated component values>>=
set gencomps [GeneratedComponent findWhere {$Domain eq $domain}]

<<population: set complementary reference values>>
<<population: set subclass reference values>>
<<population: set subclass container values>>
----

==== Calculating Complementary Reference Values

A *Complementary Reference* is a pointer reference from a referred to
class instance back to the referring class instance.
For simple associations,
it is the reference that enables navigating the association in the
_backward_ direction directly by pointer indirection.
There are three different types of complementary references:

. Singular references are held as a single pointer value and can be used
when the multiplicity of the relationships is one.
. Array references are held as a counted array of pointer values and
are used for static associations when the multiplicity is greater than one.
. Link references are held as a doubly-linked list and
are used for dynamic associations when the multiplicity is greater than one.

In addition,
a *Complementary Reference* is either a backward reference, _i.e._ used
to navigate the association in _backward_ direction, or a foward reference
used to navigate in the _forward_ direction.

[source,tcl]
----
<<population: set complementary reference values>>=
<<population: set singular reference values>>
<<population: set array reference values>>
<<population: set link reference values>>
----

Since Complementary References are references that arise out of
associative relationships,
there are three classes where they appear:

. Simple Referenced Classes have a reference to their corresponding
Simple Referring Class
. Target Classes refer to the Associator class in class based associations.
. Source Classes also refer to the Associator class in class based
associations and are used to navigate the class based association
in the forward direction.

So for each of the three ways of storing reference pointers there are
also three different classes that need to have references generated for
them.
Below we take up each case individually.

==== Singular Reference Values

[source,tcl]
----
<<population: set singular reference values>>=
set singlerefs [pipe {
    SingularReference findWhere {$Domain eq $domain} |
    findRelated % R26 {~R28 BackwardReference} ~R94
} {} |%]
# puts [relformat [deRef $singlerefs] singlerefs]

<<population: set singular referenced class values>>
<<population: set singular target class values>>
<<population: set singular source class values>>
----

==== Singular Backward Reference Values

Backward complementary references arise in two situations:

. A Simple Referenced Class refers to a Simple Referring Class when
navigating an association in the _backward_ direction.
. A Target Class refers to the Associator Class when navigating a
class based association in the _backward_ direction.

[source,tcl]
----
<<population: set singular referenced class values>>=
set simprefedclass [findRelated $singlerefs {~R38 SimpleReferencedClass}]
# Compute the referenced made by the refering class instances.
set refingrefs [pipe {
    deRef $simprefedclass |
    relation eliminate ~ Role |
    relation rename ~ Class ReferencedClass |
    relation join ~ $::micca::SimpleReferringClass |
    relation rename ~ Class ReferringClass Relationship Component |
    relation eliminate ~ Role Conditionality Multiplicity |
    relation join ~ $popvalues -using\
        {Domain Domain Component Component ReferringClass Class} |
    relation update ~ sbtup {1} {
        tuple update $sbtup Component "[tuple extract $sbtup Component]__BACK"}
}]
# puts [relformat $refingrefs refingrefs]

# Now we have to split out the nil references
# Invert referring and referenced formating a new value to show
# which instances referenced by the referring class.
set backrefs [pipe {
    relation restrictwith $refingrefs {$Value ne "@nil@"} |
    relation extend ~ sbtup NewValue string {[list\
        [tuple extract $sbtup ReferringClass]\
        [tuple extract $sbtup Instance]]} |
    relation eliminate ~ ReferringClass Instance |
    relation rename ~ ReferencedClass Class Value Instance NewValue Value
}]
# puts [relformat $backrefs backrefs]

foreach backref [relation body $backrefs] {
    ClassComponentValue create {*}$backref
}

CreateNilDestBackRefs $simprefedclass $backrefs
----

We can factor out some common code for creating the back references
for conditional associations where we have `nil` reference values.

(((micca,Helpers,CreateNilDestBackRefs)))
[source,tcl]
----
<<helper commands>>=
proc CreateNilDestBackRefs {refedclasses backrefs} {
    set nilbackrefs [FindNilDestBackRefs $refedclasses $backrefs]
    # puts [relformat $nilbackrefs nilbackrefs]
    foreach nilbackref [relation body $nilbackrefs] {
        ClassComponentValue create {*}$nilbackref Value @nil@
    }
}
----

(((micca,Helpers,FindNilDestBackRefs)))
[source,tcl]
----
<<helper commands>>=
proc FindNilDestBackRefs {refedclasses backrefs} {
    # Find the components for the Referenced Classes regardless of value.
    # The difference between this set and those components where a value
    # was specified must be the set of components whose value are nil.
    set valueinsts [relation project $backrefs Domain Class Component Instance]
    set nilrefs [pipe {
        findRelated $refedclasses R38 R94 |
        deRef ~ |
        relation project ~ Domain Class Name |
        relation rename ~ Name Component |
        relation join ~ $::micca::ClassInstance |
        relation eliminate ~ Number |
        relation minus ~ $valueinsts
    }]
    # puts [relformat $nilrefs nilrefs]
    return $nilrefs
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test singlebackref-1.0 {
    Class based association with singular back reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class X {
            }
            class Y {
            }
            class AXY {
            }
            class Z {
            }
            class AXZ {
            }
            association R1 -associator AXY X 0..1--0..1 Y
            association R2 -associator AXZ X 0..1--0..1 Z
        }

        population foo {
            class AXY {
                instance axy1 R1 {X x1 Y y1}
                instance axy2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3 ; # not referenced
            }
            class Y {
                instance y1
                instance y2
                instance y3 ; # not referenced
            }
            class AXZ {
                allocate 3
            }
            class Z {
                instance z1
                instance z2
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 13}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test singlebackref-1.1 {
    Class association singular back reference -- no initial instances
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class X {}
            class Y {}
            class A {}
            association R1 -associator A X 0..1--0..1 Y
        }

        population foo {
            class A {
                allocate 5
            }
            class X {
                allocate 5
            }
            class Y {
                instance y1
                instance y2
                instance y3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 3}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test singlebackref-1.2 {
    Class association singular back reference -- reflexive
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class X {}
            class A {}
            association R1 -associator A X 0..1--0..1 X
        }

        population foo {
            class A {
                instance a1 R1 {forward x2 backward x1}
                instance a2 R1 {forward x1 backward x2}
            }
            class X {
                instance x1
                instance x2
                instance x3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 8}
} -result {1}
----
endif::showtests[]

Because a Target Class is part of a class based association,
its backward references will be to the associator class itself.

[source,tcl]
----
<<population: set singular target class values>>=
set trgclass [findRelated $singlerefs {~R38 TargetClass}]
set trgrefing [pipe {
    deRef $trgclass |
    relation eliminate ~ Role Conditionality Multiplicity |
    relation rename ~ Class TargetClass |
    relation join ~ $::micca::AssociatorClass |
    relation rename ~ Class AssociatorClass |
    relation eliminate ~ Role |
    relation join ~ $::micca::SourceClass |
    relation rename ~ Class SourceClass Relationship Component |
    relation eliminate ~ Role Conditionality Multiplicity |
    relation rename ~ AssociatorClass Class |
    ralutil::rvajoin ~ $popvalues Values |
    relation update ~ sbtup {1} {
        tuple update $sbtup Component "[tuple extract $sbtup Component]__BACK"}
}]
# puts [relformat $trgrefing trgrefing]

set trgbackrefs [pipe {
    relation restrictwith $trgrefing {[relation isnotempty $Values]} |
    relation ungroup ~ Values |
    relation rename ~ Class AssociatorClass
}]
# puts [relformat $trgbackrefs trgbackrefs]
----

At this point we split out the reflexive versus the non-reflexive case.
As usual with class based associations,
reflexive association require special handling.

For the non-reflexive case,
we extract the reference to the Target Class.

[source,tcl]
----
<<population: set singular target class values>>=
set nrtrgbackrefs [pipe {
    relation restrictwith $trgbackrefs {$SourceClass ne $TargetClass} |
    relation extend ~ tbtup TargetInstance string {[dict get\
        [tuple extract $tbtup Value] [tuple extract $tbtup TargetClass]]}
}]
# puts [relformat $nrtrgbackrefs nrtrgbackrefs]
----

For the reflexive case, we extract the reference for the *forward*
direction.
It is the forward direction reference for which we need to create a back
reference.

[source,tcl]
----
<<population: set singular target class values>>=
set rtrgbackrefs [pipe {
    relation restrictwith $trgbackrefs {$SourceClass eq $TargetClass} |
    relation extend ~ tbtup TargetInstance string {[dict get\
        [tuple extract $tbtup Value] forward]}
}]
# puts [relformat $rtrgbackrefs rtrgbackrefs]
----

Once we have extracted the correct reference value,
then we can combine the processing going on.
The goal is to create a relation value whose heading matches
the attributes of the *Class Component Value* class in the platform model.

[source,tcl]
----
<<population: set singular target class values>>=
set backrefs [pipe {
    relation union $nrtrgbackrefs $rtrgbackrefs |
    relation extend ~ brtup NewValue string {[list\
        [tuple extract $brtup AssociatorClass]\
        [tuple extract $brtup Instance]]} |
    relation eliminate ~ AssociatorClass SourceClass Instance Value |
    relation rename ~ TargetClass Class TargetInstance Instance NewValue Value
}]
# puts [relformat $backrefs backrefs]
----

Note that the value computed for the back reference contains both the
class name and instance name of the reference.
This is to make code generation easier so that we don't have to look
up the association to determine to which class the reference is intended.

With the relation value in hand,
it is a simple matter to create the necessary component values.

[source,tcl]
----
<<population: set singular target class values>>=
foreach backref [relation body $backrefs] {
    ClassComponentValue create {*}$backref
}

CreateNilDestBackRefs $trgclass $backrefs
----

==== Singular Forward Reference Values

The Complementary References for a Source Class are used to navigate
the association in the forward direction.
The query for Source Classes is much the same as for Target Classes
with the two attribute names inverted.

[source,tcl]
----
<<population: set singular source class values>>=
set srcclass [pipe {
    SingularReference findWhere {$Domain eq $domain} |
    findRelated % R26 {~R28 ForwardReference} ~R95
} {} |%]
set srcrefing [pipe {
    deRef $srcclass |
    relation eliminate ~ Role Conditionality Multiplicity |
    relation rename ~ Class SourceClass |
    relation join ~ $::micca::AssociatorClass |
    relation rename ~ Class AssociatorClass |
    relation eliminate ~ Role |
    relation join ~ $::micca::TargetClass |
    relation rename ~ Class TargetClass Relationship Component |
    relation eliminate ~ Role Conditionality Multiplicity |
    relation rename ~ AssociatorClass Class |
    ralutil::rvajoin ~ $popvalues Values |
    relation update ~ sbtup {1} {
        tuple update $sbtup Component "[tuple extract $sbtup Component]__FORW"}
}]
# puts [relformat $srcforwrefs srcforwrefs]

set srcforwrefs [pipe {
    relation restrictwith $srcrefing {[relation isnotempty $Values]} |
    relation ungroup ~ Values |
    relation rename ~ Class AssociatorClass
}]
----

Again we must deal with the reflexive and non-reflexive cases
separately so that we can interpret the value of the reference properly.

[source,tcl]
----
<<population: set singular source class values>>=
set nrsrcforwrefs [pipe {
    relation restrictwith $srcforwrefs {$SourceClass ne $TargetClass} |
    relation extend ~ tbtup SourceInstance string {[dict get\
        [tuple extract $tbtup Value] [tuple extract $tbtup SourceClass]]}
}]
# puts [relformat $nrsrcforwrefs nrsrcforwrefs]

set rsrcforwrefs [pipe {
    relation restrictwith $srcforwrefs {$SourceClass eq $TargetClass} |
    relation extend ~ tbtup SourceInstance string {[dict get\
        [tuple extract $tbtup Value] backward]}
}]
# puts [relformat $rsrcforwrefs rsrcforwrefs]
----

Combining the two cases back,
we compute the component values.

[source,tcl]
----
<<population: set singular source class values>>=
set forwrefs [pipe {
    relation union $nrsrcforwrefs $rsrcforwrefs |
    relation extend ~ frtup NewValue string {[list\
        [tuple extract $frtup AssociatorClass]\
        [tuple extract $frtup Instance]]} |
    relation eliminate ~ AssociatorClass TargetClass Instance Value |
    relation rename ~ SourceClass Class SourceInstance Instance NewValue Value
}]
# puts [relformat $forwrefs forwrefs]
----

Finally, the forward reference values are created.

[source,tcl]
----
<<population: set singular source class values>>=
foreach forwref [relation body $forwrefs] {
    ClassComponentValue create {*}$forwref
}

CreateNilSourceForwRefs $srcclass $forwrefs
----

The case of `nil` references from Source Classes can also be factored
away.
The processing is very similar to that for destination back references.

(((micca,Helpers,CreateNilSourceForwRefs)))
[source,tcl]
----
<<helper commands>>=
proc CreateNilSourceForwRefs {srcclasses forwrefs} {
    set nilforwrefs [FindNilSourceForwRefs $srcclasses $forwrefs]
    # puts [relformat $nilforwrefs nilforwrefs]
    foreach nilforwref [relation body $nilforwrefs] {
        ClassComponentValue create {*}$nilforwref Value @nil@
    }
}
----

(((micca,Helpers,FindNilSourceForwRefs)))
[source,tcl]
----
<<helper commands>>=
proc FindNilSourceForwRefs {refedclasses forwrefs} {
    # Find the components for the Referenced Classes regardless of value.
    # The difference between this set and those components where a value
    # was specified must be the set of components whose value are nil.
    set valueinsts [relation project $forwrefs Domain Class Component Instance]
    set nilrefs [pipe {
        findRelated $refedclasses R95 |
        deRef ~ |
        relation project ~ Domain Class Name |
        relation rename ~ Name Component |
        relation join ~ $::micca::ClassInstance |
        relation eliminate ~ Number |
        relation minus ~ $valueinsts
    }]
    # puts [relformat $nilrefs nilrefs]
    return $nilrefs
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test singlebackref-2.0 {
    Class based association singular back reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..1--0..1 Y
        }

        population foo {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
            }
            class Y {
                instance y1
                instance y2
                instance y3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 8}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test singlebackref-2.1 {
    Class based association singular back reference -- no linkage
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {}
            class X {}
            class Y {}
            association R1 -associator A X 0..1--0..1 Y
        }

        population foo {
            class A {
                allocate 3
            }
            class X {
                instance x1
                instance x2
                instance x3
            }
            class Y {
                instance y1
                instance y2
                instance y3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 6}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test singlebackref-2.2 {
    Class based association singular back reference -- reflexive
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {
            }
            class X {
            }
            association R1 -associator A X 0..1--0..1 X
        }

        population foo {
            class A {
                instance a1 R1 {forward x2 backward x1}
                instance a2 R1 {forward x3 backward x2}
            }
            class X {
                instance x1
                instance x2
                instance x3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 8}
} -result {1}
----
endif::showtests[]

==== Array Reference Values

When the multiplicity of an association is greater than one
and the association has been declared static,
then we can use a more convenient means to store the required
pointer values, namely, a counted array.
Again,
we will consider each of the three cases separately.

[source,tcl]
----
<<population: set array reference values>>=
set arrayrefs [pipe {
    ArrayReference findWhere {$Domain eq $domain} |
    findRelated % R26 {~R28 BackwardReference} ~R94
} {} |%]
# puts [relformat [deRef $arrayrefs] arrayrefs]

<<population: set array referenced class values>>
<<population: set array target class values>>
<<population: set array source class values>>
----

First we examine the simple referenced classes.

[source,tcl]
----
<<population: set array referenced class values>>=
set arrayrefedclass [findRelated $arrayrefs {~R38 SimpleReferencedClass}]
set refingrefs [FindSimpleReferringRefs $arrayrefedclass $popvalues]
# puts [relformat $refingrefs refingrefs]
set backrefs [pipe {
    FindSimpleBackRefs $refingrefs |
    relation eliminate ~ Relationship
}]
# puts [relformat $backrefs backrefs]

foreach backref [relation body $backrefs] {
    ClassComponentValue create {*}$backref
}

CreateNilDestBackRefs $arrayrefedclass $backrefs
----

As it turns out,
the query needed for array type pointer storage is the same as that
needed for linked list storage (they are both multiple in nature).
The only difference between the two is how the queried information is
generated into the code.
So we can factor out the query for simple backward references.
We will also factor out the other cases below.

(((micca,Helpers,FindSimpleReferringRefs)))
(((micca,Helpers,FindSimpleBackRefs)))
[source,tcl]
----
<<helper commands>>=
proc FindSimpleReferringRefs {refedclasses popvalues} {
    return [pipe {
        deRef $refedclasses |
        relation eliminate ~ Role |
        relation rename ~ Class ReferencedClass |
        relation join ~ $::micca::SimpleReferringClass |
        relation rename ~ Class ReferringClass |
        relation eliminate ~ Role Conditionality Multiplicity |
        relation join ~ $popvalues -using\
            {Domain Domain Relationship Component ReferringClass Class} |
        relation extend ~ abtup\
            Component string {"[tuple extract $abtup Relationship]__BACK"}
    }]
}

proc FindSimpleBackRefs {refingrefs} {
    return [pipe {
        relation group $refingrefs Instances Instance |
        relation extend ~ abtup\
            NewValue string {[list [tuple extract $abtup ReferringClass]\
                [relation list [tuple extract $abtup Instances]]]} |
        relation eliminate ~ ReferringClass Instances |
        relation rename ~ ReferencedClass Class Value Instance NewValue Value
    }]
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test arraybackref-1.0 {
    Class association array back reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class X {}
            class Y {}
            class AXY {}
            association R1 -associator AXY -static X 0..*--0..1 Y

            class Z {}
            class AXZ {}
            association R2 -associator AXZ -static X 0..*--0..1 Z
        }

        population foo {
            class AXY {
                instance axy1 R1 {X x1 Y y1}
                instance axy2 R1 {X x2 Y y1}
                instance axy3 R1 {X x3 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
                instance y3
            }
            class AXZ {
                allocate 4
            }
            class Z {
                instance z1
                instance z2
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 16}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test arraybackref-1.1 {
    Class based association array back reference -- reflexive
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class X {}
            class A {}
            association R1 -associator A -static X 0..*--0..1 X
        }

        population foo {
            class A {
                instance a1 R1 {forward x3 backward x1}
                instance a2 R1 {forward x3 backward x2}
                instance a3 R1 {forward x1 backward x3}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 11}
} -result {1}
----
endif::showtests[]

For target class references we have the following.

[source,tcl]
----
<<population: set array target class values>>=
set trgclass [findRelated $arrayrefs {~R38 TargetClass}]
set refingrefs [FindTargetReferringRefs $trgclass $popvalues]
# puts [relformat $refingrefs refingrefs]
set backrefs [pipe {
    FindTargetBackRefs $refingrefs |
    relation eliminate ~ Relationship
}]
# puts [relformat $backrefs backrefs]

foreach backref [relation body $backrefs] {
    ClassComponentValue create {*}$backref
}

CreateNilDestBackRefs $trgclass $backrefs
----

Again, finding the target back references can be shared with the
linked list references below.

(((micca,Helpers,FindTargetBackRefs)))
[source,tcl]
----
<<helper commands>>=
proc FindTargetReferringRefs {refedclasses popvalues} {
    set backrefs [pipe {
        deRef $refedclasses |
        relation eliminate ~ Role Conditionality Multiplicity |
        relation rename ~ Class TargetClass |
        relation join ~ $::micca::AssociatorClass |
        relation rename ~ Class AssociatorClass |
        relation eliminate ~ Role |
        relation join ~ $::micca::SourceClass |
        relation rename ~ Class SourceClass |
        relation eliminate ~ Role Conditionality Multiplicity |
        relation join ~ $popvalues -using\
            {Domain Domain Relationship Component AssociatorClass Class}
    }]
    # puts [relformat $backrefs backrefs]

    # Non-reflexive
    set nrtrgbackrefs [pipe {
        relation restrictwith $backrefs {$SourceClass ne $TargetClass} |
        relation extend ~ tbtup TargetInstance string {[dict get\
            [tuple extract $tbtup Value] [tuple extract $tbtup TargetClass]]}
    }]
    # puts [relformat $nrtrgbackrefs nrtrgbackrefs]

    # Reflexive
    set rtrgbackrefs [pipe {
        relation restrictwith $backrefs {$SourceClass eq $TargetClass} |
        relation extend ~ tbtup TargetInstance string {[dict get\
            [tuple extract $tbtup Value] forward]}
    }]
    # puts [relformat $rtrgbackrefs rtrgbackrefs]
    return [pipe {
        relation union $nrtrgbackrefs $rtrgbackrefs |
        relation eliminate ~ SourceClass Value |
        relation extend ~ brtup\
            Component string {"[tuple extract $brtup Relationship]__BACK"}
    }]
}

proc FindTargetBackRefs {refingrefs} {
    return [pipe {
        relation group $refingrefs Instances Instance |
        relation extend ~ brtup\
            NewValue string {[list\
                [tuple extract $brtup AssociatorClass]\
                [relation list [tuple extract $brtup Instances]]]} |
        relation eliminate ~ AssociatorClass Instances |
        relation rename ~ TargetClass Class TargetInstance Instance NewValue Value
    }]
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test arraybackref-2.0 {
    Class based association array back reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {
            }
            class X {
            }
            class Y {
            }
            association R1 -static -associator A X 0..*--0..1 Y
        }

        population foo {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
                instance a3 R1 {X x3 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
                instance y3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 10}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test arraybackref-2.1 {
    Class based association array back reference -- reflexive
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {
            }
            class X {
            }
            association R1 -static -associator A X 0..*--0..1 X
        }

        population foo {
            class A {
                instance a1 R1 {backward x1 forward x2}
                instance a2 R1 {backward x2 forward x3}
                instance a3 R1 {backward x3 forward x2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 11}
} -result {1}
----
endif::showtests[]

An lastly, the forward references made by source classes.

[source,tcl]
----
<<population: set array source class values>>=
set srcclass [pipe {
    ArrayReference findWhere {$Domain eq $domain} |
    findRelated % R26 {~R28 ForwardReference} ~R95
} {} |%]

set refingrefs [FindSourceReferringRefs $srcclass $popvalues]
# puts [relformat $refingrefs refingrefs]
set forwrefs [pipe {
    FindSourceForwRefs $refingrefs |
    relation eliminate ~ Relationship
}]
# puts [relformat $forwrefs forwrefs]

foreach forwref [relation body $forwrefs] {
    ClassComponentValue create {*}$forwref
}

CreateNilSourceForwRefs $srcclass $forwrefs
----

And we factor out the finding of these references for later use.

(((micca,Helpers,FindSourceForwRefs)))
[source,tcl]
----
<<helper commands>>=
proc FindSourceReferringRefs {refedclasses popvalues} {
    set forwrefs [pipe {
        deRef $refedclasses |
        relation eliminate ~ Role Conditionality Multiplicity |
        relation rename ~ Class SourceClass |
        relation join ~ $::micca::AssociatorClass |
        relation rename ~ Class AssociatorClass |
        relation eliminate ~ Role |
        relation join ~ $::micca::TargetClass |
        relation rename ~ Class TargetClass |
        relation eliminate ~ Role Conditionality Multiplicity |
        relation join ~ $popvalues -using\
            {Domain Domain Relationship Component AssociatorClass Class}
    }]
    # puts [relformat $forwrefs forwrefs]

    # Non-reflexive
    set nrsrcforwrefs [pipe {
        relation restrictwith $forwrefs {$SourceClass ne $TargetClass} |
        relation extend ~ tbtup SourceInstance string {[dict get\
            [tuple extract $tbtup Value] [tuple extract $tbtup SourceClass]]}
    }]
    # puts [relformat $nrsrcforwrefs nrsrcforwrefs]

    # Reflexive
    set rsrcforwrefs [pipe {
        relation restrictwith $forwrefs {$SourceClass eq $TargetClass} |
        relation extend ~ tbtup SourceInstance string {[dict get\
            [tuple extract $tbtup Value] backward]}
    }]
    # puts [relformat $rsrcforwrefs rsrcforwrefs]
    return [pipe {
        relation union $nrsrcforwrefs $rsrcforwrefs |
        relation eliminate ~ TargetClass Value |
        relation extend ~ frtup\
            Component string {"[tuple extract $frtup Relationship]__FORW"}
    }]
}

proc FindSourceForwRefs {refingrefs} {
    return [pipe {
        relation group $refingrefs Instances Instance |
        relation extend ~ frtup\
            NewValue string {[list\
                [tuple extract $frtup AssociatorClass]\
                [relation list [tuple extract $frtup Instances]]]} |
        relation eliminate ~ AssociatorClass Instances |
        relation rename ~ SourceClass Class SourceInstance Instance NewValue Value
    }]
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test arrayforwref-1.0 {
    Class based association array forward references
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {
            }
            class X {
            }
            class Y {
            }
            association R1 -static -associator A X 0..*--0..* Y
        }

        population foo {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
                instance a3 R1 {X x3 Y y2}
                instance a4 R1 {X x1 Y y2}
                instance a5 R1 {X x1 Y y3}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
                instance y3
                instance y4
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 13}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test arrayforwref-1.1 {
    Class based association array forward reference -- reflexive
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {}
            class X {}
            association R1 -static -associator A X 0..*--0..* X
        }

        population foo {
            class A {
                instance a1 R1 {backward x1 forward x2}
                instance a2 R1 {backward x2 forward x3}
                instance a3 R1 {backward x3 forward x2}
                instance a4 R1 {backward x1 forward x3}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 12}
} -result {1}
----

[source,c]
----
<<config command tests>>=
test arrayforwref-1.2 {
    Class based association array forward reference -- reflexive, empty refs
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain codegen5_1 {
            class A {}
            class X {}
            association R1 -static -associator A X 0..*--0..* X
        }
        population codegen5_1 {
            class A {
                instance a1 R1 {forward x2 backward x1}
            }
            class X {
                instance x1
                instance x2
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 5}
} -result {1}
----
endif::showtests[]

[source,tcl]
----
<<population: set link reference values>>=
set linkbackrefs [pipe {
    LinkReference findWhere {$Domain eq $domain} |
    findRelated % R26 {~R28 BackwardReference} ~R94
} {} |%]

<<population: set link referenced class values>>
<<population: set link target class values>>
<<population: set link source class values>>
----

The third manner in which references are stored is as linked lists.
For dynamic association,
inserting and removing instances from linked lists is much easier than
dealing with an array based storage.
Of course,
the linkage pointers require more space and that is why both alternatives
are supported.

For simple backward references,
we use the same means to find them, but use different code to create
the linked references.

[source,tcl]
----
<<population: set link referenced class values>>=
set linkrefedclass [findRelated $linkbackrefs {~R38 SimpleReferencedClass}]

set refingrefs [FindSimpleReferringRefs $linkrefedclass $popvalues]
# puts [relformat $refingrefs refingrefs]
set backrefs [FindSimpleBackRefs $refingrefs]
# puts [relformat $backrefs backrefs]

CreateLinkedRefs $backrefs BLINKS

CreateNilLinkedBackRefs $linkrefedclass $backrefs
----

Because the related class instances are threaded onto linked lists,
we have a list terminus in the referring class and link containers in
the other participant classes.
We must have a way that any given instance may be threaded onto multiple
lists and it is quite possible for any given class to participate in
multiple associations.
The function below creates both the Link Reference values as well as
the Link Container values in the referenced class instances.
It does this by traversing the list of related instances and generating
values corresponding to the class, instance and component of the reference.

(((micca,Helpers,CreateLinkedRefs)))
[source,tcl]
----
<<helper commands>>=
proc CreateLinkedRefs {backrefs compname} {
    foreach backref [relation body $backrefs] {
        lassign [dict get $backref Value] refing insts
        set relship [dict get $backref Relationship]
        set next [list $refing [lindex $insts 0] ${relship}__$compname]
        set prev [list $refing [lindex $insts end] ${relship}__$compname]
        ClassComponentValue create\
            Domain [dict get $backref Domain]\
            Class [dict get $backref Class]\
            Instance [dict get $backref Instance]\
            Component [dict get $backref Component]\
            Value [dict create next $next prev $prev]

        set instindex 0
        set terminus [list\
            [dict get $backref Class]\
            [dict get $backref Instance]\
            [dict get $backref Component]\
        ]
        set prev $terminus
        for {set value [lindex $insts $instindex]} {$value ne {}}\
                {set value [lindex $insts [incr instindex]]} {
            if {$instindex < [llength $insts] - 1} {
                set next [list\
                    $refing\
                    [lindex $insts $instindex+1]\
                    ${relship}__$compname\
                ]
            } else {
                set next $terminus
            }
            ClassComponentValue create\
                Domain [dict get $backref Domain]\
                Class $refing\
                Instance $value\
                Component ${relship}__$compname\
                Value [dict create next $next prev $prev]
            set prev [list\
                $refing\
                $value\
                ${relship}__$compname\
            ]
        }
    }
}
----

(((micca,Helpers,CreateNilLinkedBackRefs)))
[source,tcl]
----
<<helper commands>>=
proc CreateNilLinkedBackRefs {refedclasses backrefs} {
    set nilbackrefs [FindNilDestBackRefs $refedclasses $backrefs]
    # puts [relformat $nilbackrefs nilbackrefs]
    CreateNilLinkedRefs $nilbackrefs
}
----

(((micca,Helpers,CreateNilLinkedRefs)))
[source,tcl]
----
<<helper commands>>=
proc CreateNilLinkedRefs {nilbackrefs} {
    relation foreach nilbackref $nilbackrefs {
        relation assign $nilbackref
        ClassComponentValue create\
            Domain $Domain\
            Class $Class\
            Instance $Instance\
            Component $Component\
            Value [dict create\
                next [list $Class $Instance $Component]\
                prev [list $Class $Instance $Component]\
            ]
    }
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test linkbackref-1.0 {
    Class based association link back reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class X {}
            class Y {}
            class A {}
            association R1 -associator A X 0..*--0..1 Y
        }

        population foo {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
                instance a3 R1 {X x3 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
                instance y3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 13}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test linkbackref-1.1 {
    Class association link back reference with no actual references
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class X {}
            class Y {}
            class A {}
            association R1 -associator A X 0..*--0..1 Y
        }

        population foo {
            class A {
                allocate 4
            }
            class X {
                allocate 4
            }
            class Y {
                instance y1
                instance y2
                instance y3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 3}
} -result {1}
----
endif::showtests[]

ifdef::showtests[]
[source,tcl]
----
<<config command tests>>=
test linkbackref-1.2 {
    Class association link back reference -- multiple dynamic missing population
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain ship {
            class Warehouse {
                attribute warehouseName {char[32]}
            }
            class Shipment {
                attribute value int -default 20
            }
            class WarehouseClerk {
                attribute clerkID unsigned -default 30
            }
            class Packing {}
            association R24 Shipment 0..*--1 Warehouse
            association R25 WarehouseClerk 1..*--1 Warehouse
            association R22 -associator Packing\
                    Shipment 0..*--0..1 WarehouseClerk
        }
        population ship {
            class Warehouse {
                instance wh1 warehouseName {"acme"}
                instance wh2 warehouseName {"ez-fullfillment"}
            }
            class Shipment {
                allocate 4
            }
            class WarehouseClerk {
                instance fred R25 wh1
                instance ralph R25 wh2
            }
            class Packing {
                allocate 4
            }
        }
    }
    log::debug [formatMiccaClass ClassComponent]
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 14}
} -result {1}
----
endif::showtests[]

Target classes references are handled similar to the simple referenced classes.

[source,tcl]
----
<<population: set link target class values>>=
set trgclass [findRelated $linkbackrefs {~R38 TargetClass}]
set refingrefs [FindTargetReferringRefs $trgclass $popvalues]
# puts [relformat $refingrefs refingrefs]
set backrefs [FindTargetBackRefs $refingrefs]
# puts [relformat $backrefs backrefs]

CreateLinkedRefs $backrefs BLINKS

CreateNilLinkedBackRefs $trgclass $backrefs
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test linkbackref-2.0 {
    Class based association target link reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {
            }
            class X {
            }
            class Y {
            }
            association R1 -associator A X 0..*--0..1 Y
        }

        population foo {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
                instance a3 R1 {X x3 Y y2}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
                instance y3
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 13}
} -result {1}
----
endif::showtests[]

And finally the forward references from source classes.

[source,tcl]
----
<<population: set link source class values>>=
set srcclass [pipe {
    LinkReference findWhere {$Domain eq $domain} |
    findRelated % R26 {~R28 ForwardReference} ~R95
} {} |%]

set refingrefs [FindSourceReferringRefs $srcclass $popvalues]
set forwrefs [FindSourceForwRefs $refingrefs]
CreateLinkedRefs $forwrefs FLINKS

CreateNilLinkedForwRefs $srcclass $forwrefs
----

(((micca,Helpers,CreateNilLinkedForwRefs)))
[source,tcl]
----
<<helper commands>>=
proc CreateNilLinkedForwRefs {srcclasses forwrefs} {
    set nilbackrefs [FindNilSourceForwRefs $srcclasses $forwrefs]
    # puts [relformat $nilbackrefs nilbackrefs]
    CreateNilLinkedRefs $nilbackrefs
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test linkforwref-1.0 {
    Class based association link forward references
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {
            }
            class X {
            }
            class Y {
            }
            association R1 -associator A X 0..*--0..* Y
        }

        population foo {
            class A {
                instance a1 R1 {X x1 Y y1}
                instance a2 R1 {X x2 Y y1}
                instance a3 R1 {X x3 Y y2}
                instance a4 R1 {X x1 Y y2}
                instance a5 R1 {X x1 Y y3}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
            class Y {
                instance y1
                instance y2
                instance y3
                instance y4
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 23}
} -result {1}
----

[source,tcl]
----
<<config command tests>>=
test linkforwref-1.1 {
    Class based association link forward reference -- reflexive
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class A {
            }
            class X {
            }
            association R1 -associator A X 0..*--0..* X
        }

        population foo {
            class A {
                instance a1 R1 {backward x1 forward x2}
                instance a2 R1 {backward x2 forward x3}
                instance a3 R1 {backward x3 forward x2}
                instance a4 R1 {backward x1 forward x3}
            }
            class X {
                instance x1
                instance x2
                instance x3
                instance x4
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 20}
} -result {1}
----
endif::showtests[]

Subclass references are made by reference superclasses.
We must look for superclass references made by reference subclasses to find the
reference values needed to compute the subclass reference made by the
superclass.

[source,tcl]
----
<<population: set subclass reference values>>=
set rsupercomps [pipe {
    ReferringSubclass findWhere {$Domain eq $domain} |
    findRelated % R47 R40 R41 ~R20 {~R25 PopulatedComponent} {~R21 Reference}\
        {~R23 SuperclassReference} R23 R21 R25 {~R103 ClassComponentValue} |
    deRef % |
    relation join %\
        $::micca::ReferenceGeneralization -using {Domain Domain Component Name}\
        [relation rename $::micca::ReferencedSuperclass Class Superclass]\
        -using {Domain Domain Component Relationship} |
    relation extend % rstup NewValue string {
        [list [tuple extract $rstup Class] [tuple extract $rstup Instance]]} |
    relation eliminate % Class Instance Role |
    relation rename % Superclass Class Value Instance NewValue Value
} {} |%]
# puts [relformat $rsupercomps rsupercomps]

foreach subref [relation body $rsupercomps] {
    ClassComponentValue create {*}$subref
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test subclassref-1.0 {
    generated components for subclass reference
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {
            }
            class sub1 {
            }
            class sub2 {
            }

            generalization R1 super sub1 sub2
        }

        population bar {
            class super {
                instance super1
                instance super2
            }
            class sub1 {
                instance fred1 R1 super1
            }
            class sub2 {
                instance alice1 R1 super2
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 4}
} -result {1}
----
endif::showtests[]

Subclass containers are used by union superclasses and are the
union superclass counterpart of a subclass reference by a referenced
superclass.
We use similar query.

[source,tcl]
----
<<population: set subclass container values>>=
set usupercomps [pipe {
    UnionSubclass findWhere {$Domain eq $domain} |
    findRelated % R47 R40 R41 ~R20 {~R25 PopulatedComponent} {~R21 Reference}\
        {~R23 SuperclassReference} R23 R21 R25 {~R103 ClassComponentValue} |
    deRef % |
    relation join %\
        $::micca::UnionGeneralization -using {Domain Domain Component Name}\
        [relation rename $::micca::UnionSuperclass Class Superclass]\
        -using {Domain Domain Component Relationship} |
    relation extend % rstup NewValue string {
        [list [tuple extract $rstup Class] [tuple extract $rstup Instance]]} |
    relation eliminate % Class Instance Role |
    relation rename % Superclass Class Value Instance NewValue Value
} {} |%]
# puts [relformat $usupercomps usupercomps]

foreach subcont [relation body $usupercomps] {
    ClassComponentValue create {*}$subcont
}
----

==== Union Subclass Numbering

Since subclass instances stored as a union do not have
a separate storage pool,
the instance numbering of union subclass instances is not independent.
We modify the instance numbers of union subclass instances in the initial
instance population to match those of the containing superclass instances.

[source,tcl]
----
<<population: update union subclass numbering>>=
set usupers [pipe {
    FindUltimateSuperclasses $domain |
    findRelated % {~R48 UnionSuperclass}
} {} |%]
# puts [relformat [deRef $usupers] usupers]

while {[isNotEmptyRef $usupers]} {
    set subrefs [pipe {
        deRef $usupers |
        relation eliminate ~ Role |
        relation rename ~ Relationship Component |
        relation join ~ $::micca::ClassComponentValue $::micca::ClassInstance |
        relation rename ~ Class Superclass Instance SuperInstance |
        relation extend ~ srtup\
            Class string {[lindex [tuple extract $srtup Value] 0]}\
            Instance string {[lindex [tuple extract $srtup Value] 1]} |
        relation project ~ Domain Class Instance Number
    }]
    # puts [relformat $subrefs subrefs]

    # relvar updateper does not update identifying attributes and
    # Number is a secondary identifier.
    # So we have to do it the hard way.
    # And because Number is part of a secondary identifier, we must remove the
    # old tuples and the add in the new ones or we risk a duplicate identifier
    # situation.
    relvar minus ::micca::ClassInstance [pipe {
        relation eliminate $subrefs Number |
        relation join ~ $::micca::ClassInstance -using\
            {Domain Domain Class Class Instance Instance}
    }]
    relvar union ::micca::ClassInstance $subrefs

    set usupers [pipe {
        findRelated $usupers R44 ~R45 |
        deRef % |
        relation semijoin % $::micca::UnionSuperclass\
            -using {Domain Domain Class Class} |
        ::rosea::Helpers::ToRef ::micca::UnionSuperclass %
    } {} |%]
}
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test subcontainer-1.0 {
    generated components for subclass container
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain bar {
            class super {}
            class sub1 {}
            class sub2 {}

            generalization R1 -union super sub1 sub2
        }

        population bar {
            class super {
                instance super1
                instance super2
            }
            class sub1 {
                table {
                    R1
                } fred {
                    super1
                }
            }
            class sub2 {
                instance alice1 R1 super2
            }
        }
    }
    log::debug [formatMiccaClass ClassComponentValue]
    testConditions\
        {[refMultiplicity [ClassComponentValue findAll]] == 4}
} -result {1}
----
endif::showtests[]

== Handling Configuration Errors

One of the design elements of the configuration DSL is the use of
the `micca` platform model to hold the configuration information.
This design approach allows us to encode the rules for what is a valid
domain configuration into the constraints.
Any attempt to define domain elements that violate those rules
will be caught at the end of the relvar transaction that end
the `configure` command.

The problem with this approach is that the error messages the are
returned refer to the classes of the platform model not those of
the domain we were attempting to define.

We will mitigate this problem by capturing the result returned by
TclRAL and turning it into error messages that are more meaningful
to the task of configuring a domain.
Unfortunately,
the messages produced by TclRAL are intended to be human readable,
so we will have to parse them into a form that is easier to deal
with programmatically.
Fortunately, the messages are very regular in structure so
the parsing code need not be very sophisticated.

Our strategy is to extract only the essential information from the
error message and then map the information onto a more meaningful error
message.
Part of what we want to include in the error message is the values
from the tuples failing the constraint.
These values contain information the user entered rather than the
abstractions of the platform model.

The essential information mapping is shown below.
Naturally enough, we hold it in a relvar.

[source,tcl]
----
<<config data>>=
relvar create Config_DataError {
    Relationship        string
    RefClass            string
    RefType             string
    Format              string
} {Relationship RefClass RefType}
----

The *Relationship* attribute is the name of the relationship in the
platform model that failed the constraint check.
The *RefClass* attribute is the platform model class that has the tuples
that failed the constraint check.
The *RefType* attribute defines the way in which the constraint failed.
The *Format* attribute is a string that contains the text of the
error message that we want to display.
The text in the *Format* attribute may also contain variable references
to attributes in the tuple of *RefClass* that failed.
The variable references in the *Format* will be substituted
with the values from the failing tuples in order to give specifics of
the error back to the user.

[float]
===== Implementation

The design of the `HandleConfigError` procedure is shown below.
It is a nested iteration over the lines of the error result, pulling
off the constraint violation details and then iterating over the
tuples that were found in the violation.

(((micca,Config,HandleConfigError)))
[source,tcl]
----
<<config commands>>=
proc HandleConfigError {result} {
    set lines [split [string trimright $result] \n]
    set nlines [llength $lines]
    set lineno 0
    upvar #0 ::micca::@Config@::errcount errcount
    while {$lineno < $nlines} {
        <<HandleConfigError: examine one failure>>
    }

    return
}
----

The information in the TclRAL error message is simple enough
and well structured enough that a regular expression can be used
to match and extract the interesting parts.

[source,tcl]
----
<<HandleConfigError: examine one failure>>=
set line [lindex $lines $lineno]
incr lineno
if {[regexp {^for[^:]+([^(]+)\(.+\), in relvar (.+)$} $line\
        match rnum refclass]} {
    set rnum [namespace tail $rnum]
    set refclass [namespace tail $refclass]

    # Now iterate over the "tuple" lines that follow the constraint message.
    while {$lineno < $nlines} {
        set tupline [lindex $lines $lineno]
        if {[regexp {^tuple {(.+)} (.+)$} $tupline match tuple phrase]} {
            incr lineno
            incr errcount
            <<HandleConfigError: examine one tuple>>
            <<HandleConfigError: format error message>>
        } else {
            break
        }
    }
} elseif {[regexp {procedural contraint, "([^"]+)", failed} $line match\
        constraint]} {
    # There is only one procedural constraint, R74C.
    # If an error is detected in the procedural constraint script,
    # messages will be printed there.
    log::error $result
    incr errcount
} else {
    log::error $result
    incr errcount
}
----

We match the phrase in the tuple message to create an enumeration of
the types of constraint violations.
These are just a bit simpler to handle and look up.

[source,tcl]
----
<<HandleConfigError: examine one tuple>>=
if {[string match {is not referenced*} $phrase]} {
    set reftype notrefed
} elseif {[string match {references no*} $phrase]} {
    set reftype refnone
} elseif {[string match {is referenced by multiple*} $phrase]} {
    set reftype refedmult
} elseif {[string match {*to by multiple*} $phrase]} {
    set reftype multrefed
} elseif {[string match {is not referred to*} $phrase]} {
    set reftype notrefto
} else {
    log::error "unknown constraint phrasing, \"$phrase\""
    continue
}
----

Finally, we look up the format information and generate an error message.
Using the `dict with` command allows us to take the tuple value from the
error message, treat it like a dictionary and get the values into
Tcl variable.
The `subst` command then will perform the variable substitutions in the
format string.

[source,tcl]
----
<<HandleConfigError: format error message>>=
set cde [relvar restrictone Config_DataError Relationship $rnum RefClass\
        $refclass RefType $reftype]
if {[relation isnotempty $cde]} {
    dict with tuple {
        log::error [subst -nocommands [relation extract $cde Format]]
    }
} else {
    log::error "$line\n$tupline"
}
----

We now need to enumerate all the platform model constraints that can be violated
and supply messages that provide less abstract and more useful user error
messages.
Because of the way the configuration data is stored into the platform model
classes,
not all violations are even possible.

[source,tcl]
----
<<config data>>=
relvar insert Config_DataError {
    Relationship        R20
    RefClass            Class
    RefType             notrefed
    Format              {in domain, $Domain, class, $Name,\
                        has no class components}
} {
    Relationship        R20
    RefClass            ClassComponent
    RefType             refnone
    Format              {in domain, $Domain, class, $Class, does not exist}
} {
    Relationship        R21
    RefClass            ClassComponent
    RefType             notrefto
    Format              {in domain, $Domain, class, $Class,\
                         component, $Name, failed to be completed created}
} {
    Relationship        R41
    RefClass            Relationship
    RefType             notrefed
    Format              {in domain, $Domain, relationship, $Name,\
                         failed to be completed created}
} {
    Relationship        R70
    RefClass            TransitionPlace
    RefType             refnone
    Format              {in domain, $Domain, class or assigner,\
                         $Model, event, $Event, causes a transition\
                         out of state, $State, but state $State does not\
                         exist}
} {
    Relationship        R72
    RefClass            StateTransition
    RefType             refnone
    Format              {in domain, $Domain, class or assigner,\
                         $Model, for the transition,\
                         $State - $Event -> $NewState, state $NewState does\
                         not exist}
} {
    Relationship        R86
    RefClass            DeferredEvent
    RefType             notrefed
    Format              {in domain, $Domain, class, $Model,\
                        defines event, $Event as polymorphic, yet\
                        $Model is not a superclass}
} {
    Relationship        R87
    RefClass            StateModel
    RefType             notrefed
    Format              {in domain, $Domain, class, $Model,\
                        there are no events defined for the state model}
} {
    Relationship        R101
    RefClass            ElementPopulation
    RefType             refnone
    Format              {for domain population, $Domain, class or assigner,\
                         $Element, does not exist}
} {
    Relationship        R101
    RefClass            Population
    RefType             notrefed
    Format              {for domain population, $Domain, no values for the\
                         domain elements are specified}
} {
    Relationship        R103
    RefClass            ClassComponentValue
    RefType             refnone
    Format              {for domain population, $Domain, class, $Class,\
                         instance, $Instance, sets the value of\
                         $Component to $Value,\
                         but $Component is not a known component of $Class"}
} {
    Relationship        R103
    RefClass            ClassInstance
    RefType             notrefed
    Format              {for domain population, $Domain, class, $Class,\
                         instance, $Instance, does not have any class\
                         components}
}
----

== Helper Commands

In this section we present a set of commands that factor common processing
used in a number of areas.
These commands are placed in a separate namespace
which is imported into most of the other package namespaces.

[source,tcl]
----
<<helper commands namespace>>=
namespace eval Helpers {
    logger::initNamespace [namespace current]

    <<tclral imports>>
    namespace import ::ral::relvar
    namespace path {::micca ::rosea::InstCmds}

    <<helper data>>
    <<helper commands>>
}
----

=== DeclError

All error notification in the package is consolidated in
the +DeclError+ procedure.

[float]
==== Implementation

The +DeclError+ procedure locates a format string based on the error code
and applies its arguments to it.
We use the +::throw+ command to raise the error to insure that we have
consistent error code information for the package.

(((micca,Helpers,DeclError)))
[source,tcl]
----
<<helper commands>>=
namespace export DeclError

proc DeclError {errcode args} {
    variable errFormats
    set errmsg [format [dict get $errFormats $errcode] {*}$args]
    tailcall throw [list MICCA $errcode {*}$args $errmsg] $errmsg
}
----

The mapping of +errcode+ values to format strings is held as
package data in the helper namespace of the package.

[source,tcl]
----
<<helper data>>=
variable errFormats
set errFormats [dict create {*}{
    <<error code formats>>
}]
----

=== Generate Numbers

There are a number of classes that have attributes that are
zero based sequential numbers.
We want a convenient way to generate these ordinal numbers.
Many times we want the number to start at zero within a set of
attributes.

[float]
==== Implementation

[source,tcl]
----
<<helper data>>=
relvar create SeqNumbers {
    Domain string
    ClassName string
    Attrs list
    Number int
} {Domain ClassName Attrs}
----

(((micca,Helpers,GenNumber)))
[source,tcl]
----
<<helper commands>>=
proc GenNumber {domain class args} {
    set num [relvar restrictone SeqNumbers Domain $domain ClassName $class\
        Attrs $args]
    if {[relation isempty $num]} {
        relvar insert SeqNumbers [list\
            Domain $domain\
            ClassName $class\
            Attrs $args\
            Number 0\
        ]
        return 0
    } else {
        set result [expr {[relation extract $num Number] + 1}]
        relvar updateone SeqNumbers sn [list Domain $domain ClassName $class\
            Attrs $args] {
            tuple update $sn Number $result
        }
        return $result
    }
}
----

=== Parse C Type Names

There a number of places where we require a ``C'' type name.
We have adopted the strategy to separate out ``C'' identifiers from
type names when parameters and other such things are required.
In ``C'' itself, parameter and variables follow a declaration
type syntax that is meant to be mnemonic of the way a variable is used
in an assignment statement.
We find it easier to keep identifiers and types separate,
but it means we need to be able to verify that a given type name is
syntactically correct and to compose a type name and identfier into
a variable or parameter declaration.

Since this is strictly a parsing problem,
we will rely on the parser tools that are part of `tcllib`.
The parser tools take a PEG specification and generate a parser in Tcl.
We will not discuss the grammar and other details of this parsing.
Suffice it to say that we have formulated a PEG for parsing standard
``C'' type names.
The output of the parser tools is a Tcl OO class that can parse a text
string and return an AST of the type name.
We will use the Tcl OO class as a superclass and provide two methods
in our derived class that perform the required type name validation
and generate a variable declaration from a type name and identifier.

[float]
==== Implementation

[source,tcl]
----
<<required packages>>=
package require oo::util
package require pt::util
----

(((micca,Helpers,typeverifier)))
[source,tcl]
----
<<helper commands>>=
source [file dirname [info script]]/typename/typeparser.tcl

oo::class create typeverifier {
    superclass typeparser

    method verifyTypeName {typename} {
        try {
            my parset $typename
            return true
        } on error {result} {
            puts [::pt::util error2readable $result $typename]
            return false
        }
    }

    method composeDeclaration {typename identifier} {
        my variable location

        set ast [my parset $typename]
        set location [lindex $ast 2]
        ::pt::ast topdown [mymethod TopWalker] $ast

        return [string cat\
            [string range $typename 0 $location]\
            " $identifier"\
            [string range $typename $location+1 end]\
        ]
    }

    method assignmentType {typename} {
        my variable assignmentType

        set ast [my parset $typename]
        set assignmentType [dict create type scalar]
        ::pt::ast topdown [mymethod AssignWalker] $ast

        return $assignmentType
    }

    method TopWalker {ast} {
        my variable location

        lassign $ast nodetype start end
        if {$nodetype eq "pointer"} {
            set location $end
        } elseif {$nodetype eq "array_declarator"} {
            set location [expr {$start - 1}]
        }
        return $ast
    }

    method AssignWalker {ast} {
        my variable assignmentType

        lassign $ast nodetype start end
        if {$nodetype eq "array_declarator"} {
            # HERE figure out dimension and whether type is "char"
            dict set assignmentType dimension 10
            dict set assignmentType type array
        }
        return $ast
    }
}

typeverifier create typeCheck
namespace export typeCheck
----

ifdef::showtests[]
[float]
==== Tests

[source,tcl]
----
<<config command tests>>=
test typecheck-1.0 {
    attribute with bad data type
} -setup {
} -cleanup {
    cleanupDomain
} -body {
    micca configure {
        domain foo {
            class c1 {
                attribute c1_id {* int}
            }
        }
    }
} -result {encountered 2 configuration script errors} -returnCodes error
----

[source,tcl]
----
<<config command tests>>=
test typecheck-1.1 {
    compose a variable declaration
} -setup {
} -cleanup {
} -body {
    ::micca::@Config@::Helpers::typeCheck composeDeclaration\
        {int (*)(int, int)} xx
} -result {int (* xx)(int, int)}
----

[source,tcl]
----
<<config command tests>>=
test typecheck-1.2 {
    compose an array declaration
} -setup {
} -cleanup {
} -body {
    ::micca::@Config@::Helpers::typeCheck composeDeclaration {char [32]} xx
} -result {char  xx[32]}
----
endif::showtests[]

=== Checking for Duplicates

(((micca,Helpers,CheckDuplicate)))
[source,tcl]
----
<<helper commands>>=
proc CheckDuplicate {class args} {
    set ref [$class findById {*}$args]
    if {[isNotEmptyRef $ref]} {
        tailcall DeclError DUP_INSTANCE_NAME $class $args
    }
    return
}
----

(((error code,DUP_ELEMENT_NAME)))
[source,tcl]
----
<<error code formats>>=
DUP_INSTANCE_NAME    {an element of class, "%s", already exists with\
        attributes, "%s"}
----

ifdef::showtests[]
== Test Utility Commands

There are number of utility commands that are part of the testing
infrastructure.
We present them here without additional commentary.

[source,tcl]
----
<<test utility commands>>=
namespace export getMiccaClass
proc getMiccaClass {class} {
    return [deRef [$class findAll]]
}
----

[source,tcl]
----
<<test utility commands>>=
namespace export formatMiccaClass
proc formatMiccaClass {class} {
    return \n[ral relformat [getMiccaClass $class] $class]
}
----

[source,tcl]
----
<<test utility commands>>=
namespace export readMiccaAttribute
proc readMiccaAttribute {class attr args} {
    return [rosea tunnel [$class findById {*}$args] readAttribute $attr]
}
----

[source,tcl]
----
<<test utility commands>>=
proc cleanupDomain {} {
    set preserve {
        ::micca::TransitionRule
    }
    relvar eval {
        foreach var [relvar names {::micca::[A-Z]*}] {
            if {$var ni $preserve} {
                relvar set $var [relation empty [relvar set $var]]
            }
        }
    }

    set config {
        ::micca::@Config@::Helpers::SeqNumbers
    }
    foreach var $config {
        relvar set $var [relation empty [relvar set $var]]
    }
}
----

[source,tcl]
----
<<test utility commands>>=
proc testConditions {args} {
    set result 1
    foreach exp $args {
        set passed [uplevel 1 [list expr $exp]]
        if {!$passed} {
            log::error "\"$exp\" failed"
            set result 0
        }
    }
    return $result
}
----
endif::showtests[]
