// vim:set syntax=asciidoc:
////
Template for classes.

=== Class 

Class description

Attribute Name::
    Attribute Description
[horizontal]
    Data Type::: Data type name

// repeated for each attribute

////

// Some attributes

:mult-attribute: This attribute records whether the reference by the class can be multiple.  Muliple associations may refer to more than one associated instances.  Singular association may refer to only one associated instance.

:cond-attribute: This attribute records whether the reference by the class is conditional. Conditional associations allow for there to be zero instances referred to. Unconditional associations insist that there must be at some instance referred to.


= The Micca Platform

[partintro]
--
In this part we present a class model of the platform specific model.
Some readers will have studied platform independent models.
These are sometimes referred to as _meta-models_.
There is no single meta-model for XUML.
You can express the rules of executable modeling in a number of ways,
although the several meta-models that have been proposed have,
as would be expected,
many of the same constructs in them.
The model we present here is platform specific.
The platform we are targeting is single threaded with ``C'' as the
implementation language.
The platform also assumes that all data will be held in primary memory
and that all data storage is statically allocated.
Consequently,
some of the constructs in this model will be decidedly implementation
oriented.
It is, after all, meant to be specific to a particular computing technology.
A single threaded, ``C'' based implementation is *not* an appropriate
basis for all executable models.
It will, however, solve a large class of application types.
That is generally true of all translation technologies.
You must be specific about the chosen class of applications and then
choose appropriate computing technology that is applicable to that class
of applications.
There is no such thing as a universal software architecture any more than
there is a universal programming language.
All involve trade-offs of usually conflicting needs and requirements.

The role of the platform model is central to the overall translation
scheme.
Populating this model is the primary focus of the `micca` domain specific
language.
The code generation phase of the translation will query the populated
platform model to produce ``C'' language output to implement the
intent of the model.

Consequently,
we devote considerable effort to describing the platform model.
We divide the discussion up into several sections focused on
a particular subsystem of the platform model.
The platform model itself will be implemented as a `rosea` domain.
Intermixed with the platform model description is the implementation of the
model in `rosea`.
--

== Domain Subsystem

=== Introduction

The domain subsystem is concerned with defining the basic elements
of what constitutes a domain
Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-domain.pdf[title="Domain Subsystem Class Diagram"]

[[domain-subsystem-discussion]]
A *Domain* is identified by a *Name*.
A *Domain* consists of a set of *Domain Elements* (*R1*).
*Domain Elements* are of two types (*R2*),
*Class* and *Relationship*.
*R2* insures that classes and relationships have different names and this
insures there are no naming conflicts in the generated code.
For *Domain Element.*Name* attribute and many other names,
we will insist that names be able to be
used as ``C'' language identifiers, _i.e._ they must start with
a letter followed by an arbitrary number of letters, digits or underscore
characters.
The code generation process will use these names directly as this
eases the burden of finding model elements in the generated implementation.

A *Domain* may also define a set of *Domain Operation* (*R5*).
These operations constitute the invocable interface functions for the
*Domain*.
A *Domain* is otherwise encapsulated.
A *Domain Operation* may also have *Domain Operation Parameter* (*R6*)
associated with it.
It is also typical for a *Domain* to have a set of *Type Alias* (*R7*).
A *Type Alias* provides a convenient way to map model type names onto
``C'' implementation types.

A *Class* may also have a set of *Operation* (*R3*).
An *Operation* may also have a set of *Operation Parameter* (*R4*).

=== Domain

A domain is a real or imagined world with its own set of rules.

Name \{I}::
    Each domain in a system must have a unique name.
[horizontal]
    Data Type::: string
Interface::
    A Domain will, in general, have dependencies on other aspects of the
    system. The Interface attribute is a string that will be inserted
    in the generated interface header file for the domain.
    Typically, the Interface will contain `#include` ``C'' preprocessor
    statements, but may contain any other compiler declarations
    needed.
[horizontal]
    Data Type::: string
Prologue::
    The Prologue for a Domain is inserted into the code file before any
    `micca` generated code.
    This gives the translation the opportunity to have external or forward
    references needed to satisfy the ``C'' compiler.
[horizontal]
    Data Type::: string
Epilogue::
    The Epilogue for a Domain is inserted into the code file after any
    `micca` generated code.
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Domain {
    attribute Name string -id 1
    attribute Interface string
    attribute Prologue string
    attribute Epilogue string
}
----

=== Domain Element

A domain element is one of the constituent parts of a domain.

Domain \{I,R1}::
    The name of the domain to which the element belongs.
[horizontal]
    Data Type::: references Domain.Name
Name \{I}::
    Each domain elements is given a name that is unique within the domain.
[horizontal]
    Data Type::: c-identifier

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainElement {
    attribute Domain string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}

    reference R1 Domain -link {Domain Name}
}
----

==== Checking for ``C'' Identifiers

Many names in the platform model will be directly used as an identifier in
the generated ``C'' code.
We insist they be of the correct form when the model is populated.
A simple regular expression will do the trick.

[source,tcl]
----
<<helper commands>>=
proc isIdentifier {name} {
    return [regexp {\A[[:alpha:]]\w*\Z} $name]
}
----

=== R1

* *Domain Element* is an entity of _exactly one_ *Domain*
* *Domain* models entities using _one or more_ *Domain Element*

We do not allow an empty domain.
Domains with no composing elements cannot model anything useful.
Each element of a domain belongs strictly to a single domain,
_i.e._ domain elements are never shared between domains.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R1 DomainElement 1..*--1 Domain
----

=== Class

A Class represents a logical predicate about some aspect of a Domain.

Domain \{I,I2,R2,R104}::
    The name of the domain to which the class belongs.
[horizontal]
    Data Type::: References DomainElement.Domain
Name \{I,R2,R104}::
    Classes are identified by name within the domain to which they belong.
[horizontal]
    Data Type::: string
Number \{I2}::
    It is useful during code generationto have a sequential integer number for
    classes within a given domain.
[horizontal]
    Data Type::: sequential numeric

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Class {
    attribute Domain string -id 1 -id 2
    attribute Name string -id 1 ; # <1>
    attribute Number int -id 2 -system 0

    reference R2 DomainElement -link Domain -link Name
    reference R104 ValueElement -link Domain -link Name
}
----
<1> The question arises whether we need to check if *Class.Name* is a
valid ``C'' identifier.
The answer is no.
Since *Class.Name* refers to *DomainElement.Name* unconditionally,
the check on *DomainElement.Name* insures that *Class.Name* is a valid
``C'' identifier.
Otherwise, we would fail the referential integrity check indicated by *R2*.

=== Relationship

A Relationship represents a real world association between class instances.

Domain \{I,R2}::
    The name of the domain to which the relationsihp belongs.
[horizontal]
    Data Type::: References DomainElement.Domain
Name \{I,R2}::
    Relationships are identified by name within the domain to which they belong.
    Traditionally, relationships are given names of the form, "R<digit>+", where
    <digit> is a decimal number.
    Although the convention is very commonly used in the executable modeling
    world, relationships may be given any desired name.
[horizontal]
    Data Type::: string
Number \{I2}::
    It is useful during code generationto have a sequential integer number for
    relationships within a given domain.
[horizontal]
    Data Type::: sequential numeric

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Relationship {
    attribute Domain string -id 1 -id 2
    attribute Name string -id 1
    attribute Number int -id 2 -system 0

    reference R2 DomainElement -link Domain -link Name
}
----

=== R2

* *DomainElement* is a *Class* or *Relationship*

There are only two types of domain elements, Classes and Relationships.
These elements model the logical predicates of the domain subject matter.

[source,tcl]
----
<<platform relationships>>=
generalization R2 DomainElement Class Relationship
----

=== Domain Operation

A Domain Operation is a executable body of code that provides
a service access point into a domain.
The set of domain operations of a domain constitute the invocable programming
interface to the domain.

Domain \{I,R5}::
    The name of the domain to which the domain operation belongs.
[horizontal]
    Data Type::: refers to Domain.Name
Name \{I}::
    The name of the operation. Domain operations are given names that
    must be unique only within a given domain.
[horizontal]
    Data Type:::: c-identifier
Body::
    The code that is to be executed when the domain operation is invoked.
    This code is presumed to be ``C'' language statements and,
    except for some preprocessing of the statements,
    is passed along in the generated output file for the domain.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the domain operation.
[horizontal]
    Data Type:::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainOperation {
    attribute Domain string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Body string
    attribute ReturnDataType string

    reference R5 Domain -link {Domain Name}
}
----

=== R5

* *Domain Operation* is a service for _exactly one_ *Domain*
* *Domain* provides service via _zero or more_ *Domain Operation*

Domain operations only operate on a single domain.
However, a domain may not provide an explicit service entry points
and have no defined domain operations.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R5 DomainOperation 0..*--1 Domain
----

=== Domain Operation Parameter

A Domain Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R6}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to DomainOperation.Domain
Operation \{I,I2,R6}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to DomainOperation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list
    without reference to the parameter name.
[horizontal]
    Data Type::: numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainOperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string

    reference R6 DomainOperation -link Domain -link {Operation Name}
}
----

=== R6

* *Domain Operation Parameter* defines a formal parameter of _exactly one_
    *Domain Operation*
* *Domain Operation* has a formal parameter defined by _zero or more_
    *Domain Operation Parameter*

A domain operation parameter definition only applies to a single operation.
However, domain operations may have no parameters
as it is valid to have ``C'' functions with no parameters.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R6 DomainOperationParameter 0..*--1 DomainOperation
----

=== Operation

An *Operation* is a executable body of code that computes on a
class or class instance.

Domain \{I,R3}::
    The name of the domain to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Domain
Class \{I,R3}::
    The name of the class to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Name
Name \{I}::
    The name of the operation. Operations are given names that
    must be unique only within a given class.
[horizontal]
    Data Type:::: c-identifier
IsInstance::
    This attribute determine whether the operation applies to class instances.
    If true, then the generated code for the operation will have
    an implicitly declared parameter named `self`.
[horizontal]
    Data Type:::: boolean
Body::
    The code that is to be executed when the operation is invoked.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the operation.
[horizontal]
    Data Type:::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Operation {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute IsInstance boolean
    attribute Body string
    attribute ReturnDataType string

    reference R3 Class -link Domain -link {Class Name}
}
----

=== R3

* *Operation* operates over _exactly one_ *Class*
* *Class* is the domain for _zero or more_ *Operation*

Operations only operate on a single class.
However, a class may not provide any explicit operations.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R3 Operation 0..*--1 Class
----

=== Operation Parameter

An Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R4}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Domain
Class \{I,I2,R4}::
    The name of the class to which the parameter belongs.
[horizontal]
    Data Type::: refers to Operation.Class
Operation \{I,I2,R4}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list.
[horizontal]
    Data Type::: sequential numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class OperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Class string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string

    reference R4 Operation -link Domain -link Class -link {Operation Name}
}
----

=== R4

* *Operation Parameter* defines a formal parameter of _exactly one_
    *Operation*
* *Operation* has a formal parameter defined by _zero or more_
    *Operation Parameter*

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R4 OperationParameter 0..*--1 Operation
----

== Classes Subsystem

=== Introduction

[[classes-subsystem-discussion]]
The classes subsystem defines how model level ideas of a class will be
realized in `micca`.
We will simplify considerably the relational view of classes that
we find at the model level.
Because we are holding all data in memory and we are using
an implemenation language that exposes addresses,
there are number of simplifying transformations on classes available to us.

* Since the address in memory (_.i.e._ a pointer to an object) is unique,
we can use it as an identifier of each class instance.
If the identifying attributes from the model serve no other descriptive role,
then they can be eliminated altogether.
Using the object pointer as an identifier has a number of
other implementation benefits such as directly accessing attribute values.
* Referential attributes will be replaced by pointer values.
Since referential attributes always refer to identifiers in the model,
then implementing relationships can be accomplished by storing
sets of pointers whose values refer to objects in memory.

Both of these considerations lead to the decision,
common for platforms of the type `micca` is intended,
to map model level class definitions onto ``C'' structure definitions.
Storage for a class can then be allocated as an array of structures
that correspond to the class definition and
relationship information is stored as pointers into the instance array.
Most of the classes subsystem is concerned with how the ``C'' structure
definitions will be composed and the type of information that is held.
We will also be concerned with how some relationship storage will be
structured since there are choices that have different trade-offs.

Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-classes.pdf[title="Classes Subsystem Class Diagram"]

A *Class* is composed of *ClassComponent* (*R20*).
*ClassComponent* consists of four different types (*R21*).
An *Attribute* is a named, descriptive value of the *Class* and may have
a *DefaultValue* (*R22*).
A *Reference* is used to implement class relationships.
A generalization subclass may be held as a discriminated union in
a *SubclassContainer*.
When a class instance participates in a multiple relationship that uses
linked lists,
the memory for the list linkage is held in a *LinkContainer*.
A *Reference* may also be one of four different types (*R23*).
The types of references fulfill different roles and types of relationships.
An *AssociationReference* is used to store information about
association relationships.
An *AssociatorReference* holds the references for an *AssociatorClass*.
A generalization supertype uses a *SubclassReference* to traverse a
generalization relationships from superclass to subclass.
A subtype uses a *SuperclassReference* to traverse a
generalization relationship from subclas to superclass.
Associations have different multiplicities and use different
types of pointer storage (*R24*).
A *SingularReference* is used to hold relationship pointers for
singular multiplicities.
When the multiplicity of a relationship is greater than one,
two different storage strategies are supported.
For relatively static relationships,
references can be held as an *ArrayReference*.
For dynamic relationships,
a *LinkedReference* is often a better choice.

=== Class Component

A Class Component is an element of the implementation class structure
and directly represents a member of the structure definition for the class
as it is used in the implementation.

Domain \{I,R20}::
    The name of the domain to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Domain
Class \{I,R20}::
    The name of the class to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Name
Name \{I}::
    The name of the component.
[horizontal]
    Data Type::: c-identifier
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassComponent {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R20 Class -link Domain -link {Class Name}
}
----

=== R20

* *ClassComponent* defines the properties of _exactly one_ *Class*
* *Class* is characterized by _one or more_ *ClassComponent*

A Class is made up of one or more components and each component
can belong to only one class.
Empty classes are not allowed as these are deemed to model nothing.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R20 ClassComponent 1..*--1 Class
----

=== R21

* *ClassComponent* is an *Attribute*, *Reference*, *SubclassContainer*,
or *LinkContainer*

There are four types of components that may be part of a class.
These four types represent the different ways attributes and relationships
are stored in class structures.
An attribute corresponds to model level attributes that hold data that
parameterizes the class
(_i.e._ attributes whose roles are not strictly referential or identifying).
A reference is one or more pointers that are used to implement
model level relationships.
A subclass container can be used by a superclass to hold subclass elements
as a discriminated union.
This is one option for how generalization relationship information may be
stored.
A link container is a set of pointers used to implement a linked list.
This is one option for how sets of relationship pointer information may be
stored.
The space for the link pointers is allocated in to the class that would be
chained together on a relationship.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R21 ClassComponent Attribute Reference SubclassContainer LinkContainer
----

=== Attribute

The Attribute class represent descriptive data that parameterizes a class.

Domain \{I,R21}::
    The name of the domain to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the attribute.
[horizontal]
    Data Type::: Refers to Class Component.Name
DataType::
    The data type of the parameters.
[horizontal]
    Data Type::: c-typename
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Attribute {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute DataType string

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== Default Value

The default value of an attribute is one that will be given to the
attribute when an class instance is created if no value is otherwise provided.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class DefaultValue {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Attribute string -id 1

    reference R22 Attribute -link Domain -link Class -link {Attribute Name}
}
----

=== R22

* *DefaultValue* supplies missing value for _exactly one_ *Attribute*
* *Attribute* has missing value supplied by _zero or one_ *DefaultValue*

An Attribute may be defined to have a default value that the system
will use when the attribute's value is not otherwise specified when
a class instance is created.
There can only be one default value for an attribute
and not all attributes will define default values.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R22 DefaultValue 0..1--1 Attribute
----

=== Reference

A reference is one or more pointer values that are used to implement
the storage for a relationship.

Domain \{I,R21}::
    The name of the domain to which the reference belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the reference belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the reference.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Reference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== Subclass Container

One option for storing generalization relationship information is
as a discriminated union.
The idea is that subclass storage is accomplished by creating a union
of all the subclasses in the generalization.
Then an component of the superclass is defined to be the subclasses union
along with another member to track to which subclass the superclass is
currently related.
This type of storage structure can save some memory space and
traversal across the generalization relationships can be accomplished
with pointer arithmetic.

Domain \{I,R21}::
    The name of the domain to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the subclass container.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SubclassContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== LinkContainer

A link container is a class component that holds pointer values that allow a
class instance to be on a linked list that is used as the storage for a
relationship.
One type of relationship storage uses linked lists when multiple
instances must be referenced.
The linkage is embedded into the class structure for the instances that
are being referenced.
The link list approach to relationship storage requires more space
but has better run time characteristics when the relationship is
dynamic.

Domain \{I,R21}::
    The name of the domain to which the link container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the link container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the link container.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class LinkContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== R23

* *Reference* is a *AssociationReference*, *AssociatorReference*,
*SubclassReference* or *SuperclassReference*

There are four types of storage arrangements that are used to handle
pointers used to track class relationships.
These types handle the specific cases of model level relationships
are translated into a ``C'' environment.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R23 Reference\
    AssociationReference AssociatorReference SubclassReference SuperclassReference
----

=== Association Reference
An Association Reference is used to store pointer values for an association
type relationship.
An Association Reference will store one or two references depending whether
the association is reflexive.
For reflexive associations,
the Association Reference stores reference types for both the forward and
reverse directions of the relationships traversal.
For non-reflexive association,
it stores only a single reference type for the direction of traversal
in which the class participates.

Domain \{I,R23}::
    The name of the domain to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the assocation reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssociationReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== Associator Reference
When a class is an associator class,
it will contain an associator reference.
This type of reference stores two pointers to the classes
participating in the association.
Note for associator references,
the pointer values to the participating classes are not allowed to be
`NULL`.

Domain \{I,R23}::
    The name of the domain to which the associator reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the associator reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the associator reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssociatorReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== Subclass Reference
For generalization relationships,
to navigate from the superclass to one of its subclasses
we must be able to determine the type of the subclass to which
the superclass is currently related.
A subclass reference is composed of both the pointer to the related subclass
instance as well as an encoding of the subclass instance type.

Domain \{I,R23,R92}::
    The name of the domain to which the subclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain and Referenced Superclass.Domain
Class \{I,R23,R92}::
    The name of the class to which the subclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class and Referenced Superclass.Class
Name \{I,R23,R92}::
    The name of the subclass reference.
[horizontal]
    Data Type::: Refers to Reference.Name and Referenced Superclass.Relationship
Role \{R92}::
    The role played by the subclass reference in the relationship.
[horizontal]
    Data Type::: Refers to Referenced Superclass.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SubclassReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string

    reference R23 Reference -link Domain -link Class -link Name
    reference R92 ReferencedSuperclass -link Domain -link Class\
        -link {Name Relationship} -link Role
}
----

=== Superclass Reference
For generalization relationships,
pointer information to navigate from a subtype to the supertype class
is stored in a Superclass Reference.

Domain \{I,R23,R91}::
    The name of the domain to which the superclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain and Referring Subclass.Domain
Class \{I,R23,R91}::
    The name of the class to which the superclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class and Referring Subclass.Class
Name \{I,R23,R91}::
    The name of the superclass reference.
[horizontal]
    Data Type::: Refers to Reference.Name and Referring Subclass.Relationship
Role \{R91}::
    The role played by the superclass reference in the relationship.
[horizontal]
    Data Type::: Refers to Referring Subclass.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SuperclassReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string

    reference R23 Reference -link Domain -link Class -link Name
    reference R91 ReferringSubclass -link Domain -link Class\
        -link {Name Relationship} -link Role
}
----

=== R24

* *AssociationReference* is a *LinkedReference*, *ArrayReference*,
or *SingularReference*

Storage for association relationships can be one of three types.
A Singular Reference hold a single pointer value and is suitable
for storing relationships that have a mulitplicity of one.
When storing pointers for relationships with a multiplicity greater that one,
two choices are available.
The Linked Reference uses a linked list.
This choice requires more space but has better dynamic run time characteristics.
The Array Reference uses a counted array of pointers.
This choice minimizes space and is a good choice if the relationship
instances are static.
However, a counted array has poorer worst case run time behavior than the
linked list when the instances of the array are dynamic.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R24 AssociationReference\
    LinkedReference ArrayReference SingularReference
----

=== Linked Reference
When associations of multiplicities greater than one are also dynamic,
_i.e._ there are `link` and `unlink` operations performed on the
relationship,
a linked list is one provided option for storing the relationship
pointers.
A Linked Reference represents the head of that linked list.

Domain \{I,R24}::
    The name of the domain to which the linked reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the linked reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the linked reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class LinkedReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 AssociationReference -link Domain -link Class -link Name
}
----

=== Array Reference
An array reference consists of an array of pointers and a count
indicating the number of array elements that are in use.
This type of reference can be used to store relationship pointers
for relationships with multiplicities greater than one.

Domain \{I,R24}::
    The name of the domain to which the array reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the array reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the array reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ArrayReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 AssociationReference -link Domain -link Class -link Name
}
----

=== Singular Reference
A singular reference consists of a single pointer value and
can be used to store relationship information for relationship of
multiplicity one.

Domain \{I,R24}::
    The name of the domain to which the singular reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the singular reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the singular reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SingularReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 AssociationReference -link Domain -link Class -link Name
}
----

== Relationship Subsystem

=== Mapping Referential Attributes to Pointers
When targeting a statically typed language such as ``C'' and assuming
that all class data will be held in primary memory,
we must devise a way to map relational notions of referential attributes
and referential integrity onto ``C''' language constructs.
There are, needless to say, many ways this can be done.
As we discussed earlier,
we make the convenient decision to use the address of a class instances
as an architecturally supplied identifier.
This decision has many benefits in the implementation.
This also means we can store pointer values as a means of implementing
relationships.

Consider a many-to-one association between two classes.
In a relational scheme,
we would have referential attributes in the class that was on the *many*
side of the relationship and the values of those attributes would
match the values of identifying attributes on the *one* side.
In a pointer based scheme we can do the same thing, _i.e._
place a pointer variable in the ``C'' structure of the class on the *many* side
and have the value of the pointer match that of a class instance on
the *one* side.
The diagram below shows this mapping.

image::pointer-example.pdf[title="Direct Mapping of Referential Attribute"]

Now lets look at the computation required to navigate this relationship,
first from the many side to the one side and then from the one side to
the many side.
For this discussion we will assume the relationship is unconditional on
both sides.

From the many side,
we can see from the above diagram that given a pointer to an *A* instance
we can navigate to the related *B* instance by simply accessing the
`R1` member of `struct A`.
When navigating from the one side to the many side,
we will, in general, obtain more than one instance as a result of the
navigation.
We can find those instances by searching all of the many-side instances
selecting those instances who have a stored pointer value that matches the
address of the one-side class instance.
So in our example, if we have a pointer to a `struct B` we would need to
search all instances of *A* looking for those where the `R1` member
matched the value of our starting pointer.

Having to perform a search for the one-side to many-side navigation is
somewhat troubling.
If the number of instances of the many-side class is small,
then there is little concern.
If it is larger, then we might explore ways to avoid costs associated
with a straight linear search of the many-side instances.
The search code is also rather inconvenient since we target a statically
typed language.
The function to iterate across the many-side instances looking for
the one-side pointer value has to be specific to that particular relationship
if we are to be strictly type safe and don't want to resort to
extremes of type casting and pointer arithmetic.

One way to avoid the search altogether is to store the pointers of the
multiple related instances.
We will have, in effect, pre-computed the related set and, at the cost of the
pointer storage, incur no run time computation to find it.
The figure below shows this in sketch form.

image::pointer-set-example.pdf[title="Mapping Instance References in Both Directions"]

In this arrangement,
the multiple instances implied by traversing the *R1* relationship from
class *B* to class *A* is held as an array of pointers to the related
*A* instances.

It does take computation to maintain the set if the instances participating
in the relationship change.
The space vs. speed trade-off is such that we will almost always use some
additional space to save a run time cost and additional code associated with
computing a set of related instances.
There are other choices of data structures that could be used
to hold the set of pointers.
By choosing different data structures to store the pointer sets,
we can, again at the cost of some additional space,
make maintaining the related pointer sets easier in the face of relationship
changes.

It is also worth noting that although at the model level,
relationships can be navigated in either direction as required by the
logic of the processing,
in practice most relationships are *not* navigated by the processing in
both directions.
So as we adopt the strategy to store relationship pointers that implement
the navigation in both participating classes,
we can also be aware that we can elide those pointers in classes where
we do not navigate a relationship in a particular direction.
In many models,
this will turn out to be a significant savings.

Analysis like that above can be applied to the other types of relationships
and pointer storage schemes can be designed that map the
relational notion of referential attributes to memory pointers.
Most of the relationship subsystem is concerned with categorizing
the types of relationships from a model level
and mapping those onto the roles the classes play in the relationship.
This will then allows us to explicitly map the role a class plays in a
relationship to the kind of storage required to implement that role and
further to the class structure components that are required to hold
the pointers.
The references subsystem models this later part.

=== Naming Conventions on Relationship Traversal

[[relationship-naming-conventions]]
In addition to modeling the real world associations between classes,
relationships also provide a means for the processing of the domain
to navigate the class diagram to access related class instances.
Here we discuss the syntax conventions we will use to indicate
how this navigation will take place.
We adopt the strategy that each relationship has a designated _direction_.
Navigating in the _forward direction_ starts with instances of a source
class and ends with instances of a target class.
Navigating in the _reverse direction_ starts with target class instances
and ends with source class instances.
To designate the forward direction we will use the unadorned relationship
name, _e.g._ `R22` and the reverse direction is indicated by
placing a tilde character before the relationship name, _e.g._ `~R22`.
The motivation behind this convention is to minimize the amount
of specification that needs to be given for navigating relationships
and to disambiguate the case of a reflexive relationship where the
source class and target class are the same.
Given the specification of a relationship direction,
the system knows which classes are involved and that need not be restated
when specifying the navigation during a state activity.
When specifying a direction to a relationship there are three cases to
consider.

For simple assocations,
the forward direction of the relationship is from the referring class
to the referenced class.
In a simple association,
one class contains referential attributes and is hence the referring class.
The other class contains the referenced identifying attributes and
is deemed the referenced class.
The forward direction is then the traversal from instances of the
referring class to instances of the referenced class.

For generalization relationships,
the forward direction of the relationship is also from the referring class
to the referenced class.
In a generalization,
the subclass instances are always the referring instances.
Navigating from the superclass to a subclass requires additional information,
namely which subclass is to be the target.
Navigating from a superclass instance to a subclass instance can yield
at most one subclass instance and possibly zero if the superclass instance
is not actually related to the requested subclass.
So the syntax convention to navigate from a superclass instance to a subclass
instance specifies navigating in the reverse direction as well as the
desired subclass name, _e.g._ `~R42 TableLamp`.

For class based associations,
it is the associator class that holds referential attributes that refer to
both participating classes.
In this case,
the forward direction of the relationships must simply be specified
and one class is designated the source and the other the target.
Since it is also possible to navigate from a participating class to the
associator class itself,
we will specify that case by including the associator class name,
similar to the way generalization relationship navigation is specified.
Navigating from source to target is specified as the unadorned
relationship name, _e.g._ `R14`.
Navigating from target to source uses the tilde notation, _e.g._ `~R14`.
Navigating from the source to the associator includes the associator
class name, _e.g._ `R14 Ownership` and from target to associator
uses the tilde and the associator class name, _e.g._ `~R14 Ownership`.

Only associations can be reflexive (_i.e._ the source and target are the
same class).
For generalization relationships,
we insist that all the subclasses are distinct and that they are distinct
from the superclass.
The conventions used here serve to disambiguate association traversal
in the reflexive case,
however, additional specification is required to fix the precise traversal
path for the case of one-to-one and many-to-many reflexive relationships.
For a one-to-one reflexive association,
we will need to specify which attributes are the referential ones and
that will set the direction.
For a many-to-many association an associator class is required and
again we will have to specify the path from source to target.

Below is the UML class diagram for the relationship subsystem of the platform
model.

image::platform-relation.pdf[title="Relationship Subsystem Class Diagram"]

There are two types of *Relationship* (*R30*), namely
*Association* and *Generalization*.
In turn,
there are two types of *Association* (*R31*), namely
*Simple Association* and *Class Based Association*.
A *Class Based Association* uses a distinct *Associator Class* (*R42*)
to hold references to the participating *Source Class* (*R34*) and
*Target Class* (*R35*).
A *Simple Association* is one where the multiplicity and conditionality
are such that all the references can be located in one of the participating
classes.
The *Simple Referring Class* houses the references (*R32*) while the
*Simple Referenced Class* is the one referred to (*R33*).
`Micca` supports two ways to handle generalization relationships (*R43*).
A *Reference Generalization* uses pointer values to implement the
relationship.
In this arrangement,
a *Referenced Superclass* (*R36*) holds a pointer and encoded type to
a *Referring Subclass* (*R37*).
The *Referring Subclass* also holds a pointer to its related superclass
instances.
A *Union Generalization* uses a discriminated union
to implement the relationship.
This leads to the complementary ideas of a *Union Superclass* (*R44*) and
a *Union Subclass* (*R45*).
All of these class roles are specialized as a *Class Role* (*R40*) which
is the many-to-many-to-many correlation between *Relationship* and
*Class* (*R41*).

=== Association
An Association is a mapping between the instances of two classes.
The two classes need not be distinct.
If the association is between instances of the same class,
then it is called a _reflexive_ association.
If the association is between instances of distinct classes,
then it is called a _non-reflexive_ association.

Domain \{I,R30}::
    The name of the domain to which the association belongs.
[horizontal]
    Data Type::: Refers to Relationship.Domain
Name \{I,R30}::
    The name of the association.
[horizontal]
    Data Type::: Refers to Relationship.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Association {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R30 Relationship -link Domain -link Name
}
----

=== Generalization
An Generalization is a partitioning of a class into a disjoint union.

Domain \{I,R30}::
    The name of the domain to which the generalization belongs.
[horizontal]
    Data Type::: Refers to Relationship.Domain
Name \{I,R30}::
    The name of the generalization.
[horizontal]
    Data Type::: Refers to Relationship.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Generalization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R30 Relationship -link Domain -link Name
}
----

=== R30
* *Relationship* is an *Association* or *Generalization*

There are two fundamental types of relationships.
These types are complementary to each other.
An Association is fundamentally related to the Cartesian product
of the participants.
A Generalization is related to the disjoint union of the particiants.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R30 Relationship Association Generalization
----

=== R31
* *Association* is a *Simple Association* or *Class Based Association*

Associations are mappings between class instances.
In its most general form,
a separate class is used to hold the mappings and these are called
*Class Based Associations*.
For the special case of one-to-one and one-to-many multiplicities,
the realization of the association can be simplified by placing
the association mappings into one of the participating classes.
These are known as *Simple Association*.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R31 Association ClassBasedAssociation SimpleAssociation
----

=== Class Based Association
A Class Based Association is a that type of association where a
distinct class is used to implement the relationship.

Domain \{I,R31}::
    The name of the domain to which the class based association belongs.
[horizontal]
    Data Type::: Refers to Association.Domain
Name \{I,R31}::
    The name of the class based association.
[horizontal]
    Data Type::: Refers to Association.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassBasedAssociation {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R31 Association -link Domain -link Name
}
----

=== Simple Association
A Simple Association is a that type of association where the relationship
is implemented using attributes in one of the participating classes.

Domain \{I,R31}::
    The name of the domain to which the simple association belongs.
[horizontal]
    Data Type::: Refers to Association.Domain
Name \{I,R31}::
    The name of the simple association.
[horizontal]
    Data Type::: Refers to Association.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SimpleAssociation {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R31 Association -link Domain -link Name
}
----

=== R43
* *Generalization* is a *Reference Generalization* or *Union Generalization*

The `micca` platform supports two different techniques to hold
generalization relationship information.
One technique is to use pointer values in a way similar to association
relationships.
The other techique is to use a discriminated union to hold the subclass
instance as part of the superclass instance.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R43 Generalization ReferenceGeneralization UnionGeneralization
----

=== Reference Generalization

A Reference Generalization is that type of generalization where
pointer references are used to implement the relationship.

Domain \{I,R43}::
    The name of the domain to which the reference generalization belongs.
[horizontal]
    Data Type::: Refers to Generalization.Domain
Name \{I,R43}::
    The name of the reference generalization association.
[horizontal]
    Data Type::: Refers to Generalization.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ReferenceGeneralization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R43 Generalization -link Domain -link Name
}
----

=== Union Association

A Union Generalization is that type of generalization where the subclass
is held as a discriminated union within the superclass instance.
Because of the properties of a generalization relationship,
a superclass is never related to more than one of its subclasses
and so a union of all the subclass structures may be used directly
as the subclass instance storage.

Domain \{I,R43}::
    The name of the domain to which the union generalization belongs.
[horizontal]
    Data Type::: Refers to Generalization.Domain
Name \{I,R43}::
    The name of the union generalization.
[horizontal]
    Data Type::: Refers to Generalization.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class UnionGeneralization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R43 Generalization -link Domain -link Name
}
----
=== Simple Referring Class
In a Simple Association between two classes,
one class has the role of refering to the other class in the association.
That role is termed the Simple Referring Class.
This class is deemed to be the source of relationship navigation when
going in the forward direction.
From a relational point of view,
the Simple Referring Class is the class in the Simple Association
which contains referential attributes.

Domain \{I,R32,R38}::
    The name of the domain to which the simple referring class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the simple referring class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R32,R38}::
    The name of the relationship in which the simple referring class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the simple referring class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SimpleReferringClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R32 SimpleAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R32

* *Simple Referring Class* is the referring member of
_exactly one_ *Simple Association*
* *Simple Association* has a referring member of
_exactly one_ *Simple Referring Class*

A *Simple Association* is one where referential attributes are
placed in one of participating class.
That class then serves the role of a *Simple Referring Class*.
Each *Simple Association* must have a class that acts as
a *Simple Referring Class* and a class can only be a *Simple Referring Class*
within the context of one *Simple Association* relationship.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R32 SimpleReferringClass 1--1 SimpleAssociation
----

=== Simple Referenced Class

In a Simple Association between two classes,
one class has the role of being referenced by the other class in the
association.
That role is termed the Simple Referenced Class.
This class is deemed to be the target of relationship navigation when
going in the forward direction.
From a relational point of view,
the Simple Referenced Class is the class in the Simple Association
which contains identifying attributes referenced by the Simple Referring Class.

Domain \{I,R33,R38}::
    The name of the domain to which the simple referenced class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the simple referenced class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R33,R38}::
    The name of the relationship in which the simple referenced class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the simple referenced class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean

Note that there is no Multiplicity attribute.
A Simple Referenced Class is always referred to by at most one
Simple Referring Class.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SimpleReferencedClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean

    reference R33 SimpleAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R33

* *Simple Referenced Class* is the referenced member of
_exactly one_ *Simple Association*
* *Simple Association* has a referenced member of
_exactly one_ *Simple Referenced Class*

A *Simple Association* is one where referential attributes are
placed in one of participating class that refer to the identifying
attributes of the other class.
The class containing the referenced identifying attributes serves
the role of a *Simple Referenced Class*.
Each *Simple Association* must have a class that acts as
a *Simple Referenced Class* and a class can only be a *Simple Referenced Class*
within the context of one *Simple Association* relationship.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R33 SimpleReferencedClass 1--1 SimpleAssociation
----

=== Conventions Used for Class Based Associations
Class based association pose some additional complexity when
describing the way in which they are mapped to the implementation realm.
The associator class represents instances of the association between
the participants.
Each instance of the associator class corresponds one-to-one to instances
of the association itself.
As we discussed
<<relationship-naming-conventions,above>>,
in a class based association one participant will be deemed the source
and the other the target in order to specify the direction of the
relationship for traversal.
The associator class itself always contains the referential attributes
and in our implementation strategy, will contain two pointers, one each
to the participating class instances.
The pointer values will never be `NULL` as the reference from the
associator class to one of the participants is always unconditional.
We will decompose a class based association to make the role of the
associator class explicit.
This is shown in the diagram below.

image::assoc-decompose.pdf[title="Decomposition of Class Based Associations"]

Note that as part of the decomposition,
the multiplicity and conditionality of the source and target sides have
been switched.
Because the references from the associator class to the participants is
unconditional,
the multiplicity and conditionality of the decomposed association when going
from the source class to the associator class is the same as that specified
for the target side at the model level and conversely for the target class.
The apparent switch of the multiplicity and conditionality results from
both the decomposition,
which makes the role of the associator class and its pointer references
explicit,
and the unconditional nature of the references from the associator class to the
participant classes.

With this in mind,
we describe the roles that classes play in a class based association below.
We will have occasion to refer back to this explanation when we generate
the code for class based associations.

=== Source Class

For a Class Based Association,
the Source Class is the starting class from which the association can be
traversed in the forward direction.

Domain \{I,R34,R38}::
    The name of the domain to which the source class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the source class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R34,R38}::
    The name of the relationship in which the source class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the source class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean

==== Implementation

[source,tcl]
----
<<platform classes>>=
class SourceClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R34 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R34

* *Source Class* is the source member for _exactly one_ *Class Based Association*
* *Class Based Association* has a source member of _exactly one_ *Source Class*

Each Class Based Association designates one of the participant classes
to serve the role as the source of traversal.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R34 SourceClass 1--1 ClassBasedAssociation
----

=== Target Class

For a Class Based Association,
the Target Class is that class where, when the association is traversed
in the forward direction starting at the Source Class, the instances
related by the association are found.
Alternatively, the Target Class can serve as the start of a traversal
of the association in the reverse direction.

Domain \{I,R35,R38}::
    The name of the domain to which the target class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the target class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R35,R38}::
    The name of the relationship in which the target class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the target class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class TargetClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R35 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R35

* *Target Class* is the target member for _exactly one_ *Class Based Association*
* *Class Based Association* has a target member of _exactly one_ *Target Class*

Each Class Based Association designates one of the participant classes
to serve the role as the target of traversal.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R35 TargetClass 1--1 ClassBasedAssociation
----

=== Associator Class

For a Class Based Association,
the Associator Class is that class which holds references to the
participating classes.
Each instance of an Associator Class represents an instance of the
association between the participants.

Domain \{I,R42,R40,R93}::
    The name of the domain to which the associator class belongs.
[horizontal]
    Data Type::: Refers to Class Based Association.Domain,
    Class Role.Domain and Associator Reference.Domain.
Class \{I,R40,R93}::
    The name of the associator class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Associator Reference.Domain.
Relationship \{I,R42,R40,R93}::
    The name of the relationship in which the associator class
    participates.
[horizontal]
    Data Type::: Refers to Class Based Association.Name,
    Class Role.Relationship and Associator Reference.Name.
Role \{I,R40}::
    The role the associator class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssociatorClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R42 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R93 AssociatorReference -link Domain -link Class\
        -link {Relationship Name}
}
----

=== R42

* *Associator Class* is the referring member of _exactly one_
*Class Based Association*
* *Class Based Association* has a referring member of _exactly one_
*Associator Class*

Class Based Associations must have a class that serves the role of
the associator and holds the references to the participating classes.
That role is served by exactly one class in the association.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R42 AssociatorClass 1--1 ClassBasedAssociation
----

=== R38

* *Association Participant Class* is a *Simple Referring Class*,
*Simple Referenced Class*, *Source Class* or *Target Class*

All the class roles that participate in a association relationships
can be generalized to be an Association Participant Class.
The common characteristic of these classes is that they
may hold pointer references to other classes in the association.

[source,tcl]
----
<<platform relationships>>=
generalization R38 AssociationParticipantClass\
    SimpleReferringClass SimpleReferencedClass\
    SourceClass TargetClass
----

=== Association Participant Class

An Association Participant Class is that type of role in an association
where the class may hold references to other participants in the association.

Domain \{I,R40,R90}::
    The name of the domain to which the association participant class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Associator Reference.Domain.
Class \{I,R40,R90}::
    The name of the association participant class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Associator Reference.Domain.
Relationship \{I,R40,R90}::
    The name of the relationship in which the association participant class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship and
    Associator Reference.Name.
Role \{I,R40}::
    The role the association participant class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssociationParticipantClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R90 AssociationReference -link Domain -link Class\
        -link {Relationship Name}
}
----

=== Referenced Superclass

A Referenced Superclass is that role in a Reference Generalization
assumed by the superclass.

Domain \{I,R36,R46}::
    The name of the domain to which the referenced superclass class belongs.
[horizontal]
    Data Type::: Refers to Superclass.Domain and
    Reference Generalization.Domain.
Class \{I,R46}::
    The name of the referenced superclass class.
[horizontal]
    Data Type::: Refers to Superclass.Domain.
Relationship \{I,R36,R46}::
    The name of the relationship in which the referenced superclass class
    participates.
[horizontal]
    Data Type::: Refers to Superclass.Relationship and
    Reference Generalization.Name.
Role \{I,R46}::
    The role the referenced superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Superclass.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class ReferencedSuperclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R36 ReferenceGeneralization -link Domain -link {Relationship Name}
    reference R46 Superclass -link Domain -link Class -link Relationship -link Role
}
----

=== R36

* *Referenced Superclass* is the abstract member of _exactly one_
*Reference Generalization*
* *Reference Generalization* has an abstract member of _exactly one_
*Referenced Superclass*

Each generalization relationship has exactly one member that serves as
the abstract or superclass member.
We will also insist that superclass roles may not be played by any
of the participant subclasses in the generalization.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R36 ReferencedSuperclass 1--1 ReferenceGeneralization
----

=== Referring Subclass

For a Reference Generalization,
a Referring Subclass is that role played by a subclass.

Domain \{I,R37,R47}::
    The name of the domain to which the referring subclass class belongs.
[horizontal]
    Data Type::: Refers to Subclass.Domain and
    Reference Generalization.Domain.
Class \{I,R47}::
    The name of the referring subclass class.
[horizontal]
    Data Type::: Refers to Subclass.Domain.
Relationship \{I,R37,R47}::
    The name of the relationship in which the referring subclass class
    participates.
[horizontal]
    Data Type::: Refers to Subclass.Relationship and
    Reference Generalization.Name.
Role \{I,R47}::
    The role the referring subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Subclass.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class ReferringSubclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R37 ReferenceGeneralization -link Domain -link {Relationship Name}
    reference R47 Subclass -link Domain -link Class -link Relationship -link Role
}
----

=== R37

* *Referring Subclass* is a specific member of _exactly one_
*Reference Generalization*
* *Reference Generalization* has a specific member of _one or more_
*Referring Subclass*

Each generalization relationship has one or more participants that
are the specific members or subclasses of the generalization.
We will also insist that there are at least two subclass members
since partitioning a set into a single improper subset serves no
useful semantic reason.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R37 ReferringSubclass 1..*--1 ReferenceGeneralization
----

=== Union Superclass

For a Union Generalization,
the Union Superclass is that class that serves as a superclass in the
relationship.
This type of superclass will also be constructed so that the storage
for any related subclass will be a part of the memory allocated to the
superclass instance.
This provides a platform specific optimization of memory space for
simple generalizations.

Domain \{I,R46,R44,R96}::
    The name of the domain to which the union superclass class belongs.
[horizontal]
    Data Type::: Refers to Superclass.Domain,
    Reference Generalization.Domain and Subclass Container.Domain.
Class \{I,R46,R96}::
    The name of the union superclass class.
[horizontal]
    Data Type::: Refers to Superclass.Domain and Subclass Container.Domain.
Relationship \{I,R46,R44,R96}::
    The name of the relationship in which the union superclass class
    participates.
[horizontal]
    Data Type::: Refers to Superclass.Relationship,
    Union Generalization.Name, and Subclass Container.Name.
Role \{I,R46}::
    The role the union superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Superclass.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class UnionSuperclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R46 Superclass -link Domain -link Class -link Relationship -link Role
    reference R44 UnionGeneralization -link Domain -link {Relationship Name}
    reference R96 SubclassContainer -link Domain -link Class\
        -link {Relationship Name}
}
----

=== R44

* *Union Superclass* is the abstract member of _exactly one_
*Union Generalization*
* *Union Generalization* has an abstract member of _exactly one_
*Union Superclass*

Each generalization relationship has exactly one member that serves as
the abstract or superclass member.
We will also insist that superclass roles may not be played by any
of the participant subclasses in the generalization.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R44 UnionSuperclass 1--1 UnionGeneralization
----

=== Union Subclass

For a Union Generalization,
a Union Subclass is that role played by a subclass in the generalization.

Domain \{I,R47,R45}::
    The name of the domain to which the union subclass class belongs.
[horizontal]
    Data Type::: Refers to Subclass.Domain and Union Generalization.Domain.
Class \{I,R47}::
    The name of the union subclass class.
[horizontal]
    Data Type::: Refers to Subclass.Domain.
Relationship \{I,R47,R45}::
    The name of the relationship in which the referring subclass class
    participates.
[horizontal]
    Data Type::: Refers to Subclass.Relationship and Union Generalization.Name.
Role \{I,R47}::
    The role the union subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Subclass.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class UnionSubclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R47 Subclass -link Domain -link Class -link Relationship -link Role
    reference R45 UnionGeneralization -link Domain -link {Relationship Name}
}
----

=== R45

* *Union Subclass* is a specific member of _exactly one_
*Union Generalization*
* *Union Generalization* has a specific member of _one or more_
*Union Subclass*

Each generalization relationship has one or more participants that
are the specific members or subclasses of the generalization.
We will also insist that there are at least two subclass members
since partitioning a set into a single improper subset serves no
useful semantic reason.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R45 UnionSubclass 1..*--1 UnionGeneralization
----

=== Superclass

A Superclass is the abstract member of a generalization relationship
and serves the role of a superclass.

Domain \{I,R40}::
    The name of the domain to which the superclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Class \{I,R40}::
    The name of the superclass class.
[horizontal]
    Data Type::: Refers to Class Role.Class
Relationship \{I,R40}::
    The name of the relationship in which the superclass class participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship
Role \{I,R40}::
    The role the superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class Superclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
}
----

=== R46

* *Superclass* is a *Referenced Superclass* or *Union Superclass*

The `micca` platform supports two different implementation means for
representing a superclass in a generalization relationship.
A generalization may be represented using pointer references or as
a discriminated union.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R46 Superclass ReferencedSuperclass UnionSuperclass
----

=== Subclass

A Subclass is the specific member of a generalization relationship
and serves the role of a subclass.

Domain \{I,R40}::
    The name of the domain to which the subclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Class \{I,R40}::
    The name of the subclass class.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Relationship \{I,R40}::
    The name of the relationship in which the subclass class participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship
Role \{I,R40}::
    The role the subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Subclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
}
----

=== R47

* *Subclass* is a *Referenced Subclass* or *Union Subclass*

The `micca` platform supports two different implementation means for
representing a subclass in a generalization relationship.
A generalization may be represented using pointer references or as
a discriminated union.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R47 Subclass ReferringSubclass UnionSubclass
----

=== Class Role

A Class Role is an abstraction of the various ways that classes may
participate in relationships.
The major concept in the relationship subsystem is to define the
various types of relationships and then abstract the way that classes
participate in the relationships and the roles they play in holding
referential attributes, etc.

Domain \{I,R41}::
    The name of the domain to which the class role class belongs.
[horizontal]
    Data Type::: Refers to Class.Domain and Relationships.Domain.
Class \{I,R41}::
    The name of the class role class.
[horizontal]
    Data Type::: Refers to Class.Name.
Relationship \{I,R41}::
    The name of the relationship in which the class role class participates.
[horizontal]
    Data Type::: Refers to Relationship.Name.
Role \{I,R40}::
    The role the class role class plays in the relationship.
    There are three roles available to a class.
    It may be a _source_, _target_ or _associator_.
    Note that the Role attribute is part of the identifier of the class.
    This accounts for reflexive associations where the same class
    will play two different roles in the association.
[horizontal]
    Data Type::: {source, target, associator}.

==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassRole {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1 -check {$Role in {source target associator}}

    reference R41 Relationship -link Domain -link {Relationship Name}
    reference R41 Class -link Domain -link {Class Name}
}
----

=== R40

* *Class Role* is a *Association Participant Class*, *Associator Class*,
*Superclass*, or *Subclass*

Classes play various roles when that are involved in relationships.
This generalization abstracts the various ways that classes are involved
in relationships into a role.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R40 ClassRole AssociationParticipantClass AssociatorClass\
    Superclass Subclass
----

=== R41

* *Class Role* _is an instance of_ *Relationship* models the association
between _one or more_ *Class*
* *Class Role* _is an instance of_ *Class* participates in _zero or more_
*Relationship*

Classes may participate in relationships to model the real world
associations between the classes.
It is possible (but not usual) for a class not to participate in any
relationship.
Relationships alway involve the participation of one or more classes
(usually two or three).
Note that *Class Role* has an additional identifying attribute, *Role*,
so that *R41* is actually a many-to-many-to-many association.
This additional multiplicity is required since reflexive relationships
have the same class playing more than one role in the relationship.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R41 Relationship 0..*--1..* Class -associator ClassRole
----

== References Subsystem

=== Introduction

In the Relationship subsystem,
we say how the platform models relationships and how classes play a
role in realizing the relationship.
In the References subsystem,
we map the roles a class plays in realizing a relationship to the
components that the class instances must store.
This mapping joins back up with the Class Components seen in the
Classes subsystem

Below is the UML class diagram for the references subsystem of the platform
model.

image::platform-references.pdf[title="References Subsystem Class Diagram"]

=== R90

* *Association Participant Class* holds references in _at most one_
*Association Reference*
* *Association Reference* is a reference holder for _one or more_
*Association Participant Class*

When a class serves as an Association Participant Class it may hold
pointer references to the other class in the association.
There may be no pointer references at for relationships directions that are not
traversed.
Each Association Reference hold one or two pointers, with two pointers
being required for reflexive relationships.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R90 AssociationParticipantClass 1..*--0..1 AssociationReference
----

=== R91

* *Super Class Reference* is a reference for _exactly one_ *Referring Subclass*
* *Referring Subclass* references via _at most one_ *Superclass Reference*

When a Referring Subclass stores a reference to its superclass it does so
in a *Superclass Reference*.
Not all Referring Subclass instances are navigated to the superclass so
the Referring Subclass may have no references to its superclass.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R91 SuperclassReference 0..1--1 ReferringSubclass
----

=== R92

* *Subclass Reference* is the reference to a subclass for _exactly one_
*Referenced Superclass*
* *Referenced Superclass* references subclasses via _at most one_
*Subclass Reference*

When a superclass in a reference generalization stores its reference to
its currently related subclass in a *Subclass Reference*.
If the superclass to subclass path of the generalization is not navigated,
then there need not be any associated Subclass Reference.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R92 SubclassReference 0..1--1 ReferencedSuperclass
----

=== R93

* *Associator Class* references participants via _exactly one_
*Associator Reference*
* *Associator Reference* is the reference for _exactly one_ *Associator Class*

An Associator Class must hold references to both participants of the
association and does so in an Associator Reference.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R93 AssociatorClass 1--1 AssociatorReference
----

=== R96

* *Union Superclass* stores subclass instances in _exactly one_
*Subclass Container*
* *Subclass Container* is the storage for subclasses of _exactly one_
*Union Superclass*

The use of a discriminated union to store associated subclass instances
in a superclass instance memory structure eliminates the need for
various reference pointers.
The Union Superclass stores the currently related subclass instance
in the Subclass Container that can be used to disinguish the type of 
the related subclass.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R96 UnionSuperclass 1--1 SubclassContainer
----

== State Model Subsystem

=== Introduction

The class, relationship and reference subsystems describe how model level
concepts of classes and relationships are mapped to implementation level
concepts of structures and pointers.
In the state model subsystem we turn our attention to the dynamics
and sequencing of execution of the model.

The classes in the state model subsystem capture the essential information
of a Moore type state model along with the XUML conventions of how
to specify ignored and error transitions.
The sequencing of execution via dispatch of state machine events is
handled by the run time mechanisms of `micca`.
The run time is completely data driven.
So our focus in the platform model is to capture that data needed to
generate the data structures used by the run time mechanisms.
The implications of this are that the state model subsystem is relatively
platform independent.
There are no particular ``C'' language implications of dispatching events
to state machines since the there is no particular ``C'' language
constructs specific to state machines.
The run time mechanisms must supply all the logic around event dispatch.
We will find it convenient to include some sequential numeric attributes
since the run time will use array data structures to access some types
of information and we would like a rather direct way of computing
appropriate array indices.

Below is the UML class diagram for the state model subsystem of the platform
model.

image::platform-statemodel.pdf[title="State Model Subsystem Class Diagram"]

A *State Model* is of one of two types (*R50*),
an *Instance State Model* or an *Assigner State Model*.
An *Instance State Model* is associated with a *Class* (*R51*) and an
*Assigner State Model* is associated with an *Association* relationship (*R52*).
Both types of state models operate the same.
They contain a set of *States* (*R55*) and possibly a *Creation State* (*R56*).
A *State Model* has a default *Transition Rule* (*R59*) to resolve
unspecified transitions and an initial state (*R58*) to know where things
start.
A *State* has an executable activity and that activity may have
*Activity Parameters* (*R60*).
All the *States* and the *Creation State* constitute a *State Place* where
the state model can transition when it has an event dispatched to it (*R57*).
An *Assigner State Model* also consists of two types (*R53*),
*Single Assigner* and *Multiple Assigner*.
A *Single Assigner* has only a single instance while a
*Multiple Assigner* has a many instances as the *Class* that
partitions is behavior (*R54*).

=== State Model

A State Model is a finite automaton, specifically a Moore type state machine.
A State Model is used to define the sequencing of execution for the
lifecycle of its assocated class or assigner.
The State Model defines behavior that is common to all of the associated
instances or assigners and each instance or assigner instance has its own
notion of its current state.

Domain \{I,R58}::
    The domain in which the state model resides.
[horizontal]
    Data Type::: Refers to State.Domain
Model \{I,R58}::
    The name of the class or association for which the state model operates.
[horizontal]
    Data Type::: Refers to State.Model
InitialState \{R58}::
    The name of the state into which the a newly create state model is placed
    by default.
[horizontal]
    Data Type::: Refers to State.Name
DefaultTrans \{R59}::
    The name of the default transition rule.
[horizontal]
    Data Type::: Refers to Transition Rule.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class StateModel {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute InitialState string
    attribute DefaultTrans string

    reference R58 State -link Domain -link Model -link {InitialState Name}
    reference R59 TransitionRule -link {DefaultTrans Name}
}
----

=== R58

* *State Model* is sync created in _exactly one_ *State*
* *State* is the sync creation place for _at most one_ *State Model*

When an entity that has an associated State Model is create synchronously,
it is placed in an initial state.
No state activity is run as part of the synchronous creation.
Not all States of a State Model serve the role of being the default
initial state.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R58 StateModel 0..1--1 State
----

=== R59

* *State Model* transitions by default via _exactly one_ *Transition Rule*
* *Transition Rule* is the default transition for _at most one_ *State Model*

When specifying the state transitions for a state model,
not all transitions must be specified explicitly.
Those transition not explicitly specified are are give the value of
a Transition Rule.
Since there multiple Transition Rules, any given Transition Rule may not be
used as a default transition for a State Model.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R59 StateModel 0..1--1 TransitionRule
----

=== R50

* *State Model* is a *Instance State Model* or *Assigner State Model*

The execution rules of XUML allow the lifecycle of either a class or an
association to be described by a State Model.
These are the only two domain entities that exhibit lifecycle behavior.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R50 StateModel InstanceStateModel AssignerStateModel
----

=== Instance State Model

An Instance State Model is that type of state model associated with the
lifecycle of a class instance.

Domain \{I,R50,R51}::
    The domain in which the instance state model resides.
[horizontal]
    Data Type::: Refers to Class.Domain and State Model.Domain
Class \{I,R50,R51}::
    The name of the class for which the instance state model operates.
[horizontal]
    Data Type::: Refers to Class.Name and State Model.Model

==== Implementation

[source,tcl]
----
<<platform classes>>=
class InstanceStateModel {
    attribute Domain string -id 1
    attribute Class string -id 1

    reference R50 StateModel -link Domain -link {Class Model}
    reference R51 Class -link Domain -link {Class Name}
}
----

=== R51

* *Instance State Model* describes the lifecycle of _exactly one_ *Class*
* *Class* lifecycle is described by _at most one_ *Instance State Model*

An Instance State Model is the definition of the lifecycle behavior
for only one class but not all classes will exhibit lifecycle behavior and
so may not have an Instance State Model.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R51 InstanceStateModel 0..1--1 Class
----

=== Assigner State Model

An Assigner State Model is that type of state model associated with the
lifecycle of an association relationship.
Sometimes the semantics of the domain subject matter are such that
forming and breaking an association must be serialized.
The archetypical example is where the association is competitive
and parallel activity could create incorrect association linkages.

Domain \{I,R50,R52}::
    The domain in which the assigner state model resides.
[horizontal]
    Data Type::: Refers to Association.Domain and State Model.Domain
Association \{I,R50,R52}::
    The name of the association relationship for which the assigner state
    model operates.
[horizontal]
    Data Type::: Refers to Association.Name and State Model.Model

==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssignerStateModel {
    attribute Domain string -id 1
    attribute Association string -id 1

    reference R50 StateModel -link Domain -link {Association Model}
    reference R52 Association -link Domain -link {Association Name}
}
----

=== R52

* *Assigner State Model* describes the lifecycle of _exactly one_ *Association*
* *Association* lifecycle is described by _at most one_ *Assigner State Model*

An Assigner State Model is the definition of the lifecycle behavior for only
one association relationship but not all associations will exhibit lifecycle
behavior and so may not have an Assigner State Model.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R52 AssignerStateModel 0..1--1 Association
----

=== State

A State is one of the components of a State Model.
States have a name that is disctinct among the other states of the State Model
and have an executable activity that is run by the system when the
state is entered upon a transition.

Domain \{I,R55,R57,R61}::
    The domain in which the state resides.
[horizontal]
    Data Type::: Refers to State Model.Domain and State Place.Domain
Model \{I,R55,R57,R61}::
    The name of the state model to which the state belongs.
[horizontal]
    Data Type::: Refers to State Model.Model and State Place.Model
Name \{I,R57}::
    The name of the state.
[horizontal]
    Data Type::: c-identifier
Activity::
    The body of code that is executed when the state is entered.
[horizontal]
    Data Type::: string
IsFinal::
    Determines whether the class instance will be automatically deleted
    when the state activity is completed.
[horizontal]
    Data Type::: boolean
SigID \{R61}::
    The identifier of the parameter signature for the state.
[horizontal]
    Data Type::: Refers to Parameter Signature.SigID

==== Implementation

[source,tcl]
----
<<platform classes>>=
class State {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Name string -id 1
    attribute Activity string
    attribute IsFinal boolean
    attribute SigID string

    reference R55 StateModel -link Domain -link Model
    reference R57 StatePlace -link Domain -link Model -link Name
    reference R61 ParameterSignature -link Domain -link Model -link SigID
}
----

=== R55

* *State* is an active element of _exactly one_ *State Model*
* *State Model* acts via _one or more_ *State*

A State is part of only a single State Model.
Sharing states between state models is not allowed.
Every State Model must have at least one state.
The notion of an empty state model does not carry any behavior which it
the purpose of a state model.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R55 State 1..*--1 StateModel
----

=== Parameter Signature

A State can define formal parameters for its activity.
The set of those parameters form a signature for the state.
Any event that causes a transition into a given state must carry
argument values that match the formal parameters of the state,
_i.e._ the event can be considered to have the same signature at the
state into which it causes a transition.

Domain \{I}::
    The domain in which the parameter signature resides.
[horizontal]
    Data Type::: string
Model \{I}::
    The name of the state model to which the parameter signature belongs.
[horizontal]
    Data Type::: string
SigID \{I}::
    The identifier of the parameter signature for the state.
[horizontal]
    Data Type::: arbitrary identfier

==== Implementation

[source,tcl]
----
<<platform classes>>=
class ParameterSignature {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute SigID string -id 1
}
----

=== R61

* *State* has an activity interface of _at most one_ *Parameter Signature*
* *Parameter Signature* is the activity interface of _one or more_ *State*

The parameters of the activity of a state constitute its signature.
A state may have no signature if it has no parameters.
Within a given model,
several state may have the same signature.
This allows an event to have the same signature but cause a transition
to different states.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R61 State 1..*--0..1 ParameterSignature
----

=== Activity Parameter

An Activity Parameter is a formal parameter to the activity of a state.
When the state activity is executed,
the transitioning event carrys the actual argument values for
each parameter.

Domain \{I,I2,R60}::
    The domain in which the activity parameter resides.
[horizontal]
    Data Type::: Refers to State.Domain
Model \{I,I2,R60}::
    The name of the state model to which the activity parameter belongs.
[horizontal]
    Data Type::: Refers to State.Model
State \{I,I2,R60}::
    The name of the state to which the activity parameter is a parameter.
[horizontal]
    Data Type::: Refers to State.Name
Name \{I}::
    The name of the activity parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    A sequential number given to the parameter to enable invoking
    a state activity and passing its parameters by order.
[horizontal]
    Data Type::: sequential numeric
DataType::
    The data type of the activity parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation

[source,tcl]
----
<<platform classes>>=
class ActivityParameter {
    attribute Domain string -id 1 -id 2
    attribute Model string -id 1 -id 2
    attribute SigID string -id 1 -id 2
    attribute Name string -id 1
    attribute Number string -id 2
    attribute DataType string

    reference R60 ParameterSignature -link Domain -link Model -link SigID
}
----

=== R60

* *Activity Parameter* is a formal parameter to _exactly one_
*Parameter Signature*
* *Parameter Signature* has a formal parameter of _one or more_
*Activity Parameter*

When a State is entered on a transition of a dispatched event,
its activity is executed.
The event causing the transition may carry argument values for the
state activity.
An Activity Parameter is a description of the formal parameters that
the state activity accepts.
An Activity Parameter is always part of a Parameter Signature.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R60 ActivityParameter 1..*--1 ParameterSignature
----

=== Creation State

When a entity that has an associated State Model is created
asynchonously by a creation event,
it is placed in a pseudo-initial state.
The creation event is then dispatched to the instance, causing a
transition to a real state and the consequent execution of the
destination state activity.
The Creation State is the state the instance resides in temporarily
until the creation event is dispatched.
It differs from an ordinary state in that it can have no activity
associated with it and can only have out-bound transitions
(_i.e._ you cannot transition into a Creation State).

Domain \{I,R56,R57}::
    The domain in which the creation state resides.
[horizontal]
    Data Type::: Refers to State Model.Domain and State Place.Domain
Model \{I,R56,R57}::
    The name of the state model to which the creation state belongs.
[horizontal]
    Data Type::: Refers to State Model.Model and State Place.Model
Name \{I,R57}::
    The name of the creation state.
    Since a State Model may have at most one Creation State (by R56)
    and since a Creation State does not result in creating any
    ``C'' language identifiers, we choose a distinctive name for
    the Creation State that is outside of the domain for ordination
    state names.
    It suffices to choose the literal string ``@''
    to distinguish the Creation State.
[horizontal]
    Data Type::: the literal string ``@''

==== Implementation

[source,tcl]
----
<<platform classes>>=
class CreationState {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Name string -id 1

    reference R56 StateModel -link Domain -link Model
    reference R57 StatePlace -link Domain -link Model -link Name
}
----

=== R56

A State Model may have at most one Creation State and that Creation State
is unique to a given State Model.
Not all State Models have creation events defined for them, _i.e._
not all Classes support asynchronous creation.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R56 CreationState 0..1--1 StateModel
----

=== State Place

A State Place is an abstract location from which an event transition may
occur.

Domain \{I,I2}::
    The domain in which the state place resides.
[horizontal]
    Data Type::: string
Model \{I,I2}::
    The name of the state model to which the state place belongs.
[horizontal]
    Data Type::: string
Name \{I}::
    The name of the state place.
[horizontal]
    Data Type::: Union of State.Name and Creation State.Name
Number \{I2}::
    A sequential number given to the state place to aid in the encoding
    of states required during code generation.
[horizontal]
    Data Type::: sequential numeric

==== Implementation

[source,tcl]
----
<<platform classes>>=
class StatePlace {
    attribute Domain string -id 1 -id 2
    attribute Model string -id 1 -id 2
    attribute Name string -id 1
    attribute Number string -id 2
}
----

=== R57

* *State Place* is a *State* or *Creation State*

State transitions can originate from either a State or a Creation State.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R57 StatePlace State CreationState
----

=== Transition Rule

The execution rules for XUML state models allow for two types of
transition specifications that do not actually cause a transition in
a state machine.
These rules simplify the specification of state models.
One transition rule states that an event is to be ignored in a state
and is named, ``IG''.
The other transition rule states that it is a logical impossiblity for
the event to be received in the state and is named, ``CH''
(for ``can't happen'').

Name \{I}::
    The name of the transition rule.
[horizontal]
    Data Type::: {IG, CH}
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class TransitionRule {
    attribute Name string -id 1 -check {$Name in {IG CH}}
}
----

=== R53

* *Assigner State Model* is a *Single Assigner* or *Multiple Assigner*

When an association has an Assigner State Model,
it may exist as a singleton or it may have multple instances of the
assigner.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R53 AssignerStateModel SingleAssigner MultipleAssigner
----

=== Single Assigner

A Single Assigner is a type of Assigner State Model that is used
when a competitive association must be serialized through one
execution path.
This is the most frequent case.

Domain \{I,R53}::
    The domain in which the single assigner resides.
[horizontal]
    Data Type::: Refers to Assigner State Model.Domain
Association \{I,R53}::
    The name of the association relationship for which the single assigner
    operates.
[horizontal]
    Data Type::: Refers to Assigner State Model.Association
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SingleAssigner {
    attribute Domain string -id 1
    attribute Association string -id 1

    reference R53 AssignerStateModel -link Domain -link Association
}
----

=== Multiple Assigner

A Multiple Assigner is a type of Assigner State Model that is used
when a competitive association is partitioned into distinct subsets
wherein the assignment of the association is made.

Domain \{I,R53,R54}::
    The domain in which the multiple assigner resides.
[horizontal]
    Data Type::: Refers to Assigner State Model.Domain
    and Class.Domain
Association \{I,R53}::
    The name of the association relationship for which the multiple assigner
    operates.
[horizontal]
    Data Type::: Refers to Assigner State Model.Association
Class \{R54}::
    The name of the class whose instances partition the multiple assigner.
[horizontal]
    Data Type::: Refers to Class.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class MultipleAssigner {
    attribute Domain string -id 1
    attribute Association string -id 1
    attribute Class string

    reference R53 AssignerStateModel -link Domain -link Association
    reference R54 Class -link Domain -link {Class Name}
    reference R104 ValueElement -link Domain -link {Association Name}
}
----

=== R54

* *Multiple Assigner* is partitioned by _exactly one_ *Class*
* *Class* partions instance of _zero or more_ *Multple Assigner*

A Multiple Assigner operates on association instances that are divided
into sets associated with the instance of some Class.
Not all Classes partition Multiple Assigners.
The archetypical example of a Multiple Assigner is where a clerk
services customers but the clerk only services customers who are shopping
int the department in which the clerk works.
In this case the department serves to partition the assignment of
clerks to customers to insure that assignments occur within the context
of the department in which the clerk works.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R54 MultipleAssigner 0..*--1 Class
----

== Event Subsystem

=== Introduction
The Event subsystem is concerned with classifying events that drive
state machine transitions.
The complexity here is that the execution rules for XUML allow for
one form of polymorphism, namely polymorphic events.

A polymorphic event can arise only in the context of a generalization
relationship.
Events can be designated as polymorphic and when such an event is
signaled to a superclass instance,
it is mapped at run time to an event in the subclass instance that
is currently related to superclass instance.
The net effect is to allow the subclasses of a generalization all to respond to
the same events and yet the events are signaled to the superclass instances of
the generalization.

Strictly speaking event polymorphism is an optimization performed by the run
time mechanisms since mapping an event to a subclass could be performed as part
of the state activity.
However, such code is repetitive and rather fragile in the wake of
adding or deleting subclasses in a generalization.
This is a case where the system can ``know'' the right thing to do
and remove a significant burden from the model level processing.

In its most common usage,
polymorphic events are quite straight forward.
Events are designated as polymorphic by the superclass and
they are used as ordinary events by the state models of the subclasses.
In its most general usage however,
we must account for both repeated generalization (_i.e._ where a subclass
serves as the superclass for a futher generalization) and
compound generalization (_i.e._ where a class is the superclass for
multiple generalization relationships).
The full set of rules and implications of polymorphic events can be rather
daunting.

* Associating polymorphic events with a superclass does _not_ imply
that the superclass has no state behavior of its own.
A superclass may have both a state model and polymorphic events since
generating a polymorphic event to a superclass does not result in any
behavior in the superclass.
* A given superclass may be the superclass of multiple generalizations.
In this case, generating an event to an instance of such a superclass
will cause an event to be generated to all generalizations for which
the class is a superclass.
In this way, a single event generated may result in multiple events being
dispatched.
* The state model for a subclass may respond to
ordinary events that are not part of the polymorphic event set associated
with the generalization.
Such events may be generated directly to instances of the subclass
or they may be self generated.
* A class that is a subclass may also be a superclass of another generalization,
_i.e._ a subclass may be subject to repeated generalization.
Such a mid-level class may designate additional polymorphic events associated
with the generalization relationship for which it is the superclass.
Also a mid-level class may delegate polymorphic events associated with its
subclass role to any hierarchy for which it serves as a superclass.
* All leaf classes, _i.e._ subclasses which are _not_
the superclass of another generalization,
must consume as ordinary events all polymorphic events delegated to them.
It is sufficient to ignore or deem an event as can't happen, but
polymorphic events are mapped ultimately to ordinary events.

Note also that generalizations are _not_ subject to the so called
``diamond'' construct where a given class is a subclass of multiple
generalizations which themselves have a common superclass ancestor.
Blessedly,
referential integrity simply does not allow such a beast to be constructed.

These rules give rise to the following class model for state model events.

image::platform-event.pdf[title="Event Subsystem Class Diagram"]

An *Event* can be of two types (*R80*), either a *Deferred Event* or a
*Transitioning Event*.
A *Transitioning Event* actually causes state transition in a *State Model*
(*R87*).
A *Deferred Event* arises from a *Superclass* across a *Deferral Path* (*R86*).
Because of *R80*,
ordinary events and polymorphic events in a superclass must have different
names.
We do consider this an advantage in avoiding confusion between polymorphic
events and ordinary events in the superclass.
A *Transitioning Event* is either a locally defined *Local Event*
or a *Mapped Event* (*R82*).
A *Local Event* is specified directly by a state model and a
*Mapped Event* is a deferred event as it is consumed in state model (*R84*).
A *Deferred Event* is either a *Polymorphic Event* defined directly by
a superclass or is delegated as an *Inherited Event*
from another generalization for which the class was a subclass.
Both an *Inherited Event* or a *Mapped Event* are forms of
*Non-Local Event* (*R83*) and a *Non-Local Event* may only be defined
to act upon a *Subclass* (*R85*).

=== Event

An Event is a stimulus to a state model that has to potential to cause
a transition.

Domain \{I}::
    The domain in which the event resides.
[horizontal]
    Data Type::: string
Model \{I}::
    The name of the state model to which the event belongs.
[horizontal]
    Data Type::: string
Event \{I}::
    The name of the event.
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Event {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
}
----

=== R80

* *Event* is a *Deferred Event* or *Transitioning Event*

There are two types of events.
Those that cause an immediate effect on a state model are
*Transitioning Events*.
Those that are mapped at run time to an event in a subclass are
*Deferred Events*.
The execution rules do not allow for any other types of events.
Note that a creation event is just another form of *Transitioning Event*.
The only difference is that the run time mechanism creates the
class instance immediately before dispatching the creation event to it.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R80 Event DeferredEvent TransitioningEvent
----

=== Deferred Event

A Deferred Event is that type of event which is specified in a
Superclass but which is mapped to an event in a Subclass.

Domain \{I,I2,R80}::
    The domain in which the deferred event resides.
[horizontal]
    Data Type::: Refers to Event.Domain
Model \{I,I2,R80}::
    The name of the state model to which the deferred event belongs.
[horizontal]
    Data Type::: Refers to Event.Model
Event \{I,R80}::
    The name of the deferred event.
[horizontal]
    Data Type::: Refers to Event.Event
Number \{I2}::
    A ordinal number for the deferred event. We find it convenient to
    number the deferred events in a manner that would allow the
    number to be used as an array index.
[horizontal]
    Data Type::: Zero based sequential integer

==== Implementation

[source,tcl]
----
<<platform classes>>=
class DeferredEvent {
    attribute Domain string -id 1 -id 2
    attribute Model string -id 1 -id 2
    attribute Event string -id 1
    attribute Number int -id 2

    reference R80 Event -link Domain -link Model -link Event
}
----

=== R81

* *Deferred Event* is a *Polymorphic Event* or *Inherited Event*

There are two source of events that are deferred.
Deferral happens in the sense that the events do not affect the behavior of the
superclass to which they are sent.
A superclass may declare an event as polymorphic or a
subclass of a generalization may choose to not act upon the event
if it is also the superclass of a different generalization.
In the later case,
the event not acted upon is inherited by the subclasses.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R81 DeferredEvent PolymorphicEvent InheritedEvent
----

=== Deferral Path

A Deferral Path is traversal along a generalization relationship
where an event is being deferred to a subclass of the generalization.

Domain \{I,R80}::
    The domain in which the deferral path resides.
[horizontal]
    Data Type::: Refers to Superclass.Domain and Deferred Event.Domain
Model \{I,R80}::
    The name of the state model to which the deferral path belongs.
[horizontal]
    Data Type::: Refers to Superclass.Class and Deferred Event.Model
Event \{I,R80}::
    The name of the event that is being deferred along the deferral path.
[horizontal]
    Data Type::: Refers to Deferred Event.Event
Relationship \{I,R86}::
    The generalization relationship along which the event is deferred.
[horizontal]
    Data Type::: Refers to Superclass.Relationship
Role \{I,R86}::
    The role of the superclass which is deferring an event.
[horizontal]
    Data Type::: Refers to Superclass.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class DeferralPath {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R86 DeferredEvent -link Domain -link Model -link Event
    reference R86 Superclass -link Domain -link {Model Class}\
        -link Relationship -link Role
}
----

=== R86

* *Deferral Path* is an instance of
*Superclass* propagates _zero or more_ *Deferred Event*
* *Deferral Path* is an instance of
*Deferred Event* is propagated by _one or more_ *Superclass*

Event polymorphism allows an event in a Superclass to be deferred
to the subclasses.
Not all Superclasses define polymorphic events.
A given polymorphic event may be propagated along mulitple generalization
relationships in the case of a compound generalization,
_i.e._ a superclass that is the a superclass for multiple generalizations.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R86 Superclass 1..*--0..* DeferredEvent -associator DeferralPath
----

=== Transitioning Event

A Transitioning Event is that type of event that has the potential to
cause a state transition when dispatched to a state machine.

Domain \{I,R80,R87}::
    The domain in which the transitioning event resides.
[horizontal]
    Data Type::: Refers to Event.Domain and State Model.Domain
Model \{I,R80,R87}::
    The name of the state model to which the transitioning event belongs.
[horizontal]
    Data Type::: Refers to Event.Model and State Model.Model
Event \{I,R80}::
    The name of the transitioning event.
[horizontal]
    Data Type::: Refers to Event.Event
Number \{I2}::
    A ordinal number for the transitioning event. We find it convenient to
    number the deferred events in a manner that would allow the
    number to be used as an array index.
[horizontal]
    Data Type::: Zero based sequential integer

==== Implementation

[source,tcl]
----
<<platform classes>>=
class TransitioningEvent {
    attribute Domain string -id 1 -id 2
    attribute Model string -id 1 -id 2
    attribute Event string -id 1
    attribute Number int -id 2

    reference R80 Event -link Domain -link Model -link Event
    reference R87 StateModel -link Domain -link Model
}
----

=== R82

* *Transitioning Event* is a *Mapped Event* or *Local Event*

Events that can cause state transitions arise from two circumstances.
First, they may be locally defined.
This is usually the preponderance of events.
Second, the event could have been deferred from a superclass and
when it dispatched to a subclass is mapped into an event defined
for the subclass.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R82 TransitioningEvent MappedEvent LocalEvent
----

=== R87

* *Transitioning Event* causes transitions in _exactly one_ *State Model*
* *State Model* has transitions caused by _one or more_ *Transitioning Event*

Events that cause transition in a state model are defined to be specific
to that state model and all state models must respond to at least one event
by the definition of a state machine.
Of course, state models can, and usually do, respond to multiple events.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R87 TransitioningEvent 1..*--1 StateModel
----

=== Polymorphic Event

A polymorphic event is an event defined for the superclass of a generalization
that is to be mapped at run time to an event of one of the subclasses
of the generalization.
The run time mapping determines the subclass to which the superclass is
currently related and maps the event into one by the same name in the
subclass.

Domain \{I,R81}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Deferred Event.Domain
Model \{I,R81}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Deferred Event.Model
Event \{I,R81}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Deferred Event.Event

==== Implementation

[source,tcl]
----
<<platform classes>>=
class PolymorphicEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R81 DeferredEvent -link Domain -link Model -link Event
}
----

=== Inherited Event

A polymorphic event defined for superclass becomes an inherited
event in the subclasses of the generalization if a subclass does not
act upon the polymorphic event.
This can occur when the subclass is part of a repeated generalization
where it serves the role of subclass in a generalization that defines
the polymorphic event and serves the role of superclass in another
generalization.
The event can be thought of as being inherited down the hierarchy formed
by the repeated generalizations.

Domain \{I,R81,R83}::
    The domain in which the inherited event resides.
[horizontal]
    Data Type::: Refers to Deferred Event.Domain and Non-Local Event.Domain
Model \{I,R81,R83}::
    The name of the state model to which the inherited event belongs.
[horizontal]
    Data Type::: Refers to Deferred Event.Model and Non-Local Event.Model
Event \{I,R81,R83}::
    The name of the inherited event.
[horizontal]
    Data Type::: Refers to Deferred Event.Event and Non-Local Event.Event
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class InheritedEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R81 DeferredEvent -link Domain -link Model -link Event
    reference R83 Non-LocalEvent -link Domain -link Model -link Event
}
----

=== Mapped Event

When a deferred event is consumed by a subclass it becomes a
mapped event for the subclass state model.
This allows the subclass to define other events to which it may respond.

Domain \{I,R82,R83,R84}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Transitioning Event.Domain,
    Non-Local Event.Domain and Deferred Event.Domain
Model \{I,R82,R83}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Transitioning Event.Model and Non-Local Event.Model
Event \{I,R82,R83,R84}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event, Non-Local Event.Event
    and Deferred Event.Event
ParentModel \{R84}::
    The name of the state model from which the mapped event was deferred.
    Data Type::: Refers to Deferred Event.Model

==== Implementation

[source,tcl]
----
<<platform classes>>=
class MappedEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute ParentModel string

    reference R82 TransitioningEvent -link Domain -link Model -link Event
    reference R83 Non-LocalEvent -link Domain -link Model -link Event
    reference R84 DeferredEvent -link Domain -link {ParentModel Model}\
        -link Event
}
----

=== R84

* *Mapped Event* is the realization of _exactly one_ *Deferred Event*
* *Deferred Event* is realized as _at most one_ *Mapped Event*

When a deferred event is consumed, it becomes a mapped event in the
subclass where it is acted upon.
A mapped event always starts out as one that is deferred from a superclass.
Not all deferred events are necessarily mapped.
It is possible to defer an event through muliple generalizations before it
is finally consumed and becomes a mapped event.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R84 MappedEvent 0..*--1 DeferredEvent
----

=== Local Event

A local event is an event defined by a class and directly acted upon by the
state model of the class.
This forms the vast majority of defined events and all the events for
classes that are not subclasses of a generalization.

Domain \{I,R82}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Transitioning Event.Domain
Model \{I,R82}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Transitioning Event.Model
Event \{I,R82}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event

==== Implementation

[source,tcl]
----
<<platform classes>>=
class LocalEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R82 TransitioningEvent -link Domain -link Model -link Event
}
----

=== R83

* *Non-Local Event* is an *Inherited Event* or *Mapped Event*

Together, inherited and mapped events form a set of events that
do not originate from the immediate local state model definition.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R83 Non-LocalEvent InheritedEvent MappedEvent
----

=== Non-Local Event

A non-local event is that type of event that arises from polymorphic
events that are mapped through a generalization hierarchy.

Domain \{I,R85}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Subclass.Domain
Model \{I,R85}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Subclass.Class
Event \{I}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: string
Relationship \{R85}::
    The generalization relationship along which the non-local event is applied.
[horizontal]
    Data Type::: Refers to Subclass.Relationship
Role \{R85}::
    The role of the subclass to which the non-local event is applied.
[horizontal]
    Data Type::: Refers to Subclass.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class Non-LocalEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute Relationship string
    attribute Role string

    reference R85 Subclass -link Domain -link {Model Class} -link Relationship\
        -link Role
}
----

=== R85

* *Non-Local Event* affects _exactly one_ *Subclass*
* *Subclass* is affected by _zero or more_ *Non-Local Event*

Regardless of the source of non-local events, they can only cause
transition in the state model of a subclass.
Classes that are not subclasses cannot respond to non-local events.
Some subclasses will not have state models or polymorphic events
defined in their superclass.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R85 Non-LocalEvent 0..1--1 Subclass
----

== Transition Subsystem

=== Introduction

The Transition subsystem is concerned with the dispatch of state model
events.

image::platform-transition.pdf[title="Transition Subsystem Class Diagram"]

All the *State Places* and *Transitioning Events* combine to form a
transition matrix (*R70*) the cells of which are represented by
*Transition Places*.
There are two types of transitions that can occur in an state model (*R71*).
A *State Transition* causes the state machine to enter a new state
of the state model (*R72*).
A *Non-State Transition* does not cause a new state to be entered but
has the side effect of either ignoring the event or causing a system error
(*R73*).

=== Transition Place

The cartesian product of the state of a state model and the events of
the model form a conceptual transition matrix.
A transition place models the individual cells of the conceptual transition
matrix.

Domain \{I,R70}::
    The domain in which the transition place resides.
[horizontal]
    Data Type::: Refers to State Place.Domain and Transitioning Event.Domain
Model \{I,R70}::
    The name of the state model to which the transition place belongs.
[horizontal]
    Data Type::: Refers to State Place.Model and Transitioning Event.Model
State \{I,R70}::
    The name of the state to which the transition place refers.
[horizontal]
    Data Type::: Refers to State Place.Name
Event \{I,R70}::
    The name of the event which will cause a transition out of the
    transition place.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event

==== Implementation

[source,tcl]
----
<<platform classes>>=
class TransitionPlace {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1

    reference R70 StatePlace -link Domain -link Model -link {State Name}
    reference R70 TransitioningEvent -link Domain -link Model -link Event
}
----

=== R70

* *Transition Place* is an instance of *State Place* transitions according to
_zero or more_ *Transitioning Event*
* *Transition Place* is an instance of *Transitioning Event* drives transition
among _zero or more_ *State Place*

A state model operates by having a function that maps states and events
onto new states.
A Transition Place is one of the enumerations of that mapping function.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R70 StatePlace 0..*--0..* TransitioningEvent -associator TransitionPlace
----

=== R71
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R71 TransitionPlace StateTransition Non-StateTransition
----

=== State Transition

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class StateTransition {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1
    attribute NewState string

    reference R71 TransitionPlace -link Domain -link Model -link State\
        -link Event
    reference R72 State -link Domain -link Model -link {NewState Name}
}
----

=== R72
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R72 StateTransition 0..*--1 State
----

=== Non-State Transition

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Non-StateTransition {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1
    attribute TransRule string

    reference R71 TransitionPlace -link Domain -link Model -link State\
        -link Event
    reference R73 TransitionRule -link {TransRule Name}
}
----

=== R73
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R73 Non-StateTransition 0..*--1 TransitionRule
----

== Population Subsystem

=== Introduction
The Population subsystem is concerned with defining the
initial data values that class instances will have and to specifying
the storage characteristics for classes.
In a `micca` generated system,
there is no dynamic memory allocation and all class storage is specified
at compile time.

image::platform-population.pdf[title="Population Subsystem Class Diagram"]

=== Population

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Population {
    attribute Name string -id 1
    attribute Domain string -id 1

    reference R100 Domain -link {Domain Name}
}
----

=== R100
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R100 Population 0..*--1 Domain
----

=== Value Element

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ValueElement {
    attribute Domain string -id 1
    attribute Name string -id 1
}
----

=== Element Population

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ElementPopulation {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Element string -id 1
    attribute Allocation int

    reference R101 Population -link {Population Name} -link Domain
    reference R101 ValueElement -link Domain -link {Element Name}
}
----

=== R101
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R101 Population 0..*--1..* ValueElement -associator ElementPopulation
----

=== R104
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R104 ValueElement Class MultipleAssigner
----

=== Element Instance

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ElementInstance {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Element string -id 1
    attribute Instance string -id 1

    reference R102 ElementPopulation -link Population -link Domain -link Element
}
----

=== R102
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R102 ElementInstance 0..*--1 ElementPopulation
----

=== R105
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R105 ElementInstance ClassInstance MultipleAssignerInstance
----

=== Class Instance

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassInstance {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Instance string -id 1

    reference R105 ElementInstance -link Population -link Domain\
        -link {Class Element} -link Instance
}
----

=== Multiple Assigner Instance

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class MultipleAssignerInstance {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Association string -id 1
    attribute Instance string

    reference R105 ElementInstance -link Population -link Domain\
        -link {Association Element} -link Instance
}
----

=== R103
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R103 ClassInstance 0..*--1..* ClassComponent\
    -associator ClassComponentValue
----

=== Class Instance Value

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassComponentValue {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Component string -id 1
    attribute Instance string -id 1
    attribute Value string

    reference R103 ClassInstance -link Population -link Domain\
        -link Class -link Instance
    reference R103 ClassComponent -link Domain -link Class -link {Component Name}
}
----
