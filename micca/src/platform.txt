// vim:set syntax=asciidoc:
////
Template for classes.

=== Class 

Class description

Attribute Name::
    Attribute Description
[horizontal]
    Data Type::: Data type name

// repeated for each attribute

////

// Some attributes

:mult-attribute: This attribute records whether the reference by the class can be multiple.  Muliple associations may refer to more than one associated instances.  Singular association may refer to only one associated instance.

:cond-attribute: This attribute records whether the reference by the class is conditional. Conditional associations allow for there to be zero instances referred to. Unconditional associations insist that there must be at some instance referred to.


= The Micca Platform

[partintro]
--
In this part we present a class model of the platform specific model used
by `micca`.
Some readers will have studied platform independent models.
These are sometimes referred to as _meta-models_.
There is no single meta-model for XUML.
You can express the rules of executable modeling in a number of ways,
although the several meta-models that have been proposed have,
as would be expected,
many of the same constructs in them.
The model we present here is platform specific.
The platform we are targeting is single threaded with ``C'' as the
implementation language.
The platform also assumes that all data will be held in primary memory
and that all data storage is statically allocated.
Consequently,
some of the constructs in this model will be decidedly implementation
oriented.
It is, after all, meant to be specific to a particular computing technology.
A single threaded, ``C'' based implementation is *not* an appropriate
basis for all executable models.
It will, however, solve a large class of application types.
That is generally true of all translation technologies.
You must be specific about the chosen class of applications and then
choose appropriate computing technology that is applicable to that class
of applications.
There is no such thing as a universal software architecture any more than
there is a universal programming language.
All involve trade-offs of usually conflicting needs and requirements.

The role of the platform model is central to the overall translation
scheme.
Populating this model is the primary focus of the `micca` domain specific
language.
The code generation phase of the translation will query the populated
platform model to produce ``C'' language output to implement the
intent of the model.

Consequently,
we devote considerable effort to describing the platform model.
We divide the discussion up into several sections focused on
a particular subsystem of the platform model.
The platform model itself will be implemented as a `rosea` domain.
Intermixed with the platform model description is the implementation of the
model in `rosea`.
--

== Domain Subsystem

=== Introduction

The domain subsystem is concerned with defining the basic elements
of what constitutes a domain
Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-domain.pdf[title="Domain Subsystem Class Diagram"]

[[domain-subsystem-discussion]]
A *Domain* is identified by a *Name*.
A *Domain* consists of a set of *Domain Elements* (*R1*).
*Domain Elements* are of two types (*R2*),
*Class* and *Relationship*.
*R2* insures that classes and relationships have different names and this
insures there are no naming conflicts in the generated code.
For *Domain Element.*Name* attribute and many other names,
we will insist that names be able to be
used as ``C'' language identifiers, _i.e._ they must start with
a letter followed by an arbitrary number of letters, digits or underscore
characters.
The code generation process will use these names directly as this
eases the burden of finding model elements in the generated implementation.

A *Domain* may also define a set of *Domain Operation* (*R5*).
These operations constitute the invocable interface functions for the
*Domain*.
A *Domain* is otherwise encapsulated.
A *Domain Operation* may also have *Domain Operation Parameter* (*R6*)
associated with it.
It is also typical for a *Domain* to have a set of *Type Alias* (*R7*).
A *Type Alias* provides a convenient way to map model type names onto
``C'' implementation types.

A *Class* may also have a set of *Operation* (*R3*).
An *Operation* may also have a set of *Operation Parameter* (*R4*).

=== Domain

A domain is a real or imagined world with its own set of rules.

Name \{I}::
    Each domain in a system must have a unique name.
[horizontal]
    Data Type::: string
Interface::
    A Domain will, in general, have dependencies on other aspects of the
    system. The Interface attribute is a string that will be inserted
    in the generated interface header file for the domain.
    Typically, the Interface will contain `#include` ``C'' preprocessor
    statements, but may contain any other compiler declarations
    needed.
[horizontal]
    Data Type::: string
Prologue::
    The Prologue for a Domain is inserted into the code file before any
    `micca` generated code.
    This gives the translation the opportunity to have external or forward
    references needed to satisfy the ``C'' compiler.
[horizontal]
    Data Type::: string
Epilogue::
    The Epilogue for a Domain is inserted into the code file after any
    `micca` generated code.
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Domain {
    attribute Name string -id 1
    attribute Interface string -default {}
    attribute Prologue string -default {}
    attribute Epilogue string -default {}
}
----

=== Domain Element

A domain element is one of the constituent parts of a domain.

Domain \{I,R1}::
    The name of the domain to which the element belongs.
[horizontal]
    Data Type::: references Domain.Name
Name \{I}::
    Each domain elements is given a name that is unique within the domain.
[horizontal]
    Data Type::: c-identifier

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class DomainElement {
    attribute Domain string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}

    reference R1 Domain -link {Domain Name}
}
----

==== Checking for ``C'' Identifiers

Many names in the platform model will be directly used as an identifier in
the generated ``C'' code.
We insist they be of the correct form when the model is populated.
To be a proper identifier,
a name cannot be a keyword, must begin with an alphabetic character and
contain zero or more alphabetic, numeric or underscore characters.

[source,tcl]
----
<<helper data>>=
set keywords {_Bool _Complex _Imaginary auto break case char const
    continue default do double else enum extern float for goto if 
    inline int long register restrict return short signed sizeof static
    struct switch typedef union unsigned void volatile while}

<<helper commands>>=
proc isIdentifier {name} {
    variable keywords
    return [expr {[lsearch -sorted -exact $keywords $name] == -1 &&\
            [regexp {\A[[:alpha:]]\w*\Z} $name]}]
}
----

=== R1

* *Domain Element* is an entity of _exactly one_ *Domain*
* *Domain* models entities using _zero or more_ *Domain Element*

A domain is allowed to be empty of domain elements.
This is certainly not an extremely useful situation,
but we want to allow domain definitions to be cumulative.
Each element of a domain belongs strictly to a single domain,
_i.e._ domain elements are never shared between domains.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R1 DomainElement 0..*--1 Domain
----

=== Class

A Class represents a logical predicate about some aspect of a Domain.

Domain \{I,I2,R2,R104}::
    The name of the domain to which the class belongs.
[horizontal]
    Data Type::: References DomainElement.Domain
Name \{I,R2,R104}::
    Classes are identified by name within the domain to which they belong.
[horizontal]
    Data Type::: string
Number \{I2}::
    It is useful during code generationto have a sequential integer number for
    classes within a given domain.
[horizontal]
    Data Type::: sequential numeric

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class Class {
    attribute Domain string -id 1 -id 2
    attribute Name string -id 1 ; # <1>
    attribute Number int -id 2

    reference R2 DomainElement -link Domain -link Name
    reference R104 ValueElement -link Domain -link Name
}
----
<1> The question arises whether we need to check if *Class.Name* is a
valid ``C'' identifier.
The answer is no.
Since *Class.Name* refers to *DomainElement.Name* unconditionally,
the check on *DomainElement.Name* insures that *Class.Name* is a valid
``C'' identifier.
Otherwise, we would fail the referential integrity check indicated by *R2*.

=== Relationship

A Relationship represents a real world association between class instances.

Domain \{I,R2}::
    The name of the domain to which the relationsihp belongs.
[horizontal]
    Data Type::: References DomainElement.Domain
Name \{I,R2}::
    Relationships are identified by name within the domain to which they belong.
    Traditionally, relationships are given names of the form, "R<digit>+", where
    <digit> is a decimal number.
    Although the convention is very commonly used in the executable modeling
    world, relationships may be given any desired name.
[horizontal]
    Data Type::: string
Number \{I2}::
    It is useful during code generationto have a sequential integer number for
    relationships within a given domain.
[horizontal]
    Data Type::: sequential numeric

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class Relationship {
    attribute Domain string -id 1 -id 2
    attribute Name string -id 1
    attribute Number int -id 2 -system 0

    reference R2 DomainElement -link Domain -link Name
}
----

=== R2

* *DomainElement* is a *Class* or *Relationship*

There are only two types of domain elements, Classes and Relationships.
These elements model the logical predicates of the domain subject matter.

[source,tcl]
----
<<micca configuration>>=
generalization R2 DomainElement Class Relationship
----

=== Domain Operation

A Domain Operation is a executable body of code that provides
a service access point into a domain.
The set of domain operations of a domain constitute the invocable programming
interface to the domain.

Domain \{I,R5}::
    The name of the domain to which the domain operation belongs.
[horizontal]
    Data Type::: refers to Domain.Name
Name \{I}::
    The name of the operation. Domain operations are given names that
    must be unique only within a given domain.
[horizontal]
    Data Type:::: c-identifier
Body::
    The code that is to be executed when the domain operation is invoked.
    This code is presumed to be ``C'' language statements and,
    except for some preprocessing of the statements,
    is passed along in the generated output file for the domain.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the domain operation.
[horizontal]
    Data Type:::: c-typename

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class DomainOperation {
    attribute Domain string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Body string
    attribute ReturnDataType string

    reference R5 Domain -link {Domain Name}
}
----

=== R5

* *Domain Operation* is a service for _exactly one_ *Domain*
* *Domain* provides service via _zero or more_ *Domain Operation*

Domain operations only operate on a single domain.
However, a domain may not provide an explicit service entry points
and have no defined domain operations.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R5 DomainOperation 0..*--1 Domain
----

=== Domain Operation Parameter

A Domain Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R6}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to DomainOperation.Domain
Operation \{I,I2,R6}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to DomainOperation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list
    without reference to the parameter name.
[horizontal]
    Data Type::: numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class DomainOperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string

    reference R6 DomainOperation -link Domain -link {Operation Name}
}
----

=== R6

* *Domain Operation Parameter* defines a formal parameter of _exactly one_
    *Domain Operation*
* *Domain Operation* has a formal parameter defined by _zero or more_
    *Domain Operation Parameter*

A domain operation parameter definition only applies to a single operation.
However, domain operations may have no parameters
as it is valid to have ``C'' functions with no parameters.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R6 DomainOperationParameter 0..*--1 DomainOperation
----

=== Constructor

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class Constructor {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Body string

    reference R8 Class -link Domain -link {Class Name}
}
----

=== R8

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R8 Constructor 0..*--1 Class
----

=== Destructor

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class Destructor {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Body string

    reference R9 Class -link Domain -link {Class Name}
}
----

=== R9

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R9 Destructor 0..*--1 Class
----

=== Operation

An *Operation* is a executable body of code that computes on a
class or class instance.

Domain \{I,R3}::
    The name of the domain to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Domain
Class \{I,R3}::
    The name of the class to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Name
Name \{I}::
    The name of the operation. Operations are given names that
    must be unique only within a given class.
[horizontal]
    Data Type:::: c-identifier
IsInstance::
    This attribute determine whether the operation applies to class instances.
    If true, then the generated code for the operation will have
    an implicitly declared parameter named `self`.
[horizontal]
    Data Type:::: boolean
Body::
    The code that is to be executed when the operation is invoked.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the operation.
[horizontal]
    Data Type:::: c-typename

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class Operation {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute IsInstance boolean
    attribute Body string
    attribute ReturnDataType string

    reference R3 Class -link Domain -link {Class Name}
}
----

=== R3

* *Operation* operates over _exactly one_ *Class*
* *Class* is the domain for _zero or more_ *Operation*

Operations only operate on a single class.
However, a class may not provide any explicit operations.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R3 Operation 0..*--1 Class
----

=== Operation Parameter

An Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R4}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Domain
Class \{I,I2,R4}::
    The name of the class to which the parameter belongs.
[horizontal]
    Data Type::: refers to Operation.Class
Operation \{I,I2,R4}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list.
[horizontal]
    Data Type::: sequential numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class OperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Class string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string

    reference R4 Operation -link Domain -link Class -link {Operation Name}
}
----

=== R4

* *Operation Parameter* defines a formal parameter of _exactly one_
    *Operation*
* *Operation* has a formal parameter defined by _zero or more_
    *Operation Parameter*

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R4 OperationParameter 0..*--1 Operation
----

=== Type Alias

==== Implementation
[source,tcl]
----
<<micca configuration>>=
class TypeAlias {
    attribute Domain string -id 1
    attribute TypeName string -id 1
    attribute TypeDefinition string

    reference R7 Domain -link {Domain Name}
}
----

=== R7

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R7 TypeAlias 0..*--1 Domain
----


== Classes Subsystem

=== Introduction

[[classes-subsystem-discussion]]
The classes subsystem defines how model level ideas of a class will be
realized in `micca`.
We will simplify considerably the relational view of classes that
we find at the model level.
Because we are holding all data in memory and we are using
an implemenation language that exposes addresses,
there are number of simplifying transformations on classes available to us.

* Since the address in memory (_.i.e._ a pointer to an object) is unique,
we can use it as an identifier of each class instance.
If the identifying attributes from the model serve no other descriptive role,
then they can be eliminated altogether.
Using the object pointer as an identifier has a number of
other implementation benefits such as directly accessing attribute values.
* Referential attributes will be replaced by pointer values.
Since referential attributes always refer to identifiers in the model,
then implementing relationships can be accomplished by storing
sets of pointers whose values refer to objects in memory.

Both of these considerations lead to the decision,
common for platforms of the type `micca` is intended,
to map model level class definitions onto ``C'' structure definitions.
Storage for a class can then be allocated as an array of structures
that correspond to the class definition and
relationship information is stored as pointers into the instance array.
Most of the classes subsystem is concerned with how the ``C'' structure
definitions will be composed and the type of information that is held.
We will also be concerned with how some relationship storage will be
structured since there are choices that have different trade-offs.

Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-classes.pdf[title="Classes Subsystem Class Diagram"]

A *Class* is composed of *ClassComponent* (*R20*).
*ClassComponent* consists of four different types (*R21*).
An *Attribute* is a named, descriptive value of the *Class* and may have
a *DefaultValue* (*R22*).
A *Reference* is used to implement class relationships.
A generalization subclass may be held as a discriminated union in
a *SubclassContainer*.
When a class instance participates in a multiple relationship that uses
linked lists,
the memory for the list linkage is held in a *LinkContainer*.
A *Reference* may also be one of four different types (*R23*).
The types of references fulfill different roles and types of relationships.
An *AssociationReference* is used to store information about
association relationships.
An *AssociatorReference* holds the references for an *AssociatorClass*.
A generalization supertype uses a *SubclassReference* to traverse a
generalization relationships from superclass to subclass.
A subtype uses a *SuperclassReference* to traverse a
generalization relationship from subclas to superclass.
Associations have different multiplicities and use different
types of pointer storage (*R24*).
A *SingularReference* is used to hold relationship pointers for
singular multiplicities.
When the multiplicity of a relationship is greater than one,
two different storage strategies are supported.
For relatively static relationships,
references can be held as an *ArrayReference*.
For dynamic relationships,
a *LinkedReference* is often a better choice.

=== Class Component

A Class Component is an element of the implementation class structure
and directly represents a member of the structure definition for the class
as it is used in the implementation.

Domain \{I,R20}::
    The name of the domain to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Domain
Class \{I,R20}::
    The name of the class to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Name
Name \{I}::
    The name of the component.
[horizontal]
    Data Type::: c-identifier
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ClassComponent {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R20 Class -link Domain -link {Class Name}
}
----

=== R20

* *ClassComponent* defines the properties of _exactly one_ *Class*
* *Class* is characterized by _one or more_ *ClassComponent*

A Class is made up of one or more components and each component
can belong to only one class.
Empty classes are not allowed as these are deemed to model nothing.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R20 ClassComponent 1..*--1 Class
----

=== R21

* *ClassComponent* is an *Attribute*, *Reference*, *SubclassContainer*,
or *LinkContainer*

There are four types of components that may be part of a class.
These four types represent the different ways attributes and relationships
are stored in class structures.
An attribute corresponds to model level attributes that hold data that
parameterizes the class
(_i.e._ attributes whose roles are not strictly referential or identifying).
A reference is one or more pointers that are used to implement
model level relationships.
A subclass container can be used by a superclass to hold subclass elements
as a discriminated union.
This is one option for how generalization relationship information may be
stored.
A link container is a set of pointers used to implement a linked list.
This is one option for how sets of relationship pointer information may be
stored.
The space for the link pointers is allocated in to the class that would be
chained together on a relationship.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R21 ClassComponent Attribute Reference SubclassContainer LinkContainer
----

=== Attribute

The Attribute class represent descriptive data that parameterizes a class.

Domain \{I,R21}::
    The name of the domain to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the attribute.
[horizontal]
    Data Type::: Refers to Class Component.Name
DataType::
    The data type of the parameters.
[horizontal]
    Data Type::: c-typename
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Attribute {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute DataType string

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== Default Value

The default value of an attribute is one that will be given to the
attribute when an class instance is created if no value is otherwise provided.
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class DefaultValue {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Attribute string -id 1
    attribute Value string

    reference R22 Attribute -link Domain -link Class -link {Attribute Name}
}
----

=== R22

* *DefaultValue* supplies missing value for _exactly one_ *Attribute*
* *Attribute* has missing value supplied by _zero or one_ *DefaultValue*

An Attribute may be defined to have a default value that the system
will use when the attribute's value is not otherwise specified when
a class instance is created.
There can only be one default value for an attribute
and not all attributes will define default values.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R22 DefaultValue 0..1--1 Attribute
----

=== Reference

A reference is one or more pointer values that are used to implement
the storage for a relationship.

Domain \{I,R21}::
    The name of the domain to which the reference belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the reference belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the reference.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Reference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== Subclass Container

One option for storing generalization relationship information is
as a discriminated union.
The idea is that subclass storage is accomplished by creating a union
of all the subclasses in the generalization.
Then an component of the superclass is defined to be the subclasses union
along with another member to track to which subclass the superclass is
currently related.
This type of storage structure can save some memory space and
traversal across the generalization relationships can be accomplished
with pointer arithmetic.

Domain \{I,R21}::
    The name of the domain to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the subclass container.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SubclassContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== LinkContainer

A link container is a class component that holds pointer values that allow a
class instance to be on a linked list that is used as the storage for a
relationship.
One type of relationship storage uses linked lists when multiple
instances must be referenced.
The linkage is embedded into the class structure for the instances that
are being referenced.
The link list approach to relationship storage requires more space
but has better run time characteristics when the relationship is
dynamic.

Domain \{I,R21}::
    The name of the domain to which the link container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the link container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the link container.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class LinkContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== R23

* *Reference* is a *AssociationReference*, *AssociatorReference*,
*SubclassReference* or *SuperclassReference*

There are four types of storage arrangements that are used to handle
pointers used to track class relationships.
These types handle the specific cases of model level relationships
are translated into a ``C'' environment.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R23 Reference\
    AssociationReference AssociatorReference SubclassReference SuperclassReference
----

=== Association Reference
An Association Reference is used to store pointer values for an association
type relationship.

Domain \{I,R23}::
    The name of the domain to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the assocation reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class AssociationReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== Associator Reference
When a class is an associator class,
it will contain an associator reference.
This type of reference stores two pointers to the classes
participating in the association.
Note for associator references,
the pointer values to the participating classes are not allowed to be
`NULL`.

Domain \{I,R23}::
    The name of the domain to which the associator reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the associator reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the associator reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class AssociatorReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== Subclass Reference
For generalization relationships,
to navigate from the superclass to one of its subclasses
we must be able to determine the type of the subclass to which
the superclass is currently related.
A subclass reference is composed of both the pointer to the related subclass
instance as well as an encoding of the subclass instance type.

Domain \{I,R23,R92}::
    The name of the domain to which the subclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain and Referenced Superclass.Domain
Class \{I,R23,R92}::
    The name of the class to which the subclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class and Referenced Superclass.Class
Name \{I,R23,R92}::
    The name of the subclass reference.
[horizontal]
    Data Type::: Refers to Reference.Name and Referenced Superclass.Relationship
Role \{R92}::
    The role played by the subclass reference in the relationship.
[horizontal]
    Data Type::: Refers to Referenced Superclass.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SubclassReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string

    reference R23 Reference -link Domain -link Class -link Name
    reference R92 ReferencedSuperclass -link Domain -link Class\
        -link {Name Relationship} -link Role
}
----

=== Superclass Reference
For generalization relationships,
pointer information to navigate from a subtype to the supertype class
is stored in a Superclass Reference.

Domain \{I,R23,R91}::
    The name of the domain to which the superclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain and Referring Subclass.Domain
Class \{I,R23,R91}::
    The name of the class to which the superclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class and Referring Subclass.Class
Name \{I,R23,R91}::
    The name of the superclass reference.
[horizontal]
    Data Type::: Refers to Reference.Name and Referring Subclass.Relationship
Role \{R91}::
    The role played by the superclass reference in the relationship.
[horizontal]
    Data Type::: Refers to Referring Subclass.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SuperclassReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string

    reference R23 Reference -link Domain -link Class -link Name
    reference R91 ReferringSubclass -link Domain -link Class\
        -link {Name Relationship} -link Role
}
----

=== Directional Reference
A Directional Reference is used to store pointer values for one direction
of an association.

Domain \{I,R25,R90}::
    The name of the domain to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R25,R90}::
    The name of the class to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R25,R90}::
    The name of the assocation reference.
[horizontal]
    Data Type::: Refers to Reference.Name
Role \{I,R25,R90}::
    The role the directional reference class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class DirectionalReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string -id 1

    reference R25 AssociationReference -link Domain -link Class -link Name
    reference R90 AssociationParticipantClass -link Domain -link Class\
        -link {Name Relationship} -link Role
}
----

=== R25

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R25 DirectionalReference 1..*--1 AssociationReference
----

=== R24

* *DirectionalReference* is a *LinkedReference*, *VectorReference*,
*Constant Reference* or *SingularReference*

Storage for association relationships can be one of four types.
A Singular Reference hold a single pointer value and is suitable
for storing relationships that have a mulitplicity of one.
When storing pointers for relationships with a multiplicity greater that one,
three choices are available.
The Linked Reference uses a linked list.
This choice requires more space but has better dynamic run time characteristics.
The Vector Reference uses a counted array of pointers.
This choice uses less space than the linked reference but requires shuffling
pointers in the vector when relationship instances are deleted.
The Constant Reference places the reference pointers in constant memory
and is only suitable for relationships where the instances don't change
and are known from the population of the domain.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R24 DirectionalReference\
    LinkedReference VectorReference ConstantReference SingularReference
----

=== Linked Reference
When associations of multiplicities greater than one are also dynamic,
_i.e._ there are `link` and `unlink` operations performed on the
relationship,
a linked list is one provided option for storing the relationship
pointers.
A Linked Reference represents the head of that linked list.

Domain \{I,R24}::
    The name of the domain to which the linked reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the linked reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the linked reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
Role \{I,R24}::
    The role the linked reference class plays in the relationship.
[horizontal]
    Data Type::: Refers to Directional Reference.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class LinkedReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string -id 1

    reference R24 DirectionalReference -link Domain -link Class -link Name\
        -link Role
}
----

=== Vector Reference
An array reference consists of an array of pointers and a count
indicating the number of array elements that are in use.
This type of reference can be used to store relationship pointers
for relationships with multiplicities greater than one.

Domain \{I,R24}::
    The name of the domain to which the array reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the array reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the array reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
Role \{I,R24}::
    The role the array reference class plays in the relationship.
[horizontal]
    Data Type::: Refers to Directional Reference.Role
Capacity::
    The attribute determines the maximum number of reference pointers
    that may be stored for the relationship.
[horizontal]
    Data Type::: numeric
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class VectorReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string -id 1
    attribute Capacity boolean

    reference R24 DirectionalReference -link Domain -link Class -link Name\
        -link Role
}
----

=== Constant Reference

Domain \{I,R24}::
    The name of the domain to which the constant reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the constant reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the constant reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
Role \{I,R24}::
    The role the constant reference class plays in the relationship.
[horizontal]
    Data Type::: Refers to Directional Reference.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ConstantReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string -id 1

    reference R24 DirectionalReference -link Domain -link Class -link Name\
        -link Role
}
----

=== Singular Reference
A singular reference consists of a single pointer value and
can be used to store relationship information for relationship of
multiplicity one.

Domain \{I,R24}::
    The name of the domain to which the singular reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the singular reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the singular reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
Role \{I,R24}::
    The role the singular reference class plays in the relationship.
[horizontal]
    Data Type::: Refers to Directional Reference.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SingularReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string -id 1

    reference R24 DirectionalReference -link Domain -link Class -link Name\
        -link Role
}
----

== Relationship Subsystem

=== Mapping Referential Attributes to Pointers
When targeting a statically typed language such as ``C'' and assuming
that all class data will be held in primary memory,
we must devise a way to map relational notions of referential attributes
and referential integrity onto ``C''' language constructs.
There are, needless to say, many ways this can be done.
As we discussed earlier,
we make the convenient decision to use the address of a class instances
as an architecturally supplied identifier.
This decision has many benefits in the implementation.
This also means we can store pointer values as a means of implementing
relationships.

Consider a many-to-one association between two classes.
In a relational scheme,
we would have referential attributes in the class that was on the *many*
side of the relationship and the values of those attributes would
match the values of identifying attributes on the *one* side.
In a pointer based scheme we can do the same thing, _i.e._
place a pointer variable in the ``C'' structure of the class on the *many* side
and have the value of the pointer match that of a class instance on
the *one* side.
The diagram below shows this mapping.

image::pointer-example.pdf[title="Direct Mapping of Referential Attribute"]

Now lets look at the computation required to navigate this relationship,
first from the many side to the one side and then from the one side to
the many side.
For this discussion we will assume the relationship is unconditional on
both sides.

From the many side,
we can see from the above diagram that given a pointer to an *A* instance
we can navigate to the related *B* instance by simply accessing the
`R1` member of `struct A`.
When navigating from the one side to the many side,
we will, in general, obtain more than one instance as a result of the
navigation.
We can find those instances by searching all of the many-side instances
selecting those instances who have a stored pointer value that matches the
address of the one-side class instance.
So in our example, if we have a pointer to a `struct B` we would need to
search all instances of *A* looking for those where the `R1` member
matched the value of our starting pointer.

Having to perform a search for the one-side to many-side navigation is
somewhat troubling.
If the number of instances of the many-side class is small,
then there is little concern.
If it is larger, then we might explore ways to avoid costs associated
with a straight linear search of the many-side instances.
The search code is also rather inconvenient since we target a statically
typed language.
The function to iterate across the many-side instances looking for
the one-side pointer value has to be specific to that particular relationship
if we are to be strictly type safe and don't want to resort to
extremes of type casting and pointer arithmetic.

One way to avoid the search altogether is to store the pointers of the
multiple related instances.
We will have, in effect, pre-computed the related set and, at the cost of the
pointer storage, incur no run time computation to find it.
The figure below shows this in sketch form.

image::pointer-set-example.pdf[title="Mapping Instance References in Both Directions"]

In this arrangement,
the multiple instances implied by traversing the *R1* relationship from
class *B* to class *A* is held as an array of pointers to the related
*A* instances.

It does take computation to maintain the set if the instances participating
in the relationship change.
The space vs. speed trade-off is such that we will almost always use some
additional space to save a run time cost and additional code associated with
computing a set of related instances.
There are other choices of data structures that could be used
to hold the set of pointers.
By choosing different data structures to store the pointer sets,
we can, again at the cost of some additional space,
make maintaining the related pointer sets easier in the face of relationship
changes.

It is also worth noting that although at the model level,
relationships can be navigated in either direction as required by the
logic of the processing,
in practice most relationships are *not* navigated by the processing in
both directions.
So as we adopt the strategy to store relationship pointers that implement
the navigation in both participating classes,
we can also be aware that we can elide those pointers in classes where
we do not navigate a relationship in a particular direction.
In many models,
this will turn out to be a significant savings.

Analysis like that above can be applied to the other types of relationships
and pointer storage schemes can be designed that map the
relational notion of referential attributes to memory pointers.
Most of the relationship subsystem is concerned with categorizing
the types of relationships from a model level
and mapping those onto the roles the classes play in the relationship.
This will then allows us to explicitly map the role a class plays in a
relationship to the kind of storage required to implement that role and
further to the class structure components that are required to hold
the pointers.
The references subsystem models this later part.

=== Naming Conventions on Relationship Traversal

[[relationship-naming-conventions]]
In addition to modeling the real world associations between classes,
relationships also provide a means for the processing of the domain
to navigate the class diagram to access related class instances.
Here we discuss the syntax conventions we will use to indicate
how this navigation will take place.
We adopt the strategy that each relationship has a designated _direction_.
Navigating in the _forward direction_ starts with instances of a source
class and ends with instances of a target class.
Navigating in the _reverse direction_ starts with target class instances
and ends with source class instances.
To designate the forward direction we will use the unadorned relationship
name, _e.g._ `R22` and the reverse direction is indicated by
placing a tilde character before the relationship name, _e.g._ `~R22`.
The motivation behind this convention is to minimize the amount
of specification that needs to be given for navigating relationships
and to disambiguate the case of a reflexive relationship where the
source class and target class are the same.
Given the specification of a relationship direction,
the system knows which classes are involved and that need not be restated
when specifying the navigation during a state activity.
When specifying a direction to a relationship there are three cases to
consider.

For simple assocations,
the forward direction of the relationship is from the referring class
to the referenced class.
In a simple association,
one class contains referential attributes and is hence the referring class.
The other class contains the referenced identifying attributes and
is deemed the referenced class.
The forward direction is then the traversal from instances of the
referring class to instances of the referenced class.

For generalization relationships,
the forward direction of the relationship is also from the referring class
to the referenced class.
In a generalization,
the subclass instances are always the referring instances.
Navigating from the superclass to a subclass requires additional information,
namely which subclass is to be the target.
Navigating from a superclass instance to a subclass instance can yield
at most one subclass instance and possibly zero if the superclass instance
is not actually related to the requested subclass.
So the syntax convention to navigate from a superclass instance to a subclass
instance specifies navigating in the reverse direction as well as the
desired subclass name, _e.g._ `~R42 TableLamp`.

For class based associations,
it is the associator class that holds referential attributes that refer to
both participating classes.
In this case,
the forward direction of the relationships must simply be specified
and one class is designated the source and the other the target.
Since it is also possible to navigate from a participating class to the
associator class itself,
we will specify that case by including the associator class name,
similar to the way generalization relationship navigation is specified.
Navigating from source to target is specified as the unadorned
relationship name, _e.g._ `R14`.
Navigating from target to source uses the tilde notation, _e.g._ `~R14`.
Navigating from the source to the associator includes the associator
class name, _e.g._ `R14 Ownership` and from target to associator
uses the tilde and the associator class name, _e.g._ `~R14 Ownership`.

Only associations can be reflexive (_i.e._ the source and target are the
same class).
For generalization relationships,
we insist that all the subclasses are distinct and that they are distinct
from the superclass.
The conventions used here serve to disambiguate association traversal
in the reflexive case,
however, additional specification is required to fix the precise traversal
path for the case of one-to-one and many-to-many reflexive relationships.
For a one-to-one reflexive association,
we will need to specify which attributes are the referential ones and
that will set the direction.
For a many-to-many association an associator class is required and
again we will have to specify the path from source to target.

Below is the UML class diagram for the relationship subsystem of the platform
model.

image::platform-relation.pdf[title="Relationship Subsystem Class Diagram"]

There are two types of *Relationship* (*R30*), namely
*Association* and *Generalization*.
In turn,
there are two types of *Association* (*R31*), namely
*Simple Association* and *Class Based Association*.
A *Class Based Association* uses a distinct *Associator Class* (*R42*)
to hold references to the participating *Source Class* (*R34*) and
*Target Class* (*R35*).
A *Simple Association* is one where the multiplicity and conditionality
are such that all the references can be located in one of the participating
classes.
The *Simple Referring Class* houses the references (*R32*) while the
*Simple Referenced Class* is the one referred to (*R33*).
`Micca` supports two ways to handle generalization relationships (*R43*).
A *Reference Generalization* uses pointer values to implement the
relationship.
In this arrangement,
a *Referenced Superclass* (*R36*) holds a pointer and encoded type to
a *Referring Subclass* (*R37*).
The *Referring Subclass* also holds a pointer to its related superclass
instances.
A *Union Generalization* uses a discriminated union
to implement the relationship.
This leads to the complementary ideas of a *Union Superclass* (*R44*) and
a *Union Subclass* (*R45*).
All of these class roles are specialized as a *Class Role* (*R40*) which
is the many-to-many-to-many correlation between *Relationship* and
*Class* (*R41*).

=== Association
An Association is a mapping between the instances of two classes.
The two classes need not be distinct.
If the association is between instances of the same class,
then it is called a _reflexive_ association.
If the association is between instances of distinct classes,
then it is called a _non-reflexive_ association.

Domain \{I,R30}::
    The name of the domain to which the association belongs.
[horizontal]
    Data Type::: Refers to Relationship.Domain
Name \{I,R30}::
    The name of the association.
[horizontal]
    Data Type::: Refers to Relationship.Name.
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Association {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R30 Relationship -link Domain -link Name
}
----

=== Generalization
An Generalization is a partitioning of a class into a disjoint union.

Domain \{I,R30}::
    The name of the domain to which the generalization belongs.
[horizontal]
    Data Type::: Refers to Relationship.Domain
Name \{I,R30}::
    The name of the generalization.
[horizontal]
    Data Type::: Refers to Relationship.Name.
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Generalization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R30 Relationship -link Domain -link Name
}
----

=== R30
* *Relationship* is an *Association* or *Generalization*

There are two fundamental types of relationships.
These types are complementary to each other.
An Association is fundamentally related to the Cartesian product
of the participants.
A Generalization is related to the disjoint union of the particiants.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R30 Relationship Association Generalization
----

=== R31
* *Association* is a *Simple Association* or *Class Based Association*

Associations are mappings between class instances.
In its most general form,
a separate class is used to hold the mappings and these are called
*Class Based Associations*.
For the special case of one-to-one and one-to-many multiplicities,
the realization of the association can be simplified by placing
the association mappings into one of the participating classes.
These are known as *Simple Association*.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R31 Association ClassBasedAssociation SimpleAssociation
----

=== Class Based Association
A Class Based Association is a that type of association where a
distinct class is used to implement the relationship.

Domain \{I,R31}::
    The name of the domain to which the class based association belongs.
[horizontal]
    Data Type::: Refers to Association.Domain
Name \{I,R31}::
    The name of the class based association.
[horizontal]
    Data Type::: Refers to Association.Name.
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ClassBasedAssociation {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R31 Association -link Domain -link Name
}
----

=== Simple Association
A Simple Association is a that type of association where the relationship
is implemented using attributes in one of the participating classes.

Domain \{I,R31}::
    The name of the domain to which the simple association belongs.
[horizontal]
    Data Type::: Refers to Association.Domain
Name \{I,R31}::
    The name of the simple association.
[horizontal]
    Data Type::: Refers to Association.Name.
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SimpleAssociation {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R31 Association -link Domain -link Name
}
----

=== R43
* *Generalization* is a *Reference Generalization* or *Union Generalization*

The `micca` platform supports two different techniques to hold
generalization relationship information.
One technique is to use pointer values in a way similar to association
relationships.
The other techique is to use a discriminated union to hold the subclass
instance as part of the superclass instance.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R43 Generalization ReferenceGeneralization UnionGeneralization
----

=== Reference Generalization

A Reference Generalization is that type of generalization where
pointer references are used to implement the relationship.

Domain \{I,R43}::
    The name of the domain to which the reference generalization belongs.
[horizontal]
    Data Type::: Refers to Generalization.Domain
Name \{I,R43}::
    The name of the reference generalization association.
[horizontal]
    Data Type::: Refers to Generalization.Name.
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ReferenceGeneralization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R43 Generalization -link Domain -link Name
}
----

=== Union Association

A Union Generalization is that type of generalization where the subclass
is held as a discriminated union within the superclass instance.
Because of the properties of a generalization relationship,
a superclass is never related to more than one of its subclasses
and so a union of all the subclass structures may be used directly
as the subclass instance storage.

Domain \{I,R43}::
    The name of the domain to which the union generalization belongs.
[horizontal]
    Data Type::: Refers to Generalization.Domain
Name \{I,R43}::
    The name of the union generalization.
[horizontal]
    Data Type::: Refers to Generalization.Name.
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class UnionGeneralization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R43 Generalization -link Domain -link Name
}
----
=== Simple Referring Class
In a Simple Association between two classes,
one class has the role of refering to the other class in the association.
That role is termed the Simple Referring Class.
This class is deemed to be the source of relationship navigation when
going in the forward direction.
From a relational point of view,
the Simple Referring Class is the class in the Simple Association
which contains referential attributes.

Domain \{I,R32,R38}::
    The name of the domain to which the simple referring class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the simple referring class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R32,R38}::
    The name of the relationship in which the simple referring class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the simple referring class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SimpleReferringClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R32 SimpleAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R32

* *Simple Referring Class* is the referring member of
_exactly one_ *Simple Association*
* *Simple Association* has a referring member of
_exactly one_ *Simple Referring Class*

A *Simple Association* is one where referential attributes are
placed in one of participating class.
That class then serves the role of a *Simple Referring Class*.
Each *Simple Association* must have a class that acts as
a *Simple Referring Class* and a class can only be a *Simple Referring Class*
within the context of one *Simple Association* relationship.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R32 SimpleReferringClass 1--1 SimpleAssociation
----

=== Simple Referenced Class

In a Simple Association between two classes,
one class has the role of being referenced by the other class in the
association.
That role is termed the Simple Referenced Class.
This class is deemed to be the target of relationship navigation when
going in the forward direction.
From a relational point of view,
the Simple Referenced Class is the class in the Simple Association
which contains identifying attributes referenced by the Simple Referring Class.

Domain \{I,R33,R38}::
    The name of the domain to which the simple referenced class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the simple referenced class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R33,R38}::
    The name of the relationship in which the simple referenced class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the simple referenced class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean

Note that there is no Multiplicity attribute.
A Simple Referenced Class is always referred to by at most one
Simple Referring Class.
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SimpleReferencedClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean

    reference R33 SimpleAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R33

* *Simple Referenced Class* is the referenced member of
_exactly one_ *Simple Association*
* *Simple Association* has a referenced member of
_exactly one_ *Simple Referenced Class*

A *Simple Association* is one where referential attributes are
placed in one of participating class that refer to the identifying
attributes of the other class.
The class containing the referenced identifying attributes serves
the role of a *Simple Referenced Class*.
Each *Simple Association* must have a class that acts as
a *Simple Referenced Class* and a class can only be a *Simple Referenced Class*
within the context of one *Simple Association* relationship.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R33 SimpleReferencedClass 1--1 SimpleAssociation
----

=== Conventions Used for Class Based Associations
Class based association pose some additional complexity when
describing the way in which they are mapped to the implementation realm.
The associator class represents instances of the association between
the participants.
Each instance of the associator class corresponds one-to-one to instances
of the association itself.
As we discussed
<<relationship-naming-conventions,above>>,
in a class based association one participant will be deemed the source
and the other the target in order to specify the direction of the
relationship for traversal.
The associator class itself always contains the referential attributes
and in our implementation strategy, will contain two pointers, one each
to the participating class instances.
The pointer values will never be `NULL` as the reference from the
associator class to one of the participants is always unconditional.
We will decompose a class based association to make the role of the
associator class explicit.
This is shown in the diagram below.

image::assoc-decompose.pdf[title="Decomposition of Class Based Associations"]

Note that as part of the decomposition,
the multiplicity and conditionality of the source and target sides have
been switched.
Because the references from the associator class to the participants is
unconditional,
the multiplicity and conditionality of the decomposed association when going
from the source class to the associator class is the same as that specified
for the target side at the model level and conversely for the target class.
The apparent switch of the multiplicity and conditionality results from
both the decomposition,
which makes the role of the associator class and its pointer references
explicit,
and the unconditional nature of the references from the associator class to the
participant classes.

With this in mind,
we describe the roles that classes play in a class based association below.
We will have occasion to refer back to this explanation when we generate
the code for class based associations.

=== Source Class

For a Class Based Association,
the Source Class is the starting class from which the association can be
traversed in the forward direction.

Domain \{I,R34,R38}::
    The name of the domain to which the source class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the source class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R34,R38}::
    The name of the relationship in which the source class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the source class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SourceClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R34 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R34

* *Source Class* is the source member for _exactly one_ *Class Based Association*
* *Class Based Association* has a source member of _exactly one_ *Source Class*

Each Class Based Association designates one of the participant classes
to serve the role as the source of traversal.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R34 SourceClass 1--1 ClassBasedAssociation
----

=== Target Class

For a Class Based Association,
the Target Class is that class where, when the association is traversed
in the forward direction starting at the Source Class, the instances
related by the association are found.
Alternatively, the Target Class can serve as the start of a traversal
of the association in the reverse direction.

Domain \{I,R35,R38}::
    The name of the domain to which the target class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the target class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R35,R38}::
    The name of the relationship in which the target class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the target class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class TargetClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R35 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R35

* *Target Class* is the target member for _exactly one_ *Class Based Association*
* *Class Based Association* has a target member of _exactly one_ *Target Class*

Each Class Based Association designates one of the participant classes
to serve the role as the target of traversal.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R35 TargetClass 1--1 ClassBasedAssociation
----

=== Associator Class

For a Class Based Association,
the Associator Class is that class which holds references to the
participating classes.
Each instance of an Associator Class represents an instance of the
association between the participants.

Domain \{I,R42,R40,R93}::
    The name of the domain to which the associator class belongs.
[horizontal]
    Data Type::: Refers to Class Based Association.Domain,
    Class Role.Domain and Associator Reference.Domain.
Class \{I,R40,R93}::
    The name of the associator class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Associator Reference.Domain.
Relationship \{I,R42,R40,R93}::
    The name of the relationship in which the associator class
    participates.
[horizontal]
    Data Type::: Refers to Class Based Association.Name,
    Class Role.Relationship and Associator Reference.Name.
Role \{I,R40}::
    The role the associator class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class AssociatorClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R42 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R93 AssociatorReference -link Domain -link Class\
        -link {Relationship Name}
}
----

=== R42

* *Associator Class* is the referring member of _exactly one_
*Class Based Association*
* *Class Based Association* has a referring member of _exactly one_
*Associator Class*

Class Based Associations must have a class that serves the role of
the associator and holds the references to the participating classes.
That role is served by exactly one class in the association.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R42 AssociatorClass 1--1 ClassBasedAssociation
----

=== R38

* *Association Participant Class* is a *Simple Referring Class*,
*Simple Referenced Class*, *Source Class* or *Target Class*

All the class roles that participate in a association relationships
can be generalized to be an Association Participant Class.
The common characteristic of these classes is that they
may hold pointer references to other classes in the association.

[source,tcl]
----
<<micca configuration>>=
generalization R38 AssociationParticipantClass\
    SimpleReferringClass SimpleReferencedClass\
    SourceClass TargetClass
----

=== Association Participant Class

An Association Participant Class is that type of role in an association
where the class may hold references to other participants in the association.

Domain \{I,R40}::
    The name of the domain to which the association participant class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Class \{I,R40}::
    The name of the association participant class.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Relationship \{I,R40}::
    The name of the relationship in which the association participant class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship
Role \{I,R40}::
    The role the association participant class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class AssociationParticipantClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
}
----

=== Referenced Superclass

A Referenced Superclass is that role in a Reference Generalization
assumed by the superclass.

Domain \{I,R36,R46}::
    The name of the domain to which the referenced superclass class belongs.
[horizontal]
    Data Type::: Refers to Superclass.Domain and
    Reference Generalization.Domain.
Class \{I,R46}::
    The name of the referenced superclass class.
[horizontal]
    Data Type::: Refers to Superclass.Domain.
Relationship \{I,R36,R46}::
    The name of the relationship in which the referenced superclass class
    participates.
[horizontal]
    Data Type::: Refers to Superclass.Relationship and
    Reference Generalization.Name.
Role \{I,R46}::
    The role the referenced superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Superclass.Role

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ReferencedSuperclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R36 ReferenceGeneralization -link Domain -link {Relationship Name}
    reference R46 Superclass -link Domain -link Class -link Relationship -link Role
}
----

=== R36

* *Referenced Superclass* is the abstract member of _exactly one_
*Reference Generalization*
* *Reference Generalization* has an abstract member of _exactly one_
*Referenced Superclass*

Each generalization relationship has exactly one member that serves as
the abstract or superclass member.
We will also insist that superclass roles may not be played by any
of the participant subclasses in the generalization.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R36 ReferencedSuperclass 1--1 ReferenceGeneralization
----

=== Referring Subclass

For a Reference Generalization,
a Referring Subclass is that role played by a subclass.

Domain \{I,R37,R47}::
    The name of the domain to which the referring subclass class belongs.
[horizontal]
    Data Type::: Refers to Subclass.Domain and
    Reference Generalization.Domain.
Class \{I,R47}::
    The name of the referring subclass class.
[horizontal]
    Data Type::: Refers to Subclass.Domain.
Relationship \{I,R37,R47}::
    The name of the relationship in which the referring subclass class
    participates.
[horizontal]
    Data Type::: Refers to Subclass.Relationship and
    Reference Generalization.Name.
Role \{I,R47}::
    The role the referring subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Subclass.Role

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ReferringSubclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R37 ReferenceGeneralization -link Domain -link {Relationship Name}
    reference R47 Subclass -link Domain -link Class -link Relationship -link Role
}
----

=== R37

* *Referring Subclass* is a specific member of _exactly one_
*Reference Generalization*
* *Reference Generalization* has a specific member of _one or more_
*Referring Subclass*

Each generalization relationship has one or more participants that
are the specific members or subclasses of the generalization.
We will also insist that there are at least two subclass members
since partitioning a set into a single improper subset serves no
useful semantic reason.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R37 ReferringSubclass 1..*--1 ReferenceGeneralization
----

=== Union Superclass

For a Union Generalization,
the Union Superclass is that class that serves as a superclass in the
relationship.
This type of superclass will also be constructed so that the storage
for any related subclass will be a part of the memory allocated to the
superclass instance.
This provides a platform specific optimization of memory space for
simple generalizations.

Domain \{I,R46,R44,R96}::
    The name of the domain to which the union superclass class belongs.
[horizontal]
    Data Type::: Refers to Superclass.Domain,
    Reference Generalization.Domain and Subclass Container.Domain.
Class \{I,R46,R96}::
    The name of the union superclass class.
[horizontal]
    Data Type::: Refers to Superclass.Domain and Subclass Container.Domain.
Relationship \{I,R46,R44,R96}::
    The name of the relationship in which the union superclass class
    participates.
[horizontal]
    Data Type::: Refers to Superclass.Relationship,
    Union Generalization.Name, and Subclass Container.Name.
Role \{I,R46}::
    The role the union superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Superclass.Role

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class UnionSuperclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R46 Superclass -link Domain -link Class -link Relationship -link Role
    reference R44 UnionGeneralization -link Domain -link {Relationship Name}
    reference R96 SubclassContainer -link Domain -link Class\
        -link {Relationship Name}
}
----

=== R44

* *Union Superclass* is the abstract member of _exactly one_
*Union Generalization*
* *Union Generalization* has an abstract member of _exactly one_
*Union Superclass*

Each generalization relationship has exactly one member that serves as
the abstract or superclass member.
We will also insist that superclass roles may not be played by any
of the participant subclasses in the generalization.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R44 UnionSuperclass 1--1 UnionGeneralization
----

=== Union Subclass

For a Union Generalization,
a Union Subclass is that role played by a subclass in the generalization.

Domain \{I,R47,R45}::
    The name of the domain to which the union subclass class belongs.
[horizontal]
    Data Type::: Refers to Subclass.Domain and Union Generalization.Domain.
Class \{I,R47}::
    The name of the union subclass class.
[horizontal]
    Data Type::: Refers to Subclass.Domain.
Relationship \{I,R47,R45}::
    The name of the relationship in which the referring subclass class
    participates.
[horizontal]
    Data Type::: Refers to Subclass.Relationship and Union Generalization.Name.
Role \{I,R47}::
    The role the union subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Subclass.Role

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class UnionSubclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R47 Subclass -link Domain -link Class -link Relationship -link Role
    reference R45 UnionGeneralization -link Domain -link {Relationship Name}
}
----

=== R45

* *Union Subclass* is a specific member of _exactly one_
*Union Generalization*
* *Union Generalization* has a specific member of _one or more_
*Union Subclass*

Each generalization relationship has one or more participants that
are the specific members or subclasses of the generalization.
We will also insist that there are at least two subclass members
since partitioning a set into a single improper subset serves no
useful semantic reason.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R45 UnionSubclass 1..*--1 UnionGeneralization
----

=== Superclass

A Superclass is the abstract member of a generalization relationship
and serves the role of a superclass.

Domain \{I,R40}::
    The name of the domain to which the superclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Class \{I,R40}::
    The name of the superclass class.
[horizontal]
    Data Type::: Refers to Class Role.Class
Relationship \{I,R40}::
    The name of the relationship in which the superclass class participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship
Role \{I,R40}::
    The role the superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Superclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
}
----

=== R46

* *Superclass* is a *Referenced Superclass* or *Union Superclass*

The `micca` platform supports two different implementation means for
representing a superclass in a generalization relationship.
A generalization may be represented using pointer references or as
a discriminated union.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R46 Superclass ReferencedSuperclass UnionSuperclass
----

=== Subclass

A Subclass is the specific member of a generalization relationship
and serves the role of a subclass.

Domain \{I,R40}::
    The name of the domain to which the subclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Class \{I,R40}::
    The name of the subclass class.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Relationship \{I,R40}::
    The name of the relationship in which the subclass class participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship
Role \{I,R40}::
    The role the subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Subclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
}
----

=== R47

* *Subclass* is a *Referenced Subclass* or *Union Subclass*

The `micca` platform supports two different implementation means for
representing a subclass in a generalization relationship.
A generalization may be represented using pointer references or as
a discriminated union.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R47 Subclass ReferringSubclass UnionSubclass
----

=== Class Role

A Class Role is an abstraction of the various ways that classes may
participate in relationships.
The major concept in the relationship subsystem is to define the
various types of relationships and then abstract the way that classes
participate in the relationships and the roles they play in holding
referential attributes, etc.

Domain \{I,R41}::
    The name of the domain to which the class role class belongs.
[horizontal]
    Data Type::: Refers to Class.Domain and Relationships.Domain.
Class \{I,R41}::
    The name of the class role class.
[horizontal]
    Data Type::: Refers to Class.Name.
Relationship \{I,R41}::
    The name of the relationship in which the class role class participates.
[horizontal]
    Data Type::: Refers to Relationship.Name.
Role \{I,R40}::
    The role the class role class plays in the relationship.
    There are three roles available to a class.
    It may be a _source_, _target_ or _associator_.
    Note that the Role attribute is part of the identifier of the class.
    This accounts for reflexive associations where the same class
    will play two different roles in the association.
[horizontal]
    Data Type::: {source, target, associator}.

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ClassRole {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1 -check {$Role in {source target associator}}

    reference R41 Relationship -link Domain -link {Relationship Name}
    reference R41 Class -link Domain -link {Class Name}
}
----

=== R40

* *Class Role* is a *Association Participant Class*, *Associator Class*,
*Superclass*, or *Subclass*

Classes play various roles when that are involved in relationships.
This generalization abstracts the various ways that classes are involved
in relationships into a role.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R40 ClassRole AssociationParticipantClass AssociatorClass\
    Superclass Subclass
----

=== R41

* *Class Role* _is an instance of_ *Relationship* models the association
between _one or more_ *Class*
* *Class Role* _is an instance of_ *Class* participates in _zero or more_
*Relationship*

Classes may participate in relationships to model the real world
associations between the classes.
It is possible (but not usual) for a class not to participate in any
relationship.
Relationships alway involve the participation of one or more classes
(usually two or three).
Note that *Class Role* has an additional identifying attribute, *Role*,
so that *R41* is actually a many-to-many-to-many association.
This additional multiplicity is required since reflexive relationships
have the same class playing more than one role in the relationship.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R41 Relationship 0..*--1..* Class -associator ClassRole
----

== References Subsystem

=== Introduction

In the Relationship subsystem,
we say how the platform models relationships and how classes play a
role in realizing the relationship.
In the References subsystem,
we map the roles a class plays in realizing a relationship to the
components that the class instances must store.
This mapping joins back up with the Class Components seen in the
Classes subsystem

Below is the UML class diagram for the references subsystem of the platform
model.

image::platform-references.pdf[title="References Subsystem Class Diagram"]

=== R90

* *Association Participant Class* holds references in _at most one_
*Association Reference*
* *Association Reference* is a reference holder for _one or more_
*Association Participant Class*

When a class serves as an Association Participant Class it may hold
pointer references to the other class in the association.
There may be no pointer references at for relationships directions that are not
traversed.
Each Association Reference hold one or two pointers, with two pointers
being required for reflexive relationships.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R90 DirectionalReference 0..1--1 AssociationParticipantClass
----

=== R91

* *Super Class Reference* is a reference for _exactly one_ *Referring Subclass*
* *Referring Subclass* references via _at most one_ *Superclass Reference*

When a Referring Subclass stores a reference to its superclass it does so
in a *Superclass Reference*.
Not all Referring Subclass instances are navigated to the superclass so
the Referring Subclass may have no references to its superclass.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R91 SuperclassReference 0..1--1 ReferringSubclass
----

=== R92

* *Subclass Reference* is the reference to a subclass for _exactly one_
*Referenced Superclass*
* *Referenced Superclass* references subclasses via _at most one_
*Subclass Reference*

When a superclass in a reference generalization stores its reference to
its currently related subclass in a *Subclass Reference*.
If the superclass to subclass path of the generalization is not navigated,
then there need not be any associated Subclass Reference.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R92 SubclassReference 0..1--1 ReferencedSuperclass
----

=== R93

* *Associator Class* references participants via _exactly one_
*Associator Reference*
* *Associator Reference* is the reference for _exactly one_ *Associator Class*

An Associator Class must hold references to both participants of the
association and does so in an Associator Reference.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R93 AssociatorClass 1--1 AssociatorReference
----

=== R96

* *Union Superclass* stores subclass instances in _exactly one_
*Subclass Container*
* *Subclass Container* is the storage for subclasses of _exactly one_
*Union Superclass*

The use of a discriminated union to store associated subclass instances
in a superclass instance memory structure eliminates the need for
various reference pointers.
The Union Superclass stores the currently related subclass instance
in the Subclass Container that can be used to disinguish the type of 
the related subclass.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R96 UnionSuperclass 1--1 SubclassContainer
----

== State Model Subsystem

=== Introduction

The class, relationship and reference subsystems describe how model level
concepts of classes and relationships are mapped to implementation level
concepts of structures and pointers.
In the state model subsystem we turn our attention to the dynamics
and sequencing of execution of the model.

The classes in the state model subsystem capture the essential information
of a Moore type state model along with the XUML conventions of how
to specify ignored and error transitions.
The sequencing of execution via dispatch of state machine events is
handled by the run time mechanisms of `micca`.
The run time is completely data driven.
So our focus in the platform model is to capture that data needed to
generate the data structures used by the run time mechanisms.
The implications of this are that the state model subsystem is relatively
platform independent.
There are no particular ``C'' language implications of dispatching events
to state machines since the there is no particular ``C'' language
constructs specific to state machines.
The run time mechanisms must supply all the logic around event dispatch.
We will find it convenient to include some sequential numeric attributes
since the run time will use array data structures to access some types
of information and we would like a rather direct way of computing
appropriate array indices.

Below is the UML class diagram for the state model subsystem of the platform
model.

image::platform-statemodel.pdf[title="State Model Subsystem Class Diagram"]

A *State Model* is of one of two types (*R50*),
an *Instance State Model* or an *Assigner State Model*.
An *Instance State Model* is associated with a *Class* (*R51*) and an
*Assigner State Model* is associated with an *Association* relationship (*R52*).
Both types of state models operate the same.
They contain a set of *States* (*R55*) and possibly a *Creation State* (*R56*).
A *State Model* has a default *Transition Rule* (*R59*) to resolve
unspecified transitions and an initial state (*R58*) to know where things
start.
All the *States* and the *Creation State* constitute a *State Place* where
the state model can transition when it has an event dispatched to it (*R57*).
An *Assigner State Model* also consists of two types (*R53*),
*Single Assigner* and *Multiple Assigner*.
A *Single Assigner* has only a single instance while a
*Multiple Assigner* has a many instances as the *Class* that
partitions is behavior (*R54*).

=== State Model

A State Model is a finite automaton, specifically a Moore type state machine.
A State Model is used to define the sequencing of execution for the
lifecycle of its assocated class or assigner.
The State Model defines behavior that is common to all of the associated
instances or assigners and each instance or assigner instance has its own
notion of its current state.

Domain \{I,R58}::
    The domain in which the state model resides.
[horizontal]
    Data Type::: Refers to State.Domain
Model \{I,R58}::
    The name of the class or association for which the state model operates.
[horizontal]
    Data Type::: Refers to State.Model
InitialState \{R58}::
    The name of the state into which the a newly create state model is placed
    by default.
[horizontal]
    Data Type::: Refers to State.Name
DefaultTrans \{R59}::
    The name of the default transition rule.
[horizontal]
    Data Type::: Refers to Transition Rule.Name
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class StateModel {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute InitialState string
    attribute DefaultTrans string

    reference R58 State -link Domain -link Model -link {InitialState Name}
    reference R59 TransitionRule -link {DefaultTrans Name}
}
----

=== R58

* *State Model* is sync created in _exactly one_ *State*
* *State* is the sync creation place for _at most one_ *State Model*

When an entity that has an associated State Model is create synchronously,
it is placed in an initial state.
No state activity is run as part of the synchronous creation.
Not all States of a State Model serve the role of being the default
initial state.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R58 StateModel 0..1--1 State
----

=== R59

* *State Model* transitions by default via _exactly one_ *Transition Rule*
* *Transition Rule* is the default transition for _at most one_ *State Model*

When specifying the state transitions for a state model,
not all transitions must be specified explicitly.
Those transition not explicitly specified are are give the value of
a Transition Rule.
Since there multiple Transition Rules, any given Transition Rule may not be
used as a default transition for a State Model.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R59 StateModel 0..1--1 TransitionRule
----

=== R50

* *State Model* is a *Instance State Model* or *Assigner State Model*

The execution rules of XUML allow the lifecycle of either a class or an
association to be described by a State Model.
These are the only two domain entities that exhibit lifecycle behavior.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R50 StateModel InstanceStateModel AssignerStateModel
----

=== Instance State Model

An Instance State Model is that type of state model associated with the
lifecycle of a class instance.

Domain \{I,R50,R51}::
    The domain in which the instance state model resides.
[horizontal]
    Data Type::: Refers to Class.Domain and State Model.Domain
Class \{I,R50,R51}::
    The name of the class for which the instance state model operates.
[horizontal]
    Data Type::: Refers to Class.Name and State Model.Model

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class InstanceStateModel {
    attribute Domain string -id 1
    attribute Class string -id 1

    reference R50 StateModel -link Domain -link {Class Model}
    reference R51 Class -link Domain -link {Class Name}
}
----

=== R51

* *Instance State Model* describes the lifecycle of _exactly one_ *Class*
* *Class* lifecycle is described by _at most one_ *Instance State Model*

An Instance State Model is the definition of the lifecycle behavior
for only one class but not all classes will exhibit lifecycle behavior and
so may not have an Instance State Model.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R51 InstanceStateModel 0..1--1 Class
----

=== Assigner State Model

An Assigner State Model is that type of state model associated with the
lifecycle of an association relationship.
Sometimes the semantics of the domain subject matter are such that
forming and breaking an association must be serialized.
The archetypical example is where the association is competitive
and parallel activity could create incorrect association linkages.

Domain \{I,R50,R52}::
    The domain in which the assigner state model resides.
[horizontal]
    Data Type::: Refers to Association.Domain and State Model.Domain
Association \{I,R50,R52}::
    The name of the association relationship for which the assigner state
    model operates.
[horizontal]
    Data Type::: Refers to Association.Name and State Model.Model

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class AssignerStateModel {
    attribute Domain string -id 1
    attribute Association string -id 1

    reference R50 StateModel -link Domain -link {Association Model}
    reference R52 Association -link Domain -link {Association Name}
}
----

=== R52

* *Assigner State Model* describes the lifecycle of _exactly one_ *Association*
* *Association* lifecycle is described by _at most one_ *Assigner State Model*

An Assigner State Model is the definition of the lifecycle behavior for only
one association relationship but not all associations will exhibit lifecycle
behavior and so may not have an Assigner State Model.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R52 AssignerStateModel 0..1--1 Association
----

=== State

A State is one of the components of a State Model.
States have a name that is disctinct among the other states of the State Model
and have an executable activity that is run by the system when the
state is entered upon a transition.

Domain \{I,R55,R57,R76}::
    The domain in which the state resides.
[horizontal]
    Data Type::: Refers to State Model.Domain, State Place.Domain
    and Argument Signature .Domain
Model \{I,R55,R57,R76}::
    The name of the state model to which the state belongs.
[horizontal]
    Data Type::: Refers to State Model.Model, State Place.Model
    and Argument Signature.Model
Name \{I,R57}::
    The name of the state.
[horizontal]
    Data Type::: c-identifier
Activity::
    The body of code that is executed when the state is entered.
[horizontal]
    Data Type::: string
IsTerminal::
    Determines whether the class instance will be automatically deleted
    when the state activity is completed.
[horizontal]
    Data Type::: boolean
SigID \{R76}::
    The identifier of the argument signature for the state.
[horizontal]
    Data Type::: Refers to Argument Signature.SigID

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class State {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Activity string
    attribute IsTerminal boolean
    attribute SigID string

    reference R55 StateModel -link Domain -link Model
    reference R57 StatePlace -link Domain -link Model -link Name
    reference R76 ArgumentSignature -link Domain -link Model -link SigID
}
----

=== R55

* *State* is an active element of _exactly one_ *State Model*
* *State Model* acts via _one or more_ *State*

A State is part of only a single State Model.
Sharing states between state models is not allowed.
Every State Model must have at least one state.
The notion of an empty state model does not carry any behavior which it
the purpose of a state model.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R55 State 1..*--1 StateModel
----

=== Creation State

When a entity that has an associated State Model is created
asynchonously by a creation event,
it is placed in a pseudo-initial state.
The creation event is then dispatched to the instance, causing a
transition to a real state and the consequent execution of the
destination state activity.
The Creation State is the state the instance resides in temporarily
until the creation event is dispatched.
It differs from an ordinary state in that it can have no activity
associated with it and can only have out-bound transitions
(_i.e._ you cannot transition into a Creation State).

Domain \{I,R56,R57}::
    The domain in which the creation state resides.
[horizontal]
    Data Type::: Refers to State Model.Domain and State Place.Domain
Model \{I,R56,R57}::
    The name of the state model to which the creation state belongs.
[horizontal]
    Data Type::: Refers to State Model.Model and State Place.Model
Name \{I,R57}::
    The name of the creation state.
    Since a State Model may have at most one Creation State (by R56)
    and since a Creation State does not result in creating any
    ``C'' language identifiers, we choose a distinctive name for
    the Creation State that is outside of the domain for ordination
    state names.
    It suffices to choose the literal string ``@''
    to distinguish the Creation State.
[horizontal]
    Data Type::: the literal string ``@''

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class CreationState {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Name string -id 1

    reference R56 StateModel -link Domain -link Model
    reference R57 StatePlace -link Domain -link Model -link Name
}
----

=== R56

A State Model may have at most one Creation State and that Creation State
is unique to a given State Model.
Not all State Models have creation events defined for them, _i.e._
not all Classes support asynchronous creation.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R56 CreationState 0..1--1 StateModel
----

=== State Place

A State Place is an abstract location from which an event transition may
occur.

Domain \{I,I2}::
    The domain in which the state place resides.
[horizontal]
    Data Type::: string
Model \{I,I2}::
    The name of the state model to which the state place belongs.
[horizontal]
    Data Type::: string
Name \{I}::
    The name of the state place.
[horizontal]
    Data Type::: Union of State.Name and Creation State.Name
Number \{I2}::
    A sequential number given to the state place to aid in the encoding
    of states required during code generation.
[horizontal]
    Data Type::: sequential numeric

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class StatePlace {
    attribute Domain string -id 1 -id 2
    attribute Model string -id 1 -id 2
    attribute Name string -id 1
    attribute Number string -id 2
}
----

=== R57

* *State Place* is a *State* or *Creation State*

State transitions can originate from either a State or a Creation State.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R57 StatePlace State CreationState
----

=== Transition Rule

The execution rules for XUML state models allow for two types of
transition specifications that do not actually cause a transition in
a state machine.
These rules simplify the specification of state models.
One transition rule states that an event is to be ignored in a state
and is named, ``IG''.
The other transition rule states that it is a logical impossiblity for
the event to be received in the state and is named, ``CH''
(for ``can't happen'').

Name \{I}::
    The name of the transition rule.
[horizontal]
    Data Type::: {IG, CH}
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class TransitionRule {
    attribute Name string -id 1 -check {$Name in {IG CH}}
}
----

=== R53

* *Assigner State Model* is a *Single Assigner* or *Multiple Assigner*

When an association has an Assigner State Model,
it may exist as a singleton or it may have multple instances of the
assigner.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R53 AssignerStateModel SingleAssigner MultipleAssigner
----

=== Single Assigner

A Single Assigner is a type of Assigner State Model that is used
when a competitive association must be serialized through one
execution path.
This is the most frequent case.

Domain \{I,R53}::
    The domain in which the single assigner resides.
[horizontal]
    Data Type::: Refers to Assigner State Model.Domain
Association \{I,R53}::
    The name of the association relationship for which the single assigner
    operates.
[horizontal]
    Data Type::: Refers to Assigner State Model.Association
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class SingleAssigner {
    attribute Domain string -id 1
    attribute Association string -id 1

    reference R53 AssignerStateModel -link Domain -link Association
}
----

=== Multiple Assigner

A Multiple Assigner is a type of Assigner State Model that is used
when a competitive association is partitioned into distinct subsets
wherein the assignment of the association is made.

Domain \{I,R53,R54}::
    The domain in which the multiple assigner resides.
[horizontal]
    Data Type::: Refers to Assigner State Model.Domain
    and Class.Domain
Association \{I,R53}::
    The name of the association relationship for which the multiple assigner
    operates.
[horizontal]
    Data Type::: Refers to Assigner State Model.Association
Class \{R54}::
    The name of the class whose instances partition the multiple assigner.
[horizontal]
    Data Type::: Refers to Class.Name
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class MultipleAssigner {
    attribute Domain string -id 1
    attribute Association string -id 1
    attribute Class string

    reference R53 AssignerStateModel -link Domain -link Association
    reference R54 Class -link Domain -link {Class Name}
    reference R104 ValueElement -link Domain -link {Association Name}
}
----

=== R54

* *Multiple Assigner* is partitioned by _exactly one_ *Class*
* *Class* partions instance of _zero or more_ *Multple Assigner*

A Multiple Assigner operates on association instances that are divided
into sets associated with the instance of some Class.
Not all Classes partition Multiple Assigners.
The archetypical example of a Multiple Assigner is where a clerk
services customers but the clerk only services customers who are shopping
in the department where the clerk works.
In this case the department serves to partition the assignment of
clerks to customers to insure that assignments occur within the context
of the department in which the clerk works.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R54 MultipleAssigner 0..*--1 Class
----

== Event Subsystem

=== Introduction
The Event subsystem is concerned with classifying events that drive
state machine transitions.
The complexity here is that the execution rules for XUML allow for
one form of polymorphism, namely polymorphic events.

A polymorphic event can arise only in the context of a generalization
relationship.
Events can be designated as polymorphic and when such an event is
signaled to a superclass instance,
it is mapped at run time to an event in the subclass instance that
is currently related to superclass instance.
The net effect is to allow the subclasses of a generalization all to respond to
the same events and yet the events are signaled to the superclass instances of
the generalization.

Strictly speaking event polymorphism is an optimization performed by the run
time mechanisms since mapping an event to a subclass could be performed as part
of the state activity.
However, such code is repetitive and rather fragile in the wake of
adding or deleting subclasses in a generalization.
This is a case where the system can ``know'' the right thing to do
and remove a significant burden from the model level processing.

In its most common usage,
polymorphic events are quite straight forward.
Events are designated as polymorphic by the superclass and
they are used as ordinary events by the state models of the subclasses.
In its most general usage however,
we must account for both repeated generalization (_i.e._ where a subclass
serves as the superclass for a futher generalization) and
compound generalization (_i.e._ where a class is the superclass for
multiple generalization relationships).
The full set of rules and implications of polymorphic events can be rather
daunting.

* Associating polymorphic events with a superclass does _not_ imply
that the superclass has no state behavior of its own.
A superclass may have both a state model and polymorphic events since
generating a polymorphic event to a superclass does not result in any
behavior in the superclass.
* A given superclass may be the superclass of multiple generalizations.
In this case, generating an event to an instance of such a superclass
will cause an event to be generated to all generalizations for which
the class is a superclass.
In this way, a single event generated may result in multiple events being
dispatched.
* The state model for a subclass may respond to
ordinary events that are not part of the polymorphic event set associated
with the generalization.
Such events may be generated directly to instances of the subclass
or they may be self generated.
* A class that is a subclass may also be a superclass of another generalization,
_i.e._ a subclass may be subject to repeated generalization.
Such a mid-level class may designate additional polymorphic events associated
with the generalization relationship for which it is the superclass.
Also a mid-level class may delegate polymorphic events associated with its
subclass role to any hierarchy for which it serves as a superclass.
* All leaf classes, _i.e._ subclasses which are _not_
the superclass of another generalization,
must consume as ordinary events all polymorphic events delegated to them.
It is sufficient to ignore or deem an event as can't happen, but
polymorphic events are mapped ultimately to ordinary events.

Note also that generalizations are _not_ subject to the so called
``diamond'' construct where a given class is a subclass of multiple
generalizations which themselves have a common superclass ancestor.
Blessedly,
referential integrity simply does not allow such a beast to be constructed.

These rules give rise to the following class model for state model events.

image::platform-event.pdf[title="Event Subsystem Class Diagram"]

An *Event* can be of two types (*R80*), either a *Deferred Event* or a
*Transitioning Event*.
A *Transitioning Event* actually causes state transition in a *State Model*
(*R87*).
A *Deferred Event* arises from a *Superclass* across a *Deferral Path* (*R86*).
Because of *R80*,
ordinary events and polymorphic events in a superclass must have different
names.
We do consider this an advantage in avoiding confusion between polymorphic
events and ordinary events in the superclass.
A *Transitioning Event* is either a locally defined *Local Event*
or a *Mapped Event* (*R82*).
A *Local Event* is specified directly by a state model and a
*Mapped Event* is a deferred event as it is consumed in state model (*R84*).
A *Deferred Event* is either a *Polymorphic Event* defined directly by
a superclass or is delegated as an *Inherited Event*
from another generalization for which the class was a subclass.
Both an *Inherited Event* or a *Mapped Event* are forms of
*Non-Local Event* (*R83*) and a *Non-Local Event* may only be defined
to act upon a *Subclass* (*R85*).

=== Event

An Event is a stimulus to a state model that has to potential to cause
a transition.

Domain \{I,R78}::
    The domain in which the event resides.
[horizontal]
    Data Type::: Refers to Argument Signature.Domain
Model \{I,R78}::
    The name of the state model to which the event belongs.
[horizontal]
    Data Type::: Refers to Argument Signature.Model
Event \{I}::
    The name of the event.
[horizontal]
    Data Type::: string
SigID \{R78}::
    The identifier of the argument signature for the event.
[horizontal]
    Data Type::: Refers to Argument Signature.SigID
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Event {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute SigID string

    reference R78 ArgumentSignature -link Domain -link Model -link SigID
}
----

=== R80

* *Event* is a *Deferred Event* or *Transitioning Event*

There are two types of events.
Those that cause an immediate effect on a state model are
*Transitioning Events*.
Those that are mapped at run time to an event in a subclass are
*Deferred Events*.
The execution rules do not allow for any other types of events.
Note that a creation event is just another form of *Transitioning Event*.
The only difference is that the run time mechanism creates the
class instance immediately before dispatching the creation event to it.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R80 Event DeferredEvent TransitioningEvent
----

=== Deferred Event

A Deferred Event is that type of event which is specified in a
Superclass but which is mapped to an event in a Subclass.

Domain \{I,I2,R80}::
    The domain in which the deferred event resides.
[horizontal]
    Data Type::: Refers to Event.Domain
Model \{I,I2,R80}::
    The name of the state model to which the deferred event belongs.
[horizontal]
    Data Type::: Refers to Event.Model
Event \{I,R80}::
    The name of the deferred event.
[horizontal]
    Data Type::: Refers to Event.Event
Number \{I2}::
    A ordinal number for the deferred event. We find it convenient to
    number the deferred events in a manner that would allow the
    number to be used as an array index.
[horizontal]
    Data Type::: Zero based sequential integer

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class DeferredEvent {
    attribute Domain string -id 1 -id 2
    attribute Model string -id 1 -id 2
    attribute Event string -id 1
    attribute Number int -id 2

    reference R80 Event -link Domain -link Model -link Event
}
----

=== R81

* *Deferred Event* is a *Polymorphic Event* or *Inherited Event*

There are two source of events that are deferred.
Deferral happens in the sense that the events do not affect the behavior of the
superclass to which they are sent.
A superclass may declare an event as polymorphic or a
subclass of a generalization may choose to not act upon the event
if it is also the superclass of a different generalization.
In the later case,
the event not acted upon is inherited by the subclasses.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R81 DeferredEvent PolymorphicEvent InheritedEvent
----

=== Deferral Path

A Deferral Path is traversal along a generalization relationship
where an event is being deferred to a subclass of the generalization.

Domain \{I,R80}::
    The domain in which the deferral path resides.
[horizontal]
    Data Type::: Refers to Superclass.Domain and Deferred Event.Domain
Model \{I,R80}::
    The name of the state model to which the deferral path belongs.
[horizontal]
    Data Type::: Refers to Superclass.Class and Deferred Event.Model
Event \{I,R80}::
    The name of the event that is being deferred along the deferral path.
[horizontal]
    Data Type::: Refers to Deferred Event.Event
Relationship \{I,R86}::
    The generalization relationship along which the event is deferred.
[horizontal]
    Data Type::: Refers to Superclass.Relationship
Role \{I,R86}::
    The role of the superclass which is deferring an event.
[horizontal]
    Data Type::: Refers to Superclass.Role

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class DeferralPath {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R86 DeferredEvent -link Domain -link Model -link Event
    reference R86 Superclass -link Domain -link {Model Class}\
        -link Relationship -link Role
}
----

=== R86

* *Deferral Path* is an instance of
*Superclass* propagates _zero or more_ *Deferred Event*
* *Deferral Path* is an instance of
*Deferred Event* is propagated by _one or more_ *Superclass*

Event polymorphism allows an event in a Superclass to be deferred
to the subclasses.
Not all Superclasses define polymorphic events.
A given polymorphic event may be propagated along mulitple generalization
relationships in the case of a compound generalization,
_i.e._ a superclass that is the a superclass for multiple generalizations.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R86 Superclass 1..*--0..* DeferredEvent -associator DeferralPath
----

=== Transitioning Event

A Transitioning Event is that type of event that has the potential to
cause a state transition when dispatched to a state machine.

Domain \{I,R80,R87}::
    The domain in which the transitioning event resides.
[horizontal]
    Data Type::: Refers to Event.Domain and State Model.Domain
Model \{I,R80,R87}::
    The name of the state model to which the transitioning event belongs.
[horizontal]
    Data Type::: Refers to Event.Model and State Model.Model
Event \{I,R80}::
    The name of the transitioning event.
[horizontal]
    Data Type::: Refers to Event.Event
Number \{I2}::
    A ordinal number for the transitioning event. We find it convenient to
    number the deferred events in a manner that would allow the
    number to be used as an array index.
[horizontal]
    Data Type::: Zero based sequential integer

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class TransitioningEvent {
    attribute Domain string -id 1 -id 2
    attribute Model string -id 1 -id 2
    attribute Event string -id 1
    attribute Number int -id 2

    reference R80 Event -link Domain -link Model -link Event
    reference R87 StateModel -link Domain -link Model
}
----

=== R82

* *Transitioning Event* is a *Mapped Event* or *Local Event*

Events that can cause state transitions arise from two circumstances.
First, they may be locally defined.
This is usually the preponderance of events.
Second, the event could have been deferred from a superclass and
when it dispatched to a subclass is mapped into an event defined
for the subclass.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R82 TransitioningEvent MappedEvent LocalEvent
----

=== R87

* *Transitioning Event* causes transitions in _exactly one_ *State Model*
* *State Model* has transitions caused by _one or more_ *Transitioning Event*

Events that cause transition in a state model are defined to be specific
to that state model and all state models must respond to at least one event
by the definition of a state machine.
Of course, state models can, and usually do, respond to multiple events.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R87 TransitioningEvent 1..*--1 StateModel
----

=== Polymorphic Event

A polymorphic event is an event defined for the superclass of a generalization
that is to be mapped at run time to an event of one of the subclasses
of the generalization.
The run time mapping determines the subclass to which the superclass is
currently related and maps the event into one by the same name in the
subclass.

Domain \{I,R81}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Deferred Event.Domain
Model \{I,R81}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Deferred Event.Model
Event \{I,R81}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Deferred Event.Event

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class PolymorphicEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R81 DeferredEvent -link Domain -link Model -link Event
}
----

=== Inherited Event

A polymorphic event defined for superclass becomes an inherited
event in the subclasses of the generalization if a subclass does not
act upon the polymorphic event.
This can occur when the subclass is part of a repeated generalization
where it serves the role of subclass in a generalization that defines
the polymorphic event and serves the role of superclass in another
generalization.
The event can be thought of as being inherited down the hierarchy formed
by the repeated generalizations.

Domain \{I,R81,R83}::
    The domain in which the inherited event resides.
[horizontal]
    Data Type::: Refers to Deferred Event.Domain and Non-Local Event.Domain
Model \{I,R81,R83}::
    The name of the state model to which the inherited event belongs.
[horizontal]
    Data Type::: Refers to Deferred Event.Model and Non-Local Event.Model
Event \{I,R81,R83}::
    The name of the inherited event.
[horizontal]
    Data Type::: Refers to Deferred Event.Event and Non-Local Event.Event
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class InheritedEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R81 DeferredEvent -link Domain -link Model -link Event
    reference R83 Non-LocalEvent -link Domain -link Model -link Event
}
----

=== Mapped Event

When a deferred event is consumed by a subclass it becomes a
mapped event for the subclass state model.
This allows the subclass to define other events to which it may respond.

Domain \{I,R82,R83,R84}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Transitioning Event.Domain,
    Non-Local Event.Domain and Deferred Event.Domain
Model \{I,R82,R83}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Transitioning Event.Model and Non-Local Event.Model
Event \{I,R82,R83,R84}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event, Non-Local Event.Event
    and Deferred Event.Event
ParentModel \{R84}::
    The name of the state model from which the mapped event was deferred.
    Data Type::: Refers to Deferred Event.Model

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class MappedEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute ParentModel string

    reference R82 TransitioningEvent -link Domain -link Model -link Event
    reference R83 Non-LocalEvent -link Domain -link Model -link Event
    reference R84 DeferredEvent -link Domain -link {ParentModel Model}\
        -link Event
}
----

=== R84

* *Mapped Event* is the realization of _exactly one_ *Deferred Event*
* *Deferred Event* is realized as _at most one_ *Mapped Event*

When a deferred event is consumed, it becomes a mapped event in the
subclass where it is acted upon.
A mapped event always starts out as one that is deferred from a superclass.
Not all deferred events are necessarily mapped.
It is possible to defer an event through muliple generalizations before it
is finally consumed and becomes a mapped event.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R84 MappedEvent 0..*--1 DeferredEvent
----

=== Local Event

A local event is an event defined by a class and directly acted upon by the
state model of the class.
This forms the vast majority of defined events and all the events for
classes that are not subclasses of a generalization.

Domain \{I,R82}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Transitioning Event.Domain
Model \{I,R82}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Transitioning Event.Model
Event \{I,R82}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class LocalEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R82 TransitioningEvent -link Domain -link Model -link Event
}
----

=== R83

* *Non-Local Event* is an *Inherited Event* or *Mapped Event*

Together, inherited and mapped events form a set of events that
do not originate from the immediate local state model definition.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R83 Non-LocalEvent InheritedEvent MappedEvent
----

=== Non-Local Event

A non-local event is that type of event that arises from polymorphic
events that are mapped through a generalization hierarchy.

Domain \{I,R85}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Subclass.Domain
Model \{I,R85}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Subclass.Class
Event \{I}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: string
Relationship \{R85}::
    The generalization relationship along which the non-local event is applied.
[horizontal]
    Data Type::: Refers to Subclass.Relationship
Role \{R85}::
    The role of the subclass to which the non-local event is applied.
[horizontal]
    Data Type::: Refers to Subclass.Role

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Non-LocalEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute Relationship string
    attribute Role string

    reference R85 Subclass -link Domain -link {Model Class} -link Relationship\
        -link Role
}
----

=== R85

* *Non-Local Event* affects _exactly one_ *Subclass*
* *Subclass* is affected by _zero or more_ *Non-Local Event*

Regardless of the source of non-local events, they can only cause
transition in the state model of a subclass.
Classes that are not subclasses cannot respond to non-local events.
Some subclasses will not have state models or polymorphic events
defined in their superclass.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R85 Non-LocalEvent 0..1--1 Subclass
----

== Transition Subsystem

=== Introduction

The transition subsystem is concerned with the dispatch of state model
events.
The type of dispatch supported by XUML is the same as for a Moore type
state machine,
_i.e._ for a given state an event causes a transition into a new state
(possibly the same as the current state) and executes any activity
associated with the state.
In UML parlance, these are known as entry actions.
No other form of action dispatch is supported as it is not needed.

One other complexity of state activity dispatch is that event arguments.
Each state may define a signature of parameters that the state activity
expects.
It is a corollary of Moore state machines that any event that causes
a transition _into_ a state must carry arguments that match the
formal parameter signature of the state.

The diagram below shows the transition subsystem classes.

image::platform-transition.pdf[title="Transition Subsystem Class Diagram"]

All the *State Places* and *Transitioning Events* combine to form a
transition matrix (*R70*) the cells of which are represented by
*Transition Places*.
There are two types of transitions that can occur in an state model (*R71*).
A *State Transition* causes the state machine to enter a new state
of the state model (*R72*).
A *Non-State Transition* does not cause a new state to be entered but
has the side effect of either ignoring the event or causing a system error
(*R73*).

When a state transition happens,
the arguments carried by the event are transferred to the state
activity according to the *Argument Signature* (*R74*).
An *Argument Signature* correponds to a set of positional parameters (*R75*)
which have a fixed position in the argument list and a defined data type.
Each *State* and *Event* may have an *Argument Signature* (*R76* and *R78*)
and the signatures must match for a given *State Transition*.
The *State* may view its arguments as named parameters (*R77*)
and those parameter names may be referenced in the code for the
*State Activity*.
Similarly,
an *Event* may name its formal parameters (*R79*).
Note that the parameter names do not affect the arguments themselves.
The only thing important about the arguments of a state activity are the
position and data type, as is required by ``C'' when invoking a function.
The parameter naming from the *State* and *Event* points of view need
not be the same.

=== Transition Place

The Cartesian product of the state of a state model and the events of
the model form a conceptual transition matrix.
A transition place models the individual cells of the conceptual transition
matrix.

Domain \{I,R70}::
    The domain in which the transition place resides.
[horizontal]
    Data Type::: Refers to State Place.Domain and Transitioning Event.Domain
Model \{I,R70}::
    The name of the state model to which the transition place belongs.
[horizontal]
    Data Type::: Refers to State Place.Model and Transitioning Event.Model
State \{I,R70}::
    The name of the state to which the transition place refers.
[horizontal]
    Data Type::: Refers to State Place.Name
Event \{I,R70}::
    The name of the event which will cause a transition out of the
    transition place.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class TransitionPlace {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1

    reference R70 StatePlace -link Domain -link Model -link {State Name}
    reference R70 TransitioningEvent -link Domain -link Model -link Event
}
----

=== R70

* *Transition Place* is an instance of *State Place* transitions according to
_zero or more_ *Transitioning Event*
* *Transition Place* is an instance of *Transitioning Event* drives transition
among _zero or more_ *State Place*

A state model operates by having a function that maps states and events
onto new states.
A Transition Place is one of the enumerations of that mapping function.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R70 StatePlace 0..*--0..* TransitioningEvent -associator TransitionPlace
----

=== R71

* *Transition Place* is a *State Transition* or *Non-State Transition*

As a convenience to the analyst,
events can be ignored or cause a system error.
These rules simplify the state model and result in there being two
different types of transitions.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R71 TransitionPlace StateTransition Non-StateTransition
----

=== State Transition

A State Transition is that type of Transition Place where the dispatch of
an event causes the state machine to enter a new state.

Domain \{I,R71,R72,R74}::
    The domain in which the state transition resides.
[horizontal]
    Data Type::: Refers to Transition Place.Domain, State.Domain
    and Argument Signature.Domain
Model \{I,R71}::
    The name of the state model to which the state transition belongs.
[horizontal]
    Data Type::: Refers to Transition Place.Model, State.Model and
    Argument Signature.Model
State \{I,R71}::
    The name of the state that is the starting state for the state transition.
[horizontal]
    Data Type::: Refers to Transition Place.Name
Event \{I,R70}::
    The name of the event which will cause the state transition.
[horizontal]
    Data Type::: Refers to Transition Place.Event
NewState \{R72}::
    The name of the state to which state transition arrives.
[horizontal]
    Data Type::: Refers to State.Name
SigID \{R74}::
    The signature ID of the argument signature that will govern the
    transfer of values from the event arguments to the activity parameters.
[horizontal]
    Data Type::: Refers to Argument Signature.SigID

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class StateTransition {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1
    attribute NewState string
    attribute SigID string

    reference R71 TransitionPlace -link Domain -link Model -link State\
        -link Event
    reference R72 State -link Domain -link Model -link {NewState Name}
    reference R74 ArgumentSignature -link Domain -link Model -link SigID
}
----

=== R72

* *State Transition* is destined for _exactly one_ *State*
* *State* is the destination of _at most one_ *State Transition*

When an event is dispatched and it causes a transition,
a new state becomes the current state.
This must happen for every state transition.
Conversely, not all states are the destination of a transition.
Some state may only have outbound transitions.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R72 StateTransition 0..*--1 State
----

=== Non-State Transition

A Non-State Transition is that type of Transition Place where the dispatch of
an event does not cause a transition and the system takes a prescribed
action.

Domain \{I,R71}::
    The domain in which the non-state transition resides.
[horizontal]
    Data Type::: Refers to Transition Place.Domain
Model \{I,R71}::
    The name of the state model to which the non-state transition belongs.
[horizontal]
    Data Type::: Refers to Transition Place.Model
State \{I,R71}::
    The name of the state that is the starting state for the non-state
    transition.
[horizontal]
    Data Type::: Refers to Transition Place.Name
Event \{I,R71}::
    The name of the event which is received by the non-state transition.
[horizontal]
    Data Type::: Refers to Transition Place.Event
TransRule \{R73}::
    The system rule that is performed when the event is received in the state.
[horizontal]
    Data Type::: Refers to Transition Rule.Name
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Non-StateTransition {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1
    attribute TransRule string

    reference R71 TransitionPlace -link Domain -link Model -link State\
        -link Event
    reference R73 TransitionRule -link {TransRule Name}
}
----

=== R73

* *Non-State Transition* has the effect of _exactly one _*Transition Rule*
* *Transition Rule* describes the effect for _zero or more _
*Non-State Transition*

All transitions that do not result in a new state being entered must
take an action that is dictated by transitions rules that govern
non-state transitions.
Any given transition rule may not be applied to a non-state transition.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R73 Non-StateTransition 0..*--1 TransitionRule
----

=== Argument Signature

A State can define formal parameters for its activity.
The set of those parameters form a signature for the state.
Any event that causes a transition into a given state must carry
argument values that match the formal parameters of the state,
_i.e._ the event can be considered to have the same signature as the
state into which it causes a transition.

Domain \{I}::
    The domain in which the argument signature resides.
[horizontal]
    Data Type::: string
Model \{I}::
    The name of the state model to which the argument signature belongs.
[horizontal]
    Data Type::: string
SigID \{I}::
    The identifier of the argument signature for the state.
    Argument signatures are identified uniquely within a given state
    model.
    This choice of identification is somewhat arbitrary and this particular
    choice is an attempt to keep the signature information localized to
    a particular state model.
[horizontal]
    Data Type::: arbitrary identfier

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ArgumentSignature {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute SigID string -id 1
}
----

=== R74

* *State Transition* transfers argument values by _at most one_
*Argument Signature*
* *Argument Signature* defines argument transfer for _one or more_
*State Transition*

The parameters of the state activity constitute its signature.
A state may have no signature if it has no parameters.
Within a given model,
several states may have the same signature.
This allows an event to have the same signature but cause a transition
to different states.

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R74 StateTransition 1..*--0..1 ArgumentSignature
----

=== R76

* *State* accepts arguments matching _at most one_ *Argument Signature*
* *Argument Signature* is the argument pattern for _one or more_ *State*

Constraint:: R76 = ~R72 + R74

The State that is the destination for a transition has a signature of
the arguments that it accepts.
Not all states have arguments and so may not have a signature.
An argument signature can apply to more than one state as it would need to
do if the same event can cause transitions into different states.
Note that R76 is further constrained to match the traversal from *State* to
*Argument Signature* via ~R72 + R74.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R76 State 1..*--0..1 ArgumentSignature
----

=== R78

* *Event* accepts arguments matching _at most one_ *Argument Signature*
* *Argument Signature* is the argument pattern for _one or more_ *Event*

Constraint:: R78 = \~R80.Transitioning Event + \~R70.Transition Place +
~R71.State Transition + R74

Events that cause transitions into states can carry arguments to the
state activity.
The argument signature of the event must match that of the state
into which the transition happens.
Not all events carry arguments and the argument signature may describe the
pattern for multiple events.
This is necessary if different events cause a transition to the same state.
Note that R78 is further constrained to match the traversal from
*Event* to *Argument Signature* via the path, \~R80.Transitioning Event
+ \~R70.Transition Place + ~R71.State Transition + R74

==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R78 Event 1..*--0..1 ArgumentSignature
----

=== Activity Argument

An Activity Argument is a formal parameter to the activity of a state.
When the state activity is executed,
the transitioning event carrys the actual argument values for
each parameter.

Domain \{I,R75}::
    The domain in which the activity argument resides.
[horizontal]
    Data Type::: Refers to Argument Signature.Domain
Model \{I,R75}::
    The name of the state model to which the activity argument belongs.
[horizontal]
    Data Type::: Refers to Argument Signature.Model
SigID \{I,R75}::
    The argument signature ID for the activity argument.
[horizontal]
    Data Type::: Refers to Argument Signature.SigID
Position \{I2}::
    An ordinal number given to the argument to indicate its order in
    a set of arguments for an activity.
    In ``C'' arguments to functions are passed by position and we need to
    be able to create argument lists properly.
[horizontal]
    Data Type::: zero based sequential numeric
DataType::
    The data type of the activity argument.
[horizontal]
    Data Type::: c-typename

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ActivityArgument {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute SigID string -id 1
    attribute Position int -id 1
    attribute DataType string

    reference R75 ArgumentSignature -link Domain -link Model -link SigID
}
----

=== R75

* *Activity Argument* is an argument of _exactly one_
*Argument Signature*
* *Argument Signature* has an argument of _one or more_
*Activity Argument*

When a State is entered on a transition of a dispatched event,
its activity is executed.
The event causing the transition may carry argument values for the
state activity.
An Activity Argument is a description of the arguments that
the state activity accepts.
An Activity Argument is always part of a Argument Signature and does
not exist outside of the context of a single signature.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R75 ActivityArgument 1..*--1 ArgumentSignature
----

=== Activity Parameter

An Activity Parameter is a formal parameter to the activity of a state.
When the state activity is executed,
the transitioning event carrys the actual argument values for
each parameter.

Domain \{I,R77}::
    The domain in which the activity parameter resides.
[horizontal]
    Data Type::: Refers to State.Domain and Activity Argument.Domain
Model \{I,R77}::
    The name of the state model to which the activity parameter belongs.
[horizontal]
    Data Type::: Refers to State.Model and Activity Argument.Model
State \{I,R77}::
    The name of the state to which the activity parameter belongs.
[horizontal]
    Data Type::: Refers to State.Name
SigID \{I,R77}::
    The argument signature ID for the activity parameter.
[horizontal]
    Data Type::: Refers to Activty Argument.SigID
Position \{I,R77}::
    A ordinal number given to the argument to indicate its order in
    a set of arguments for an activity.
[horizontal]
    Data Type::: Refers to Activity Argument.Position
Name::
    The name of the parameter. This name may be used as a variable name
    in the code for the state activity.
[horizontal]
    Data Type::: c-identifier

==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ActivityParameter {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute SigID string -id 1
    attribute Position int -id 1
    attribute Name string

    reference R77 ActivityArgument -link Domain -link Model -link SigID\
        -link Position
    reference R77 State -link Domain -link Model -link {State Name}
}
----

=== R77

* *Activity Parameter* is an instance of *State* expects parameters of
_zero or more_ *Activity Argument*
* *Activity Parameter* is an instance of *Activity Argument*
is the parameter pattern for _one or more_ *State*

A State may have activity arguments. Those arguments form a signature
that is based on the position and data type.
However, the State may choose to name the arguments in whatever way
it chooses as the basis of its formal parameters.
In the same way that ``C'' functions can have the same signature of
arguments even if the names given to the arguments differ.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R77 State 1..*--0..* ActivityArgument -associator ActivityParameter
----

=== Event Parameter

An Event Parameter is a formal parameter for data that an event carries.
When the state activity is executed,
the transitioning event carrys the actual argument values for
each activity parameter.
The Event Parameter gives a name to the argument value from the events
point of view.

Domain \{I,R79}::
    The domain in which the event parameter resides.
[horizontal]
    Data Type::: Refers to Event.Domain and Activity Argument.Domain
Model \{I,R79}::
    The name of the state model to which the event parameter belongs.
[horizontal]
    Data Type::: Refers to Event.Model and Activity Argument.Model
Event \{I,R79}::
    The name of the event to which the event parameter belongs.
[horizontal]
    Data Type::: Refers to Event.Event
SigID \{I,R79}::
    The argument signature ID for the activity parameter.
[horizontal]
    Data Type::: Refers to Activty Argument.SigID
Position \{I,R79}::
    A ordinal number given to the argument to indicate its order in
    a set of arguments for an activity.
[horizontal]
    Data Type::: Refers to Activity Argument.Position
Name::
    The name of the parameter. This name may be used as a variable name
    in the code for the state activity.
[horizontal]
    Data Type::: c-identifier
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class EventParameter {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute SigID string -id 1
    attribute Position int -id 1
    attribute Name string

    reference R79 ActivityArgument -link Domain -link Model -link SigID\
        -link Position
    reference R79 Event -link Domain -link Model -link Event
}
----

=== R79

* *Activity Parameter* is an instance of *Event* carries parameters of
_zero or more_ *Activity Argument*
* *Activity Parameter* is an instance of *Activity Argument*
is the parameter pattern for _one or more_ *Event*

A Event may have arguments. Those arguments form a signature
that is based on the position and data type.
However, the Event may choose to name the arguments in whatever way
it chooses as the basis of its formal parameters.
In the same way that ``C'' functions can have the same signature of
arguments even if the names given to the arguments differ.
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R79 Event 1..*--0..* ActivityArgument -associator EventParameter
----

== Population Subsystem

=== Introduction
The Population subsystem is concerned with defining the
initial data values that class instances will have and to specifying
the storage characteristics for classes.
In a `micca` generated system,
there is no dynamic memory allocation and all class storage is specified
at compile time.

image::platform-population.pdf[title="Population Subsystem Class Diagram"]

=== Population

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class Population {
    attribute Name string -id 1
    attribute Domain string -id 1

    reference R100 Domain -link {Domain Name}
}
----

=== R100
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R100 Population 0..*--1 Domain
----

=== Value Element

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ValueElement {
    attribute Domain string -id 1
    attribute Name string -id 1
}
----

=== Element Population

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ElementPopulation {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Element string -id 1
    attribute Allocation int

    reference R101 Population -link {Population Name} -link Domain
    reference R101 ValueElement -link Domain -link {Element Name}
}
----

=== R101
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R101 Population 0..*--1..* ValueElement -associator ElementPopulation
----

=== R104
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R104 ValueElement Class MultipleAssigner
----

=== Element Instance

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ElementInstance {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Element string -id 1
    attribute Instance string -id 1

    reference R102 ElementPopulation -link Population -link Domain -link Element
}
----

=== R102
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R102 ElementInstance 0..*--1 ElementPopulation
----

=== R105
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
generalization R105 ElementInstance ClassInstance MultipleAssignerInstance
----

=== Class Instance

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ClassInstance {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Instance string -id 1

    reference R105 ElementInstance -link Population -link Domain\
        -link {Class Element} -link Instance
}
----

=== Multiple Assigner Instance

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class MultipleAssignerInstance {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Association string -id 1
    attribute Instance string

    reference R105 ElementInstance -link Population -link Domain\
        -link {Association Element} -link Instance
}
----

=== R103
 
==== Implementation
[source,tcl]
----
<<micca configuration>>=
association R103 ClassInstance 0..*--1..* ClassComponent\
    -associator ClassComponentValue
----

=== Class Instance Value

Class description

Attribute::
    Description
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<micca configuration>>=
class ClassComponentValue {
    attribute Population string -id 1
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Component string -id 1
    attribute Instance string -id 1
    attribute Value string

    reference R103 ClassInstance -link Population -link Domain\
        -link Class -link Instance
    reference R103 ClassComponent -link Domain -link Class -link {Component Name}
}
----
