// vim:set syntax=asciidoc:
////
Template for classes.

=== Class 

Class description

Attribute Name::
    Attribute Description
[horizontal]
    Data Type::: Data type name

// repeated for each attribute

////

// Some attributes

:mult-attribute: This attribute records whether the reference by the class can be multiple.  Muliple associations may refer to more than one associated instances.  Singular association may refer to only one associated instance.

:cond-attribute: This attribute records whether the reference by the class is conditional. Conditional associations allow for there to be zero instances referred to. Unconditional associations insist that there must be at some instance referred to.


= The Micca Platform

[partintro]
--
In this part we present a class model of the platform specific model used
by `micca`.
Some readers will have studied platform independent models.
These are sometimes referred to as _meta-models_.
There is no single meta-model for XUML.
You can express the rules of executable modeling in a number of ways,
although the several meta-models that have been developed have,
as would be expected,
many of the same constructs in them.
The model we present here is platform specific.
The platform we are targeting is single threaded with ``C'' as the
implementation language.
The platform also assumes that all data will be held in primary memory
and that all data storage is statically allocated.
Consequently,
some of the constructs in this model will be decidedly implementation
oriented.
It is, after all, meant to be specific to a particular computing technology.
A single threaded, ``C'' based implementation is *not* an appropriate
basis for all executable models.
It is suitable, however, for a large class of applications.
That is generally true of all translation technologies.
You must be specific about the chosen class of applications and then
choose appropriate computing technology that is applicable to that class
of applications.
There is no such thing as a universal software architecture any more than
there is a universal programming language.
All involve trade-offs of usually conflicting needs and requirements.

The role of the platform model is central to the overall translation
scheme.
Populating this model is the primary focus of the `micca` domain specific
language.
The code generation phase of the translation will query the populated
platform model to produce ``C'' language output to implement the
semantics of the model.

Consequently,
we devote considerable effort to describing the platform model.
We divide the discussion up into several sections focused on
a particular subsystem of the platform model.
The platform model itself is implemented as a `rosea` domain.
Intermixed with the platform model description is the implementation of the
model in `rosea`.
--

== Domain Subsystem

=== Introduction

The domain subsystem is concerned with defining the basic elements
of what constitutes a domain
Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-domain.pdf[title="Domain Subsystem Class Diagram"]

[[domain-subsystem-discussion]]
A *Domain* is identified by a *Name*.
A *Domain* consists of a set of *Domain Elements* (*R1*).
*Domain Elements* are of two types (*R2*),
*Class* and *Relationship*.
*R2* insures that classes and relationships have different names and this
insures there are no naming conflicts in the generated code.
For the *Domain Element.Name* attribute and many other names,
we will insist that the names be usable as ``C'' language identifiers,
_i.e._ they must start with a letter followed by an arbitrary number of
letters, digits or underscore characters.
The code generation process will use these names directly since this
eases the burden of finding model elements in the generated implementation.

A *Domain* may also define a set of *Domain Operation* (*R5*).
These operations constitute the invocable interface functions for the
*Domain*.
A *Domain* is otherwise encapsulated and code generation will not
expose symbol names used in the domain's implementation.
A *Domain Operation* may also have *Domain Operation Parameter* (*R6*)
associated with it.
It is also typical for a *Domain* to have a set of *Type Alias* (*R7*).
A *Type Alias* provides a convenient way to map model type names onto
``C'' implementation types.

A *Class* may also have a set of *Operation* (*R3*).
An *Operation* may also have a set of *Operation Parameter* (*R4*).
A *Class* *Operation* may be class based or instance based,
the difference being that an instance based operation is invoked with
a reference to the class instance upon which the operation is to happen.

=== Domain

A domain is a real or imagined world with its own set of rules.

Name \{I}::
    Each domain in a system must have a unique name.
    Code generation will use the domain name to generate a component of
    the file system path name for the generated ``C'' files
    and the domain is prepended to external symbols to avoid
    name collisions.
[horizontal]
    Data Type::: string
Interface::
    A Domain will, in general, have dependencies on other aspects of the
    system. The Interface attribute is a string that will be inserted
    in the generated interface header file for the domain.
    Typically, the Interface will contain `#include` ``C'' preprocessor
    statements, but may contain any other compiler declarations
    needed.
[horizontal]
    Data Type::: string
Prologue::
    The Prologue for a Domain is inserted into the code file before any
    `micca` generated code.
    This gives the translation the opportunity to have external or forward
    references needed to satisfy the ``C'' compiler.
[horizontal]
    Data Type::: string
Epilogue::
    The Epilogue for a Domain is inserted into the code file after any
    `micca` generated code.
[horizontal]
    Data Type::: string
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
class Domain {
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Interface string -default {}
    attribute Prologue string -default {}
    attribute Epilogue string -default {}
}
----

=== Domain Element

A domain element is one of the constituent parts of a domain.

Domain \{I,R1}::
    The name of the domain to which the element belongs.
[horizontal]
    Data Type::: references Domain.Name
Name \{I}::
    Each domain elements is given a name that is unique within the domain.
[horizontal]
    Data Type::: c-identifier.
    In addition, the code generator reserves all names that end in
    two underscore characters (__) followed by one or more upper case
    or decimal numeric characters.

[source,tcl]
.Implementation
----
<<micca configuration>>=
class DomainElement {
    attribute Domain string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name] &&\
            ![::regexp -- {__[A-Z]+\Z} $Name]}

    reference R1 Domain -link {Domain Name}
}
----

==== Checking for ``C'' Identifiers

Many names in the platform model will be directly used as an identifier in
the generated ``C'' code.
We insist they be of the correct form when the model is populated.
To be a proper identifier,
a name cannot be a keyword, must begin with an alphabetic character and
contain zero or more alphabetic, numeric or underscore characters.

[source,tcl]
----
<<helper data>>=
set keywords {_Alignas _Alignof _Atomic _Bool _Complex _Generic _Imaginary
    _Noreturn _Static_assert _Thread_local alignas alignof auto bool break case
    char complex const continue default do double else enum extern float for
    goto if imaginary inline int long noreturn register restrict return short
    signed sizeof static static_assert struct switch thread_local typedef union
    unsigned void volatile while}

<<helper commands>>=
proc isIdentifier {name} {
    variable keywords
    return [expr {[lsearch -sorted -exact $keywords $name] == -1 &&\
            [regexp {\A[[:alpha:]]\w*\Z} $name]}] ; # <1>
}
----
<1> The regular expression gibberish is just a translation of what
the narrative description says.

=== R1

* *Domain Element* is an entity of _exactly one_ *Domain*
* *Domain* models entities using _zero or more_ *Domain Element*

A domain is allowed to be empty of domain elements.
This is certainly not an extremely useful situation but is allowed.
Each element of a domain belongs strictly to a single domain,
_i.e._ domain elements are never shared between domains.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R1 DomainElement 0..*--1 Domain
----

=== Class

A Class represents a logical predicate about some aspect of a Domain.

Domain \{I,I2,R2,R104}::
    The name of the domain to which the class belongs.
[horizontal]
    Data Type::: References DomainElement.Domain
Name \{I,R2,R104}::
    Classes are identified by name within the domain to which they belong.
[horizontal]
    Data Type::: string
Number \{I2}::
    It is useful during code generation to have a sequential integer number for
    classes within a given domain.
[horizontal]
    Data Type::: zero based sequential numeric

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Class {
    attribute Domain string -id 1 -id 2
    attribute Name string -id 1 ; # <1>
    attribute Number int -id 2

    reference R2 DomainElement -link Domain -link Name
    reference R104 ValueElement -link Domain -link Name
}
----
<1> The question arises whether we need to check if *Class.Name* is a
valid ``C'' identifier.
The answer is no.
Since *Class.Name* refers to *DomainElement.Name* unconditionally,
the check on *DomainElement.Name* insures that *Class.Name* is a valid
``C'' identifier.
Otherwise, we would fail the referential integrity check indicated by *R2*.

=== Relationship

A Relationship represents a real world association between class instances.

Domain \{I,R2}::
    The name of the domain to which the relationsihp belongs.
[horizontal]
    Data Type::: References DomainElement.Domain
Name \{I,R2}::
    Relationships are identified by name within the domain to which they belong.
    Traditionally, relationships are given names of the form, "R<digit>+", where
    <digit> is a decimal number.
    Although the convention is very commonly used in the executable modeling
    world, relationships may be given any valid ``C'' identifier.
[horizontal]
    Data Type::: Refers to Domain Element.Name
Number \{I2}::
    It is useful during code generation to have a sequential integer number for
    relationships within a given domain.
[horizontal]
    Data Type::: sequential numeric

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Relationship {
    attribute Domain string -id 1 -id 2
    attribute Name string -id 1
    attribute Number int -id 2 -system 0

    reference R2 DomainElement -link Domain -link Name
}
----

=== R2

* *DomainElement* is a *Class* or *Relationship*

There are only two types of domain elements, Classes and Relationships.
These elements alone model the domain subject matter.

[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R2 DomainElement Class Relationship
----

=== Domain Operation

A Domain Operation is an executable body of code that provides
a service access point into a domain.
The set of domain operations of a domain constitute the invocable programming
interface to the domain.

Domain \{I,R5}::
    The name of the domain to which the domain operation belongs.
[horizontal]
    Data Type::: refers to Domain.Name
Name \{I}::
    The name of the operation. Domain operations are given names that
    must be unique only within a given domain.
[horizontal]
    Data Type:::: c-identifier
Body::
    The code that is to be executed when the domain operation is invoked.
    This code is presumed to be ``C'' language statements and,
    except for some preprocessing of the statements,
    is passed along in the generated output file for the domain.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the domain operation.
[horizontal]
    Data Type:::: c-typename
Comment::
    A text string that is passed only as a comment in the generated
    header file for the domain.
    This provides a means for documentation of the operation to be
    included in the generated output of the domain.
[horizontal]
    Data Type:::: string

[source,tcl]
.Implementation
----
<<micca configuration>>=
class DomainOperation {
    attribute Domain string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Body string
    attribute ReturnDataType string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName\
            $ReturnDataType]}
    attribute Comment string -default {}
    attribute File string
    attribute Line int

    reference R5 Domain -link {Domain Name}
}
----

=== R5

* *Domain Operation* is a service for _exactly one_ *Domain*
* *Domain* provides service via _zero or more_ *Domain Operation*

Domain operations only operate on a single domain.
However, a domain may not provide an explicit service entry points
and have no defined domain operations.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R5 DomainOperation 0..*--1 Domain
----

=== Domain Operation Parameter

A Domain Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R6}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to Domain Operation.Domain
Operation \{I,I2,R6}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to Domain Operation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list
    without reference to the parameter name.
[horizontal]
    Data Type::: numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

[source,tcl]
.Implementation
----
<<micca configuration>>=
class DomainOperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName $DataType]}

    reference R6 DomainOperation -link Domain -link {Operation Name}
}
----

=== R6

* *Domain Operation Parameter* defines a formal parameter of _exactly one_
    *Domain Operation*
* *Domain Operation* has a formal parameter defined by _zero or more_
    *Domain Operation Parameter*

A domain operation parameter definition only applies to a single operation.
However, domain operations may have no parameters
as it is valid to have ``C'' functions with no parameters.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R6 DomainOperationParameter 0..*--1 DomainOperation
----

=== External Operation

A External Operation is a executable body of code that provides
a service access point into a domain.
The set of external operations of a domain constitute the invocable
programming
interface to the domain.

Domain \{I,R10}::
    The name of the domain to which the external operation belongs.
[horizontal]
    Data Type::: refers to Domain.Name
Name \{I}::
    The name of the operation. External operations are given names that
    must be unique only within a given domain.
[horizontal]
    Data Type:::: c-identifier
Body::
    A body of code may be specified for an external operation.
    Normally, the code generator ignores the external operation code
    since that functionality is being provided by something outside
    of the domain.
    However for testing purposes, the code will include an implementation
    of the external operation.
    This simplifies building an executable for the the domain.
    This code is presumed to be ``C'' language statements and,
    except for some preprocessing of the statements,
    is passed along in the generated output file for the domain if
    requested.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the external operation.
[horizontal]
    Data Type:::: c-typename
Comment::
    A text string that is passed only as a comment in the generated
    header file for the domain.
    This provides a means for documentation of the operation to be
    included in the generated output of the domain.
[horizontal]
    Data Type:::: string

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ExternalOperation {
    attribute Domain string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Body string -default {}
    attribute ReturnDataType string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName\
            $ReturnDataType]}
    attribute Comment string -default {}
    attribute File string
    attribute Line int

    reference R10 Domain -link {Domain Name}
}
----

=== R10

* *External Operation* provides service to _exactly one_ *Domain*
* *Domain* requires service from _zero or more_ *External Operation*

External operations only provide service to a single domain.
However, a domain may not require any explicit external services
and have no defined external operations.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R10 ExternalOperation 0..*--1 Domain
----

=== External Operation Parameter

A External Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R11}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to External Operation.Domain
Operation \{I,I2,R11}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to External Operation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list
    without reference to the parameter name.
[horizontal]
    Data Type::: numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ExternalOperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName $DataType]}

    reference R11 ExternalOperation -link Domain -link {Operation Name}
}
----

=== R11

* *External Operation Parameter* defines a formal parameter of _exactly one_
    *External Operation*
* *External Operation* has a formal parameter defined by _zero or more_
    *External Operation Parameter*

An external operation parameter definition only applies to a single operation.
However, external operations may have no parameters
as it is valid to have ``C'' functions with no parameters.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R11 ExternalOperationParameter 0..*--1 ExternalOperation
----

=== Constructor

A Constructor is a body of code that is invoked by the system when a
class instance is created.
Note that the constructor concept in `micca` is very simplified.
Constructors receive no arguments other than a reference to the
newly created class instance
nor is there any notion of a construction hierarchy with other classes.
The primary use for construction is to initialize attributes that have
some internal structure and represent a user defined data type.

Domain \{I,R8}::
    The name of the domain to which the constructor applies.
[horizontal]
    Data Type::: refers to Class.Domain
Class \{I,R8}::
    The name of the class to which the constructor applies.
[horizontal]
    Data Type::: refers to Class.Name
Body ::
    The body of the constructor. This is assumed to be ``C'' code.
[horizontal]
    Data Type::: string

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Constructor {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Body string
    attribute File string
    attribute Line int

    reference R8 Class -link Domain -link {Class Name}
}
----

=== R8

* *Constructor* is an instance initializer for _exactly one_ *Class*
* *Class* initializes instances using _at most one_ *Constructor*

A class may have a constructor but is not required to.
Any constructor only operates on a single class.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R8 Constructor 0..*--1 Class
----

=== Destructor

A Destructor is a body of code that is invoked by the system when a
class instance is destroyed.
The destructor is invoked with a reference to the class instance being
destroyed.
Like constructors,
the primary use for a destructor is to clean up resources or aggregate

Domain \{I,R9}::
    The name of the domain to which the destructore applies.
[horizontal]
    Data Type::: refers to Class.Domain
Class \{I,R9}::
    The name of the class to which the destructore applies.
[horizontal]
    Data Type::: refers to Class.Name
Body ::
    The body of the constructor. This is assumed to be ``C'' code.
[horizontal]
    Data Type::: string

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Destructor {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Body string
    attribute File string
    attribute Line int

    reference R9 Class -link Domain -link {Class Name}
}
----

=== R9

* *Destructor* is an instance destroyer for _exactly one_ *Class*
* *Class* destroys instances using _at most one_ *Destructor*

A class may have a destructor but is not required to.
Any destructor only operates on a single class.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R9 Destructor 0..*--1 Class
----

=== Operation

An *Operation* is a executable body of code that computes on a
class or class instance.

Domain \{I,R3}::
    The name of the domain to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Domain
Class \{I,R3}::
    The name of the class to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Name
Name \{I}::
    The name of the operation. Operations are given names that
    must be unique only within a given class.
[horizontal]
    Data Type:::: c-identifier
IsInstance::
    This attribute determine whether the operation applies to class instances.
    If true, then the generated code for the operation will have
    an implicitly declared parameter named `self`.
[horizontal]
    Data Type:::: boolean
Body::
    The code that is to be executed when the operation is invoked.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the operation.
[horizontal]
    Data Type:::: c-typename

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Operation {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute IsInstance boolean
    attribute Body string
    attribute ReturnDataType string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName\
            $ReturnDataType]}
    attribute File string
    attribute Line int

    reference R3 Class -link Domain -link {Class Name}
}
----

=== R3

* *Operation* operates over _exactly one_ *Class*
* *Class* is the domain for _zero or more_ *Operation*

Operations only operate on a single class.
However, a class may not provide any explicit operations.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R3 Operation 0..*--1 Class
----

=== Operation Parameter

An Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R4}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Domain
Class \{I,I2,R4}::
    The name of the class to which the parameter belongs.
[horizontal]
    Data Type::: refers to Operation.Class
Operation \{I,I2,R4}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list.
[horizontal]
    Data Type::: sequential numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

[source,tcl]
.Implementation
----
<<micca configuration>>=
class OperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Class string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName $DataType]}

    reference R4 Operation -link Domain -link Class -link {Operation Name}
}
----

=== R4

* *Operation Parameter* defines a formal parameter of _exactly one_
    *Operation*
* *Operation* has a formal parameter defined by _zero or more_
    *Operation Parameter*

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R4 OperationParameter 0..*--1 Operation
----

=== Type Alias

Typically, attributes in class models are given application specific
data types that reflect the value semantics of the attribute.
These must be mapped onto an implementation provided data type.
A Type Alias is just such a mapping.
In ``C'',
there are no mechanisms to implement a user defined data type.
What is provided is a simple alias scheme whereby a new name may be given
to a defined type.

Domain \{I,R7}::
    The name of the domain to which the type alias belongs.
[horizontal]
    Data Type::: refers to Class.Domain
TypeName \{I}::
    The new name of a type. Typically, this name will correspond to the type
    for a model attribute.
    The name must be a ``C'' identifier as it will be passed along by
    the code generation.
[horizontal]
    Data Type::: c-identifier
TypeDefinition ::
    A ``C'' type name which represents the type alias in the implementation.
[horizontal]
    Data Type::: c-typename

[source,tcl]
.Implementation
----
<<micca configuration>>=
class TypeAlias {
    attribute Domain string -id 1
    attribute TypeName string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $TypeName]}
    attribute TypeDefinition string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName\
            $TypeDefinition]}

    reference R7 Domain -link {Domain Name}
}
----

=== R7

* *Type Alias* is an implementation type of _exactly one_ *Domain*
* *Domain* defines implementation types via _zero or more_ *Type Alias*

Domains may specify an arbitrary number of aliases for their attribute
data types.
Any alias specified by a domain applies only to that domain.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R7 TypeAlias 0..*--1 Domain
----


== Classes Subsystem

=== Introduction

[[classes-subsystem-discussion]]
The classes subsystem defines how model level ideas of a class will be
realized in `micca`.
We will simplify considerably the relational view of classes that
we find at the model level.
Because we are holding all data in memory and we are using
an implemenation language that exposes addresses,
there are number of simplifying transformations on classes available to us.

* Since the address in memory (_.i.e._ a pointer to an object) is unique,
we can use it as an identifier of each class instance.
If the identifying attributes from the model serve no other descriptive role,
then they can be eliminated altogether.
Using the object pointer as an identifier has a number of
other implementation benefits such as directly accessing attribute values.
* Referential attributes will be replaced by pointer values.
Since referential attributes always refer to identifiers in the model,
then implementing relationships can be accomplished by storing
sets of pointers whose values refer to objects in memory.

Both of these considerations lead to the decision,
common for platforms of the type `micca` is intended,
to map model level class definitions onto ``C'' structure definitions.
Storage for a class can then be allocated as an array of structures
that correspond to the class definition and
relationship information is stored as pointers into the instance arrays.
Most of the classes subsystem is concerned with how the ``C'' structure
definitions will be composed and the type of information that is held.
We will also be concerned with how some relationship storage will be
structured since there are choices that have different trade-offs.

Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-classes.pdf[title="Classes Subsystem Class Diagram"]

A *Class* is composed of *ClassComponent* (*R20*).
There are two types of *ClassComponent* (*R25*).
*PopulatedComponent* are fundamental components whose values can be determine
by population.
*GeneratedComponent* are those that arise because of the design of how
reference information is held.
There are two types of *PopulatedComponent* (*R21).
An *Attribute* is a named, descriptive value of the *Class*.
Attributes come in two types (*R29*).
The value of an *IndependentAttribute* does not depend upon any other
aspect of the  domain and may have a *DefaultValue* (*R22*).
A *DependentAttribute* depends upon other aspects of the domain
and its value can be computed by a formula.
Consequently, you cannot update the value of a *DependentAttribute*.
Dependent attributes are, strictly speaking, redundant, but are used
by models to provide summary information in a more conveniently accessible form.
A *Reference* is used to specify class relationships.
There are three types of *Reference* (*R23*).
An *AssociationReference* is a reference a class makes to realize
a relationship.
An *Associator Reference* is the pair of references that an associator
class makes to map participants in a class based association.
A *Superclass Reference* is the reference that a *Subclass* makes to
it related *Superclass*.
There are four types of *GeneratedComponent* (*R24*).
A reference generalization supertype uses a *SubclassReference* to traverse a
generalization relationship from superclass to subclass.
A union generalization subclass may be held as a discriminated union in
a *SubclassContainer*.
When a class instance participates in a multiple relationship that uses
linked lists,
the memory for the list linkage is held in a *LinkContainer*.
Traversal in a relationship in the direction opposite of the
references is realized by a *ComplementaryReference*.
A *ComplementaryReference* may also be one of three different types (*R26*).
The types of references fulfill different roles and types of relationships.
A *SingularReference* is used to store a pointer to a single class instance.
An *ArrayReference* holds the references for static associations of
multiplicity greater than one
and a *LinkReference* serves the same role for dynamic associations.
A *LinkReference uses a *LinkContainer* to store pointers for chaining
instances together (*R27*).
A *ComplementaryReference* may also be used in one of two ways (*R28*).
A *ForwardReference* is that reference set originated in a class based
association when traversing the forward direction.
A *BackwardReference* is that reference used when navigating any association
in the reverse direction.

=== Class Component

A Class Component is an element of the implementation class structure
and directly represents a member of the structure definition for the class
as it is used in the generated code.

Domain \{I,R20}::
    The name of the domain to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Domain
Class \{I,R20}::
    The name of the class to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Name
Name \{I}::
    The name of the component.
[horizontal]
    Data Type::: c-identifier
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ClassComponent {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R20 Class -link Domain -link {Class Name}
}
----

=== R20

* *ClassComponent* defines the properties of _exactly one_ *Class*
* *Class* is characterized by _one or more_ *ClassComponent*

A Class is made up of one or more components and each component
can belong to only one class.
Empty classes are not allowed as these are deemed to model nothing.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R20 ClassComponent 1..*--1 Class
----

=== R25

* *ClassComponent* is a *GeneratedComponent* or *PopulatedComponent*

Some class components are fundamental in the sense that they
can be given values as part of an initial instance population or
when dynamically created.
These types of components are *PopulatedComponents*.
Other types of class components are created as part of the specific
design of how model execution rules are mapped onto the implementation.
The values of such components can be deduced from those of the
*PopulatedComponents*.
These types of components are *GeneratedComponents*.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R25 ClassComponent GeneratedComponent PopulatedComponent
----

=== Populated Component

A Populated Component is that type of Class Component for which values
can be specified in an initial instance population or during
run time creation.
These types of components are fundamental to the class model and
carry values that are meaningful to the semantics of the model.

Domain \{I,R25}::
    The name of the domain to which the populated component belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R25}::
    The name of the class to which the populated component belongs.
[horizontal]
    Data Type::: Refers to Class Component.Name
Name \{I,R25}::
    The name of the component.
[horizontal]
    Data Type::: Refers to Class Component.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class PopulatedComponent {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R25 ClassComponent -link Domain -link Class -link Name
}
----

=== Generated Component

A Generated Component is that type of Class Component
that exists as a result of the design of how model execution rules
are being mapped onto the implementation.
The values of these components can be deduced from those of the
Populated Components.

Domain \{I,R25}::
    The name of the domain to which the generated component belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R25}::
    The name of the class to which the generated component belongs.
[horizontal]
    Data Type::: Refers to Class Component.Name
Name \{I,R25}::
    The name of the component.
[horizontal]
    Data Type::: Refers to Class Component.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class GeneratedComponent {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R25 ClassComponent -link Domain -link Class -link Name
}
----

=== R21

* *PopulatedComponent* is an *Attribute* or *Reference*

There are two types of components that may be populated for a class.
An attribute corresponds to a model level attribute that holds data
parameterizing the class
(_i.e._ attributes whose roles are descriptive and not strictly referential or
identifying).
A reference is one or more pointers that are used to implement
model level relationships.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R21 PopulatedComponent Attribute Reference
----

=== Attribute

The Attribute class represent descriptive data that parameterizes a class.

Domain \{I,R21}::
    The name of the domain to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Populated Component.Domain
Class \{I,R21}::
    The name of the class to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Populated Component.Class
Name \{I,R21}::
    The name of the attribute.
[horizontal]
    Data Type::: Refers to Populated Component.Name
DataType::
    The data type of the parameters.
[horizontal]
    Data Type::: c-typename
Dimension::
    The number of elements in the array allocated to the attribute.
    A Dimension of 0 represents a simple scalar value.
    Dimensions greater than 0 mean that the attribute will be allocated
    as an array of the type given by the *Data Type* attribute.
    By special dispensation,
    attributes of `char` *Data Type* with a *Dimension* greater than 0
    will be treated as a string and values will be `NUL` terminated
    in the convention of simple strings in ``C''.
[horizontal]
    Data Type::: non-negative number
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
class Attribute {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute DataType string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName $DataType]}
    attribute Dimension int -default 0 -check {$Dimension >= 0}

    reference R21 PopulatedComponent -link Domain -link Class -link Name
}
----

=== Independent Attribute

The Independent Attribute class represents those attributes whose
value is independent of other components of the model.
Values of independent attributes may be read or updated by domain activities.

Domain \{I,R29}::
    The name of the domain to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Attribute.Domain
Class \{I,R29}::
    The name of the class to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Attribute.Class
Name \{I,R29}::
    The name of the attribute.
[horizontal]
    Data Type::: Refers to Attribute.Name
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
class IndependentAttribute {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R29 Attribute -link Domain -link Class -link Name
}
----

=== Dependent Attribute

The Dependent Attribute class represents those attributes whose
value can be described by a formula or algorithm.
Values of independent attributes may only be read.

Domain \{I,R29}::
    The name of the domain to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Attribute.Domain
Class \{I,R29}::
    The name of the class to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Attribute.Class
Name \{I,R29}::
    The name of the attribute.
[horizontal]
    Data Type::: Refers to Attribute.Name
Formula::
    A segment of ``C'' code that is executed whenever there the
    attribute is read.
    The return value of the code matches the type given by
    the related Attribute.Data Type attribute.
[horizontal]
    Data Type::: string
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
class DependentAttribute {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Formula string
    attribute File string
    attribute Line int

    reference R29 Attribute -link Domain -link Class -link Name
}
----

=== R29

* *Attribute* is an *IndependentAttribute* or *DependentAttribute*

The `R29` generalization reflects the distinction made between
those attributes that are functionally independent of the other model
components and those that are not.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R29 Attribute IndependentAttribute DependentAttribute
----

=== Default Value

The default value of an attribute is one that will be given to the
attribute when an class instance is created if no value is otherwise provided.
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class DefaultValue {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Attribute string -id 1
    attribute Value string

    reference R22 IndependentAttribute -link Domain -link Class\
            -link {Attribute Name}
}
----

=== R22

* *DefaultValue* supplies missing value for _exactly one_ *IndependentAttribute*
* *IndependentAttribute* has missing value supplied by _zero or one_ *DefaultValue*

An Independent Attribute may be defined to have a default value that the system
will use when the attribute's value is not otherwise specified when
a class instance is created.
There can only be one default value for an attribute
and not all attributes will define default values.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R22 DefaultValue 0..1--1 IndependentAttribute
----

=== Reference

A reference is one or more pointer values that are used to implement
the ability to navigate a relationship.

Domain \{I,R21}::
    The name of the domain to which the reference belongs.
[horizontal]
    Data Type::: Refers to Populated Component.Domain
Class \{I,R21}::
    The name of the class to which the reference belongs.
[horizontal]
    Data Type::: Refers to Populated Component.Class
Name \{I,R21}::
    The name of the reference.
[horizontal]
    Data Type::: Refers to Populated Component.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Reference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 PopulatedComponent -link Domain -link Class -link Name
}
----

=== R23

* *Reference* is a *AssociationReference*, *AssociatorReference*,
or *SuperclassReference*

There are three types of references that specify class relationships.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R23 Reference\
    AssociationReference AssociatorReference SuperclassReference
----

=== Association Reference
An Association Reference is the reference made by the class playing the
referring role in a simple association type of relationship.

Domain \{I,R23}::
    The name of the domain to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the assocation reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class AssociationReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== Associator Reference
When a class is an associator class,
it makes two references to the participants in a class based association.
Note for associator references,
the reference values may not be empty and must always refer to a class
instance.
This is because there is an instance of the associator class for
each instance of the association relationship itself.

Domain \{I,R23}::
    The name of the domain to which the associator reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the associator reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the associator reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class AssociatorReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== Superclass Reference
A Superclass Reference is the reference that a subclass makes to
the superclass instance to which it is related.

Domain \{I,R23}::
    The name of the domain to which the superclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the superclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the superclass reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class SuperclassReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== R24

* *Generated Component* is a *Complementary Reference*, *Link Container*,
*Subclass Container* or *Subclass Reference*

There are four types of components that are generated.
These components do not have independent values,
_i.e._ the values of the component may be derived from
the values of *PopulatedComponents*.
The necessity of these types of components arise from the design
decision as to how relationships are navigated and subclass instance
may be stored.

[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R24 GeneratedComponent ComplementaryReference LinkContainer\
        SubclassContainer SubclassReference
----

=== Complementary Reference

To facilitate navigating associations in the directions other
than that indicated by direct referential attributes,
a Complementary Reference component is created to hold reference pointers to
the referring class of an association.

Domain \{I,R24}::
    The name of the domain to which the complementary reference belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Domain
Class \{I,R24}::
    The name of the class to which the complementary reference belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Class
Name \{I,R24}::
    The name of the complementary reference.
[horizontal]
    Data Type::: Refers to Generated Component.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ComplementaryReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 GeneratedComponent -link Domain -link Class -link Name
}
----

=== Link Container

When a class stores multiple references as part of a back reference
and those references are threaded onto a linked list,
then the classes residing on the linked list have a Link Container
component defined for them to hold the link list pointers.
It is possible for an instance to be threaded onto multiple linked
lists and each will have a Link Container component defined to hold
the pointer values.

Domain \{I,R24}::
    The name of the domain to which the link container belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Domain
Class \{I,R24}::
    The name of the class to which the link container belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Class
Name \{I,R24}::
    The name of the link container.
[horizontal]
    Data Type::: Refers to Generated Component.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class LinkContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute LinkClass string
    attribute LinkComp string

    reference R24 GeneratedComponent -link Domain -link Class -link Name
    reference R27 LinkReference -link Domain -link {LinkClass Class}\
            -link {LinkComp Name}
}
----

=== Subclass Container

One option for storing generalization relationship information is
as a union.
The idea is that subclass storage is accomplished by creating a union
of all the subclasses in the generalization.
Then an component of the superclass is defined to be the subclasses union.
This type of storage structure can save some memory space and
traversal across the generalization relationships can be accomplished
with pointer arithmetic.

Domain \{I,R24}::
    The name of the domain to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Domain
Class \{I,R24}::
    The name of the class to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Class
Name \{I,R24}::
    The name of the subclass container.
[horizontal]
    Data Type::: Refers to Generated Component.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class SubclassContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 GeneratedComponent -link Domain -link Class -link Name
}
----

=== Subclass Reference
For generalization relationships that used references (rather than a union),
a Subclass Reference holds the pointer to the related subclass instance.

Domain \{I,R24}::
    The name of the domain to which the subclass reference belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Domain
Class \{I,R24}::
    The name of the class to which the subclass reference belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Class
Name \{I,R24}::
    The name of the subclass reference.
[horizontal]
    Data Type::: Refers to Generated Component.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class SubclassReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 GeneratedComponent -link Domain -link Class -link Name
}
----

=== R26

* *Complementary Reference* is a *Singular Reference*, *Array Reference*,
    or *Link Reference*

There are three types of Complementary References
that represent the three ways that reference pointer values are stored.
The type of reference accommodates both the multiplicity of the
association and its dynamic behavior.

[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R26 ComplementaryReference SingularReference ArrayReference\
        LinkReference
----

=== Singular Reference

A singular reference holds a single pointer value as a scalar
structure member.
It is used when the back reference for an association is of multiplicity one.

Domain \{I,R26}::
    The name of the domain to which the singular reference belongs.
[horizontal]
    Data Type::: Refers to Back Reference.Domain
Class \{I,R26}::
    The name of the class to which the singular reference belongs.
[horizontal]
    Data Type::: Refers to Back Reference.Class
Name \{I,R26}::
    The name of the singular reference.
[horizontal]
    Data Type::: Refers to Back Reference.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class SingularReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R26 ComplementaryReference -link Domain -link Class -link Name
}
----

=== Array Reference

An array reference holds multiple reference pointer values in the form
of an array.
It is used when the back reference for an association is of multiplicity
greater than one and the association is static in nature.

Domain \{I,R26}::
    The name of the domain to which the array reference belongs.
[horizontal]
    Data Type::: Refers to Back Reference.Domain
Class \{I,R26}::
    The name of the class to which the array reference belongs.
[horizontal]
    Data Type::: Refers to Back Reference.Class
Name \{I,R26}::
    The name of the array reference.
[horizontal]
    Data Type::: Refers to Back Reference.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ArrayReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R26 ComplementaryReference -link Domain -link Class -link Name
}
----

=== Link Reference

A link reference holds the terminus of a linked list that is used
to thread together multiple instances as part of a back reference.
It is used when the back reference for an association is of multiplicity
greater than one and the association is dynamic in nature.

Domain \{I,R26}::
    The name of the domain to which the link reference belongs.
[horizontal]
    Data Type::: Refers to Back Reference.Domain
Class \{I,R26}::
    The name of the class to which the link reference belongs.
[horizontal]
    Data Type::: Refers to Back Reference.Class
Name \{I,R26}::
    The name of the link reference.
[horizontal]
    Data Type::: Refers to Back Reference.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class LinkReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R26 ComplementaryReference -link Domain -link Class -link Name
}
----

=== R27

* *LinkContainer* contains pointers for _exactly one_ *LinkReference*
* *LinkReference* links to _exactly one_ *LinkContainer*

When class instances are threaded onto a linked list as part of
a Link Reference,
the reference is always between exactly two classes.
One class contains the linked list terminus
and the other (not necessarily distinct) class contains Link Containers
to hold the linked list pointers.
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R27 LinkContainer 1--1 LinkReference
----

=== R28

* *Complementary Reference* is a *Forward Reference* or *Backward Reference*

A *Complementary Reference* is used in one of two ways.
First, it is used when navigating the forward direction for class based
associations.
Second, it used when navigating in the reverse direction for all
types of associations.

[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R28 ComplementaryReference ForwardReference BackwardReference
----

=== Forward Reference

To facilitate navigating associations in the directions other
than that indicated by direct referential attributes,
a Forward Reference component is created to hold reference pointers to
the referring class of an association.

Domain \{I,I2,R27}::
    The name of the domain to which the forward reference belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Domain
Class \{I,I2,R27}::
    The name of the class to which the forward reference belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Class
Name \{I,R27}::
    The name of the forward reference.
[horizontal]
    Data Type::: Refers to Generated Component.Name
Relationship \{I2}::
    The relationship name that the forward reference is used in navigating.
[horizontal]
    Data Type::: string
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ForwardReference {
    attribute Domain string -id 1 -id 2
    attribute Class string -id 1 -id 2
    attribute Name string -id 1
    attribute Relationship string -id 2

    reference R28 ComplementaryReference -link Domain -link Class -link Name
}
----

=== Backward Reference

To facilitate navigating associations in the directions other
than that indicated by direct referential attributes,
a Backward Reference component is created to hold reference pointers to
the referring class of an association.

Domain \{I,I2,R27}::
    The name of the domain to which the backward reference belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Domain
Class \{I,I2,R27}::
    The name of the class to which the backward reference belongs.
[horizontal]
    Data Type::: Refers to Generated Component.Class
Name \{I,R27}::
    The name of the backward reference.
[horizontal]
    Data Type::: Refers to Generated Component.Name
Relationship \{I2}::
    The relationship name that the backward reference is used in navigating.
[horizontal]
    Data Type::: string
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class BackwardReference {
    attribute Domain string -id 1 -id 2
    attribute Class string -id 1 -id 2
    attribute Name string -id 1
    attribute Relationship string -id 2

    reference R28 ComplementaryReference -link Domain -link Class -link Name
}
----

== Relationship Subsystem [[relationship-subsystem]]

=== Mapping Referential Attributes to Pointers
When targeting a statically typed language such as ``C'' and assuming
that all class data will be held in primary memory,
we must devise a way to map relational notions of referential attributes
and referential integrity onto ``C''' language constructs.
There are, needless to say, many ways this can be done.
As we discussed earlier,
we make the convenient decision to use the address of a class instance
as an architecturally supplied identifier.
This design decision has many benefits in the implementation.
This also means we can store pointer values as a means of implementing
relationship navigation.

Consider a many-to-one association between two classes.
In a relational scheme,
we would have referential attributes in the class that was on the *many*
side of the relationship and the values of those attributes would
match the values of identifying attributes on the *one* side.
In a pointer based scheme we can do the same thing, _i.e._
place a pointer variable in the ``C'' structure of the class on the *many* side
and have the value of the pointer match that of a class instance on
the *one* side.

Now lets look at the computation required to navigate this relationship,
first from the many side to the one side and then from the one side to
the many side.
For this discussion we will assume the relationship is unconditional on
both sides.

From the many side,
given a pointer to an *A* instance
we can navigate to the related *B* instance by simply accessing the
structure member that points to the related *B* instance.
When navigating from the one side to the many side,
we will, in general, obtain more than one instance as a result of the
navigation.
We can find those instances by searching all of the many-side instances
selecting those instances who have a stored pointer value that matches the
address of the one-side class instance.

Having to perform a search for the one-side to many-side navigation is
somewhat troubling.
If the number of instances of the many-side class is small,
then there is little concern.
If it is larger, then we might explore ways to avoid costs associated
with a straight linear search of the many-side instances.
The search code is also rather inconvenient since we target a statically
typed language.
The function to iterate across the many-side instances looking for
the one-side pointer value has to be specific to that particular relationship
if we are to be strictly type safe and don't want to resort to
extremes of type casting and pointer arithmetic.

One way to avoid the search altogether is to store the pointers of the
multiple related instances.
We will have, in effect, pre-computed the related set and, at the cost of the
pointer storage, incur no run time computation to find it.
In this arrangement,
the multiple instances implied by traversing the relationship from
one side to the many side are held in an appropriate data structure
as part of the one side class structure.

It does take computation to maintain the set if the instances participating
in the relationship change.
The space vs. speed trade-off is such that we will always use some
additional space to save a run time cost and additional code associated with
computing a set of related instances.
We will also find that the choice of data structure to hold multiple
pointers will be better if we know the dynamics of the relationship.
By choosing different data structures to store the pointer sets,
we can, again at the cost of some additional space,
make maintaining the related pointer sets easier in the face of relationship
changes.

So we adopt the strategy to store relationship pointers that implement
the navigation in both participating classes.
This decision will also be helpful when we discuss referential integrity
checking and transactions on the data model.

Analysis like that above can be applied to the other types of relationships
and pointer storage schemes can be designed that map the
relational notion of referential attributes to memory pointers.
Most of the relationship subsystem is concerned with categorizing
the types of relationships from a model level
and mapping those onto the roles the classes play in the relationship.
This will then allows us to explicitly map the role a class plays in a
relationship to the kind of storage required to implement that role and
further to the class structure components that are required to hold
the pointers.
The references subsystem models this later part.

A careful analysis of the conditionality, multiplicity, reflexivity and
dynamics of relationships shows that there are 18 distinct outcomes
for how referential notions are mapped onto implementation pointer storage.
The diagrams below show how each case is implemented.
These diagrams are useful to understand both how the relationship subsystem
models the various types of relationships but also how the code generator
emits the required ``C'' structure element definitions for the classes.

image::rel-simp-nr-1-1.pdf[title="Simple Non-Reflexive 1:1 Association"]

image::rel-simp-r-1-1.pdf[title="Simple Reflexive 1:1 Association"]

image::rel-simp-nr-M-1-dyn.pdf[title="Simple Non-Reflexive M:1 Dynamic Association"]

image::rel-simp-r-M-1-dyn.pdf[title="Simple Reflexive M:1 Dynamic Association"]

image::rel-simp-nr-M-1-static.pdf[title="Simple Non-Reflexive M:1 Static Association"]

image::rel-simp-r-M-1-static.pdf[title="Simple Reflexive M:1 Static Association"]

image::rel-assoc-nr-1-1.pdf[title="Class Based Non-Reflexive 1:1 Association"]

image::rel-assoc-r-1-1.pdf[title="Class Based Reflexive 1:1 Association"]

image::rel-assoc-nr-M-1-dyn.pdf[title="Class Based Non-Reflexive M:1 Dynamic Association"]

image::rel-assoc-r-M-1-dyn.pdf[title="Class Based Reflexive M:1 Dynamic Association"]

image::rel-assoc-nr-M-1-static.pdf[title="Class Based Non-Reflexive M:1 Static Association"]

image::rel-assoc-r-M-1-static.pdf[title="Class Based Reflexive M:1 Static Association"]

image::rel-assoc-nr-M-M-dyn.pdf[title="Class Based Non-Reflexive M:M Dynamic Association"]

image::rel-assoc-r-M-M-dyn.pdf[title="Class Based Reflexive M:M Dynamic Association"]

image::rel-assoc-nr-M-M-static.pdf[title="Class Based Non-Reflexive M:M Static Association"]

image::rel-assoc-r-M-M-static.pdf[title="Class Based Reflexive M:M Static Association"]

image::rel-gen-ref.pdf[title="Reference Based Generalization"]

image::rel-gen-union.pdf[title="Union Based Generalization"]

=== Naming Conventions on Relationship Traversal

[[relationship-naming-conventions]]
In addition to modeling the real world associations between classes,
relationships also provide a means for the processing of the domain
to navigate the class diagram to access related class instances.
Here we discuss the syntax conventions we will use to indicate
how this navigation will take place.
We adopt the strategy that each relationship has a designated _direction_.
Navigating in the _forward direction_ starts with instances of a source
class and ends with instances of a target class.
Navigating in the _reverse direction_ starts with target class instances
and ends with source class instances.
To designate the forward direction we will use the unadorned relationship
name, _e.g._ `R22` and the reverse direction is indicated by
placing a tilde character before the relationship name, _e.g._ `~R22`.
The motivation behind this convention is to minimize the amount
of specification that needs to be given for navigating relationships
and to disambiguate the case of a reflexive relationship where the
source class and target class are the same.
Given the specification of a relationship direction,
the system knows which classes are involved and that detail need not be
restated when specifying the navigation.
When specifying a direction to a relationship there are three cases to
consider.

For simple assocations,
the forward direction of the relationship is from the referring class
to the referenced class.
In a simple association,
one class contains referential attributes and is hence the referring class.
The other class contains the referenced identifying attributes and
is deemed the referenced class.
The forward direction is then the traversal from instances of the
referring class to instances of the referenced class.

For generalization relationships,
the forward direction of the relationship is also from the referring class
to the referenced class.
In a generalization,
the subclass instances are always the referring instances.
Navigating from the superclass to a subclass requires additional information,
namely which subclass is to be the target.
Navigating from a superclass instance to a subclass instance can yield
at most one subclass instance and possibly zero if the superclass instance
is not actually related to the requested subclass.
So the syntax convention to navigate from a superclass instance to a subclass
instance specifies navigating in the reverse direction as well as the
desired subclass name, _e.g._ `~R42 TableLamp`.

For class based associations,
it is the associator class that holds referential attributes that refer to
both participating classes.
In this case,
the forward direction of the relationships must simply be specified
and one class is designated the source and the other the target.
Since it is also possible to navigate from a participating class to the
associator class itself,
we will specify that case by including the associator class name,
similar to the way generalization relationship navigation is specified.
Navigating from source to target is specified as the unadorned
relationship name, _e.g._ `R14`.
Navigating from target to source uses the tilde notation, _e.g._ `~R14`.
Navigating from the source to the associator includes the associator
class name, _e.g._ `R14 Ownership` and from target to associator
uses the tilde and the associator class name, _e.g._ `~R14 Ownership`.

Only associations can be reflexive (_i.e._ the source and target are the
same class).
For generalization relationships,
we insist that all the subclasses are distinct and that they are distinct
from the superclass.
The conventions used here serve to disambiguate association traversal
in the reflexive case,
however, additional specification is required to fix the precise traversal
path for the case of one-to-one and many-to-many reflexive relationships.
For a one-to-one reflexive association,
we will need to specify which attributes are the referential ones and
that will set the direction.
For a many-to-many association an associator class is required and
again we will have to specify the path from source to target.

=== Conventions Used for Class Based Associations
[[class-base-association-conventions]]
Class based association pose some additional complexity when
describing the way in which they are mapped to the implementation realm.
The associator class represents instances of the association between
the participants.
Each instance of the associator class corresponds one-to-one to instances
of the association itself.
As we discussed
<<relationship-naming-conventions,above>>,
in a class based association one participant will be deemed the source
and the other the target in order to specify the direction of the
relationship for traversal.
The associator class itself always contains the referential attributes
and in our implementation strategy, will contain two pointers, one each
to the participating class instances.
The pointer values will never be `NULL` as the reference from the
associator class to one of the participants is always unconditional.
We will decompose a class based association to make the role of the
associator class explicit.
This is shown in the diagram below.

image::assoc-decompose.pdf[title="Decomposition of Class Based Associations"]

Note that as part of the decomposition,
the multiplicity and conditionality of the source and target sides have
been switched.
Because the references from the associator class to the participants is
unconditional,
the multiplicity and conditionality of the decomposed association when going
from the source class to the associator class is the same as that specified
for the target side at the model level and conversely for the target class.
The apparent switch of the multiplicity and conditionality results from
both the decomposition,
which makes the role of the associator class and its pointer references
explicit,
and the unconditional nature of the references from the associator class to the
participant classes.

With this in mind,
we describe the roles that classes play in a class based association below.
We will have occasion to refer back to this explanation when we generate
the code for class based associations.

=== Class Diagram

Below is the UML class diagram for the relationship subsystem of the platform
model.

image::platform-relation.pdf[title="Relationship Subsystem Class Diagram"]

There are two types of *Relationship* (*R30*), namely
*Association* and *Generalization*.
In turn,
there are two types of *Association* (*R31*), namely
*Simple Association* and *Class Based Association*.
A *Class Based Association* uses a distinct *Associator Class* (*R42*)
to hold references to the participating *Source Class* (*R34*) and
*Target Class* (*R35*).
A *Simple Association* is one where the multiplicity and conditionality
are such that all the references can be located in one of the participating
classes.
The *Simple Referring Class* houses the references (*R32*) while the
*Simple Referenced Class* is the one referred to (*R33*).
`Micca` supports two ways to handle generalization relationships (*R43*).
A *Reference Generalization* uses pointer values to implement the
relationship.
In this arrangement,
a *Referenced Superclass* (*R36*) holds a pointer and encoded type to
a *Referring Subclass* (*R37*).
The *Referring Subclass* also holds a pointer to its related superclass
instances.
A *Union Generalization* uses a discriminated union
to implement the relationship.
This leads to the complementary ideas of a *Union Superclass* (*R44*) and
a *Union Subclass* (*R45*).
All of these class roles are specialized as a *Class Role* (*R40*) which
is the many-to-many-to-many correlation between *Relationship* and
*Class* (*R41*).

=== Association
An Association is a mapping between the instances of two classes.
The two classes need not be distinct.
If the association is between instances of the same class,
then it is called a _reflexive_ association.
If the association is between instances of distinct classes,
then it is called a _non-reflexive_ association.

Domain \{I,R30}::
    The name of the domain to which the association belongs.
[horizontal]
    Data Type::: Refers to Relationship.Domain
Name \{I,R30}::
    The name of the association.
[horizontal]
    Data Type::: Refers to Relationship.Name.
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Association {
    attribute Domain string -id 1
    attribute Name string -id 1
    attribute IsStatic boolean -default false

    reference R30 Relationship -link Domain -link Name
}
----

=== Generalization
An Generalization is a partitioning of a class into a disjoint union.

Domain \{I,R30}::
    The name of the domain to which the generalization belongs.
[horizontal]
    Data Type::: Refers to Relationship.Domain
Name \{I,R30}::
    The name of the generalization.
[horizontal]
    Data Type::: Refers to Relationship.Name.
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Generalization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R30 Relationship -link Domain -link Name
}
----

=== R30
* *Relationship* is an *Association* or *Generalization*

There are two fundamental types of relationships.
These types are complementary to each other.
An Association is fundamentally related to the Cartesian product
of the participants.
A Generalization is related to the disjoint union of the particiants.

[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R30 Relationship Association Generalization
----

=== R31
* *Association* is a *Simple Association* or *Class Based Association*

Associations are mappings between class instances.
In its most general form,
a separate class is used to hold the mappings and these are called
*Class Based Associations*.
For the special case of one-to-one and one-to-many multiplicities,
the realization of the association can be simplified by placing
the association mappings into one of the participating classes.
These are known as *Simple Association*.

[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R31 Association ClassBasedAssociation SimpleAssociation
----

=== Class Based Association
A Class Based Association is a that type of association where a
distinct class is used to implement the relationship.

Domain \{I,R31}::
    The name of the domain to which the class based association belongs.
[horizontal]
    Data Type::: Refers to Association.Domain
Name \{I,R31}::
    The name of the class based association.
[horizontal]
    Data Type::: Refers to Association.Name.
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ClassBasedAssociation {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R31 Association -link Domain -link Name
}
----

=== Simple Association
A Simple Association is a that type of association where the relationship
is implemented using attributes in one of the participating classes.

Domain \{I,R31}::
    The name of the domain to which the simple association belongs.
[horizontal]
    Data Type::: Refers to Association.Domain
Name \{I,R31}::
    The name of the simple association.
[horizontal]
    Data Type::: Refers to Association.Name.
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class SimpleAssociation {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R31 Association -link Domain -link Name
}
----

=== R43
* *Generalization* is a *Reference Generalization* or *Union Generalization*

The `micca` platform supports two different techniques to hold
generalization relationship information.
One technique is to use pointer values in a way similar to association
relationships.
The other techique is to use a discriminated union to hold the subclass
instance as part of the superclass instance.

[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R43 Generalization ReferenceGeneralization UnionGeneralization
----

=== Reference Generalization

A Reference Generalization is that type of generalization where
pointer references are used to implement the relationship.

Domain \{I,R43}::
    The name of the domain to which the reference generalization belongs.
[horizontal]
    Data Type::: Refers to Generalization.Domain
Name \{I,R43}::
    The name of the reference generalization association.
[horizontal]
    Data Type::: Refers to Generalization.Name.
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ReferenceGeneralization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R43 Generalization -link Domain -link Name
}
----

=== Union Association

A Union Generalization is that type of generalization where the subclass
is held as a discriminated union within the superclass instance.
Because of the properties of a generalization relationship,
a superclass is never related to more than one of its subclasses
and so a union of all the subclass structures may be used directly
as the subclass instance storage.

Domain \{I,R43}::
    The name of the domain to which the union generalization belongs.
[horizontal]
    Data Type::: Refers to Generalization.Domain
Name \{I,R43}::
    The name of the union generalization.
[horizontal]
    Data Type::: Refers to Generalization.Name.
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class UnionGeneralization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R43 Generalization -link Domain -link Name
}
----

=== Simple Referring Class

In a Simple Association between two classes,
one class has the role of refering to the other class in the association.
That role is termed the Simple Referring Class.
This class is deemed to be the source of relationship navigation when
going in the forward direction.
From a relational point of view,
the Simple Referring Class is the class in the Simple Association
which contains referential attributes.

Domain \{I,R32,R40,R90}::
    The name of the domain to which the simple referring class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain,
    Class Role.Domain and Association Reference.Domain
Class \{I,R40,R90}::
    The name of the simple referring class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Association Reference.Domain
Relationship \{I,R32,R40,R90}::
    The name of the relationship in which the simple referring class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name,
    Class Role.Relationship and Association Reference.Relationship
Role \{I,R40}::
    The role the simple referring class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class SimpleReferringClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R32 SimpleAssociation -link Domain -link {Relationship Name}
    reference R40 ClassRole\
        -link Domain -link Class -link Relationship -link Role
    reference R90 AssociationReference -link Domain -link Class\
            -link {Relationship Name}
}
----

=== R32

* *Simple Referring Class* is the referring member of
_exactly one_ *Simple Association*
* *Simple Association* has a referring member of
_exactly one_ *Simple Referring Class*

A *Simple Association* is one where referential attributes are
placed in one of participating class.
That class then serves the role of a *Simple Referring Class*.
Each *Simple Association* must have a class that acts as
a *Simple Referring Class* and a class can only be a *Simple Referring Class*
within the context of one *Simple Association* relationship.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R32 SimpleReferringClass 1--1 SimpleAssociation
----

=== Simple Referenced Class

In a Simple Association between two classes,
one class has the role of being referenced by the other class in the
association.
That role is termed the Simple Referenced Class.
This class is deemed to be the target of relationship navigation when
going in the forward direction.
From a relational point of view,
the Simple Referenced Class is the class in the Simple Association
which contains identifying attributes referenced by the Simple Referring Class.

Domain \{I,R33,R38}::
    The name of the domain to which the simple referenced class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Back Referring Class.Domain.
Class \{I,R38}::
    The name of the simple referenced class.
[horizontal]
    Data Type::: Refers to Back Referring Class.Class
Relationship \{I,R33,R38}::
    The name of the relationship in which the simple referenced class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Back Referring Class.Relationship
Role \{I,R38}::
    The role the simple referenced class plays in the relationship.
[horizontal]
    Data Type::: Refers to Back Referring Class.Role

Note that there are no Conditionality and Multiplicity attributes.
A Simple Referenced Class is always referred to by at exactly one
Simple Referring Class.
Simple Associations exhibit this property and all other
associations are Class Based Associations where the conditionality
of the association is based on whether there are instances of the
Associator Class.

[source,tcl]
.Implementation
----
<<micca configuration>>=
class SimpleReferencedClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R33 SimpleAssociation -link Domain -link {Relationship Name}
    reference R38 DestinationClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R33

* *Simple Referenced Class* is the referenced member of
_exactly one_ *Simple Association*
* *Simple Association* has a referenced member of
_exactly one_ *Simple Referenced Class*

A *Simple Association* is one where referential attributes are
placed in one of participating class that refer to the identifying
attributes of the other class.
The class containing the referenced identifying attributes serves
the role of a *Simple Referenced Class*.
Each *Simple Association* must have a class that acts as
a *Simple Referenced Class* and a class can only be a *Simple Referenced Class*
within the context of one *Simple Association* relationship.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R33 SimpleReferencedClass 1--1 SimpleAssociation
----

=== Source Class

For a Class Based Association,
the Source Class is the starting class from which the association can be
traversed in the forward direction.

Domain \{I,R34,R38}::
    The name of the domain to which the source class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Back Referring Class.Domain.
Class \{I,R38}::
    The name of the source class.
[horizontal]
    Data Type::: Refers to Back Referring Class.Class
Relationship \{I,R34,R38}::
    The name of the relationship in which the source class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Back Referring Class.Relationship
Role \{I,R38}::
    The role the source class plays in the relationship.
[horizontal]
    Data Type::: Refers to Back Referring Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean


[source,tcl]
.Implementation
----
<<micca configuration>>=
class SourceClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R34 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R40 ClassRole\
        -link Domain -link Class -link Relationship -link Role
    reference R95 ForwardReference -link Domain -link Class -link Relationship\
        -refid 2
}
----

=== R34

* *Source Class* is the source member for _exactly one_ *Class Based Association*
* *Class Based Association* has a source member of _exactly one_ *Source Class*

Each Class Based Association designates one of the participant classes
to serve the role as the source of traversal.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R34 SourceClass 1--1 ClassBasedAssociation
----

=== Target Class

For a Class Based Association,
the Target Class is that class where, when the association is traversed
in the forward direction starting at the Source Class, the instances
related by the association are found.
Alternatively, the Target Class can serve as the start of a traversal
of the association in the reverse direction.

Domain \{I,R35,R38}::
    The name of the domain to which the target class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Back Referring Class.Domain.
Class \{I,R38}::
    The name of the target class.
[horizontal]
    Data Type::: Refers to Back Referring Class.Class
Relationship \{I,R35,R38}::
    The name of the relationship in which the target class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Back Referring Class.Relationship
Role \{I,R38}::
    The role the target class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class TargetClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R35 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R38 DestinationClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R35

* *Target Class* is the target member for _exactly one_ *Class Based Association*
* *Class Based Association* has a target member of _exactly one_ *Target Class*

Each Class Based Association designates one of the participant classes
to serve the role as the target of traversal.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R35 TargetClass 1--1 ClassBasedAssociation
----

=== Associator Class

For a Class Based Association,
the Associator Class is that class which holds references to the
participating classes.
Each instance of an Associator Class represents an instance of the
association between the participants.

Domain \{I,R42,R40,R93}::
    The name of the domain to which the associator class belongs.
[horizontal]
    Data Type::: Refers to Class Based Association.Domain,
    Class Role.Domain and Associator Reference.Domain.
Class \{I,R40,R93}::
    The name of the associator class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Associator Reference.Domain.
Relationship \{I,R42,R40,R93}::
    The name of the relationship in which the associator class
    participates.
[horizontal]
    Data Type::: Refers to Class Based Association.Name,
    Class Role.Relationship and Associator Reference.Name.
Role \{I,R40}::
    The role the associator class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class AssociatorClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Multiplicity boolean

    reference R42 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R93 AssociatorReference -link Domain -link Class\
        -link {Relationship Name}
}
----

=== R42

* *Associator Class* is the referring member of _exactly one_
*Class Based Association*
* *Class Based Association* has a referring member of _exactly one_
*Associator Class*

Class Based Associations must have a class that serves the role of
the associator and holds the references to the participating classes.
That role is served by exactly one class in the association.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R42 AssociatorClass 1--1 ClassBasedAssociation
----

=== R38

* *Back Referring Class* is a
*Simple Referenced Class*, *Source Class* or *Target Class*

All the class roles that are referenced by other classes in relationships
can be generalized to be a Back Referring Class.
The common characteristic of these classes is that they
may hold pointer references to other classes in the association
that are used to navigate the relationship in the reverse direction.

[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R38 DestinationClass\
    SimpleReferencedClass TargetClass
----

=== Destination Class

An Destination Class is that type of role in an association
where the class is the destination of navigating the relationship
in the forward direction.

Domain \{I,R40,R94}::
    The name of the domain to which the association participant class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Backward Referenced.Domain
Class \{I,R40,R94}::
    The name of the association participant class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Backward Referenced.Class
Relationship \{I,R40,R94}::
    The name of the relationship in which the association participant class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship and
    Backward Referenced.Relationship
Role \{I,R40}::
    The role the association participant class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class DestinationClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R94 BackwardReference -link Domain -link Class -link Relationship\
        -refid 2
}
----

=== Referenced Superclass

A Referenced Superclass is that role in a Reference Generalization
assumed by the superclass.

Domain \{I,R36,R46,R92}::
    The name of the domain to which the referenced superclass class belongs.
[horizontal]
    Data Type::: Refers to Superclass.Domain,
    Reference Generalization.Domain and
    Subclass Reference.Domain
Class \{I,R46,R92}::
    The name of the referenced superclass class.
[horizontal]
    Data Type::: Refers to Superclass.Domain and
    Subclass Reference.Class
Relationship \{I,R36,R46,R92}::
    The name of the relationship in which the referenced superclass class
    participates.
[horizontal]
    Data Type::: Refers to Superclass.Relationship,
    Reference Generalization.Name and
    Subclass Reference.Name
Role \{I,R46}::
    The role the referenced superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Superclass.Role


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ReferencedSuperclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R36 ReferenceGeneralization -link Domain -link {Relationship Name}
    reference R48 Superclass -link Domain -link Class\
            -link Relationship -link Role
    reference R92 SubclassReference -link Domain -link Class\
            -link {Relationship Name}
}
----

=== R36

* *Referenced Superclass* is the abstract member of _exactly one_
*Reference Generalization*
* *Reference Generalization* has an abstract member of _exactly one_
*Referenced Superclass*

Each generalization relationship has exactly one member that serves as
the abstract or superclass member.
We will also insist that superclass roles may not be played by any
of the participant subclasses in the generalization.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R36 ReferencedSuperclass 1--1 ReferenceGeneralization
----

=== Referring Subclass

For a Reference Generalization,
a Referring Subclass is that role played by a subclass.

Domain \{I,R37,R47}::
    The name of the domain to which the referring subclass class belongs.
[horizontal]
    Data Type::: Refers to Subclass.Domain and Reference Generalization.Domain
Class \{I,R47}::
    The name of the referring subclass class.
[horizontal]
    Data Type::: Refers to Subclass.Class
Relationship \{I,R37,R47}::
    The name of the relationship in which the referring subclass class
    participates.
[horizontal]
    Data Type::: Refers to Subclass.Relationship and
    Reference Generalization.Name
Role \{I,R47}::
    The role the referring subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Subclass.Role


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ReferringSubclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R37 ReferenceGeneralization -link Domain -link {Relationship Name}
    reference R47 Subclass -link Domain -link Class -link Relationship -link Role
}
----

=== R37

* *Referring Subclass* is a specific member of _exactly one_
*Reference Generalization*
* *Reference Generalization* has a specific member of _one or more_
*Referring Subclass*

Each generalization relationship has one or more participants that
are the specific members or subclasses of the generalization.
We will also insist that there are at least two subclass members
since partitioning a set into a single improper subset serves no
useful semantic reason.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R37 ReferringSubclass 1..*--1 ReferenceGeneralization
----

=== Union Superclass

For a Union Generalization,
the Union Superclass is that class that serves as a superclass in the
relationship.
This type of superclass will also be constructed so that the storage
for any related subclass will be a part of the memory allocated to the
superclass instance.
This provides a platform specific optimization of memory space for
simple generalizations.

Domain \{I,R40,R44,R96}::
    The name of the domain to which the union superclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain,
    Union Generalization.Domain and Subclass Container.Domain.
Class \{I,R40,R96}::
    The name of the union superclass class.
[horizontal]
    Data Type::: Refers to Class Role.Class and Subclass Container.Class.
Relationship \{I,R40,R44,R96}::
    The name of the relationship in which the union superclass class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship,
    Union Generalization.Name, and Subclass Container.Name.
Role \{I,R40}::
    The role the union superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role


[source,tcl]
.Implementation
----
<<micca configuration>>=
class UnionSuperclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R44 UnionGeneralization -link Domain -link {Relationship Name}
    reference R48 Superclass -link Domain -link Class\
            -link Relationship -link Role
    reference R96 SubclassContainer -link Domain -link Class\
        -link {Relationship Name}
}
----

=== R44

* *Union Superclass* is the abstract member of _exactly one_
*Union Generalization*
* *Union Generalization* has an abstract member of _exactly one_
*Union Superclass*

Each generalization relationship has exactly one member that serves as
the abstract or superclass member.
We will also insist that superclass roles may not be played by any
of the participant subclasses in the generalization.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R44 UnionSuperclass 1--1 UnionGeneralization
----

=== Union Subclass

For a Union Generalization,
a Union Subclass is that role played by a subclass in the generalization.

Domain \{I,R47,R45}::
    The name of the domain to which the union subclass class belongs.
[horizontal]
    Data Type::: Refers to Subclass.Domain and Union Generalization.Domain.
Class \{I,R47}::
    The name of the union subclass class.
[horizontal]
    Data Type::: Refers to Subclass.Domain.
Relationship \{I,R47,R45}::
    The name of the relationship in which the referring subclass class
    participates.
[horizontal]
    Data Type::: Refers to Subclass.Relationship and Union Generalization.Name.
Role \{I,R47}::
    The role the union subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Subclass.Role


[source,tcl]
.Implementation
----
<<micca configuration>>=
class UnionSubclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R47 Subclass -link Domain -link Class -link Relationship -link Role
    reference R45 UnionGeneralization -link Domain -link {Relationship Name}
}
----

=== R45

* *Union Subclass* is a specific member of _exactly one_
*Union Generalization*
* *Union Generalization* has a specific member of _one or more_
*Union Subclass*

Each generalization relationship has one or more participants that
are the specific members or subclasses of the generalization.
We will also insist that there are at least two subclass members
since partitioning a set into a single improper subset serves no
useful semantic reason.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R45 UnionSubclass 1..*--1 UnionGeneralization
----

=== Superclass

A Superclass is the specific member of a generalization relationship
and serves the role of a superclass.

Domain \{I,R40}::
    The name of the domain to which the superclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Class \{I,R40}::
    The name of the superclass class.
[horizontal]
    Data Type::: Refers to Class Role.Domain
Relationship \{I,R40}::
    The name of the relationship in which the superclass class participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship
Role \{I,R40}::
    The role the superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Superclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role

    instop findSubclasses {} {
        set refsubs [findRelated $self {~R48 ReferencedSuperclass} R36 ~R37 R47]
        set usubs [findRelated $self {~R48 UnionSuperclass} R44 ~R45 R47]
        return [refUnion $refsubs $usubs]
    }
}
----

=== R48

* *Superclass* is a *Referenced Superclass* or *Union Superclass*

The `micca` platform supports two different implementation means for
representing a superclass in a generalization relationship.
A generalization may be represented using pointer references or as
a union.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R48 Superclass ReferencedSuperclass UnionSuperclass
----

=== Subclass

A Subclass is the specific member of a generalization relationship
and serves the role of a subclass.

Domain \{I,R40,R91}::
    The name of the domain to which the subclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Superclass Reference.Domain
Class \{I,R40,R91}::
    The name of the subclass class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Superclass Reference.Class
Relationship \{I,R40,R91}::
    The name of the relationship in which the subclass class participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship
    and Superclass Reference.Name
Role \{I,R40,R91}::
    The role the subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Subclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R91 SuperclassReference -link Domain -link Class\
            -link {Relationship Name}
}
----

=== R47

* *Subclass* is a *Referring Subclass* or *Union Subclass*

The `micca` platform supports two different implementation means for
representing a subclass in a generalization relationship.
A generalization may be represented using pointer references or as
a discriminated union.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R47 Subclass ReferringSubclass UnionSubclass
----

=== Class Role

A Class Role is an abstraction of the various ways that classes may
participate in relationships.
The major concept in the relationship subsystem is to define the
various types of relationships and then abstract the way that classes
participate in the relationships and the roles they play in holding
referential attributes, etc.

Domain \{I,R41}::
    The name of the domain to which the class role class belongs.
[horizontal]
    Data Type::: Refers to Class.Domain and Relationships.Domain.
Class \{I,R41}::
    The name of the class role class.
[horizontal]
    Data Type::: Refers to Class.Name.
Relationship \{I,R41}::
    The name of the relationship in which the class role class participates.
[horizontal]
    Data Type::: Refers to Relationship.Name.
Role \{I,R40}::
    The role the class role class plays in the relationship.
    There are three roles available to a class.
    It may be a _source_, _target_ or _associator_.
    Note that the Role attribute is part of the identifier of the class.
    This accounts for reflexive associations where the same class
    will play two different roles in the association.
[horizontal]
    Data Type::: {source, target, associator}.


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ClassRole {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1 -check {$Role in {source target associator}}

    reference R41 Relationship -link Domain -link {Relationship Name}
    reference R41 Class -link Domain -link {Class Name}
}
----

=== R40

* *Class Role* is a *Simple Referring Class*, *Destination Class*,
*Source Class*, *Associator Class*, *Union Superclass*, or *Subclass*

Classes play various roles when that are involved in relationships.
This generalization abstracts the various ways that classes are involved
in relationships into a role.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R40 ClassRole SimpleReferringClass DestinationClass\
        SourceClass AssociatorClass Superclass Subclass
----

=== R41

* *Class Role* _is an instance of_ *Relationship* models the association
between _one or more_ *Class*
* *Class Role* _is an instance of_ *Class* participates in _zero or more_
*Relationship*

Classes may participate in relationships to model the real world
associations between the classes.
It is possible (but not usual) for a class not to participate in any
relationship.
Relationships alway involve the participation of one or more classes
(usually two or three).
Note that *Class Role* has an additional identifying attribute, *Role*,
so that *R41* is actually a many-to-many-to-many association.
This additional multiplicity is required since reflexive relationships
have the same class playing more than one role in the relationship.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R41 Relationship 0..*--1..* Class -associator ClassRole
----

== References Subsystem

=== Introduction

In the Relationship subsystem,
we saw how the platform models relationships and how classes play a
role in realizing the relationship.
In the References subsystem,
we map the roles a class plays in realizing a relationship to the
components that the class instances must store.
This mapping joins back with the Class Components seen in the
Classes subsystem

Below is the UML class diagram for the references subsystem of the platform
model.

image::platform-references.pdf[title="References Subsystem Class Diagram"]

=== R90

* *Simple Referring Class* holds references in _exactly one_
*Association Reference*
* *Association Reference* is a reference holder for _exactly one_
*Simple Referring Class*

When a class serves as an Simple Referring Class it may hold
pointer references to the other class in the association.
Association References hold the pointer information needed to
traverse the relationship in the forward direction.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R90 SimpleReferringClass 1--1 AssociationReference
----

=== R91

* *Subclass* references via _exactly one_ *Superclass Reference*
* *Superclass Reference* is a reference for _exactly one_ *Subclass*

A Subclass must always refer to its related Superclass
and it does so by having a Superclass Reference as one of its
components.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R91 Subclass 1--1 SuperclassReference
----

=== R94

* *Destination Class* holds references in _exactly one_
*Backward Reference*
* *Backward Reference* is a reference holder for _exactly one_
*Destination Class*

When a class serves as an Destination Class it holds
pointer references to the other class in the association.
These pointer references aid in navigating the relationship
in the reverse direction.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R94 DestinationClass 1--1 BackwardReference
----

=== R95

* *Source Class* holds references in _exactly one_
*Forward Reference*
* *Forward Reference* is a reference holder for _exactly one_
*Source Class*

When a class serves as an Source Class it holds
pointer references to the associator class in the class based association.
These pointer references aid in navigating the relationship
in the forward direction.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R95 SourceClass 1--1 ForwardReference
----

=== R92

* *Referenced Superclass* references subclasses via _at most one_
*Subclass Reference*
* *Subclass Reference* is the reference to a subclass for _exactly one_
*Referenced Superclass*

When a Referenced Superclass in a reference generalization stores its reference
to its currently related subclass in a *Subclass Reference*.
However, a Referenced Superclass may exist before its
related Subclass Reference is generated.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R92 ReferencedSuperclass 1--1 SubclassReference
----

=== R93

* *Associator Class* references participants via _exactly one_
*Associator Reference*
* *Associator Reference* is the reference for _exactly one_ *Associator Class*

An Associator Class must hold references to both participants of the
association and does so in an Associator Reference.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R93 AssociatorClass 1--1 AssociatorReference
----

=== R96

* *Union Superclass* stores subclass instances in _at most one_
*Subclass Container*
* *Subclass Container* is the storage for subclasses of _exactly one_
*Union Superclass*

The use of a union to store associated subclass instances
in a superclass instance memory structure eliminates the need for
various reference pointers.
The Union Superclass stores the currently related subclass instance
in the Subclass Container that can be used to disinguish the type of 
the related subclass.
However, a Union Superclass may exist before its
related Subclass Container is generated.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R96 UnionSuperclass 1--1 SubclassContainer
----

== State Model Subsystem

=== Introduction

The class, relationship and reference subsystems describe how model level
concepts of classes and relationships are mapped to implementation level
concepts of structures and pointers.
In the state model subsystem we turn our attention to the dynamics
and sequencing of execution of the model.

The classes in the state model subsystem capture the essential information
of a Moore type state model along with the XUML conventions of how
to specify ignored and error transitions.
The sequencing of execution via dispatch of state machine events is
handled by the run time mechanisms of `micca`.
The run time is completely data driven.
So our focus in the platform model is to capture that data needed to
generate the data structures used by the run time mechanisms.
The implications of this are that the state model subsystem is relatively
platform independent.
There are no particular ``C'' language implications of dispatching events
to state machines since the there is no particular ``C'' language
constructs specific to state machines.
The run time mechanisms must supply all the logic around event dispatch.
We will find it convenient to include some sequential numeric attributes
since the run time will use array data structures to access some types
of information and we would like a rather direct way of computing
appropriate array indices.

Below is the UML class diagram for the state model subsystem of the platform
model.

image::platform-statemodel.pdf[title="State Model Subsystem Class Diagram"]

A *State Model* is of one of two types (*R50*),
an *Instance State Model* or an *Assigner State Model*.
An *Instance State Model* is associated with a *Class* (*R51*) and an
*Assigner State Model* is associated with an *Association* relationship (*R52*).
Both types of state models operate the same.
They contain a set of *States* (*R55*) and possibly a *Creation State* (*R56*).
A *State Model* has a default *Transition Rule* (*R59*) to resolve
unspecified transitions and an initial state (*R58*) to know where things
start.
All the *States* and the *Creation State* constitute a *State Place* where
the state model can transition when it has an event dispatched to it (*R57*).
An *Assigner State Model* also consists of two types (*R53*),
*Single Assigner* and *Multiple Assigner*.
A *Single Assigner* has only a single instance while a
*Multiple Assigner* has a many instances as the *Class* that
partitions is behavior (*R54*).

=== State Model

A State Model is a finite automaton, specifically a Moore type state machine.
A State Model is used to define the sequencing of execution for the
lifecycle of its assocated class or assigner.
The State Model defines behavior that is common to all of the associated
instances or assigners and each class instance or assigner instance has its own
notion of its current state.

Domain \{I,R58}::
    The domain in which the state model resides.
[horizontal]
    Data Type::: Refers to State.Domain
Model \{I,R58}::
    The name of the class or association for which the state model operates.
[horizontal]
    Data Type::: Refers to State.Model
InitialState \{R58}::
    The name of the state into which the a newly create state model is placed
    by default.
[horizontal]
    Data Type::: Refers to State.Name
DefaultTrans \{R59}::
    The name of the default transition rule.
[horizontal]
    Data Type::: Refers to Transition Rule.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class StateModel {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute InitialState string
    attribute DefaultTrans string

    reference R58 State -link Domain -link Model -link {InitialState Name}
    reference R59 TransitionRule -link {DefaultTrans Name}
}
----

=== R58

* *State Model* is sync created in _exactly one_ *State*
* *State* is the sync creation place for _at most one_ *State Model*

When an entity that has an associated State Model is create synchronously,
it is placed in an initial state.
No state activity is run as part of the synchronous creation.
Not all States of a State Model serve the role of being the default
initial state.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R58 StateModel 0..1--1 State
----

=== R59

* *State Model* transitions by default via _exactly one_ *Transition Rule*
* *Transition Rule* is the default transition for _zero or more_ *State Model*

When specifying the state transitions for a state model,
not all transitions must be specified explicitly.
Those transition not explicitly specified are are give the value of
a Transition Rule.
Since there multiple Transition Rules, any given Transition Rule may not be
used as a default transition for a State Model.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R59 StateModel 0..*--1 TransitionRule
----

=== R50

* *State Model* is a *Instance State Model* or *Assigner State Model*

The execution rules of XUML allow the lifecycle of either a class or an
association to be described by a State Model.
These are the only two domain entities that exhibit lifecycle behavior.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R50 StateModel InstanceStateModel AssignerStateModel
----

=== Instance State Model

An Instance State Model is that type of state model associated with the
lifecycle of a class instance.

Domain \{I,R50,R51}::
    The domain in which the instance state model resides.
[horizontal]
    Data Type::: Refers to Class.Domain and State Model.Domain
Class \{I,R50,R51}::
    The name of the class for which the instance state model operates.
[horizontal]
    Data Type::: Refers to Class.Name and State Model.Model


[source,tcl]
.Implementation
----
<<micca configuration>>=
class InstanceStateModel {
    attribute Domain string -id 1
    attribute Class string -id 1

    reference R50 StateModel -link Domain -link {Class Model}
    reference R51 Class -link Domain -link {Class Name}
}
----

=== R51

* *Instance State Model* describes the lifecycle of _exactly one_ *Class*
* *Class* lifecycle is described by _at most one_ *Instance State Model*

An Instance State Model is the definition of the lifecycle behavior
for only one class but not all classes will exhibit lifecycle behavior and
so may not have an Instance State Model.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R51 InstanceStateModel 0..1--1 Class
----

=== Assigner State Model

An Assigner State Model is that type of state model associated with the
lifecycle of an association relationship.
Sometimes the semantics of the domain subject matter are such that
forming and breaking an association must be serialized.
The archetypical example is where the association is competitive
and parallel activity could create incorrect association linkages.

Domain \{I,R50,R52}::
    The domain in which the assigner state model resides.
[horizontal]
    Data Type::: Refers to Association.Domain and State Model.Domain
Association \{I,R50,R52}::
    The name of the association relationship for which the assigner state
    model operates.
[horizontal]
    Data Type::: Refers to Association.Name and State Model.Model


[source,tcl]
.Implementation
----
<<micca configuration>>=
class AssignerStateModel {
    attribute Domain string -id 1
    attribute Association string -id 1

    reference R50 StateModel -link Domain -link {Association Model}
    reference R52 Association -link Domain -link {Association Name}
}
----

=== R52

* *Assigner State Model* describes the lifecycle of _exactly one_ *Association*
* *Association* lifecycle is described by _at most one_ *Assigner State Model*

An Assigner State Model is the definition of the lifecycle behavior for only
one association relationship but not all associations will exhibit lifecycle
behavior and so may not have an Assigner State Model.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R52 AssignerStateModel 0..1--1 Association
----

=== State

A State is one of the components of a State Model.
States have a name that is disctinct among the other states of the State Model
and have an executable activity that is run by the system when the
state is entered upon a transition.

Domain \{I,R55,R57,R78}::
    The domain in which the state resides.
[horizontal]
    Data Type::: Refers to State Model.Domain, State Place.Domain
    and Parameter Signature .Domain
Model \{I,R55,R57}::
    The name of the state model to which the state belongs.
[horizontal]
    Data Type::: Refers to State Model.Model and State Place.Model
Name \{I,R57}::
    The name of the state.
[horizontal]
    Data Type::: c-identifier
Activity::
    The body of code that is executed when the state is entered.
[horizontal]
    Data Type::: string
IsFinal::
    Determines whether the class instance will be automatically deleted
    when the state activity is completed.
[horizontal]
    Data Type::: boolean
PSigID \{R78}::
    The identifier of the parameter signature for the state.
[horizontal]
    Data Type::: Refers to Parameter Signature.SigID


[source,tcl]
.Implementation
----
<<micca configuration>>=
class State {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Name string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Name]}
    attribute Activity string
    attribute File string
    attribute Line int
    attribute IsFinal boolean
    attribute PSigID string

    reference R55 StateModel -link Domain -link Model
    reference R57 StatePlace -link Domain -link Model -link Name
    reference R78 ParameterSignature -link Domain -link PSigID
}
----

=== R55

* *State* is an active element of _exactly one_ *State Model*
* *State Model* acts via _one or more_ *State*

A State is part of only a single State Model.
Sharing states between state models is not allowed.
Every State Model must have at least one state.
The notion of an empty state model does not carry any behavior which it
the purpose of a state model.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R55 State 1..*--1 StateModel
----

=== Creation State

When a entity that has an associated State Model is created
asynchonously by a creation event,
it is placed in a pseudo-initial state.
The creation event is then dispatched to the instance, causing a
transition to a real state and the consequent execution of the
destination state activity.
The Creation State is the state the instance resides in temporarily
until the creation event is dispatched.
It differs from an ordinary state in that it can have no activity
associated with it and can only have out-bound transitions
(_i.e._ you cannot transition into a Creation State).

Domain \{I,R56,R57}::
    The domain in which the creation state resides.
[horizontal]
    Data Type::: Refers to State Model.Domain and State Place.Domain
Model \{I,R56,R57}::
    The name of the state model to which the creation state belongs.
[horizontal]
    Data Type::: Refers to State Model.Model and State Place.Model
Name \{I,R57}::
    The name of the creation state.
    Since a State Model may have at most one Creation State (by R56)
    and since a Creation State does not result in creating any
    ``C'' language identifiers, we choose a distinctive name for
    the Creation State that is outside of the domain for ordination
    state names.
    It suffices to choose the literal string ``@''
    to distinguish the Creation State.
[horizontal]
    Data Type::: the literal string ``@''


[source,tcl]
.Implementation
----
<<micca configuration>>=
class CreationState {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Name string -id 1

    reference R56 StateModel -link Domain -link Model
    reference R57 StatePlace -link Domain -link Model -link Name
}
----

=== R56

A State Model may have at most one Creation State and that Creation State
is unique to a given State Model.
Not all State Models have creation events defined for them, _i.e._
not all Classes support asynchronous creation.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R56 CreationState 0..1--1 StateModel
----

=== State Place

A State Place is an abstract location from which an event transition may
occur.

Domain \{I,I2}::
    The domain in which the state place resides.
[horizontal]
    Data Type::: string
Model \{I,I2}::
    The name of the state model to which the state place belongs.
[horizontal]
    Data Type::: string
Name \{I}::
    The name of the state place.
[horizontal]
    Data Type::: Union of State.Name and Creation State.Name
Number \{I2}::
    A sequential number given to the state place to aid in the encoding
    of states required during code generation.
[horizontal]
    Data Type::: sequential numeric


[source,tcl]
.Implementation
----
<<micca configuration>>=
class StatePlace {
    attribute Domain string -id 1 -id 2
    attribute Model string -id 1 -id 2
    attribute Name string -id 1
    attribute Number int -id 2
}
----

=== R57

* *State Place* is a *State* or *Creation State*

State transitions can originate from either a State or a Creation State.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R57 StatePlace State CreationState
----

=== Transition Rule

The execution rules for XUML state models allow for two types of
transition specifications that do not actually cause a transition in
a state machine.
These rules simplify the specification of state models.
One transition rule states that an event is to be ignored in a state
and is named, ``IG''.
The other transition rule states that it is a logical impossiblity for
the event to be received in the state and is named, ``CH''
(for ``can't happen'').

Name \{I}::
    The name of the transition rule.
[horizontal]
    Data Type::: {IG, CH}
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class TransitionRule {
    attribute Name string -id 1 -check {$Name in {IG CH}}
}
----

The number of Transition Rule instances is well known and constant
so we will specify them here.

[source,tcl]
----
<<micca population>>=
class TransitionRule    {
    Name                } {
    IG
    CH
}
----

=== R53

* *Assigner State Model* is a *Single Assigner* or *Multiple Assigner*

When an association has an Assigner State Model,
it may exist as a singleton or it may have multple instances of the
assigner.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R53 AssignerStateModel SingleAssigner MultipleAssigner
----

=== Single Assigner

A Single Assigner is a type of Assigner State Model that is used
when a competitive association must be serialized through one
execution path.
This is the most frequent case.

Domain \{I,R53}::
    The domain in which the single assigner resides.
[horizontal]
    Data Type::: Refers to Assigner State Model.Domain
Association \{I,R53}::
    The name of the association relationship for which the single assigner
    operates.
[horizontal]
    Data Type::: Refers to Assigner State Model.Association
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class SingleAssigner {
    attribute Domain string -id 1
    attribute Association string -id 1

    reference R53 AssignerStateModel -link Domain -link Association
}
----

=== Multiple Assigner

A Multiple Assigner is a type of Assigner State Model that is used
when a competitive association is partitioned into distinct subsets
wherein the assignment of the association is made.

Domain \{I,R53,R54}::
    The domain in which the multiple assigner resides.
[horizontal]
    Data Type::: Refers to Assigner State Model.Domain
    and Class.Domain
Association \{I,R53}::
    The name of the association relationship for which the multiple assigner
    operates.
[horizontal]
    Data Type::: Refers to Assigner State Model.Association
Class \{R54}::
    The name of the class whose instances partition the multiple assigner.
[horizontal]
    Data Type::: Refers to Class.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class MultipleAssigner {
    attribute Domain string -id 1
    attribute Association string -id 1
    attribute Class string

    reference R53 AssignerStateModel -link Domain -link Association
    reference R54 Class -link Domain -link {Class Name}
    reference R104 ValueElement -link Domain -link {Association Name}
}
----

=== R54

* *Multiple Assigner* is partitioned by _exactly one_ *Class*
* *Class* partions instance of _zero or more_ *Multple Assigner*

A Multiple Assigner operates on association instances that are divided
into sets associated with the instance of some Class.
Not all Classes partition Multiple Assigners.
The archetypical example of a Multiple Assigner is where a clerk
services customers but the clerk only services customers who are shopping
in the department where the clerk works.
In this case the department serves to partition the assignment of
clerks to customers to insure that assignments occur within the context
of the department in which the clerk works.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R54 MultipleAssigner 0..*--1 Class
----

== Event Subsystem

=== Introduction
The Event subsystem is concerned with classifying events that drive
state machine transitions.
The complexity here is that the execution rules for XUML allow for
one form of polymorphism, namely polymorphic events.

A polymorphic event can arise only in the context of a generalization
relationship.
Events can be designated as polymorphic and when such an event is
signaled to a superclass instance,
it is mapped at run time to an event in the subclass instance that
is currently related to superclass instance.
The net effect is to allow the subclasses of a generalization all to respond to
the same events and yet the events are signaled to the superclass instances of
the generalization.
This aleviates the burden on the signalling class to determine the
subclass instance to which the superclass instance is currently related.

Strictly speaking event polymorphism is an optimization performed by the run
time mechanisms since mapping an event to a subclass could be performed as part
of the state activity.
However, such code is repetitive and rather fragile in the wake of
adding or deleting subclasses in a generalization.
This is a case where the system can ``know'' the right thing to do
and remove a significant burden from the model level processing.

In its most common usage,
polymorphic events are quite straight forward.
Events are designated as polymorphic by the superclass and
they are used as transitioning events by the state models of the subclasses.
In its most general usage however,
we must account for both repeated generalization (_i.e._ where a subclass
serves as the superclass for a futher generalization) and
compound generalization (_i.e._ where a class is the superclass for
multiple generalization relationships).
The full set of rules and implications of polymorphic events can be rather
daunting.

* Associating polymorphic events with a superclass does _not_ imply
that the superclass has no state behavior of its own.
A superclass may have both a state model and polymorphic events since
generating a polymorphic event to a superclass does not result in any
behavior in the superclass.
* A given superclass may be the superclass of multiple generalizations.
In this case, generating an event to an instance of such a superclass
will cause an event to be generated to all generalizations for which
the class is a superclass.
In this way, signalling a single event may result in multiple events being
dispatched.
* The state model for a subclass may respond to
transitioning events that are not part of the polymorphic event set associated
with the generalization.
Such events may be signalled directly to instances of the subclass
or they may be signalled by a subclass instance itself.
* A class that is a subclass may also be a superclass of another generalization,
_i.e._ a subclass may be subject to repeated generalization.
Such a mid-level class may designate additional polymorphic events associated
with the generalization relationship for which it is the superclass.
Also a mid-level class may delegate polymorphic events associated with its
subclass role to any hierarchy for which it serves as a superclass.
* A mid-level class may have a state model that consumes an inherited
polymorphic event.
In that case,
the event is not inherited down any other generalization for which
the mid-level class is a superclass.
* All leaf classes, _i.e._ subclasses which are _not_
the superclass of another generalization,
must consume as transitioning events all polymorphic events delegated to them.
It is sufficient to ignore an event or deem an event as can't happen, but
polymorphic events are mapped ultimately to transitioning events when
the bottom of the generalization hierarchy is reached.

Note also that generalizations are _not_ subject to the so called
``diamond'' construct where a given class is a subclass of multiple
generalizations which themselves have a common superclass ancestor.
Blessedly,
referential integrity simply does not allow such a beast to be constructed.

These rules give rise to the following class model for state model events.

image::platform-event.pdf[title="Event Subsystem Class Diagram"]

An *Event* can be of two types (*R80*), either a *Deferred Event* or a
*Transitioning Event*.
A *Transitioning Event* actually causes state transition in a *State Model*
(*R87*).
A *Deferred Event* arises from a *Superclass* across a *Deferral Path* (*R86*).
Because of *R80*,
transitioning events and polymorphic events in a superclass must have different
names.
We do consider this an advantage in avoiding confusion between polymorphic
events and transitioning events in the superclass.
A *Transitioning Event* is either a *Local Event* or a *Mapped Event* (*R82*).
A *Local Event* is specified directly by a state model and a
*Mapped Event* is a deferred event as it is consumed in a state model (*R84*).
A *Deferred Event* is either a *Polymorphic Event* defined directly by
a superclass or is delegated as an *Inherited Event*
from another generalization for which the class was a subclass.
Both an *Inherited Event* or a *Mapped Event* are forms of
*NonLocal Event* (*R83*) and a *NonLocal Event* may only be defined
to act upon a *Subclass* (*R85*).

=== Event [[platform-event-class]]

An Event is a stimulus to a state model that has to potential to cause
a transition.

Domain \{I,R69}::
    The domain in which the event resides.
[horizontal]
    Data Type::: Refers to Parameter Signature.Domain
Model \{I}::
    The name of the state model to which the event belongs.
[horizontal]
    Data Type::: c-identifier
Event \{I}::
    The name of the event.
[horizontal]
    Data Type::: string
PSigID \{R69}::
    The identifier of the parameter signature for the event.
[horizontal]
    Data Type::: Refers to Argument Signature.SigID
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class Event {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute PSigID string
    attribute Number int

    reference R69 ParameterSignature -link Domain -link PSigID
}
----

=== R80

* *Event* is a *Deferred Event* or *Transitioning Event*

There are two types of events.
Those that cause an immediate effect on a state model are
*Transitioning Events*.
Those that are mapped at run time to an event in a subclass are
*Deferred Events*.
The execution rules do not allow for any other types of events.
Note that a creation event is just another form of *Transitioning Event*.
The only difference is that the run time mechanism creates the
class instance immediately before dispatching the creation event to it.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R80 Event DeferredEvent TransitioningEvent
----

=== Deferred Event

A Deferred Event is that type of event which is specified in a
Superclass but which is mapped to an event in a Subclass.

Domain \{I,I2,R80}::
    The domain in which the deferred event resides.
[horizontal]
    Data Type::: Refers to Event.Domain
Model \{I,I2,R80}::
    The name of the state model to which the deferred event belongs.
[horizontal]
    Data Type::: Refers to Event.Model
Event \{I,R80}::
    The name of the deferred event.
[horizontal]
    Data Type::: Refers to Event.Event
Number::
    A non-negative number assigned to event and used by the code generator.
[horizontal]
    Data Type::: zero based sequential numeric


[source,tcl]
.Implementation
----
<<micca configuration>>=
class DeferredEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R80 Event -link Domain -link Model -link Event
}
----

=== R81

* *Deferred Event* is a *Polymorphic Event* or *Inherited Event*

There are two source of events that are deferred.
Deferral happens in the sense that the events do not affect the behavior of the
superclass to which they are sent.
A superclass may declare an event as polymorphic or a
subclass of a generalization may choose to not act upon the event
if it is also the superclass of a different generalization.
In the later case,
the event not acted upon is inherited by the subclasses.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R81 DeferredEvent PolymorphicEvent InheritedEvent
----

=== Deferral Path

A Deferral Path is traversal along a generalization relationship
where an event is being deferred to a subclass of the generalization.

Domain \{I,R80}::
    The domain in which the deferral path resides.
[horizontal]
    Data Type::: Refers to Superclass.Domain and Deferred Event.Domain
Model \{I,R80}::
    The name of the state model to which the deferral path belongs.
[horizontal]
    Data Type::: Refers to Superclass.Class and Deferred Event.Model
Event \{I,R80}::
    The name of the event that is being deferred along the deferral path.
[horizontal]
    Data Type::: Refers to Deferred Event.Event
Relationship \{I,R86}::
    The generalization relationship along which the event is deferred.
[horizontal]
    Data Type::: Refers to Superclass.Relationship
Role \{I,R86}::
    The role of the superclass which is deferring an event.
[horizontal]
    Data Type::: Refers to Superclass.Role


[source,tcl]
.Implementation
----
<<micca configuration>>=
class DeferralPath {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R86 DeferredEvent -link Domain -link Model -link Event
    reference R86 Superclass -link Domain -link {Model Class}\
        -link Relationship -link Role
}
----

=== R86

* *Deferral Path* is an instance of
*Superclass* propagates _zero or more_ *Deferred Event*
* *Deferral Path* is an instance of
*Deferred Event* is propagated by _one or more_ *Superclass*

Event polymorphism allows an event in a Superclass to be deferred
to the subclasses.
Not all Superclasses define polymorphic events.
A given polymorphic event may be propagated along mulitple generalization
relationships in the case of a compound generalization,
_i.e._ a superclass that is the a superclass for multiple generalizations.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R86 Superclass 1..*--0..* DeferredEvent -associator DeferralPath
----

=== Transitioning Event

A Transitioning Event is that type of event that has the potential to
cause a state transition when dispatched to a state machine.

Domain \{I,R80,R87}::
    The domain in which the transitioning event resides.
[horizontal]
    Data Type::: Refers to Event.Domain and State Model.Domain
Model \{I,R80,R87}::
    The name of the state model to which the transitioning event belongs.
[horizontal]
    Data Type::: Refers to Event.Model and State Model.Model
Event \{I,R80}::
    The name of the transitioning event.
[horizontal]
    Data Type::: Refers to Event.Event
Number::
    A non-negative number assigned to event and used by the code generator.
[horizontal]
    Data Type::: zero based sequential numeric


[source,tcl]
.Implementation
----
<<micca configuration>>=
class TransitioningEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R80 Event -link Domain -link Model -link Event
    reference R87 StateModel -link Domain -link Model
}
----

=== R82

* *Transitioning Event* is a *Mapped Event* or *Local Event*

Events that can cause state transitions arise from two circumstances.
First, they may be locally defined.
This is usually the preponderance of events.
Second, the event could have been deferred from a superclass and
when it dispatched to a subclass is mapped into an event defined
for the subclass.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R82 TransitioningEvent MappedEvent LocalEvent
----

=== R87

* *Transitioning Event* causes transitions in _exactly one_ *State Model*
* *State Model* has transitions caused by _one or more_ *Transitioning Event*

Events that cause transition in a state model are defined to be specific
to that state model and all state models must respond to at least one event
by the definition of a state machine.
Of course, state models can, and usually do, respond to multiple events.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R87 TransitioningEvent 1..*--1 StateModel
----

=== Polymorphic Event

A polymorphic event is an event defined for the superclass of a generalization
that is to be mapped at run time to an event of one of the subclasses
of the generalization.
The run time mapping determines the subclass to which the superclass is
currently related and maps the event into one by the same name in the
subclass.

Domain \{I,R81}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Deferred Event.Domain
Model \{I,R81}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Deferred Event.Model
Event \{I,R81}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Deferred Event.Event


[source,tcl]
.Implementation
----
<<micca configuration>>=
class PolymorphicEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R81 DeferredEvent -link Domain -link Model -link Event
}
----

=== Inherited Event

A polymorphic event defined for superclass becomes an inherited
event in the subclasses of the generalization if a subclass does not
act upon the polymorphic event.
This can occur when the subclass is part of a repeated generalization
where it serves the role of subclass in a generalization that defines
the polymorphic event and serves the role of superclass in another
generalization.
The event can be thought of as being inherited down the hierarchy formed
by the repeated generalizations.

Domain \{I,R81,R83}::
    The domain in which the inherited event resides.
[horizontal]
    Data Type::: Refers to Deferred Event.Domain and NonLocal Event.Domain
Model \{I,R81,R83}::
    The name of the state model to which the inherited event belongs.
[horizontal]
    Data Type::: Refers to Deferred Event.Model and NonLocal Event.Model
Event \{I,R81,R83}::
    The name of the inherited event.
[horizontal]
    Data Type::: Refers to Deferred Event.Event and NonLocal Event.Event
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class InheritedEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R81 DeferredEvent -link Domain -link Model -link Event
    reference R83 NonLocalEvent -link Domain -link Model -link Event
}
----

=== Mapped Event

When a deferred event is consumed by a subclass it becomes a
mapped event for the subclass state model.
This allows the subclass to define other events to which it may respond.

Domain \{I,R82,R83,R84}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Transitioning Event.Domain,
    NonLocal Event.Domain and Deferred Event.Domain
Model \{I,R82,R83}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Transitioning Event.Model and NonLocal Event.Model
Event \{I,R82,R83,R84}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event, NonLocal Event.Event
    and Deferred Event.Event
ParentModel \{R84}::
    The name of the state model from which the mapped event was deferred.
    Data Type::: Refers to Deferred Event.Model


[source,tcl]
.Implementation
----
<<micca configuration>>=
class MappedEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute ParentModel string

    reference R82 TransitioningEvent -link Domain -link Model -link Event
    reference R83 NonLocalEvent -link Domain -link Model -link Event
    reference R84 DeferredEvent -link Domain -link {ParentModel Model}\
        -link Event
}
----

=== R84

* *Mapped Event* is the realization of _exactly one_ *Deferred Event*
* *Deferred Event* is realized as _at most one_ *Mapped Event*

When a deferred event is consumed, it becomes a mapped event in the
subclass where it is acted upon.
A mapped event always starts out as one that is deferred from a superclass.
Not all deferred events are necessarily mapped.
It is possible to defer an event through muliple generalizations before it
is finally consumed and becomes a mapped event.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R84 MappedEvent 0..*--1 DeferredEvent
----

=== Local Event

A local event is an event defined by a class and directly acted upon by the
state model of the class.
This forms the vast majority of defined events and all the events for
classes that are not subclasses of a generalization.

Domain \{I,R82}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Transitioning Event.Domain
Model \{I,R82}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Transitioning Event.Model
Event \{I,R82}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event


[source,tcl]
.Implementation
----
<<micca configuration>>=
class LocalEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1

    reference R82 TransitioningEvent -link Domain -link Model -link Event
}
----

=== R83

* *NonLocal Event* is an *Inherited Event* or *Mapped Event*

Together, inherited and mapped events form a set of events that
do not originate from the immediate local state model definition.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R83 NonLocalEvent InheritedEvent MappedEvent
----

=== NonLocal Event

A non-local event is that type of event that arises from polymorphic
events that are mapped through a generalization hierarchy.

Domain \{I,R85}::
    The domain in which the polymorphic event resides.
[horizontal]
    Data Type::: Refers to Subclass.Domain
Model \{I,R85}::
    The name of the state model to which the polymorphic event belongs.
[horizontal]
    Data Type::: Refers to Subclass.Class
Event \{I}::
    The name of the polymorphic event.
[horizontal]
    Data Type::: string
Relationship \{R85}::
    The generalization relationship along which the non-local event is applied.
[horizontal]
    Data Type::: Refers to Subclass.Relationship
Role \{R85}::
    The role of the subclass to which the non-local event is applied.
[horizontal]
    Data Type::: Refers to Subclass.Role


[source,tcl]
.Implementation
----
<<micca configuration>>=
class NonLocalEvent {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute Event string -id 1
    attribute Relationship string
    attribute Role string

    reference R85 Subclass -link Domain -link {Model Class} -link Relationship\
        -link Role
}
----

=== R85

* *NonLocal Event* affects _exactly one_ *Subclass*
* *Subclass* is affected by _zero or more_ *NonLocal Event*

Regardless of the source of non-local events, they can only cause
transition in the state model of a subclass.
Classes that are not subclasses cannot respond to non-local events.
Some subclasses will not have state models or polymorphic events
defined in their superclass.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R85 NonLocalEvent 0..*--1 Subclass
----

== Transition Subsystem

=== Introduction

The transition subsystem is concerned with the dispatch of state model
events.
The type of dispatch supported by XUML is the same as for a Moore type
state machine,
_i.e._ for a given state an event causes a transition into a new state
(not necessarily distinct from the current state) and executes any activity
associated with the state.
In UML parlance, these are known as entry actions.
No other form of action dispatch is supported as it is not needed.

One other complexity of state activity dispatch is that event arguments.
Each state may define a signature of parameters that the state activity
expects.
It is a corollary of Moore state machines that any event that causes
a transition _into_ a state must carry arguments that match the
formal parameter signature of the state.

The diagram below shows the transition subsystem classes.

image::platform-transition.pdf[title="Transition Subsystem Class Diagram"]

All the *State Places* and *Transitioning Events* combine to form a
transition matrix (*R70*) the cells of which are represented by
*Transition Places*.
There are two types of transitions that can occur in an state model (*R71*).
A *State Transition* causes the state machine to enter a new state
of the state model (*R72*).
A *NonState Transition* does not cause a new state to be entered but
has the side effect of either ignoring the event or causing a system error
(*R73*).

When a state transition happens,
the arguments carried by the event are transferred to the state
activity according to the *Argument Signature* (*R74*).
An *Argument Signature* correponds to a set of positional parameters (*R75*)
which have a fixed position in the argument list and a defined data type.
Each *State* and *Event* may have an *Parameter Signature* (*R78* and *R69*)
A *Parameter Signature* gives names to the positional parameters.
The *Parameter Signature* for events causing a transition into a
state must match the underlying *Argument Signature* of the
*State Transition* (*R76*)
A *State* or *Event* may name its parameters in any way it wishes (*R79*)
but the names do not affect the underlying position or data type of
a *Argument Signature* (*R77*).
The only thing important about the arguments of a state activity are the
position and data type, as is required by ``C'' when invoking a function.
The parameter naming from the *State* and *Event* points of view need
not be the same.

=== Transition Place

The Cartesian product of the state of a state model and the events of
the model form a conceptual transition matrix.
A transition place models the individual cells of the conceptual transition
matrix.

Domain \{I,R70}::
    The domain in which the transition place resides.
[horizontal]
    Data Type::: Refers to State Place.Domain and Transitioning Event.Domain
Model \{I,R70}::
    The name of the state model to which the transition place belongs.
[horizontal]
    Data Type::: Refers to State Place.Model and Transitioning Event.Model
State \{I,R70}::
    The name of the state to which the transition place refers.
[horizontal]
    Data Type::: Refers to State Place.Name
Event \{I,R70}::
    The name of the event which will cause a transition out of the
    transition place.
[horizontal]
    Data Type::: Refers to Transitioning Event.Event


[source,tcl]
.Implementation
----
<<micca configuration>>=
class TransitionPlace {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1

    reference R70 StatePlace -link Domain -link Model -link {State Name}
    reference R70 TransitioningEvent -link Domain -link Model -link Event
}
----

=== R70

* *Transition Place* is an instance of *State Place* transitions according to
_zero or more_ *Transitioning Event*
* *Transition Place* is an instance of *Transitioning Event* drives transition
among _zero or more_ *State Place*

A state model operates by having a function that maps states and events
onto new states.
A Transition Place is one of the enumerations of that mapping function.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R70 StatePlace 0..*--0..* TransitioningEvent -associator TransitionPlace
----

=== R71

* *Transition Place* is a *State Transition* or *NonState Transition*

As a convenience to the analyst,
events can be ignored or cause a system error.
These rules simplify the state model and result in there being two
different types of transitions.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R71 TransitionPlace StateTransition NonStateTransition
----

=== State Transition

A State Transition is that type of Transition Place where the dispatch of
an event causes the state machine to enter a new state.

Domain \{I,R71,R72,R74}::
    The domain in which the state transition resides.
[horizontal]
    Data Type::: Refers to Transition Place.Domain, State.Domain
    and Argument Signature.Domain
Model \{I,R71,R72}::
    The name of the state model to which the state transition belongs.
[horizontal]
    Data Type::: Refers to Transition Place.Model and State.Model
State \{I,R71}::
    The name of the state that is the starting state for the state transition.
[horizontal]
    Data Type::: Refers to Transition Place.Name
Event \{I,R70}::
    The name of the event which will cause the state transition.
[horizontal]
    Data Type::: Refers to Transition Place.Event
NewState \{R72}::
    The name of the state to which state transition arrives.
[horizontal]
    Data Type::: Refers to State.Name
ASigID \{R74,C}::
    The identifier of the argument signature that will govern the
    transfer of values from the event arguments to the activity parameters.
    The value of `ASigID` is constrained by the constraints placed on
    `R74`.
[horizontal]
    Data Type::: Refers to Argument Signature.SigID


[source,tcl]
.Implementation
----
<<micca configuration>>=
class StateTransition {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1
    attribute NewState string
    attribute ASigID string

    reference R71 TransitionPlace -link Domain -link Model -link State\
        -link Event
    reference R72 State -link Domain -link Model -link {NewState Name}
    reference R74 ArgumentSignature -link Domain -link ASigID
}
----


=== R72

* *State Transition* is destined for _exactly one_ *State*
* *State* is the destination of _at most one_ *State Transition*

When an event is dispatched and it causes a transition,
a new state becomes the current state.
This must happen for every state transition.
Conversely, not all states are the destination of a transition.
Some state may only have outbound transitions.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R72 StateTransition 0..*--1 State
----

=== NonState Transition

A NonState Transition is that type of Transition Place where the dispatch of
an event does not cause a transition and the system takes a prescribed
action.

Domain \{I,R71}::
    The domain in which the non-state transition resides.
[horizontal]
    Data Type::: Refers to Transition Place.Domain
Model \{I,R71}::
    The name of the state model to which the non-state transition belongs.
[horizontal]
    Data Type::: Refers to Transition Place.Model
State \{I,R71}::
    The name of the state that is the starting state for the non-state
    transition.
[horizontal]
    Data Type::: Refers to Transition Place.Name
Event \{I,R71}::
    The name of the event which is received by the non-state transition.
[horizontal]
    Data Type::: Refers to Transition Place.Event
TransRule \{R73}::
    The system rule that is performed when the event is received in the state.
[horizontal]
    Data Type::: Refers to Transition Rule.Name
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class NonStateTransition {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute State string -id 1
    attribute Event string -id 1
    attribute TransRule string

    reference R71 TransitionPlace -link Domain -link Model -link State\
        -link Event
    reference R73 TransitionRule -link {TransRule Name}
}
----

=== R73

* *NonState Transition* has the effect of _exactly one _*Transition Rule*
* *Transition Rule* describes the effect for _zero or more _
*NonState Transition*

All transitions that do not result in a new state being entered must
take an action that is dictated by transitions rules that govern
non-state transitions.
Any given transition rule may not be applied to a non-state transition.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R73 NonStateTransition 0..*--1 TransitionRule
----

=== Argument Signature

A State can define formal parameters for its activity.
The set of those parameters form a signature for the state.
Any event that causes a transition into a given state must carry
argument values that match the formal parameters of the state,
_i.e._ the event can be considered to have the same signature as the
state into which it causes a transition.

Domain \{I}::
    The domain in which the argument signature resides.
[horizontal]
    Data Type::: string
ASigID \{I}::
    The identifier of the argument signature.
    Argument signatures are identified uniquely within a given domain.
    This choice of identification is somewhat arbitrary and this particular
    choice is an attempt to keep the signature information localized to
    a particular domain.
[horizontal]
    Data Type::: arbitrary identfier


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ArgumentSignature {
    attribute Domain string -id 1
    attribute ASigID string -id 1
}
----

=== R74

* *State Transition* transfers argument values by _at most one_
*Argument Signature*
* *Argument Signature* defines argument transfer for _one or more_
*State Transition*

The parameters of the state activity constitute its signature.
A state may have no signature if it has no parameters.
Within a given model,
several states may have the same signature.
This allows an event to have the same signature but cause a transition
to different states.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R74 StateTransition 0..*--0..1 ArgumentSignature
----

*R74* is _not_ an independent relationship.
It is constrained by the requirement that the Argument Signature associated
with both the new state of a transition and the event that causes
a transition must be the same.
We insist that:

* R74 = R72 + R78 + R76
* R74 = R71 + R70 + R80 + R69 + R76

In other words,
both the Argument Signatures of the New State of a State Transition and
that of the Event that causes the transiton must be the same.
To enforce that constraint,
we write a TclRAL procedural constraint on the State Transition
class.

Matching argument signatures for a state transition is one of the more
complicated aspects of the platform model.
We define the procedural constraint below that will insure that the
two constaints are enforced.
We must also print any error messages as part of the procedural constraint,
because after the constraint fails, the configuration classes (relvars)
will have been rolled back to their previous values.

Procedural constraints are not directly supported by `rosea`,
so we have to fall back to TclRAL commands to implement it.
The strategy is to compute the argument signatures for the
event causing the transition and the new state of the transition
and then compare that result with the argument signature of the
state transition.
If there is a mismatch,
then we determine which transitions are causing the problem.

There are two complications in the enforcing this constraint.
First, we are interested in the Argument Signatures of the state and
event and _not_ the Parameter Signatures.
In other words, we only care about the positions and data types of
the parameters and _not_ the names given to them from the points of view
of the event and state.
Second, we have to deal with the fact that *R78* and *R69* are conditional,
_i.e._ a State or Event may not have any parameters at all.
This means that we cannot simply join across those relationships because
we will miss the case where a State or Event does not have a Parameter
Signature (since those tuples would not show up in the join).
Here we will have to rely on the `rvajoin` to insure all the cases are
considered.

The strategy for the query is to compute a relation value that
has the Argument Signature ID for the State Transition, Event and State.
Then we can find tuples where there is a mismatch.

[source,tcl]
----
<<micca constraints>>=
relvar procedural R74C StateTransition {
    set found 0

    set viaStateTrans [ralutil pipe {
        ral relation eliminate $::micca::StateTransition State |
        ral relation rename ~ NewState State
    }] ; # <1>
    # puts [ral relformat $viaStateTrans viaStateTrans]

    set viaState [ralutil pipe {
        ral relation semijoin\
            $::micca::StateTransition $::micca::State\
                -using {Domain Domain Model Model NewState Name} |
        ralutil rvajoin ~ $::micca::ParameterSignature ASigIDs |
        ral relation extend ~ stup StateASigID string {
            [ral tuple extract $stup PSigID] eq {} ? {} :\
                [ral tuple extract [ral relation tuple\
                [ral tuple extract $stup ASigIDs]] ASigID]} |
        ral relation eliminate ~ Activity IsFinal PSigID ASigIDs |
        ral relation rename ~ Name State
    }] ; # <2>
    # puts [ral relformat $viaState viaState]
    set viaEvent [pipe {
        ral relation semijoin\
            $::micca::StateTransition $::micca::TransitionPlace\
            $::micca::TransitioningEvent $::micca::Event |
        ralutil rvajoin ~ $::micca::ParameterSignature ASigIDs |
        ral relation extend ~ stup EventASigID string {
            [ral tuple extract $stup PSigID] eq {} ? {} :\
                [ral tuple extract [ral relation tuple\
                [ral tuple extract $stup ASigIDs]] ASigID]} |
        ral relation eliminate ~ PSigID ASigIDs
    }] ; # <3>
    # puts [ral relformat $viaEvent viaEvent]

    set sigs [ral relation join $viaStateTrans $viaState $viaEvent] ; # <4>

    set badstates [ral relation restrict $sigs stup {
            [ral tuple extract $stup ASigID] ne\
            [ral tuple extract $stup StateASigID]}] ; # <5>
    # puts [ral relformat $badstates badstates]

    ral relation foreach badstate $badstates {
        incr found
        ral relation assign $badstate {Domain domain} {Model model} {Event event}\
            {State state}
        puts stderr "in domain, \"$domain\", state model for, \"$model\",\
            event, \"$event\", causes a transition to state, \"$state\",\
            but the state and event argument signatures do not match"
    }

    set badevts [ral relation restrict $sigs stup {
            [ral tuple extract $stup ASigID] ne\
            [ral tuple extract $stup EventASigID]}] ; # <6>
    # puts [ral relformat $badevts badevts]

    ral relation foreach badevt $badevts {
        incr found
        ral relation assign $badevt {Domain domain} {Model model} {Event event}\
            {State state}
        puts stderr "in domain, \"$domain\", state model for, \"$model\",\
            event, \"$event\", causes a transition to state, \"$state\",\
            but the event and state argument signatures do not match"
    }

    return [expr {$found == 0}]
}
----
<1> It is the signature of the state into which the transition
is made (_i.e._ the NewState) that we are concerned with.
<2> The use of `rvajoin` insures that we have an attribute that will record
whether or not there is any related Parameter Signature.
The `ASigIDs` attribute will be an empty relation if there is no
related Parameter Signature and a singular relation if there is.
The logic of the `relation extend` propagates the ASigID as its own
attribute.
<3> This is the same patter as for the States only now we follow
the Transitioning Event path around to the Parameter Signature.
<4> Now we can compute the relation value that compares the Argument
Signature IDs across the three paths.
<5> Compare the Argument Signature ID from the State Transition to that
of the State.
<6> Now compare against the path using the Event.

=== Parameter Signature

An state activity may require a set of parameters when it is invoked.
Those parameters may have arbitrary names, but for the implementation
to operate correctly,
the order of a parameter and its data type, not its name, govern
whether or not a set of event arguments matches a set of state activity
parameters.
A Parameter Signature is a way for states and events to name
parameters as they wish, but still have a way to determine if the
arguments match the formal parameters.

Domain \{I,R76}::
    The domain in which the argument signature resides.
[horizontal]
    Data Type::: Refers to Argument Signature.Domain
PSigID \{I}::
    The identifier of the parameter signature.
    Parameter signatures are identified uniquely within a given domain.
    This choice of identification is somewhat arbitrary and this particular
    choice is an attempt to keep the signature information localized to
    a particular domain.
[horizontal]
    Data Type::: arbitrary identfier
ASigID \{I,R76}::
    The identifier of the argument signature for the parameter signature.
[horizontal]
    Data Type::: Refers to Argument Signature.ASigID


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ParameterSignature {
    attribute Domain string -id 1
    attribute PSigID string -id 1
    attribute ASigID string

    reference R76 ArgumentSignature -link Domain -link ASigID
}
----

=== R76

* *Parameter Signature* has values described by _exactly one_
*Argument Signature*
* *Argument Signature* describes the values for _one or more_
*Parameter Signature*

Every Parameter Signature must have an Argument Signature to describe
the position and data types of the parameters.
Argument Signatures do not exist unless they describe some set of parameters.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R76 ParameterSignature 1..*--1 ArgumentSignature
----

=== R78

* *State* has its activity interface defined by _at most one_
*Parameter Signature*
* *Parameter Signature* defines the activity interface for _zero or more_
*State*

A State may not have a Parameter Signature if it does not require
any parameters for its state activity.
A Parameter Signature may not describe the parameters of any state,
_i.e._ it may describe the parameters of an Event.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R78 State 0..*--0..1 ParameterSignature
----

=== R69

* *Event* has its data interface defined by _at most one_
*Parameter Signature*
* *Parameter Signature* defines the data interface for _zero or more_
*Event*

An Event may not have a Parameter Signature if it does not carry any
event arguments.
A Parameter Signature may not describe the parameters of any event,
_i.e._ it may describe the parameters of an State.

Note that R69 and R78 technically allow a Parameter Signature to
exist that is not associated with any State or Event.
We will not create such a situation in the `micca` configuration DSL code
and no real harm would come if we did.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R69 Event 0..*--0..1 ParameterSignature
----

=== Argument

An Argument is a specific data value of a given type in a fixed location
in a set of arguments.

Domain \{I,R75}::
    The domain in which the argument resides.
[horizontal]
    Data Type::: Refers to Argument Signature.Domain
ASigID \{I,R75}::
    The argument signature ID for the argument.
[horizontal]
    Data Type::: Refers to Argument Signature.SigID
Position \{I}::
    An ordinal number given to the argument to indicate its order in
    a set of arguments.
    In ``C'' arguments to functions are passed by position and we need to
    be able to create argument lists properly.
[horizontal]
    Data Type::: zero based sequential numeric
DataType::
    The data type of the activity argument.
[horizontal]
    Data Type::: c-typename


[source,tcl]
.Implementation
----
<<micca configuration>>=
class Argument {
    attribute Domain string -id 1
    attribute ASigID string -id 1
    attribute Position int -id 1
    attribute DataType string\
        -check {[::micca::@Config@::Helpers::typeCheck verifyTypeName $DataType]}

    reference R75 ArgumentSignature -link Domain -link ASigID
}
----

=== R75

* *Argument* is an argument of _exactly one_ *Argument Signature*
* *Argument Signature* has an argument of _one or more_ *Argument*

When a State is entered on a transition of a dispatched event,
its activity is executed.
The event causing the transition may carry argument values for the
state activity.
An Argument is a description of the arguments that
the state activity accepts.
An Argument is always part of a Argument Signature and does
not exist outside of the context of a single signature.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R75 Argument 1..*--1 ArgumentSignature
----

=== Parameter

A Parameter is a formal parameter to the activity of a state
or the data of an Event.
When the state activity is executed,
the transitioning event carrys the actual argument values for
each parameter.

Domain \{I,I2,R79,R77}::
    The domain in which the parameter resides.
[horizontal]
    Data Type::: Refers to Parameter Signature.Domain and
    Argument.Domain
PSigID \{I,I2,R79}::
    The parameter signature ID for the parameter.
[horizontal]
    Data Type::: Refers to Parameter Signature.PSigID
Name \{I}::
    The name of the parameter. This name may be used as a variable name
    in the code for the state activity.
[horizontal]
    Data Type::: c-identifier
Position \{I2,R77}::
    A ordinal number given to the argument to indicate its order in
    a set of arguments for an activity.
[horizontal]
    Data Type::: Refers to Argument.Position
ASigID \{R77,C}::
    The argument signature ID for the parameter.
    Note this attribute's value is further constrained to match
    the value of the ASigID of its Parameter Signature related across R79.
[horizontal]
    Data Type::: Refers Argument.ASigID.


[source,tcl]
.Implementation
----
<<micca configuration>>=
class Parameter {
    attribute Domain string -id 1 -id 2
    attribute PSigID string -id 1 -id 2
    attribute Name string -id 1
    attribute Position int -id 2
    attribute ASigID string

    reference R77 Argument -link Domain -link ASigID -link Position
    reference R79 ParameterSignature -link Domain -link PSigID
}
----

=== R77

* *Parameter* has its data type described by _exactly one_ *Argument*
* *Argument* describes the data type for _one or more_ *Parameter*

All parameters simply give a name to a particular position and data type
in a parameter set.
Arguments always describe a parameter's position and data type.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R77 Parameter 1..*--1 Argument
----

=== R79

* *Parameter* is part of _exactly one_ *Parameter Signature*
* *Parameter Signature* contains _one or more_ *Parameter*

Parameters always belong to some Parameter Signature and
there are no empty Parameter Signatures.

[source,tcl]
.Implementation
----
<<micca configuration>>=
association R79 Parameter 1..*--1 ParameterSignature
----

== Population Subsystem

=== Introduction
The Population subsystem is concerned with defining the
initial data values that class instances will have when the domain starts
running and to specifying the storage characteristics for classes.
In a `micca` generated system,
there is no dynamic memory allocation and all class storage is specified
at compile time.
Many domains have substantial initial instance populations and
`micca` provides a way to specify those populations.
When the code is generated,
inital instances become initializers in the array where a class is stored.
One goal of managing the initial instance population is to avoid
having to write executable code that creates the instances.
Such code is run only once,
and for platforms targeted by `micca`,
code space for code that is only run once needs to be minimized.
We can take advantage of initialized variables in ``C'' to have
data values placed in the proper variables when the system is started.

image::platform-population.pdf[title="Population Subsystem Class Diagram"]

A *Population* is a collection of initial data values for a *Domain* (*R100*).
Only certain *Value Element* components in a *Domain* can be supplied
with initial values.
A *Value Element* is one of two types (*R104*), either a *Class* or a
*Multiple Assigner*.
A *Population* must consist of an *Element Population* for each
*Value Element* (*R101*).
Reflecting the two different types of *Value Elements*,
there are two different types of *Element Populations* (*R105*).
A *Population* can have its *Associations* marked as static (*R109*),
in which case the code generator can make different choices for the
data structure used to store the reference pointers.
A *Class Population* contains *Class Instances* (*R102*) and an
*Assigner Population* contains *Multiple Assigner Instances* (*R107*).
A *Dynamic Class Population* parameterizes the amount of space allocated to
store instances.
A *Static Class Population* is where the number of instance is determined by
the initial instance population.
A *Static Class Population* also has the property that it can be
constant and placed in read only memory if it has no dynamic behavior at all.
A *Class Instance* defines values for *Class Components* (*R103*)
and this will include values for both attributes and references.
A *Multiple Assigner Instance* is always an instance for a *Multiple Assigner*
(*R106*).
A *Multiple Assigner Instance* is also always associated with the
*Class Instance* of the identifying class for the multiple assigner (*R108*).

=== Population

A Population is a set of instance values for a Domain.

Domain \{I,R100}::
    The domain for which the population defines values.
[horizontal]
    Data Type::: Refers to Domain.Name


[source,tcl]
.Implementation
----
<<micca configuration>>=
class Population {
    attribute Domain string -id 1

    reference R100 Domain -link {Domain Name}
}
----

=== R100

* *Population* supplies initial data values for _exactly one_ *Domain*
* *Domain* has initial data values specified by _at most one_ *Population*

A Population always applies to a single domain.
It is possible to define a Domain without giving a population.
This allows domain definitions to be reused with many different populations
for testing and deployment purposes.
However, code generation insists that there be a population for the domain.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R100 Population 0..1--1 Domain
----

=== Value Element

A Value Element is an entity in a domain that can be supplied population values.

Domain \{I}::
    The domain to which the value element belongs.
[horizontal]
    Data Type::: string
Name \{I}::
    The name of the value element.
[horizontal]
    Data Type::: c-identifier
 

[source,tcl]
.Implementation
----
<<micca configuration>>=
class ValueElement {
    attribute Domain string -id 1
    attribute Name string -id 1
}
----

=== R104

* *Value Element* is a *Class* or *Multiple Assigner*

There are two types of entities in a domain that can be supplied
inital values, namely a Class or a Multiple Assigner.
All other entities of a domain do not have any value semantics.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R104 ValueElement Class MultipleAssigner
----

=== Element Population

An Element Population defines the space allocated for storage of
the Value Elements in a Population.

Domain \{I,R101}::
    The domain to which the element population belongs
[horizontal]
    Data Type::: Refers to Population.Domain and Value Element.Domain
Element \{I,R101}::
    The name of the value element for which the element population defines
    an allocation.
[horizontal]
    Data Type::: Refers to Value Element.Name


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ElementPopulation {
    attribute Domain string -id 1
    attribute Element string -id 1

    reference R101 Population -link Domain
    reference R101 ValueElement -link Domain -link {Element Name}
}
----

=== R101

* *Element Population* is an instance of
*Population* supplies initial data values for _one or more_ *Value Element*
* *Element Population* is an instance of
*Value Element* has initial data value supplied in *Population*

A Population supples the values for Value Elements.
All Value Elements should be supplied population values.
A Value Element may exist independent of a Population so that a domain
may be defined separately from any population.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R101 Population 0..*--1..* ValueElement -associator ElementPopulation
----

=== R105

* *Element Popluation* is a *Class Population* or *Multiple Assigner Population*

There are two types of element populations that correspond to the
two types of Value Elements.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
generalization R105 ElementPopulation ClassPopulation AssignerPopulation
----

=== Class Population

A Class Population is a set of class instances.

Domain \{I,R105}::
    The domain to which the class population belongs.
[horizontal]
    Data Type::: Refers to Element Population.Domain
Class \{I,R102}::
    The name of the class to which the class population applies.
[horizontal]
    Data Type::: Refers to Element Population.Element
Allocation::
    The number instances of the class which is allocated beyond storage
    required for the instances specified by the population.
    The space for instance storage will consist of that specified in the
    initial instance population plus the value of the Allocation attribute.
    For classes where all instances are created at runtime,
    this attribute is set to the maximum number of the instances that can exist
    at the same time.
    For classes where all the instances are created at population time
    and no instances are created at run time,
    this attribute can be set to zero.
    For classes where some instances are specified at population time and
    others are created at run time,
    this attribute sets the initial space available for dynamic instance
    creation.
[horizontal]
    Data Type::: Non-negative numeric


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ClassPopulation {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Allocation int -check {$Allocation >= 0}

    reference R105 ElementPopulation -link Domain -link {Class Element}
}
----

=== Assigner Population

An Assigner Population is a set of multiple assigner instances.

Domain \{I,R105}::
    The domain to which the assigner population belongs.
[horizontal]
    Data Type::: Refers to Element Population.Domain
Association \{I,R102}::
    The name of the association to which the assigner population applies.
[horizontal]
    Data Type::: Refers to Element Population.Element


[source,tcl]
.Implementation
----
<<micca configuration>>=
class AssignerPopulation {
    attribute Domain string -id 1
    attribute Association string -id 1

    reference R105 ElementPopulation -link Domain -link {Association Element}
}
----

=== Class Instance

A Class Instance represents the set of values that are used to populate
the components of a particular instance of a class.

Domain \{I,R102}::
    The domain to which the class instance belongs
[horizontal]
    Data Type::: Refers to Class Population.Domain
Class \{I,R102}::
    The name of the class to which the class instance pertains.
[horizontal]
    Data Type::: Refers to Class Population.Class
Instance \{I}::
    The name of the class instance. Instances may be given arbitrary names
    and those names are used to refer to the instance when
    populating relationship references to the instance.
    We insist that instance names be valid ``C'' identifiers since
    they will show up in the generated header file as preprocessor
    defines.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    A number associated with the class instance. The number will be used
    as an array index into the storage array associated with the class.
[horizontal]
    Data Type::: zero based sequential number


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ClassInstance {
    attribute Domain string -id 1 -id 2
    attribute Class string -id 1 -id 2
    attribute Instance string -id 1\
        -check {[::micca::@Config@::Helpers::isIdentifier $Instance]}
    attribute Number int -id 2

    reference R102 ClassPopulation -link Domain -link Class
}
----

=== R102

* *Class Instance* is part of _exactly one_ *Class Population*
* *Class Population* contains _one or more_ *Class Instance*

Class instances are specific to a given population.
It is possible not to specify any initial instances for those classes
where all instances are created at run time.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R102 ClassInstance 0..*--1 ClassPopulation
----

=== Class Component Value

Domain \{I,R103}::
    The domain to which the class component value belongs.
[horizontal]
    Data Type::: Refers to Class Instance.Domain and Class Component.Domain
Class \{I,R103}::
    The name of the class to which the class component value pertains.
[horizontal]
    Data Type::: Refers to Class Instance.Class and Class Component.Class
Component \{I,R103}::
    The name of the class component to which the class component value applies.
[horizontal]
    Data Type::: Refers to Class Component.Name
Instance \{I,R103}::
    The name of the class instance to which the class component value pertains.
[horizontal]
    Data Type::: Refers to Class Instance.Instance
Value::
    The value to be given the the class component.
[horizontal]
    Data Type::: string


[source,tcl]
.Implementation
----
<<micca configuration>>=
class ClassComponentValue {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Component string -id 1
    attribute Instance string -id 1
    attribute Value string

    reference R103 ClassInstance -link Domain -link Class -link Instance
    reference R103 ClassComponent -link Domain -link Class -link {Component Name}
}
----

=== R103

* *Class Component Value* is an instance of
*Class Instance* describes the value of _one or more_ *Class Component*
* *Class Component Value* is an instance of
*Class Component* has its value describe by _zero or more_ *Class Instance*

A Class Instance gives the value of the Class Components.
All Class Components need to be given a value.
Class Components exist independent of any population value so that
they may be defined separately from a population.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R103 ClassInstance 0..*--1..* ClassComponent\
    -associator ClassComponentValue
----

=== Multiple Assigner Instance

A Multiple Assigner Instance represents an instanciation of a Multiple
Assigner.

Domain \{I,I2,R107,R106,R108}::
    The domain to which the multiple assigner instance belongs.
[horizontal]
    Data Type::: Refers to Assigner Population.Domain,
    Class Instance.Domain and Multiple Assigner.Domain
Association \{I,I2,R107,R106}::
    The name of the association to which the multiple assigner instance
    pertains.
[horizontal]
    Data Type::: Refers to Assigner Population.Association and
    Multiple Assigner.Association
Instance \{I}::
    The name of the multiple assigner instance.
[horizontal]
    Data Type::: string
Number \{I2}::
    A number associated with the multiple assigner instance.
    The number will be used as an array index into the storage array associated
    with the class.
[horizontal]
    Data Type::: zero based sequential number
IdClass \{R108,C}::
    The name of the class which identifies the multiple assigner instance.
    Note that this attribute is further constrained to match the
    value of Multiple Assigner.Class when traversed along the R106
    relationship.
[horizontal]
    Data Type::: Refers to Class Instance.Class
IdInstance \{R108}::
    The name of the class instance which identifies the multiple assigner
    instance.
[horizontal]
    Data Type::: Refers to Class Instance.Instance


[source,tcl]
.Implementation
----
<<micca configuration>>=
class MultipleAssignerInstance {
    attribute Domain string -id 1 -id 2
    attribute Association string -id 1 -id 2
    attribute Instance string -id 1
    attribute Number int -id 2
    attribute IdClass string
    attribute IdInstance string

    reference R107 AssignerPopulation -link Domain -link Association
    reference R106 MultipleAssigner -link Domain -link Association
    reference R108 ClassInstance -link Domain -link {IdClass Class}\
        -link {IdInstance Instance}
}
----

=== R106

* *Multiple Assigner Instance* is an instance of _exactly one_
*Multiple Assigner*
* *Multiple Assigner* is instanciated as _zero or more_
*Multiple Assigner Instance*

Each Multiple Assigner Instance must be associated to a particular
Multiple Assigner.
A Multiple Assigner may be defined separately from any population.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R106 MultipleAssignerInstance 0..*--1 MultipleAssigner
----

=== R107

* *Multiple Assigner Instance* is part of _exactly one_ *Assigner Population*
* *Assigner Population* contains _one or more_ *Multiple Assigner Instance*

Assigner instances are specific to a given population.
It is possible not to specify any initial instances for those assigners
where all instances are created at run time.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R107 MultipleAssignerInstance 0..*--1 AssignerPopulation
----

=== R108

* *Multiple Assigner Instance* is identified by _exactly one_ *Class Instance*
* *Class Instance* is the identifier for _zero or more_
*Multiple Assigner Instance*

A Multiple Assigner is always associated with a Class and so
the Multiple Assigner Instances must be associated with a Class Instance.
A Class Instance may be used to identify more that one Multiple Assigner
Instances if the Class is the identifying class for more that one
Multiple Assigner.
It is possible for a Class to not identify any Multiple Assigners.
 
[source,tcl]
.Implementation
----
<<micca configuration>>=
association R108 MultipleAssignerInstance 0..*--1 ClassInstance
----
