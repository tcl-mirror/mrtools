// vim:set syntax=asciidoc:
////
Template for classes.

=== Class 

Class description

Attribute Name::
    Attribute Description
[horizontal]
    Data Type::: Data type name

// repeated for each attribute

////

= The Micca Platform

[partintro]
--
In this part we present a class model of the platform specific model.
Populating this model is the primary focus of the micca domain specific
language.

Some readers will have studied platform independent models.
These are sometimes referred to as _meta-models_.
There is no single meta-model for XUML.
You can express the rules of executable modeling in a number of ways,
although the several meta-models that have been proposed have,
as would be expected,
many of the same constructs in them.
The model we present here is platform specific.
The platform we are targeting is single threaded with ``C'' as the
implementation language.
The platform also assumes that all data will be held in primary memory
and that all data storage is statically allocated.
Consequently,
some of the constructs in this model will be decidedly implementation
oriented.
It is, after all, meant to be specific to a particular computing technology.
A single threaded, ``C'' based implementation is *not* an appropriate
basis for all executable models.
It will, however, solve a large class of application types.
That is generally true of all translation technologies.
You must be specific about the chosen class of applications and then
choose appropriate computing technology that is applicable to that class
of applications.
There is no such thing as a universal software architecture any more than
there is a universal programming language.
All involve trade-offs of usually conflicting needs and requirements.

We divide the discussion up into several sections focused on
a particular subsystem of the platform model.
Intermixed with the platform model is the implementation of the model
in `rosea`.
--

== Domain Subsystem

=== Introduction

[[domain-platform-discussion]]
A *Domain* is identified by a *Name*.
A *Domain* consists of a set of *Domain Elements* (*R1*).
*Domain Elements* are of two types (*R2*),
*Class* and *Relationship*.
*R2* insures that no two elements have the same name and this makes sure that
there are no naming conflicts in the generated code.
For *Domain Element.*Name* attribute and many other names,
we will insist that names be able to be
used as ``C'' language identifiers, _i.e._ they must start with
a letter followed by an arbitrary number of letters, digits or underscore
characters.
The code generation process will use these names directly as this
eases the burden of finding model elements in the generated implementation.

A *Domain* may also define a set of *Domain Operation* (*R5*).
These operations constitute the invocable interface functions for the
*Domain*.
A *Domain* is otherwise encapsulated.
A *Domain Operation* may also have *Domain Operation Parameter* (*R6*)
associated with it.
It is also typical for a *Domain* to have a set of *Type Alias* (*R7*).
A *Type Alias* provides a convenient way to map model type names onto
``C'' implementation types.

A *Class* may also have a set of *Operation* (*R3*).
An *Operation* may also have a set of *Operation Parameter* (*R4*).

Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-domain.pdf[title="Domain Subsystem Class Diagram"]

=== Domain

A domain is a real or imagined world with its own set of rules.

Name \{I}::
    Each domain in a system must have a unique name.
[horizontal]
    Data Type::: string
Interface::
    A Domain will, in general, have dependencies on other aspects of the
    system. The Interface attribute is a string that will be inserted
    in the generated interface header file for the domain.
    Typically, the Interface will contain `#include` ``C'' preprocessor
    statements, but may contain any other compiler declarations
    needed.
[horizontal]
    Data Type::: string
Prologue::
    The Prologue for a Domain is inserted into the code file before any
    `micca` generated code.
    This gives the translation the opportunity to have external or forward
    references needed to satisfy the ``C'' compiler.
[horizontal]
    Data Type::: string
Epilogue::
    The Epilogue for a Domain is inserted into the code file after any
    `micca` generated code.
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Domain {
    attribute Name string -id 1
    attribute Interface string
    attribute Prologue string
    attribute Epilogue string
}
----

=== Domain Element

A domain element is one of the constituent parts of a domain.

Domain \{I,R1}::
    The name of the domain to which the element belongs.
[horizontal]
    Data Type::: references Domain.Name
Name \{I}::
    Each domain elements is given a name that is unique within the domain.
[horizontal]
    Data Type::: c-identifier

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainElement {
    attribute Domain string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}

    reference R1 Domain -link {Domain Name}
}
----

==== Checking for ``C'' Identifiers

Many names in the platform model will be directly used as an identifier in
the generated ``C'' code.
We insist they be of the correct form when the model is populated.
A simple regular expression will do the trick.

[source,tcl]
----
<<helper commands>>=
proc isIdentifier {name} {
    return [regexp {\A[[:alpha:]]\w*\Z} $name]
}
----

=== R1

* *Domain Element* is an entity of _exactly one_ *Domain*
* *Domain* models entities using _one or more_ *Domain Element*

We do not allow an empty domain.
Domains with no composing elements cannot model anything useful.
Each element of a domain belongs strictly to a single domain,
_i.e._ domain elements are never shared between domains.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R1 DomainElement 1..*--1 Domain
----

=== Class

A Class represents a logical predicate about some aspect of a Domain.

Domain \{I,R2,R104}::
    The name of the domain to which the class belongs.
[horizontal]
    Data Type::: References DomainElement.Domain

Name \{I,R2,R104}::
    Classes are identified by name within the domain to which they belong.
[horizontal]
    Data Type::: string

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Class {
    attribute Domain string -id 1
    attribute Name string -id 1 ; # <1>

    reference R2 DomainElement -link Domain -link Name
}
----
<1> The question arises whether we need to check if *Class.Name* is a
valid ``C'' identifier.
The answer is no.
Since *Class.Name* refers to *DomainElement.Name* unconditionally,
the check on *DomainElement.Name* insures that *Class.Name* is a valid
``C'' identifier.
Otherwise, we would fail the referential integrity check indicated by *R2*.

=== Relationship

A Relationship represents a real world association between class instances.

Domain \{I,R2}::
    The name of the domain to which the relationsihp belongs.
[horizontal]
    Data Type::: References DomainElement.Domain

Name \{I,R2}::
    Relationships are identified by name within the domain to which they belong.
    Traditionally, relationships are given names of the form, "R<digit>+", where
    <digit> is a decimal number.
    Although the convention is very commonly used in the executable modeling
    world, relationships may be given any desired name.
[horizontal]
    Data Type::: string

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Relationship {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R2 DomainElement -link Domain -link Name
}
----

=== R2

* *DomainElement* is a *Class* or *Relationship*

There are only two types of domain elements, Classes and Relationships.
These elements model the logical predicates of the domain subject matter.

[source,tcl]
----
<<platform relationships>>=
generalization R2 DomainElement Class Relationship
----

=== Domain Operation

A Domain Operation is a executable body of code that provides
a service access point into a domain.
The set of domain operations of a domain constitute the invocable programming
interface to the domain.

Domain \{I,R5}::
    The name of the domain to which the domain operation belongs.
[horizontal]
    Data Type::: refers to Domain.Name
Name \{I}::
    The name of the operation. Domain operations are given names that
    must be unique only within a given domain.
[horizontal]
    Data Type:::: c-identifier
Body::
    The code that is to be executed when the domain operation is invoked.
    This code is presumed to be ``C'' language statements and,
    except for some preprocessing of the statements,
    is passed along in the generated output file for the domain.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the domain operation.
[horizontal]
    Data Type:::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainOperation {
    attribute Domain string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Body string
    attribute ReturnDataType string

    reference R5 Domain -link {Domain Name}
}
----

=== R5

* *Domain Operation* is a service for _exactly one_ *Domain*
* *Domain* provides service via _zero or more_ *Domain Operation*

Domain operations only operate on a single domain.
However, a domain may not provide an explicit service entry points
and have no defined domain operations.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R5 DomainOperation 0..*--1 Domain
----

=== Domain Operation Parameter

A Domain Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R6}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to DomainOperation.Domain
Operation \{I,I2,R6}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to DomainOperation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list
    without reference to the parameter name.
[horizontal]
    Data Type::: numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainOperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string

    reference R6 DomainOperation -link Domain -link {Operation Name}
}
----

=== R6

* *Domain Operation Parameter* defines a formal parameter of _exactly one_
    *Domain Operation*
* *Domain Operation* has a formal parameter defined by _zero or more_
    *Domain Operation Parameter*

A domain operation parameter definition only applies to a single operation.
However, domain operations may have no parameters
as it is valid to have ``C'' functions with no parameters.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R6 DomainOperationParameter 0..*--1 DomainOperation
----

=== Operation

An *Operation* is a executable body of code that computes on a
class or class instance.

Domain \{I,R3}::
    The name of the domain to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Domain
Class \{I,R3}::
    The name of the class to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Name
Name \{I}::
    The name of the operation. Operations are given names that
    must be unique only within a given class.
[horizontal]
    Data Type:::: c-identifier
IsInstance::
    This attribute determine whether the operation applies to class instances.
    If true, then the generated code for the operation will have
    an implicitly declared parameter named `self`.
[horizontal]
    Data Type:::: boolean
Body::
    The code that is to be executed when the operation is invoked.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the operation.
[horizontal]
    Data Type:::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Operation {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute IsInstance boolean
    attribute Body string
    attribute ReturnDataType string

    reference R3 Class -link Domain -link {Class Name}
}
----

=== R3

* *Operation* operates over _exactly one_ *Class*
* *Class* is the domain for _zero or more_ *Operation*

Operations only operate on a single class.
However, a class may not provide any explicit operations.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R3 Operation 0..*--1 Class
----

=== Operation Parameter

An Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R4}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Domain
Class \{I,I2,R4}::
    The name of the class to which the parameter belongs.
[horizontal]
    Data Type::: refers to Operation.Class
Operation \{I,I2,R4}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list.
[horizontal]
    Data Type::: numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class OperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Class string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string

    reference R4 Operation -link Domain -link Class -link {Operation Name}
}
----

=== R4

* *Operation Parameter* defines a formal parameter of _exactly one_
    *Operation*
* *Operation* has a formal parameter defined by _zero or more_
    *Operation Parameter*

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R4 OperationParameter 0..*--1 Operation
----

== Classes Subsystem

The classes subsystem defines how model level ideas of a class will be
realized in `micca`.
We will simplify considerably the relational view of classes that
we find at the model level.
Because we are holding all data in memory and we are using
an implemenation language that exposes addresses,
there are number of transformations on classes available to us.

* Since the address in memory (_.i.e._ a pointer to an object) is unique
we can dispense with identifying attributes if they served no other role
in the model.
The object pointer can serve as an identifier and it has a number of
other implementation benefits such as directly accessing attribute values.
* Referential attributes will be replaced by pointer values.
Since referential attributes always refer to identifiers in the model,
then implementing relationships can be accomplished by storing
sets of pointers whose values refer to objects in memory.

Both of these considerations lead to the common decision in this type of
platform to map model level class definitions onto ``C'' structure definitions.
Storage for a class can then be allocated as an array of structures
that correspond to the class definition.


Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-classes.pdf[title="Classes Subsystem Class Diagram"]

=== Class Component

A Class Component is an element of the implementation class structure
and directly represents a member of the structure definition for the class
as it is used in the implementation.

Domain::
    The name of the domain to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Domain
Class::
    The name of the class to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Name
Name::
    The name of the component.
[horizontal]
    Data Type::: c-identifier
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassComponent {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R20 Class -link Domain -link {Class Name}
}
----

=== R21

* *ClassComponent* is an *Attribute*, *Reference*, *SubclassContainer*,
or *LinkContainer*

[source,tcl]
----
<<platform relationships>>=
generalization R21 ClassComponent Attribute Reference SubclassContainer LinkContainer
----

There are four types of components that compose a class.
An attribute corresponds to model level attributes that hold data that
parameterizes the class
(_i.e._ attributes whose roles are not strictly referential or identifying).
A reference is one or more pointers that are used to implement
model level relationships.
A subclass container can be used by a superclass to hold subclass elements
as a discriminated union.
This is one option for how generalization relationship information may be
stored.
A link container is a set of pointers used to implement a linked list.
This is one option for how relationship pointer information may be stored.
The link container is allocated in the space of the class that would be
chained together on a relationship.

=== Attribute

The Attribute class represent an attribute in a class.

Domain::
    The name of the domain to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class::
    The name of the class to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name::
    The name of the attribute.
[horizontal]
    Data Type::: Refers to Class Component.Name
DataType::
    The data type of the parameters.
[horizontal]
    Data Type::: c-typename
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Attribute {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute DataType string

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== Reference

A reference is one or more pointer values that are used to implement
the storage for a relationship.

Domain::
    The name of the domain to which the reference belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class::
    The name of the class to which the reference belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name::
    The name of the reference.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Reference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== Subclass Container

One option for storing generalization relationship information is
as a discriminated union.
The idea is that subclass storage is accomplished by creating a union
of all the subclasses in the generalization and also keep a separate
structure member to keep track of to which subclass the superclass is
currently related.
When this type of storage for a generalization relationship is chosen,
then the super class will have a subclass container as part of its
structure definition.

Domain::
    The name of the domain to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class::
    The name of the class to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name::
    The name of the subclass container.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SubclassContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----
