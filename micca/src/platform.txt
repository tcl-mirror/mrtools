// vim:set syntax=asciidoc:
////
Template for classes.

=== Class 

Class description

Attribute Name::
    Attribute Description
[horizontal]
    Data Type::: Data type name

// repeated for each attribute

////

// Some attributes

:mult-attribute: This attribute records whether the reference by the class can be multiple.  Muliple associations may refer to more than one associated instances.  Singular association may refer to only one associated instance.

:cond-attribute: This attribute records whether the reference by the class is conditional. Conditional associations allow for there to be zero instances referred to. Unconditional associations insist that there must be at some instance referred to.


= The Micca Platform

[partintro]
--
In this part we present a class model of the platform specific model.
Some readers will have studied platform independent models.
These are sometimes referred to as _meta-models_.
There is no single meta-model for XUML.
You can express the rules of executable modeling in a number of ways,
although the several meta-models that have been proposed have,
as would be expected,
many of the same constructs in them.
The model we present here is platform specific.
The platform we are targeting is single threaded with ``C'' as the
implementation language.
The platform also assumes that all data will be held in primary memory
and that all data storage is statically allocated.
Consequently,
some of the constructs in this model will be decidedly implementation
oriented.
It is, after all, meant to be specific to a particular computing technology.
A single threaded, ``C'' based implementation is *not* an appropriate
basis for all executable models.
It will, however, solve a large class of application types.
That is generally true of all translation technologies.
You must be specific about the chosen class of applications and then
choose appropriate computing technology that is applicable to that class
of applications.
There is no such thing as a universal software architecture any more than
there is a universal programming language.
All involve trade-offs of usually conflicting needs and requirements.

The role of the platform model is central to the overall translation
scheme.
Populating this model is the primary focus of the `micca` domain specific
language.
The code generation phase of the translation will query the populated
platform model to produce ``C'' language output to implement the
intent of the model.

Consequently,
we devote considerable effort to describing the platform model.
We divide the discussion up into several sections focused on
a particular subsystem of the platform model.
The platform model itself will be implemented as a `rosea` domain.
Intermixed with the platform model description is the implementation of the
model in `rosea`.
--

== Domain Subsystem

=== Introduction

Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-domain.pdf[title="Domain Subsystem Class Diagram"]

[[domain-subsystem-discussion]]
A *Domain* is identified by a *Name*.
A *Domain* consists of a set of *Domain Elements* (*R1*).
*Domain Elements* are of two types (*R2*),
*Class* and *Relationship*.
*R2* insures that no two elements have the same name and this makes sure that
there are no naming conflicts in the generated code.
For *Domain Element.*Name* attribute and many other names,
we will insist that names be able to be
used as ``C'' language identifiers, _i.e._ they must start with
a letter followed by an arbitrary number of letters, digits or underscore
characters.
The code generation process will use these names directly as this
eases the burden of finding model elements in the generated implementation.

A *Domain* may also define a set of *Domain Operation* (*R5*).
These operations constitute the invocable interface functions for the
*Domain*.
A *Domain* is otherwise encapsulated.
A *Domain Operation* may also have *Domain Operation Parameter* (*R6*)
associated with it.
It is also typical for a *Domain* to have a set of *Type Alias* (*R7*).
A *Type Alias* provides a convenient way to map model type names onto
``C'' implementation types.

A *Class* may also have a set of *Operation* (*R3*).
An *Operation* may also have a set of *Operation Parameter* (*R4*).

=== Domain

A domain is a real or imagined world with its own set of rules.

Name \{I}::
    Each domain in a system must have a unique name.
[horizontal]
    Data Type::: string
Interface::
    A Domain will, in general, have dependencies on other aspects of the
    system. The Interface attribute is a string that will be inserted
    in the generated interface header file for the domain.
    Typically, the Interface will contain `#include` ``C'' preprocessor
    statements, but may contain any other compiler declarations
    needed.
[horizontal]
    Data Type::: string
Prologue::
    The Prologue for a Domain is inserted into the code file before any
    `micca` generated code.
    This gives the translation the opportunity to have external or forward
    references needed to satisfy the ``C'' compiler.
[horizontal]
    Data Type::: string
Epilogue::
    The Epilogue for a Domain is inserted into the code file after any
    `micca` generated code.
[horizontal]
    Data Type::: string
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Domain {
    attribute Name string -id 1
    attribute Interface string
    attribute Prologue string
    attribute Epilogue string
}
----

=== Domain Element

A domain element is one of the constituent parts of a domain.

Domain \{I,R1}::
    The name of the domain to which the element belongs.
[horizontal]
    Data Type::: references Domain.Name
Name \{I}::
    Each domain elements is given a name that is unique within the domain.
[horizontal]
    Data Type::: c-identifier

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainElement {
    attribute Domain string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}

    reference R1 Domain -link {Domain Name}
}
----

==== Checking for ``C'' Identifiers

Many names in the platform model will be directly used as an identifier in
the generated ``C'' code.
We insist they be of the correct form when the model is populated.
A simple regular expression will do the trick.

[source,tcl]
----
<<helper commands>>=
proc isIdentifier {name} {
    return [regexp {\A[[:alpha:]]\w*\Z} $name]
}
----

=== R1

* *Domain Element* is an entity of _exactly one_ *Domain*
* *Domain* models entities using _one or more_ *Domain Element*

We do not allow an empty domain.
Domains with no composing elements cannot model anything useful.
Each element of a domain belongs strictly to a single domain,
_i.e._ domain elements are never shared between domains.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R1 DomainElement 1..*--1 Domain
----

=== Class

A Class represents a logical predicate about some aspect of a Domain.

Domain \{I,I2,R2,R104}::
    The name of the domain to which the class belongs.
[horizontal]
    Data Type::: References DomainElement.Domain
Name \{I,R2,R104}::
    Classes are identified by name within the domain to which they belong.
[horizontal]
    Data Type::: string
Number \{I2}::
    It is useful during code generationto have a sequential integer number for
    classes within a given domain.
[horizontal]
    Data Type::: sequential numeric

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Class {
    attribute Domain string -id 1 -id 2
    attribute Name string -id 1 ; # <1>
    attribute Number int -id 2 -system 0

    reference R2 DomainElement -link Domain -link Name
}
----
<1> The question arises whether we need to check if *Class.Name* is a
valid ``C'' identifier.
The answer is no.
Since *Class.Name* refers to *DomainElement.Name* unconditionally,
the check on *DomainElement.Name* insures that *Class.Name* is a valid
``C'' identifier.
Otherwise, we would fail the referential integrity check indicated by *R2*.

=== Relationship

A Relationship represents a real world association between class instances.

Domain \{I,R2}::
    The name of the domain to which the relationsihp belongs.
[horizontal]
    Data Type::: References DomainElement.Domain
Name \{I,R2}::
    Relationships are identified by name within the domain to which they belong.
    Traditionally, relationships are given names of the form, "R<digit>+", where
    <digit> is a decimal number.
    Although the convention is very commonly used in the executable modeling
    world, relationships may be given any desired name.
[horizontal]
    Data Type::: string
Number \{I2}::
    It is useful during code generationto have a sequential integer number for
    relationships within a given domain.
[horizontal]
    Data Type::: sequential numeric

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Relationship {
    attribute Domain string -id 1 -id 2
    attribute Name string -id 1
    attribute Number int -id 2 -system 0

    reference R2 DomainElement -link Domain -link Name
}
----

=== R2

* *DomainElement* is a *Class* or *Relationship*

There are only two types of domain elements, Classes and Relationships.
These elements model the logical predicates of the domain subject matter.

[source,tcl]
----
<<platform relationships>>=
generalization R2 DomainElement Class Relationship
----

=== Domain Operation

A Domain Operation is a executable body of code that provides
a service access point into a domain.
The set of domain operations of a domain constitute the invocable programming
interface to the domain.

Domain \{I,R5}::
    The name of the domain to which the domain operation belongs.
[horizontal]
    Data Type::: refers to Domain.Name
Name \{I}::
    The name of the operation. Domain operations are given names that
    must be unique only within a given domain.
[horizontal]
    Data Type:::: c-identifier
Body::
    The code that is to be executed when the domain operation is invoked.
    This code is presumed to be ``C'' language statements and,
    except for some preprocessing of the statements,
    is passed along in the generated output file for the domain.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the domain operation.
[horizontal]
    Data Type:::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainOperation {
    attribute Domain string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Body string
    attribute ReturnDataType string

    reference R5 Domain -link {Domain Name}
}
----

=== R5

* *Domain Operation* is a service for _exactly one_ *Domain*
* *Domain* provides service via _zero or more_ *Domain Operation*

Domain operations only operate on a single domain.
However, a domain may not provide an explicit service entry points
and have no defined domain operations.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R5 DomainOperation 0..*--1 Domain
----

=== Domain Operation Parameter

A Domain Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R6}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to DomainOperation.Domain
Operation \{I,I2,R6}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to DomainOperation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list
    without reference to the parameter name.
[horizontal]
    Data Type::: numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class DomainOperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string

    reference R6 DomainOperation -link Domain -link {Operation Name}
}
----

=== R6

* *Domain Operation Parameter* defines a formal parameter of _exactly one_
    *Domain Operation*
* *Domain Operation* has a formal parameter defined by _zero or more_
    *Domain Operation Parameter*

A domain operation parameter definition only applies to a single operation.
However, domain operations may have no parameters
as it is valid to have ``C'' functions with no parameters.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R6 DomainOperationParameter 0..*--1 DomainOperation
----

=== Operation

An *Operation* is a executable body of code that computes on a
class or class instance.

Domain \{I,R3}::
    The name of the domain to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Domain
Class \{I,R3}::
    The name of the class to which the operation belongs.
[horizontal]
    Data Type::: refers to Class.Name
Name \{I}::
    The name of the operation. Operations are given names that
    must be unique only within a given class.
[horizontal]
    Data Type:::: c-identifier
IsInstance::
    This attribute determine whether the operation applies to class instances.
    If true, then the generated code for the operation will have
    an implicitly declared parameter named `self`.
[horizontal]
    Data Type:::: boolean
Body::
    The code that is to be executed when the operation is invoked.
[horizontal]
    Data Type:::: c-code
ReturnDataType::
    The data type of the value returned by the operation.
[horizontal]
    Data Type:::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class Operation {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute IsInstance boolean
    attribute Body string
    attribute ReturnDataType string

    reference R3 Class -link Domain -link {Class Name}
}
----

=== R3

* *Operation* operates over _exactly one_ *Class*
* *Class* is the domain for _zero or more_ *Operation*

Operations only operate on a single class.
However, a class may not provide any explicit operations.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R3 Operation 0..*--1 Class
----

=== Operation Parameter

An Operation may define a set of formal parameters.
When invoked,
the caller must supply an actual argument value for each formal parameter.

Domain \{I,I2,R4}::
    The name of the domain to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Domain
Class \{I,I2,R4}::
    The name of the class to which the parameter belongs.
[horizontal]
    Data Type::: refers to Operation.Class
Operation \{I,I2,R4}::
    The name of the domain operation to which the parameter applies.
[horizontal]
    Data Type::: refers to Operation.Name
Name \{I}::
    The name of the parameter.
[horizontal]
    Data Type::: c-identifier
Number \{I2}::
    The ordinal position of the parameter when it is supplied as part
    of a list of other parameters.
    In addition to names,
    parameters are given a number as in many cases supplying
    arguments for formal parameters is accomplished in an ordered list.
[horizontal]
    Data Type::: sequential numeric
DataType::
    The data type of the parameter.
[horizontal]
    Data Type::: c-typename

==== Implementation
[source,tcl]
----
<<platform classes>>=
class OperationParameter {
    attribute Domain string -id 1 -id 2
    attribute Class string -id 1 -id 2
    attribute Operation string -id 1 -id 2
    attribute Name string -id 1 -check {[::micca::Helpers::isIdentifier $Name]}
    attribute Number int -id 2
    attribute DataType string

    reference R4 Operation -link Domain -link Class -link {Operation Name}
}
----

=== R4

* *Operation Parameter* defines a formal parameter of _exactly one_
    *Operation*
* *Operation* has a formal parameter defined by _zero or more_
    *Operation Parameter*

==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R4 OperationParameter 0..*--1 Operation
----

== Classes Subsystem

=== Introduction

[[classes-subsystem-discussion]]
The classes subsystem defines how model level ideas of a class will be
realized in `micca`.
We will simplify considerably the relational view of classes that
we find at the model level.
Because we are holding all data in memory and we are using
an implemenation language that exposes addresses,
there are number of simplifying transformations on classes available to us.

* Since the address in memory (_.i.e._ a pointer to an object) is unique,
we can use it as an identifier of each class instance.
If the identifying attributes from the model serve no other descriptive role,
then they can be eliminated altogether.
Using the object pointer as an identifier has a number of
other implementation benefits such as directly accessing attribute values.
* Referential attributes will be replaced by pointer values.
Since referential attributes always refer to identifiers in the model,
then implementing relationships can be accomplished by storing
sets of pointers whose values refer to objects in memory.

Both of these considerations lead to the common decision in this type of
platform to map model level class definitions onto ``C'' structure definitions.
Storage for a class can then be allocated as an array of structures
that correspond to the class definition.
Most of the classes subsystem is concerned with how the ``C'' structure
definitions will be composed and the type of information that is held.
We will also be concerned with how some relationship storage will be
structured.

Below is the UML class diagram for the domain subsystem of the platform model.

image::platform-classes.pdf[title="Classes Subsystem Class Diagram"]

A *Class* is composed of *ClassComponent* (*R20*).
*ClassComponent* consists of four different types (*R21*).
An *Attribute* is a named, descriptive value of the *Class* and may have
a *DefaultValue* (*R22*).
A *Reference* is used to implement class relationships.
A generalization subclass may be held as a discriminated union in
a *SubclassContainer*.
When a class instance participates in a multiple relationship that uses
linked lists,
the list links are held in a *LinkContainer*.
A *Reference* may also be one of four different types (*R23*).
The types of references fulfill different roles and types of relationships.
An *AssociationReference* is used to store information about
association relationships.
An *AssociatorReference* holds the references for an *AssociatorClass*.
A generalization supertype uses a *SubclassReference* to traverse a
generalization relationships from superclass to subclass.
A subtype uses a *SuperclassReference* to traverse a
generalization relationship from subclas to superclass.
Associations have different multiplicities and use different
types of pointer storage (*R24*).
A *SingularReference* is used to hold relationship pointers for
singular multiplicities.
When the multiplicity of a relationship is greater than one,
two different storage strategies are supported.
For relatively static relationships,
references can be held as an *ArrayReference*.
For dynamic relationships,
a *LinkedReference* is often a better choice.

=== Class Component

A Class Component is an element of the implementation class structure
and directly represents a member of the structure definition for the class
as it is used in the implementation.

Domain \{I,R20}::
    The name of the domain to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Domain
Class \{I,R20}::
    The name of the class to which the class component belongs.
[horizontal]
    Data Type::: Refers to Class.Name
Name \{I}::
    The name of the component.
[horizontal]
    Data Type::: c-identifier
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassComponent {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R20 Class -link Domain -link {Class Name}
}
----

=== R20

* *ClassComponent* defines the properties of _exactly one_ *Class*
* *Class* is characterized by _one or more_ *ClassComponent*

A Class is made up of one or more components and each component
can belong to only one class.
Empty classes are not allowed as these are deemed to model nothing.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R20 ClassComponent 1..*--1 Class
----

=== R21

* *ClassComponent* is an *Attribute*, *Reference*, *SubclassContainer*,
or *LinkContainer*

There are four types of components that may be part of a class.
These four types represent the different ways attributes and relationships
are stored in class structures.
An attribute corresponds to model level attributes that hold data that
parameterizes the class
(_i.e._ attributes whose roles are not strictly referential or identifying).
A reference is one or more pointers that are used to implement
model level relationships.
A subclass container can be used by a superclass to hold subclass elements
as a discriminated union.
This is one option for how generalization relationship information may be
stored.
A link container is a set of pointers used to implement a linked list.
This is one option for how sets of relationship pointer information may be
stored.
The space for the link pointers is allocated in to the class that would be
chained together on a relationship.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R21 ClassComponent Attribute Reference SubclassContainer LinkContainer
----

=== Attribute

The Attribute class represent descriptive data that parameterizes a class.

Domain \{I,R21}::
    The name of the domain to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the attribute belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the attribute.
[horizontal]
    Data Type::: Refers to Class Component.Name
DataType::
    The data type of the parameters.
[horizontal]
    Data Type::: c-typename
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Attribute {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute DataType string

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== Default Value

The default value of an attribute is one that will be given to the
attribute when an class instance is created if no value is otherwise provided.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class DefaultValue {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Attribute string -id 1

    reference R22 Attribute -link Domain -link Class -link {Attribute Name}
}
----

=== R22

* *DefaultValue* supplies missing value for _exactly one_ *Attribute*
* *Attribute* has missing value supplied by _zero or one_ *DefaultValue*

An Attribute may be defined to have a default value that the system
will use when the attribute's value is not otherwise specified when
a class instance is created.
There can only be one default value for an attribute
and not all attributes will define default values.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R22 DefaultValue 0..1--1 Attribute
----

=== Reference

A reference is one or more pointer values that are used to implement
the storage for a relationship.

Domain \{I,R21}::
    The name of the domain to which the reference belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the reference belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the reference.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Reference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== Subclass Container

One option for storing generalization relationship information is
as a discriminated union.
The idea is that subclass storage is accomplished by creating a union
of all the subclasses in the generalization.
Then an component of the superclass is defined to be the subclasses union
along with another member to track to which subclass the superclass is
currently related.
This type of storage structure can save some memory space and
traversal across the generalization relationships can be accomplished
with pointer arithmetic.

Domain \{I,R21}::
    The name of the domain to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the subclass container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the subclass container.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SubclassContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== LinkContainer

A link container is a class component that holds pointer values that allow a
class instance to be on a linked list that is used as the storage for a
relationship.
One type of relationship storage uses linked lists when multiple
instances must be referenced.
The linkage is embedded into the class structure for the instances that
are being referenced.
The link list approach to relationship storage requires more space
but has better run time characteristics when the relationship is
dynamic.

Domain \{I,R21}::
    The name of the domain to which the link container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Domain
Class \{I,R21}::
    The name of the class to which the link container belongs.
[horizontal]
    Data Type::: Refers to Class Component.Class
Name \{I,R21}::
    The name of the link container.
[horizontal]
    Data Type::: Refers to Class Component.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class LinkContainer {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R21 ClassComponent -link Domain -link Class -link Name
}
----

=== R23

* *Reference* is a *AssociationReference*, *AssociatorReference*,
*SubclassReference* or *SuperclassReference*

There are four types of storage arrangements that are used to handle
pointers used to track class relationships.
These types handle the specific cases of model level relationships
are translated into a ``C'' environment.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R23 Reference\
    AssociationReference AssociatorReference SubclassReference SuperclassReference
----

=== Association Reference
An Association Reference is used to store pointer values for an association
type relationship.
An Association Reference will store one or two references depending whether
the association is reflexive.
For reflexive associations,
the Association Reference stores reference types for both the forward and
reverse directions of the relationships traversal.
For non-reflexive association,
it stores only a single reference type for the direction of traversal
in which the class participates.

Domain \{I,R23}::
    The name of the domain to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the assocation reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the assocation reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssociationReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== Associator Reference
When a class is an associator class,
it will contain an associator reference.
This type of reference stores two pointers to the classes
participating in the association.
Note for associator references,
the pointer values to the participating classes are not allowed to be
`NULL`.

Domain \{I,R23}::
    The name of the domain to which the associator reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain
Class \{I,R23}::
    The name of the class to which the associator reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class
Name \{I,R23}::
    The name of the associator reference.
[horizontal]
    Data Type::: Refers to Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssociatorReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R23 Reference -link Domain -link Class -link Name
}
----

=== Subclass Reference
For generalization relationships,
to navigate from the superclass to one of its subclasses
we must be able to determine the type of the subclass to which
the superclass is currently related.
A subclass reference is composed of both the pointer to the related subclass
instance as well as an encoding of the subclass instance type.

Domain \{I,R23,R92}::
    The name of the domain to which the subclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain and Referenced Superclass.Domain
Class \{I,R23,R92}::
    The name of the class to which the subclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class and Referenced Superclass.Class
Name \{I,R23,R92}::
    The name of the subclass reference.
[horizontal]
    Data Type::: Refers to Reference.Name and Referenced Superclass.Relationship
Role \{R92}::
    The role played by the subclass reference in the relationship.
[horizontal]
    Data Type::: Refers to Referenced Superclass.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SubclassReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string

    reference R23 Reference -link Domain -link Class -link Name
    reference R92 ReferencedSuperclass -link Domain -link Class\
        -link {Name Relationship} -link Role
}
----

=== Superclass Reference
For generalization relationships,
pointer information to navigate from a subtype to the supertype class
is stored in a Superclass Reference.

Domain \{I,R23,R91}::
    The name of the domain to which the superclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Domain and Referring Subclass.Domain
Class \{I,R23,R91}::
    The name of the class to which the superclass reference belongs.
[horizontal]
    Data Type::: Refers to Reference.Class and Referring Subclass.Class
Name \{I,R23,R91}::
    The name of the superclass reference.
[horizontal]
    Data Type::: Refers to Reference.Name and Referring Subclass.Relationship
Role \{R91}::
    The role played by the superclass reference in the relationship.
[horizontal]
    Data Type::: Refers to Referring Subclass.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SuperclassReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1
    attribute Role string

    reference R23 Reference -link Domain -link Class -link Name
    reference R91 ReferringSubclass -link Domain -link Class\
        -link {Name Relationship} -link Role
}
----

=== R24

* *AssociationReference* is a *LinkedReference*, *ArrayReference*,
or *SingularReference*

Storage for association relationships can be one of three types.
A Singular Reference hold a single pointer value and is suitable
for storing relationships that have a mulitplicity of one.
When storing pointers for relationships with a multiplicity greater that one,
two choices are available.
The Linked Reference uses a linked list.
This choice requires more space but has better dynamic run time characteristics.
The Array Reference uses a counted array of pointers.
This choice minimizes space and is a good choice if the relationship
instances are static.
However, a counted array has poorer worst case run time behavior than the
linked list when the instances of the array are dynamic.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R24 AssociationReference\
    LinkedReference ArrayReference SingularReference
----

=== Linked Reference
When associations of multiplicities greater than one are also dynamic,
_i.e._ there are `link` and `unlink` operations performed on the
relationship,
a linked list is one provided option for storing the relationship
pointers.
A Linked Reference represents the head of that linked list.

Domain \{I,R24}::
    The name of the domain to which the linked reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the linked reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the linked reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class LinkedReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 AssociationReference -link Domain -link Class -link Name
}
----

=== Array Reference
An array reference consists of an array of pointers and a count
indicating the number of array elements that are in use.
This type of reference can be used to store relationship pointers
for relationships with multiplicities greater than one.

Domain \{I,R24}::
    The name of the domain to which the array reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the array reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the array reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ArrayReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 AssociationReference -link Domain -link Class -link Name
}
----

=== Singular Reference
A singular reference consists of a single pointer value and
can be used to store relationship information for relationship of
multiplicity one.

Domain \{I,R24}::
    The name of the domain to which the singular reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Domain
Class \{I,R24}::
    The name of the class to which the singular reference belongs.
[horizontal]
    Data Type::: Refers to Association Reference.Class
Name \{I,R24}::
    The name of the singular reference.
[horizontal]
    Data Type::: Refers to Association Reference.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SingularReference {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Name string -id 1

    reference R24 AssociationReference -link Domain -link Class -link Name
}
----

== Relationship Subsystem

=== Mapping Referential Attributes to Pointers
When targeting a statically typed language such as ``C'' and assuming
that all class data will be held in primary memory,
we must devise a way to map relational notions of referential attributes
and referential integrity onto ``C''' language constructs.
There are, needless to say, many ways this can be done.
As we discussed earlier,
we make the convenient decision to use the address of a class instances
as an architecturally supplied identifier.
This decision has many benefits in the implementation.
This also means we can store pointer values as a means of implementing
relationships.

Consider a many-to-one association between two classes.
In a relational scheme,
we would have referential attributes in the class that was on the *many*
side of the relationship and the values of those attributes would
match the values of identifying attributes on the *one* side.
In a pointer based scheme we can do the same thing, _i.e._
place a pointer variable in the ``C'' structure of the class on the *many* side
and have the value of the pointer match that of a class instance on
the *one* side.
The diagram below shows this mapping.

image::pointer-example.pdf[title="Direct Mapping of Referential Attribute"]

Now lets look at the computation required to navigate this relationship,
first from the many side to the one side and then from the one side to
the many side.
For this discussion we will assume the relationship is unconditional on
both sides.

From the many side,
we can see from the above diagram that given a pointer to an *A* instance
we can navigate to the related *B* instance by simply accessing the
`R1` member of `struct A`.
When navigating from the one side to the many side,
we will, in general, obtain more than one instance as a result of the
navigation.
We can find those instances by searching all of the many-side instances
selecting those instances who have a stored pointer value that matches the
address of the one-side class instance.
So in our example, if we have a pointer to a `struct B` we would need to
search all instances of *A* looking for those where the `R1` member
matched the value of our starting pointer.

Having to perform a search for the one-side to many-side navigation is
somewhat troubling.
If the number of instances of the many-side class is small,
then there is little concern.
If it is larger, then we might explore ways to avoid costs associated
with a straight linear search of the many-side instances.
The search code is also rather inconvenient since we target a statically
typed language.
The function to iterate across the many-side instances looking for
the one-side pointer value has to be specific to that particular relationship
if we are to be strictly type safe and don't want to resort to
extremes of type casting and pointer arithmetic.

One way to avoid the search altogether is to store the pointers of the
multiple related instances.
We will have, in effect, pre-computed the related set and, at the cost of the
pointer storage, incur no run time computation to find it.
The figure below shows this in sketch form.

image::pointer-set-example.pdf[title="Mapping Instance References in Both Directions"]

In this arrangement,
the multiple instances implied by traversing the *R1* relationship from
class *B* to class *A* is held as an array of pointers to the related
*A* instances.

It does take computation to maintain the set if the instances participating
in the relationship change.
The space vs. speed trade-off is such that we will almost always use some
additional space to save a run time cost and additional code associated with
computing a set of related instances.
There are other choices of data structures that could be used
to hold the set of pointers.
By choosing different data structures to store the pointer sets,
we can, again at the cost of some additional space,
make maintaining the related pointer sets easier in the face of relationship
changes.

It is also worth noting that although at the model level,
relationships can be navigated in either direction as required by the
logic of the processing,
in practice most relationships are *not* navigated by the processing in
both directions.
So as we adopt the strategy to store relationship pointers that implement
the navigation in both participating classes,
we can also be aware that we can elide those pointers in classes where
we do not navigate a relationship in a particular direction.
In many models,
this will turn out to be a significant savings.

Analysis like that above can be applied to the other types of relationships
and pointer storage schemes can be designed that map the
relational notion of referential attributes to memory pointers.
Most of the relationship subsystem is concerned with categorizing
the types of relationships from a model level
and mapping those onto the roles the classes play in the relationship.
This will then allows us to explicitly map the role a class plays in a
relationship to the kind of storage required to implement that role and
further to the class structure components that are required to hold
the pointers.
The references subsystem models this later part.

=== Naming Conventions on Relationship Traversal

[[relationship-naming-conventions]]
In addition to modeling the real world associations between classes,
relationships also provide a means for the processing of the domain
to navigate the class diagram to access related class instances.
Here we discuss the syntax conventions we will use to indicate
how this navigation will take place.
We adopt the strategy that each relationship has a designated _direction_.
Navigating in the _forward direction_ starts with instances of a source
class and ends with instances of a target class.
Navigating in the _reverse direction_ starts with target class instances
and ends with source class instances.
To designate the forward direction we will use the unadorned relationship
name, _e.g._ `R22` and the reverse direction is indicated by
placing a tilde character before the relationship name, _e.g._ `~R22`.
The motivation behind this convention is to minimize the amount
of specification that needs to be given for navigating relationships
and to disambiguate the case of a reflexive relationship where the
source class and target class are the same.
Given the specification of a relationship direction,
the system knows which classes are involved and that need not be restated
when specifying the navigation during a state activity.
When specifying a direction to a relationship there are three cases to
consider.

For simple assocations,
the forward direction of the relationship is from the referring class
to the referenced class.
In a simple association,
one class contains referential attributes and is hence the referring class.
The other class contains the referenced identifying attributes and
is deemed the referenced class.
The forward direction is then the traversal from instances of the
referring class to instances of the referenced class.

For generalization relationships,
the forward direction of the relationship is also from the referring class
to the referenced class.
In a generalization,
the subclass instances are always the referring instances.
Navigating from the superclass to a subclass requires additional information,
namely which subclass is to be the target.
Navigating from a superclass instance to a subclass instance can yield
at most one subclass instance and possibly zero if the superclass instance
is not actually related to the requested subclass.
So the syntax convention to navigate from a superclass instance to a subclass
instance specifies navigating in the reverse direction as well as the
desired subclass name, _e.g._ `~R42 TableLamp`.

For class based associations,
it is the associator class that holds referential attributes that refer to
both participating classes.
In this case,
the forward direction of the relationships must simply be specified
and one class is designated the source and the other the target.
Since it is also possible to navigate from a participating class to the
associator class itself,
we will specify that case by including the associator class name,
similar to the way generalization relationship navigation is specified.
Navigating from source to target is specified as the unadorned
relationship name, _e.g._ `R14`.
Navigating from target to source uses the tilde notation, _e.g._ `~R14`.
Navigating from the source to the associator includes the associator
class name, _e.g._ `R14 Ownership` and from target to associator
uses the tilde and the associator class name, _e.g._ `~R14 Ownership`.

Only associations can be reflexive (_i.e._ the source and target are the
same class).
For generalization relationships,
we insist that all the subclasses are distinct and that they are distinct
from the superclass.
The conventions used here serve to disambiguate association traversal
in the reflexive case,
however, additional specification is required to fix the precise traversal
path for the case of one-to-one and many-to-many reflexive relationships.
For a one-to-one reflexive association,
we will need to specify which attributes are the referential ones and
that will set the direction.
For a many-to-many association an associator class is required and
again we will have to specify the path from source to target.

Below is the UML class diagram for the relationship subsystem of the platform
model.

image::platform-relation.pdf[title="Relationship Subsystem Class Diagram"]

There are two types of *Relationship* (*R30*), namely
*Association* and *Generalization*.
In turn,
there are two types of *Association* (*R31*), namely
*Simple Association* and *Class Based Association*.
A *Class Based Association* uses a distinct *Associator Class* (*R42*)
to hold references to the participating *Source Class* (*R34*) and
*Target Class* (*R35*).
A *Simple Association* is one where the multiplicity and conditionality
are such that all the references can be located in one of the participating
classes.
The *Simple Referring Class* houses the references (*R32*) while the
*Simple Referenced Class* is the one referred to (*R33*).
`Micca` supports two ways to handle generalization relationships (*R43*).
A *Reference Generalization* uses pointer values to implement the
relationship.
In this arrangement,
a *Referenced Superclass* (*R36*) holds a pointer and encoded type to
a *Referring Subclass* (*R37*).
The *Referring Subclass* also holds a pointer to its related superclass
instances.
A *Union Generalization* uses a discriminated union
to implement the relationship.
This leads to the complementary ideas of a *Union Superclass* (*R44*) and
a *Union Subclass* (*R45*).
All of these class roles are specialized as a *Class Role* (*R40*) which
is the many-to-many-to-many correlation between *Relationship* and
*Class* (*R41*).

=== Association
An Association is a mapping between the instances of two classes.
The two classes need not be distinct.
If the association is between instances of the same class,
then it is called a _reflexive_ association.
If the association is between instances of distinct classes,
then it is called a _non-reflexive_ association.

Domain \{I,R30}::
    The name of the domain to which the association belongs.
[horizontal]
    Data Type::: Refers to Relationship.Domain
Name \{I,R30}::
    The name of the association.
[horizontal]
    Data Type::: Refers to Relationship.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Association {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R30 Relationship -link Domain -link Name
}
----

=== Generalization
An Generalization is a partitioning of a class into a disjoint union.

Domain \{I,R30}::
    The name of the domain to which the generalization belongs.
[horizontal]
    Data Type::: Refers to Relationship.Domain
Name \{I,R30}::
    The name of the generalization.
[horizontal]
    Data Type::: Refers to Relationship.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class Generalization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R30 Relationship -link Domain -link Name
}
----

=== R30
* *Relationship* is an *Association* or *Generalization*

There are two fundamental types of relationships.
These types are complementary to each other.
An Association is fundamentally related to the Cartesian product
of the participants.
A Generalization is related to the disjoint union of the particiants.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R30 Relationship Association Generalization
----

=== R31
* *Association* is a *Simple Association* or *Class Based Association*

Associations are mappings between class instances.
In its most general form,
a separate class is used to hold the mappings and these are called
*Class Based Associations*.
For the special case of one-to-one and one-to-many multiplicities,
the realization of the association can be simplified by placing
the association mappings into one of the participating classes.
These are known as *Simple Association*.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R31 Association ClassBasedAssociation SimpleAssociation
----

=== Class Based Association
A Class Based Association is a that type of association where a
distinct class is used to implement the relationship.

Domain \{I,R31}::
    The name of the domain to which the class based association belongs.
[horizontal]
    Data Type::: Refers to Association.Domain
Name \{I,R31}::
    The name of the class based association.
[horizontal]
    Data Type::: Refers to Association.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassBasedAssociation {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R31 Association -link Domain -link Name
}
----

=== Simple Association
A Simple Association is a that type of association where the relationship
is implemented using attributes in one of the participating classes.

Domain \{I,R31}::
    The name of the domain to which the simple association belongs.
[horizontal]
    Data Type::: Refers to Association.Domain
Name \{I,R31}::
    The name of the simple association.
[horizontal]
    Data Type::: Refers to Association.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SimpleAssociation {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R31 Association -link Domain -link Name
}
----

=== R43
* *Generalization* is a *Reference Generalization* or *Union Generalization*

The `micca` platform supports two different techniques to hold
generalization relationship information.
One technique is to use pointer values in a way similar to association
relationships.
The other techique is to use a discriminated union to hold the subclass
instance as part of the superclass instance.

==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R43 Generalization ReferenceGeneralization UnionGeneralization
----

=== Reference Generalization

A Reference Generalization is that type of generalization where
pointer references are used to implement the relationship.

Domain \{I,R43}::
    The name of the domain to which the reference generalization belongs.
[horizontal]
    Data Type::: Refers to Generalization.Domain
Name \{I,R43}::
    The name of the reference generalization association.
[horizontal]
    Data Type::: Refers to Generalization.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class ReferenceGeneralization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R43 Generalization -link Domain -link Name
}
----

=== Union Association

A Union Generalization is that type of generalization where the subclass
is held as a discriminated union within the superclass instance.
Because of the properties of a generalization relationship,
a superclass is never related to more than one of its subclasses
and so a union of all the subclass structures may be used directly
as the subclass instance storage.

Domain \{I,R43}::
    The name of the domain to which the union generalization belongs.
[horizontal]
    Data Type::: Refers to Generalization.Domain
Name \{I,R43}::
    The name of the union generalization.
[horizontal]
    Data Type::: Refers to Generalization.Name.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class UnionGeneralization {
    attribute Domain string -id 1
    attribute Name string -id 1

    reference R43 Generalization -link Domain -link Name
}
----
=== Simple Referring Class
In a Simple Association between two classes,
one class has the role of refering to the other class in the association.
That role is termed the Simple Referring Class.
This class is deemed to be the source of relationship navigation when
going in the forward direction.
From a relational point of view,
the Simple Referring Class is the class in the Simple Association
which contains referential attributes.

Domain \{I,R32,R38}::
    The name of the domain to which the simple referring class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the simple referring class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R32,R38}::
    The name of the relationship in which the simple referring class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the simple referring class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SimpleReferringClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R32 SimpleAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R32

* *Simple Referring Class* is the referring member of
_exactly one_ *Simple Association*
* *Simple Association* has a referring member of
_exactly one_ *Simple Referring Class*

A *Simple Association* is one where referential attributes are
placed in one of participating class.
That class then serves the role of a *Simple Referring Class*.
Each *Simple Association* must have a class that acts as
a *Simple Referring Class* and a class can only be a *Simple Referring Class*
within the context of one *Simple Association* relationship.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R32 SimpleReferringClass 1--1 SimpleAssociation
----

=== Simple Referenced Class

In a Simple Association between two classes,
one class has the role of being referenced by the other class in the
association.
That role is termed the Simple Referenced Class.
This class is deemed to be the target of relationship navigation when
going in the forward direction.
From a relational point of view,
the Simple Referenced Class is the class in the Simple Association
which contains identifying attributes referenced by the Simple Referring Class.

Domain \{I,R33,R38}::
    The name of the domain to which the simple referenced class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the simple referenced class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R33,R38}::
    The name of the relationship in which the simple referenced class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the simple referenced class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean

Note that there is no Multiplicity attribute.
A Simple Referenced Class is always referred to by at most one
Simple Referring Class.
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class SimpleReferencedClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean

    reference R33 SimpleAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R33

* *Simple Referenced Class* is the referenced member of
_exactly one_ *Simple Association*
* *Simple Association* has a referenced member of
_exactly one_ *Simple Referenced Class*

A *Simple Association* is one where referential attributes are
placed in one of participating class that refer to the identifying
attributes of the other class.
The class containing the referenced identifying attributes serves
the role of a *Simple Referenced Class*.
Each *Simple Association* must have a class that acts as
a *Simple Referenced Class* and a class can only be a *Simple Referenced Class*
within the context of one *Simple Association* relationship.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R33 SimpleReferencedClass 1--1 SimpleAssociation
----

=== Conventions Used for Class Based Associations
Class based association pose some additional complexity when
describing the way in which they are mapped to the implementation realm.
The associator class represents instances of the association between
the participants.
Each instance of the associator class corresponds one-to-one to instances
of the association itself.
As we discussed
<<relationship-naming-conventions,above>>,
in a class based association one participant will be deemed the source
and the other the target in order to specify the direction of the
relationship for traversal.
The associator class itself always contains the referential attributes
and in our implementation strategy, will contain two pointers, one each
to the participating class instances.
The pointer values will never be `NULL` as the reference from the
associator class to one of the participants is always unconditional.
We will decompose a class based association to make the role of the
associator class explicit.
This is shown in the diagram below.

image::assoc-decompose.pdf[title="Decomposition of Class Based Associations"]

Note that as part of the decomposition,
the multiplicity and conditionality of the source and target sides have
been switched.
Because the references from the associator class to the participants is
unconditional,
the multiplicity and conditionality of the decomposed association when going
from the source class to the associator class is the same as that specified
for the target side at the model level and conversely for the target class.
The apparent switch of the multiplicity and conditionality results from
both the decomposition,
which makes the role of the associator class and its pointer references
explicit,
and the unconditional nature of the references from the associator class to the
participant classes.

With this in mind,
we describe the roles that classes play in a class based association below.
We will have occasion to refer back to this explanation when we generate
the code for class based associations.

=== Source Class

For a Class Based Association,
the Source Class is the starting class from which the association can be
traversed in the forward direction.

Domain \{I,R34,R38}::
    The name of the domain to which the source class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the source class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R34,R38}::
    The name of the relationship in which the source class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the source class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean

==== Implementation

[source,tcl]
----
<<platform classes>>=
class SourceClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R34 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R34

* *Source Class* is the source member for _exactly one_ *Class Based Association*
* *Class Based Association* has a source member of _exactly one_ *Source Class*

Each Class Based Association designates one of the participant classes
to serve the role as the source of traversal.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R34 SourceClass 1--1 ClassBasedAssociation
----

=== Target Class

For a Class Based Association,
the Target Class is that class where, when the association is traversed
in the forward direction starting at the Source Class, the instances
related by the association are found.
Alternatively, the Target Class can serve as the start of a traversal
of the association in the reverse direction.

Domain \{I,R35,R38}::
    The name of the domain to which the target class belongs.
[horizontal]
    Data Type::: Refers to Simple Association.Domain and
    Association Participant Class.Domain.
Class \{I,R38}::
    The name of the target class.
[horizontal]
    Data Type::: Refers to Association Participant Class.Class
Relationship \{I,R35,R38}::
    The name of the relationship in which the target class
    participates.
[horizontal]
    Data Type::: Refers to Simple Association.Name
    and Association Participant Class.Relationship
Role \{I,R38}::
    The role the target class plays in the relationship.
[horizontal]
    Data Type::: Refers to Association Participant Class.Role
Conditionality::
    {cond-attribute}
[horizontal]
    Data Type::: boolean
Multiplicity::
    {mult-attribute}
[horizontal]
    Data Type::: boolean
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class TargetClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1
    attribute Conditionality boolean
    attribute Multiplicity boolean

    reference R35 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R38 AssociationParticipantClass\
        -link Domain -link Class -link Relationship -link Role
}
----

=== R35

* *Target Class* is the target member for _exactly one_ *Class Based Association*
* *Class Based Association* has a target member of _exactly one_ *Target Class*

Each Class Based Association designates one of the participant classes
to serve the role as the target of traversal.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R35 TargetClass 1--1 ClassBasedAssociation
----

=== Associator Class

For a Class Based Association,
the Associator Class is that class which holds references to the
participating classes.
Each instance of an Associator Class represents an instance of the
association between the participants.

Domain \{I,R42,R40,R93}::
    The name of the domain to which the associator class belongs.
[horizontal]
    Data Type::: Refers to Class Based Association.Domain,
    Class Role.Domain and Associator Reference.Domain.
Class \{I,R40,R93}::
    The name of the associator class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Associator Reference.Domain.
Relationship \{I,R42,R40,R93}::
    The name of the relationship in which the associator class
    participates.
[horizontal]
    Data Type::: Refers to Class Based Association.Name,
    Class Role.Relationship and Associator Reference.Name.
Role \{I,R40}::
    The role the associator class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssociatorClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R42 ClassBasedAssociation -link Domain -link {Relationship Name}
    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R93 AssociatorReference -link Domain -link Class\
        -link {Relationship Name}
}
----

=== R42

* *Associator Class* is the referring member of _exactly one_
*Class Based Association*
* *Class Based Association* has a referring member of _exactly one_
*Associator Class*

Class Based Associations must have a class that serves the role of
the associator and holds the references to the participating classes.
That role is served by exactly one class in the association.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R42 AssociatorClass 1--1 ClassBasedAssociation
----

=== R38

* *Association Participant Class* is a *Simple Referring Class*,
*Simple Referenced Class*, *Source Class* or *Target Class*

All the class roles that participate in a association relationships
can be generalized to be an Association Participant Class.
The common characteristic of these classes is that they
may hold pointer references to other classes in the association.

[source,tcl]
----
<<platform relationships>>=
generalization R38 AssociationParticipantClass\
    SimpleReferringClass SimpleReferencedClass\
    SourceClass TargetClass
----

=== Association Participant Class

An Association Participant Class is that type of role in an association
where the class may hold references to other participants in the association.

Domain \{I,R40,R90}::
    The name of the domain to which the association participant class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Associator Reference.Domain.
Class \{I,R40,R90}::
    The name of the association participant class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Associator Reference.Domain.
Relationship \{I,R40,R90}::
    The name of the relationship in which the association participant class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship and
    Associator Reference.Name.
Role \{I,R40}::
    The role the association participant class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class AssociationParticipantClass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R90 AssociationReference -link Domain -link Class\
        -link {Relationship Name}
}
----

=== Referenced Superclass

A Referenced Superclass is that role in a Reference Generalization
assumed by the superclass.

Domain \{I,R36,R40}::
    The name of the domain to which the referenced superclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain and
    Reference Generalization.Domain.
Class \{I,R40}::
    The name of the referenced superclass class.
[horizontal]
    Data Type::: Refers to Class Role.Domain.
Relationship \{I,R36,R40}::
    The name of the relationship in which the referenced superclass class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship and
    Reference Generalization.Name.
Role \{I,R40}::
    The role the referenced superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class ReferencedSuperclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R36 ReferenceGeneralization -link Domain -link {Relationship Name}
    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
}
----

=== R36

* *Referenced Superclass* is the abstract member of _exactly one_
*Reference Generalization*
* *Reference Generalization* has an abstract member of _exactly one_
*Referenced Superclass*

Each generalization relationship has exactly one member that serves as
the abstract or superclass member.
We will also insist that superclass roles may not be played by any
of the participant subclasses in the generalization.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R36 ReferencedSuperclass 1--1 ReferenceGeneralization
----

=== Referring Subclass

For a Reference Generalization,
a Referring Subclass is that role played by a subclass.

Domain \{I,R37,R40}::
    The name of the domain to which the referring subclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain and
    Reference Generalization.Domain.
Class \{I,R40}::
    The name of the referring subclass class.
[horizontal]
    Data Type::: Refers to Class Role.Domain.
Relationship \{I,R37,R40}::
    The name of the relationship in which the referring subclass class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship and
    Reference Generalization.Name.
Role \{I,R40}::
    The role the referring subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class ReferringSubclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R37 ReferenceGeneralization -link Domain -link {Relationship Name}
    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
}
----

=== R37

* *Referring Subclass* is a specific member of _exactly one_
*Reference Generalization*
* *Reference Generalization* has a specific member of _one or more_
*Referring Subclass*

Each generalization relationship has one or more participants that
are the specific members or subclasses of the generalization.
We will also insist that there are at least two subclass members
since partitioning a set into a single improper subset serves no
useful semantic reason.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R37 ReferringSubclass 1..*--1 ReferenceGeneralization
----

=== Union Superclass

For a Union Generalization,
the Union Superclass is that class that serves as a superclass in the
relationship.
This type of superclass will also be constructed so that the storage
for any related subclass will be a part of the memory allocated to the
superclass instance.
This provides a platform specific optimization of memory space for
simple generalizations.

Domain \{I,R40,R44,R96}::
    The name of the domain to which the union superclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain,
    Reference Generalization.Domain and Subclass Container.Domain.
Class \{I,R40,R96}::
    The name of the union superclass class.
[horizontal]
    Data Type::: Refers to Class Role.Domain and Subclass Container.Domain.
Relationship \{I,R40,R44,R96}::
    The name of the relationship in which the union superclass class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship,
    Union Generalization.Name, and Subclass Container.Name.
Role \{I,R40}::
    The role the union superclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class UnionSuperclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R44 UnionGeneralization -link Domain -link {Relationship Name}
    reference R96 SubclassContainer -link Domain -link Class\
        -link {Relationship Name}
}
----

=== R44

* *Union Superclass* is the abstract member of _exactly one_
*Union Generalization*
* *Union Generalization* has an abstract member of _exactly one_
*Union Superclass*

Each generalization relationship has exactly one member that serves as
the abstract or superclass member.
We will also insist that superclass roles may not be played by any
of the participant subclasses in the generalization.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R44 UnionSuperclass 1--1 UnionGeneralization
----

=== Union Subclass

For a Union Generalization,
a Union Subclass is that role played by a subclass in the generalization.

Domain \{I,R40,R45}::
    The name of the domain to which the union subclass class belongs.
[horizontal]
    Data Type::: Refers to Class Role.Domain and
    Union Generalization.Domain.
Class \{I,R40}::
    The name of the union subclass class.
[horizontal]
    Data Type::: Refers to Class Role.Domain.
Relationship \{I,R40,R45}::
    The name of the relationship in which the referring subclass class
    participates.
[horizontal]
    Data Type::: Refers to Class Role.Relationship and
    Union Generalization.Name.
Role \{I,R40}::
    The role the union subclass class plays in the relationship.
[horizontal]
    Data Type::: Refers to Class Role.Role

==== Implementation

[source,tcl]
----
<<platform classes>>=
class UnionSubclass {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1

    reference R40 ClassRole -link Domain -link Class -link Relationship -link Role
    reference R45 UnionGeneralization -link Domain -link {Relationship Name}
}
----

=== R45

* *Union Subclass* is a specific member of _exactly one_
*Union Generalization*
* *Union Generalization* has a specific member of _one or more_
*Union Subclass*

Each generalization relationship has one or more participants that
are the specific members or subclasses of the generalization.
We will also insist that there are at least two subclass members
since partitioning a set into a single improper subset serves no
useful semantic reason.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R45 UnionSubclass 1..*--1 UnionGeneralization
----

=== Class Role

A Class Role is an abstraction of the various ways that classes may
participate in relationships.
The major concept in the relationship subsystem is to define the
various types of relationships and then abstract the way that classes
participate in the relationships and the roles they play in holding
referential attributes, etc.

Domain \{I,R41}::
    The name of the domain to which the class role class belongs.
[horizontal]
    Data Type::: Refers to Class.Domain and Relationships.Domain.
Class \{I,R41}::
    The name of the class role class.
[horizontal]
    Data Type::: Refers to Class.Name.
Relationship \{I,R41}::
    The name of the relationship in which the class role class participates.
[horizontal]
    Data Type::: Refers to Relationship.Name.
Role \{I,R40}::
    The role the class role class plays in the relationship.
    There are three roles available to a class.
    It may be a _source_, _target_ or _associator_.
    Note that the Role attribute is part of the identifier of the class.
    This accounts for reflexive associations where the same class
    will play two different roles in the association.
[horizontal]
    Data Type::: {source, target, associator}.

==== Implementation

[source,tcl]
----
<<platform classes>>=
class ClassRole {
    attribute Domain string -id 1
    attribute Class string -id 1
    attribute Relationship string -id 1
    attribute Role string -id 1 -check {$Role in {source target associator}}

    reference R41 Relationship -link Domain -link {Relationship Name}
    reference R41 Class -link Domain -link {Class Name}
}
----

=== R40

* *Class Role* is a *Association Participant Class*, *Associator Class*,
*Referenced Superclass*, *Referring Subclass*, *Union Superclass* or
*Union Subclass*

Classes play various roles when that are involved in relationships.
This generalization abstracts the various ways that classes are involved
in relationships into a role.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
generalization R40 ClassRole AssociationParticipantClass AssociatorClass\
    ReferencedSuperclass ReferringSubclass UnionSuperclass UnionSubclass
----

=== R41

* *Class Role* _is an instance of_ *Relationship* models the association
between _one or more_ *Class*
* *Class Role* _is an instance of_ *Class* participates in _zero or more_
*Relationship*

Classes may participate in relationships to model the real world
associations between the classes.
It is possible (but not usual) for a class not to participate in any
relationship.
Relationships alway involve the participation of one or more classes
(usually two or three).
Note that *Class Role* has an additional identifying attribute, *Role*,
so that *R41* is actually a many-to-many-to-many relationship.
This additional multiplicity is required since reflexive relationships
have the same class playing more than one role in the relationship.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R41 Relationship 0..*--1..* Class -associator ClassRole
----

== References Subsystem

=== Introduction

In the Relationship subsystem,
we say how the platform models relationships and how classes play a
role in realizing the relationship.
In the References subsystem,
we map the roles a class plays in realizing a relationship to the
components that the class instances must store.
This mapping joins back up with the Class Components seen in the
Classes subsystem

Below is the UML class diagram for the references subsystem of the platform
model.

image::platform-references.pdf[title="References Subsystem Class Diagram"]

=== R90

* *Association Participant Class* holds references in _at most one_
*Association Reference*
* *Association Reference* is a reference holder for _one or more_
*Association Participant Class*

When a class serves as an Association Participant Class it may hold
pointer references to the other class in the association.
There may be no pointer references at for relationships directions that are not
traversed.
Each Association Reference hold one or two pointers, with two pointers
being required for reflexive relationships.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R90 AssociationParticipantClass 1..*--0..1 AssociationReference
----

=== R91

* *Super Class Reference* is a reference for _exactly one_ *Referring Subclass*
* *Referring Subclass* references via _at most one_ *Superclass Reference*

When a Referring Subclass stores a reference to its superclass it does so
in a *Superclass Reference*.
Not all Referring Subclass instances are navigated to the superclass so
the Referring Subclass may have no references to its superclass.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R91 SuperclassReference 0..1--1 ReferringSubclass
----

=== R92

* *Subclass Reference* is the reference to a subclass for _exactly one_
*Referenced Superclass*
* *Referenced Superclass* references subclasses via _at most one_
*Subclass Reference*

When a superclass in a reference generalization stores its reference to
its currently related subclass in a *Subclass Reference*.
If the superclass to subclass path of the generalization is not navigated,
then there need not be any associated Subclass Reference.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R92 SubclassReference 0..1--1 ReferencedSuperclass
----

=== R93

* *Associator Class* references participants via _exactly one_
*Associator Reference*
* *Associator Reference* is the reference for _exactly one_ *Associator Class*

An Associator Class must hold references to both participants of the
association and does so in an Associator Reference.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R93 AssociatorClass 1--1 AssociatorReference
----

=== R96

* *Union Superclass* stores subclass instances in _exactly one_
*Subclass Container*
* *Subclass Container* is the storage for subclasses of _exactly one_
*Union Superclass*

The use of a discriminated union to store associated subclass instances
in a superclass instance memory structure eliminates the need for
various reference pointers.
The Union Superclass stores the currently related subclass instance
in the Subclass Container that can be used to disinguish the type of 
the related subclass.
 
==== Implementation
[source,tcl]
----
<<platform relationships>>=
association R96 UnionSuperclass 1--1 SubclassContainer
----

== State Model Subsystem

=== Introduction

The class, relationship and reference subsystems describe how model level
concepts of classes and relationships are mapped to implementation level
concepts of structures and pointers.
In the state model subsystem we turn our attention to the dynamics
and sequencing of execution of the model.

The classes in the state model subsystem capture the essential information
of a Moore type state model along with the XUML conventions of how
to specify ignored and error transitions.
The sequencing of execution via dispatch of state machine events is
handled by the run time mechanisms of `micca`.
The run time is completely data driven.
So our focus in the platform model is to capture that data needed to
generate the data structures used by the run time mechanisms.
The implications of this are that the state model subsystem is relatively
platform independent.
There are no particular ``C'' language implications of dispatching events
to state machines.

Below is the UML class diagram for the state model subsystem of the platform
model.

image::platform-statemodel.pdf[title="State Model Subsystem Class Diagram"]

A *State Model* is of one of two types (*R50*),
an *Instance State Model* or an *Assigner State Model*.
An *Instance State Model* is associated with a *Class* (*R51*) and an
*Assigner State Model* is associated with an *Association* relationship (*R52*).
Both types of state models operate the same.
They contain a set of *States* (*R55*) and possibly a *Creation State* (*R56*).
A *State Model* has a default *Transition Rule* (*R59*) to resolve
unspecified transitions and an initial state (*R58*) to know where things
start.
A *State* has an executable activity and that activity may have
*Activity Parameters* (*R60*).
All the *States* and the *Creation State* constitute a *State Place* where
the state model can transition when it has an event dispatched to it (*R57*).
An *Assigner State Model* also consists of two types (*R53*),
*Single Assigner* and *Multiple Assigner*.
A *Single Assigner* has only a single instance while a
*Multiple Assigner* has a many instances as the *Class* that
partitions is behavior (*R54*).

=== State Model

A State Model is a finite automaton, specifically a Moore type state machine.
A State Model is used to define the sequencing of execution for the
lifecycle of its assocated class or assigner.

Domain \{I,R58}::
    The domain in which the state model resides.
[horizontal]
    Data Type::: Refers to State.Domain
Model \{I,R58}::
    The name of the class or association for which the state model operates.
    Data Type::: Refers to State.Model
InitialState \{R58}::
    The name of the state into which the a newly create state model is placed.
    Data Type::: Refers to State.Name
DefaultTrans \{R59}::
    The name of the default transition rule.
    Data Type::: Refers to Transition Rule.Name
 
==== Implementation

[source,tcl]
----
<<platform classes>>=
class StateModel {
    attribute Domain string -id 1
    attribute Model string -id 1
    attribute InitialState string
    attribute DefaultTrans string

    reference R58 State -link Domain -link Model -link {InitialState Name}
    reference R59 TransitionRule -link {DefaultTrans Name}
}
----

== Event Subsystem
Event Subsystem

=== Introduction

image::platform-event.pdf[title="Event Subsystem Class Diagram"]

== Transition Subsystem
Transition Subsystem

=== Introduction

image::platform-transition.pdf[title="Transition Subsystem Class Diagram"]

== Population Subsystem
Population Subsystem

=== Introduction

image::platform-population.pdf[title="Population Subsystem Class Diagram"]
