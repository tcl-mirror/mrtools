// vim:syntax=asciidoc:
= Notes on Relationship Operations

[abstract]
TBD

== Problem Statement

This paper explores the problem of how to formulate model level operations
to create, delete and update relationship instances in
https://en.wikipedia.org/wiki/Executable_UML[Executable UML]
(xUML).
There are two primary goals:

. Provide a consistent, well defined vocabulary to describe the operations.
. Insure the relationship operations can be translated across
all potential target platforms.

Current action languages use a notion of "relate" and "unrelate" or
"link" and "unlink" to express the relationship operations.
These operations are formulated using instance references.
For example:

* Let `xref` be a variable whose value is a reference to an instance of some
  class X.
* Let `yref` be a variable whose value is a reference to an instance of some
  class Y.
* Let `R1` be an association between classes X and Y.
  For simplicity,
  assume `R1` is a simple many-to-one unconditional association between X and Y.
  A class diagram fragment showing this might appear as follows.

image::X-Y-1-to-1.pdf[title="Example R1 Association"]

Most action languages have statements to create an instance of the R1
association between X and Y instances similar to:

----
relate xref to yref across R1
----

Complementary constructs are used to delete a relationship instance.

----
unrelate xref from yref across R1
----

The important point here is _not_ the syntax or keywords used,
but rather the implied operation and its arguments.

Comparing the diagram to the previous `relate` statement,
the statement implies that an instance of X may
be created (and a reference to that instance stored in the `xref` variable)
without supplying a value for the `Y_ID` attribute.
Otherwise, it would not be necessary to supply the `yref` value.
This is problematic if we insist, as we discuss later, 
that attributes must have a valid value at all times.

Similarly,
the `unrelate` statement requires that a reference to the related
Y instance be supplied as an argument.
This arrangement has several awkward aspects:

. The diagram implies that deleting an instance of X deletes the instance
of R1 because the `Y_ID` attribute which manifests the relationship
is no longer defined and it's not possible for the Y instance
to be related any longer to the non-existent X instance.
. If the activity invoking the `unrelate` operation
must supply an instance reference to the related instance
of Y (the `yref` value in this case)
then it is forced to navigate the association to obtain the instance reference.
Yet, the ``system'' knows what Y instance is related because that is
given by the value of `Y_ID` of the referenced X instance (the 
X instance referenced by the `xref` value in this case).
. What is the behavior of the `unrelate` statement if the value of `yref` does
not refer to the instance that is actually related to `xref`
or if it refers to an instance of some class other than Y?
Are we exposing a potential for undefined behavior that must be detected
at runtime and therefore placing subtle requirements on the
model execution runtime?

These action language constructs equate the idea of an instance of the
relationship with that of a ``link'' between the two instances.
Because most of these operations were formulated with statically
typed implementation languages in mind,
they have underlying assumptions implying that
operations on relationships involve pointers.
That is _not_ the case for all translation targets and the concept of
relationship linkage insinuates a correspondence to pointers that is
implementation dependent and therefore undesirable.

In this paper we will _not_ suggest any action language syntax for
the proposed operations.
Rather we stay focused on the semantics of the operations and the required
parameters.
Action languages should develop convenient syntax to support the
proper underlying operations.

== Fundamentals

Sadly, there is very little commonly accepted and
shared outlook or knowledge in software
engineering and this situation also extends to the xUML world.
So, we feel compelled to enumerate our basic assumptions.

* A software system is made up of one or more interacting _domains_.
  A domain is a subject matter decomposition of the system requirements.
  Domain interactions are governed by bridges which resolve the requirements
  and dependencies of one domain onto the services provided by other domains.
* A domain captures the requirements allocated to it using three facets:
  . A data facet that defines entities of concern to the domain.
    The data facet model is based on the well established
    principals of the relational model of data and abstract data types.
  . A dynamics facet which describes execution sequencing and synchronization.
    The dynamics facet model is based on finite state automata.
  . A processing facet which determines the algorithmic computations performed.
    The processing facet model is based on the data flow model of execution.

This paper is concerned with defining operation on relationships.
So, our goal is to determine the semantics of the operations used in the
processing facet to create and manipulate relationships that are defined in the
data facet.
We want to develop the relationship operations with several distinct
realms in mind.

xUML Class Model::
    We consider xUML class models as an _application_ of the relational
    model model of data.
    Thus, we need to have a direct mapping for all xUML data operations back
    to relational algebra.
    Eventually, everything must be able to be expressed in relational
    algebraic terms.
Implementations Based on Relational Data Management::
    One important Model Execution (MX) domain target manages its data
    using implementation components that support relational concepts
    (_e.g._ a Relational Database Management System).
    The relationship operations must be able to be readily translated
    onto MX domain implementations that use relationally based data
    management techniques.
Implementations Based on Statically Typed Programming Languages::
    Another very important MX target uses conventional
    programming languages that are statically typed and holds the
    class data in primary memory.
    In this case,
    the behavior of xUML data model operations must be simulated
    without having explicit relational data management facilities
    available.

== xUML Class Model Fundamentals

Since we consider an xUML class model to be based on the relational
model of data,
in this section we enumerate the correspondences between xUML terms
and relational model terms.

* An xUML class model is a normalized relational schema of at least
  https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form[Boyce-Codd Normal Form]
  (BCNF).
  xUML modelers rarely use normalization in the same manner as used
  for database design,
  despite sharing many of the same modeling concepts.
  This arises from the different approaches taken in the two fields.
  Database design often starts with an arbitrary collection of data
  which is then analyzed for its functional dependencies.
  xUML analysis starts from the propective of identifying and
  abstracting real-world entities and their associations
  according to a set of modeling rules.
  The result is that xUML class models tend to be formulated in normalized
  form from the outset since the modeling rules guide the analysis toward
  that end.

* A populated xUML class model is assumed to follow the
  https://en.wikipedia.org/wiki/Closed-world_assumption[_closed world assumption_]
  as it is typically applied to relational schema.

* An xUML _class_ corresponds to a _relvar_ (relation variable).
  Specifically, an xUML class defines the heading of a relation value
  that can be stored in a relation variable of the same type.
  In particular, note that an xUML class does _not_ correspond to an
  object oriented programming (OOP) language class
  nor does it correspond to an abstract data type as might be used
  as an attribute data type.
  An xUML class represents a logical predicate about the subject matter of the
  domain and its attributes define a characterization of a
  real-world entity with respect to the domain subject matter.
  This follows from the equivalency of relational algebra and
  first-order predicate logic.

* A class _attribute_ corresponds to an attribute of the relation
  header for the relation value held in the relvar corresponding to a class.
  Each attribute has a defined data type.
  Such data types may be _scalar_ or _non-scalar_.
  Data typing is an orthogonal concept to xUML classes.
  We will not discuss data typing here and note that this discussion depends
  only upon the existance of an equality operation for an attribute data type.

* A class _instance_ is defined to be a tuple of a relation value stored in a
  relvar. Thus the cardinality of the relation value stored in a relvar
  is the number of instances of a class.
  Since we intend an xUML class model to have an implementation on a
  computer, we implicitly assume that the number of class instances is
  finite.

* At all times, every attribute of every class instance must have a
  value selected from the set of values defined by the attribute data type.
  Consequently, there is no *NULL* value and no attribute may be
  assigned the value of *NULL*.
  There has been much written and discussed about *NULL* values in the
  relational model and we will not repeat it here.
  We do note that there is much confusion over the concept of *NULL* as
  might be used in a modeling context and the use of `NULL` or `nil` values
  in a programming language context.
  They are not the same thing and we see no benefit to using *NULL* in a
  modeling context despite the usefulness of `NULL` or `nil` in a programming
  context.
  Null values are excluded on two accounts:
  . They are unnecessary adding nothing to the expressiveness of the
  modeling constructs.
  . They introduce the need for three-valued logic which is a major, unwelcome
  complication.


* Each xUML class must have at least one identifier (this follows from
  the normalization requirements).
  An identifier is a set of class attributes whose values, as a set, must be
  unique for all instances of the class.
  An identifier corresponds to a
  https://en.wikipedia.org/wiki/Candidate_key[_candidate keys_]
  in the relational model.
  Consequently, the set of attributes that constitute an identifier
  may _not_ be a subset, proper or improper, of any other identifier's
  attribute set (this also follows from the normalization requirements).
  However, it is not uncommon that the intersection of the attribute
  sets of the class identfiers be non-empty.

* An _instance reference_ [[instance-reference-def]]
  is a means to refer to one or more class instances.
  It is defined as a relation value whose heading is
  the projection of one of the identifiers of the class to which it refers.
  Since the values contained in such a projection are functionally related
  to the values of the other attributes of the instance,
  it is possible to obtain the set of instances to which the instance
  reference refers by performing a `semijoin` operation between the
  instance reference and the class relvar.
  Note that we make no distinction between an instance reference that
  refers to multiple (or even zero) instances and one that references
  only a single instance.
  The set aspects of a relation value handle all cases.

== Relationships in XUML

In xUML, relationships model real-world associations between classes.
The semantics of the relationship are indicated by verb phrases
attributed to each side and the phrases appear on the class diagram.
A relationship is _manifested_ by a referential integrity constraint.
The integrity constraint is formed by requiring
_referential attributes_ in
one class to have the same values as _identifying attributes_ in another
class (possibly the same, in which case the relationship is _reflexive_).

Relationships are used for two distinct purposes:

. Constaining the membership of the participating classes.
. _Navigating_ from instances of one class to instances of a related class.

As we discuss below,
relationships can be viewed as functions or partial functions.
The functional view coincides well with the use of verb phrases to
describe the relationship semantics since we usually associate functions
with some sort of action.
Navigating a relationship is logically equivalent to invoking a function on a
subset of the function's domain to obtain the image of that function in the
codomain.
From a relational algebra point of view,
relationship navigation is accomplished by the `semijoin` operation
(or the `semiminus` operation for the intent is to find the unrelated
instances).
In relational algebra,
we do not have the restriction of only
navigating along the defined referential constraints.
We may perform a `semijoin` between any two relvars and get some result
as long as the join attributes have the same data type,
even if we are compelled to rename attributes.
However, the result could be meaningless if the join attributes have
no logical correlation.
Navigating using the referential attributes of a relationship insures
both the data type requirements and maintains logical meaning.


There are two distinct types of relationships:

. Associations are mappings between the instances in one class to
those in another.
An association can be viewed as a binary relation that is a subset of the
Cartesian product of a projection of the identifiers of the participating
classes.

. Generalizations represent a set partition of a superclass into
a set of subclasses. The set of subclasses of the generalization
are disjoint and the union of the subclasses is equal to the superclass
(specifically, the intersection of the projection of the subclass
identifiers is empty and the union of the projection of the subclass
identifiers equals the projection of the superclass identifier).

=== Association Relationships

Association relationships are characterized by their _conditionality_
and _multiplicity_.
Conditionality determines if all the instances of a class must
participate in the relationship.
Multiplicity determine if a class instance may participate in the
relationship more than one time.
The various combinations of multiplicity and conditionality give rise
to additional classifications for associations.

Simple associations::
    are those associations that are singular and unconditional on
    at least one side.
    They are considered _simple_ in the since that it is possible to
    eliminate the associative class that manifests the association mapping.

Partial function associations::
    are those associations which have conditionality on at least one
    side.
    In this case, navigating the association in the direction of the
    conditionality can result in no instances being found.

Many valued associations::
    are those association where there may be multiple mappings between 
    the same instances.
    These types of associations have, of necessity, at least one additional
    identifying attribute in the associative class.

There are 10 distinct combinations of multiplicity and conditionality
for associations.
In this section,
we show each case and discuss the characteristics of the association.
Each is shown in a diagram.
Each diagram contains a set-oriented graphic emphasizing the
association as a function between two sets.
We also show the same information using UML class diagram notation.

Relationships and their correspondence to functions are discussed and their
properties are characterized.
However, it is notable that our intent here is different than
that usually associated with mathematical discussions of functions.
In mathematics,
the sets over which the function operates are usually given and it is the
properties of the function that are of interest.
For example,
we may say that
latexmath:[$f(x) = 2x + 1$]
is a function from
latexmath:[$\mathbb{R} \to \mathbb{R}$]
and then discuss the properties of
latexmath:[$f(x)$]
(in this case it is injective).
From a modeling perspective,
we tend to take the opposite point of view.
Namely, we fix the properties of the functions since those properties relate
to the problem semantics.
Since the membership of the sets is *not* constant and changes over the
execution time of the domain,
the relationships then serve to constrain the set membership to insure
the _a priori_ function properties are *not* violated.
For example,
in a one-to-one unconditional association, creating an instance in one
participant of the association requires creating a related instance in order to
maintain properties of the function that underlies the association.
Failure by the model processing to maintain the set membership to match the
association function properties results in a failed transaction on the data
model.

Because the class instance sets are finite,
we can describe the association function by enumerating a binary relation
containing the mapping elements
(as opposed to using a formula to define the function).
From the relational point of view,
we define a relvar of degree two whose attributes refer to the
identifiers of the association participants.
Each tuple in the associative relvar then represents an instance of the
association itself.
We start by formulating all associations in this manner
and then show how some associations under certain conditions may
be simplified in a way that eliminates the need for the
correlating relvar.

The first four sections below describe the simple association cases.
Next come the partial function associations and finally we show
the many valued associations.
Once we have seen the characteristics of all 10 cases,
we will be in a position to discuss operations on associations
and the case-by-case discussion will allow us to verify and exercise those
operations.

==== One to One Association

The following
<<association-1to1,diagram>>
shows the properties of a one-to-one association.

The top of the diagram shows the mapping of instances of X to instances
of Y in a traditional set oriented graphic.
The relationship, R, is a function taking elements of the X set into
elements of the Y set, _i.e._ R : X -> Y.
X is the _domain_ of R, and Y is the _codomain_ of R.
R is a bijective function.

The middle section of the diagram shows the same information in
UML class diagram notation.
Here the notion of class identifiers has been made explicit.
For simplicity but without the loss of any generality,
we use identifiers that have only a single attribute.
The R Assoc class is a relvar of degree two containing the identifiers
of the participating X and Y classes.
Note that either the X identifier or the Y identifier may serve
as the identifier for R Assoc.

Because of the multiplicity and conditionality,
we know that the number of instances of R Assoc must equal both the
number of instances of X and the number of instances of Y.
Under the special circumstances that R Assoc has no additional attributes,
_i.e._ the abstraction associated with R only characterizes the
functional mapping between X and Y,
then the association may be simplified by eliminating the
R Assoc class and including a referential
attribute in either the X or Y class.
This is shown at the bottom of the diagram.
Either representation may be chosen and xUML models tend to make the
choice based on clarifying semantic intent.

[[association-1to1]]
image::1to1.pdf[title="One-to-one Association"]

==== At Most One to One Association

The next case is an at-most-one to one association.
The following diagram shows characteristics of associations of this
multiplicity and conditionality.

The depiction of R in set-based notation shows that some elements of
Y (_i.e._ those colored red) do not participate in the association.
R is still a function, but in this case it is an injective function.
Consequently, the image of R under X is a subset of Y and the
inverse of R is a partial function.

The implications of this arrangement are that for some elements of Y,
the inverse of R is undefined.
Thus it is possible when navigating from Y to X across R,
to obtain an empty result.
From a relational algebra point of view,
it is possible to select a subset of Y such that the semijoin of the
subset to the relation value held in the X relvar
yields an empty relation of with the heading of X.
It holds in general, that conditionality on one side of an association
implies that an empty traversal is possible and activity code must
take into account that no instances will have been found in the
association traversal.

The UML notation in the middle of the diagram shows R Assoc as the
associative class that manifests the functional mapping of R.
Note that the cardinality of R Assoc is equal to the cardinality
of X but may be less than the cardinality of Y.
Thus when the simple association conditions hold,
R Assoc may be eliminated, but the referential attribute must be
placed in X.

image::0-1to1.pdf[title="At most one-to-one Association"]

==== At Least One to One Association

The diagram below shows an at-least-one to one association.

The depiction of R in set-based notation shows that multiple
elements of X may map to the same element of Y.
R is a surjective function and its inverse is multi-valued.

The UML representation shows,
the R Assoc class is identified by X_ID.
This is because the number of instances of R Assoc
equals the number of instance of X.
This is another way of stating that the preimage of R is equal to X.
Again, under the simplifying conditions,
R Assoc may be eliminated by placing the Y_ID referential attribute
in X.

image::1-Mto1.pdf[title="At least one-to-one Association"]

==== Any to One Association

The last case of simple associations is the any-to-one association
as shown in the following figure.

The set-based graphic shows that some instances of Y are not mapped
by R (shown by the red circles in Y).
R is a function, but it is neither injective nor surjective.
The inverse of R is both partial and multi-valued.

The UML diagram shows that R Assoc is identified by `X_ID`
since the number of instances of R Assoc equals that of X.
This association may also be simplfied to eliminate the R Assoc
class, including the `Y_ID` referential attribute in X.

image::0-Mto1.pdf[title="Any-to-one Association"]

==== At Most One to At Most One Association

The remaining permutations of multiplicity and conditionality are such
that he simplification we were able to make in the previous four cases
is not available.
In the next three association types,
the simplification is not available because of the conditionality
of the association.
For the three association types after that, the simplification is
not available because of the multiplicity of the association.

The figure
<<association-0-1to0-1,below>>
shows a conditional one-to-one association.
As before,
X is the domain and Y is the codomain.
In this case however,
R is a partial function,
_i.e._ not all elements of X have a mapping under R.
It is also the case that not all elements of Y are mapped.
Consequently, the image of R over X is a subset of Y,
and the preimage is a subset of X.
Note, that for some elements of X, R is undefined and,
in the inverse case,
for some elements of Y, the inverse of R is undefined.

When represented in UML notation,
it is necessary to have an associative class (R Assoc in the figure),
which explicitly enumerates all the instances of R.
Because of the singular nature of the association,
both the X identifier and the Y identfier are identifiers of R Assoc.

Past formulations of xUML have advised simplifying this type of association
by folding an identifying attribute into X or Y as we had done in the
previous cases.
This is problematic because such a simplification cannot represent the
conditionality without resorting to the use of `NULL` or some other _special
value_ for the referential attribute.
Since we have required that every attribute contain a value from it
defined data type and since `NULL` is not a value of any data type,
a referential attribute value cannot indicate the conditionality of
the association.
Using a special value of for the attribute to indicate that the instance
is not related is also not acceptable.
Since data types define all the allowed values, there are no special
ones in the set.
Often, special values are chosen as being a value in some underlying
system supplied data type that happens not to be used in the subset
of the system type used by the attribute.
For example, we might choose -1 as a special value for an attribute
implemented in a system supplied integer type knowing that
only non-negative values of the system type are used as attribute values.
But this simply conflates unwelcome implementation constructs into the model.
Special values also imply special processing in the activities of the
model to recognize the conditionality of the association.
Recognizing that the instances of the association class have a one-to-one
correspondence to the instances of the relationship saves all
the unpleasantness of `NULL` and special values.
We can recognize that the relationship is conditional when navigating
from one participant to another yields the empty relation for the
destination class.
Some analysts object to adding another class to the class model.
We fail to understand such reluctance and think the association classes
convey significant meaning about the real-world association being modeled.
Translation mechanisms may choose any convenient means at their disposal
if they wish to optimize away the association class for this type
of association.


[[association-0-1to0-1]]
image::0-1to0-1.pdf[title="At most one-to-at most one Association"]

==== At Least One to At Most One Association

The figure
<<association-1-Mto0-1,below>>
shows a conditional many-to-one association.
In this case,
all instances of Y are mapped, but some instances of X
(_i.e._ those shown in red)
do not participate in the function.
Thus, R is a partial function.
Since the image of X under R is Y,
we can think of R as begin a partially injective function.
The preimage of R is a subset of X and the inverse of R
is a multi-value function.

When represented in UML class diagram notation,
the R Assoc class is the associative class.
Instances of R Assoc represent instances of the class.
Note that the identifier of X is sufficient to identify the
R Assoc instances.

[[association-1-Mto0-1]]
image::1-Mto0-1.pdf[title="At least one-to-at most one Association"]

==== Any to At Most One Association

The many-to-one biconditional association is shown in the following
<<association-0-Mto0-1,figure>>.
This association allows for instances in X not to participate in
R.
So not only is R a partial function so is the inverse of R.
When defined,
the inverse is also multi-valued.

With this multiplicity and conditionality,
the cardinality of R Assoc is less than or equal to the cardinalities
of both X and Y.
This implies that there are no simplifications available to dispense
with the R Assoc class.
Note that the identifier of X (as also a referential attribute)
serves as the identifier of R Assoc.

[[association-0-Mto0-1]]
image::0-Mto0-1.pdf[title="Any-to-at most one Association"]

==== At Least One to At Least One Association

The last three cases involve many-to-many associations.
In all these cases,
the associative class is a subset of the Cartesian product of the
two participant classes.

The following
<<association-1-Mto1-M,figure>>
shows the many-to-many unconditional case.
The set functions are multi-valued.
The cardinality of R Assoc is greater than or equal to the
cardinalities of both X and Y.
So,
to identify an instance of R Assoc requires both the X and Y identifiers
(which are also used referentially).

[[association-1-Mto1-M]]
image::1-Mto1-M.pdf[title="At least one-to-at least one Association"]

==== At Least One to Any Association

The many-to-many and conditional on one side association allows
instances of X (as shown in red in the following
<<association-1-Mto0-M, figure>>)
not to be related to any instance of Y.

[[association-1-Mto0-M]]
image::1-Mto0-M.pdf[title="At least one-to-any Association"]

==== Any to Any Association

The many-to-many biconditional case allows instances from both X and Y
to not be related as shown in the following
<<association-0-Mto0-M,figure>>.

[[association-0-Mto0-M]]
image::0-Mto0-M.pdf[title="Any-to-any Association"]

=== Reflexive Association Relationships

In the previous examples,
we have assumed that the X and Y classes are distinct.
Reflexive associations are also possible where the participant
classes are the same.
Since the association is between members of the same set,
it is not possible to have the conditionality of the association
different on the two ends.
This reduces the number of distinct combinations for reflexive associations
to six, namely:

* One _to_ one (1 _to_ 1)
* At least one _to_ one (1..* _to_ 1)
* At least one _to_ at least one (1..* _to_ 1..*)
* At most one _to_ at most one (0..1 _to_ 0..1)
* Any _to_ at most one (0..* _to_ 0..1)
* Any _to_ any (0..* _to_ 0..*)

We do not provide any diagrams for the reflexive case since they are
a simple variation on the diagrams provided before.

=== Summary

Some insight can be gained by putting the conditionality and multiplicity
combination into a tabular form.footnote:[The idea of using a matrix
to show the conditionality and mulitiplicity comes from a private
communication with Paul Higham.]

.Matrix of Association Relationships
[options="header,unbreakable",width="50%",cols="h,4*^"]
|===================
|       |1      |0..1   |1..*   |0..*
|1      |F R S  |       |       |
|0..1   |F S    |P R    |       |
|1..*   |F R S  |P      |-      |
|0..*   |F S    |P R    |-      |-
|===================

F =>::
    Association is a function.
P =>::
    Association is a partial function.
R =>::
    Association may be reflexive.
S =>::
    Association may use simplified form.

== Referential Attributes

<<instance-reference-def,Previously>>,
we introduced the concept of an instance reference as a means of
referring to an instance of a class.
The definition presented was in relational terms.
In xUML we need an instance reference concept since many operations
are directed at a particular instance (_e.g._ signaling an event).


/////////////////
== xUML Relationship Operations
We specifically want to develop XUML operations associated with
relationship instantiation that does not involve refering to the
referential attributes.
This may seem strange,
but by eliminating the referential attributes from the operations
enables us to translate to architectures that do not use an
underlying relational data management scheme.
As long as we can do this and still be able to formulate the
operations in relational algebraic terms,
we are still on sound ground and have a more useful formulation of
the relational principles in XUML.

In fact we go one step farther and say that in XUML activities,
updating the value of a referential attribute is forbidden.

== Creating Association Instances
For class based associations an instance of the association is created
when an instance of the associator class is create.
From a relational point of view,
we must supply a value for every attribute whenever we create an instance
and that includes the referential attributes.
So we can formulate a creation rule for XUML that says:

*****
Creating an associative class requires supplying instance references
to the two participating instances in addition to the values of
any other attributes.
*****

By knowing instance references to the participating classes,
an architecture can determine the values of the identifiers of the
participants and thereby know the values to use for the referential attributes.

=== Creating Simple Associations
For the case of simple associations,
the association instance is created whenever an instance of the
S class is created.
So, the same rule applies.
If a class is the referring source class for a simple association,
then the creation operation must be supplied with an instance reference
to the related instance.

== Deleting Association Instances
Again from the relational,
an instance of a class based association is deleted whenever the
associator instance is deleted.
The same is true for deleting a source instance in a simple association.
The instance is gone, the referential attributes are not accessible
and whether or not that leaves the data in a consistent state is determine
at the end of the data transaction.

== Updating Association Instances
From the relational point of view,
we can update an association by updating the values of the referential
attributes.
Since we do not want to formulate the XUML operation using
referential attributes,
we do so using an instance reference.
So an association instance can be updated by supplying an instance reference
to the new instance.
The architecture can determine the values of the identifiers of the
instance and use those values to update the referntial attributes.

== Implications for Statically Typed Implementations
When translating to conventional computing target with a conventional
programming language,
architectures usually choose to construct an identifier for instances
to be the memory address of the object and to use that constructed
identfier to implement the referential aspects of the data model,
both consistency and navigation.
Indeed part of the reason to formulate the association operations for XUML
without referential attributes is to support this type of translation.
The advantage to the implementation is just so great that the technique
cannot be ignored.

The architectures that are constructed in this way use pointers in place
of referential attributes.
In all the cases we discussed,
as single, non-NULL, address will implement the referential nature of
either an associator instance or the reference made by a source class
in a simple association.

However,
to navigate the relationships in the opposite directions,
the architecture invariably inserts additional pointers into the
instance structures.
These pointers aleviate the need to perform a search of the pool
of instances in order to go "backward" in a navigation.
Strictly speaking, the added pointers are redundant.
Because they are redundant,
it is the responsiblity of the architecture to deal with them in terms
of keeping them up to date and consistent when created or modified.
These pointers form a set of "back links" and it is worth examining
what has to happen to the back links in light of the above
definitions of how association are manipulated.
/////////////////
