[manpage_begin micca 1 1.0a2]
[comment {
# This software is copyrighted 2015 - 2017 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
}]
[moddesc "XUML Model Translation"]
[titledesc "Executable Model Translation to C"]
[copyright "2015 - 2017 by G. Andrew Mangogna"]

[description]

[list_begin definitions]
[call "[cmd "micca"] [arg options] [arg file1] [arg [opt "file2 ..."]]"]

[cmd Micca] is a program that transforms a domain specific language (DSL)
script of an Executable Model into "C" code to implement the
logic of the model.
The DSL is defined in the [cmd micca-DSL] manual page.
[list_end]

available [option options] are:
[list_begin options]
[opt_def -version]
Print out version and copyright information and exit.
[opt_def -stubexternalops]
Include external operation code in output.
[opt_def -nogenerate]
Don't generate any output files.
[opt_def -save [arg filename]]
Save the domain configuration in a file name, [arg filename].
If this option is absent, the domain configuration is saved to a
file named [file miccasave.ral] in the current directory.
[opt_def -savesqlite [arg filename]]
Save the domain configuration to a SQLite database named, [arg filename].
[opt_def -posix]
Output the POSIX version of the run time code and exit.
[opt_def -efm32gg]
Output the EFM32 Giant Gecko version of the run time code and exit.
[opt_def -msp432]
Output the MSP432 version of the run time code and exit.
[opt_def -msp430]
Output the MSP430 version of the run time code and exit.
[opt_def -doc]
Output the manual page documentation in HTML format in the
[var miccadoc] directory.
[opt_def -expanderror error]
How macro expansion errors are handled.
By default, they fail throwing an error.
[opt_def --]
Stop option processing.
[opt_def -help]
Print a help message.
[opt_def -?]
Print a help message.
[list_end]

[section "Building A Micca Application"]

A successful run of [cmd micca] yields two files: a "C" source file and
a "C" header file.
To link a running application,
the [fun main] function must be supplied.
The following is an example of how the [fun main] function might appear.

[example {
#include <stdlib.h>
#include "micca_rt.h"

int
main(
    int argc,
    char *argv[])
{
    /*
     * Hardware and other low level system initialization is usually done
     * first.
     */

    /*
     * Initialize the run-time code itself.
     */
    mrt_Initialize() ;

    /*
     * Initialize domains, bridges and any other code that might require access
     * to the facilities of the run-time code. Typically, each domain in the
     * system would have an "init()" domain operation and these can be invoked
     * here. Sometimes domain interactions are such that a second round of
     * initialization is required.  Bridges between domains may also require
     * that the initialization for a domain be done before the bridge can be
     * initialized. Once mrt_Initialize() has been invoked, domains may
     * generate events and do other model level activities.  Regardless of how
     * the initialization is accomplished, it is system specific and,
     * unfortunately, only temporally cohesive.
     */

    /*
     * Entering the event loop causes the system to run.
     */
    mrt_EventLoop() ;

    /*
     * It is possible that domain activities can cause the main loop to exit.
     * Here we consider that successful. Other actions are possible and
     * especially if the event loop is exited as a result of some unrecoverable
     * system error.
     */
    return EXIT_SUCCESS ;
}
}]

The required elements of main are to invoke [fun mrt_Initialize()]
before any run-time elements might be needed and to invoke
[fun mrt_EventLoop()] to cause the system to run.

[section "Running A Micca Application"]

The runtime provides several functions that are used to control
the state machine event dispatch mechanism.s.

[list_begin definitions]

[call [fun "void mrt_Initialize(void)"]]

The [fun mrt_Initialize] is invoked to initalize all the internal
data structure of the micca run-time.
It must be invoked before any other run-time function.

[call [fun "void mrt_EventLoop(void)"]]

The [fun mrt_EventLoop] function is the preferred way for a
micca generated application to run.
This function dispatches events, causing the system
to execute, and will not return unless
some action in the domain invokes [fun mrt_SyncToEventLoop].

[call [fun "bool mrt_SyncToEventLoop(void)"]]

A state activity may invoke [fun mrt_SyncToEventLoop]
to request that the run-time event loop exit and return to its caller
(typically [fun main]) at the end of the current ongoing thread of control.
The return value is a boolean indicating whether the event loop
was requested to exit (true).
This function provides a way for domain activities to stop the system
from running without causing an explicit error.

[list_end]

[section "Controlling the Event Loop"]

The [cmd micca] run time provides two function to have finer
control over dispatching events.
Using these functions is [emph not] the preferred way to cause
a [cmd micca] generated application to run, but they are
useful in test situations and when it is necessary to integrate
with legacy applications that might have their own event loop.

[list_begin definitions]

[call [fun "bool mrt_DispatchThreadOfControl(bool wait)"]]

[list_begin arguments]
[arg_def bool wait]
A boolean value that determines if the function waits for an event to
begin the thread of control if there is no thread of control currently
ready to run.
Waiting is useful if the thread of control will be started by
a delayed signal.
[list_end]

The [fun mrt_DispatchThreadOfControl] function runs at most one thread
of control before returning to the caller.
It returns a boolean value indicating if a thread of control was
actually run.
A thread of control is started when an event that was signaled outside
any instance context ([emph e.g.] by a domain operation or by a
portal operation)
or a delayed signal whose delay time has expired is dispatched.
The thread of control continues until all the events have been delivered which
were signaled from within any instance context as a direct or indirect result
of any transition caused by the event that started the thread of control.
[para]
At the end of the thread of control,
the referential integrity implied by the relationships of the
domain is evaluated.
Any class where instances of the class were created or deleted
or any of the relationships in which a class participates are modified
will be evaluated to determine if the constraints implied by
the relationships of the domain are preserved.

[call [fun "bool mrt_DispatchSingleEvent(void)"]]

The [fun mrt_DispatchSingleEvent] function dispatches at most one event
from the event queue and returns a boolean indicated if an event was
dispatched.
If the dispatched event ended a thread of control,
then the normal processing associated with ending a thread of control happens
(i.e. referential integrity is checked).
This function provides a means of fine grained control over event dispatching
that can be useful in testing situations or when it is necessary to
integrate [cmd micca] generated domains with legacy code.

[list_end]

[section "Fatal Error Handler"]

[list_begin definitions]

[call [fun "typedef void (*MRT_FatalErrorHandler)(MRT_ErrorCode, char const *,\
    va_list)"]]
[call [fun "MRT_FatalErrorHandler mrt_SetFatalErrorHandler(MRT_FatalErrorHandler newHandler)"]]

Applications may substitute their own fatal error handler for the
default one.
All error detected by the run-time cause a fatal error condition.
By default,
a message printed to the standard error and the standard library
function, [fun abort()] is invoked.
Application can install a new hander by invoking
[fun mrt_SetFatalErrorHandler] which returns a pointer to the previous
handler.
If the application supplied error handler returns,
the run-time will still invoke [fun abort()] to insure that no further
attempts to dispatch events is made.

[para]
Application supplied error handlers may also use
the standard library functions, [fun setjmp()] and [fun longjmp()] to
perform a non-local transfer of control.
This allows the application to exert finer control over error situations.
[emph "N.B. that restarting event dispatch after a fatal error must\
be done with great care."]

[para]
The following example shows one way to return execution control to
an application if a fatal error occurs.

[example {
#include <setjmp.h>
#include "micca_rt.h"

static jmp_buf fataljmp ;
static MRT_FatalErrorHandler prevHandler ;

static void
jumpFatalHandler(
    MRT_ErrorCode errNum,
    char const *fmt,
    va_list alist)
{
    /*
     * Print a message using the default error handler.
     */
    prevHandler(errNum, fmt, alist) ;
    /*
     * Non-local goto to return control back to main.
     */
    longjmp(fataljmp, errNum) ;
}

int
main(
    int argc,
    char *argv[])
{
    /*
     * Initialize the run-time code itself.
     */
    mrt_Initialize() ;


    prevHandler = mrt_SetFatalErrorHandler(jumpFatalHandler) ;

    for (;;) {
        int errCode = setjmp(fataljmp) ;
        if (errCode == 0) {
            /*
             * The first time through, we enter the event loop to cause the
             * application to run. "mrt_EventLoop()" does not return unless
             * some domain action invokes "mrt_SyncToEventLoop()".  So in the
             * event that we return from the event loop, it was purposeful and
             * we probably want to end the application.
             */
            mrt_EventLoop() ;
            break ;
        } else {
            /*
             * Control returns here in the event of a fatal error in the
             * run-time. The value of "errCode" is the fatal error number.  The
             * application can do anything it wishes. If the application
             * determines that the program should end, then executing a break
             * statement here (as is done below) will accomplish that.
             * Otherwise, it may wish to take whatever corrective action or
             * other notifications are necessary.  Falling through this else
             * clause will restart the event loop.
             */
            break ;
        }
    }

    return EXIT_SUCCESS ;
}
}]

This technique can be used effectively when testing if the test case can
force a fatal error and then repair the state of things after
jumping out of the event loop.
Then the event loop can be restarted.

[list_end]

[see_also rosea]

[keywords translation]

[manpage_end]
