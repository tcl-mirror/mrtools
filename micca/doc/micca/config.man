[manpage_begin micca-DSL n 0.1]
[comment {
# This software is copyrighted 2015 - 2016 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
}]
[moddesc "Micca Configuration DSL"]
[titledesc "Commands for Defining a Domain"]
[copyright "2015 - 2016 by G. Andrew Mangogna"]
[description]
This manpage describes the [cmd micca] DSL.
When translating an executable model using [cmd micca],
the model is transcoded into the DSL described in this manual.
The DSL is implemented as an internal DSL
in Tcl and the script follows Tcl syntax rules.

[section Commands]

At the highest level,
the commands in this section allow you to define the characteristics
of a domain and its initial instance population.

[list_begin definitions]
[call [cmd domain] [arg name] [arg script]]

The [cmd domain] command defines a domain named, [arg name], and evaluates
[arg script] in a context where commands in [arg script] may be used to define
the characteristics of a domain.
The [arg script] argument should contain invocations of the
[sectref "Domain Commands" "domain commands"]
described below.

[example {
domain wmctrl {
    # A script containing domain commands to define the domain.
    ...
}
}]

[call [cmd population] [arg domain] [arg script]]

The [cmd population] command is used to define the initial instance
population for the domain named, [arg domain].
The [arg script] argument should contain commands
that define the attribute values, relationship linkages and
storage allocations for [arg domain].
It is evaluated in a context where the
[sectref "Population Commands" "population commands"]
described below are available.

[example {
population wmctrl {
    # A script containing populations commands to define the initial
    # instance population and storage allocation for the domain.
    ...
}
}]

[list_end]

[section "Domain Commands"]

The commands in this section are used to define the characteristics
of a domain using the [cmd micca] DSL.
These are the commands that are available when the [arg script]
argument of the [cmd domain] is evaluated.

[list_begin definitions]

[call [cmd class] [arg classname] [arg script]]
The [cmd class] command defines a class named, [arg classname].
The [arg script] argument is a script that is evaluated in a context where
[sectref "Class Commands" "class commands"]
are available to define the characteristics of the class.
The [cmd class] command may invoked multiple times for the same
[arg classname] and the class definition is cumulative.

[example {
class Pump {
    # Commands that define the characteristics of the Pump class.
    ...
}
}]

[call [cmd association] [arg name]\
    [arg [opt "-associator class"]]\
    [arg [opt "-static | -dynamic"]]\
    [arg [opt --]]\
    [arg source] [arg spec] [arg target] [arg [opt script]]]

The [cmd association] command defines an association relationship
called, [arg name],
between a [arg source] class and [arg target] class.
Traditionally,
association names follow a naming convention of a capital R followed
by a number ([emph e.g.] R27),
but any non-empty string [emph not] starting with a tilde character (~)
is allowed.
The forward direction of navigating the relationship is from [arg source]
to [arg target].
For simple associations ([emph i.e.] those not involving a associator
class),
the [arg source] class serves as the refering class
([emph i.e.] it contains the referential attributes formalizing
the association)
and the [arg target] class serves as the referenced class
([emph i.e.] it contains the identifier to which the referential
attributes of the [arg source] class refer).
The conditionality and multiplicity of the association is given by the
[arg spec] argument.
The [arg spec] argument must take one of the following forms:

[list_begin options]
[opt_def "1--1"]
    The association is [emph one] to [emph one].
[opt_def 0..1--1]
[opt_def ?--1]
    The association is [emph "at most one"] to [emph one].
[opt_def 0..1--0..1]
[opt_def ?--?]
    The association is [emph "at most one"] to [emph "at most one"].
[opt_def 1..*--1]
[opt_def +--1]
    The association is [emph "one or more"] to [emph one].
[opt_def 0..*--1]
[opt_def *--1]
    The association is [emph "zero or more"] to [emph one].
[opt_def 1..*--0..1]
[opt_def +--?]
    The association is [emph "one or more"] to [emph "at most one"].
[opt_def 0..*--0..1]
[opt_def *--?]
    The association is [emph "zero or more"] to [emph "at most one"].
[opt_def 1..*--1..*]
[opt_def +--+]
    The association is [emph "one or more"] to [emph "one or more"].
[opt_def 0..*--1..*]
[opt_def *--+]
    The association is [emph "zero or more"] to [emph "one or more"].
[opt_def 1..*--0..*]
[opt_def +--*]
    The association is [emph "one or more"] to [emph "zero or more"].
[opt_def 0..*--0..*]
[opt_def *--*]
    The association is [emph "zero or more"] to [emph "zero or more"].
[list_end]


A class based association is indicated by the [arg -associator] argument
with [arg class] begin defined as the associator class.
Note that [cmd micca] will insist that any association whose
multiplicity and conditionality on the [arg target] class side
is [var 0..1] or where both sides have a multiplicity greater than one
be formalized using an associator class.
This is the same as disallowing any of a [emph NULL] value for
a referential attribute and insisting the instances of the
association track the instances of the associator class.

If the [arg -static] argument is given then the association is
defined to be static and the number of instances of the association 
itself cannot vary during the run time of the domain.
If the [arg -dynamic] argument is given or neither [arg -static]
or [arg -dynamic] is given,
then the instances of the association are assumed to vary during the
run time of the domain.
These options allow [cmd micca] to choose the appropriate data structures
for relationship storage given the run time behavior of the relationship.

The association command may have an optional [arg script] argument.
If [arg script] is present,
then the association is defined to have an assigner and
[arg script] is evaluated to define the characteristics of the assigner.
The [arg script] is evaluated in a context where
[sectref "Assigner Commands" "assigner commands"]
are available to define the characteristics of the association assigner.

[example {
association R13 -static WashingMachine 1--1 Tub

association R22 -associator Ownership Dog 1..*--0..* Owner

association R2 -associator Service Clerk 0..1--0..1 Client {
    statemodel {
        # State model for assigning clerks to clients.
    }
}
}]


[call [cmd generalization] [arg name] [arg [opt "-union | -reference"]]\
        [arg super] [arg sub1] [arg sub2] [arg [opt ...]]]

The [cmd generalization] command defines a generalization relationship
called, [arg name].
Traditionally,
generalization names follow a naming convention of a capital R followed
by a number ([emph e.g.] R27),
but any non-empty string [emph not] starting with a tilde character (~)
is allowed.
The [arg super] is the name of a class that will serve as the superclass
in the generalization.
The [arg subN] arguments give the names of the subclasses of the
generalization.
At least two subclasses must be given.
If the [arg -union] argument is given,
then subclasses will be stored in a union within the structure of the
superclass.
If the [arg -reference] argument is given or if neither [arg -union]
nor [arg -reference] is present,
the subclasses are stored separate from the superclass and instance
references are used to implement the generalization relationship.

[example {
generalization R12 Lamp TableLamp FloorLamp

generalization R32 -union Washer FrontLoader TopLoader
}]

[call [cmd domainop] [arg rettype] [arg name] [arg parameters] [arg body]\
        [arg [opt comment]]]

The [cmd domainop] command defines a domain operation called, [arg name].
A domain operation is translated to a "C" function of external scope.
The "C" return type of the function is given by the [arg rettype] argument.
Formal parameters to the operation are given as a list
of parameter name / parameter type pairs in the [arg parameters] argument.
The code for the domain operation is supplied in the [arg body]
argument.
If present, the optional [arg comment] argument text is inserted as
a comment in the generated header file for the domain just before the
external declaration of the domain operation function.
This provides a convenient way to provide addition information to users
of the domain operation in the generated header file.

[example {
domainop void startWasher {washerID MRT_InstId when MRT_DelayTime} {
    // C Code to start a washing machine.
} {
Use this operation to start a washing machine.
}
}]

[call [cmd externalop] [arg rettype] [arg name] [arg parameters] [arg body]\
        [arg [opt comment]]]

The [cmd externalop] command defines an external operation called,
[arg name], which
the domain assumes will be supplied out side of the domain definition.
An external operation is translated into an exteral function reference.
The "C" return type of the function is given by the [arg rettype] argument.
Formal parameters to the operation are given as a list
of parameter name / parameter type pairs in the [arg parameters] argument.
"C" code may be supplied as the [arg body] argument.
By default, the code is [emph not] placed in the output,
but to aid in testing and simulation,
the [cmd micca] translator has an option to include the code in the
translated output.
If present, the optional [arg comment] argument text is inserted as
a comment in the generated header file for the domain just before the
external declaration of the external operation function.

[example {
externalop {char const *} MSG_Get_message {lang {char const *}} {} {
Get a message from the MSG external entity.
}
}]

[call [cmd typealias] [arg name] [arg definition]]

The [cmd typealias] command defines a new data type name, [arg name],
and equates it to the "C" type defintion given by [arg definition].

[example {
typealias Direction_t enum {
    Up, Down
}
}]

[call [cmd interface] [arg text]]

The [cmd micca] code generator produces a header file for the domain.
The [cmd interface] command will insert [arg text] near the beginning
of the generated header file.
The [cmd interface] command may be invoked multiple times,
and the text is concatenated in the order the commands are encountered.
This command is typically used for declarations and include
files needed by other code in the domain.

[example {
interface {
    #include "myheader.h"
}
}]

[call [cmd prologue] [arg text]]

The [cmd micca] code generator produces a code file for the domain.
The [cmd prologue] command will insert [arg text] near the beginning
of the generated code file.
The [cmd prologue] command may be invoked multiple times,
and the text is concatenated in the order the commands are encountered.
This command is typically used for declarations and include
files needed by code in the domain.

[example {
prologue {
    struct Point {
        int x ;
        int y ;
    } ;
    static void scalarMultiple(int, struct Point *) ;
}
}]

[call [cmd epilogue] [arg text]]

The [cmd micca] code generator produces a code file for the domain.
The [cmd epilogue] command will insert [arg text] near the end
of the generated code file.
The [cmd epilogue] command may be invoked multiple times,
and the text is concatenated in the order the commands are encountered.
This command is typically used for local definitions
needed by code in the domain.

[example {
epilogue {
    static void
    scalarMultiple(
        int a,
        struct Point *p)
    {
        p->x *= a ;
        p->y *= a ;
        return ;
    }
}
}]

[list_end]

[section "Class Commands"]

The commands in this section may appear in the [arg script]
argument of the [cmd class] command to define the properties
of a class.

[list_begin definitions]
[call [cmd attribute] [arg name] [arg type] [arg [opt "-default value"]]\
    [arg [opt "-dependent formula"]]]

The [cmd attribute] command defines [arg name] to be an attribute of the
enclosing class.
The attribute has a data type of [arg type].
[arg Name] must be a valid "C" identifier and [arg type] must be
a valid "C" type name or a type name given by the [cmd typealias] command.
A default value for the attribute may optionally be specified using
the [option -default] option.
Default values are used in any context where the an instance of the
class is created and no value for the attribute is given in the
creation invocation.
The [arg value] of a default value must be a valid "C" initializer and
is passed directly to the generated code.
By special dispensation,
attributes of type [emph "array of character"]
([emph e.g.] char[lb]16[rb]) are treated
as NUL terminated strings in the usual "C" conventions.
If the [option -dependent] arguments is present,
the [arg name] attribute is defined as a mathematically dependent
attribute.
These types of attributes may only be read
and when they are read,
the value of the attribute is that returned by the [arg formula].
The [arg formula] value should consist of "C" code to compute the
value of the attribute.
When invoked, [arg formula] is supplied with a value of [var self]
for the class instance, a pointer to a location where the
attribute value is to be written and the number of bytes
memory for the result.
The variable name of the pointer is the same as the name of the attribute
and it is a pointer to the same type as the attribute.
The variable name of the memory size is [var size].

[example {
class Washer {
    attribute ModelName {char[20]} ; # This is a NUL terminated string
    attribute Capacity unsigned -default 4
}

class Extent {
    attribute Height int
    attribute Width int
    attribute Area int -dependent {
        *Area = self->Height * self->Width ;
    }
}

class Name {
    attribute FirstName char[32] ;
    attribute LastName char[32] ;
    attribute FullName char[64] -dependent {
        size_t firstLen = strlen(self->FirstName) ;
        size_t lastLen = strlen(self->LastName) ;
        *FullName = '\0' ;
        if (size >= firstLen + lastLen + 2) {
            strcat(FullName, self->FirstName)
            strcat(FullName, " ") ;
            strcat(FullName, self->LastName) ;
        }
    }
}
}]

[call [cmd classop] [arg rettype] [arg name] [arg parameters] [arg body]]

The [cmd classop] command defines a class based operation of the
enclosing class.
The name of the operation is given by the [arg name] argument and its
"C" return type is [arg rettype].
Formal parameters to the operation are given as a list
of parameter name / parameter type pairs in the [arg parameters] argument.
The code for the operation is supplied in the [arg body] argument.

[example {
classop {struct Washer *} findById {washerID MRT_InstId} {
    // Code to find a specific washer instance.
}
}]

[call [cmd instop] [arg rettype] [arg name] [arg parameters] [arg body]]

The [cmd instop] command defines an instance based operation of the
enclosing class.
The name of the operation is given by the [arg name] argument and its
"C" return type is [arg rettype].
Formal parameters to the operation are given as a list
of parameter name / parameter type pairs in the [arg parameters] argument.
The code for the operation is supplied in the [arg body] argument.
Instance operations have an implied parameter of [var self],
which is supplied automatically to the operation upon invocation.

[example {
instop unsigned incrCapacity {howmuch unsigned} {
    return self->Capacity += howmuch ;
}
}]

[call [cmd classop] [arg rettype] [arg name] [arg parameters] [arg body]]

The [cmd classop] command defines a class based operation of the
enclosing class.
The name of the operation is given by the [arg name] argument and its
"C" return type is [arg rettype].
Formal parameters to the operation are given as a list
of parameter name / parameter type pairs in the [arg parameters] argument.
The code for the operation is supplied in the [arg body] argument.
Class operations do [emph not] have an implied parameter of [var self].
Class operation typically do not arise as part of a domain model
and are most useful when implementing particular search or summarizing
code on the class as a whole.

[call [cmd statemodel] [arg body]]

The [cmd statemodel] command defines the states, events and transitions
of a state model which is associated with the enclosing class.
The [arg body] argument should contain invocations of
[sectref "State Model Commands" "state model commands"]
to define the properties of the class state model.

[example {
statemodel {
    # Commands to define the states, events and transitions of
    # the class state model.
}
}]

[call [cmd polymorphic] [arg event] [arg [opt "argname argtype ..."]]]

The [cmd polymorphic] command defines a polymorphic event named,
[arg event] which has optional parameters given by
[opt "argnameN argtypeN"] pairs.
A polymorphic event may only be defined on a class that serves as a
superclass in a generalization relationship.
If [arg event] requires any parameters they must be given in this command.
Polymorphic events are inherited across all generalizations in which
the enclosing class is a superclass.

[example {
polymorphic Run howfast int howlong int
polymorphic Stop
}]

[call [cmd constructor] [arg body]]

The [cmd constructor] command defines a constructor for the enclosing class.
The [arg body] argument consists of "C" code which is run
whenever a class is created during run time.
The constructor is supplied automatically with a value for the [var self]
variable.
Typically, constructors are used to initialize complex user defined
data types associated with attributes.

[call [cmd destructor] [arg body]]

The [cmd destructor] command defines a destructor for the enclosing class.
The [arg body] argument consists of "C" code which is run
whenever a class is deleted during run time.
The destructor is supplied automatically with a value for the [var self]
variable.
Typically, destructors are used to clean up complex user defined
data types associated with attributes.

[list_end]

[section "State Model Commands"]

The commands in this section are used to define the state model
for a class.

[list_begin definitions]

[call [cmd state] [arg name] [arg parameters] [arg body]]

The [cmd state] command defines a new state called, [arg name].
If the state accepts parameters, they are given in the
[arg parameters] argument as a list of parameter name / parameter type
pairs.
If the state does not accept parameters, the empty list ( {} ) should
be given.
Upon entry into the state,
the "C" code given in the [arg body] argument is executed.
The [arg body] will have a pre-defined variable named, [var self],
which is a reference to the class instance for which the state
transition happened.

The [arg body] should contain "C" code and [cmd micca] embedded
macro commands.
The embedded commands provide a convenient interface for performing
model level actions such as signaling events.
A separate manual page gives the available embedded commands.

[example {
state Running {} {
    %<my findOneRelated car R3 R7>%
    if (car != NULL) {
        %<instance car signal Started>%
    }
}

state Activate {count int} {
    %<my update Number count>%
    %<my signal Run>%
}
}]

[call [cmd transition] [arg currstate] - [arg event] -> [arg newstate]]
[call [cmd event] [arg name] [arg [opt "argname argtype ..."]]]
[call [cmd initialstate] [arg state]]
[call [cmd defaulttrans] [arg transition]]
[call [cmd final] [arg [opt "state ..."]]]
[list_end]

[section "Assigner Commands"]
[list_begin definitions]
[call [cmd identifyby] [arg class]]
[list_end]

[section "Population Commands"]

[list_begin definitions]
[call [cmd class] [arg name] [arg script]]
[call [cmd assigner] [arg association] [arg script]]
[list_end]

[section "Class Population Commands"]
[list_begin definitions]
[call [cmd instance] [arg name] [arg comp1] [arg values1] [arg [opt ...]]]
[call [cmd table] [arg heading] [arg name1] [arg values1] [arg [opt ...]]]
[call [cmd allocate] [arg size]]
[list_end]

[section "Assigner Population Commands"]
[list_begin definitions]
[call [cmd instance] [arg name] [arg idinstance]]
[list_end]

[see_also micca]

[keywords executable model]

[manpage_end]
