[manpage_begin micca-Embedded n 0.1]
[comment {
# This software is copyrighted 2015 - 2016 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
}]
[moddesc "Micca Embedded Macros"]
[titledesc "Commands for Code Generation"]
[copyright "2015 - 2016 by G. Andrew Mangogna"]
[description]
This manpage describes the [cmd micca] embedded macro commands.

[section Commands]
Commands are divided into sections.

[section "Class Operations"]
For every class in a domain,
a macro command is created that has the same name as the class.
That class command takes as its first argument a subcommand.
The various subcommands for classes are given in this section.

[list_begin definitions]
[call %<[arg class] [cmd create] [arg instref]\
    [arg [opt "attr1 value1 attr2 value2 ..."]]]

The [cmd create] subcommand generates code to
synchronously create a new instance of [arg class].
A reference to the instance is placed in the variable called, [arg instref].
If [arg instref] has not been previously declared,
it is declared automatically.
The attributes of the newly created instance are set to the values given
by the [arg "attrN / valueN"] pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the [cmd create] subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
If [arg class] has an associated state model,
then the newly created instance is placed in the default initial state
that was defined for the state model.
No state activity is executed since the instance creation is done
synchronously.

[example {
%<Color create c Red 20 Green 30 Blue 100>%
}]

[call %<[arg class] [cmd createin] [arg instref] [arg state]\
    [arg [opt "attr1 value1 attr2 value2 ..."]]]

The [cmd create] subcommand generates code to
synchronously create a new instance of [arg class] and place it the
[arg state] state.
A reference to the instance is placed in the variable called, [arg instref].
If [arg instref] has not been previously declared,
it is declared automatically.
The attributes of the newly created instance are set to the values given
by the [arg "attrN / valueN"] pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the [cmd create] subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
[arg Class] must have a state model and
the newly created instance has its initial state set to [arg state].
No state activity is executed since the instance creation is done
synchronously.

[example {
%<WashingMachine createin wm Stopped >%
}]

[call %<[arg class] [cmd createasync] [arg event]\
    \{[arg [opt "param1 value1 param2 value2 ..."]]\}\
    [arg [opt "attr1 value1 attr2 value2 ..."]]]

The [cmd createasync] subcommand generates code to
asynchronously create a new instance of [arg class] by signaling [arg event]
as a creation event.
Any parameters of the creation event are given by the
[arg [opt "paramN valueN"]] pairs.
If the event has no parameters,
an empty list ({}) must be used as argument.
The attributes of the newly created instance are set to the values given
by the [arg [opt "attrN  valueN"]] pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the [cmd createasync] subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
This command only defined for classes that have a state model for which
creation events have been specified.
The instance is created and placed in it pseudo-initial state
awaiting delivery of [arg event],
whereupon it will transition and execute a state activity.

[call %<[arg class] [cmd foreachInstance] [arg instref]>% [arg body] %<end>%]

The [cmd foreachInstance] subcommand generates
statements to iterate over the instances of
[arg class] assigning a reference to each instance to the variable
named, [arg instref].
If the [arg instref] variable does not exist before invoking
[cmd foreachInstance], then it is created automatically,
but goes out of scope at the end of [arg body].
The code statements contained in the [arg body] are then executed.
The [arg body] is terminated by a [cmd %<end>%] macro command.

[example {
%<Color foreachInstance c>%
    %<instance c attr Red>% += 30 ;
%<end>%
}]

[call %<[arg class] [cmd foreachWhere] [arg instref] [arg clause]>% [arg body]\
    %end%]

The [cmd foreachWhere] subcommand generates statements to
iterate over the instances of [arg class].
Each instance for which [arg clause] evaluates to [emph true],
a reference to the instance is assigned to the variable named,
[arg instref], and [arg body] is executed.
The [arg body] is terminated by a [cmd %<end>%] macro command.
If the [arg instref] variable does not exist before invoking [cmd foreachWhere],
then it is created automatically, but goes out of scope at the end
of [arg body].

[example {
%<Color foreachWhere c {c->Red < 30}>%
    printf("low red color: %d\n", %<instance c attr Red>%) ;
    %<instance c update Red 30>%
%<end>%
}]

[call %<[arg class] [cmd findWhere] [arg instref] [arg clause]>%]

The [cmd findWhere] subcommand for a class generates code
to search the instances of [arg class].
A reference to the first allocated instance of [arg class] for which
[arg clause] evaluates to [cmd true] is assigned to the
[arg instref] variable.
If there are multiple instances where [arg clause] evaluates to [cmd true],
then the one returned is arbitrary.
If [arg clause] never evaluates to [cmd true] then [arg instref] will have the
value of [cmd NULL].

[example {
%<Color findWhere nored {nored>Red == 0}>%
if (nored != NULL) {
    %<instance nored update Red 10>%
}
}]

[call %<[arg class] [cmd selectWhere] [arg instref] [arg clause] [arg instset]>%]

The [cmd selectWhere] subcommand for a class generates code
to conditionally add instances of [arg class] to an instance set.
For each instance of [arg class],
a reference to the instance is assigned to the [arg instref] variable
and [arg clause] is evaluated.
If [arg clause] evaluates to true,
then the instance is added to the set being accumulated in
the [arg instset] variable.
The [arg instset] variable is declared automatically if necessary.

[example {
%<Color selectWhere lowred {lowred->Red < 30} lrset>%
if (%<instset lrset empty>%) {
    printf("no low red colors\n") ;
}
}]

[call %<[arg class] [cmd instref] [arg refvarname]>%]

The [cmd instref] subcommand for a class generates code to
declare [arg refvarname] to be a variable whose type is suitable to hold
an instance reference to instances of [arg class].
This command is not frequently used as most command will
automatically declare the necessary ``C'' variables.

[example {
%<Color instref mycolor>%
}]

[call %<[arg class] [cmd instset] [arg setvarname]>%]

The [cmd instset] subcommand for a class generates code to
declare [arg setvarname] to be a variable whose type is
suitable to hold a set of instances of [arg class].
The variable is initialized appropriately so that the set is empty.

[example {
%<Color instset highContrastColors>%
}]

[call %<[arg class] [cmd idtoref] [arg instid] [arg instref]>%]

The [cmd idtoref] subcommand for a class generates code to 
convert the [arg instid] integer identifier of a class instance to
a reference to the instance stored in a variable named [arg instref].
Outside of a domain,
class instances are identified by small integer numbers and when
passed into the domain,
this command converts them to actual instance references that can be used
in further processing.

[call %<[arg class] [cmd findByName] [arg instname] [arg instref]>%]

The [cmd findByName] subcommand for a class generates code to
place an instance reference in the variable named, [arg instref],
that referes to the class instance named, [arg instname].
When instances are defined in the initial instance population,
they are given names and this command allows for computing an instance
reference to one of the named instances of the initial instance population.

[example {
%<Schedule findByName singleton sref>%
}]

[call %<[arg class] [cmd operation] [arg opname] [arg [opt "name1 value1 ..."]]>%]

The [cmd operation] subcommand for a class generates code to invoke
the class-based operation named [arg opname] passing the arguments
given by the [arg "nameN valueN"] pairs.
Operation argument passing is by name (rather than by order),
so the order of the name / value pairs is arbitrary and the generated
code will invoke the underlying ``C'' function properly.

[example {
%<Color addToBlue blueIncr 20>% ;
}]

[list_end]

[section "Relationship Operations"]
[subsection "Association Operations"]
[list_begin definitions]
[call [arg association] [cmd swap] [arg sourceref] [arg targetref]]
[list_end]

[subsection "Single Assigner Association Operations"]
[list_begin definitions]
[call [arg association] [cmd signal] [arg event]]
[list_end]

[subsection "Multiple Assigner Association Operations"]
[list_begin definitions]
[call [arg association] [cmd signal] [arg event] [arg instref]]
[call [arg association] [cmd create] [arg instref] [arg idinst]]
[list_end]

[subsection "Generalization Operations"]
[list_begin definitions]
[call [arg generalization] [cmd reclassify] [arg superref] [arg subclass]\
    [arg subref]]
[list_end]

[section "Instance Operations"]
[list_begin definitions]
[call [cmd instance] [arg instref] [cmd attr]]
[call [cmd instance] [arg instref] [cmd update]]
[call [cmd instance] [arg instref] [cmd assign]]
[call [cmd instance] [arg instref] [cmd signal]]
[call [cmd instance] [arg instref] [cmd delaysignal]]
[call [cmd instance] [arg instref] [cmd canceldelayed]]
[call [cmd instance] [arg instref] [cmd delayremaining]]
[call [cmd instance] [arg instref] [cmd delete]]
[call [cmd instance] [arg instref] [cmd operation]]
[call [cmd instance] [arg instref] [cmd foreachRelated]]
[call [cmd instance] [arg instref] [cmd foreachRelatedWhere]]
[call [cmd instance] [arg instref] [cmd findOneRelated]]
[call [cmd instance] [arg instref] [cmd instid]]
[list_end]

[section "Instance Set Operations"]
[list_begin definitions]
[call [cmd instset] [cmd foreachSelected] [arg instset]]
[call [cmd instset] [cmd selectRelated] [arg instset]]
[call [cmd instset] [cmd selectRelatedWhere] [arg instset]]
[call [cmd instset] [cmd empty] [arg instset]]
[call [cmd instset] [cmd cardinality] [arg instset]]
[call [cmd instset] [cmd notempty] [arg instset]]
[call [cmd instset] [cmd equal] [arg instset]]
[call [cmd instset] [cmd notequal] [arg instset]]
[call [cmd instset] [cmd add] [arg instset]]
[call [cmd instset] [cmd remove] [arg instset]]
[call [cmd instset] [cmd contains] [arg instset]]
[call [cmd instset] [cmd union] [arg instset]]
[call [cmd instset] [cmd intersect] [arg instset]]
[call [cmd instset] [cmd minus] [arg instset]]
[list_end]

[section "External Operations"]
[list_begin definitions]
[call [cmd externalop] [arg opname] [arg [opt "name1 value1 ..."]]]

The [cmd exteral] command

[list_end]

[see_also micca DSL]

[keywords executable model]

[manpage_end]
