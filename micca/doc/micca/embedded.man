[manpage_begin micca-Embedded n 1.0.1]
[comment {
# This software is copyrighted 2015 - 2017 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
}]
[moddesc "Micca Embedded Macros"]
[titledesc "Commands for Code Generation"]
[copyright "2015 - 2017 by G. Andrew Mangogna"]
[description]
This manpage describes the [cmd micca] embedded macro commands.
To aid in translating domain actions from action language into "C",
a set of commands may be embedded into the "C" source code.
During code generation,
the embedded commands are expanded and replaced by the functionally
equivalent "C" code.
Note that embedded commands may [emph not] be nested.

[para]
The supplied embedded commands are intended to perform model level
actions and remove the need to remember and understand the detailed
"C" function interface to the run time.
For the following action language (from a state activity):
[example {
Filling To Wash State Activity
------------------------------
# Fill the tub with wash water.
select one wc related by self->R4[WC]
select one ct related by self->R1[CT]
signal Fill(wc.WashWaterTemp) to ct
}]

The translation using the embedded commands would appear as:
[example {
state FillingToWash {} {
    // Fill the tub with wash water.
    <%my findOneRelated wc R4%>
    <%my findOneRelated ct ~R1%>
    <%instance wc assign {WashWaterTemp washtemp}%>
    <%instance ct signal Fill temp washtemp%>   // <1>
}
}]

[section Commands]
Commands are divided into sections depending upon to which model
level entity they refer.
Commands are categorized as:

[list_begin itemized]
[item] [sectref "Class Operations"]
[item] [sectref "Relationship Operations"]
[item] [sectref "Instance Operations"]
[item] [sectref "Instance Set Operations"]
[item] [sectref "External Entity Operations"]
[list_end]

[section "Class Operations"]
For every class in a domain,
a macro command is created that has the same name as the class.
That class command takes as its first argument a subcommand.
The various subcommands for classes are given in this section.

[list_begin definitions]

[call <%[arg class] [cmd create] [arg instref]\
    [arg [opt "attr1 value1 attr2 value2 ..."]]]

The [cmd create] subcommand generates code to
synchronously create a new instance of [arg class].
A reference to the instance is placed in the variable called, [arg instref].
If [arg instref] has not been previously declared,
it is declared automatically.
The attributes of the newly created instance are set to the values given
by the [arg "attrN / valueN"] pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the [cmd create] subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
If [arg class] has an associated state model,
then the newly created instance is placed in the default initial state
that was defined for the state model.
No state activity is executed since the instance creation is done
synchronously.

[example {
<%Color create c Red 20 Green 30 Blue 100%>
}]

[call <%[arg class] [cmd createasync] [arg event]\
    \{[arg [opt "param1 value1 param2 value2 ..."]]\}\
    [arg [opt "attr1 value1 attr2 value2 ..."]]]

The [cmd createasync] subcommand generates code to
asynchronously create a new instance of [arg class] by signaling [arg event]
as a creation event.
Any parameters of the creation event are given by the
[arg [opt "paramN valueN"]] pairs.
If the event has no parameters,
an empty list ({}) must be used as argument.
The attributes of the newly created instance are set to the values given
by the [arg [opt "attrN  valueN"]] pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the [cmd createasync] subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
This command is only defined for classes that have a state model for which
creation events have been specified.
The instance is created and placed in its pseudo-initial state
awaiting delivery of [arg event],
whereupon it will transition and execute a state activity.

[example {
<%Order createasync New_order {quantity 20} Customer {"Fred"} Account 2700%>
}]

[call <%[arg class] [cmd createin] [arg instref] [arg state]\
    [arg [opt "attr1 value1 attr2 value2 ..."]]]

The [cmd createin] subcommand generates code to
synchronously create a new instance of [arg class] and place it the
[arg state] state.
A reference to the instance is placed in the variable called, [arg instref].
If [arg instref] has not been previously declared,
it is declared automatically.
The attributes of the newly created instance are set to the values given
by the [arg "attrN / valueN"] pairs.
All attributes of the instance must either be supplied a value 
as part of the invocation of the [cmd create] subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.
[arg Class] must have a state model and
the newly created instance has its initial state set to [arg state].
No state activity is executed since the instance creation is done
synchronously.

[example {
<%WashingMachine createin wm Stopped %>
}]

[call <%[arg class] [cmd findByName] [arg instname] [arg instref]%>]

The [cmd findByName] subcommand for a class generates code to
place an instance reference in the variable named, [arg instref],
that refers to the class instance named, [arg instname].
When instances are defined in the initial instance population,
they are given names and this command allows for computing directly an instance
reference to one of the named instances of the initial instance population.

[example {
<%Schedule findByName singleton sref%>
}]

[call <%[arg class] [cmd findWhere] [arg instref] [arg clause]%>]

The [cmd findWhere] subcommand for a class generates code
to search the instances of [arg class].
A reference to the first allocated instance of [arg class] for which
[arg clause] evaluates to [cmd true] is assigned to the
[arg instref] variable.
If the [arg instref] variable does not exist before invoking
[cmd findWhere], then it is declared automatically.
If there are multiple instances where [arg clause] evaluates to [cmd true],
then the one returned is arbitrary.
If [arg clause] never evaluates to [cmd true] then [arg instref] will have the
value of [var NULL].

[example {
<%Color findWhere nored {nored->Red == 0}%>
if (nored != NULL) {
    <%instance nored update Red 10%>
}
}]

[call <%[arg class] [cmd foreachInstance] [arg instref]%> [arg body] <%end%>]

The [cmd foreachInstance] subcommand generates
statements to iterate over the instances of
[arg class] assigning a reference to each instance to the variable
named, [arg instref].
If the [arg instref] variable does not exist before invoking
[cmd foreachInstance], then it is declared automatically
and with a scope local to the command.
The code statements contained in the [arg body] are then executed.
The [arg body] is terminated by a [cmd <%end%>] macro command.

[example {
<%Color foreachInstance c%>
    <%instance c attr Red%> += 30 ;
<%end%>
}]

[call <%[arg class] [cmd foreachWhere] [arg instref] [arg clause]%> [arg body]\
    <%end%>]

The [cmd foreachWhere] subcommand generates statements to
iterate over the instances of [arg class].
A reference to each 
instance for which [arg clause] evaluates to [emph true],
is assigned to the variable named,
[arg instref], and [arg body] is executed.
If the [arg instref] variable does not exist before invoking
[cmd foreachWhere], then it is declared automatically
and with a scope local to the command.
The [arg body] is terminated by a [cmd <%end%>] macro command.

[example {
<%Color foreachWhere c {c->Red < 30}%>
    printf("low red color: %d\n", <%instance c attr Red%>) ;
    <%instance c update Red 30%>
<%end%>
}]

[call <%[arg class] [cmd idtoref] [arg instid] [arg instref]%>]

The [cmd idtoref] subcommand for a class generates code to 
convert the [arg instid] integer identifier of a class instance to
a reference to the instance stored in a variable named [arg instref].
Outside of a domain,
class instances are identified by small integer numbers and when
passed into the domain,
this command converts them to actual instance references that can be used
in further processing.

[call <%[arg class] [cmd instset] [arg setvarname]%>]

The [cmd instset] subcommand for a class generates code to
declare [arg setvarname] to be a variable whose type is
suitable to hold a set of instances of [arg class].
The variable is initialized appropriately so that the set is empty.

[example {
<%Color instset highContrastColors%>
}]

[call <%[arg class] [cmd operation] [arg opname] [arg [opt "name1 value1 ..."]]%>]

The [cmd operation] subcommand for a class generates code to invoke
the class-based operation named [arg opname] passing the arguments
given by the [arg "nameN valueN"] pairs.
Operation argument passing is by name (rather than by order),
so the order of the name / value pairs is arbitrary and the generated
code will invoke the underlying "C" function properly.

[example {
<%Color addToBlue blueIncr 20%> ;
}]

[call <%[arg class] [cmd refvar] [arg refvarname]%>]

The [cmd refvar] subcommand for a class generates code to
declare [arg refvarname] to be a variable whose type is suitable to hold
an instance reference to instances of [arg class].
This command is not frequently used as most command will
automatically declare the necessary "C" variables.
However, it can be useful to declare an instance reference variable
to make sure it remains within a desired block scope.

[example {
<%Color instref mycolor%>
}]

[call <%[arg class] [cmd selectWhere] [arg instref] [arg clause] [arg instset]%>]

The [cmd selectWhere] subcommand for a class generates code
to conditionally add instances of [arg class] to an instance set.
For each instance of [arg class],
a reference to the instance is assigned to the [arg instref] variable
and [arg clause] is evaluated.
If the [arg instref] variable does not exist before invoking
[cmd selectWhere], then it is declared automatically.
If [arg clause] evaluates to true,
then the instance is added to the set being accumulated in
the [arg instset] variable.
The [arg instset] variable is declared automatically if necessary.

[example {
<%Color selectWhere lowred {lowred->Red < 30} lrset%>
if (<%instset lrset empty%>) {
    printf("no low red colors\n") ;
}
}]

[list_end]

[section "Relationship Operations"]

Each relationship defined by a domain will have a command by the
same name created.
Those relationship commands have subcommands that depend upon the type
of the relationship.
These fall into four categories:

[list_begin itemized]
[item] Associations
[item] Associations that also have a single assigner
[item] Associations that also have a multiple assigner
[item] Generalizations
[list_end]

The following section show the subcommands available for each category.

[subsection "Association Operations"]

All association relationship have a single command, [cmd reference],
defined for them.
The interpretation of [cmd reference] is slightly different for
simple associations than for class based associations.
Associations may also have an assigner defined on them and, if so,
additional commands are available for the assigner operations.

[subsection "Simple Association Operations"]
[list_begin definitions]
[call <%[arg association] [cmd reference] [arg sourceref] [arg targetref]%>]

The [cmd reference] subcommand when applied to simple associations
updates the referenced instance for the association.
The [arg sourceref] argument is the name of a "C" variable that holds a
reference to an instance of the class playing the role of the referring
class in the association.
The [arg targetref] argument is the name of a "C" variable that holds a
reference to an instance of the class playing the role of the
referenced class in the association.
The [cmd reference] subcommand removes any existing referenced instance
in the association and replaces it with the [arg targetref] instance.

[para]
For a simple association, [var R3], defined as:
[example {
association R3 Member 0..*--1 Group
}]
In [var R3], Member is the referring class and Group is the referenced class.
Then if [var groupref] contains an instance reference to a Group and
[var memberref] contains an instance reference to a Member, then:
[example {
R3 reference memberref groupref
}]
changes the instance of [var memberref] so that it refers to
[var groupref].
[list_end]

[subsection "Class Based Association Operations"]
[list_begin definitions]
[call <%[arg association] [cmd reference] [arg assocref] [arg partref]\
    [arg [opt direction]]%>]

The [cmd reference] subcommand when applied to class based associations
updates the referenced instance of one of the participants
in the association.
The [arg assocref] argument is the name of a "C" variable that holds a
reference to an instance from the class that is the associator
class in the association.
The [arg partref] argument is the name of a "C" variable that holds a
reference to an instance from the class that is one of the participant
in the association.
The [cmd reference] subcommand removes any existing references to
the participant in the association and replaces it with the
[arg partref] instance.
For a reflexive class based association,
the [arg direction] argument must be supplied as either [var forward]
or [var backward].
This indicates that the [cmd reference] operation should be applied to the
instance in either the forward or backward direction of
the association traversal.
Since the name of the participant classes in a reflexive association
are the same,
the [arg direction] argument is used to disambiguate the which
side [arg partref] refers to.

[para]
For a class based association, [var R4], defined as:
[example {
association R4 -associator Membership Member 0..*--1..* Group
}]
In [var R4], Membership is the associator class.
Then if [var mshipref] contains a reference to a Membership instance and
[var memberref] contains a reference to a Member instance, then:
[example {
R4 reference mshipref memberref
}]
changes the instance of [var mshipref] so that it refers to
[var memberref].
[list_end]

[subsection "Single Assigner Association Operations"]

Associations that are also single assigners have an additional
command defined for them in order to signal events to the assigner.

[list_begin definitions]
[call <%[arg association] [cmd signal] [arg event]\
    [arg [opt "name1 value1 name2 value2 ..."]]%>]

For associations that have a single assigner,
the [cmd signal] command signals [arg event] to the assigner.
If any of the [arg "nameN / valueN"] arguments are present,
they are passed as the parameters to [arg event].
All parameters required by the event must be supplied and
the parameter names must match those of the signature of the event.
Event parameters are passed by name,
so the ordering of the [arg "nameN valueN"] pairs is not significant.
[list_end]

[subsection "Multiple Assigner Association Operations"]

For associations that are multiple assigners,
two additional commands are defined.
Note that there is no [cmd signal] command for a multiple assigner.
Once an instance of the assigner is found using the
[cmd findByIdInstance] command, it is signaled like any other
instance, [emph i.e.] using <%instance [arg instref] signal [arg event]%>.

[list_begin definitions]
[call <%[arg association] [cmd create] [arg instref] [arg idinst]%>]
[call <%[arg association] [cmd findByIdInstance] [arg instref] [arg idinst]%>]
[list_end]

[subsection "Generalization Operations"]

For generalization relationships,
two commands are defined.

[list_begin definitions]

[call <%[arg generalization] [cmd classify] [arg superref] [arg subref]%>\
    [arg body] <%end%>]
[call <%[cmd subclass] [arg classname]%> [arg body] <%end%>]
[call <%[cmd default]%> [arg body] <%end%>]

The [cmd classify] subcommand navigates the [arg generalization]
relationship to the currently related subclass instance.
The [arg superref] argument is the name of a variable holding
a reference to a superclass instance of [arg generalization].
The [arg subref] argument is the name of variable into which a reference
to the currently related subclass instance of [arg superref] is placed.
The type of [arg subref] will be declared automatically as the type
of the currently related subclass instance.
The [arg body] of the [cmd classify] command must consist of invocations
of <%[cmd subclass] [arg classname]%> or <%[cmd default]%> commands.
The subclass of the instance currently related to [arg superref] is
matched against the [arg classnames] given in the [cmd subclass]
commands of the body.
Upon finding a match,
[arg subref] is declared to be of the corresponding [arg classname]
type, set to refer to the related subclass and then the
[arg body] of the corresponding [cmd subclass] command is executed.
The scope of [arg subref] is local to the matching [arg body] statements.
If the currently related instance does not match any of the
[arg classnames] given in [cmd subclass] commands,
then the body of the [cmd default] command is executed.
In the [cmd default] case,
[arg subref] is not defined.
If there is no match and no [cmd default] command is given,
then nothing is executed.
Note it is not necessary to give a [cmd default] command body if
all of the subclasses of [arg generalization] are specified in
[cmd subclass] commands.
A warning is issued if some subclasses of [arg generalization] are missing
from [cmd subclass] commands and no [cmd default] command is given.
Note that it is [emph not] necessary to place a "C" [var break] statement
as part of the body of a [cmd subclass] or [cmd default] command.

[example {
<%R17 classify lampref sublampref%>
    <%subclass TableLamp%>
        <%instance update sublampref Color red%>
    <%end%>
    <%subclass FloorLamp%>
        <%instance update sublampref Height 7%>
    <%end%>
    <%subclass DeskLamp%>
        <%instance update sublampref Wattage 100%>
    <%end%>
<%end%>
}]

[call <%[arg generalization] [cmd reclassify] [arg subref] [arg newsubclass]\
    [arg newsubref] [arg [opt "attr1 value1 ..."]]%>]

The [cmd reclassify] subcommand changes the type of the subclass instance
in the [arg subref] variable to be an instance of [arg newsubclass].
A reference to the new subclass instance is place in a variable named
[arg newsubref].
The [arg newsubref] instance refers to the same superclass instance
as [arg subref] did.
After the reclassification has happened, the instance referred to by
[arg subref] no long exists (it was deleted as part of the reclassification).
The [arg newsubref] variable is created automatically if needed.
The newly created instance of [arg newsubclass] has its attributes
initialized by the [arg "attrN / valueN"] pairs.
All attributes of the new subclass instance must either be supplied a value 
as part of the invocation of the [cmd reclassify] subcommand or
have default values declared for them as part of the class definition.
Any value given as an argument overrides any default value that might
have been defined for an attribute.

[example {
/*
 * Create a Lamp instance and one of its corresponding subclass instances.
 */
<%Lamp create lampref%>
<%TableLamp create tableref Color blue R17 lampref%>
/*
 * Magically convert the table lamp instance into a desk lamp instance.
 */
<%R17 reclassify tableref DeskLamp deskref Wattage 70%>
/*
 * "deskref" now refers to "lampref" across R17 and
 * "tableref" no longer exists.
 */
}]
[list_end]

[section "Instance Operations"]

The [cmd instance] command performs operations on instances.
The first argument to the [cmd instance] command is always the name
of a "C" variable that contains a reference to the instance.
The second argument is the name of a subcommand operation to be performed
on the instance.

[list_begin definitions]

[call <%[cmd instance] [arg instref] [cmd assign]\
    [arg [opt "assignspec1 assignspec2 ..."]]%>]

The [cmd assign] subcommand assigns attribute values of the instance
referenced by the value of the [arg instref] variable into
ordinary "C" variables.
Each [arg assignspecN] argument consists of one or two elements.
If the [arg assignspecN] argument consist of one element,
then it must be the name of an attribute and a "C" variable by 
the same name is declared and the corresponding attribute from
[arg instref] is assigned to it.
If the [arg assignspecN] argument consists of two elements,
then the first element must be the name of an attribute and the
second element will be used as the name of a "C" variable
into which the corresponding attribute value is assigned.
If no [arg assignspecN] arguments are given,
then all the attributes of [arg instref] are assigned to
variables whose names are the same as the attribute name.

[example {
<%instance c assign Red Blue {Green mygreen}%>
if (Blue > mygreen) {
    printf("this one is more blue than green\n") ;
}
}]

[call <%[cmd instance] [arg instref] [cmd attr] [arg name]%>]

The [arg attr] subcommand generate "C" code suitable for using as
an lvalue or an rvalue to access the [arg name] attribute of
the instance refered to by the [arg instref] variable.
If [arg name] is not an attribute of the class of [arg instref],
then an error is reported.

[example {
<%instance c attr Total%> = <%instance c attr Red%> + <%instance c attr Blue%> ;
}]

[call <%[cmd instance] [arg instref] [cmd canceldelayed] [arg event]\
    [arg [opt sourceinst]]%>]

The [cmd canceldelayed] subcommand arranges for [arg event] to
not be delivered to the instance referenced by [arg instref].
The [arg sourcinst] argument is a "C" variable name holding a reference
to the instance that originally signaled [arg event].
If [arg sourceinst] is not supplied,
then the signaling instance is taken as [var self] if invoked within
as state activity and [var NULL] otherwise.
After being canceled, [arg event] will not be dispatched.
It is not an error to cancel an event that does not exist
or has already been dispatched.
Only event that were signaled as delayed events may be canceled.

[example {
<%instance c canceldelayed Start%>
}]

[call <%[cmd instance] [arg instref] [cmd delayremaining] [arg event]\
    [arg [opt sourceinst]]%>]

The [cmd delayremaining] subcommand generates an rvalue expression
of type [type MRT_DelayTime]
that evaluates to the number of milliseconds before [arg event]
will be signaled.
The [arg sourcinst] argument is a "C" variable name holding a reference
to the instance that originally signaled [arg event].
If [arg sourceinst] is not supplied,
then the signaling instance is taken as [var self] if invoked within
as state activity and [var NULL] otherwise.
A return value of zero implies that [arg event] has already been
dispatched or does not exist.

[example {
MRT_DelayTime newtime = <%instance c delayremaining Start%> + 100 ;
<%instance c canceldelayed Start%>
<%instance c delaysignal newtime Start%>
}]

[call <%[cmd instance] [arg instref] [cmd delaysignal] [arg time] [arg event]\
    [arg [opt "name1 value1 name2 value2 ..."]]%>]

The [cmd delaysignal] subcommand arranges for [arg event]
to be signaled to the instance
referenced by the [arg instref] variable no sooner than
[arg time] in the future.
If [arg time] is given as zero,
then the event is signalled immediately.
If any of the [arg "nameN valueN"] arguments are present,
they are passed as the parameters to [arg event].
All parameters required by the event must be supplied and
the parameter names must match those of the signature of the event.
Event parameters are passed by name,
so the ordering of the [arg "nameN valueN"] pairs is not significant.

[example {
<%instance c delaysignal 100 Start%>
}]

[call <%[cmd instance] [arg instref] [cmd delete]%>]

The [cmd delete] subcommand deletes the instance referenced by
the value of the [arg instref] variable.

[call <%[cmd instance] [arg startref] [cmd findOneRelated]>\
    [arg instref] [arg rel1] [arg [opt "rel2 ..."]]%>]

The [cmd findOneRelated] subcommand obtains a single instance by navigating
the relationship chain which starts at [arg startref] and is given
by the [arg relN] arguments.
The form of the [arg relN] arguments is the same as for the [cmd foreachRelated]
subcommand.
A reference to the related instance is assigned into the [arg instref]
variable.
If no related instance is found, [emph i.e.] the relationship chain
is conditional,
then [arg instref] will have the value of [var NULL].
If the navigation of the relationship chain would yield more than one
instance, then an error is reported.
This subcommand is a convenience function when it is known that
at most one instance can result from navigating the relationships chain.

[example {
<%instance ct findOneRelated wm R1%>
}]

[call <%[cmd instance] [arg startref] [cmd findRelatedWhere]\
    [arg instref] [arg boolexpr] [arg rel1] [arg [opt "rel2 ..."]]%>]

The [cmd findRelatedWhere] subcommand obtains a single instance by navigating
the relationship chain which starts at [arg startref] and is given
by the [arg relN] arguments.
The form of the [arg relN] arguments is the same as for the [cmd foreachRelated]
subcommand.
A reference to each related instance is assigned into the [arg instref]
variable and [arg boolexpr] is evaluated.
If [arg boolexpr] evaluates to non-zero,
then the iteration stops and [arg instref] contains a reference to
the matching instance.
If no match is found or there are no related instances,
[arg instref] is set to NULL.
If there are multiple matching instances in the related set of instances,
the one found is arbitrary.

[example {
<%instance ct findRelatedWhere mtr {mrt->MotorID == MTR_Pump} ~R2%>
}]

[call <%[cmd instance] [arg startref] [cmd foreachRelated]\
    [arg instref] [arg rel1] [arg [opt "rel2 ..."]]%> [arg body] <%end%>]

The [cmd foreachRelated] subcommand iterates across the set of
instances obtained by navigating the relationships chain which
begins at [arg startref] and is given by the [arg relN] arguments.
A reference to each instance found is assigned to the [arg instref] variable
and [arg body] is executed.
The [arg body] is terminated by a [cmd <%end%>] macro command.
The scope of the [arg instref] variable is confined to the statements
in [arg body] unless it was previously declared.
The [arg relN] arguments specify the relationship navigation and
are of the form:
[list_begin itemized]
[item] [cmd R][emph dd] traversing relationship Rdd in the forward direction.
[item] [cmd ~R][emph dd] traversing relationship Rdd in the reverse direction.
[item] {[cmd R][emph dd] [arg class]}
traversing relationship Rdd in the forward direction and stopping at
[arg class].
[item] {[cmd ~R][emph dd] [arg class]}
traversing relationship Rdd in the reverse direction and stopping at
[arg class].
[list_end]

where [cmd ~R][emph dd] follows our usual naming conventions for
relationships, the letter "R" followed by decimal digits
([emph e.g.] [var R27]) ;

[example {
<%instance color foreachRelated pigm R23 ~R47 {R13 Pigment}%>
    printf("found pigment, %s\n", <%instance pigm attr Name%>) ;
<%end%>
}]

[call <%[cmd instance] [arg startref] [cmd foreachRelatedWhere]\
    [arg instref] [arg boolexpr] [arg rel1] [arg [opt "rel2 ..."]]%>\
    [arg body] <%end%>]

The [cmd foreachRelatedWhere] subcommand conditionally iterates across the set
of instances obtained by navigating the relationships chain which begins at
[arg startref] and is given by the [arg relN] arguments.
A reference to each instance found is assigned to the [arg instref] variable
and [arg boolexpr] is evaluated.
If [arg boolexpr] evaluates to true (or non-zero), then [arg body] is executed.
The [arg body] is terminated by a [cmd <%end%>] macro command.
The scope of the [arg instref] variable is confined to the statements
in [arg body] unless it was previously declared.
The [arg relN] arguments specify the relationship navigation and
are of the same form as for the [cmd foreachRelated] subcommand.

[example {
<%instance color foreachRelatedWhere pigm {pigm->Amount > 20} R23 ~R47 {R13 Pigment}%>
    printf("found pigment, %s\n", <%instance pigm attr Name%>) ;
<%end%>
}]

[call <%[cmd instance] [arg instref] [cmd instid]%>]

The [cmd instid] subcommand generates a "C" rvalue expression of unsigned type
that computes a small integer identifier for the instance reference held in the
[arg instref] variable.
The identifer values are sequential and
range from 0 to the number of instances of the
class of [arg instref] minus one.
These numeric id's are useful for identifying instances outside
of their domain and may be passed to the [arg class] [cmd idtoref]
command to recover the value of the instance reference.

[example {
unsigned cid = <%instance color instid%> ;
<%Color mapcolor Color cid%> ;
}]

[call <%[cmd instance] [arg instref] [cmd operation] [arg opname]\
    [arg [opt "param1 value1 param2 value2 ..."]]%>]

The [cmd operation] command generates a "C" rvalue expression that
invokes the instance based operation, [arg opname],
passing the [arg paramN] values as arguments.
Parameter arguments must appear as parameter name / value pairs
and the parameter names must match that of the signature of [arg opname].
All parameters must be supplied values and the parameter name / value
pairs may in any order.
The value of the [arg instref] references will become the value of
[var self] when the operation is invoked.

[example {
<%instance color operation incrRed incrAmount 20%> ;
}]

[call <%[cmd instance] [arg startref] [cmd selectRelated] [arg instsetvar]\
    [arg rel1] [arg [opt "rel2 ..."]]%>]

The [cmd selectRelated] subcommand operates the same way as the
[cmd foreachRelated] subcommand, except the instances found during the
relationship chain navigation are added to the instance set held in the
[arg instsetvar] variable.

[example {
<%instance color selectRelated pigmset R23 ~R47 {R13 Pigment}%>
}]

[call <%[cmd instance] [arg startref] [cmd selectRelatedWhere] [arg instsetvar]\
    [arg instref] [arg boolexpr] [arg rel1] [arg [opt "rel2 ..."]]%>]

The [cmd selectRelatedWhere] subcommand operates the same way as the
[cmd foreachRelatedWhere] subcommand, except the instances found during the
relationship chain navigation are added to the instance set held in the
[arg instsetvar] variable.

[example {
<%instance color selectRelatedWhere pigmset pigm {pigm->Amount > 20} R23 ~R47 {R13 Pigment}%>
}]

[call <%[cmd instance] [arg instref] [cmd signal] [arg event]\
    [arg [opt "name1 value1 name2 value2 ..."]]%>]

The [cmd signal] subcommand signals [arg event] to the instance
referenced by the [arg instref] variable.
If any of the [arg "nameN / valueN"] arguments are present,
they are passed as the parameters to [arg event].
All parameters required by the event must be supplied and
the parameter names must match those of the signature of the event.
Event parameters are passed by name,
so the ordering of the [arg "nameN valueN"] pairs is not significant.

[example {
<%instance c signal Start%>
}]

[call <%[cmd instance] [arg instref] [cmd update] [arg [opt "attr1 value1 ..."]]%>]

The [cmd update] subcommand updates the values of the attributes
of the instance referenced by the value of the [arg instref] variable.
Attributes and corresponding values are given in pairs.
The [arg valueN] arguments may be any "C" rvalue expression.

[example {
<%instance c update Red 20 Blue 30 Green 40%>
<%instance d update Red {20 * 3}%>
}]

[list_end]

[section "Instance Set Operations"]

The [cmd instset] command performs operations on instance sets.
Instance sets are sets of instance references where all the instances
are of the same class.
Instance sets are created by the class [cmd instset] and [cmd selectWhere]
commands and the instance [cmd selectRelated] and [cmd selectRelatedWhere]
commands.
The first argument to the [cmd instset] command is always the name
of a "C" variable that contains an instance set.
The second argument is the name of a subcommand operation to be performed
on the instance set.


[list_begin definitions]

[call <%[cmd instset] [arg instsetvar] [cmd add] [arg instref]%>]

The [cmd add] subcommand adds the instance reference contained in the
variable named, [arg instref], to the instance reference set
contained in the variable named, [arg instsetvar].
The [arg instref] instance must be of the same class as the other instance
references in [arg instsetvar].
Adding a duplicate member to the set is silently ignored and the
set property of [arg instsetvar] is maintained.

[call <%[cmd instset] [arg instsetvar] [cmd cardinality]%>]

The [cmd cardinality] subcommand generates a "C" unsigned rvalue expression
which evaluates to the number of members of the instance reference set
contained it the variable named, [arg instsetvar].

[example {
<%Color selectWhere color {color->Blue < 30 && color->Red > 100} brcolors%>
printf("%u blue / red colors present\n", <%instset brcolors cardinality%>) ;
}]

[call <%[cmd instset] [arg instsetvar] [cmd contains] [arg instref]%>]

The [cmd contains] subcommand generates a "C" boolean rvalue expression
which evaluates to [emph true] if the instance reference contained in
the variable named, [arg instref], is a member of the instance reference
set contained in the variable named, [arg instsetvar], and [emph false]
otherwise.
The instance referenced by [arg instref] must be of the same class
as the references in [arg instsetvar].

[call <%[cmd instset] [arg instsetvar] [cmd empty]%>]

The [cmd empty] subcommand generates a "C" boolean rvalue expression which
evaluates to [emph true] if if the instance reference set contained in the
variable named, [arg instsetvar], has no members and [emph false] otherwise.

[example {
<%Color selectWhere color {color->Blue < 30} lowblues%>
if (<%instset lowblues empty%>) {
    <%Color create lb Red 10 Blue 30 Green 50%>
}
}]

[call <%[cmd instset] [arg instsetvar] [cmd equal] [arg compareset]%>]

The [cmd equal] subcommand generates a "C" boolean rvalue expression which
evaluates to [emph true] if if the instance reference set contained in the
variable named, [arg instsetvar], is equal to the one contained in the variable
named, [arg compareset] and [emph false] otherwise.
For two instance reference sets to be equal the sets must
be sets of the same class as well as contain the same instances of
that class.

[call <%[cmd instset] [arg instsetvar] [cmd foreachInstance] [arg instref]%>\
    [arg body] [arg <%end%>]]

The [cmd foreachInstance] subcommand iterates over the members of the
instance reference set contained in the variable named [arg instsetvar].
Each instance reference in the set is assigned to the variable named,
[arg instref] and [arg body] is executed.
The [arg <%end%>] command terminates the [arg body] statements.
The order of the iteration over the set is unspecified and should
be considered arbitrary.

[example {
<%Color selectWhere color {color->Red > 30} highreds%>
<%instset highreds foreachInstance highred%>
    <%instance highred assign {Red redValue}%>
    <%instance highred update Red {redValue - 20}%>
<%end%>
}]

[call <%[cmd instset] [arg resultset] [cmd intersect] [arg set1] [arg set2]\
    [arg [opt "set3 ..."]]%>]

The [cmd intersect] subcommand computes the set intersection of the instance
references contained in the [arg setN] variables and stores the
result in the variable named, [arg resultset].
The [arg resultset] variable is declared if it does not already exist.
All of the [arg setN] instance sets must refer to instances of the same
class.
The order of the appearance of the [arg setN] arguments does not
affect the result.

[call <%[cmd instset] [arg resultset] [cmd minus] [arg set1] [arg set2]%>]

The [cmd minus] subcommand computes the set difference between the
instance reference set held in the [arg set1] variable and the
instance reference set held in the [arg set2] variable.
The order of the arguments is significant as [arg set1] is treated as
the minuend and [arg set2] is treated as the subtrahend
([emph i.e.] [cmd minus] computes [arg set1] - [arg set2]).

[call <%[cmd instset] [arg instsetvar] [cmd notempty]%>]

The [cmd notempty] subcommand generates a "C" boolean rvalue expression which
evaluates to [emph true] if if the instance reference set contained in
the variable named, [arg instsetvar], has at least one member
and [emph false] otherwise.

[call <%[cmd instset] [arg instsetvar] [cmd notequal] [arg compareset]%>]

The [cmd notequal] subcommand generates a "C" boolean rvalue expression which
evaluates to [emph true] if if the instance reference set contained in the
variable named, [arg instsetvar], is not equal to the one contained in the
variable named, [arg compareset] and [emph false] otherwise.

[call <%[cmd instset] [arg instsetvar] [cmd remove] [arg instref]%>]

The [cmd remove] subcommand removes the instance reference contained in the
variable named, [arg instref], from the instance reference set
contained in the variable named, [arg instsetvar].
The [arg instref] instance must be of the same class as the other instance
references in [arg instsetvar].
Removing an instance reference that is not a member of the
[arg instsetvar] set is silently ignored.

[call <%[cmd instset] [arg resultset] [cmd union] [arg set1] [arg set2]\
    [arg [opt "set3 ..."]]%>]

The [cmd union] subcommand computes the set union of the instance
references contained in the [arg setN] variables and stores the
result in the variable named, [arg resultset].
The [arg resultset] variable is declared if it does not already exist.
All of the [arg setN] instance sets must refer to instances of the same
class.
The order of the appearance of the [arg setN] arguments does not
affect the result.

[example {
<%Color selectWhere lowred {lowred->Red < 30} lrset%>
<%Color selectWhere highgreen {highgreen > 60} hgset%>
<%instset lhset union lrset hgset%>
}]

[list_end]

[section "External Entity Operations"]

For each external entity defined by the [cmd eentity] command
in the domain configuration,
a macro command is defined by the same name.
For each external entity operation defined on an external entity,
a subcommand is defined that is used to invoke the operation.

[list_begin definitions]
[call <%[arg eentity] [arg operation] [arg [opt "param1 value1 ..."]]%>]

The [arg "eentity operation"] subcommands generate a "C" rvalue expression that
invokes the external operation named,
[arg operation] that has been defined for the [arg eentity] external entity.
The [arg paramN] are pased as arguments to the operation.
The type of the generated expresssion is the same as the
declared return type of [arg operation].
Arguments must be given as [arg param] / [arg value] pairs.
All arguments to [arg operation] must be given but the order of the
parameter name / value pairs is arbitrary.

[example {
unsigned colorId = <%instance color instid%> ;
unsigned shades = <%ColorEE getColorShades color colorId%> ;
}]

[list_end]

[see_also micca DSL]

[keywords executable model]

[manpage_end]
