== Translating processing

The processing facet of a model is the third and most difficult to translate.
Translating domain actions requires the Translator to reformulate the
intent of an action language or data flow diagram into ``C'' language
statements.
The semantic gap between these representations is larger than that of
either the dynamics facet (where it is virtually zero) or the data facet
(where there are a relatively small set of rules and guidelines).

=== Action language -- what action language?

The first quandry we encounter is to determine how domain activities
are described to the Translator.
Since we don't transfer any machine readable content from the analysis effort,
there is no requirement for a formal, parsable description of how activities
are expressed.
Many action languages have been defined.
It is possible the analyst decided to express the processing facet as a
data flow diagram with associated descriptions of the processes.
It could be that the domain actions are written in a more informal pseudo-code.
Regardless of how the actions are expressed,
projects are strongly encouraged to adopt one particular way to express domain
actions for all the domains in the project.
Multiple types of action specifications only confuses the matter.

Practice shows,
counter to what you might think,
the exact manner of expressing the model processing actions is not
as important is might seem.
In well designed models,
most activities are small and highly focused in what they must accomplish.
Complex mathematical calculations are usually delegated to specialized
libraries.
For example,
there is little reason to model and write action language for
a Fourier transform.
Fourier transforms are a well researched and implemented world
unto themselves and would yield little insight into the larger problem.
Model code is usually more concerned with when and on what data
would a transform be applied.
What is important is that the actions be expressed in a form that is
clear and unambiguous.

In our discussion and examples here,
we will used a variety of ways to show model actions and how they are
translated using `micca`.
Sometimes a pseudo-code narrative is sufficient.
However,
we will tend to use an action language called, _Scrall_, the most.
Scrall is an open source action language designed to leverage the
distinct semantics of XUML.footnote::[Need a reference here!]

=== Categories of processing

Broadly speaking,
domain actions fall into two categories:

Expression evaluation and flow of control::
    Actions need to be able to compute things, such as adding or
    multiplying values. Actions need to be able to test values
    and change the flow of execution. 
    These are basic operations required to perform any reasonable computation.
Model level actions::
    Action languages have primitives that affect model level components.
    For example, signaling an event to an instance is a model level
    action that is usually expressed as a basic construct in the action
    language.

Examined from a different perspective,
these two categories of actions can also be seen as:

* Constructs that are directly supported by the implementation language
    (``C'' in our case) and for which there is a direct mapping
    from the action onto the implementation language.
* Constructs that are built upon the implementation language using data
    and code constructs of the target language to implement operations on model
    components.

Consider the following action snippet:

----
(Altitude < Minimum)?
    Pull up -> me
----

The intent of the action is to test whether the altitude value
is less than some minimum and if so,
then to signal the *Pull up* event to the instance running the actions,
_i.e._ *me*.
A translation of these ideas to ``C'' might look like:

[source,c]
----
unsigned Altitude ;
unsigned Minimum ;

// some code to assign values to both Altitude and Miniumum

if (Altitude < Minumum) {
    // OK, now what? How to I signal an event?
}
----

Signaling an event to an instance is not a base concept in ``C''
and there is no direct, handy statement in the language that will do it.
Consequently,
`micca` has devised data structures and supplies code as part of the run-time
library to perform that operation.
There is nothing mysterious about that code.
It is ordinary ``C'' code and can be viewed like any other ``C''
implementation.
The function to signal events is called `mrt_SignalEvent()` and it accepts
arguments required to accomplish the model level action of sending an event
signal to a class instance.
It is possible to translate the activity by writing the ``C'' code that invokes
`mrt_SignalEvent()` directly, and that would cause the signal to be generated.

The difficulty of coding directly against the run-time library interfaces is:

* There is a large cognitive burden to understand the details of the
    run-time API and supply the correct argument values.
* Direct coding against the run-time API strongly couples the model
    translation to the run-time interface.
    Future changes to the run-time that might be required to correct errors or
    extend its functionality could break a translation.

The `micca` solution to this is to provide an _embeddable_ command language
that generates the code needed for model level actions.
One significant advantage of the embedded commands is that `micca` has
access to the platform specific model when the code generation happens.
Consequently,
error diagnosis is much improved.
If you attempt to signal an event to a class instance and that instance
does not have such an event,
`micca` is able to diagnose that condition and issue an appropriate error
message.
This helps detect errors earlier in the process rather than
relying on the ``C'' compiler.

=== `Micca` embedded command language

An activity in a `micca` translation, _e.g._ a state activity,
appears as ordinary ``C'' code with other commands embedded into the code.
The commands are embedded by surrounding them with the `<%` and `%>`
characters.
Our previous example would appear as:

[source,c]
----
unsigned Altitude ;
unsigned Minimum ;

// some code to assign values to both Altitude and Miniumum

if (Altitude < Minumum) {
<%  my signal Pull_up       %>
}
----

There are a few rules about the embedded commands:

* The command syntax is the same as for `micca` itself, _i.e._ it is Tcl
    syntax.
* Leading or trailing whitespace around the embedded
    command does not matter.  So you may format
    the embedded commands in whatever way you find clearest.
    The above formatting tries to keep the `<%` and `%>` markers
    out of the way to make indentation more apparent.
* Embedded commands *do not nest*.
* Some embedded commands generate multiple ``C'' code statements and include
    all the necessary semicolon punctuation.
    Other embedded commands are intended to be used in expressions and
    so do not place semicolons in the output.
    The reference documentation for the embedded command language states
    which behavior each command has, but you will quickly know
    the difference by the intent of each embedded command.
* During the code generation, the embedded command is removed from the input
    and the semantically equivalent ``C'' code is placed in the output at the
    same location.
* Since it is unknown how many ``C'' statements a command may generate,
    all statements should be treated as _compound_ statements and surrounded
    by curly braces (as we did in the `if` test of the previous example).

==== Generated code

Most people who perform a model translation using `micca` are curious about
the contents of the generated ``C'' code.
It usually takes some experience to trust the tooling and examining the
code can garner that trust.
In the end,
everything must end up as ``C'' code and we should be able to read
that code.
What follows is a sample showing a state activity and its generated code.

First, we show the `micca` source.
This is a state activity, so it would be part of a state model.

----
statemodel {
    # Code for states, events, et.al.

    state Autocycle_Session_Deactivate {} {
    <%  my update Deactivate true               %>
    <%  my signal Deactivate                    %>
    }
}
----

And the following is the generated code snippet.

[source,c]
----
static void
Autocycle_Session_Deactivate(
    struct Autocycle_Session *const self)
// <%  my update Deactivate true               %>
// <%  my signal Deactivate                    %>
{
    MRT_INSTRUMENT_ENTRY
    // instance self update Deactivate true
    self->Deactivate = true ;
    // instance self signal Deactivate {}
    mrt_SignalEvent(6, self, self, NULL, 0) ; // Deactivate
}
----

There are several points of interest:

* State activities are turned into ordinary ``C'' functions.
    Most names are made file static to avoid cluttering
    the global space of names and to lessen the chance of a name
    conflict.
    State activities to not return values.
    All of their side effects are recorded in the class data.
* Each state activity function has an argument called, `self`, which
    is a reference to the class instance for which the action is
    being run.
* The contents of the state action is placed as a comment at the
    beginning of the function body.
* `MRT_INSTRUMENT_ENTRY` is a macro that can be used for logging
    and instrumentation output or it can be defined to be empty and
    no additional code is generated.
* As each embedded command is expanded, a comment containing the
    command is placed in the ``C'' code.
    In this example, `my signal` is the same as `instance self`.
    The `my` prefix is just a shorthand.
* Updating an attribute is done via pointer indirection on the instance
    using structure members defined as part of the class's attributes.
* Signaling an event happens by invoking a function in the run-time
    with the proper argument values.
    In this case the *Deactivate* event has been numbered `6`,
    and the event is self-directed with no parameters.
    `Micca` generates all the numbers used to encode things such
    as states and events.
* The output code is neatly formatted.
    Although the code is not examined often,
    during debugging you may be setting breakpoints in the generated code and
    it is helpful if it is readable and there are clues about how the generated
    code relates back to the model.

We do not show any other generated code in this document.
How the code is generated is discussed in the
<<micca-litprog,literate source document>>
for `micca`.
Code generation test cases are
http://repos.modelrealization.com/cgi-bin/fossil/mrtools[available]
for those interested in
the precise details of how the generated output appears.

As we stated previously,
model actions are a mix of ordinary ``C'' code,
used for expression evaluation and flow of control,
plus embedded commands to perform model level operations.
In the end,
the result looks like ``C'' but with what can be imagined as
unusual looking function invocations to perform the model level
semantics.

=== Categories of domain activities

The processing accomplished by a model occurs in very specific places.
In general,
model activities do not sequence the overall flow of execution.
That responsibility is given to the Model Execution domain,
which in this case is the run-time code supplied by `micca`.
The following sections describe where the processing in a domain is
found.

==== State activities

The primary processing of a domain occurs in activities associated with
states.
State activities cannot be directly invoked.
Rather,
they are executed when an event is received which causes a transition
into a state.
`Micca` converts the ``C'' code specified for a state activity into
an ordinary ``C'' function of file static scope.
State activities have an automatically declared `self` variable
that references the class instance receiving the event.

==== Domain operations

Domain operations are actvities which provide an exterally callable
interface to the domain.
`Micca` converts domain operations into ``C'' function of external scope.

==== Instance operations

Instance operations are defined within a class and represent
common code factored into a ``C'' function.
Instance operations have an automatically declared `self` variable
that references the class instance upon which the operation is invoked.

==== Class operations

`Micca` allows the definition of an operation associated with a particular
class.
Class operations do not arise from the XUML model.
They represent code that the Translator has added to the implementation
for some particular purpose.
For example,
identity constraints are usually enforced by a class operation
and this topic is covered in a subsequent section.

=== Referring to instances

Since many operations are directed at instances, _e.g._ access an attribute,
we must have some way to refer to an instance.
In this section,
we describe the ways provided by `micca` to refer to instances of platform
classes.

==== Instance references

Operations on class instances are accomplished by
being given or by finding an _instance reference_.
To access the attributes, navigate a relationship or signal event,
you must have some way to identify the class instance which is affected.
This is accomplished with an _instance reference variable_.
An instance reference variable is simply a variable whose value refers
to a particular class instance.
There is no notion of an instance reference variable that refers to an
instance of an arbitrary class.
Instance references are typed according to the class to which the instance
belongs.

`Micca` provides an embedded command to declare an instance reference
variable.
Each platform class defined in the domain has a command defined for it.
For example,
if there is a `Part` class in the domain, then the following
declares an instance reference variable for a `Part`.

----
<%  Part refvar screw  %>
----

This command will declare a variable named, `screw`, which can hold a value
that refers to an instance of the platform class, `Part`.
This construct is not frequently used since most embedded commands
will automatically declare any necessary ``C'' variable that holds
the command result.
However,
sometimes you will want to control the scope of the variable by using this
command.

In practice,
an instance reference variable is actually a ``C'' pointer and so
carries with it all the usual admonitions about pointers.
In particular,
`micca` does use an instance reference variable value of `NULL` to indicate
that the variable does not refer to any instance.
For example,
searching for a particular instance or navigating a conditional
relationship can yield a `NULL` value in the instance reference variable.

==== The `self` instance reference variable

For state activities and instance operations,
`micca` automatically declares and initializes an instance reference
variable called, `self`.
The `self` instance reference variable refers to the instance receiving
the event or on which the instance operation happens.

The `micca` embedded command language uses the `instance` command
for all operations that use an instance reference variable to
perform a model level action on an instance.

For example:

----
<%  instance red_part attr Weight   %>
----

access the *Weight* attribute of the instance referenced by the `red_part`
variable.

As a shorthand,
embedded commands that refer to the instance `self` can simply use
the `my` command.
For example,
rather than write:

----
<%  instance self update Color red  %>
----

one can write:

----
<%  my update Color red  %>
----

==== Instance reference sets

`Micca` also supports the concept of an _instance reference set_.
As its name implies,
an instance reference set can refer to multiple instances (and possibly zero).
Like instance reference variables,
instance reference sets are typed to the class to which the instances
belong.
An example of declaring an instance reference set is:

----
<%  Part instset red_parts   %>
----

Like instance reference variables,
instance reference sets are declared using the embedded command
that is available which is named the same as the platform class.
Instance reference sets are implemented using bit fields.
This is a compact representation, but the maximum number of elements
in an instance reference set must be known at compile time.
The default value is 128, _i.e._ an instance reference set can only
describe the set of instances for a class that has at most 128 instances.
This value can be changed by defining the `MRT_INSTANCE_SET_SIZE`
pre-processor macro to a different number.
We cover all the operations on instance reference sets in a subsequent section.

=== Accessing instance attributes
Accessing instance attributes

=== Signaling events
Signaling events

==== Signaling delayed events
Signaling delayed events

==== Delayed event operations
Delayed event operations

=== Navigating relationships
Navigating relationships

==== Navigating simple associations
Navigating simple associations

==== Navigating associative relationships
Navigating associative relationships

==== Navigating generalizations
Navigating generalizations

=== Searching for class instances
Searching for class instances

`Micca` provides two embedded commands to locate class instances,
`findByName` and `findWhere`.

The first command, `findByName` is rather specialized.
When the initial instance population is defined,
each initial instance is given a _name_.
That name is used to handle relationship associations in the
inital instances and stands for an instance reference.
It can do the same at run time.
For example,
if there is a single instance of some class named, `singleton`,
the you can directly reference using `findByName`.

.Micca translation
----
<%  Schedule findByName singleton theSchedule       %>
----

This will result in an instance reference to the `singleton` instance
of the `Schedule` class being place in the ``C'' variable called,
`theSchedule`.
So if you know by context that you want a particular instance that
was defined in the initial instance population,
the `findByName` command will obtain is by direct means without any
searching.

A more general search is obtained using the `findWhere` command.

.Scrall action
----
airports in my country .= Airport(1, Country : my country)
----

.Micca translation
----
<%  Airport findWhere airports_in_my_country\
        {strcmp(airports_in_my_country->Country, my_country) == 0}       %>
----

This translation assumes that the `Country` attribute is a string
and the `my_country` variable points to a string.
So `strcmp()` is used to make the comparison.
The `findWhere` command sequentially searches the instances of the
class assigning a reference to the instance variable and evaluating
the condition.
It stops when it finds the first match and the instance reference will
be `NULL` if no match is found.

=== Interating over class instances
Interating over class instances

=== Handling sets of instances
Handling sets of instances

=== Creating class instances
Creating class instances

==== Synchronous creation of class instances

To create an instance,
the values of *all* attributes must be supplied.
Attribute values may be supplied explicitly at the point of creation
or by default values or by declaring the attribute to be zero initialized.
(Note that dependent attributes are not initalized since they are
computed by a formula at each access).
All attributes also means that all relationship associations must
be defined at the point of creation.
This insistence insures that there is never any _partially_ initialized
instances floating round in the program.

In Scrall, a synchronous instance creation would appear as:

.Scrall action
----
ac .= *Aircraft(Tail: t, Altitude: a, Heading: h, Location: l, Airspeed:s)
----

This assumes `t`, `a`, `h`, `l`, and `s` are variables with appropriate
values.

The corresponding embedded command is:

.Micca translation
----
<%  Aircraft create ac Tail t Altitude a Heading h Location l Airspeed s %>
----

Note it is not necessary to declare a variable named, `ac`, to hold
the instance reference value.
The `micca` code generator will automatically declare the variable if
needed.

When relationship references must be specified,
this is done using the relationship number and an instance reference
variable.
Note the specification of relationships is _not_ done using the values
of referential attributes.
Rather, the notion is abstracted away from the individual attributes
and the association is expressed in terms of the number of the relationship
and a reference to the related instance.
In this case the action language might appear as:

.Scrall action
----
v .= *Owned Vehicle( License number:l ) &R1 me
----

.Micca translation
----
<%  Owned_Vehicle create License_number l R1 self   %>
----

Note that the requirement to supply instance references at creation
time to satisfy the referential attribute values will impose an order
to instance creation in certain cases.
For example,
classes related across a generalization relationship must be created
in supertype to subtype order since the subtype instance must have
an instance reference to its related supertype instance to satisfy
the referential integrity.
So, if there were class definitions such as:

.Micca class definition
----
class Lamp {
    attribute Manufacturer {char[32]}
    attribute Model ModelType_t
}
class Table_Lamp {
    attribute Height unsigned
}
class Desk_Lamp {
    attribute Wattage unsigned
}

generalization R22 Lamp Table_Lamp Desk_Lamp
----

Then creating an instance of a *Desk_Lamp* requires creating an
instance of *Lamp* and that must be done first.

.Micca translation
----
<%  Lamp create lamp Manufacturer {"Edison"} Model L100     %>
<%  Desk_Lamp create dlamp Wattage 100 R22 lamp             %>
----

Also note in the `micca create` command,
the order of attributes and relationship names does not matter.

==== Asynchronous creation of class instances

.Scrall action
----
New folder(Parent: parent id) -> *Folder
----

.Micca translation
----
<%  Folder createasync New_folder {Parent parent_id}        %>
----

=== Deleting class instances
Deleting class instances

=== External entities
External entities

==== External identification of instances
External identification of instances

////
The following sections group the embedded commands based on
model level components such as classes or relationships.
Embedded commands are presented, along with some example action language,
to show how the intent of the action language is rendered into
the embedded commands.

In this section we examine the support for operating on classes.
This includes:

* Creating class instances
* Deleting class instances
* Searching for class instances
* Iterating across class instances

* types of model level actions
  ** actions associated with instances
  ** actions associated with relationships
  *** navigating
  *** subtype migration
  ** actions associated with state machines
  ** instance sets
  ** operations
  *** domain operations
  *** instance operations
  *** class operations
  ** external entities
////


// vim:syntax=asciidoc:
