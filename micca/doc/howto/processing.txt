== Translating processing

The processing facet of a model is the most difficult to translate.
Translating domain actions requires the Translator to reformulate the
intent of an action language or data flow diagram into ``C'' language
statements.
The semantic gap between these representations is larger than that of
either the dynamics facet (where it is virtually zero) or the data facet
(where there are a relatively small set of rules and guidelines).

=== Action language -- what action language?

The first quandry we encounter is to determine how domain activities
are described to the Translator.
Since we don't transfer any machine readable content from the analysis effort,
there is no requirement for a formal description of how activities are
expressed.
Many action languages have been defined.
It is possible the analyst decided to express the processing facet at a
data flow diagram with associated descriptions of the processes.
It could be that the domain actions are written in a more informal pseudo-code.
Regardless of how the actions are expressed,
projects are strongly encouraged to adopt one particular way to express domain
actions for all the domains in the project.
Multiple types of action specifications only confuses the matter.

It turns out that, counter to what you might think,
the exact manner of expressing the model processing actions is not
as important is might seem.
In well designed models,
most activities are small and highly focused in what they must accomplish.
What is important is that the actions be expressed in a form that is
clear and unambiguous.

In our discussion and examples here,
we will used a variety of ways to show model actions and how they are
translated using `micca`.
Sometimes a pseudo-code narrative is sufficient.
However,
we will tend to use an action language called, _Scrall_, the most.
Scrall is an open source action language designed to leverage the
distinct semantics of XUML.footnote::[Need a reference here!]

=== Categories of processing

Broadly speaking,
domain actions fall into two categories:

. Expression evaluation and flow of control.
    Actions need to be able to compute things, such as adding or
    multiplying values. Actions need to be able to test values
    and change the flow of execution. 
    These are basic operations required to perform any reasonable computation.
. Model level actions.
    Action languages have primitives that affect model level components.
    For example, signaling an event to an instance is a model level
    action that is usually expressed as a basic construct in the action
    language.

Examined from a different perspective,
these two categories of actions can also be seen as:

. Constructs that are directly supported by the implementation language
    (``C'' in our case) and for which there is a direct mapping
    from the action onto the implementation language.
. Constructs that are built upon the implementation language using data
    and code constructs to implement higher order operations on model
    components.

Consider the following action snippet:

----
(Altitude < Minimum)?
    Pull up -> me
----

The intent of the action is to test whether the altitude value
is less than some minimum and if so,
then to signal the *Pull up* event to the instance running the actions
(_i.e._ *me*).
A translation of these ideas to ``C'' might look like:

[source,c]
----
unsigned Altitude ;
unsigned Minimum ;

// some code to assign values to both Altitude and Miniumum

if (Altitude < Minumum) {
    // OK, now what? How to I signal an event?
}
----

Clearly,
signaling an event to an instance is not a base concept in ``C''
and there is no direct, handy statement in the language that will do it.
Consequently,
`micca` has devised data structures and supplies code as part of the run-time
library to perform that operation.
There is nothing mysterious about that code.
It is ordinary ``C'' code and can be viewed like any other ``C''
implementation.
The function to signal events is called `mrt_SignalEvent()` and it accepts
arguments required to accomplish the model level action of sending an event
signal to a class instance.
It is possible to write the ``C'' code that invokes `mrt_SignalEvent()`
directly, and that would cause the signal to be generated.

The difficulty of coding directly against the run-time library interfaces is:

. There is a large cognitive burden to understand the details of the
    run-time API.
. Direct coding against the run-time library API strongly couples the
    translation to the run-time interface and could prevent future changes
    to the run-time that might be required to correct errors or extend
    the functionality.

The `micca` solution to this is to provide an _embeddable_ command language
that generates the code needed for model level actions.
One significant advantage of the embedded commands is that `micca` has
access to the platform specific model when the code generation happens.
Consequently,
error diagnosis is much improved.
If you attempt to signal an event to a class instance and that instance
does not have such an event,
`micca` is able to diagnose that condition and issue an appropriate error
message.

=== `Micca` embedded command language

An activity in a `micca` translation, _e.g._ a state activity,
appears as ordinary ``C'' code with other commands embedded into the code.
The commands are embedded by surrounding them with the `<%` and `%>`
characters.
Our previous example would appear as:

[source,c]
----
unsigned Altitude ;
unsigned Minimum ;

// some code to assign values to both Altitude and Miniumum

if (Altitude < Minumum) {
<%  my signal Pull_up       %>
}
----

There are a few rules about the embedded commands:

. The command syntax is the same as for `micca` itself, _i.e._ it is Tcl
    syntax.
. Leading or trailing whitespace around the embedded
    command does not matter.  So you may format
    the embedded commands in whatever way you find clearest.
    The above formatting tries to keep the `<%` and `%>` markers
    out of the way to make indentation more apparent.
. Embedded commands *do not nest*.
. Some embedded commands generate ``C'' code statements and include all
    the necessary semicolon punctuation.
    Other embedded commands are intended to be used in expressions and
    so do not place semicolons in the output.
    The reference documentation for the embedded command language states
    which behavior each command has, but you will quickly know
    the difference by the intent of each embedded command.
. During the code generation, the embedded command is removed from the input
    and the results of its execution is placed in the output at the same
    location.
. Since it is unknown how many ``C'' statements a command may generate,
    all statements should be treated as _compound_ statements and surrounded
    by curly braces (as we did in the `if` test of the previous example).

==== Generated code

Most people who perform a model translation using `micca` are curious about
the contents of the generated ``C'' code.
It usually takes some experience to trust the tooling and examining the
code can garner that trust.
In the end,
everything must end up as ``C'' code and we should be able to read
that code.
What follows is a sample showing a state activity and its generated code.

First, we show the `micca` source.
This is a state activity, so it would be part of a state model.

----
statemodel {
    # Code for states, events, et.al.

    state Autocycle_Session_Deactivate {} {
    <%  my update Deactivate true               %>
    <%  my signal Deactivate                    %>
    }
}
----

And the following is the generated code snippet.

[source,c]
----
static void
Autocycle_Session_Deactivate(
    struct Autocycle_Session *const self)
// <%  my update Deactivate true               %>
// <%  my signal Deactivate                    %>
{
    MRT_INSTRUMENT_ENTRY
    // instance self update Deactivate true
    self->Deactivate = true ;
    // instance self signal Deactivate {}
    mrt_SignalEvent(6, self, self, NULL, 0) ; // Deactivate
}
----

There are several points of interest:

. State activities are turned into ordinary ``C'' functions.
    Most names are made file static to avoid cluttering
    the global space of names and to lessen the chance of a name
    conflict.
    State activities to not return values.
    All of their side effects are recording in the class data.
. Each state activity function has an argument called, `self`, which
    is a reference to the class instance for which the action is
    being run.
. The contents of the state action is placed as a comment at the
    beginning of the function body.
. `MRT_INSTRUMENT_ENTRY` is a macro that can be used for logging
    and instrumentation output or it can be defined to be empty and
    no additional code is generated.
. As each embedded command is expanded, a comment containing the
    command is placed in the ``C'' code.
    In this example, `my signal` is the same as `instance self`.
    The `my` prefix is just a shorthand.
. Updating an attribute is done via pointer indirection on the instance
    using structure members defined as part of the class's attributes.
. Signaling an event happens by invoking a function in the run-time
    with the proper argument values.
    In this case the *Deactivate* event has been numbered `6`,
    and the event is self-directed with no parameters.
    `Micca` generates all the numbers used to encode things such
    as states and events.
. The output code is neatly formatted.
    Although the code is not examined often,
    during debugging you may be setting breakpoints in the generated code and
    it is helpful if it is readable and there are clues about how the generated
    code relates back to the model.

We do not show any other generated code in this document.
How the code is generated is discussed in the
<<micca-litprog,literate source document>>
for `micca`.
Code generation test cases are
http://repos.modelrealization.com/cgi-bin/fossil/mrtools[available]
for those interested in
the precise details of how the generated output appears.

As we stated previously,
model actions are a mix of ordinary ``C'' code plus embedded commands
to perform model level operations.
In the end,
the result looks like ``C'' but with what can be imagined as
unusually looking function invocations to perform the model level
semantics.

The following sections group the embedded commands based on
model level components such as classes or relationships.
Embedded commands are presented, along with some example action language,
to show how the intent of the action language is rendered into
the embedded commands.

=== Embedded commands for classes

In this section we examine the support for operating on classes.
This includes:

* Creating class instances
* Deleting class instances
* Searching for class instances
* Iterating across class instances

==== Synchronous creation of class instances

To create an instance,
the values of *all* attributes must be supplied.
Attribute values may be supplied explicitly at the point of creation
or by default values or by declaring the attribute to be zero initialized.
(Note that dependent attributes are not initalized since they are
computed by a formula at each access).
All attributes also means that all relationship associations must
be defined at the point of creation.
This insistence insures that there is never any _partially_ initialized
instances floating round in the program.

In Scrall, a synchronous instance creation would appear as:

.Scrall action
----
ac .= *Aircraft(Tail: t, Altitude: a, Heading: h, Location: l, Airspeed:s)
----

This assumes `t`, `a`, `h`, `l`, and `s` are variables with appropriate
values.

The corresponding embedded command is:

.Micca translation
----
<%  Aircraft create ac Tail t Altitude a Heading h Location l Airspeed s %>
----

Note it is not necessary to declare a variable name, `ac`, to hold
the instance reference value.
The `micca` code generator will automatically declare the variable if
needed.

When relationship references must be specified,
this is done using the relationship number and an instance reference
variable.
Note the specification of relationships is _not_ done using the values
of referential attributes.
Rather, the notion is abstracted away from the individual attributes
and the association is expressed in terms of the number of the relationship
and a reference to the related instance.
In this case the action language might appear as:

.Scrall action
----
v .= *Owned Vehicle( License number:l ) &R1 me
----

.Micca translation
----
<%  Owned_Vehicle create License_number l R1 self   %>
----

Note that the requirement to supply instance references at creation
time to satisfy the referential attribute values will impose an order
to instance creation in certain cases.
For example,
classes related across a generalization relationship must be created
in supertype to subtype order since the subtype instance must have
an instance reference to its related supertype instance to satisfy
the referential integrity.
So, if there were class definitions such as:

.Micca class definition
----
class Lamp {
    attribute Manufacturer {char[32]}
    attribute Model ModelType_t
}
class Table_Lamp {
    attribute Height unsigned
}
class Desk_Lamp {
    attribute Wattage unsigned
}

generalization R22 Lamp Table_Lamp Desk_Lamp
----

Then creating an instance of a *Desk_Lamp* requires creating an
instance of *Lamp* and that must be done first.

.Micca translation
----
<%  Lamp create lamp Manufacturer {"Edison"} Model L100     %>
<%  Desk_Lamp create dlamp Wattage 100 R22 lamp             %>
----

Also note in the `micca create` command,
the order of attributes and relationship names does not matter.

==== Asynchronous creation of class instances

.Scrall action
----
New folder(Parent: parent id) -> *Folder
----

.Micca translation
----
<%  Folder createasync New_folder {Parent parent_id}        %>
----

==== Searching for class instances

`Micca` provides two embedded commands to locate class instances,
`findByName` and `findWhere`.

The first command, `findByName` is rather specialized.
When the initial instance population is defined,
each initial instance is given a _name_.
That name is used to handle relationship associations in the
inital instances and stands for an instance reference.
It can do the same at run time.
For example,
if there is a single instance of some class named, `singleton`,
the you can directly reference using `findByName`.

.Micca translation
----
<%  Schedule findByName singleton theSchedule       %>
----

This will result in an instance reference to the `singleton` instance
of the `Schedule` class being place in the ``C'' variable called,
`theSchedule`.
So if you know by context that you want a particular instance that
was defined in the initial instance population,
the `findByName` command will obtain is by direct means without any
searching.

A more general search is obtained using the `findWhere` command.

.Scrall action
----
airports in my country .= Airport(1, Country : my country)
----

.Micca translation
----
<%  Airport findWhere airports_in_my_country\
        {strcmp(airports_in_my_country->Country, my_country) == 0}       %>
----

This translation assumes that the `Country` attribute is a string
and the `my_country` variable points to a string.
So `strcmp()` is used to make the comparison.
The `findWhere` command sequentially searchs the instances of the
class assigning a reference to the instance variable and evaluating
the condition.
It stops when it finds the first match and the instance reference will
be `NULL` if no match is found.

* types of model level actions
  ** actions associated with instances
  ** actions associated with relationships
  *** navigating
  *** subtype migration
  ** actions associated with state machines
  ** instance sets
  ** operations
  *** domain operations
  *** instance operations
  *** class operations
  ** external entities



// vim:syntax=asciidoc:
