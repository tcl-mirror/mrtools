== Translating dynamics

Translating the dynamics of the model requires the least amount of
transformation of the three model facets.
The semantics of the Moore state models used in XUML are directly
mapped to `micca` commands.

For classes with a state model,
add a `statemodel` command to its class definition:

----
class LightBulb {
    # light bulb attributes, etc.

    statemodel {
        # Statements that define the states and transitions
        # of the class state model.
    }
}
----

For brevity in the following examples,
we assume the `statemodel` command is contained within the appropriate
`class` definition script.

Two things must be defined for a state model.
The states must be defined and the code to execute when the state
is entered is part of that definition.
In this section,
we do not discuss translating the code for state activities.
We consider that in the next section.
To specify a state,
`micca` uses the `state` command.

Consider a simple light bulb.

["plantuml"]
----
@startuml
hide empty description

[*] --> Off
Off --> On : Turn on
On --> Off : Turn off

Off : ~# code for Off state
On : ~# code for On state
@enduml
----

The `micca` commands for the states in this diagram are as follows.

----
statemodel {
    state Off {} {
        # code to execute when the Off state is entered.
    }

    state On {} {
        # code to execute when the On state is entered.
    }
}
----

Here we have defined two states, `Off` and `On`.
The `state` command takes three arguments:

. The name of the state.
. The parameters of the state.
. The body of ``C'' code to execute when the state is entered.

State activity parameters are carried along in the event that
causes the transition _into_ the state.
We discuss states with parameters more below.
Here there are no parameters to the state activity,
so we specify them as empty ({}).

The other aspect of a state model translation is to specify all the state
transitions.
The starting point for translating the state transitions is,
naturally enough, the transition matrix of each state model.
Consider the following simple transition matrix.

[options="header",cols="3*^",title="Light Bulb State Transitions",width="50%"]
|=====
|State / Event  |Turn off       |Turn on
|Off            |IG             |On
|On             |Off            |IG
|=====

The `micca` command to specify transitions is `transition`.
The `transition` command specifies one cell of the transition matrix.
We can complete the translation of this state model as follows.

----
statemodel {
    state Off {} {
        # code to execute when the Off state is entered.
    }

    state On {} {
        # code to execute when the On state is entered.
    }

    transition Off - Turn_off -> IG
    transition Off - Turn_on -> On
    transition On - Turn_off -> Off
    transition On - Turn_on -> IG
}
----

[NOTE]
Note that `micca` does not have any ordering requirements on the
`state` or `transition` commands.
You can put all the `transition` command first or mix them around
in any way you wish.
One common organization is to list the _outgoing_ transitions
for a state immediately after the `state` command defining the state.

=== Default transitions

The state model diagram show previously,
only shows transitions to states.
It does not show ignored (IG) or can't happen (CH) pseudo-transitions.
In our translation of the example,
we explicitly stated all the IG transitions.
This can be tedious if there are a lot of these types of transitions
to encode.
So, `micca` allows you to set a default transition.
Any transition _not_ mentioned in a `transition` command is assigned
the default transition.

Normally, the default transition is *CH* (for some very good reasons
that catches many errors).
However,
some state models, assigners in particular, 
ignore most event that do not cause an explicit transition to a state.
Our light bulb example also ignores events.
To change the default transition,
use the `defaulttrans` command.
Our light bulb example might have been written as:

----
statemodel {
    defaulttrans IG

    state Off {} {
        # code to execute when the Off state is entered.
    }
    transition Off - Turn_on -> On

    state On {} {
        # code to execute when the On state is entered.
    }
    transition On - Turn_off -> Off
}
----

Some find this manner of specifying the state model clearer.
Note also the `defaulttrans` command may appear anywhere and need not
be the first command in the state model definition.

=== Initial state

All state models must specify an initial state in which to start.
For our light bulb example,
the initial state is *Off*.
This is indicated by the state model graphic having a black circle
(the pseudo-initial state) connected to the *Off* state by an unlabeled
arrow.

The `initialstate` command is used to specify the initial starting state
for a state model.
If no `initialstate` command is specified in the state model definition,
then `micca` chooses the first state defined as the initial state.
It is usually wise to specify the initial state, if only for documentation
purposes and to make sure things don't go wrong if the order of
state definitions is changed.
Again,
our light bulb example might have bee written as:

----
statemodel {
    initialstate Off
    defaulttrans IG

    state Off {} {
        # code to execute when the Off state is entered.
    }
    transition Off - Turn_on -> On

    state On {} {
        # code to execute when the On state is entered.
    }
    transition On - Turn_off -> Off
}
----

==== Initial state semantics

How initial states get handled is fundamentally an analysis concern.
However,
it is worth repeating here how activities associated with initial states
are handled.
Sometimes, problems with initial state activity execution are
assumed to be translation problems.

There are two ways to create class instances:

. Synchronously, where a state activity requests a class instance be
    created and that instance exists when the invocation of the request
    function completes.
    If that class has a state model,
    the newly created instance is placed in an initial state according to:
    .. the default initial state defined in the `statemodel` script, or
    .. the _initial state requested by the state activity_ performing
        the synchronous creation.
        It is possible when the instance creation is operation is invoked,
        to request a specific state into which the newly created instance
        is to be placed.
        This feature is _not_ often used, but it does exist and it
        has useful cases where it is needed.

+
Regardless of how the initial state of a synchronously created
instance is determined,
the state activity associated with the initial state *is not executed*.

. Asynchronously, where a state activity sends a creation event.
    After signaling a creation event,
    the state activity that performed the signaling continues
    executing and the new class instance is created at some later time.
    When the creation event is eventually dispatched,
    the class instance is created in the _pseudo-initial state_, and the
    creation event causes a transition out of that state.
    There is only one pseudo-initial state, but there may be many
    events that cause a transition out of it (and any event which
    does not cause a transition out of the pseudo-initial state
    will cause a *CH* transition if it is used as a creation event).
    When the transition out of the pseudo-initial state happens
    a new state is entered,
    and the *state activity of the new state is executed*.

We discuss how to specify creation events below.

=== Final states

The lifecycle of some classes is over when they enter a certain state.
Consider the state model below.

["plantuml"]
----
@startuml
hide empty description

[*] --> Starting
Starting --> Requesting : Request
Requesting --> Requesting : Request
Requesting --> Finished : Done
Finished --> [*]

Starting : ~# code for Starting state
Requesting : ~# code for Requesting state
Finished : ~# code for the Finishing state
@enduml
----

----
statemodel {
    # state and transition definitions

    final Finished
}
----

=== Event definitions
Event definitions

=== Polymorphic events
Polymorphic events

=== Creation events
Creation events

==== Assigner state models
Assigner state models



// vim:syntax=asciidoc:
