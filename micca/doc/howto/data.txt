== Translating data

The first facet of an XUML model to be translated is the data.
It is recommended that all the classes and relationships be defined
first and that you insure that `micca` reads the DSL contining just
the data specifications without error.
In subsequent additions to the domain configuration,
state models and domain activities are added.
Getting the foundations in data correct are essential to the
remaining parts of the translation and so they must be done first.

=== How memory is handled

`Micca` assumes that all domain data is held in the primary memory of
a processor and the memory is directly addressable.
This is a common situation, but it is important to realize that
there is no assumption of secondary storage such as a disk drive.

`Micca` also assumes that the maximum number of instances of each class
is defined at compile time.
The `micca` run-time does no no dynamic allocation of memory space
off of a system heap, _i.e._ there are no calls to `malloc()`.
Each class has its own pool of memory from which instances are created.
That pool must be sized for the worst case number of instances the
class will ever have and that size is known when the ``C'' code
for the translation is compiled.
Memory is handled in this way to make it more deterministic.

For programmers who are more accustomed to dynamic memory allocation,
worst case memory sizing may seem restrictive or sub-optimal.
In practice,
it is slightly more work to consider the number of instances a class
may have,
but rarely are _arbitrary_ numbers of class instances required.

For example,
one may consider wanting an arbitrary number of network connections.
In truth,
operating systems do not allow processes to consume extremely large
numbers of resources and even if the resources were available,
at some time the ability service connections runs up against the
compute power of the processor.
It may seem like an arbitrary number are required, but what if that
number were 7 million?
In practice,
the number of instances of a class are typically small.

Because all data is held in primary memory and the size of that
memory is known at compile time,
the platform specific model that `micca` targets has two characteristics
that significantly help the implementation.

. All class instances have an architecturally generated identifier
    that consists of its address in primary memory.
    This identifier is used internal to the domain for all references
    to the class instances.
. All class instances have an architecturally generated identifier
    that can be used outside of the domain in order to specify
    the identify of class instances requesting or receiving services.
    The external identifier is the index in the storage pool array
    of a class.
    It is integer valued and unique within a given class.
    To uniquely identify a class instance outside of a domain,
    we must know both the class to which the instance belongs and its
    external identifying integer value.

Neither of the previous characteristics is profound.
Most programs that use data from primary memory use a _pointer_ or
_object id_ as a reference handle.
Accessing the class indirectly through a reference is a fundamental
mechanism supported by the addressing modes of all modern processors.
The mechanism is so common that we often forget that we are imposing
an identification scheme on the underlying classes.

=== Translating data types

* strings are special
* sizing integers

=== Translating classes

In our usage here,
we are overloading the term _class_ to have different meanings.
A model class and a platform-specific class are two distinct things.
They are related.
They are counterparts of each other in the model and platform realms,
but they are very different entities, logically.
In this section,
we discuss how to transform the logic of a model class into the
specifications of an platform-specific class.
To be clear,
we will refer to _model class_ when we are discussing the class
characteristics as they are presented in the data model and
_platform class_ when we are discussing how the implementation
of the model level concepts are realized.

==== Purely descriptive attributes

Attributes that are descriptive in nature and play no other role in the
model class are declared using `attribute` commands.
For example,
a model class might appear as:

["plantuml",title="Pump class in a model"]
----
@startuml
hide methods
hide circle
skinparam class {
    BackgroundColor yellow
    BorderColor black
}

class Pump {
    Pump ID : ID    {I}
    Max pressure : MPa
    Min pressure : MPa
    Flow rate : Liters per minute
}
@enduml
----

The three attributes, *Max pressure*, *Min pressure*, and *Flow rate*
are descriptive of the characteristics of a *Pump* and serve no other
role in the model class.
They are specified in the platform class using the `attribute` commmand.

.Pump platform class 
----
class Pump {
    attribute Max_pressure MPa_t
    attribute Min_pressure MPa_t
    attribute Flow_rate LpM_t
}
----

Note, attribute names must be value ``C'' identifiers and we assume
that the `MPa_t` and `LpM_t` type aliases have been defined.



=== Translating relationships

* names as "C" identifiers

* data type translation


// vim:syntax=asciidoc:
