== Introduction

This paper presents a set of techniques to demonstrate
translating an
https://en.wikipedia.org/wiki/Executable_UML[Executable UML (XUML)]
domain model into a "C" based implementation using `micca`.

* what is micca ???

=== Workflow overview

The following figure shows the overall workflow for creating a system
using modeling and translating with `micca`.

image::micca-translation.pdf[title="Workflow Overview"]

An *Analyst* creates one or more domain models.
Most systems consist of several domains.
During the analysis phase,
the analysts captures the domain requirements in a platform independent
model.
We do not explain how to perform analysis here.
Many books have been written on that subject and are listed in the
<<bibliography,bibliography>>.

When the analysis is complete,
it is transferred to a *Translator*.
The Translator is a human being.
The material transferred (as indicated by the dashed line in the figure)
is a set of diagrams and text which we
discuss <<model-contents,below>>.
Note that no machine readable content is transferred directly to the
translation phase.

The Translator's role in completing the process
is to examine the contents of the domain model materials
and formulate a micca DSL source file that contains a platform
specific configuration of the domain model.
This document is written to explain that one particular step in the overall
workflow (shown in the light blue oval in the diagram).

Once the domain configuration is complete,
`micca` reads the file and captures the platform specfic elements
it contains.
Using this data,
code is generated for the domain.
The code consists of a ``C'' source file and a ``C'' header file.

The source files for all the domains in the system,
along with any bridge code or other conventionally realized code
files are then compiled and linked together to form an executable
for the program.
Also supplied to the build process is the run-time code required
by `micca`.
Much of the code generated by `micca` depends upon or drives
the operation of its run-time code.
For example,
the state machine dispatch that sequences the lifecycles of class instances
is implemented in the run-time code and driven by data supplied in the
domain ``C'' source code.
We do *not* describe here how `micca` or its run-time code operate.
`Micca` and the run-time are fully described
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/wiki?name=MiccaPage[elsewhere].

There are several points of interest in this workflow.

* The tooling for the analysis is completely separated from that of the
  translation.
  Ideally, it would be more convenient to automate the translation
  process by eliminating the human translator.
  In practice, the complexity of UML tooling and specifically the narrow
  use of UML concepts in Executable UML makes that automation
  difficult.
  The solution chosen here is to apply human intelligence to bridge the
  tooling gap.
  We do not consider this any more unusual than applying human
  intelligence to write any other computer program.
* Because a human is involved,
  there are substantial possiblities for tailoring the solution to the
  specfic needs of the target platform.
  This can be quite difficult when attempting the translation with
  generic tooling intented to support a wider array of platforms.
* There is substantial amount of the system that is conventionally coded.
  Bridge code is supplied manually.
  Low level operating system or device specific code is usually required to
  interface to the external world.
  Claims of translation schemes that purport to yield 100% code generation
  should be viewed with skepticism.
* `Micca` is able to externally save it platform specific model population.
  This is used by companion tools, such as
  http://repos.modelrealization.com/cgi-bin/fossil/mrtools/wiki?name=BosalPage[bosal],
  to aid in testing and analyzing the implementation.
* The person who performs the role of Analyst does not have to be the
  same person who performs the role of Translator.
  It is recommended that these two roles be done by different people.
  Having different persons perform the roles adds two important
  project checks:
  ** More than one person becomes familiar with the content of the domain model.
  ** The skill sets required to be a good Translator are quite different than
    those required of a good Analyst.
    Specialization can increase the efficiency of accomplishing the work.

+
Experience has shown that all models have small logical inconsistencies
and errors in them before they are translated.
Such errors or not an indictment of the Analyst's talents.
It is important that the Translator and the Analyst communicate
and correct the inevitable errors that will be found in the first
attempts to translate the model.
The separation of analysis from translation is intended to separate the problem
essentials from the implemenatation artifacts.
It is *not* intended to erect a virtual wall across which political battles can
be waged with one side contending the models can't be made to run
and the other side contending that they are perfectly translatable.

=== Available targets
Available targets

=== Complete model

Before translation can be begin,
it is necessary to have a complete model.
That seems like an obvious statement,
but in our usual rush to finish systems there is a natural tendency
to start translation before the model is complete.
In the end,
starting with a half-baked model wastes time,
especially if the person performing the translation
(as is our recommendation)
is not the same person who created the model.

The need for a complete model does *not* imply that the
model has to satisfy every possible requirement that could be envisioned
for the domain.
The necessity for the domain model be complete and self-consistent
does *not* necessarily imply that it is complete in terms
of the services it provides to the system.
Experience shows that models,
like conventional code bases,
benefit from incremental, iterative development.
Call it agile or waterfall or whatever you like,
skilled practitioners of software development do not build systems
in one strictly sequential undertaking.
Development is iterative and the results of one iteration help direct
subsequent efforts.
The usual recommendation is to model core concepts that are central
to the subject matter of the domain and work out from there to more
peripheral concepts.
Of course such recommendations have little to offer in terms of how
to determine what the core concepts of a domain are.
Experience shows that domain models, like a conventional code base,
tend to have areas where it is less clear what the _right_ thing is
to do.
Usually, some doubts enter into the process near the domain boundary
and its interactions with other domains.
This seems to be a property of any collection of logic when exceeding a certain
size (which size is almost never exceeded by the simple examples usually
presented).

However,
domain models are precise and therefore don't have _fuzzy_ parts that stubbed
out or left open for interpretation or dangling for future elaboration.
So we consider the following a _minimal_ set of deliverables that
are required before translation can begin.[[model-contents]]

* A class model of the domain data. The class model must contain:
  - A UML class diagram (in accordance with XUML usage of class
    diagram constructs).
  - Written descriptions of each class, relationship and attribute.
    Writing descriptions of the class model elements is an essential
    aspect of creating the class model and the presence of the
    descriptions indicates that the analyst has thoroughly considered
    the implications of the model.
  - A description of each model-level data type employed in the
    class model.
    The description must define the set of values (either by formula
    or enumeration) that constitute the data type.
* A state model for each class that has non-trivial lifecycle behavior.
  The state models must contain:
  - A UML state diagram (in accordance with XUML usage).
    The diagram must show the initial state and any final states.
  - A state transition matrix in which every possible transition
    is defined.
    Every transition not shown on the state model diagram must be
    marked as *CH* (can't happen) or *IG* (ignored).
    It is suggested that ignored events be justified as to the reasoning
    for ignoring them.
  - A description of each state and the role it plays in the lifecycle
    of the class.
  - A state activity description of the processing for each state.
    The processing should be described in an unambiguous action language
    or in action data flow diagrams.
* A set of instance operation descriptions for each class
    that defines them, to include:
  - A description of the function and interface of the operation.
  - The processing performed by the operation in terms of action language
    or a data flow diagram.
* A set of domain operation descriptions that include:
  - A written description of the operation function and interface.
  - The processing of the domain operation presented as action language
    or a data flow diagram.
* A set of external entity descriptions that include:
  - A description of the logical dependencies allocated to the external
    entity by the domain.
  - A description of the function and interface for each operation
    performed by the external entity.
    This must include whether the operation is considered as synchronous
    or asynchronous in its behavior.
* An initial instance population of the domain including:
  - Values for every attribute of every instance that is to exist when
    the domain starts.
    The preferred manner of specification is via tabluar layout in a
    purely data oriented fashion.
    Values of referential attributes indicate the relationship instances
    that are part of the initial instance population.
    Using action language to define initial data populations is not
    acceptible.

=== Translation workflow summary

When a language compiler, say a ``C'' compiler, compiles a code file,
it does not produce the code according to the way the program should
have been written if you are a good programmer.
A badly structured piece of source code produces an equally badly
structured output.
The compiler can work only with the what it is given and it must
faithfully produce code, that when executed, accomplishes
the logic contained in the original source.
The compile is unaware of any intent in the code or any higher
order design in the system.

The same is true of translating XUML domain models.
A Translator does not produce code for the model as it would have
come from a good analysis.
The output can only be _derived_ from the model as it was
given by the Analyst.
If the model is overly complex and poorly conceived,
the resulting code will reflect that.

It is most important that the translation do not add or subtract
anything from the logic of the domain model.
The intent of translation is only to add the necessary software
technology to make the domain run on the intended platform.
Consequently,
a Translator tends to pay little attention to the details of
what a domain actually accomplishes.
It is a somewhat rote undertaking.
Rather the focus is on formulating clear and concise program
statements to reflect the actions of the model.
Translation concerns are those of the computing platform and not
those of the subject matter of the domain.

As described previously,
the purpose of this document is to describe a single step in the
overall workflow, namely,
formulating a platform specific domain configuration from the
platform independent modeling material transferred from the
analysis phase
The workflow for formulating the platform specific domain configuration
can be summarized as:

. Perform an introspection of the model, marking it to show the execution
    characteristics.
. Translate the class model.
. Translate the state models.
. Translate the data flow diagrams or action language to "C" code.
. Construct an initial instance population.
. Construct the bridges between domains.

Each of these areas is below in a separate section.


// vim:syntax=asciidoc:
