// vim:set syntax=asciidoc:
= Rash -- Rosea Assimilated Software Hypervisor

== Introduction [[introduction,Introduction]]

This document is about a Tcl package named, `rash`.
`Rash` is a companion package to `rosea`.
By integrating `rash` into a `rosea` based application
it is possible to view and manipulate the internals of the application.

Recall that `rosea` is a XUML data and execution domain.
It consists of two primary parts.
First is run-time code that implements the execution rules of XUML.
The second part is a domain specific configuration languge that allows
you to specify the characteristics of the XUML domain and from that
specification the data needed by the run-time code is generated.

The specification of an XUML domain is gathered by the `rosea` configuration
language into a set of relation variables.
The values held in the relation variables form a meta-description of the
domain.
`Rash` makes use of this meta-description to provide introspection
and manipulation of the domain internals.
For example,
`rash` can show all the instances of the classes of a domain,
generate events to the instances and
invoke operations on the domain or class instances.
Given the dynamic abilities of Tcl/Tk applications,
`rash` is able to tailor the display to match the characteristics of an
arbitrary domain.

`Rash` is a Tk based package.
It reads the meta-description of the domain gathered by `rosea` and,
at run time,
creates a set of windows and widgets to provide access to the aspects
of the domain.
`Rash` is intended to be interactive and provide a means to control
and view the dynamics of a running application.
As such,
it is not particularly well suited to automated operations such as
automated testing.
However,
all the infrastructure that `rash` uses is available for other uses
such as automated testing.

== Design Approach [[designapproach,Design Approach]]

It would be very tempting to implement `rash` using `rosea`.
However,
such an approach would end up mixing up the specification of `rash` with
that of the domains that `rash` is trying to view and control.
It turns out that `rash` does not use the full execution capablity that
`rosea` provides and so we can make do with a simpler structure.

We will structure `rash` in much the same way as a `rosea` would generate
it.
So we will use `namespace ensemble` as the fundamental Tcl construct in
organizing `rash`.
Classes will become relvars in a namespace.
Each class will have its operations placed in a child namespace.
Namespace ensemble commands will be used to group collections of operations.
In other words we intend to design `rash` in the same manner as
`rosea` would generate but without creating a `rosea` configuration.
We will serve as our own generator for `rash`.
This will make sure that none of the artifacts of `rash` can possibly interfer
with the domains on which `rash` is being used.

[source,tcl]
----
<<required packages>>=
package require rosea
package require ral
package require ralutil
----

== Class Diagram [[classdiagram,Class Diagram]]

Below is the class diagram.

image::classes.pdf[title="Rash Class Diagram"]

[source,tcl]
----
<<rash classes>>=
<<APP class>>
<<MBAR class>>
<<DSEL class>>
<<DOMSTAT class>>
----

[source,tcl]
----
<<rash relationships>>=
<<R1>>
<<R2>>
<<R3>>
----

=== Application Class

[source,tcl]
----
<<APP data>>=
relvar create APP {
    AppId string
    Hull string
    Version string
} AppId
----

==== Create Operation

(((rash,APP,create)))
[source,tcl]
----
<<APP code>>=
proc create {appid hull {version 1.0a1}} {
    relvar eval {
        <<APP create: insert instance>>
        <<APP create: configure display>>
        <<APP create: create menu bar>>
        <<APP create: create domain selector>>
        <<APP create: create trace viewer>>
    }

    return $self
}
<<APP exports>>=
namespace export create
----

[source,tcl]
----
<<APP create: insert instance>>=
set self [relvar insert ::rash::APP [list\
    AppId       $appid\
    Hull        $hull\
    Version     $version\
]]
relation assign $self
----

[source,tcl]
----
<<APP create: configure display>>=
toplevel $Hull
wm title $Hull "Rash  Version $Version"
wm protocol $Hull WM_DELETE_WINDOW ::exit

grid rowconfigure $Hull 1 -weight 1
grid columnconfigure $Hull 0 -weight 1
----

[source,tcl]
----
<<APP create: create menu bar>>=
set mbarHull $Hull.mbar
MBAR create $AppId $mbarHull
$Hull configure -menu $mbarHull
----

[source,tcl]
----
<<APP create: create domain selector>>=
set dselHull $Hull.dsel
DSEL create $AppId $dselHull
grid $dselHull -sticky w
----

[source,tcl]
----
<<APP create: create trace viewer>>=
#set trcHull $Hull.tview
#TRCVIEW create $AppId $trcHull
#grid $trcHull -sticky nsew
----

==== ShowUserMessage Operation

(((rash,APP,ShowUserMessage)))
[source,tcl]
----
<<APP code>>=
proc ShowUserMessage {self type title msg} {
    tk_messageBox\
        -icon $type\
        -title $title\
        -parent [readAttribute $self Hull]\
        -type ok\
        -message $msg
}
<<APP exports>>=
namespace export ShowUserMessage
----

==== Class Implementation

[source,tcl]
----
<<class namespace path>>=
namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
----

[source,tcl]
----
<<APP class>>=
<<APP data>>
namespace eval APP {
    <<class namespace path>>
    <<APP code>>
    <<APP exports>>
    namespace ensemble create
}
----

=== Menu Bar Class

[source,tcl]
----
<<MBAR data>>=
relvar create MBAR {
    AppId string
    Hull string
} AppId
----

==== Create Operation

[source,tcl]
----
<<MBAR code>>=
proc create {appid hull {debuglevel warn}} {
    set self [relvar insert ::rash::MBAR [list\
        AppId           $appid\
        Hull            $hull\
    ]]
    relation assign $self

    set self [ToRef ::rash::MBAR $self]

    variable DebugLevel
    set DebugLevel($AppId) $debuglevel

    menu $Hull
    $Hull add cascade\
        -label File\
        -menu $Hull.file

    menu $Hull.file
    $Hull.file add command\
        -label Exit\
        -command ::exit

    $Hull add cascade\
        -label Show\
        -menu $Hull.show

    menu $Hull.show
    if {$::tcl_platform(platform) eq "windows"} {
        $Hull.show add command\
            -label Console\
            -command [namespace code [list ShowConsole $self]]
    }
    $Hull.show add cascade\
        -label Debug\
        -menu $Hull.debug
    $Hull.show add command\
        -label About\
        -command [namespace code [list ShowAbout $self]]

    menu $Hull.debug
    foreach level [::logger::levels] {
        $Hull.debug add radiobutton\
            -label $level\
            -variable [namespace current]::DebugLevel($AppId)\
            -command [namespace code [list LogLevel $self]]
    }

    return $self
}
<<MBAR exports>>=
namespace export create
----

==== ShowConsole Operation

[source,tcl]
----
<<MBAR code>>=
proc ShowConsole {self} {
    catch {
        ::console show
        ::console title "Rash Console"
    }
}
----

==== ShowAbout Operation

[source,tcl]
----
<<MBAR code>>=
proc ShowAbout {self} {
    lassign $self relvar inst
    set app [pipe {
        relvar set ::rash::APP |
        relation semijoin $inst ~ -using {AppId AppId} |
        ToRef ::rash::APP ~
    }]
    APP ShowUserMessage $app info Rash\
        "[relation extract $inst AppId]\n\
        Copyright 2015, G. Andrew Mangogna\n\
        Revision: [readAttribute $app Version]"

    return
}
----

==== LogLevel Operation

[source,tcl]
----
<<MBAR code>>=
proc LogLevel {self} {
    variable DebugLevel
    ::logger::setlevel $DebugLevel([readAttribute $self AppId])
    return
}
----

==== Class Implementation

[source,tcl]
----
<<MBAR class>>=
<<MBAR data>>
namespace eval MBAR {
    <<class namespace path>>
    <<MBAR code>>
    <<MBAR exports>>
    namespace ensemble create
}
----

=== R1 -- MBAR ==> APP

[source,tcl]
----
<<rash relationships>>=
relvar association R1\
    MBAR AppId 1\
    APP AppId 1
----

=== Domain Selector Class

[source,tcl]
----
<<DSEL data>>=
relvar create DSEL {
    AppId string
    Hull string
} AppId
----

==== Create Operation

[source,tcl]
----
<<DSEL code>>=
proc create {appid hull} {
    set self [relvar insert ::rash::DSEL [list\
        AppId           $appid\
        Hull            $hull\
    ]]
    relation assign $self
    set self [ToRef ::rash::DSEL $self]

    ttk::labelframe $Hull\
        -takefocus 0\
        -text "Domain Selection"
    grid rowconfigure $Hull 0 -weight 1
    grid columnconfigure $Hull 0 -weight 1

    variable DomainSelect
    set DomainSelect($AppId) {}
    set domlist [pipe {
        ral relvar set ::rosea::Config::Domain |
        relation list ~ Name
    }]
    ttk::combobox $Hull.doms\
        -values $domlist\
        -textvariable [namespace current]::DomainSelect($AppId)
    $Hull.doms set [lindex $domlist 0]
    ::bind $Hull.doms <<ComboboxSelected>>\
            [namespace code [list DomainSelect $self]]

    grid $Hull.doms\
        -padx 4\
        -sticky ew

    return $self
}
<<DSEL exports>>
namespace export create
----

==== Domain Select Operation

[source,tcl]
----
proc DomainSelect {self} {
    assignAttribute $self
    variable DomainSelect
    if {$DomainSelect($AppId) ne {}} {
        set dstat [pipe {
            relvar set ::rash::DOMSTAT |
            relation semijoin $self ~ -using {AppId AppId}
        }]
        if {[relation isempty $dstat]} {
            relvar eval {
                DOMSTAT create $AppId $domainselect($AppId)\
                    $Hull.[string tolower $domainselect($AppId)]
            }
        } else {
            DOMSTAT raise $dstat
        }
    }
}
----

==== Class Implementation

[source,tcl]
----
<<DSEL class>>=
<<DSEL data>>
namespace eval DSEL {
    <<class namespace path>>
    <<DSEL code>>
    <<DSEL exports>>
    namespace ensemble create
}
----

=== R2 -- DSEL ==> APP

[source,tcl]
----
<<rash relationships>>=
relvar association R2\
    DSEL AppId 1\
    APP AppId 1
----

=== Domain Status Class

[source,tcl]
----
<<DOMSTAT data>>=
relvar create DOMSTAT {
    AppId string
    Hull string
} AppId
----

==== Create Operation

[source,tcl]
----
<<DOMSTAT code>>=
proc create {appid domain hull} {
    set self [relvar insert ::rash::DOMSTAT [list\
        AppId $appid\
        Domain $domain\
        Hull $hull
    ]]
    relation assign $self
    set self [ToRef ::rash::DSEL $self]

    set dominst [ral relvar restrictone ::rosea::Config::Domain Name $Domain]
    toplevel $Hull
    wm title $Hull "Domain: $domain"
    wm protocol $Hull WM_DELETE_WINDOW [list wm withdraw $Hull]
    grid rowconfigure $Hull 0 -weight 1
    grid columnconfigure $Hull 0 -weight 1

    set frame [ttk::labelframe $hull.clf -text Classes]
    grid $frame -sticky nsew
    grid rowconfigure $frame 0 -weight 1
    grid columnconfigure $frame 0 -weight 1

    set nb [ttk::notebook $frame.nb -takefocus 0]
    grid $nb -sticky nsew
    grid rowconfigure $nb 0 -weight 1
    grid columnconfigure $nb 0 -weight 1

    set classes [pipe {
        ral relvar set ::rosea::Config::Class |
        relation restrict ~ classtup {
            [tuple extract $classtup Domain] eq $Domain
        }
    }]
    relation foreach class $classes -ascending Name {
        relation assign $class {Name className}
        set cframe $nb.[string tolower $className]
        DOMCLASS create $AppId $Domain $className $cframe

        $nb add $cframe -text $className -sticky nsew
    }

    set ops [pipe {
        ral relvar set ::rosea::Config::DomainOperation |
        relation restrict ~ optup {
            [tuple extract $optup Domain] eq $Domain
        }
    }]
    if {[relation isnotempty $ops]} {
        set frame [ttk::labelframe $hull.opf -text Operations]
        grid $frame -sticky nsew
        grid rowconfigure $frame 0 -weight 1
        grid columnconfigure $frame 0 -weight 1

        set opnum 0
        relation foreach op $ops -ascending Name {
            relation assign $op {Name name} {Parameters params}
            set but [ttk::button $frame.op$opnum\
                -text $name\
                -takefocus 1\
                -command [namespace code\
                    [list domop $self $name $opnum [llength $params]]]\
            ]
            grid $but -pady 4 -row $opnum -column 0 -sticky e

            bind $but <Return> {%W invoke}
            bind $but <KP_Enter> {%W invoke}

            set prnum 0
            foreach param $params {
                lassign $param pname pdefault
                set lab [ttk::label $frame.lab$opnum$prnum -text $pname]
                set ent [ttk::entry $frame.ent$opnum$prnum]
                $ent insert 0 $pdefault

                bind $ent <Return> {focus [tk_focusNext %W]}
                bind $ent <KP_Enter> {focus [tk_focusNext %W]}

                grid $lab\
                    -padx 2\
                    -row $opnum\
                    -column [expr {$prnum * 2 + 1}]\
                    -sticky e
                grid $ent\
                    -padx 2\
                    -row $opnum\
                    -column [expr {$prnum * 2 + 2}]\
                    -sticky w

                incr prnum
            }

            if {$prnum > 0} {
                bind $ent <Return> [list focus $but]
                bind $ent <KP_Enter> [list focus $but]
            }
            incr opnum
        }
        grid rowconfigure $Hull 1 -weight 1
    }

    return $self
}
<<DOMSTAT exports>>=
namespace export create
----

==== Domop Operation

[source,tcl]
----
proc domop {self opname opnum pnum} {
    assignAttribute $self Domain Hull

    set params [list]
    for {set i 0} {$i < $pnum} {incr i} {
        lappend params [$Hull.opf.ent$opnum$i get]
    }
    set domcmd [FullyQualifyDomain $Domain]

    $domcmd $opname {*}$params
}
----

[source,tcl]
----
<<rash code>>=
proc FullyQualifyDomain {domain} {
    return [pipe {
        relvar restrictone ::rosea::Config::Domain Name $domain |
        relation extract ~ Location |
        string cat ~ ::${domain}
    }]
}
----

==== Class Implementation

[source,tcl]
----
<<DOMSTAT class>>=
<<DOMSTAT data>>
namespace eval DOMSTAT {
    <<class namespace path>>
    <<DOMSTAT code>>
    <<DOMSTAT exports>>
    namespace ensemble create
}
----

=== R3 -- DOMSTAT ==> APP

[source,tcl]
----
relvar association R3\
    DOMSTAT AppId *\
    DSEL AppId 1
----

== Code Organization

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<rash.tcl>>=
<<copyright info>>

package require Tcl 8.6
package require Tk 8.6

option add *tearOff false

package require logger
<<required packages>>

namespace eval ::rash {
    namespace import ::ral::*
    namespace import ::ralutil::*

    variable version 1.0a1

    <<rash classes>>
    <<rash relationships>>
    <<rash code>>

    namespace export init
    proc init {{appid Rash}} {
        APP create $appid .[string tolower $appid]
    }
    namespace ensemble create
}

package provide rash $::rash::version
----

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded rash 1.0a1 [list source [file join $dir rash.tcl]]
----

=== User's Manual

[source,tcl]
----
<<rash.man>>=
[manpage_begin rash n 1.0a1]
[comment {
<<copyright info>>
}]
[moddesc "Rosea Interactive Introspection"]
[titledesc "Rash"]
[copyright "2015 by G. Andrew Mangogna"]
[require rash [opt 1.0a1]]
[description]
Rash
[manpage_end]
----

=== Unit Tests

[source,tcl]
----
<<rash.test>>=
<<copyright info>>

package require cmdline
package require logger

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

logger::setlevel $options(level)

source ../src/rash.tcl
chan puts "testing rash version: [package require rash]"

package require tcltest
eval tcltest::configure $argv

namespace eval ::rash::test {
    namespace import ::tcltest::*
    ::logger::initNamespace [namespace current]

    wm withdraw .

    rash init

    tkwait window .rash

    cleanupTests
}
----

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/tcl-cm3/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
