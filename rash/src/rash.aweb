// vim:set syntax=asciidoc:
= Rash -- Rosea Assimilated Software Hypervisor

== Introduction [[introduction,Introduction]]

This document is about a Tcl package named, `rash`.
`Rash` is a companion package to `rosea`.
By integrating `rash` into a `rosea` based application
it is possible to view and manipulate the internals of the application.

Recall that `rosea` is a XUML data and execution domain.
It consists of two primary parts.
First is run-time code that implements the execution rules of XUML.
The second part is a domain specific configuration languge that allows
you to specify the characteristics of the XUML domain and from that
specification the data needed by the run-time code is generated.

The specification of an XUML domain is gathered by the `rosea` configuration
language into a set of relation variables.
The values held in the relation variables form a meta-description of the
domain.
`Rash` makes use of this meta-description to provide introspection
and manipulation of the domain internals.
For example,
`rash` can show all the instances of the classes of a domain,
generate events to the instances and
invoke operations on the domain or class instances.
Given the dynamic abilities of Tcl/Tk applications,
`rash` is able to tailor the display to match the characteristics of an
arbitrary domain.

`Rash` is a Tk based package.
It reads the meta-description of the domain gathered by `rosea` and,
at run time,
creates a set of windows and widgets to provide access to the aspects
of the domain.
`Rash` is intended to be interactive and provide a means to control
and view the dynamics of a running application.
As such,
it is not particularly well suited to automated operations such as
automated testing.
However,
all the infrastructure that `rash` uses is available for other uses
such as automated testing.

== Design Approach [[designapproach,Design Approach]]

It would be very tempting to implement `rash` using `rosea`.
However,
such an approach would end up mixing up the specification of `rash` with
that of the domains that `rash` is trying to view and control.
It turns out that `rash` does not use the full capablity that
`rosea` provides and so we can make do with a simpler structure
while avoiding any conflict with the domains that `rash` is dealing with.

We will structure `rash` in much the same way as `rosea` generates
code for domains.
So we will use `namespace ensemble` as the fundamental Tcl construct in
organizing `rash`.
Classes will become relvars in a namespace.
Each class will have its operations placed in a child namespace.
Namespace ensemble commands will be used to group collections of operations.
In other words we intend to design `rash` in the same manner consistent with
what `rosea` would generate but without creating a `rosea` configuration.
We will serve as our own generator for `rash`.
This will make sure that none of the artifacts of `rash` can possibly interfer
with the domains on which `rash` is being used.

`Rash` will be very aware of `rosea` as it needs to access configuration
data and will use some procedures defined in `rosea`.
This does create a rather tight coupling between the two packages but
that is unavoidable given what `rash` accomplishes.
We will not be able to use `rosea` constructs for navigating the class
model and other types of activities that would
require a fully configured `rosea` domain.
We will find ourselves having to code such things directly.
Fortunately,
`rash` is a relatively small application and coding the relational
algebraic expression directly is not particularly onerous.

[source,tcl]
----
<<required packages>>=
package require rosea
----

== Class Diagram [[classdiagram,Class Diagram]]

Although we do not intend to translate `rash` using `rosea`,
a class diagram is essential in knowing how `rash` is structured.
The figure below shows the classes and relationships for `rash`.
The classes in this model represent visual item with which a user
interacts and which show the internal aspects of a domain.
We will directly interface to the Tk commands that control the GUI.
We will not make any attempt to add a bridging layer into this package.
That `rosea` is bound to Tcl and `rash` is bound to `rosea` makes us
conclude that there is nothing to be gained by abstracting the GUI
to be able to run on a different windowing toolkit.
We are firmly in the Tcl/Tk camp and there is no reason to introduce
abstraction layers that can potentially obscure the logic of the program.

image::classes.pdf[title="Rash Class Diagram"]

From the graphic we can see that `rash` will consist of the following
clases.

[source,tcl]
----
<<rash classes>>=
<<APP class>>
<<MBAR class>>
<<DSEL class>>
<<DOMSTAT class>>
<<TRCVIEW class>>
<<DOMCLASS class>>
<<DVAL class>>
<<CEVT class>>
<<EVTPARAM class>>
<<SM class>>
----

Similarly,
the following relationships are shown in the graphic.

[source,tcl]
----
<<rash relationships>>=
<<R1>>
<<R2>>
<<R3>>
<<R4>>
<<R5>>
<<R6>>
<<R7>>
<<R8>>
<<R9>>
----

=== Application Class

// HERE need cross reference
We will describe later how to integrate `rash` into another application
so that you may interact with domains in that application.
However,
from the `rash` point of view,
the Application class represents the top level of the Tk widget
hierarchy that is used to present domains to the user.
The class diagram graphic shows the following attributes.

[source,tcl]
----
<<APP data>>=
relvar create APP {
    AppId string
    Hull string
    Version string
} AppId Hull
----

We will use the convention of having a `Hull`
attribute to hold the Tk window name that is the visual representation
of an aspect of the `rash` display.
We will not hold every window in the application as an attribute
of some class.
Only those windows to which we must later refer need be held as an attribute.
We will often see that we need only record the root of some window subtree
in order to accomplish the operations we want.
We also note that Tk window names, which are just strings, are unque
within an application and can serve as an identifier.
To a great extent,
the `Hull` attribute can be viewed as a mapping from the application
logic to the windowing toolkit.

==== Create Operation

Since the classes in `rash` are tightly bound to the Tk windows
they use,
we need to be able to execute some code when an instance is create.
We establish the convention of using a `create` method on the class
to obtain the needed processing when an instance of a class is created.

(((rash,APP,create)))
[source,tcl]
----
<<APP code>>=
proc create {appid hull {version 1.0a1}} {
    relvar eval {
        <<APP create: insert instance>>
        <<APP create: configure display>>
        <<APP create: create menu bar>>
        <<APP create: create domain selector>>
        <<APP create: create trace viewer>>
    }

    return $self
}
<<APP exports>>=
namespace export create
----

The `rash` application will appear as an ordinary top level window
that contains three components:

. A menu bar allowing various aspects to be controlled.
. A domain selector that allows the user to select a particular domain to view.
. A state machine trace viewing window allowing control of the tracing.

We use `relvar insert` to create the class instance.

[source,tcl]
----
<<APP create: insert instance>>=
set self [relvar insert ::rash::APP [list\
    AppId       $appid\
    Hull        $hull\
    Version     $version\
]]
relation assign $self ; # <1>
----
<1> `relvar insert` returns a relation value that contains the _as inserted_
values of the attributes.
These can then be easily placed into Tcl variables using `relation assign`.

[source,tcl]
----
<<APP create: configure display>>=
toplevel $Hull
wm title $Hull "Rash Version $Version"
wm protocol $Hull WM_DELETE_WINDOW ::exit

grid rowconfigure $Hull 1 -weight 1 ; # <1>
grid columnconfigure $Hull 0 -weight 1
----
<1> We give all of the extra space to the trace viewer component.

We now go about creating the three components of the `rash` application
interface.
First the menu bar.

[source,tcl]
----
<<APP create: create menu bar>>=
set mbarHull $Hull.mbar
MBAR create $AppId $mbarHull
$Hull configure -menu $mbarHull
----

Then the domain selector.

[source,tcl]
----
<<APP create: create domain selector>>=
set dselHull $Hull.dsel
DSEL create $AppId $dselHull
grid $dselHull -sticky nsew -pady 4
----

And finally the trace viewer.

[source,tcl]
----
<<APP create: create trace viewer>>=
set trcHull $Hull.tview
TRCVIEW create $AppId $trcHull
grid $trcHull -sticky nsew -pady 4
----

==== ShowUserMessage Operation

It is convenient to localize the processing for communicating with
the user into one place.

(((rash,APP,ShowUserMessage)))
[source,tcl]
----
<<APP code>>=
proc ShowUserMessage {self type title msg} {
    tk_messageBox\
        -icon $type\
        -title $title\
        -parent [readAttribute $self Hull]\
        -type ok\
        -message $msg
}
<<APP exports>>=
namespace export ShowUserMessage
----

Note the use of the `readAttribute` procedure above.
This is actually a `rosea` procedure and we will find it convenient
to use some `rosea` constructs, especially for instance references,
and the procedures associated with the constructs.
After all,
we are in effect directly coding the `rash` model in a manner that
is similar to what `rosea` would have generated.
It is not surprising that some of the `rosea` code would be useful.
To make access to the `rosea` code easier,
we can use the ability of a namespace to have a command resolution
path.

[source,tcl]
----
<<class namespace path>>=
namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
----

==== Class Implementation

We now compose the components of the `APP` class implementation.
This will be a repeated pattern for the other classes in `rash`.
Following the pattern of `rosea` generated code,
each class is placed in its own namespace that is, in this case,
a child namespace of `::rash`.

[source,tcl]
----
<<APP class>>=
<<APP data>>
namespace eval APP {
    <<class namespace path>>
    <<APP code>>
    <<APP exports>>
    namespace ensemble create
}
----

=== Menu Bar Class

Visually,
a menu bar is a set of buttons attached to cascading menus that sits
along the top of the main application window.
A menu bar provides easy access to common control functions.

[source,tcl]
----
<<MBAR data>>=
relvar create MBAR {
    AppId string
    Hull string
} AppId Hull
----

==== Create Operation

Following our established pattern,
we provide a `create` method to create an `MBAR` instance
and all of the Tk machinery behind it.

(((rash,MBAR,create)))
[source,tcl]
----
<<MBAR code>>=
proc create {appid hull {debuglevel warn}} {
    <<MBAR create: insert instance>>
    <<MBAR create: configure display>>

    return $self
}
<<MBAR exports>>=
namespace export create
----

As before,
we insert an instance into the relvar that holds the `MBAR` instances
and assign the attributes into Tcl variables for later use.

[source,tcl]
----
<<MBAR create: insert instance>>=
set self [relvar insert ::rash::MBAR [list\
    AppId           $appid\
    Hull            $hull\
]]
relation assign $self
----

[source,tcl]
----
<<MBAR create: configure display>>=
menu $Hull
$Hull add cascade\
    -label File\
    -menu $Hull.file

menu $Hull.file
$Hull.file add command\
    -label Exit\
    -command ::exit
----

[source,tcl]
----
<<MBAR create: configure display>>=
$Hull add cascade\
    -label Show\
    -menu $Hull.show

menu $Hull.show
if {$::tcl_platform(platform) eq "windows"} {
    $Hull.show add command\
        -label Console\
        -command [namespace code [list ShowConsole $AppId]]
}
----

[source,tcl]
----
<<MBAR create: configure display>>=
$Hull.show add cascade\
    -label Debug\
    -menu $Hull.debug

set levelvar [namespace current]::DebugLevel($AppId)
set cmd [namespace code [list LogLevel $AppId]]
menu $Hull.debug
foreach level [::logger::levels] {
    $Hull.debug add radiobutton\
        -label $level\
        -variable $levelvar\
        -command $cmd
}
----

Note how we have handled the variable needed by the radiobutton menu items.
Frequently,
Tk widgets use Tcl variables to store the data displayed by the widget.
Naturally, Tk does not know about relations values and attributes.
So sometimes it is necessary to use namespace variables to accomodate Tk.
By placing the data needed by Tk into an array indexed by an identifier
of the class instance,
then we achieve the same purpose,
albeit in a slightly less convenient form,
as holding the data in an attribute of the class.

[source,tcl]
----
<<MBAR create: insert instance>>=
variable DebugLevel
set DebugLevel($AppId) $debuglevel
----

[source,tcl]
----
<<MBAR create: configure display>>=
$Hull.show add command\
    -label About\
    -command [namespace code [list ShowAbout $AppId]]
----


==== ShowConsole Operation

(((rash,MBAR,ShowConsole)))
[source,tcl]
----
<<MBAR code>>=
proc ShowConsole {appid} {
    catch {
        ::console show
        ::console title "Rash Console"
    }
}
----

==== ShowAbout Operation

(((rash,MBAR,ShowAbout)))
[source,tcl]
----
<<MBAR code>>=
proc ShowAbout {appid} {
    set app [pipe {
        relvar restrictone ::rash::APP AppId $appid |
        ToRef ::rash::APP ~
    }]
    APP ShowUserMessage $app info Rash\
        "$appid\n\
        Copyright 2015, G. Andrew Mangogna\n\
        Revision: [readAttribute $app Version]"

    return
}
----

==== LogLevel Operation

(((rash,MBAR,LogLevel)))
[source,tcl]
----
<<MBAR code>>=
proc LogLevel {appid} {
    variable DebugLevel
    ::logger::setlevel $DebugLevel($appid)
    return
}
----

==== Class Implementation

[source,tcl]
----
<<MBAR class>>=
<<MBAR data>>
namespace eval MBAR {
    <<class namespace path>>
    <<MBAR code>>
    <<MBAR exports>>
    namespace ensemble create
}
----

=== R1 -- MBAR => APP

Each Application has exactly one Menu Bar and each Menu Bar
serves exactly one Application.

Class relationships become relvar constraints in `rash`.

[source,tcl]
----
<<R1>>=
relvar association R1\
    MBAR AppId 1\
    APP AppId 1
----

=== Domain Selector Class

`Rash` can handle applications that contain multiple domains.
The Domain Selector class allows a use to choose a domain to view and
control.

[source,tcl]
----
<<DSEL data>>=
relvar create DSEL {
    AppId string
    Hull string
} AppId Hull
----

==== Create Operation

(((rash,DSEL,create)))
[source,tcl]
----
<<DSEL code>>=
proc create {appid hull} {
    <<DSEL create: insert instance>>
    <<DSEL create: configure display>>
    <<DSEL create: bind to selection>>

    return $self
}
<<DSEL exports>>=
namespace export create
----

[source,tcl]
----
<<DSEL create: insert instance>>=
set self [relvar insert ::rash::DSEL [list\
    AppId           $appid\
    Hull            $hull\
]]
relation assign $self
----

[source,tcl]
----
<<DSEL create: configure display>>=
ttk::labelframe $Hull\
    -takefocus 0\
    -text "Domain Selection"
grid rowconfigure $Hull 0 -weight 1
grid columnconfigure $Hull 0 -weight 1
----

[source,tcl]
----
<<DSEL create: insert instance>>=
set domlist [pipe {
    ral relvar set ::rosea::Config::Domain |
    relation list ~ Name
}]
variable DomainSelect
set DomainSelect($AppId) [lindex $domlist 0]
----

[source,tcl]
----
<<DSEL create: configure display>>=
ttk::combobox $Hull.doms\
    -values $domlist\
    -textvariable [namespace current]::DomainSelect($AppId)
grid $Hull.doms\
    -padx 4\
    -sticky w
----

[source,tcl]
----
<<DSEL create: bind to selection>>=
::bind $Hull.doms <<ComboboxSelected>>\
    [namespace code [list DomainSelect $Hull]]
----

==== Domain Select Operation

(((rash,DSEL,DomainSelect)))
[source,tcl]
----
<<DSEL code>>=
proc DomainSelect {hull} {
    set self [relvar restrictone ::rash::DSEL Hull $hull]
    relation assign $self
    variable DomainSelect
    if {$DomainSelect($AppId) ne {}} {
        set dstat [pipe {
            relvar set ::rash::DOMSTAT |
            relation semijoin $self ~ -using {AppId AppId}
        }]
        if {[relation isempty $dstat]} {
            relvar eval {
                DOMSTAT create $AppId $DomainSelect($AppId)\
                    $Hull.[string tolower $DomainSelect($AppId)]
            }
        } else {
            wm deiconify [relation extract $dstat Hull]
        }
    }
}
----

==== Class Implementation

[source,tcl]
----
<<DSEL class>>=
<<DSEL data>>
namespace eval DSEL {
    <<class namespace path>>
    <<DSEL code>>
    <<DSEL exports>>
    namespace ensemble create
}
----

=== R2 -- DSEL => APP

[source,tcl]
----
<<R2>>=
relvar association R2\
    DSEL AppId 1\
    APP AppId 1
----

=== Domain Status Class

[source,tcl]
----
<<DOMSTAT data>>=
relvar create DOMSTAT {
    AppId string
    Domain string
    Hull string
} {AppId Domain} Hull
----

==== Create Operation

[source,tcl]
----
<<DOMSTAT code>>=
proc create {appid domain hull} {
    set self [relvar insert ::rash::DOMSTAT [list\
        AppId $appid\
        Domain $domain\
        Hull $hull
    ]]
    relation assign $self
    set ref [ToRef ::rash::DOMSTAT $self]

    set dominst [ral relvar restrictone ::rosea::Config::Domain Name $Domain]
    toplevel $Hull
    wm title $Hull "Domain: $domain"
    wm protocol $Hull WM_DELETE_WINDOW [list wm withdraw $Hull]
    grid rowconfigure $Hull 0 -weight 1
    grid columnconfigure $Hull 0 -weight 1

    set frame [ttk::labelframe $hull.clf -text Classes]
    grid $frame -sticky nsew
    grid rowconfigure $frame 0 -weight 1
    grid columnconfigure $frame 0 -weight 1

    set nb [ttk::notebook $frame.nb -takefocus 0]
    grid $nb -sticky nsew
    grid rowconfigure $nb 0 -weight 1
    grid columnconfigure $nb 0 -weight 1

    set classes [pipe {
        ral relvar set ::rosea::Config::Class |
        relation restrict ~ classtup {
            [tuple extract $classtup Domain] eq $Domain
        }
    }]
    relation foreach class $classes -ascending Name {
        relation assign $class {Name className}
        set cframe $nb.[string tolower $className]
        DOMCLASS create $AppId $Domain $className $cframe

        $nb add $cframe -text $className -sticky nsew
    }

    set ops [pipe {
        ral relvar set ::rosea::Config::DomainOperation |
        relation restrict ~ optup {
            [tuple extract $optup Domain] eq $Domain
        }
    }]
    if {[relation isnotempty $ops]} {
        set frame [ttk::labelframe $hull.opf -text Operations]
        grid $frame -sticky nsew
        grid rowconfigure $frame 0 -weight 1
        grid columnconfigure $frame 0 -weight 1

        set opnum 0
        relation foreach op $ops -ascending Name {
            relation assign $op {Name name} {Parameters params}
            set but [ttk::button $frame.op$opnum\
                -text $name\
                -takefocus 1\
                -command [namespace code\
                    [list domop $ref $name $opnum [llength $params]]]\
            ]
            grid $but -pady 4 -row $opnum -column 0 -sticky e

            bind $but <Return> {%W invoke}
            bind $but <KP_Enter> {%W invoke}

            set prnum 0
            foreach param $params {
                lassign $param pname pdefault
                set lab [ttk::label $frame.lab$opnum$prnum -text $pname]
                set ent [ttk::entry $frame.ent$opnum$prnum]
                $ent insert 0 $pdefault

                bind $ent <Return> {focus [tk_focusNext %W]}
                bind $ent <KP_Enter> {focus [tk_focusNext %W]}

                grid $lab\
                    -padx 2\
                    -row $opnum\
                    -column [expr {$prnum * 2 + 1}]\
                    -sticky e
                grid $ent\
                    -padx 2\
                    -row $opnum\
                    -column [expr {$prnum * 2 + 2}]\
                    -sticky w

                incr prnum
            }

            if {$prnum > 0} {
                bind $ent <Return> [list focus $but]
                bind $ent <KP_Enter> [list focus $but]
            }
            incr opnum
        }
        grid rowconfigure $Hull 1 -weight 1
    }

    return $self
}
<<DOMSTAT exports>>=
namespace export create
----

==== Domop Operation

[source,tcl]
----
<<DOMSTAT code>>=
proc domop {self opname opnum pnum} {
    assignAttribute $self Domain Hull

    set params [list]
    for {set i 0} {$i < $pnum} {incr i} {
        lappend params [$Hull.opf.ent$opnum$i get]
    }
    set domcmd [FullyQualifyDomain $Domain]

    $domcmd $opname {*}$params
}
----

[source,tcl]
----
<<rash code>>=
proc FullyQualifyDomain {domain} {
    return [pipe {
        relvar restrictone ::rosea::Config::Domain Name $domain |
        relation extract ~ Location |
        string cat ~ ::${domain}
    }]
}
----

==== Class Implementation

[source,tcl]
----
<<DOMSTAT class>>=
<<DOMSTAT data>>
namespace eval DOMSTAT {
    <<class namespace path>>
    <<DOMSTAT code>>
    <<DOMSTAT exports>>
    namespace ensemble create
}
----

=== R3 -- DOMSTAT => APP

[source,tcl]
----
<<R3>>=
relvar association R3\
    DOMSTAT AppId *\
    DSEL AppId 1
----

=== Trace View Class

[source,tcl]
----
<<TRCVIEW data>>=
relvar create TRCVIEW {
    AppId string
    Hull string
    IsFrozen boolean
    SaveDir string
} AppId Hull
----

==== Create Operation

[source,tcl]
----
<<required packages>>=
package require autoscroll
----

[source,tcl]
----
<<TRCVIEW code>>=
proc create {appid hull} {
    set self [relvar insert ::rash::TRCVIEW [list\
        AppId $appid\
        Hull $hull\
        IsFrozen false\
        SaveDir [pwd]\
    ]]
    relation assign $self

    ttk::frame $Hull
    grid rowconfigure $Hull 0 -weight 1
    grid columnconfigure $Hull 0 -weight 1

    ttk::labelframe $Hull.traces\
        -text "State Machine Traces"
    grid $Hull.traces\
        -sticky nsew
    grid rowconfigure $Hull.traces 0 -weight 1
    grid columnconfigure $Hull.traces 0 -weight 1

    text $Hull.traces.text\
        -wrap word\
        -setgrid true\
        -width 100\
        -insertwidth 0\
        -yscrollcommand [list $Hull.traces.vsb set]

    $Hull.traces.text tag configure CHtrace\
        -background red\
        -foreground black
    $Hull.traces.text tag configure IGtrace\
        -background yellow\
        -foreground black
    $Hull.traces.text tag configure TSfield\
        -background gray90

    ttk::scrollbar $Hull.traces.vsb\
        -orient vertical\
        -command [list $Hull.traces.text yview]
    ::autoscroll::autoscroll $Hull.traces.vsb

    grid $Hull.traces.text $Hull.traces.vsb -sticky nsew

    ttk::labelframe $Hull.ctrls\
        -text "Trace Controls"
    grid $Hull.ctrls\
        -sticky nsew\
        -pady 4
    ttk::button $Hull.ctrls.start\
        -text Start\
        -command [namespace code [list StartTrace $AppId]]
    ttk::button $Hull.ctrls.frz\
        -text Freeze\
        -command [namespace code [list FreezeTrace $AppId]]
    ttk::button $Hull.ctrls.clr\
        -text Clear\
        -command [namespace code [list ClearTrace $AppId]]
    ttk::button $Hull.ctrls.save\
        -text Save\
        -command [namespace code [list SaveTrace $AppId]]
    grid $Hull.ctrls.start $Hull.ctrls.frz $Hull.ctrls.clr $Hull.ctrls.save\
        -padx 4\
        -pady 4
}
<<TRCVIEW exports>>=
namespace export create
----

[source,tcl]
----
<<TRCVIEW code>>=
proc FormatTrace {appid txt {tag {}}} {
    set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
    relation assign $self Hull IsFrozen

    switch -glob -- $txt {
        {*-> CH*} {
            set tag CHtrace
        }
        {*-> IG*} {
            set tag IGtrace
        }
    }

    $Hull.traces.text insert end\
        [::rosea::Trace::FormatTimestamp [clock microseconds]] TSfield\
        { } {}\
        $txt\n $tag

    if {!$IsFrozen} {
        $Hull.traces.text see end
    }
}
----

[source,tcl]
----
<<TRCVIEW code>>=
proc StartTrace {appid} {
    set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
    relation assign $self

    rosea trace control on
    rosea trace control logon
    rosea trace control loglevel info
    interp alias {} log_$AppId {} ::rash::TRCVIEW::FormatTrace $AppId
    [logger::servicecmd rosea]::logproc info log_$AppId

    $Hull.ctrls.start configure\
        -text Stop\
        -command [namespace code [list StopTrace $AppId]]
}
----

[source,tcl]
----
<<TRCVIEW code>>=
proc StopTrace {appid} {
    set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
    relation assign $self

    rosea trace control off
    rosea trace control logoff
    interp alias {} log_$AppId {}

    $Hull.ctrls.start configure\
        -text Start\
        -command [namespace code [list StartTrace $AppId]]
}
----

[source,tcl]
----
<<TRCVIEW code>>=
proc FreezeTrace {appid} {
    set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
    relation assign $self

    relvar updateone ::rash::TRCVIEW trtup [list AppId $AppId] {
        tuple update $trtup IsFrozen true
    }
    $Hull.ctrls.frz configure\
        -text Scroll\
        -command [namespace code [list UnfreezeTrace $AppId]]
}
----

[source,tcl]
----
<<TRCVIEW code>>=
proc UnfreezeTrace {appid} {
    set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
    relation assign $self

    relvar updateone ::rash::TRCVIEW trtup [list AppId $AppId] {
        tuple update $trtup IsFrozen false
    }
    $Hull.ctrls.frz configure\
        -text Freeze\
        -command [namespace code [list FreezeTrace $AppId]]
}
----

[source,tcl]
----
<<TRCVIEW code>>=
proc ClearTrace {appid} {
    set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
    relation assign $self Hull

    rosea trace control clear
    $Hull.traces.text delete 1.0 end
}
----

[source,tcl]
----
<<TRCVIEW code>>=
proc SaveTrace {appid} {
    set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
    relation assign $self Hull SaveDir

    set app [relvar restrictone ::rash::APP AppId $appid]

    set savefile [tk_getSaveFile\
        -confirmoverwrite true\
        -parent [relation extract $app Hull]\
        -initialdir $SaveDir\
        -title "Select Trace Save File"\
        -defaultextension .sqlite\
        -initialfile [clock format [clock seconds]\
                -format "Trace-%Y-%m-%dT%H-%M-%S.sqlite"]\
        -filetypes {
            {{SQLite Files}     .sqlite}
            {{Text Files}       .txt}
            {{All Files}        *}
        }\
    ]
    if {$savefile ne {}} {
        relvar updateone ::rash::TRCVIEW tv [list AppId $appid] {
            tuple update $tv SaveDir [file dirname $savefile]
        }
        if {[file extension $savefile] eq ".sqlite"} {
            ::rosea trace control save $savefile
        } else {
            set outchan [open $savefile w]
            try {
                chan puts -nonewline $outchan [$Hull.traces.text get 1.0 end]
            } finally {
                close $outchan
            }
        }
    }
}
----

==== Class Implementation

[source,tcl]
----
<<TRCVIEW class>>=
<<TRCVIEW data>>
namespace eval TRCVIEW {
<<class namespace path>>
    <<TRCVIEW code>>
    <<TRCVIEW exports>>
    namespace ensemble create
}
----

=== R8 -- TRCVIEW => APP

[source,tcl]
----
<<R8>>=
relvar association R8\
    TRCVIEW AppId 1\
    APP AppId 1
----

=== Domain Class Class

[source,tcl]
----
<<DOMCLASS data>>=
relvar create DOMCLASS {
    AppId string
    Domain string
    Class string
    Hull string
} {AppId Domain Class} Hull
----

==== Create Operation

[source,tcl]
----
<<DOMCLASS code>>=
proc create {appid domain class hull} {
    set self [relvar insert ::rash::DOMCLASS [list\
        AppId $appid\
        Domain $domain\
        Class $class\
        Hull $hull\
    ]]
    relation assign $self

    set classinst [ral relvar restrictone ::rosea::Config::Class\
        Domain $Domain Name $Class]

    ttk::frame $Hull
    grid $Hull -sticky nsew
    grid rowconfigure $Hull {0 1} -weight 1
    grid columnconfigure $Hull 0 -weight 1

    DVAL create $AppId $Domain $Class $Hull.data

    set events [pipe {
        ral relvar set ::rosea::Config::Event |
        relation semijoin $classinst ~\
            -using {Domain Domain Name Model}
    }]

    if {[relation isnotempty $events]} {
        ttk::labelframe $Hull.sm\
            -takefocus 0\
            -text "Current State"
        grid $Hull.sm -sticky nsew
        grid rowconfigure $Hull.sm 0 -weight 1
        grid columnconfigure $Hull.sm 0 -weight 1

        SM create $AppId $Domain $Class $Hull.sm.cs

        set evtframe [ttk::labelframe $Hull.sm.evts\
            -takefocus 0\
            -text Events]
        grid $evtframe -sticky nsew

        set evtnum -1
        relation foreach event $events -ascending Event {
            relation assign $event Event
            set evtHull $evtframe.evt_[incr evtnum]
            CEVT create $AppId $Domain $Class $Event $evtHull
            grid $evtHull -pady 2 -sticky w
        }
    }

    return $self
}
<<DOMCLASS exports>>=
namespace export create
----

==== Class Implementation

[source,tcl]
----
<<DOMCLASS class>>=
<<DOMCLASS data>>
namespace eval DOMCLASS {
<<class namespace path>>
    <<DOMCLASS code>>
    <<DOMCLASS exports>>
    namespace ensemble create
}
----

=== R4 -- DOMCLASS => DOMSTAT

[source,tcl]
----
<<R4>>=
relvar association R4\
    DOMCLASS {AppId Domain} +\
    DOMSTAT {AppId Domain} 1
----

=== Data Value Class

[source,tcl]
----
<<DVAL data>>=
relvar create DVAL {
    AppId string
    Domain string
    Class string
    Instances dict
    Hull string
    CreateHull string
} {AppId Domain Class} Hull
----

==== Create Method

[source,tcl]
----
<<required packages>>=
package require tablelist_tile
package require struct::set
----

[source,tcl]
----
<<DVAL code>>=
proc create {appid domain class hull} {
    set crhull .create_[string tolower $class]
    set self [relvar insert ::rash::DVAL [list\
        AppId $appid\
        Domain $domain\
        Class $class\
        Instances [dict create]\
        Hull $hull\
        CreateHull $crhull\
    ]]
    relation assign $self
    set ref [ToRef ::rash::DVAL $self]

    ttk::labelframe $Hull\
        -takefocus 0\
        -text "Class Data"
    grid $Hull -sticky nsew
    grid rowconfigure $Hull 0 -weight 1
    grid columnconfigure $Hull 0 -weight 1

    set classrelvar [FullyQualifyDomain $Domain]::$Class
    set insts [relvar set $classrelvar]
    set attrs [relation attributes $insts]
    set idattrs [list]
    foreach id [relvar identifiers $classrelvar] {
        ::struct::set add idattrs $id
    }

    set tv [tablelist::tablelist $Hull.inst\
        -columntitles $attrs\
        -showseparators true\
        -showarrow false\
        -stripebackground lightgreen\
        -setgrid true\
        -stretch all\
        -height 4\
        -xscrollcommand [list $Hull.xs set]\
        -yscrollcommand [list $Hull.ys set]\
        -editendcommand [namespace code [list EditDone $ref]]\
    ]
    set attrnum 0
    foreach attr $attrs {
        set opts [list -name col_$attr]
        if {$attr ni $idattrs} {
            lappend opts\
                -editable true\
                -editwindow ttk::entry
        }
        $tv columnconfigure $attrnum {*}$opts
        incr attrnum
    }

    ttk::scrollbar $Hull.xs\
        -orient horizontal\
        -command [list $Hull.inst xview]
    ttk::scrollbar $Hull.ys\
        -orient vertical\
        -command [list $Hull.inst yview]

    grid $tv $Hull.ys -sticky nsew
    grid $Hull.xs - -sticky nsew
    ::autoscroll::autoscroll $Hull.xs
    ::autoscroll::autoscroll $Hull.ys

    set tlmenu [menu $Hull.tlmenu]
    $tlmenu add command\
        -label "Create"\
        -command [namespace code [list CreateDialog $ref]]
    $tlmenu add command\
        -label "Delete"\
        -command [namespace code [list DeleteInst $ref]]
    bind [$tv bodytag] <ButtonPress-3> [list tk_popup $tlmenu %X %Y]

    toplevel $crhull
    if {[winfo viewable .]} {
        wm transient $crhull .
    }
    wm withdraw $crhull

    wm title $crhull "Create Instance of $Class"
    wm protocol $crhull WM_DELETE_WINDOW\
        [namespace code [list CancelCreate $ref]]

    foreach {attr type} [relation heading $insts] {
        set awin [string tolower $attr]
        set lab [ttk::label $crhull.lab_$awin\
            -text "$attr \[$type\]"\
            -takefocus 0\
        ]
        set ent [ttk::entry $crhull.ent_$awin]

        bind $ent <Return> {focus [tk_focusNext %W]}
        bind $ent <KP_Enter> {focus [tk_focusNext %W]}

        grid $lab $ent\
            -padx 2
        grid configure $lab\
            -sticky e
        grid configure $ent\
            -sticky w
    }

    focus $crhull.ent_[string tolower [lindex $attrs 0]]

    ttk::button $crhull.create\
        -text Create\
        -command [namespace code [list CreateInst $ref]]
    bind $crhull.create <Return> {%W invoke}
    bind $crhull.create <KP_Enter> {%W invoke}

    ttk::button $crhull.cancel\
        -text Cancel\
        -takefocus 0\
        -command [namespace code [list CancelCreate $ref]]

    grid $crhull.create $crhull.cancel

    relvar trace add variable $classrelvar\
        {delete insert set unset update}\
        [namespace code [list ModTrace $ref]]

    Refresh $ref $classrelvar

    return $self
}
<<DVAL exports>>=
namespace export create
----

[source,tcl]
----
<<DVAL code>>=
proc ModTrace {self op relvar args} {
    after 0 [namespace code [list Refresh $self $relvar]]

    switch -exact -- $op {
        insert -
        set {
            return [lindex $args 0]
        }
        update {
            return [lindex $args 1]
        }
    }
}
----

[source,tcl]
----
<<DVAL code>>=
proc Refresh {self relvar} {
    assignAttribute $self

    set tv $Hull.inst
    $tv selection clear 0 end
    $tv delete 0 end

    set insts [relvar set $relvar]
    set attrs [relation attributes $insts]
    set instmap [dict create]

    set row -1
    relation foreach inst $insts {
        $tv insert end [relation extract $inst {*}$attrs]
        dict set instmap [incr row] [ToRef $relvar $inst]
    }
    $tv selection set 0 0
    updateAttribute $self Instances $instmap
}
----

[source,tcl]
----
<<DVAL code>>=
proc SelectedInst {self} {
    assignAttribute $self AppId Hull Instances

    set activecell [$Hull.inst cellindex active]
    lassign [split $activecell ,] selected selectedcolumn
    if {$selected eq {}} {
        set app [::rosea::ClassCmds::findById ::rash::APP AppId $AppId]
        APP ShowUserMessage $app info "No Instance Selected"\
            "Select instance from table where event is signaled"
        return [nilInstRef]
    } else {
        return [dict get $Instances $selected]
    }
}
<<DVAL exports>>=
namespace export SelectedInst
----

[source,tcl]
----
<<DVAL code>>=
proc CreateDialog {self} {
    assignAttribute $self CreateHull
    wm deiconify $CreateHull
    tkwait visibility $CreateHull
    focus [tk_focusNext $CreateHull]
    grab set $CreateHull
}
----

[source,tcl]
----
<<DVAL code>>=
proc CreateInst {self} {
    assignAttribute $self Domain Class CreateHull

    set classrelvar [FullyQualifyDomain $Domain]::$Class
    set insts [relvar set $classrelvar]
    set attrs [relation attributes $insts]
    set values [list]
    foreach attr $attrs {
        set ent $CreateHull.ent_[string tolower $attr]
        lappend values $attr [$ent get]
    }

    try {
        ::rosea::ClassCmds::create $classrelvar {*}$values
    } on error {result} {
        set line [lindex [split [string trimright $result \n]] 0]
        # HERE -- not working
        if {[regexp {^for[^:]+([^(]+)\(.*\), in relvar (.+)$} $line\
                match rnum refclass]} {
            set msg "Referential constraint, $rnum, on class $refclass\
                failed"
        } else {
            set msg $result
        }

        tk_messageBox\
            -icon error\
            -title "Error Creating Instance"\
            -parent [relation extract $self Hull]\
            -type ok\
            -message "Instance creation failed:\n$msg"
    }

    grab release $CreateHull
    wm withdraw $CreateHull
}
----

[source,tcl]
----
<<DVAL code>>=
proc CancelCreate {self} {
    assignAttribute $self CreateHull
    grab release $CreateHull
    wm withdraw $CreateHull
}
----

[source,tcl]
----
<<DVAL code>>=
proc DeleteInst {self} {
    set selected [SelectedInst $self]
    if {[::rosea::InstCmds::isNotEmptyRef $selected]} {
        try {
            ::rosea::InstCmds::delete $selected
        } on error {result} {
            tk_messageBox\
                -icon error\
                -title "Error Deleting Instance"\
                -parent [relation extract $self Hull]\
                -type ok\
                -message "Instance deletion failed:\n$result"
        }
    }
}
----

[source,tcl]
----
<<DVAL code>>=
proc EditDone {self path row col value} {
    assignAttribute $self

    set inst [dict get $Instances $row]
    set relvar [lindex $inst 0]
    set attrs [relation attributes [relvar set $relvar]]
    set id [tuple get [relation tuple [lindex $inst 1]]]
    try {
        relvar updateone $relvar rvtup $id {
            tuple update $rvtup [lindex $attrs $col] $value
        }
        return $value
    } on error {result opts} {
        $path rejectinput
        return -options $opts $result
    }
}
----

==== Class Implementation

[source,tcl]
----
<<DVAL class>>=
<<DVAL data>>
namespace eval DVAL {
<<class namespace path>>
    <<DVAL code>>
    <<DVAL exports>>
    namespace ensemble create
}
----

=== R5 -- DVAL => DOMCLASS

[source,tcl]
----
<<R5>>=
relvar association R5\
    DVAL {AppId Domain Class} 1\
    DOMCLASS {AppId Domain Class} 1
----

=== Class Event Class

[source,tcl]
----
<<CEVT data>>=
relvar create CEVT {
    AppId string
    Domain string
    Class string
    Event string
    Hull string
} {AppId Domain Class Event} Hull
----

==== Create Method

[source,tcl]
----
<<CEVT code>>=
proc create {appid domain class event hull} {
    set self [relvar insert ::rash::CEVT [list\
        AppId $appid\
        Domain $domain\
        Class $class\
        Event $event\
        Hull $hull\
    ]]
    relation assign $self
    set ref [ToRef ::rash::CEVT $self]

    ttk::frame $Hull
    set evtb [ttk::button $Hull.__button\
        -text $Event\
        -command [namespace code [list sendEvent $ref]]\
    ]
    grid $evtb\
        -sticky w\
        -row 0\
        -column 0

    set params [pipe {
        ral relvar restrictone ::rosea::Config::EffectiveEvent\
                Domain $Domain Model $Class Event $Event |
        relation semijoin ~ $::rosea::Config::StateTransition |
        relation eliminate ~ State Event |
        relation rename ~ NewState Name |
        relation semijoin ~ $::rosea::Config::State |
        relation list ~ Parameters |
        lindex ~ 0
    }]

    set counter -1
    foreach param $params {
        set pname [lindex $param 0]
        set phull $Hull.[string tolower $pname]
        EVTPARAM create $AppId $Domain $Class\
            $Event $pname [incr counter] $phull

        grid $phull\
            -row 0\
            -column [expr {$counter + 1}]
    }

}
<<CEVT exports>>=
namespace export create
----

[source,tcl]
----
<<CEVT code>>=
proc sendEvent {self} {
    lassign $self relvar inst

    set classinst [pipe {
        relation semijoin $inst $::rash::DOMCLASS\
                -using {AppId AppId Domain Domain Class Class}\
            $::rash::DVAL\
                -using {AppId AppId Domain Domain Class Class} |
            ToRef ::rash::DVAL ~ |
            DVAL SelectedInst ~
    }]

    if {[isNotEmptyRef $classinst]} {
        # Gather up the parameters
        set evtparams [relation semijoin $inst $::rash::EVTPARAM\
            -using {AppId AppId Domain Domain Class Class Event Event}
        ]
        set values [list]
        relation foreach paramvalue $evtparams -ascending Order {
            lappend values [EVTPARAM ReadValue $paramvalue]
        }

        ::rosea tunnel $classinst signal [relation extract $inst Event]\
                {*}$values
    }
}
----

==== Class Implementation

[source,tcl]
----
<<CEVT class>>=
<<CEVT data>>
namespace eval CEVT {
<<class namespace path>>
    <<CEVT code>>
    <<CEVT exports>>
    namespace ensemble create
}
----

=== R6 -- CEVT => DOMCLASS

[source,tcl]
----
<<R6>>=
relvar association R6\
    CEVT {AppId Domain Class} *\
    DOMCLASS {AppId Domain Class} 1
----

=== Event Parameter Class

[source,tcl]
----
<<EVTPARAM data>>=
relvar create EVTPARAM {
    AppId string
    Domain string
    Class string
    Event string
    Param string
    Order int
    Hull string
} {AppId Domain Class Event Param} {AppId Domain Class Event Order} Hull
----

==== Create Method

[source,tcl]
----
<<EVTPARAM code>>=
proc create {appid domain class event param order hull} {
    set self [relvar insert ::rash::EVTPARAM [list\
        AppId $appid\
        Domain $domain\
        Class $class\
        Event $event\
        Param $param\
        Order $order\
        Hull $hull\
    ]]
    relation assign $self

    ttk::frame $Hull
    ttk::label $Hull.label -text $Param
    ttk::entry $Hull.entry

    grid $Hull.label $Hull.entry\
        -padx 2
    grid configure $Hull.label\
        -sticky e
    grid configure $Hull.entry\
        -sticky w
}
<<EVTPARAM exports>>=
namespace export create
----

==== Read Value Method

[source,tcl]
----
<<EVTPARAM code>>=
proc ReadValue {self} {
    relation assign $self Hull
    return [$Hull.entry get]
}
<<EVTPARAM exports>>=
namespace export ReadValue
----

==== Class Implementation

[source,tcl]
----
<<EVTPARAM class>>=
<<EVTPARAM data>>
namespace eval EVTPARAM {
<<class namespace path>>
    <<EVTPARAM code>>
    <<EVTPARAM exports>>
    namespace ensemble create
}
----

=== R7 -- EVTPARAM => CEVT

[source,tcl]
----
<<R7>>=
relvar association R7\
    EVTPARAM {AppId Domain Class Event} *\
    CEVT {AppId Domain Class Event} 1
----

=== State Model Class

[source,tcl]
----
<<SM data>>=
relvar create SM {
    AppId string
    Domain string
    Class string
    Hull string
} {AppId Domain Class} Hull
----

==== Create Method

[source,tcl]
----
<<SM code>>=
proc create {appid domain class hull} {
    set self [relvar insert ::rash::SM [list\
        AppId $appid\
        Domain $domain\
        Class $class\
        Hull $hull
    ]]
    relation assign $self

    set smrelvar [FullyQualifyDomain $Domain]::__${Class}__STATEINST
    set insts [relvar set $smrelvar]
    set attrs [relation attributes $insts]

    ttk::frame $Hull
    grid $Hull -sticky nsew
    grid rowconfigure $Hull 0 -weight 1
    grid columnconfigure $Hull 0 -weight 1

    set tv [ttk::treeview $Hull.inst\
        -columns $attrs\
        -displaycolumns $attrs\
        -selectmode none\
        -show headings\
        -height 4\
        -xscrollcommand [list $Hull.xs set]\
        -yscrollcommand [list $Hull.ys set]\
    ]

    ttk::scrollbar $Hull.xs\
        -orient horizontal\
        -command [list $Hull.inst xview]
    ttk::scrollbar $Hull.ys\
        -orient vertical\
        -command [list $Hull.inst yview]

    grid $tv $Hull.ys -sticky nsew
    grid $Hull.xs - -sticky nsew
    ::autoscroll::autoscroll $Hull.xs
    ::autoscroll::autoscroll $Hull.ys

    foreach attr $attrs {
        $tv column $attr\
            -anchor w\
            -width [expr\
                {[font measure TkDefaultFont $attr] + 20}]\
            -stretch true
        $tv heading $attr\
            -text $attr\
            -anchor w
    }

    relvar trace add variable $smrelvar\
        {delete insert set unset update}\
        [namespace code [list modtrace $self]]

    refresh $self $smrelvar

    return $self
}
<<SM exports>>=
namespace export create
----

==== Modtrace Method

[source,tcl]
----
<<SM code>>=
proc modtrace {self op relvar args} {
    after 0 [namespace code [list refresh $self $relvar]]

    switch -exact -- $op {
        insert -
        set {
            return [lindex $args 0]
        }
        update {
            return [lindex $args 1]
        }
    }
}
----

==== Refresh Method

[source,tcl]
----
<<SM code>>=
proc refresh {self relvar} {
    relation assign $self
    set tv $Hull.inst
    $tv delete [$tv children {}]

    set insts [relvar set $relvar]
    set attrs [relation attributes $insts]
    relation foreach inst $insts {
        $tv insert {} end -values [relation extract $inst {*}$attrs]
    }
}
----

==== Class Implementation

[source,tcl]
----
<<SM class>>=
<<SM data>>
namespace eval SM {
<<class namespace path>>
    <<SM code>>
    <<SM exports>>
    namespace ensemble create
}
----

=== R9 -- SM => DOMCLASS

[source,tcl]
----
<<R9>>=
relvar association R9\
    SM {AppId Domain Class} ?\
    DOMCLASS {AppId Domain Class} 1
----

== Code Organization

In this section we show the organization of the files that can be
tangled from the literate source.

First, this software is copyrighted.
It is licensed in the same manner as Tcl itself.

[source,tcl]
----
<<copyright info>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----

Each _root chunk_ is described in a section below.

=== Source Code

[source,tcl]
----
<<rash.tcl>>=
<<copyright info>>

package require Tcl 8.6
package require Tk 8.6

option add *tearOff false

package require logger
<<required packages>>

namespace eval ::rash {
    namespace import ::ral::*
    namespace import ::ralutil::*

    variable version 1.0a1

    <<rash classes>>
    <<rash relationships>>
    <<rash code>>

    namespace export init
    proc init {{appid Rash}} {
        APP create $appid .[string tolower $appid]
    }
    namespace ensemble create
}

package provide rash $::rash::version
----

=== Package Index

We also provide a root chunk to extract a package index file.

[source,tcl]
----
<<pkgIndex.tcl>>=
package ifneeded rash 1.0a1 [list source [file join $dir rash.tcl]]
----

=== User's Manual

[source,tcl]
----
<<rash.man>>=
[manpage_begin rash n 1.0a1]
[comment {
<<copyright info>>
}]
[moddesc "Rosea Interactive Introspection"]
[titledesc "Rash"]
[copyright "2015 by G. Andrew Mangogna"]
[require rash [opt 1.0a1]]
[description]
Rash
[manpage_end]
----

=== Unit Tests

[source,tcl]
----
<<rash.test>>=
<<copyright info>>

package require cmdline
package require logger

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

logger::setlevel $options(level)

source ../src/rash.tcl
chan puts "testing rash version: [package require rash]"

package require tcltest
eval tcltest::configure $argv

namespace eval ::rash::test {
    namespace import ::tcltest::*
    ::logger::initNamespace [namespace current]

    wm withdraw .

    source ./wmctrl.tcl
    source ./wmctrl-stubs.tcl

    rash init

    tkwait window .rash

    cleanupTests
}
----

////
----
test X-1.0 {
} -setup {
} -cleanup {
} -body {
} -result {}
----
////

[appendix]
== Literate Programming [[literate-programming,Literate Programming]]

The source for this document conforms to
http://www.methods.co.nz/asciidoc/[asciidoc] syntax.
This document is also a
http://www.literateprogramming.com/[literate program].
The source code for the implementation is included directly in the document
source and the build process extracts the source that is then given to the Tcl
interpreter.
This process is known as __tangle__ing.
The program,
http://repos.modelrealization.com/cgi-bin/fossil/mrtools/[+atangle+],
is available to extract source code from the document source
and the +asciidoc+ tool chain can be used to produce a variety
of different output formats, although PDF is the intended choice.

The goal of a literate program is to explain the logic of the
program in an order and fashion that facilitates human understanding of the
program and then _tangle_ the document source to obtain
the Tcl code in an order suitable for the Tcl interpreter.
Briefly,
code is extracted from the literate source by
defining a series of _chunks_ that contain the source.
A chunk is _defined_ by including its name as:

........................
<<chunk name>>=
........................

The trailing +=+ sign denotes a definition.
A chunk definition ends at the end of the source block
or at the beginning of another chunk definition.
A chunk may be _referenced_ from within a chunk definition by
using its name without the trailing +=+ sign, as in:

........................
<<chunk definition>>=
    <<chunk reference>>
........................

Chunk names are arbitrary strings.
Multiple definitions with the same name are simply concatenated in the order
they are encountered.
There are one or more _root chunks_ which form the conceptual tree
for the source files that are contained in the literate source.
By convention, root chunks are named the same as the file name to
which they will be tangled.
Tangling is then the operation of starting at a root chunk and
recursively substituting the definition for the chunk references that
are encountered.

For readers that are not familiar with the literate style and
who are adept at reading source code directly,
the chunks definitions and reordering
provided by the tangle operation can be a bit disconcerting at first.
You can, of course, examine the tangled source output,
but if you read the program as a document,
you will have to trust that the
author managed to arrange the chunk definitions and references in
a manner so that the tangled output is acceptable to the Tcl interpreter.

[index]
.Index
