# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2015 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require Tk 8.6

option add *tearOff false

package require logger
package require rosea
package require autoscroll
package require tablelist_tile
package require struct::set

namespace eval ::rash {
    namespace import ::ral::*
    namespace import ::ralutil::*

    variable version 1.0a3

    relvar create APP {
        AppId string
        Hull string
        Version string
    } AppId Hull
    namespace eval APP {
        namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid hull {version 1.0a3}} {
            relvar eval {
                set self [relvar insert ::rash::APP [list\
                    AppId       $appid\
                    Hull        $hull\
                    Version     $version\
                ]]
                relation assign $self ; # <1>
                toplevel $Hull
                wm title $Hull "Rash Version $Version"
                wm protocol $Hull WM_DELETE_WINDOW ::exit
                
                grid rowconfigure $Hull 1 -weight 1 ; # <1>
                grid columnconfigure $Hull 0 -weight 1
                set mbarHull $Hull.mbar
                MBAR create $AppId $mbarHull
                $Hull configure -menu $mbarHull
                set dselHull $Hull.dsel
                DSEL create $AppId $dselHull
                grid $dselHull -sticky nsew -pady 4
                set trcHull $Hull.tview
                TRCVIEW create $AppId $trcHull
                grid $trcHull -sticky nsew -pady 4
            }
        
            return $self
        }
        proc ShowUserMessage {self type title msg} {
            tk_messageBox\
                -icon $type\
                -title $title\
                -parent [readAttribute $self Hull]\
                -type ok\
                -message $msg
        }
        namespace export create
        namespace export ShowUserMessage
        namespace ensemble create
    }
    relvar create MBAR {
        AppId string
        Hull string
    } AppId Hull
    namespace eval MBAR {
        namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid hull {debuglevel warn}} {
            set self [relvar insert ::rash::MBAR [list\
                AppId           $appid\
                Hull            $hull\
            ]]
            relation assign $self
            variable DebugLevel
            set DebugLevel($AppId) $debuglevel
            menu $Hull
            $Hull add cascade\
                -label File\
                -menu $Hull.file
            
            menu $Hull.file
            $Hull.file add command\
                -label Exit\
                -command ::exit
            $Hull add cascade\
                -label Show\
                -menu $Hull.show
            menu $Hull.show
            if {$::tcl_platform(platform) eq "windows"} {
                $Hull.show add command\
                    -label Console\
                    -command [namespace code [list ShowConsole $AppId]]
            }
            $Hull.show add cascade\
                -label Debug\
                -menu $Hull.debug
            
            set levelvar [namespace current]::DebugLevel($AppId)
            set cmd [namespace code [list LogLevel $AppId]]
            menu $Hull.debug
            foreach level [::logger::levels] {
                $Hull.debug add radiobutton\
                    -label $level\
                    -variable $levelvar\
                    -command $cmd
            }
            $Hull.show add command\
                -label About\
                -command [namespace code [list ShowAbout $AppId]]
        
            return $self
        }
        proc ShowConsole {appid} {
            catch {
                ::console show
                ::console title "Rash Console"
            }
        }
        proc ShowAbout {appid} {
            set app [pipe {
                relvar restrictone ::rash::APP AppId $appid |
                ToRef ::rash::APP ~
            }]
            APP ShowUserMessage $app info Rash\
                "$appid\n\
                Copyright 2015, G. Andrew Mangogna\n\
                Revision: [readAttribute $app Version]"
        
            return
        }
        proc LogLevel {appid} {
            variable DebugLevel
            ::logger::setlevel $DebugLevel($appid)
            return
        }
        namespace export create
        namespace ensemble create
    }
    relvar create DSEL {
        AppId string
        Hull string
    } AppId Hull
    namespace eval DSEL {
        namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid hull} {
            set self [relvar insert ::rash::DSEL [list\
                AppId           $appid\
                Hull            $hull\
            ]]
            relation assign $self
            set domlist [relation list $::rosea::Config::Domain Name]
            variable DomainSelect
            set DomainSelect($AppId) [lindex $domlist 0]
            ttk::labelframe $Hull\
                -takefocus 0\
                -text "Domain Selection"
            grid rowconfigure $Hull 0 -weight 1
            grid columnconfigure $Hull 0 -weight 1
            ttk::combobox $Hull.doms\
                -values $domlist\
                -textvariable [namespace current]::DomainSelect($AppId)
            grid $Hull.doms\
                -padx 4\
                -sticky w
            ::bind $Hull.doms <<ComboboxSelected>>\
                [namespace code [list DomainSelect $AppId]]
            ::bind $Hull.doms <Return>\
                [namespace code [list DomainSelect $AppId]]
            ::bind $Hull.doms <KP_Enter>\
                [namespace code [list DomainSelect $AppId]]
        
            return $self
        }
        proc DomainSelect {appid} {
            set self [relvar restrictone ::rash::DSEL AppId $appid] ; # <1>
            relation assign $self
            variable DomainSelect
            if {$DomainSelect($AppId) ne {}} { # <2>
                set dstat [pipe {
                    relvar set ::rash::DOMSTAT |
                    relation semijoin $self ~ -using {AppId AppId} |
                    relation restrict ~ dstup {
                        [tuple extract $dstup Domain] eq $DomainSelect($AppId)}
                }]
        
                if {[relation isempty $dstat]} { # <3>
                    relvar eval {
                        DOMSTAT create $AppId $DomainSelect($AppId)\
                            $Hull.[string tolower $DomainSelect($AppId)]
                    }
                } else {
                    wm deiconify [relation extract $dstat Hull]
                }
            }
        }
        namespace export create
        namespace ensemble create
    }
    relvar create DOMSTAT {
        AppId string
        Domain string
        Hull string
    } {AppId Domain} Hull
    namespace eval DOMSTAT {
        namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid domain hull} {
            set dominst [ral relvar restrictone ::rosea::Config::Domain Name $domain]
            if {[relation isempty $dominst]} {
                set app [pipe {
                    relvar restrictone ::rash::APP AppId $appid |
                    ToRef ::rash::APP ~
                }] ; # <1>
                APP ShowUserMessage $app error "Domain Error" "Unknown Domain, \"$domain\""
                return
            }
            set self [relvar insert ::rash::DOMSTAT [list\
                AppId $appid\
                Domain $domain\
                Hull $hull
            ]]
            relation assign $self
            set ref [ToRef ::rash::DOMSTAT $self] ; # <1>
            toplevel $Hull
            wm title $Hull "Domain: $domain"
            wm protocol $Hull WM_DELETE_WINDOW [list wm withdraw $Hull]
            grid rowconfigure $Hull 0 -weight 1
            grid columnconfigure $Hull 0 -weight 1
            set frame [ttk::labelframe $hull.clf -text Classes]
            grid $frame -sticky nsew
            grid rowconfigure $frame 0 -weight 1
            grid columnconfigure $frame 0 -weight 1
            
            set nb [ttk::notebook $frame.nb -takefocus 0]
            grid $nb -sticky nsew
            grid rowconfigure $nb 0 -weight 1
            grid columnconfigure $nb 0 -weight 1
            set classes [pipe {
                ral relvar set ::rosea::Config::Class |
                relation restrict ~ classtup {
                    [tuple extract $classtup Domain] eq $Domain
                }
            }]
            relation foreach class $classes -ascending Name {
                relation assign $class {Name className}
                set cframe $nb.[string tolower $className]
                DOMCLASS create $AppId $Domain $className $cframe
            
                $nb add $cframe -text $className -sticky nsew
            }
            set ops [pipe {
                ral relvar set ::rosea::Config::DomainOperation |
                relation restrict ~ optup {
                    [tuple extract $optup Domain] eq $Domain
                }
            }]
            if {[relation isnotempty $ops]} {
                set frame [ttk::labelframe $hull.opf -text Operations]
                grid $frame -sticky nsew
                
                set opnum 0 ; # <1>
                relation foreach op $ops -ascending Name {
                    relation assign $op {Name name} {Parameters params}
                
                    set but [ttk::button $frame.op$opnum\
                        -text $name\
                        -takefocus 1\
                        -command [namespace code\
                            [list InvokeDomOp $ref $name $opnum [llength $params]]]\
                    ]
                    grid $but -pady 4 -row $opnum -column 0 -sticky e
                    bind $but <Return> {%W invoke}
                    bind $but <KP_Enter> {%W invoke}
                    set prnum 0 ; # <1>
                    foreach param $params {
                        lassign $param pname pdefault
                        set lab [ttk::label $frame.lab$opnum$prnum -text $pname]
                        set ent [ttk::entry $frame.ent$opnum$prnum]
                        $ent insert 0 $pdefault
                        bind $ent <Return> {focus [tk_focusNext %W]}
                        bind $ent <KP_Enter> {focus [tk_focusNext %W]}
                        grid $lab\
                            -padx 2\
                            -row $opnum\
                            -column [expr {$prnum * 2 + 1}]\
                            -sticky e ; # <1>
                        grid $ent\
                            -padx 2\
                            -row $opnum\
                            -column [expr {$prnum * 2 + 2}]\
                            -sticky w
                        
                        incr prnum
                    }
                    
                    if {$prnum > 0} {
                        bind $ent <Return> [list focus $but]
                        bind $ent <KP_Enter> [list focus $but]
                    } ; # <2>
                    incr opnum
                }
            }
        
            return $self
        }
        proc InvokeDomOp {self opname opnum pnum} {
            assignAttribute $self Domain Hull
        
            set params [list]
            for {set i 0} {$i < $pnum} {incr i} {
                lappend params [$Hull.opf.ent$opnum$i get] ; # <1>
            }
            set domcmd [FullyQualifyDomain $Domain]
        
            $domcmd $opname {*}$params
        
            set nextwin [tk_focusNext $Hull.opf.op$opnum] ; # <2>
            focus $nextwin
            after idle [list $nextwin selection range 0 end] ; # <3>
        }
        namespace export create
        namespace ensemble create
    }
    relvar create TRCVIEW {
        AppId string
        Hull string
        IsFrozen boolean
        SaveDir string
    } AppId Hull
    namespace eval TRCVIEW {
    namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid hull} {
            set self [relvar insert ::rash::TRCVIEW [list\
                AppId $appid\
                Hull $hull\
                IsFrozen false\
                SaveDir [pwd]\
            ]]
            relation assign $self
            ttk::frame $Hull
            grid rowconfigure $Hull 0 -weight 1
            grid columnconfigure $Hull 0 -weight 1
            ttk::labelframe $Hull.traces\
                -text "State Machine Traces"
            grid $Hull.traces\
                -sticky nsew
            grid rowconfigure $Hull.traces 0 -weight 1
            grid columnconfigure $Hull.traces 0 -weight 1
            text $Hull.traces.text\
                -wrap word\
                -setgrid true\
                -width 100\
                -insertwidth 0\
                -yscrollcommand [list $Hull.traces.vsb set]
            
            ttk::scrollbar $Hull.traces.vsb\
                -orient vertical\
                -command [list $Hull.traces.text yview]
            ::autoscroll::autoscroll $Hull.traces.vsb
            
            grid $Hull.traces.text $Hull.traces.vsb -sticky nsew
            $Hull.traces.text tag configure CHtrace\
                -background red\
                -foreground black
            $Hull.traces.text tag configure IGtrace\
                -background yellow\
                -foreground black
            $Hull.traces.text tag configure TSfield\
                -background gray90
            ttk::labelframe $Hull.ctrls\
                -text "Trace Controls"
            grid $Hull.ctrls\
                -sticky nsew\
                -pady 4
            ttk::button $Hull.ctrls.start\
                -text Start\
                -command [namespace code [list StartTrace $AppId]]
            ttk::button $Hull.ctrls.frz\
                -text Freeze\
                -command [namespace code [list FreezeTrace $AppId]]
            ttk::button $Hull.ctrls.clr\
                -text Clear\
                -command [namespace code [list ClearTrace $AppId]]
            ttk::button $Hull.ctrls.save\
                -text Save\
                -command [namespace code [list SaveTrace $AppId]]
            grid $Hull.ctrls.start $Hull.ctrls.frz $Hull.ctrls.clr $Hull.ctrls.save\
                -padx 4\
                -pady 4
        
            return $self
        }
        proc FormatTrace {appid txt {tag {}}} {
            set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
            relation assign $self Hull IsFrozen
        
            switch -glob -- $txt {
                {*-> CH*} {
                    set tag CHtrace
                }
                {*-> IG*} {
                    set tag IGtrace
                }
            }
        
            $Hull.traces.text insert end\
                [::rosea::Trace::FormatTimestamp [clock microseconds]] TSfield\
                { } {}\
                $txt\n $tag
        
            if {!$IsFrozen} {
                $Hull.traces.text see end
            }
        }
        proc StartTrace {appid} {
            set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
            relation assign $self
        
            rosea trace control on
            rosea trace control logon
            rosea trace control loglevel info
            interp alias {} log_$AppId {} ::rash::TRCVIEW::FormatTrace $AppId ; # <1>
            [logger::servicecmd rosea]::logproc info log_$AppId
        
            $Hull.ctrls.start configure\
                -text Stop\
                -command [namespace code [list StopTrace $AppId]] ; # <2>
        }
        proc StopTrace {appid} {
            set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
            relation assign $self
        
            rosea trace control off
            rosea trace control logoff
            interp alias {} log_$AppId {}
        
            $Hull.ctrls.start configure\
                -text Start\
                -command [namespace code [list StartTrace $AppId]]
        }
        proc FreezeTrace {appid} {
            set self [relvar updateone ::rash::TRCVIEW trtup [list AppId $appid] {
                tuple update $trtup IsFrozen true
            }]
            relation assign $self Hull
        
            $Hull.ctrls.frz configure\
                -text Scroll\
                -command [namespace code [list UnfreezeTrace $appid]]
        }
        proc UnfreezeTrace {appid} {
            set self [relvar updateone ::rash::TRCVIEW trtup [list AppId $appid] {
                tuple update $trtup IsFrozen false
            }]
            relation assign $self Hull
        
            $Hull.ctrls.frz configure\
                -text Freeze\
                -command [namespace code [list FreezeTrace $appid]]
        }
        proc ClearTrace {appid} {
            set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
            relation assign $self Hull
        
            rosea trace control clear
            $Hull.traces.text delete 1.0 end
        }
        proc SaveTrace {appid} {
            set self [relvar restrictone ::rash::TRCVIEW AppId $appid]
            relation assign $self Hull SaveDir
        
            set app [relvar restrictone ::rash::APP AppId $appid]
        
            set savefile [tk_getSaveFile\
                -confirmoverwrite true\
                -parent [relation extract $app Hull]\
                -initialdir $SaveDir\
                -title "Select Trace Save File"\
                -defaultextension .sqlite\
                -initialfile [clock format [clock seconds]\
                        -format "Trace-%Y-%m-%dT%H-%M-%S.sqlite"]\
                -filetypes {
                    {{SQLite Files}     .sqlite}
                    {{Text Files}       .txt}
                    {{All Files}        *}
                }\
            ]
            if {$savefile ne {}} {
                relvar updateone ::rash::TRCVIEW tv [list AppId $appid] {
                    tuple update $tv SaveDir [file dirname $savefile]
                }
                if {[file extension $savefile] eq ".sqlite"} {
                    ::rosea trace control save $savefile
                } else {
                    set outchan [open $savefile w]
                    try {
                        chan puts -nonewline $outchan [$Hull.traces.text get 1.0 end]
                    } finally {
                        close $outchan
                    }
                }
            }
        }
        namespace export create
        namespace ensemble create
    }
    relvar create DOMCLASS {
        AppId string
        Domain string
        Class string
        Hull string
    } {AppId Domain Class} Hull
    namespace eval DOMCLASS {
    namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid domain class hull} {
            set self [relvar insert ::rash::DOMCLASS [list\
                AppId $appid\
                Domain $domain\
                Class $class\
                Hull $hull\
            ]]
            relation assign $self
            ttk::frame $Hull
            grid $Hull -sticky nsew
            grid rowconfigure $Hull {0 1} -weight 1
            grid columnconfigure $Hull 0 -weight 1
            DVAL create $AppId $Domain $Class $Hull.data
            set events [pipe {
                ral relvar set ::rosea::Config::Event |
                relation restrict ~ evttup {
                    [tuple extract $evttup Domain] eq $Domain &&\
                    [tuple extract $evttup Model] eq $Class
                }
            }]
            
            if {[relation isnotempty $events]} {
                ttk::labelframe $Hull.sm\
                    -takefocus 0\
                    -text "Current State"
                grid $Hull.sm -sticky nsew
                grid rowconfigure $Hull.sm 0 -weight 1
                grid columnconfigure $Hull.sm 0 -weight 1
                SM create $AppId $Domain $Class $Hull.sm.cs
                set evtframe [ttk::labelframe $Hull.sm.evts\
                    -takefocus 0\
                    -text Events]
                grid $evtframe -sticky nsew
                set evtnum -1
                relation foreach event $events -ascending Event {
                    relation assign $event Event
                    set evtHull $evtframe.evt_[incr evtnum]
                    CEVT create $AppId $Domain $Class $Event $evtHull
                    grid $evtHull -pady 2 -sticky w
                }
            }
        
            return $self
        }
        namespace export create
        namespace ensemble create
    }
    relvar create DVAL {
        AppId string
        Domain string
        Class string
        Instances list
        Hull string
        CreateHull string
    } {AppId Domain Class} Hull
    namespace eval DVAL {
    namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid domain class hull} {
            set crhull .create_[string tolower $class]
            set self [relvar insert ::rash::DVAL [list\
                AppId $appid\
                Domain $domain\
                Class $class\
                Instances [list]\
                Hull $hull\
                CreateHull $crhull\
            ]]
            relation assign $self
            set ref [ToRef ::rash::DVAL $self]
            ttk::labelframe $Hull\
                -takefocus 0\
                -text "Class Data"
            grid $Hull -sticky nsew
            grid rowconfigure $Hull 0 -weight 1
            grid columnconfigure $Hull 0 -weight 1
            set classrelvar [FullyQualifyDomain $Domain]::$Class
            set insts [relvar set $classrelvar]
            set attrs [relation attributes $insts]
            set idattrs [list]
            foreach id [relvar identifiers $classrelvar] {
                ::struct::set add idattrs $id
            }
            set tv [tablelist::tablelist $Hull.inst\
                -columntitles $attrs\
                -showseparators true\
                -showarrow false\
                -stripebackground lightgreen\
                -setgrid true\
                -stretch all\
                -height 4\
                -xscrollcommand [list $Hull.xs set]\
                -yscrollcommand [list $Hull.ys set]\
                -editendcommand [namespace code [list EditDone $ref]]\
            ]
            set attrnum 0
            foreach attr $attrs {
                set opts [list -name col_$attr]
                if {$attr ni $idattrs} {
                    lappend opts\
                        -editable true\
                        -editwindow ttk::entry
                }
                $tv columnconfigure $attrnum {*}$opts
                incr attrnum
            }
            ttk::scrollbar $Hull.xs\
                -orient horizontal\
                -command [list $Hull.inst xview]
            ttk::scrollbar $Hull.ys\
                -orient vertical\
                -command [list $Hull.inst yview]
            
            grid $tv $Hull.ys -sticky nsew
            grid $Hull.xs - -sticky nsew
            ::autoscroll::autoscroll $Hull.xs
            ::autoscroll::autoscroll $Hull.ys
            set tlmenu [menu $Hull.tlmenu]
            $tlmenu add command\
                -label "Create"\
                -command [namespace code [list CreateDialog $ref]]
            $tlmenu add command\
                -label "Delete"\
                -command [namespace code [list DeleteInst $ref]]
            set eventtag [expr {[tk windowingsystem] eq "aqua" ? "<ButtonPress-2>" :\
                    "<ButtonPress-3>"}]
            bind [$tv bodytag] $eventtag [list tk_popup $tlmenu %X %Y] ; # <1>
            toplevel $crhull
            if {[winfo viewable .]} {
                wm transient $crhull .
            }
            wm withdraw $crhull
            
            wm title $crhull "Create Instance of $Class"
            wm protocol $crhull WM_DELETE_WINDOW\
                [namespace code [list CancelCreate $ref]]
            
            foreach {attr type} [relation heading $insts] {
                set awin [string tolower $attr]
                set lab [ttk::label $crhull.lab_$awin\
                    -text "$attr \[$type\]"\
                    -takefocus 0\
                ]
                set ent [ttk::entry $crhull.ent_$awin]
            
                bind $ent <Return> {focus [tk_focusNext %W]}
                bind $ent <KP_Enter> {focus [tk_focusNext %W]}
            
                grid $lab $ent\
                    -padx 2
                grid configure $lab\
                    -sticky e
                grid configure $ent\
                    -sticky w
            }
            
            focus $crhull.ent_[string tolower [lindex $attrs 0]]
            ttk::button $crhull.create\
                -text Create\
                -command [namespace code [list CreateInst $ref]]
            bind $crhull.create <Return> {%W invoke}
            bind $crhull.create <KP_Enter> {%W invoke}
            
            ttk::button $crhull.cancel\
                -text Cancel\
                -takefocus 0\
                -command [namespace code [list CancelCreate $ref]]
            
            grid $crhull.create $crhull.cancel
            relvar trace add variable $classrelvar\
                {delete insert set unset update}\
                [namespace code [list ModTrace $ref]]
            Refresh $ref $classrelvar
        
            return $self
        }
        proc ModTrace {self op relvar args} {
            after 0 [namespace code [list Refresh $self $relvar]] ; # <1>
        
            switch -exact -- $op {
                insert -
                set {
                    return [lindex $args 0]
                }
                update {
                    return [lindex $args 1]
                }
            }
        }
        proc Refresh {self relvar} {
            assignAttribute $self
        
            set tv $Hull.inst
            $tv selection clear 0 end
            $tv delete 0 end
        
            set insts [relvar set $relvar]
            set attrs [relation attributes $insts]
            set instmap [list]
        
            relation foreach inst $insts {
                $tv insert end [relation extract $inst {*}$attrs]
                lappend instmap [ToRef $relvar $inst]
            }
            $tv selection set 0 0
            updateAttribute $self Instances $instmap
        }
        proc SelectedInst {self} {
            assignAttribute $self AppId Hull Instances
        
            set activecell [$Hull.inst cellindex active]
            lassign [split $activecell ,] selected selectedcolumn
            if {$selected eq {}} {
                set app [::rosea::ClassCmds::findById ::rash::APP AppId $AppId]
                APP ShowUserMessage $app info "No Instance Selected"\
                    "Select instance from table where event is signaled"
                return [nilInstRef]
            } else {
                return [lindex $Instances $selected]
            }
        }
        proc CreateDialog {self} {
            assignAttribute $self CreateHull
            wm deiconify $CreateHull
            tkwait visibility $CreateHull
            focus [tk_focusNext $CreateHull]
            grab set $CreateHull
        }
        proc CreateInst {self} {
            assignAttribute $self Domain Class Hull CreateHull
        
            set classrelvar [FullyQualifyDomain $Domain]::$Class
            set insts [relvar set $classrelvar]
            set attrs [relation attributes $insts]
            set values [list]
            foreach attr $attrs {
                set ent $CreateHull.ent_[string tolower $attr]
                lappend values $attr [$ent get]
            }
        
            try {
                ::rosea::ClassCmds::create $classrelvar {*}$values
            } on error {result} {
                DataOpFailed $self $result
            }
        
            grab release $CreateHull
            wm withdraw $CreateHull
        }
        proc DataOpFailed {self result} {
        set line [lindex [split [string trimright $result \n] \n] 0]
        if {[regexp {\A[^:]+([^(]+)[^,]+, in relvar (\S+)} $line\
                match rnum refclass]} {
            set msg "Referential constraint, $rnum, on class, $refclass, failed"
        } else {
            set msg $result
        }
        
        tk_messageBox\
            -icon error\
            -title "Data Operation Failed"\
            -parent [readAttribute $self Hull]\
            -type ok\
            -message "Data Operation Failed:\n$msg"
        }
        proc CancelCreate {self} {
            assignAttribute $self CreateHull
            grab release $CreateHull
            wm withdraw $CreateHull
        }
        proc DeleteInst {self} {
            set selected [SelectedInst $self]
            if {[::rosea::InstCmds::isNotEmptyRef $selected]} {
                try {
                    ::rosea::InstCmds::delete $selected
                } on error {result} {
                    DataOpFailed $self $result
                }
            }
        }
        proc EditDone {self path row col value} {
            set ref [lindex [readAttribute $self Instances] $row]
            lassign $ref relvar inst
            set id [tuple get [relation tuple $inst]]
            set attrs [relation attributes [relvar set $relvar]]
            try {
                relvar updateone $relvar rvtup $id {
                    tuple update $rvtup [lindex $attrs $col] $value
                }
                return $value
            } on error {result opts} {
                $path rejectinput
                return -options $opts $result
            }
        }
        namespace export create
        namespace export SelectedInst
        namespace ensemble create
    }
    relvar create CEVT {
        AppId string
        Domain string
        Class string
        Event string
        Hull string
    } {AppId Domain Class Event} Hull
    namespace eval CEVT {
    namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid domain class event hull} {
            set self [relvar insert ::rash::CEVT [list\
                AppId $appid\
                Domain $domain\
                Class $class\
                Event $event\
                Hull $hull\
            ]]
            relation assign $self
            set ref [ToRef ::rash::CEVT $self]
            ttk::frame $Hull
            set evtb [ttk::button $Hull.__button\
                -text $Event\
                -command [namespace code [list SendEvent $ref]]\
            ]
            grid $evtb\
                -sticky w\
                -row 0\
                -column 0
            set params [pipe {
                ral relvar restrictone ::rosea::Config::EffectiveEvent\
                        Domain $Domain Model $Class Event $Event |
                relation semijoin ~ $::rosea::Config::StateTransition |
                relation eliminate ~ State Event |
                relation rename ~ NewState Name |
                relation semijoin ~ $::rosea::Config::State |
                relation list ~ Parameters |
                lindex ~ 0
            }]
            set counter -1
            foreach param $params {
                set pname [lindex $param 0]
                set phull $Hull.[string tolower $pname]
                EVTPARAM create $AppId $Domain $Class\
                    $Event $pname [incr counter] $phull
            
                grid $phull\
                    -row 0\
                    -column [expr {$counter + 1}]
            }
        
            return $self
        }
        proc SendEvent {self} {
            lassign $self relvar inst
        
            set classinst [pipe {
                relation semijoin $inst $::rash::DVAL\
                        -using {AppId AppId Domain Domain Class Class} |
                    ToRef ::rash::DVAL ~ |
                    DVAL SelectedInst ~
            }]
        
            if {[isNotEmptyRef $classinst]} {
                # Gather up the parameters
                set evtparams [relation semijoin $inst $::rash::EVTPARAM\
                    -using {AppId AppId Domain Domain Class Class Event Event}
                ]
                set values [list]
                relation foreach paramvalue $evtparams -ascending Order {
                    lappend values [EVTPARAM ReadValue $paramvalue]
                }
        
                ::rosea tunnel $classinst signal [relation extract $inst Event]\
                        {*}$values
            }
        }
        namespace export create
        namespace ensemble create
    }
    relvar create EVTPARAM {
        AppId string
        Domain string
        Class string
        Event string
        Param string
        Order int
        Hull string
    } {AppId Domain Class Event Param} {AppId Domain Class Event Order} Hull
    namespace eval EVTPARAM {
    namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid domain class event param order hull} {
            set self [relvar insert ::rash::EVTPARAM [list\
                AppId $appid\
                Domain $domain\
                Class $class\
                Event $event\
                Param $param\
                Order $order\
                Hull $hull\
            ]]
            relation assign $self
        
            ttk::frame $Hull
            ttk::label $Hull.label -text $Param
            ttk::entry $Hull.entry
        
            grid $Hull.label $Hull.entry\
                -padx 2
            grid configure $Hull.label\
                -sticky e
            grid configure $Hull.entry\
                -sticky w
        }
        proc ReadValue {self} {
            relation assign $self Hull
            return [$Hull.entry get]
        }
        namespace export create
        namespace export ReadValue
        namespace ensemble create
    }
    relvar create SM {
        AppId string
        Domain string
        Class string
        Hull string
    } {AppId Domain Class} Hull
    namespace eval SM {
    namespace path {::rash ::rosea::InstCmds ::rosea::Helpers}
        proc create {appid domain class hull} {
            set self [relvar insert ::rash::SM [list\
                AppId $appid\
                Domain $domain\
                Class $class\
                Hull $hull
            ]]
            relation assign $self
            
            set smrelvar [FullyQualifyDomain $Domain]::${Class}__STATEINST
            set insts [relvar set $smrelvar]
            set attrs [relation attributes $insts]
            ttk::frame $Hull
            grid $Hull -sticky nsew
            grid rowconfigure $Hull 0 -weight 1
            grid columnconfigure $Hull 0 -weight 1
            
            set tv [ttk::treeview $Hull.inst\
                -columns $attrs\
                -displaycolumns $attrs\
                -selectmode none\
                -show headings\
                -height 4\
                -xscrollcommand [list $Hull.xs set]\
                -yscrollcommand [list $Hull.ys set]\
            ]
            
            ttk::scrollbar $Hull.xs\
                -orient horizontal\
                -command [list $Hull.inst xview]
            ttk::scrollbar $Hull.ys\
                -orient vertical\
                -command [list $Hull.inst yview]
            
            grid $tv $Hull.ys -sticky nsew
            grid $Hull.xs - -sticky nsew
            ::autoscroll::autoscroll $Hull.xs
            ::autoscroll::autoscroll $Hull.ys
                foreach attr $attrs {
                    $tv column $attr\
                        -anchor w\
                        -width [expr\
                            {[font measure TkDefaultFont $attr] + 20}]\
                        -stretch true
                    $tv heading $attr\
                        -text $attr\
                        -anchor w
                }
            relvar trace add variable $smrelvar\
                {delete insert set unset update}\
                [namespace code [list ModTrace $self]]
            
            Refresh $self $smrelvar
        
            return $self
        }
        proc ModTrace {self op relvar args} {
            after 0 [namespace code [list Refresh $self $relvar]]
        
            switch -exact -- $op {
                insert -
                set {
                    return [lindex $args 0]
                }
                update {
                    return [lindex $args 1]
                }
            }
        }
        proc Refresh {self relvar} {
            relation assign $self
            set tv $Hull.inst
            $tv delete [$tv children {}]
        
            set insts [relvar set $relvar]
            set attrs [relation attributes $insts]
            relation foreach inst $insts {
                $tv insert {} end -values [relation extract $inst {*}$attrs]
            }
        }
        namespace export create
        namespace ensemble create
    }
    relvar association R1\
        MBAR AppId 1\
        APP AppId 1
    relvar association R2\
        DSEL AppId 1\
        APP AppId 1
    relvar association R3\
        DOMSTAT AppId *\
        DSEL AppId 1
    relvar association R4\
        DOMCLASS {AppId Domain} +\
        DOMSTAT {AppId Domain} 1
    relvar association R5\
        DVAL {AppId Domain Class} 1\
        DOMCLASS {AppId Domain Class} 1
    relvar association R6\
        CEVT {AppId Domain Class} *\
        DOMCLASS {AppId Domain Class} 1
    relvar association R7\
        EVTPARAM {AppId Domain Class Event} *\
        CEVT {AppId Domain Class Event} 1
    relvar association R8\
        TRCVIEW AppId 1\
        APP AppId 1
    relvar association R9\
        SM {AppId Domain Class} ?\
        DOMCLASS {AppId Domain Class} 1
    proc FullyQualifyDomain {domain} {
        return [pipe {
            relvar restrictone ::rosea::Config::Domain Name $domain |
            relation extract ~ Location |
            string cat ~ ::${domain}
        }]
    }

    namespace export init
    proc init {{appid Rash}} {
        APP create $appid .[string tolower $appid]
    }
    namespace ensemble create
}

package provide rash $::rash::version
