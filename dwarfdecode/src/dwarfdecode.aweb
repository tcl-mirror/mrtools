= Decoding Dwarf Debugging Information

== Introduction

This document describes a Tcl package named, *dwarfdecode*.
The *dwarfdecode* package interprets dwarf formatted debugging information
and makes it available in a more convenient form.

The use case for this information is to perform introspection on executable
files outside of a debugger.
Conventional source level debuggers use dwarf information to bridge the
gap between an executable and the program source from which it was derived.
For embeddeded systems, it is often the case that the information that
is readily available about the operation of the system is in terms of
low level addresses and other values.
The embedded system may not have the resources to store information that
can be used to relate back to the source.
This can be be particularly true of run time trace information where objects
are identified by their address and need to be corollated to the source
code from which they were derived.

One of the problems in dealing with dwarf information is its sheer volume.
Even small executable can yield a large amount of dwarf debugging information.

== Representing Dwarf Information

Dwarf information is typically placed into executables as a separate sections.
The section are given specific names:

* +.debug_abbrev+
* +.debug_aranges+
* +.debug_frame+
* +.debug_info+
* +.debug_line+
* +.debug_loc+
* +.debug_macinfo+
* +.debug_pubnames+
* +.debug_pubtypes+
* +.debug_ranges+
* +.debug_str+

(((class,dwarfinfo)))

----
<<dwarf info class>>=
::oo::class create ::dwarfdecode::dwarfinfo {
    <<dwarf info methods>>
}
----

The following sections describe the methods available to *dwarfinfo* objects.

(((dwarfinfo methods,exported,constructor)))

=== constructor
----
<<dwarf info methods>>=
constructor {fileobj} {
    set svcname ::dwarfdecode[self]
    ::logger::init $svcname
    ::logger::import -all -namespace log $svcname

    my variable debugInfoObj
    set debugInfoObj [::dwarfdecode::DebugInfo\
            [$fileobj getSectionDataByName .debug_info]]
    my variable abbrevInfoObj
    set abbrefInfoObj [::dwafdecode::DebugAbbrev\
            [$fileobj getSectionDataByName .debug_abbrev]]
}
----

(((dwarfinfo methods,exported,destructor)))

=== destructor
----
<<dwarf info methods>>=
destructor {
    my variable debugInfoObj
    $debugInfoObj destroy
    my variable abbrevInfoObj
    $abbrevInfoObj destroy
}
----

== Dwarf Debug Information

(((class,DebugInfo)))

----
<<dwarf debug info class>>=
::oo::class create ::dwarfdecode::DebugInfo {
    variable infoStream infoTree
    <<dwarf debug info methods>>
}
----

(((DebugInfo methods,exported,constructor)))

=== constructor
----
<<dwarf debug info methods>>=
constructor {debugData} {
    set svcname ::dwarfdecode[self]
    ::logger::init $svcname
    ::logger::import -all -namespace log $svcname

    namespace import ::ral::*
    namespace import ::ralutil::*

    relvar create DebugInfoIndex {
        Node        string
        Offset      int
        Base        int
        Item        int
    } Node Offset {Base Item}

    set infoStream [::dwarfdecode::InfoStream new $debugData]
    set infoTree [::struct::tree]
}
----

(((DebugInfo methods,exported,destructor)))

=== destructor
----
<<dwarf debug info methods>>=
destructor {
    $infoStream destroy
    $infoTree destroy
}
----

=== decode
----
<<dwarf debug info methods>>=
method decode {abbrevInfoObj} {
    while {[$infoStream remain] > 0} {
        log::debug "remain = [$infoStream remain]"
        set cuHeaderBegin [$infoStream where]
        log::debug "cuHeaderBegin = $cuHeaderBegin"
        # get the length of the compilation unit
        $infoStream convert 4 iu cuLength

        set endOffset [expr {[$infoStream where] + $cuLength}]

        # get the remainder of the compilation unit header
        $infoStream convert 7 "su iu cu" cuVersion cuAbbrOffset cuAddrSize
        log::debug "compilation unit header: length = $cuLength,\
                version = $cuVersion, abbrOffset = $cuAbbrOffset,\
                addrSize = $cuAddrSize"

        # Create a tree node to contain the header information
        set headNode [$infoTree insert root end]
        $infoTree set $headNode tag CUHeader
        $infoTree set $headNode offset $cuHeaderBegin
        $infoTree set $headNode base $cuHeaderBegin
        $infoTree set $headNode item 0
        $infoTree set $headNode attrs [dict create\
            unit_length $cuLength\
            version $cuVersion\
            debug_abbrev_offset $cuAbbrOffset\
            address_size $cuAddrSize\
        ]
        relvar insert DebugInfoIndex [list\
            Node        $headNode\
            Offset      $cuHeaderBegin\
            Base        $cuHeaderBegin\
            Item        0\
        ]
        # Get the abbreviation information.
        my variable abbrInfo
        set abbrInfo [$abbrevInfoObj decode $cuAbbrOffset]

        # Iterate across the debug info building the tree of information
        # about each compilation unit
        while {[$infoStream where] < $endOffset} {
            my decodeDebugInfoEntry $cuHeaderBegin $headNode
        }
    }

    log::debug \n[relformat [relvar set DebugInfoIndex] DebugInfoIndex]

    return
}
----

----
<<dwarf debug info methods>>=
method decodeDebugInfoEntry {base parent} {
    set offset [$infoStream where]
    set item [expr {$offset - $base}]
    set abbrCode [$infoStream unsignedLEB128]

    if {$abbrCode != 0} {
        log::debug "entry = $item, reference = $offset, code = $abbrCode"
        set infonode [$infoTree insert $parent end]
        log::debug "$infonode at depth [$infoTree depth $infonode]"
        $infoTree set $infonode offset $offset
        $infoTree set $infonode base $base
        $infoTree set $infonode item $item
        relvar insert DebugInfoIndex [list\
            Node        $infonode\
            Offset      $offset\
            Base        $base\
            Item        $item\
        ]

        my variable abbrInfo
        set abbrEntry [dict get $abbrInfo $abbrCode]
        dict with abbrEntry {
            $infoTree set $infonode tag $tag
            set attrlist [list]
            foreach {attr form} $attrs {
                set attrvalue [my DecodeValueForm $form]
                log::debug "$attr ==> $attrvalue ($form)"
                lappend attrlist $attr $form $attrvalue
            }
            $infoTree set $infonode attrs $attrlist
        }
        if {$hasChildren} {
            log::debug "child begin at [$infoStream where]"
            set childCode [my decodeDebugInfoEntry $base $infonode]
            log::debug "child end at [$infoStream where]"
            while {$childCode != 0} {
                log::debug "child begin at [$infoStream where]"
                set childCode [my decodeDebugInfoEntry $base $infonode]
                log::debug "child end at [$infoStream where]"
            }
        }
    }

    return $abbrCode
}
----

----
<<dwarf debug info methods>>=
method print {{ochan stdout}} {
    my variable infoTree

    $infoTree walk root -order pre -type dfs {action node} {
        set values [$infoTree getall $node]
        set leader [string repeat {   } [$infoTree depth $node]]
        foreach {name value} $values {
            puts $ochan "$leader$name $value"
        }
    }
}
----

=== Decoding Attribute Data

----
<<dwarf debug info methods>>=
method DecodeValueForm {form} {
    set methname Decode_$form
    if {$methname ni [info object methods [self] -all -private]} {
        error "unrecognized attribute form, \"$form\""
    }
    return [my $methname]
}
----

----
<<dwarf debug info methods>>=
# Form value =0x01
method Decode_DW_FORM_addr {} {
    $infoStream convert 4 iu value
    return $value
}

# Form value =0x03
method Decode_DW_FORM_block2 {} {
    $infoStream convert 2 su blockLen
    $infoStream convert $blockLen cu$blockLen value
    return $value
}

# Form value =0x04
method Decode_DW_FORM_block4 {} {
    $infoStream convert 4 iu blockLen
    $infoStream convert $blockLen cu$blockLen value
    return $value
}

# Form value =0x05
method Decode_DW_FORM_data2 {} {
    $infoStream convert 2 su value
    return $value
}

# Form value =0x06
method Decode_DW_FORM_data4 {} {
    $infoStream convert 4 iu value
    return $value
}

# Form value =0x07
method Decode_DW_FORM_data8 {} {
    $infoStream convert 3 wu value
    return $value
}

# Form value =0x08
method Decode_DW_FORM_string {} {
    return [$infoStream extractNULTermString]
}

# Form value =0x09
method Decode_DW_FORM_block {} {
    set blockLen [$infoStream unsignedLEB128]
    $infoStream convert $blockLen cu$blockLen value
    return $value
}

# Form value =0x0a
method Decode_DW_FORM_block1 {} {
    $infoStream convert 1 cu blockLen
    $infoStream convert $blockLen cu$blockLen value
    return $value
}

# Form value =0x0b
method Decode_DW_FORM_data1 {} {
    $infoStream convert 1 cu value
    return $value
}

# Form value =0x0c
method Decode_DW_FORM_flag {} {
    $infoStream convert 1 cu value
    return $value
}

# Form value =0x0d
method Decode_DW_FORM_sdata {} {
    return [$infoStream signedLEB128]
}

# Form value =0x0e
method Decode_DW_FORM_strp {} {
    $infoStream convert 4 iu value
    return $value
}

# Form value =0x0f
method Decode_DW_FORM_udata {} {
    return [$infoStream unsignedLEB128]
}

# Form value =0x10
method Decode_DW_FORM_ref_addr {} {
    $infoStream convert 4 iu value
    return $value
}

# Form value =0x11
method Decode_DW_FORM_ref1 {} {
    $infoStream convert 1 cu value
    return $value
}

# Form value =0x12
method Decode_DW_FORM_ref2 {} {
    $infoStream convert 2 su value
    return $value
}

# Form value =0x13
method Decode_DW_FORM_ref4 {} {
    $infoStream convert 4 iu value
    return $value
}

# Form value =0x14
method Decode_DW_FORM_ref8 {} {
    $infoStream convert 8 wu value
    return $value
}

# Form value =0x15
method Decode_DW_FORM_ref_udata {} {
    return [$infoStream unsignedLEB128]
}

# Form value =0x16
method Decode_DW_FORM_indirect {} {
    set form [my FormNumToStr [$infoStream unsignedLEB128]]
    return [my DecodeValueForm $form]
}
----

== Dwarf Abbreviations Information

Dwarf debugging information is split into two parts.
One part is contained in an *abbreviation table*
and the other part is simply a sequence of values.
The interpretation of the values is related to the
data encoded in the associated abbreviation entry.
The abbreviation entry describes how to interprete the values
of a debugging information entry.
This makes the data self-describing and eliminates the
repetative nature of the attributes type information.

We represent the abbreviation information in a class.
The abbreviation information itself must be decoded
Since each debugging information entry has an associated abbreviation
table entry,
we will defer the decoding of the abbreviation information until
it is actually called upon.

(((class,DebugAbbrev)))

----
<<dwarf debug abbrev class>>=
::oo::class create ::dwarfdecode::DebugAbbrev {
    <<dwarf debug abbrev methods>>
}
----

(((DebugAbbrev methods,exported,constructor)))

=== constructor
----
<<dwarf debug abbrev methods>>=
constructor {abbrevData} {
    set svcname ::dwarfdecode[self]
    ::logger::init $svcname
    ::logger::import -all -namespace log $svcname


    my variable infoStream
    set infoStream [::dwarfdecode::InfoStream new $abbrevData]

    my variable decodedAbbrevs
    set decodedAbbrevs [dict create]
}
----

(((DebugAbbrev methods,exported,destructor)))

=== destructor
----
destructor {
    my variable infoStream
    $infoStream destroy
}
----

----
<<dwarf debug abbrev methods>>=
method decode {offset} {
    my variable decodedAbbrevs
    set canonical [format %u $offset]
    # Get the abbreviation information.
    if {![dict exists $decodedAbbrevs $canonical]} {
        dict set decodedAbbrevs $canonical [my DecodeAbbrevSet $canonical]
    }
    return [dict get $decodedAbbrevs $canonical]
}
----

=== DecodeAbbrevSet
----
<<dwarf debug abbrev methods>>=
method DecodeAbbrevSet {offset} {
    my variable infoStream
    $infoStream seek $offset

    set abbrSet [dict create]
    for {set code [$infoStream unsignedLEB128]} {$code != 0}\
            {set code [$infoStream unsignedLEB128]} {
        set abbrEntry [my DecodeAbbrEntry]
        dict set abbrSet $code $abbrEntry
        log::debug "code = $code, abbrev = $abbrEntry"
    }
    return $abbrSet
}
----

----
<<dwarf debug abbrev methods>>=
method DecodeAbbrEntry {} {
    my variable infoStream
    set abbrEntry [dict create]

    set tag [my TagNumToStr [$infoStream unsignedLEB128]]
    dict set abbrEntry tag $tag

    $infoStream convert 1 cu hasChildren
    dict set abbrEntry hasChildren $hasChildren

    set attrs [list]
    for {set attrname [$infoStream unsignedLEB128] ;\
            set attrform [$infoStream unsignedLEB128]}\
            {!($attrname == 0 && $attrform == 0)}\
            {set attrname [$infoStream unsignedLEB128] ;\
            set attrform [$infoStream unsignedLEB128]} {
        lappend attrs [my AttrNumToStr $attrname] [my FormNumToStr $attrform]
    }
    dict set abbrEntry attrs $attrs

    return $abbrEntry
}
----

----
<<dwarf debug abbrev methods>>=
method TagNumToStr {tagnum} {
    if {$tagnum >= 0x4080 && $tagnum <= 0x4fff} {
        return [format DW_TAG_user(%#x) $tagnum]
    } elseif {$tagnum >= [llength $::dwarfdecode::tagStrMap]} {
        error "invalid tag number, \"[format %#x $tagnum]\""
    } else {
        set tagname [lindex $::dwarfdecode::tagStrMap $tagnum]
        if {$tagname eq {}} {
            error "tag number, \"$tagnum\", has no string mapping"
        }
        return $tagname
    }
}
----

----
<<dwarf data encodings>>=
variable tagStrMap {
    {}
    DW_TAG_array_type
    DW_TAG_class_type 
    DW_TAG_entry_point 
    DW_TAG_enumeration_type 
    DW_TAG_formal_parameter 
    {}
    {}
    DW_TAG_imported_declaration 
    {}
    DW_TAG_label 
    DW_TAG_lexical_block 
    {}
    DW_TAG_member 
    {}
    DW_TAG_pointer_type 
    DW_TAG_reference_type 
    DW_TAG_compile_unit 
    DW_TAG_string_type 
    DW_TAG_structure_type 
    {}
    DW_TAG_subroutine_type 
    DW_TAG_typedef 
    DW_TAG_union_type 
    DW_TAG_unspecified_parameters 
    DW_TAG_variant 
    DW_TAG_common_block 
    DW_TAG_common_inclusion 
    DW_TAG_inheritance 
    DW_TAG_inlined_subroutine 
    DW_TAG_module 
    DW_TAG_ptr_to_member_type 
    DW_TAG_set_type 
    DW_TAG_subrange_type 
    DW_TAG_with_stmt 
    DW_TAG_access_declaration 
    DW_TAG_base_type 
    DW_TAG_catch_block 
    DW_TAG_const_type 
    DW_TAG_constant 
    DW_TAG_enumerator 
    DW_TAG_file_type 
    DW_TAG_friend 
    DW_TAG_namelist 
    DW_TAG_namelist_item 
    DW_TAG_packed_type 
    DW_TAG_subprogram 
    DW_TAG_template_type_parameter 
    DW_TAG_template_value_parameter 
    DW_TAG_thrown_type 
    DW_TAG_try_block 
    DW_TAG_variant_part 
    DW_TAG_variable 
    DW_TAG_volatile_type 
    DW_TAG_dwarf_procedure 
    DW_TAG_restrict_type 
    DW_TAG_interface_type 
    DW_TAG_namespace 
    DW_TAG_imported_module 
    DW_TAG_unspecified_type 
    DW_TAG_partial_unit 
    DW_TAG_imported_unit 
    DW_TAG_condition 
    DW_TAG_shared_type 
}
----

----
<<dwarf debug abbrev methods>>=
method AttrNumToStr {attrnum} {
    if {$attrnum >= 0x2000 && $attrnum <= 0x3fff} {
        return [format DW_AT_user(%#x) $attrnum]
    } elseif {$attrnum >= [llength $::dwarfdecode::attrStrMap]} {
        error "invalid attribute number, \"[format %#x $attrnum]\""
    } else {
        set attrname [lindex $::dwarfdecode::attrStrMap $attrnum]
        if {$attrname eq {}} {
            error "attribute number, \"$attrnum\", has no string mapping"
        }
        return $attrname
    }
}
----

----
<<dwarf data encodings>>=
variable attrStrMap {
    {}
    DW_AT_sibling
    DW_AT_location
    DW_AT_name
    {}
    {}
    {}
    {}
    {}
    DW_AT_ordering
    {}
    DW_AT_byte_size
    DW_AT_bit_offset
    DW_AT_bit_size
    {}
    {}
    DW_AT_stmt_list
    DW_AT_low_pc
    DW_AT_high_pc
    DW_AT_language
    {}
    DW_AT_discr
    DW_AT_discr_value
    DW_AT_visibility
    DW_AT_import
    DW_AT_string_length
    DW_AT_common_reference
    DW_AT_comp_dir
    DW_AT_const_value
    DW_AT_containing_type
    DW_AT_default_value
    {}
    DW_AT_inline
    DW_AT_is_optional
    DW_AT_lower_bound
    {}
    {}
    DW_AT_producer
    {}
    DW_AT_prototyped
    {}
    {}
    DW_AT_return_addr
    {}
    DW_AT_start_scope
    {}
    DW_AT_bit_stride
    DW_AT_upper_bound
    {}
    DW_AT_abstract_origin
    DW_AT_accessibility
    DW_AT_address_class
    DW_AT_artificial
    DW_AT_base_types
    DW_AT_calling_convention
    DW_AT_count
    DW_AT_data_member_location
    DW_AT_decl_column
    DW_AT_decl_file
    DW_AT_decl_line
    DW_AT_declaration
    DW_AT_discr_list
    DW_AT_encoding
    DW_AT_external
    DW_AT_frame_base
    DW_AT_friend
    DW_AT_identifier_case
    DW_AT_macro_info
    DW_AT_namelist_item
    DW_AT_priority
    DW_AT_segment
    DW_AT_specification
    DW_AT_static_link
    DW_AT_type
    DW_AT_use_location
    DW_AT_variable_parameter
    DW_AT_virtuality
    DW_AT_vtable_elem_location
    DW_AT_allocated
    DW_AT_associated
    DW_AT_data_location
    DW_AT_byte_stride
    DW_AT_entry_pc
    DW_AT_use_UTF8
    DW_AT_extension
    DW_AT_ranges
    DW_AT_trampoline
    DW_AT_call_column
    DW_AT_call_file
    DW_AT_call_line
    DW_AT_description
    DW_AT_binary_scale
    DW_AT_decimal_scale
    DW_AT_small
    DW_AT_decimal_sign
    DW_AT_digit_count
    DW_AT_picture_string
    DW_AT_mutable
    DW_AT_threads_scaled
    DW_AT_explicit
    DW_AT_object_pointer
    DW_AT_endianity
    DW_AT_elemental
    DW_AT_pure
    DW_AT_recursive
}
----

----
<<dwarf debug abbrev methods>>=
method FormNumToStr {formnum} {
    if {$formnum >= [llength $::dwarfdecode::formStrMap]} {
        error "invalid form number, \"[format %#x $formnum]\""
    } else {
        set formname [lindex $::dwarfdecode::formStrMap $formnum]
        if {$formname eq {}} {
            error "form number, \"$formnum\", has no string mapping"
        }
        return $formname
    }
}
----

----
<<dwarf data encodings>>=
variable formStrMap {
    {}
    DW_FORM_addr
    {}
    DW_FORM_block2
    DW_FORM_block4
    DW_FORM_data2
    DW_FORM_data4
    DW_FORM_data8
    DW_FORM_string
    DW_FORM_block
    DW_FORM_block1
    DW_FORM_data1
    DW_FORM_flag
    DW_FORM_sdata
    DW_FORM_strp
    DW_FORM_udata
    DW_FORM_ref_addr
    DW_FORM_ref1
    DW_FORM_ref2
    DW_FORM_ref4
    DW_FORM_ref8
    DW_FORM_ref_udata
    DW_FORM_indirect
}
----

== Dwarf Public Names and Types

(((class,DebugPubnames)))

----
<<dwarf debug pubnames class>>=
::oo::class create ::dwarfdecode::DebugPubnames {
    variable infoStream
    <<dwarf debug pubnames methods>>
}
----

(((DebugPubnames methods,exported,constructor)))

=== constructor
----
<<dwarf debug pubnames methods>>=
constructor {debugData} {
    set svcname ::dwarfdecode[self]
    ::logger::init $svcname
    ::logger::import -all -namespace log $svcname

    namespace import ::ral::*
    namespace import ::ralutil::*

    relvar create NameEntry {
        DebugInfoOffset     int
        Item                int
        Name                string
    } {DebugInfoOffset Item}

    set infoStream [::dwarfdecode::InfoStream new $debugData]
}
----

(((DebugPubnames methods,exported,destructor)))

=== destructor
----
<<dwarf debug pubnames methods>>=
destructor {
    $infoStream destroy
}
----

(((DebugPubnames methods,exported,decode)))

=== decode

----
<<dwarf debug pubnames methods>>=
method decode {} {
    while {[$infoStream remain] > 0} {
        # Read in the header
        # First the length field
        $infoStream convert 4 iu unit_length
        # Get the remainder of the header
        $infoStream convert 10 "su iu iu"\
                version debug_info_offset debug_info_length
        log::debug "pubname header:\
            unit_length $unit_length\
            version $version\
            debug_info_offset $debug_info_offset\
            debug_info_length $debug_info_length"

        incr unit_length -10

        while {$unit_length > 0} {
            $infoStream convert 4 iu section_offset
            incr unit_length -4
            if {$section_offset == 0} {
                break
            }
            set name [$infoStream extractNULTermString]
            log::debug "pubname: $section_offset $name"
            relvar insert NameEntry [list\
                DebugInfoOffset     $debug_info_offset\
                Item                $section_offset\
                Name                $name\
            ]

            # +1 for the NUL terminator
            incr unit_length [expr {-(1 + [string length $name])}]
        }
        $infoStream advance $unit_length
    }
    #log::debug \n[relformat [relvar set NameEntry] NameEntry]
}
----

== Dwarf Public Names and Types

(((class,DebugAranges)))

----
<<dwarf debug aranges class>>=
::oo::class create ::dwarfdecode::DebugAranges {
    variable infoStream
    <<dwarf debug aranges methods>>
}
----

(((DebugAranges methods,exported,constructor)))

=== constructor
----
<<dwarf debug aranges methods>>=
constructor {debugData} {
    set svcname ::dwarfdecode[self]
    ::logger::init $svcname
    ::logger::import -all -namespace log $svcname

    namespace import ::ral::*
    namespace import ::ralutil::*

    relvar create AddressRange {
        DebugInfoOffset     int
        BeginAddress        int
        Length              int
    } DebugInfoOffset

    set infoStream [::dwarfdecode::InfoStream new $debugData]
}
----

(((DebugAranges methods,exported,destructor)))

=== destructor
----
<<dwarf debug aranges methods>>=
destructor {
    $infoStream destroy
}
----

(((DebugAranges methods,exported,decode)))

=== decode

----
<<dwarf debug aranges methods>>=
method decode {} {
    while {[$infoStream remain] > 0} {
        # Read in the header
        # First the length field
        $infoStream convert 4 iu unit_length
        # Get the remainder of the header
        $infoStream convert 10 "su iu cu cu"\
                version debug_info_offset address_size segment_size
        log::debug "arange header:\
            unit_length $unit_length\
            version $version\
            debug_info_offset $debug_info_offset\
            address_size $address_size\
            segment_size $segment_size

        incr unit_length -8

        while {$unit_length > 0} {
            $infoStream convert 8 "iu iu" address length
            incr unit_length -8
            if {$address == 0 && $length == 0} {
                break
            }
            log::debug "arange: $address $length"
            relvar insert AddressRange [list\
                DebugInfoOffset     $debug_info_offset\
                BeginAddress        $address\
                Length              $length\
            ]
        }
        $infoStream advance $unit_length
    }
    log::debug \n[relformat [relvar set AddressRange] AddressRange]
}
----

== Dwarf Information Stream

Decoding dwarf information entails processing streams of binary data.
For this purpose we create class to support the specific kinds of
binary decoding required for dwarf information.
The other classes in the package use the +InfoStream+ class to keep track
of their position in the binary stream.
Since dwarf data is divided into several portions there turn out to be
several objects of this class that are needed.

(((class,InfoStream)))

----
<<dwarf info stream class>>=
::oo::class create ::dwarfdecode::InfoStream {
    variable binaryInfo infoOffset
    <<dwarf info stream methods>>
}
----

The binary data is held very simply as a string and an offset into
that string where the next operation will take place.
Most dwarf data is packed sequentially so keep track of the current
location makes things more convenient.

(((InfoStream,exported methods,constructor)))

=== constructor

The constructor just initializes the object variables.

----
<<dwarf info stream methods>>=
constructor {data} {
    set binaryInfo $data
    set infoOffset 0
}
----

(((InfoStream,exported methods,where)))

=== where

The +where+ method returns the current offset into the binary string.

----
<<dwarf info stream methods>>=
method where {} {
    return $infoOffset
}
----

----
<<dwarf info stream tests>>=
test InfoStream-where-1.0 {
    Determine current location
} -setup {
    set is [dwarfdecode::InfoStream new "\0"]
} -cleanup {
    $is destroy
} -body {
    $is where
} -result {0}
----

(((InfoStream,method,remain)))

=== remain

The +remain+ method returns the number of bytes between the current
position and the end of the binary string.

----
<<dwarf info stream methods>>=
method remain {} {
    return [expr {[string length $binaryInfo] - $infoOffset}]
}
----

----
<<dwarf info stream tests>>=
test InfoStream-remain-1.0 {
    Find remaining number of bytes
} -setup {
    set is [dwarfdecode::InfoStream new "\x1\x2"]
} -cleanup {
    $is destroy
} -body {
    $is remain
} -result {2}
----

(((InfoStream,method,seek)))

=== seek

The +seek+ method changes the value of the current position to be that
of _offset_.
Seeking past the end of the binary data is an error.

----
<<dwarf info stream methods>>=
method seek {offset} {
    if {$offset >= [string length $binaryInfo]} {
        error "attempt to seek past end of information"
    }
    set infoOffset $offset
    return
}
----

----
<<dwarf info stream tests>>=
test InfoStream-seek-1.0 {
    Seek into data
} -setup {
    set is [dwarfdecode::InfoStream new "\x1\x2"]
} -cleanup {
    $is destroy
} -body {
    $is seek 1
    $is where
} -result {1}
----

----
<<dwarf info stream tests>>=
test InfoStream-seek-2.0 {
    Seek past end of data
} -setup {
    set is [dwarfdecode::InfoStream new "\x1\x2"]
} -cleanup {
    $is destroy
} -body {
    $is seek 3
} -result {attempt to seek past end of information} -returnCodes error
----

(((InfoStream,method,advance)))

----
<<dwarf info stream methods>>=
method advance {amount} {
    set newOffset [expr {$infoOffset + $amount}]
    if {$newOffset < 0 || $newOffset > [string length $binaryInfo]} {
        error "attempt to advance outside of information range"
    }
    set infoOffset $newOffset
}
----

(((InfoStream,method,convert)))

=== convert

The *convert* method is a simple control structure around the *binary scan*
command.
There we can consolidate the error checking.
The +count+ argument is the number of bytes to advance the current
stream position.
The +fmt+ is the *binary scan* format string and +args+ is list of
variable names into which the scanned results are placed.

----
<<dwarf info stream methods>>=
method convert {count fmt args} {
    foreach arg $args {
        upvar 1 $arg $arg
    }
    set cvtd [binary scan $binaryInfo "@$infoOffset $fmt" {*}$args]
    if {$cvtd != [llength $args]} {
        error "expected to convert \"[llength $args]\" values,\
            actually converted \"$cvtd\""
    }
    tailcall my advance $count
}
----

----
<<dwarf info stream tests>>=
test InfoStream-convert-1.0 {
    Convert an unsigned 4-byte little-endian integer
} -setup {
    set is [dwarfdecode::InfoStream new "\x01\x02\x00\x00"]
} -cleanup {
    $is destroy
} -body {
    $is convert 4 iu value
    return [format %#x $value]
} -result {0x201}
----

(((InfoStream,method,extractString)))

=== extractNULTermString

The *extractNULTermString* method extracts a NUL terminated string from the
binary data. It searches for the first NUL value from the current position

----
<<dwarf info stream methods>>=
method extractNULTermString {} {
    set strcount\
            [expr {[string first \0 $binaryInfo $infoOffset] - $infoOffset}]
    binary scan $binaryInfo "@$infoOffset a$strcount" strvalue
    # +1 to point past the NUL byte
    my advance [expr {$strcount + 1}]
    return $strvalue
}
----

----
<<dwarf info stream tests>>=
test InfoStream-extractNULTermString-1.0 {
    Extract a "C" style string
} -setup {
    set is [dwarfdecode::InfoStream new "Abc\0Def"]
} -cleanup {
    $is destroy
} -body {
    $is extractNULTermString
} -result {Abc}
----

[float]
=== LEB128 Representation

Dwarf uses something called ``Little Endian Base 128'' to hold numerical
data of an arbitrary precision but encoded in a way that gives a smaller
representation for small magnitiude numbers.
There are both signed and unsigned versions.

=== unsignedLEB128

----
<<dwarf info stream methods>>=
method unsignedLEB128 {} {
    set shift 0
    set result 0
    for {set done false} {!$done} {set done [expr {($byte & 0x80) == 0}]} {
        my convert 1 cu byte
        set result [expr {$result | (($byte & 0x7f) << $shift)}]
        incr shift 7
    }
    return $result
}
----

----
<<dwarf info stream tests>>=
test InfoStream-unsignedLEB128-1.0 {
    Decode 0 as unsigned LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\0"]
} -cleanup {
    $is destroy
} -body {
    $is unsignedLEB128
} -result {0}
----

----
<<dwarf info stream tests>>=
test InfoStream-unsignedLEB128-2.0 {
    Decode 1 byte non-zero unsigned LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\x7f"]
} -cleanup {
    $is destroy
} -body {
    $is unsignedLEB128
} -result {127}
----

----
<<dwarf info stream tests>>=
test InfoStream-unsignedLEB128-3.0 {
    Decode 2 byte unsigned LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\x80\x01"]
} -cleanup {
    $is destroy
} -body {
    $is unsignedLEB128
} -result {128}
----

=== signedLEB128

For signed LEB128 integers, we must perform the necessary sign extension.
The basic decoding is the same.

----
<<dwarf info stream methods>>=
method signedLEB128 {} {
    set shift 0
    set result 0
    for {set done false} {!$done} {set done [expr {($byte & 0x80) == 0}]} {
        my convert 1 cu byte
        set result [expr {$result | (($byte & 0x7f) << $shift)}]
        incr shift 7
    }
    # Test the sign bit
    if {($result & (1 << ($shift - 1))) != 0} {
        # OR in the bit extensions
        set result [expr {$result | (~0 << $shift)}]
    }
    return $result
}
----

----
<<dwarf info stream tests>>=
test InfoStream-signedLEB128-1.0 {
    Decode 0 as signed LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\0"]
} -cleanup {
    $is destroy
} -body {
    $is signedLEB128
} -result {0}
----

----
<<dwarf info stream tests>>=
test InfoStream-signedLEB128-2.0 {
    Decode 1 byte positive integer as signed LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\2"]
} -cleanup {
    $is destroy
} -body {
    $is signedLEB128
} -result {2}
----

----
<<dwarf info stream tests>>=
test InfoStream-signedLEB128-3.0 {
    Decode 1 byte negative integer as signed LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\x7e"]
} -cleanup {
    $is destroy
} -body {
    $is signedLEB128
} -result {-2}
----

----
<<dwarf info stream tests>>=
test InfoStream-signedLEB128-4.0 {
    Decode 2 byte positive integer as signed LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\xff\x00"]
} -cleanup {
    $is destroy
} -body {
    $is signedLEB128
} -result {127}
----

----
<<dwarf info stream tests>>=
test InfoStream-signedLEB128-4.1 {
    Decode 2 byte positive integer as signed LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\x80\x01"]
} -cleanup {
    $is destroy
} -body {
    $is signedLEB128
} -result {128}
----

----
<<dwarf info stream tests>>=
test InfoStream-signedLEB128-5.0 {
    Decode 2 byte negative integer as signed LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\x81\x7f"]
} -cleanup {
    $is destroy
} -body {
    $is signedLEB128
} -result {-127}
----

----
<<dwarf info stream tests>>=
test InfoStream-signedLEB128-5.0 {
    Decode 2 byte negative integer as signed LEB128
} -setup {
    set is [dwarfdecode::InfoStream new "\x80\x7f"]
} -cleanup {
    $is destroy
} -body {
    $is signedLEB128
} -result {-128}
----

== Code Organization

=== Source Code

----
<<dwarfdecode.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.

package require Tcl 8.6
package require logger
package require ral
package require ralutil
package require struct::tree

namespace eval ::dwarfdecode {
    namespace export dwarfinfo
    namespace ensemble create

    logger::initNamespace [namespace current]

    variable version 1.0

    <<dwarf data encodings>>
}

<<dwarf info stream class>>
<<dwarf debug aranges class>>
<<dwarf debug pubnames class>>
<<dwarf debug abbrev class>>
<<dwarf debug info class>>
<<dwarf info class>>

package provide dwarfdecode $::dwarfdecode::version
----

=== Unit Tests

----
<<unit tests>>=
<<dwarf info stream tests>>
----

----
<<dwarfdecode.test>>=
#!/usr/bin/env tclsh
# This software is copyrighted 2013 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
#
#*++
# PROJECT:
#  mrtools
#
# MODULE:
#  dwarfdecode.test -- unit tests for dwarfdecode package
#
# ABSTRACT:
#
#*--
#

package require Tcl 8.6
package require cmdline
package require logger

source ../../elfdecode/src/elfdecode.tcl
chan puts "using elfdecode version: [package require elfdecode]"

source ../src/dwarfdecode.tcl
package require dwarfdecode
chan puts "testing dwarfdecode version: [package require dwarfdecode]"

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
    {file.arg {} {Elf file name}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

::dwarfdecode::log::setlevel $options(level)
#::logger::setlevel $options(level)

package require tcltest
eval tcltest::configure $argv

namespace eval ::dwarfdecode::test {
    ::logger::initNamespace [namespace current] $options(level)

    namespace import ::tcltest::*

    <<unit tests>>

    cleanupTests
}

namespace delete ::dwarfdecode::test
----
