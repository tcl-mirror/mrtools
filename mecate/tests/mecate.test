#!/usr/bin/env tclsh
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
# This software is copyrighted 2018 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
#

package require Tcl 8.6
package require cmdline
package require logger
package require tcltest

source ../code/tcl/mecate.tcl

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

::mecate::log::setlevel $options(level)

tcltest::configure {*}$argv

namespace eval ::mecate::test {
    ::logger::initNamespace [namespace current]

    log::info "testing mecate version: [package require mecate]"

    namespace import ::tcltest::*
    namespace import ::ral::*
    namespace import ::ralutil::*

    # Utility proc to execute unexported methods.
    proc objeval {obj args} {
        namespace eval [info object namespace $obj] {*}$args
    }
    test constructor-1.0 {
        Create rein object
    } -setup {
    } -cleanup {
    } -body {
        mecate rein create ::apptest
    } -result {::apptest}
    test cget-1.0 {
        Get timeout value
    } -setup {
    } -cleanup {
    } -body {
        ::apptest cget -timeout
    } -result {2000}
    test configure-1.0 {
        get timeout value
    } -setup {
    } -cleanup {
        ::apptest configure -timeout 2000
    } -body {
        ::apptest configure -timeout 3000
        ::apptest cget -timeout
    } -result {3000}
    test start-1.0 {
        start test harness program
    } -setup {
    } -cleanup {
    } -body {
        ::apptest start ./bstore_harness
    } -result {[0-9]+} -match regexp
    test connect-1.0 {
        connect to program
    } -setup {
    } -cleanup {
    } -body {
        ::apptest connect
    } -result {}
    test null-1.0 {
        null method test
    } -setup {
    } -cleanup {
    } -body {
        ::apptest null
    } -result {}
    test version-1.0 {
        version method test
    } -setup {
    } -cleanup {
    } -body {
        ::apptest version
    } -result {1.1}
    test query-1.0 {
        Query the domains in the harness
    } -setup {
    } -cleanup {
    } -body {
        ::apptest query domains
    } -result {bookstore}
    test query-1.1 {
        Query the domain operations in the bookstore domain
    } -setup {
    } -cleanup {
    } -body {
        set ops [::apptest query operations bookstore]
    } -result {changeSelectionQuantity init}
    test query-1.2 {
        Query the domain operation parameters for changeSelectionQuantity
    } -setup {
    } -cleanup {
    } -body {
        set ops [::apptest query doparams bookstore changeSelectionQuantity]
    } -result {cartID MRT_InstId productID MRT_InstId quantity unsigned}
    test query-2.0 {
        Query the classes in the bookstore domain
    } -setup {
    } -cleanup {
    } -body {
        set classes [lsort [::apptest query classes bookstore]] ; # <1>
        return [lindex $classes 0]
    } -result {Artist}
    test query-2.1 {
        Query the attributes of the Artist class
    } -setup {
    } -cleanup {
    } -body {
        ::apptest query attributes bookstore Artist
    } -result {artistName}
    test query-2.2 {
        Query the instances of the Artist class
    } -setup {
    } -cleanup {
    } -body {
        ::apptest query instances bookstore Artist
    } -result {total 2 named {fs 1 mj 0}}
    test query-3.0 {
        Query the states of the ShoppingCart class
    } -setup {
    } -cleanup {
    } -body {
        ::apptest query states bookstore ShoppingCart
    } -result {@ NewOrder AddingSelectiontoOrder CancelingEntireOrder\
            EstablishingCustomerandVerifyingPayment}
    test query-4.0 {
        Query the events of the ShoppingCart class
    } -setup {
    } -cleanup {
    } -body {
        ::apptest query events bookstore ShoppingCart
    } -result {addSelection cancel checkOut startCart}
    test query-4.1 {
        Query the event parameters of the startCart event
    } -setup {
    } -cleanup {
    } -body {
        ::apptest query evparams bookstore ShoppingCart startCart
    } -result {productID {char const *} quantity unsigned}
    test query-5.0 {
        Query the current state of an instance
    } -setup {
    } -cleanup {
    } -body {
        ::apptest query current bookstore Warehouse acme
    } -result {WaitingforaShipment}
    test domainop-1.0 {
        Initialize the bookstore domain
    } -setup {
    } -cleanup {
    } -body {
        ::apptest domainop bookstore init
    } -result {}
    test read-1.0 {
        Read the value of the product ID for the XUML book.
    } -setup {
    } -cleanup {
    } -body {
        ::apptest read bookstore Product mbxuml productID
    } -result {productID 14387}
    test update-1.0 {
        Update the value of the email of the mjb author
    } -setup {
    } -cleanup {
    } -body {
        ::apptest update bookstore Author mjb email mjb@gmail.com
    } -result {email mjb@gmail.com}
    test eloop-1.0 {
        Query execution state
    } -setup {
    } -cleanup {
    } -body {
        ::apptest eloop
    } -result {running}
    test eloop-2.0 {
        Halt execution
    } -setup {
    } -cleanup {
    } -body {
        ::apptest eloop halt
    } -result {halted}
    test eloop-3.0 {
        Dispatch an event
    } -setup {
    } -cleanup {
        ::apptest eloop run ; # set things back to running for later
    } -body {
        ::apptest eloop once
    } -result {false}
    test trace-1.0 {
        Query tracing
    } -setup {
    } -cleanup {
    } -body {
        ::apptest trace
    } -result {off}
    test trace-1.1 {
        Turn tracing on
    } -setup {
    } -cleanup {
    } -body {
        ::apptest trace on
    } -result {on}
    test trace-1.2 {
        Turn tracing off
    } -setup {
    } -cleanup {
    } -body {
        ::apptest trace off
    } -result {off}
    test instr-1.0 {
        Query instrumentation
    } -setup {
    } -cleanup {
    } -body {
        ::apptest instr
    } -result {off}
    test scenario-0.1 {
        Start session with bookstore domain
    } -setup {
    } -cleanup {
    } -body {
        ::apptest disconnect
        ::apptest clearEventTraceCache
        ::apptest clearInstrTraceCache
        after 500
        ::apptest start ./bstore_harness
        ::apptest connect
        ::apptest instr on
        ::apptest trace on
    } -result {on}
    test scenario-1.0 {
        Create a shopping cart asynchronously
    } -setup {
        set prodattr [::apptest read bookstore Product mbxuml productID]
        set prodid [dict get $prodattr productID]
    } -cleanup {
    } -body {
        set cartid [::apptest createasync bookstore ShoppingCart\
                startCart $prodid 1]
        ::apptest waitForEventTrace\
                type transition\
                target ShoppingCart.$cartid\
                newstate AddingSelectiontoOrder
        return $cartid
    } -result {0}
    test scenario-1.1 {
        Cancel order by changing quantity to 0.
    } -setup {
        set prodinsts [::apptest query instances bookstore Product]
        set mbxumlinst [dict get $prodinsts named mbxuml]
    } -cleanup {
    } -body {
        ::apptest domainop bookstore changeSelectionQuantity\
            $cartid $mbxumlinst 0
        set trace [::apptest waitForEventTrace type transition event cancel\
                target ShoppingCart.$cartid]
        return [dict get $trace newstate]
    } -result {CancelingEntireOrder}
    test scenario-2.0 {
        Create a new shopping cart
    } -setup {
        set prodattr [::apptest read bookstore Product mbxuml productID]
        set prodid [dict get $prodattr productID]
    } -cleanup {
    } -body {
        set cartid [::apptest createasync bookstore ShoppingCart\
                startCart $prodid 1]
        ::apptest waitForEventTrace\
                type transition\
                target ShoppingCart.$cartid\
                newstate AddingSelectiontoOrder
        return $cartid
    } -result {1}
    test scenario-2.1 {
        Buy three copies of the book
    } -setup {
        set prodinsts [::apptest query instances bookstore Product]
        set mbxumlinst [dict get $prodinsts named mbxuml]
    } -cleanup {
    } -body {
        ::apptest domainop bookstore changeSelectionQuantity\
            $cartid $mbxumlinst 3
        set trace [::apptest waitForEventTrace type transition event changeQuantity\
                target ProductSelection.1]
        return [dict get $trace newstate]
    } -result {ChangingQuantity}
    test scenario-2.2 {
        Add some music to the shopping cart
    } -setup {
        set prodattr [::apptest read bookstore Product cmc productID]
        set prodid [dict get $prodattr productID]
    } -cleanup {
    } -body {
        ::apptest signal bookstore ShoppingCart $cartid addSelection $prodid 2
        ::apptest waitForEventTrace\
                type transition\
                target ShoppingCart.$cartid\
                newstate AddingSelectiontoOrder
        return $cartid
    } -result {1}
    test scenario-2.3 {
        Checkout to buy selections
    } -setup {
    } -cleanup {
    } -body {
        ::apptest signal bookstore ShoppingCart $cartid checkOut\
                "5555 6666 7777 8888"\
                "100 E Main St., Anywhere, CO 88888"\
                "9/11/2010"\
                "Fred Smith"\
                "fsmith@gmail.com"\
                "Fred Smith"\
                "222-555-1212"\
                "100 E Main St., Anywhere, CO 88888"
        set event [::apptest waitForEventTrace\
                type transition\
                source Warehouse.acme\
                target ShippingClerk.fs\
                newstate SelectingBooks]
        return [dict get $event newstate]
    } -result {SelectingBooks}
    test scenario-3.0 {
        Wait for order to be packed
    } -setup {
    } -cleanup {
    } -body {
        set event [::apptest waitForEventTrace\
                type transition\
                target Warehouse.acme\
                currstate WaitingforaShipment\
                newstate IG]
        return [dict get $event newstate]
    } -result {IG}
    test scenario-4.0 {
        Wait for order to be delivered
    } -setup {
    } -cleanup {
    } -body {
        set event [::apptest waitForEventTrace\
                type transition\
                target Order.0\
                newstate DeliveredtoCustomer]
        return [dict get $event newstate]
    } -result {DeliveredtoCustomer}
    test scenario-5.0 {
        Save traces
    } -setup {
    } -cleanup {
    } -body {
        ::apptest saveTraces scenarios.ral
        ::apptest saveTraces scenarios.sqlite sqlite
    } -result {}
    test scenario-5.1 {
        Print traces
    } -setup {
    } -cleanup {
    } -body {
        puts "***"
        puts "*** State Machine Event Traces"
        puts "***"
        puts [::apptest formatEventTraces]
    
        puts "***"
        puts "*** Instrumentation Traces"
        puts "***"
        puts [::apptest formatInstrTraces]
    } -result {}
    test scenario-5.2 {
        Discard event traces
    } -setup {
    } -cleanup {
    } -body {
        ::apptest discardEventTraces
        ::apptest formatEventTraces
    } -result {}
    test scenario-5.3 {
        Discard instrumentation traces
    } -setup {
    } -cleanup {
    } -body {
        ::apptest discardInstrTraces
        ::apptest formatInstrTraces
    } -result {}

    ::apptest destroy

    cleanupTests
}
