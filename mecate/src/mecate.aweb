// vim: set syntax=asciidoc:
////////
 *++
 * PROJECT:
 *  mrtools
 * MODULE:
 *  mecate.tcl -- interfacing to bosal generated harnesses
 * ABSTRACT:
 *
 *--
////////
= The Mecate Package

== Introduction

This document contains a Tcl package to support unit testing
`micca` domains that are run in `bosal` generated test harnesses.
`Bosal` is an automatic test harness generator for `micca` domains.
The test harness is an executable program that wraps one or more domains and
provides a means to communication with the outside world so that
the domain can be exercised.

These tools enable a `micca` domain to be compiled to run in a POSIX
environment and to interact with the domain by driving its execution
via operations and events.
The harnessed domain also produces output containing information about
state transitions, instrumentation information inserted by `micca`,
and fatal errors.

The basic unit test workflow is:

* Build the harnessed domain
(or domains, as test harness programs may contain several domains).
It is usually useful to compile the domain code with compiler options
that enable measuring code coverage.

* Send commands to the test application and observe the various traces
and other outputs to verify the application execution.

* Run sufficient test cases to obtain the code and state transition
coverage desired.

Although the communications interface provided by `bosal` generated
harnesses is ASCII record oriented,
the `mecate` package is intended to support the running of test cases
by providing a simpler interface to the harnessed application and
to provide services to monitor the output of the application and take
actions when specific traces, etc. are received as responses from the
test application.

The `mecate` package is organized as a single TclOO class called `rein`.

[source,tcl]
----
<<mecate commands>>=
::oo::class create ::mecate::rein {
    <<rein configuration>>
}
----

The `rein` class command is also exported as an ensemble command
from the `mecate` namespace.
An object of the `rein` class will have
methods to support the workflow discussed above.
The following sections describe the various methods of the `rean` class
and are grouped according to topics.
In many cases the methods provide only a thin veneer over the underlying
`bosal` communications protocol.
Other methods and data in the class support collecting state machine
traces and instrumentation output from a test harness.

== Class Management

The methods in this section handle constructing and configuring
objects of the `rein` class.

=== Constructor

(((rein,method,constructor)))

*****
`mecate rein create` _objname_ _?options?_

`mecate rein new` _?options?_

The constructor for `rein` takes a set of option / value pairs.
The options are:

`-timeout <msec timeout>`:: the default time out value for
    synchronization operations. If no timeout option is given,
    the default is 2000 milliseconds.
*****

(((rein,method,constructor)))

[source,tcl]
.Implementation
----
<<rein configuration>>=
constructor {args} {
    set svcname mecate[self]
    ::logger::init $svcname
    ::logger::import -all -namespace log $svcname

    set timeout 2000
    foreach {option value} $args {
        switch -exact -- $option {
            -timeout {
                set timeout $value
            }
            default {
                error "unknown option, \"$option\""
            }
        }
    }

    log::debug "-timeout option = \"$timeout\""

    variable tracesReceived
    set tracesReceived [::struct::queue]

    variable instrReceived
    set instrReceived [::struct::queue]

    namespace import ::ral::*
    namespace import ::ralutil::*

    <<rein data structures>>

    return
}
----

The configuration information for the class is used frequently enough
that we just make it variables available to all methods.
Note that the variable names are the same as the option names
and this is significant.

[source,tcl]
----
<<rein configuration>>=
variable timeout connection
----

[source,tcl]
.Tests
----
<<constructor tests>>=
test constructor-1.0 {
    Create rein object
} -setup {
} -cleanup {
} -body {
    mecate rein create ::apptest
} -result {::apptest}
----

=== Destructor

(((rein,method,destructor)))

*****
_reinobj_ `destroy`

The destructor for `rein` objects closes any communications connection made to
the harnessed application.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
destructor {
    my disconnect

    variable tracesReceived
    $tracesReceived destroy

    variable instrReceived
    $instrReceived destroy

    relvar constraint delete R1
    relvar unset Trace TransitionTrace PolymorphicTrace CreationTrace\
            Instrumentation
}
----

=== Cget

(((rein,method,cget)))

*****
_reinobj_ `cget` _option_

_option_ is one of the options described for the constructor.
The method returns the value of the given option.

The `cget` method may be used to obtain the values of the options
that were set during construction.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method cget {option} {
    switch -exact -- $option {
        -timeout {
            return [set [string range $option 1 end]]
        }

        default {
            error "unknown option, \"$option\""
        }
    }
}
----

[source,tcl]
.Tests
----
<<constructor tests>>=
test cget-1.0 {
    Get timeout value
} -setup {
} -cleanup {
} -body {
    ::apptest cget -timeout
} -result {2000}
----

=== Configure

(((rein,method,configure)))

*****
_reinobj_ `configure` _?opt1 value1 opt2 value2 ...?_

The `configure` method may be used to set the values of the
configuration options.
Option names and values are those described for the constructor.
Returns the empty string.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method configure {args} {
    foreach {option value} $args {
        switch -exact -- $option {
            -timeout {
                set [string range $option 1 end] $value
            }

            default {
                error "unknown option, \"$option\""
            }
        }
    }

    return
}
----

[source,tcl]
.Tests
----
<<constructor tests>>=
test configure-1.0 {
    get timeout value
} -setup {
} -cleanup {
    ::apptest configure -timeout 2000
} -body {
    ::apptest configure -timeout 3000
    ::apptest cget -timeout
} -result {3000}
----

== Test Harness Management

The methods in this section are used to set up and take down a
test harness program.
It is necessary to start the execution of a test harness before
is can be used.
Sometimes this is accomplished outside of a test script,
for example if the test harness is running under control of a debugger.

When a `bosal` generated test harness starts,
it acts as a server, opening a TCP port on the local host and awaiting
a connection.
The `rein` class provides methods to perform these actions directly
from a test script.

=== Start

(((rein,method,start)))

*****
_reinobj_ `start` _program_ _?delay?_

The `start` method is used to begin execution of the test harness program.
Starting is separated out as a method because certain test situation
will have the harness program running under a debugger which will be
reponsible for starting program execution.

`program`::
    The name of the test harness program.

`delay`::
    The the number of milliseconds to wait before control is returned to the
    caller.
    This time is used to insure that the harness program has
    had enough time to establish its communication interface before allowing
    the test to proceed.

The return value is the process ID of the harness program, although such
a number is of little use in the Tcl world.
When the test harness communications channel is destroyed,
the harness program itself exits.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method start {program {delay 500}} {
    log::info "starting harness program, \"$program\""
    set progargs [auto_execok $program]
    if {$progargs eq {}} {
        error "unknown program, \"$program\""
    }
    set pid [exec -ignorestderr -- $progargs &]
    after $delay
    return $pid
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test start-1.0 {
    start test harness program
} -setup {
} -cleanup {
} -body {
    ::apptest start ./bstore_harness
} -result {[0-9]+} -match regexp
----

=== Connect

(((rein,method,connect)))

*****
_reinobj_ `connect` _?port?_

The `connect` method forms a communcations connection to the test harness.
All I/O to and from the test harness happens across this connection.

`port`::
    The local host port number on which the test harness program
    accepts connection requests.
    By default this is port 3906.

Returns the empty string.
Throws an error if the connection cannot be established.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method connect {{port 3906}} {
    log::info "connecting to localhost:$port"

    set tries 0                             ; # <1>
    while {true} {
        try {
            set connection [socket localhost $port]
            chan configure $connection -blocking true -buffering line
            chan event $connection readable [mymethod HandleHarnessInput]
            return
        } on error {result opts} {
            incr tries
            if {$tries >= 3} {
                log::error "connection failure after $tries attempts"
                return -options $opts $result
            }
            log::info "connection attempt failed, waiting 500 ms to try again"
            after 500
        }
    }
}
----
<1> We intend to try the connection 3 times, pausing between any failures.

[source,tcl]
.Tests
----
<<exported tests>>=
test connect-1.0 {
    connect to program
} -setup {
} -cleanup {
} -body {
    ::apptest connect
} -result {}
----

=== Disconnect

(((rein,method,disconnect)))

*****
_reinobj_ `disconnect`

The `disconnect` method closes the communcations connection to the test harness.
This causes the test harness process to exit.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method disconnect {} {
    log::info "disconnecting from test harness"
    if {[info exists connection]} {
        catch {chan close $connection}
        unset -nocomplain connection
    }
    return
}
----

=== Null

(((rein,method,null)))

*****
_reinobj_ `null`

The `null` method performs no action on the test domain,
but communicates with it to insure that it is responsive.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method null {} {
    return [my Command null]                ; # <1>
}
----
<1> The `Command` method does all the heavy lifting when communicating
commands to the test harness.
This method is discussed
<<command-method,below>>.

[source,tcl]
.Tests
----
<<exported tests>>=
test null-1.0 {
    null method test
} -setup {
} -cleanup {
} -body {
    ::apptest null
} -result {}
----

=== Version

(((rein,method,version)))

*****
_reinobj_ `version`

The `version` method returns the version number of `bosal`
used to create the test harness code.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method version {} {
    return [my Command version]
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test version-1.0 {
    version method test
} -setup {
} -cleanup {
} -body {
    ::apptest version
} -result {1.1}
----

== Harness Introspection

A `bosal` generated harness has introspection capabilities that
can be used to determine the characteristics of the domains in the
harness.
This information is available using the `query` method described in
this section.

=== Query

(((rein,method,query)))

*****
_reinobj_ `query` _what_ _?arg1 arg2 ...?_

The `query` method returns the result of querying various entities
in a test harness.
It is possible to determine the domains in the harness,
the classes of each domain and many other characteritics.

`what`::
    The type of query to be performed. The `what` argument may be one of
    the following:

    domains:::
        Returns the names of the domains contained in the test harness.
    operations _domain_:::
        Returns the names of the domain operations for the given domain.
    doparams _domain_ _operation_:::
        Returns the names and data types of the parameters for the
        given domain operation.
    classes _domain_:::
        Returns the names of the class for the given domain.
    attributes _domain_ _class_:::
        Returns the names of the attributes for the given class.
    instances _domain_ _class_:::
        Returns the total number of instances and the name and identifiers
        for the pre-existing instances.
    states _domain_ _class_:::
        Returns the names of the states for the given class.
    events _domain_ _class_:::
        Returns the names of the events for the given class.
    evparams _domain_ _class_ _event_:::
        Returns the parameter names and data types for the given event.
    current _domain_ _class_ _instance_:::
        Returns the current state of the given class instance.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method query {what args} {
    return [my Command query $what {*}$args]
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test query-1.0 {
    Query the domains in the harness
} -setup {
} -cleanup {
} -body {
    ::apptest query domains
} -result {bookstore}
----

[source,tcl]
----
<<exported tests>>=
test query-1.1 {
    Query the domain operations in the bookstore domain
} -setup {
} -cleanup {
} -body {
    set ops [::apptest query operations bookstore]
} -result {changeSelectionQuantity init}
----

[source,tcl]
----
<<exported tests>>=
test query-1.2 {
    Query the domain operation parameters for changeSelectionQuantity
} -setup {
} -cleanup {
} -body {
    set ops [::apptest query doparams bookstore changeSelectionQuantity]
} -result {cartID MRT_InstId productID MRT_InstId quantity unsigned}
----

[source,tcl]
----
<<exported tests>>=
test query-2.0 {
    Query the classes in the bookstore domain
} -setup {
} -cleanup {
} -body {
    set classes [lsort [::apptest query classes bookstore]] ; # <1>
    return [lindex $classes 0]
} -result {Artist}
----
<1> Just pick off the first name, alphabetically, to test against.

[source,tcl]
----
<<exported tests>>=
test query-2.1 {
    Query the attributes of the Artist class
} -setup {
} -cleanup {
} -body {
    ::apptest query attributes bookstore Artist
} -result {artistName}
----

[source,tcl]
----
<<exported tests>>=
test query-2.2 {
    Query the instances of the Artist class
} -setup {
} -cleanup {
} -body {
    ::apptest query instances bookstore Artist
} -result {total 2 named {fs 1 mj 0}}
----

[source,tcl]
----
<<exported tests>>=
test query-3.0 {
    Query the states of the ShoppingCart class
} -setup {
} -cleanup {
} -body {
    ::apptest query states bookstore ShoppingCart
} -result {@ NewOrder AddingSelectiontoOrder CancelingEntireOrder\
        EstablishingCustomerandVerifyingPayment}
----

[source,tcl]
----
<<exported tests>>=
test query-4.0 {
    Query the events of the ShoppingCart class
} -setup {
} -cleanup {
} -body {
    ::apptest query events bookstore ShoppingCart
} -result {addSelection cancel checkOut startCart}
----

[source,tcl]
----
<<exported tests>>=
test query-4.1 {
    Query the event parameters of the startCart event
} -setup {
} -cleanup {
} -body {
    ::apptest query evparams bookstore ShoppingCart startCart
} -result {productID {char const *} quantity unsigned}
----

[source,tcl]
----
<<exported tests>>=
test query-5.0 {
    Query the current state of an instance
} -setup {
} -cleanup {
} -body {
    ::apptest query current bookstore Warehouse acme
} -result {WaitingforaShipment}
----

== Operations on Domains

=== Domainop

(((rein,method,domainop)))

*****
_reinobj_ `domainop` _operation ?arg1 arg2 ...?_

`operation`::
    The name of the domain operation to invoke.
`argN`::
    An argument to the domain operations. The order of the arguments
    must be the same as that defined for the given domain operation.

The `domainop` method invokes a domain operation on a domain.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method domainop {domain opname args} {
    return [my Command domainop $domain $opname {*}$args]
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test domainop-1.0 {
    Initialize the bookstore domain
} -setup {
} -cleanup {
} -body {
    ::apptest domainop bookstore init
} -result {}
----

== Operations on Class Instances

=== Create

(((rein,method,create)))

*****
_reinobj_ `create` _domain class_

`domain`::
    The name of the domain containing the class.
`class`::
    The name of the class of the instance to be create.

The `create` method creates an instance of the given class and returns
a integer identifier for the instance.
The identifying number is unique only within the class.

*N.B.*
that the instance is created in an uninitialized state and it is
necessary to follow up with invocation of the `update` method on the
instance to initialize it attributes.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method create {domain class} {
    return [my Command create $domain $class]
}
----

=== Delete

(((rein,method,delete)))

*****
_reinobj_ `delete` _domain class inst_

`domain`::
    The name of the domain containing the instance.
`class`::
    The name of the class to which the instance belongs.
`inst`::
    The integer identifier of the instance.
    Pre-existing instances may use the instance name for this field.

The `delete` method deletes the given instance.

*N.B.*
Deleting an instance often causes a referential integrity problem that
my create a fatal error when the next thread of control is finished.
In general,
it is not safe to delete arbitrary instances and there is no mechanism
provide to manipulate relationship instances in the harnessed domains.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method delete {domain class inst} {
    return [my Command delete $domain $class $inst]
}
----

=== Read

(((rein,method,read)))

*****
_reinobj_ `read` _domain class inst _?attr1 attr2 ...?_

`domain`::
    The name of the domain in which the instance is defined.
`class`::
    The name of the class to which the instance belongs.
`inst`::
    The name or ID number of the class instance to read.
`attrN`::
    The name of the attribute to whose value is returned.
    If no attribute names are given, then the return value is a list
    of alternating attribute name / attribute value elements.
    Otherwise, only the named attribute values are returned as
    name / value elements.

The `read` method reads the values of attributes from classes in a domain.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method read {domain class inst args} {
    return [my Command read $domain $class $inst {*}$args]
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test read-1.0 {
    Read the value of the product ID for the XUML book.
} -setup {
} -cleanup {
} -body {
    ::apptest read bookstore Product mbxuml productID
} -result {productID 14387}
----

=== Update

(((rein,method,update)))

*****
_reinobj_ `update` _domain class inst _?attr1 value1 attr2 value2 ...?_

`domain`::
    The name of the domain in which the instance is defined.
`class`::
    The name of the class to which the instance belongs.
`inst`::
    The name or ID number of the class instance to read.
`attrN`::
    The name of the attribute to whose value is to be updated..
`valueN`::
    The corresponding value that is to be updated into the attribute.

The `update` method updates the values of attributes of classes in a domain.
The attribute names and values are given in pairs as arguments to the
method.
Note that multiple attributes may be updated in a single invocation of the
method.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method update {domain class inst args} {
    return [my Command update $domain $class $inst {*}$args]
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test update-1.0 {
    Update the value of the email of the mjb author
} -setup {
} -cleanup {
} -body {
    ::apptest update bookstore Author mjb email mjb@gmail.com
} -result {email mjb@gmail.com}
----

== Signaling Events

One of the primary ways to cause a domain to react is to signal
events to the class instances.
Both immediate and delayed signaling is supported.

=== Signal

(((rein,method,signal)))

*****
_reinobj_ `signal` _domain class inst event ?param1 param2 ...?_

`domain`::
    The name of the domain to which the signaled instance belongs.
`class`::
    The name of the class to which the signaled instance belongs.
`inst`::
    The integer identifier or name of the instance to signal.
`event`::
    The name of the event to signal.
`paramN`::
    Parameters of the event. Parmeters must be given in the same order
    as defined for the event or start into which the event causes
    a transition.

The `signal` method signals an event to a class instance.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method signal {domain class inst event args} {
    return [my Command signal $domain $class $inst $event {*}$args]
}
----

=== Delayed Signal

(((rein,method,delaysignal)))

*****
_reinobj_ `delaysignal` _domain class inst delay event ?param1 param2 ...?_

`domain`::
    The name of the domain to which the signaled instance belongs.
`class`::
    The name of the class to which the signaled instance belongs.
`inst`::
    The integer identifier or name of the instance to signal.
`delay`::
    The minimum number of milliseconds that are to elapse before the
    event is signaled.
    A delay value of 0 results in the event being signaled immediately.
`event`::
    The name of the event to signal.
`paramN`::
    Parameters of the event. Parmeters must be given in the same order
    as defined for the event or start into which the event causes
    a transition.

The `delaysignal` method signals an event to a class instance at some
time in the future.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method delaysignal {domain class inst delay event args} {
    return [my Command signal $domain $class $inst $delay $event {*}$args]
}
----

=== Cancel Signal

(((rein,method,cancel)))

*****
_reinobj_ `cancel` _domain class inst event_

`domain`::
    The name of the domain of the instance whose event is to be canceled.
`class`::
    The name of the class of the instance whose event is to be canceled.
`inst`::
    The instance identifier or instance name whose event is to be canceled.
`event`::
    The name of the event to cancel.

The `cancel` method requests an delayed signal be canceled.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method cancel {domain class inst event} {
    return [my Command cancel $domain $class $inst $event]
}
----

=== Remaining Delay for a Signal

(((rein,method,remaining)))

*****
_reinobj_ `remaining` _domain class inst event_

`domain`::
    The name of the domain for the instance whose remaining time is requested.
`class`::
    The name of the class of the instance whose remaining time is requested.
`inst`::
    The instance identifier or instance name remaining time is requested.
`event`::
    The name of the event for which the remaining delay time is requested.

The `remaining` method returns the number of milliseconds before the
event is to be signaled.
A return value of 0, implies that either the event has already been
signaled or the delayed event did not exist.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method remaining {domain class inst event} {
    return [my Command remaining $domain $class $inst $event]
}
----

=== Create async

(((rein,method,createasync)))

*****
_reinobj_ `createasync` _domain class event ?param1 param2 ...?_

`domain`::
    The name of the domain in which the class resides.
`class`::
    The name of the class for which an instance is to be created.
`event`::
    The name of the creation event to be signaled.
`paramN`::
    The event parameters for the creation event.

The `createasync` method creates a class instance asynchronously by
signaling a creation event.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method createasync {domain class event args} {
    return [my Command createasync $domain $class $event {*}$args]
}
----

== Controlling Execution

The test harness generated by `bosal` makes extensive use of the
means provided by the `micca` run-time code to control the event
loop.
The `micca` run-time code allows the dispatch of individual events,
an entire thread of control and exiting the event event loop.
In addition, the test harness installs its own fatal condition handler
to prevent the harness program from exiting if a fatal error condition
arises.

=== Event Loop

(((rein,method,eloop)))

*****
_reinobj_ `eloop` _?run | halt | once | toc ?wait | nowait? ?_

With no arguments the `eloop` command returns the current state of the
event loop, either *running* or *halted*.

An additional argument may be given to control the state of the event loop.

run::
    Start running the event loop. Returns *running*
halt::
    Halt the dispatching of events. Returns *halted*.
once::
    Dispatch one event from the event loop. Return *true* if the event
    was dispatched and *false* if no event was awaiting dispatch.
toc ?wait | nowait?::
    Dispatch one thread of control. If *wait* is specified (or if no
    additional option is given), then the event loop will wait until
    a thread of control event arrives.
    If *nowait* is given and if there is no pending thread of control
    event, the command returns immediately.
    Returns *true* if a thread of control was dispatched and *false*
    otherwise.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method eloop {args} {
    return [my Command eloop {*}$args]
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test eloop-1.0 {
    Query execution state
} -setup {
} -cleanup {
} -body {
    ::apptest eloop
} -result {running}
----

[source,tcl]
----
<<exported tests>>=
test eloop-2.0 {
    Halt execution
} -setup {
} -cleanup {
} -body {
    ::apptest eloop halt
} -result {halted}
----

[source,tcl]
----
<<exported tests>>=
test eloop-3.0 {
    Dispatch an event
} -setup {
} -cleanup {
    ::apptest eloop run ; # set things back to running for later
} -body {
    ::apptest eloop once
} -result {false}
----

== State Machine Traces

For programs that use state machines that operate in a callback manner,
a chronological trace of the dispatched events is essential to
effective debugging.
The `micca` run-time code can produce this trace and the `bosal`
generated harness formats and transmits the trace information.

In `mecate`,
we have three points of control over state machine traces.

. Tracing can be turned on or off. If not needed then the traces
can be turned off.
. Synchronzing test execution with a state machine trace.
Facilities are provided to suspend a test's execution until either
a given trace is received or a timeout occurs.
. Trace accumulation and formatting.
All traces can be accumulated, saved and formatted into human readable
strings.

*N.B.* that tracing can be compiled out of the `micca` generated code.
If an object file obtained by compiling the domain code file with the
pre-processor symbol, `MRT_NO_TRACE`, defined is linked into a
test harness,
then no trace information will be available for that domain.

=== Trace

(((rein,method,trace)))

*****
_reinobj_ `trace` _?on | off?_

`on | off`::
    Turn tracing either *on* or *off*. If neither *on* or *off* is given,
    then the command returns the current state of tracing.

The `trace` method controls whether state machine dispatch traces
are output from the test harness and accumulated by `mecate`.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method trace {args} {
    return [my Command trace {*}$args]
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test trace-1.0 {
    Query tracing
} -setup {
} -cleanup {
} -body {
    ::apptest trace
} -result {off}
----

[source,tcl]
----
<<exported tests>>=
test trace-1.1 {
    Turn tracing on
} -setup {
} -cleanup {
} -body {
    ::apptest trace on
} -result {on}
----

[source,tcl]
----
<<exported tests>>=
test trace-1.2 {
    Turn tracing off
} -setup {
} -cleanup {
} -body {
    ::apptest trace off
} -result {off}
----

=== Wait for Event Trace

A common test sequence is to signal an event and then examine the
attributes of a class after the event has been dispatched.
This implies that it is necessary to know when the event has been dispatched.
We want to suspend test execution until the effect of signaling the
event has happened so we can stay synchronized to the test harness
execution.

To accomplish this,
each state machine event trace that is received by `mecate`
is placed in a queue that is used as a cache for the traces.
The test code may then examine the traces in the queue and if a match is
found, know that event has been dispatched.
If no match is found in the cache of traces,
then it is necessary to wait for other traces to arrive,
assuming the matching event dispatch happens in the future.

(((rein,method,waitForEventTrace)))

*****
_reinobj_ `waitForEventTrace` _?field1 pattern1 field2 pattern2?_

`fieldN`::
    The name of a field of the event trace. Valid field names are:
    `type`:::
        The type of the transition.
        The value of the type field is either *transition*, *polymorphic*,
        or *creation*.
    `event`:::
        The name of the event.
    `source`:::
        The class instance that signaled the event.
    `target`:::
        The class instance that received the event.
    `time`:::
        A timestamp of when the event was dispatched.

+
For *transition* type events, the following fields are also available:

    `currstate`:::
        The name of the state before the event dispatch.
    `newstate`:::
        The new of the state after the event dispatch.
        If this field is `IG`, the event was ignored.
        If this field is `CH`, the event caused an error condition.

+
For *polymorphic* type events, the following fields are also available:

    `relationship`:::
    The name of the generalization relationships across which the
    polymorphic event is inherited.
    `newevent`:::
    The new name the event has in the context of the next level of the
    generalization.
    `subclass`:::
    The name of the subclass to which the superclass instance was
    related when the polymorphic event was dispatched.

+
For *creation* type events, there are no additional fields.

`patternN`::
    The corresponding pattern to match for the given key.
    Patterns may be of any form accepted by the `string match` command.

The `waitForEventTrace` method examines the cache of state machine event traces
in chronological order searching for a match to the field / pattern pairs given.
Any trace that does not match is discarded from the cache.
If necessary, execution of the test is suspended until a state machine
trace matching the given parameters arrives or a timeout occurs.
Matching multiple fields is conjunctive in nature,
_i.e._ if multiple fields are given, then _all_ fields must match to consider
the event trace to be a match.

The method returns the matching state machine trace.
If a timeout occurs, then the string `TIMEOUT` is returned.
If a fatal error occurs, then the string `FATAL` is returned.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method waitForEventTrace {args} {
    variable tracesReceived
    variable traceSyncVar

    set expect $args
    while {true} {
        while {[$tracesReceived size] != 0} {
            set actual [$tracesReceived get]

            if {[my MatchTrace $actual $expect]} {
                return $actual
            } else {
                log::notice "discarding trace, \"$actual\":\
                        failed to match, \"$expect\""
            }
        }

        set timer [after $timeout [mymethod TraceTimeout]]
        vwait [self namespace]::traceSyncVar
        if {$traceSyncVar eq "TIMEOUT"} {
            error "timed out on receiving event traces"
        } elseif {$traceSyncVar eq "FATAL"} {
            error "fatal run-time error"
        } else {
            after cancel $timer
        }
    }
}
----

=== Clear the Event Trace Cache

(((rein,method,clearEventTraceCache)))

*****
_reinobj_ `clearEventTraceCache`

The `clearEventTraceCache` method deletes any accumulated state machine
event traces contained in the event trace cache.
All future attempts to match an event trace will operate only against
those traces received after this method was invoked.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method clearEventTraceCache {} {
    variable tracesReceived
    while {[$tracesReceived size] != 0} {
        $tracesReceived get
    }
    return
}
----

=== Format Event Traces

(((rein,method,formatEventTraces)))

*****
_reinobj_ `formatEventTraces` _?begin finish?_

`begin`::
    An optional number giving the starting trace to include in the output.
    If missing, then `begin` is taken as 1, the first trace accumulated.
`finish`::
    An optional number giving the last trace to include in the output.
    If missing, then `finish` is taken as the last trace accumulated.

The `formatEventTraces` method returns a string containing a human readable
print out of the received traces.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method formatEventTraces {{begin 1} {finish end}} {
    if {$begin == 1 && $finish eq "end"} {                  ; #  <1>
        set traces [relvar set Trace]
    } else {
        set traces [relation restrictwith $Trace\
                {$TraceId >= $begin && $TraceId <= $finish}]
    }
    set traces [pipe {
        rvajoin $traces [relvar set TransitionTrace] Transition |
        rvajoin ~ [relvar set PolymorphicTrace] Polymorphic |
        rvajoin ~ [relvar set CreationTrace] Creation
    }]                                                      ; # <2>

    set listing [list]                                      ; # <3>
    relation foreach trace $traces -ascending TraceId {
        relation assign $trace
        set line {}
        append line [format "% 3u " $TraceId]
        if {[relation isnotempty $Transition]} {
            relation assign $Transition Current New

            append line [format\
                "%s: Transition: %s - %s -> %s: %s ==> %s"\
                $Time $Source $Event $Target $Current $New\
            ]
        } elseif {[relation isnotempty $Polymorphic]} {
            relation assign $Polymorphic Relationship NewEvent Subclass

            append line [format\
                "%s: Polymorphic: %s - %s -> %s: %s - %s -> %s"\
                $Time $Source $Event $Target $Relationship $NewEvent $Subclass\
            ]
        } elseif {[relation isnotempty $Creation]} {
            append line [format\
                "%s: Creation: %s - %s -> %s"\
                $Time $Source $Event $Target\
            ]
        }

        lappend listing $line
    }

    return [join $listing "\n"]
}
----
<1> First, we need to select the traces that have been requested.
The default arguments select all of the traces.
Otherwise, we need to find the requested subset.
<2> This query joins the selected traces with the three subclasses of
traces based on the trace type.
Because of the properties of a _partition constraint_ exactly one
of the relation valued attributes from the `rvajoin` operations
(_i.e._ either *Transition*, *Polymorphic*, or *Creation*)
will be non-empty and the non-empty attribute will contain exactly one tuple.
This is just a convenient way to deal with the navigation of the
partition constraint.
<3> The strategy is to accumulate each formatted trace into a list and
then join the list elements to create a printable string.

=== Discard Event Traces

(((rein,method,discardEventTraces)))

*****
_reinobj_ `discardEventTraces`

The `discardEventTraces` method deletes the set of accumulated event
traces.
*****

[source,tcl]
.Implementation
----
<<rein configuration>>=
method discardEventTraces {} {
    variable traceId
    set traceId 0                   ; # <1>
    relvar eval {
        relvar set Trace [relation empty [relvar set Trace]]
        relvar set TransitionTrace [relation empty [relvar set TransitionTrace]]
        relvar set PolymorphicTrace [relation empty [relvar set PolymorphicTrace]]
        relvar set CreationTrace [relation empty [relvar set CreationTrace]]
    }                               ; # <2>
    return
}
----
<1> Event trace numbering is also reset.
<2> Clearing the trace relvars must be done in a transaction because of
the *R1* partition constraint.

== Instrumentation Traces

In addition to event traces,
`micca` domains produce instrumentation traces.
During code generation,
`micca` inserts trace statements into state activities and other functions.
The traces statements are actually ``C'' pre-processor macros which,
by default, resolve to a trace of the function name, file and line number.
This gives a record which functions in the the domain are executed.
In addition, the `MRT_DEBUG` macro is available to activities which
has the same interface as `printf()`.

In a test harness,
the instrumentation output is directed to the harness communications
port and the methods in this section define the operations that
can be applied to instrumentation traces.

=== Instr

(((rein,method,instr)))

The `instr` method controls whether instrumentation traces
are output from the test harness and accumulated.

[source,tcl]
.Implementation
----
<<rein configuration>>=
method instr {args} {
    return [my Command instr {*}$args]
}
----

[source,tcl]
.Tests
----
<<exported tests>>=
test instr-1.0 {
    Query instrumentation
} -setup {
} -cleanup {
} -body {
    ::apptest instr
} -result {off}
----

=== Wait for Instrumentation Trace

(((rein,method,waitForInstrTrace)))

The `waitForInstrTrace` method suspends execution until a instrumentation
trace matches the given parameters or a timeout occurs.

[source,tcl]
.Implementation
----
<<rein configuration>>=
method waitForInstrTrace {args} {
    variable instrReceived
    variable instrSyncVar

    set expect $args
    while {true} {
        while {[$instrReceived size] != 0} {
            set actual [$instrReceived get]

            if {[my MatchTrace $actual $expect]} {
                return $actual
            } else {
                log::notice "discarding trace, \"$actual\":\
                        failed to match, \"$expect\""
            }
        }

        set timer [after $timeout [mymethod InstrTimeout]]
        vwait [self namespace]::instrSyncVar
        if {$instrSyncVar eq "TIMEOUT"} {
            error "timed out on receiving event traces"
        } elseif {$instrSyncVar eq "FATAL"} {
            error "fatal run-time error"
        } else {
            after cancel $timer
        }
    }
}
----

=== Clear the Instrumentation Trace Cache

(((rein,method,clearInstrTraceCache)))

The `clearInstrTraceCache` method deletes any accumulated state machine
event traces.

[source,tcl]
.Implementation
----
<<rein configuration>>=
method clearInstrTraceCache {} {
    variable instrReceived
    while {[$instrReceived size] != 0} {
        $instrReceived get
    }
}
----

=== Format Instrumentation Traces

(((rein,method,formatInstrTraces)))

The `formatInstrTraces` method returns a string containing a human readable
print out of the received traces.

[source,tcl]
.Implementation
----
<<rein configuration>>=
method formatInstrTraces {{begin 0} {finish end}} {
    if {$begin == 0 && $finish eq "end"} {
        set instrs [relvar set Instrumentation]
    } else {
        set instrs [relation restrictwith $Instrumentation\
                {$InstrId >= $begin && $InstrId <= $finish}]
    }

    set listing [list]
    relation foreach instr $instrs -ascending InstrId {
        relation assign $instr
        lappend listing [format "% 3u %s: %s" $InstrId $Time $Message]
    }

    return [join $listing "\n"]
}
----

=== Discard Instrumentation Traces

(((rein,method,discardInstrTraces)))

The `discardInstrTraces` method ...

[source,tcl]
.Implementation
----
<<rein configuration>>=
method discardInstrTraces {} {
    variable instrId
    set instrId 0
    relvar eval {
        relvar set Instrumentation [relation empty [relvar set Instrumentation]]
    }
    return
}
----

=== Save Traces

(((rein,method,saveTraces)))

The `saveTraces` method ...

[source,tcl]
.Implementation
----
<<rein configuration>>=
method saveTraces {file {how ral}} {
    switch -exact -- $how {
        ral {
            serializeToFile $file [self namespace]::*
        }
        sqlite {
            storeToSQLite $file [self namespace]::*
        }
        default {
            error "unknown trace file type, \"$how\""
        }
    }
    return
}
----

== Unexported Methods

=== Command [[command-method]]

(((rein,method,command)))

The `command` method sends the harness program a `harness` command
and waits for the response.

.Implementation
----
<<rein configuration>>=
method Command {args} {
    variable cmdPattern
    variable timeout
    set cmdPattern [dict create\
        name [lindex $args 0]\
        timer [after $timeout [mymethod CmdTimeout]]
    ]
    my Puts $args

    set response [my WaitForCmdResponse]
    set result [dict get $response result]
    if {[dict get $response status] eq "error"} {
        error $result
    }
    return $result
}
method HandleCmdResponse {respValue} {
    variable cmdPattern

    set expectedName [dict get $cmdPattern name]
    set recvdName [dict get $respValue name]

    if {[string match $expectedName $recvdName]} {
        my SignalCmdResponse $respValue
    } else {
        log::error "expected response to $expectedName command,\
                got response to $recvdName command"
        my SignalCmdResponse ERROR
    }
}
method CmdTimeout {} {
    set [self namespace]::cmdSyncVar TIMEOUT
}
method SignalCmdResponse {value} {
    set [self namespace]::cmdSyncVar $value
}
method WaitForCmdResponse {} {
    variable cmdPattern
    variable cmdSyncVar
    vwait [self namespace]::cmdSyncVar

    if {$cmdSyncVar eq "TIMEOUT"} {
        error "timeout for command, \"[dict get $cmdPattern name]\""
    } elseif {$cmdSyncVar eq "FATAL"} {
        error "fatal run-time error while executing,\
                \"[dict get $cmdPattern name]\""
    } else {
        after cancel [dict get $cmdPattern timer]
    }

    if {[dict get $cmdSyncVar name] ne [dict get $cmdPattern name]} {
        error "expected response for command, \"[dict get $cmdPattern name]\",\
                got, \"[dict get $cmdSyncVar name]\""
    }
    return $cmdSyncVar
}
----

[source,tcl]
----
<<rein configuration>>=
method Puts {cmd} {
    log::debug "harness command: \"$cmd\""
    puts $connection $cmd
}

method HandleHarnessInput {} {
    set line {}
    for {set gotline false} {!$gotline} {set gotline [string is list $line]} {
        set llen [chan gets $connection input]
        if {$llen == -1} {
            if {[chan eof $connection]} {
                log::warn "EOF on harness input -- closing \"$connection\""
                chan close $connection
                unset -nocomplain connection
                return
            } elseif {[chan blocked $connection]} {
                log::notice "partial line received"
            }
        } else {
            append line $input
        }
    }

    if {[string length $line] != 0} {
        log::debug "harness response: \"$line\""

        lassign $line resp_type resp_value

        switch -exact -- $resp_type {
            cmd {
                my HandleCmdResponse $resp_value
            }
            trace {
                my HandleTraceResponse $resp_value
            }
            fatal {
                my HandleFatalResponse $resp_value
            }
            instr {
                my HandleInstrResponse $resp_value
            }
            default {
                error "unknown response type, \"$resp_value\""
            }
        }
    }
}
----

[source,tcl]
----
<<rein data structures>>=
relvar create Trace {
    TraceId     int
    Time        string
    Event       string
    Source      string
    Target      string
} TraceId

relvar create TransitionTrace {
    TraceId     int
    Current     string
    New         string
} TraceId

relvar create PolymorphicTrace {
    TraceId         int
    Relationship    string
    NewEvent        string
    Subclass        string
} TraceId

relvar create CreationTrace {
    TraceId         int
} TraceId

relvar partition R1 Trace TraceId\
    TransitionTrace TraceId\
    PolymorphicTrace TraceId\
    CreationTrace TraceId
----

[source,tcl]
----
<<rein configuration>>=
method HandleTraceResponse {respValue} {
    variable tracesReceived

    $tracesReceived put $respValue
    set [namespace current]::traceSyncVar TRACE

    variable traceId

    relvar eval {
        incr traceId
        relvar insert Trace [list\
            TraceId     $traceId\
            Time        [dict get $respValue time]\
            Event       [dict get $respValue event]\
            Source      [dict get $respValue source]\
            Target      [dict get $respValue target]\
        ]

        switch -exact -- [dict get $respValue type] {
            transition {
                relvar insert TransitionTrace [list\
                    TraceId     $traceId\
                    Current     [dict get $respValue currstate]\
                    New         [dict get $respValue newstate]\
                ]
            }
            polymorphic {
                relvar insert PolymorphiceTrace [list\
                    TraceId         $traceId\
                    Relationship    [dict get $respValue relationship]\
                    NewEvent        [dict get $respValue newevent]\
                    Subclass        [dict get $respValue subclass]\
                ]
            }
            creation {
                relvar insert CreationTrace [list\
                    TraceId     $traceId\
                ]
            }
            default {
                log::error "unknown state machine trace type,\
                        \"[dict get $respValue type]\""
            }
        }
    }
}
----

[source,tcl]
----
<<rein configuration>>=
method TraceTimeout {} {
    set [self namespace]::traceSyncVar TIMEOUT
}
----

[source,tcl]
----
<<rein data structures>>=
relvar create Instrumentation {
    InstrId     int
    Time        string
    Message     string
} InstrId
----

[source,tcl]
----
<<rein configuration>>=
method HandleInstrResponse {respValue} {
    variable instrReceived

    $instrReceived put $respValue
    set [self namespace]::instrSyncVar INSTR

    variable instrId
    incr instrId

    relvar insert Instrumentation [list\
        InstrId     $instrId\
        Time        [dict get $respValue time]\
        Message     [dict get $respValue message]\
    ]
}
----

[source,tcl]
----
<<rein configuration>>=
method InstrTimeout {} {
    set [self namespace]::instrSyncVar TIMEOUT
}
----

=== Matching Trace Data

(((rein,method,MatchTrace)))

The `MatchTrace` method compares a trace against a pattern and
determines if there is a match.

[source,tcl]
.Implementation
----
<<rein configuration>>=
method MatchTrace {trace pattern} {
    set matchCount 0
    dict for {key value} $pattern {
        if {[dict exists $trace $key] &&\
                [string match $value [dict get $trace $key]]} {
            incr matchCount
        }
    }

    return [expr {$matchCount == [dict size $pattern] ? "true" : "false"}]
}
----

[source,tcl]
----
<<rein configuration>>=
method HandleFatalResponse {respValue} {
    log::error "fatal error response, \"$respValue\""
    set [self namespace]::cmdSyncVar FATAL
    set [self namespace]::traceSyncVar FATAL
    error $respValue
}
----

== Bookstore Execution Scenarios

[source,tcl]
----
<<scenario tests>>=
test scenario-0.1 {
    Start session with bookstore domain
} -setup {
} -cleanup {
} -body {
    ::apptest disconnect
    ::apptest clearEventTraceCache
    ::apptest clearInstrTraceCache
    after 500
    ::apptest start ./bstore_harness
    ::apptest connect
    ::apptest instr on
    ::apptest trace on
} -result {on}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-1.0 {
    Create a shopping cart asynchronously
} -setup {
    set prodattr [::apptest read bookstore Product mbxuml productID]
    set prodid [dict get $prodattr productID]
} -cleanup {
} -body {
    set cartid [::apptest createasync bookstore ShoppingCart\
            startCart $prodid 1]
    ::apptest waitForEventTrace\
            type transition\
            target ShoppingCart.$cartid\
            newstate AddingSelectiontoOrder
    return $cartid
} -result {0}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-1.1 {
    Cancel order by changing quantity to 0.
} -setup {
    set prodinsts [::apptest query instances bookstore Product]
    set mbxumlinst [dict get $prodinsts named mbxuml]
} -cleanup {
} -body {
    ::apptest domainop bookstore changeSelectionQuantity\
        $cartid $mbxumlinst 0
    set trace [::apptest waitForEventTrace type transition event cancel\
            target ShoppingCart.$cartid]
    return [dict get $trace newstate]
} -result {CancelingEntireOrder}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-2.0 {
    Create a new shopping cart
} -setup {
    set prodattr [::apptest read bookstore Product mbxuml productID]
    set prodid [dict get $prodattr productID]
} -cleanup {
} -body {
    set cartid [::apptest createasync bookstore ShoppingCart\
            startCart $prodid 1]
    ::apptest waitForEventTrace\
            type transition\
            target ShoppingCart.$cartid\
            newstate AddingSelectiontoOrder
    return $cartid
} -result {1}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-2.1 {
    Buy three copies of the book
} -setup {
    set prodinsts [::apptest query instances bookstore Product]
    set mbxumlinst [dict get $prodinsts named mbxuml]
} -cleanup {
} -body {
    ::apptest domainop bookstore changeSelectionQuantity\
        $cartid $mbxumlinst 3
    set trace [::apptest waitForEventTrace type transition event changeQuantity\
            target ProductSelection.1]
    return [dict get $trace newstate]
} -result {ChangingQuantity}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-2.2 {
    Add some music to the shopping cart
} -setup {
    set prodattr [::apptest read bookstore Product cmc productID]
    set prodid [dict get $prodattr productID]
} -cleanup {
} -body {
    ::apptest signal bookstore ShoppingCart $cartid addSelection $prodid 2
    ::apptest waitForEventTrace\
            type transition\
            target ShoppingCart.$cartid\
            newstate AddingSelectiontoOrder
    return $cartid
} -result {1}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-2.3 {
    Checkout to buy selections
} -setup {
} -cleanup {
} -body {
    ::apptest signal bookstore ShoppingCart $cartid checkOut\
            "5555 6666 7777 8888"\
            "100 E Main St., Anywhere, CO 88888"\
            "9/11/2010"\
            "Fred Smith"\
            "fsmith@gmail.com"\
            "Fred Smith"\
            "222-555-1212"\
            "100 E Main St., Anywhere, CO 88888"
    set event [::apptest waitForEventTrace\
            type transition\
            source Warehouse.acme\
            target ShippingClerk.fs\
            newstate SelectingBooks]
    return [dict get $event newstate]
} -result {SelectingBooks}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-3.0 {
    Wait for order to be packed
} -setup {
} -cleanup {
} -body {
    set event [::apptest waitForEventTrace\
            type transition\
            target Warehouse.acme\
            currstate WaitingforaShipment\
            newstate IG]
    return [dict get $event newstate]
} -result {IG}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-4.0 {
    Wait for order to be delivered
} -setup {
} -cleanup {
} -body {
    set event [::apptest waitForEventTrace\
            type transition\
            target Order.0\
            newstate DeliveredtoCustomer]
    return [dict get $event newstate]
} -result {DeliveredtoCustomer}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-5.0 {
    Save traces
} -setup {
} -cleanup {
} -body {
    ::apptest saveTraces scenarios.ral
    ::apptest saveTraces scenarios.sqlite sqlite
} -result {}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-5.1 {
    Print traces
} -setup {
} -cleanup {
} -body {
    puts "***"
    puts "*** State Machine Event Traces"
    puts "***"
    puts [::apptest formatEventTraces]

    puts "***"
    puts "*** Instrumentation Traces"
    puts "***"
    puts [::apptest formatInstrTraces]
} -result {}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-5.2 {
    Discard event traces
} -setup {
} -cleanup {
} -body {
    ::apptest discardEventTraces
    ::apptest formatEventTraces
} -result {}
----

[source,tcl]
----
<<scenario tests>>=
test scenario-5.3 {
    Discard instrumentation traces
} -setup {
} -cleanup {
} -body {
    ::apptest discardInstrTraces
    ::apptest formatInstrTraces
} -result {}
----

== Code Organization

This section shows how the literate program chunks are organized into
source files.
There are several literate program *roots* in this document and each
is discussed in the sections below.

=== Source Code

The source code for the `mecate` package is shown below.

----
<<mecate.tcl>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
<<copyright info>>
#

package require Tcl 8.6
package require logger
package require ral
package require ralutil
package require oo::util
package require struct::queue

namespace eval ::mecate {
    namespace export rein
    namespace ensemble create

    logger::initNamespace [namespace current]

    variable version 0.2
}

<<mecate commands>>

package provide mecate $::mecate::version
----

=== Mecate Unit Tests

This unit tests cases included in this document are placed in a single
test file.

----
<<mecate.test>>=
#!/usr/bin/env tclsh
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
<<copyright info>>
#

package require Tcl 8.6
package require cmdline
package require logger
package require tcltest

source ../code/tcl/mecate.tcl

# Add custom arguments here.
set optlist {
    {level.arg warn {Log debug level}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

::mecate::log::setlevel $options(level)

tcltest::configure {*}$argv

namespace eval ::mecate::test {
    ::logger::initNamespace [namespace current]

    log::info "testing mecate version: [package require mecate]"

    namespace import ::tcltest::*
    namespace import ::ral::*
    namespace import ::ralutil::*

    <<test utilities>>
    <<constructor tests>>
    <<unexported tests>>
    <<exported tests>>
    <<scenario tests>>

    ::apptest destroy

    cleanupTests
}
----

----
<<test utilities>>=
# Utility proc to execute unexported methods.
proc objeval {obj args} {
    namespace eval [info object namespace $obj] {*}$args
}
----

=== Package Index

We also provide a root chunk to extract a package index file.

----
<<pkgIndex.tcl>>=
package ifneeded mecate 0.2 [list source [file join $dir mecate.tcl]]
----

=== Template

The following is a template that can be used to seed a unit test file
that uses `mecate`.

----
<<template-mecate.test>>=
# DO NOT EDIT THIS FILE!
# THIS FILE IS AUTOMATICALLY GENERATED FROM A LITERATE PROGRAM SOURCE FILE.
#
<<copyright info>>
#  *++
# MODULE:
#	unit test template
# ABSTRACT:
# 
#  *--
package require Tcl 8.6
package require cmdline
package require logger
package require tcltest
package require mecate

set optlist {
    {level.arg warn {Log debug level}}
    {program.arg {} {Name of test harness program}}
    {nostart {Don't start test harness program automatically}}
}
array set options [::cmdline::getKnownOptions argv $optlist]

::logger::setlevel $options(level)

tcltest::configure {*}$argv

namespace eval ::$options(program)::test {
    namespace import ::tcltest::*
    ::logger::initNamespace [namespace current] $::options(level)

    if {$options(program) eq {}} {
        error "no bosal test harness program name was supplied:\
                use \"-program <name>\" option"
    }

    mecate rein create ::apptest

    if {!$::options(nostart)} {
        apptest start
    }

    # Here you can set up any traces that are needed to keep track of the
    # state of instances or the values of variables.
    #
    # For example:
    #
    # ::apptest trace on
    # ::apptest instr on
    # ::apptest eloop halt  ; # Start halted so we can single step events.


    # Place your text cases here.
    #
    # For example:

    test init-1.0 {
        Initialize the domain
    } -setup {
    } -cleanup {
    } -body {
        ::apptest domainop MyDomain init
    } -result {}
    
    apptest destroy

    cleanupTests
}

if 0 {
    # This is just a template for additional tests.
    # You can copy it into your test set to save some typing.

    test X-1.0 {
    } -setup {
    } -cleanup {
    } -body {
    } -result {}
}
----

=== Copyright Information

----
<<copyright info>>=
# This software is copyrighted 2018 by G. Andrew Mangogna.
# The following terms apply to all files associated with the software unless
# explicitly disclaimed in individual files.
# 
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors and
# need not follow the licensing terms described here, provided that the
# new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING
# OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES
# THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
# OR MODIFICATIONS.
# 
# GOVERNMENT USE: If you are acquiring this software on behalf of the
# U.S. government, the Government shall have only "Restricted Rights"
# in the software and related documentation as defined in the Federal
# Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
# are acquiring the software on behalf of the Department of Defense,
# the software shall be classified as "Commercial Computer Software"
# and the Government shall have only "Restricted Rights" as defined in
# Clause 252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing,
# the authors grant the U.S. Government and others acting in its behalf
# permission to use and distribute the software in accordance with the
# terms specified in this license.
----
