// vim:set syntax=asciidoc:

== Model Class

The `model` class represents the population of the platform specific
model that is captured by `micca`.

(((command,model)))

[source,tcl]
----
<<miccautil commands>>=
::oo::class create ::miccautil::model {
    <<model class definition>>
}
----

The class command name is exported and the exported commands
of the `miccautil` namespace are used to create an ensemble command
of the same name.

[source,tcl]
----
<<package exports>>=
namespace export model
----

We will have need of a number of supporting packages.

[source,tcl]
----
<<required packages>>=
package require logger
package require logger::utils
package require logger::appender
package require ral
package require ralutil
----

The
http://repos.modelrealization.com/cgi-bin/fossil/tclral/wiki?name=Downloads[`ral` and `ralutil`]
packages are essential and hold the relational schema that is the platform
specific model.

=== Constructor

(((model,method,constructor)))

*****
`miccautil model create` _objname_ _savefile_

`miccautil model new` _savefile_

`savefile`::
    The name of a file saved from a micca run.
    This file should be saved in TclRAL native serialization.

The `create` and `new` methods create an instance of a `model` object.
The _savefile_ argument is mandatory and is the name of a file
produced by a run of `micca` with the `-save` option.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
constructor {savefile} {
    ::logger::import -all -namespace log miccautil

    namespace import ::ral::*
    namespace import ::ralutil::*

    ral deserializeFromFile $savefile [self namespace]

    set domains [pipe {
        relvar set Domain |
        relation project ~ Name |
        relation list ~
    }]

    if {[llength $domains] > 1} {
        error "micca save file must contain only one domain:\
                found, \"[join $domains ,]\""
    }

    my variable domain_name
    set domain_name [lindex $domains 0]
}
----

.Tests
[source,tcl]
----
<<constructor tests>>=
test constructor-1.0 {
    Create a model object for the sio domain
} -body {
    miccautil model create sio sio.ral

    relation cardinality [relvar set [info object namespace sio]::Domain]
} -result 1
----

[source,tcl]
----
<<constructor tests>>=
test constructor-2.0 {
    Create a model object for the aggrmgmt domain
} -body {
    miccautil model create aggrmgmt aggrmgmt.ral

    relation cardinality [relvar set [info object namespace aggrmgmt]::Domain]
} -result 1
----

=== Domain name method

(((model,method,domainName)))

*****
_modelobj_ domainName

Returns the name of the domain represented by _modelobj_.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method domainName {} {
    my variable domain_name

    return $domain_name
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test domainName-1.0 {
    Get the domain name
} -body {
    sio domainName
} -result sio
----

=== Class names

(((model,method,classes)))

*****
_modelobj_ classes

Returns a list of the names of the classes defined in the domain represented
by _modelobj_.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method classes {} {
    return [pipe {
        relvar set Class |
        relation project ~ Name |
        relation list
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test classes-1.0 {
    Get the list of classes
} -body {
    llength [sio classes]
} -result 24
----

=== State names

(((model,method,states)))

*****
_modelobj_ states _class_

class::
    The name of a class or assigner in the domain.

Returns a list of state names for _class_.
If _class_ does not exist in the domain or if class does not have a state model,
an empty list is returned.

A state name of, `@`, indicates the pseudo-initial state
from which creation events transition.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method states {class} {
    my variable domain_name

    return [pipe {
        relvar set StatePlace |
        relation restrictwith ~ {$Domain eq $domain_name && $Model eq $class} |
        relation project ~ Name |
        relation list
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test states-1.0 {
    Get the states for the Sample_Set class
} -body {
    llength [sio states Sample_Set]
} -result 4
----
[source,tcl]
----
<<method tests>>=
test states-1.1 {
    Get non-existent states
} -body {
    llength [sio states foobar]
} -result 0
----

=== Event names

(((model,method,events)))

*****
_modelobj_ events _class_

class::
    The name of a class or assigner in the domain.

Returns a list of event names for _class_.
If _class_ does not exist in the domain or if class does not have a state model
or any polymorphic events,
an empty list is returned.
The returned list includes the event names for any type of event that
the class may have.
For example,
a superclass may not have a state model, but could have polymorphic events
and these names would be returned.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method events {class} {
    my variable domain_name

    return [pipe {
        relvar set Event |
        relation restrictwith ~ {$Domain eq $domain_name && $Model eq $class} |
        relation project ~ Event |
        relation list
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test events-1.0 {
    Get the events for the Sample_Set class
} -body {
    llength [sio events Sample_Set]
} -result 4
----
[source,tcl]
----
<<method tests>>=
test events-1.1 {
    Get polymorphic events from a superclass
} -body {
    llength [aggrmgmt events Remote_Sensor]
} -result 3
----

=== State model transitions

(((domain,method,transitions)))

*****
_modelobj_ transitions _class_

class::
    The name of a class or assigner in the domain.

The `transitions` method returns a relation value that contains
a the values of all the state transitions for _class_.
The heading of the returned relation value is:

[width="75%",options="header",cols="6*^",grid="cols"]
|============
|Domain |Model  |State  |Event  |NewState   |Params
|string |string |string |string |string     |Relation
|============

where:

[horizontal]
*Domain*:: is the name of the domain.
*Model*:: is the name of the class or assigner.
*State*:: is the name of a state.
    A _State_ name of, `@`, indicates the pseudo-initial state out of
    which creation events transition.
*Event*:: is the name of an event which causes a transition out of _State_.
*NewState*:: The name of the state entered by the transition caused
    when _Event_ is received in _State_.
    A _NewState_ name of `IG` indicates the _Event_ is ignored when it
    is received in _State_.
    A _NewState_ name of `CH` indicates it is logically impossible to
    receive _Event_ in _State_ (_i.e._ _can't happen_) and at run time
    will cause a _panic_ condition.
*Params*:: is a relation valued attribute giving the parameters of _Event_.
    The cardinality of the _Params_ attribute is zero if the event
    carries no supplemental event parameters.
    _Params_ attribute has the heading:

[width="25%",options="header",cols="2*^",grid="cols"]
|============
|Name       |Position
|string     |int
|============

where:

[horizontal]
*Name*:: is the name of the parameter.
*Position*:: is the order of the parameter carried in _Event_.
    _Position_ values start at zero and increase monotonically for each tuple
    in _Params_.

The cardinality of the returned relation is _states_ times _events_ where
_states_ (including the pseudo-initial state if present)
is the number of states in the model and _events_ is the
number of events.
The cardinality of the returned relation is zero if the class has no
state model.

Each tuple in the returned relation represents a cell in a conceptual
_states_ by _events_ transition matrix with _NewState_ as the cell value.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method transitions {class_name} {
    my variable domain_name

    set sm [relvar restrictone StateModel Domain $domain_name Model $class_name]
    if {[relation isempty $sm]} {
        return [relation create {
            Domain string
            Model string
            State string
            Event string
            NewState string
            Params {Relation {Name string Position int}}
        }]
    }

    set tplaces [pipe {
        relvar set TransitionPlace |
        relation semijoin $sm ~
    }]
    # log::debug \n[relformat $tplaces tplaces]
    
    set statetrans [pipe {
        relation join $tplaces [relvar set StateTransition] |
        relation eliminate ~ ASigID |
        relation join ~ [relvar set StatePlace]\
            -using {Domain Domain Model Model NewState Name} |
        relation eliminate ~ Number
    }] ;                                                            # <1>
    # log::debug \n[relformat $statetrans statetrans]
    
    set nontrans [pipe {
        relation join $tplaces [relvar set NonStateTransition] |
        relation extend ~ ntup\
            NewState string {[tuple extract $ntup TransRule]} |
        relation eliminate ~ TransRule
    }] ;                                                            # <2>
    # log::debug \n[relformat $nontrans nontrans]


    set srcstates [pipe {
        relation semijoin $sm [relvar set StatePlace] |
        relation eliminate ~ Number |
        relation rename ~ Name State
    }]
    # log::debug \n[relformat $srcstates srcstates]

    set events [relation semijoin $sm [relvar set TransitioningEvent] ]
    # log::debug \n[relformat $events events]
    
    set defrule [relation extract $sm DefaultTrans]
    # log::debug "defrule = \"$defrule\""
    
    set deftrans [pipe {
        relation join $srcstates $events |
        relation minus ~ $tplaces |
        relation extend ~ dtup NewState string {$defrule} |
        relation update ~ ftup {[tuple extract $ftup State] eq "@"}\
            {tuple update $ftup NewState CH}
    }] ;                                                            # <3>
    # log::debug \n[relformat $deftrans deftrans]

    set params [pipe {
        relvar set Parameter |
        relation eliminate ~ ASigID
    }]
    set transmatrix [pipe {
        relation union $statetrans $nontrans $deftrans |
        relation join ~ [relvar set StatePlace]\
                -using {Domain Domain Model Model State Name} |
        relation eliminate ~ Number |
        relation join ~ [relvar set Event] |
        relation eliminate ~ Number |
        rvajoin ~ $params Params |
        relation eliminate ~ PSigID
    }]
    log::debug \n[relformat $transmatrix transmatrix]

    return $transmatrix
}
----
<1> These are the state transitions specified explicitly in the `micca` source
that cause transitions to actual states.
<2> These are the state transition specified explicitly in the `micca` source
that do not cause transitions since they are either ignored or an error
situation.
<3> These are the unspecified transitions which receive the default
transition.
Also note, that the pseudo-initial state has a fixed default transition
of `CH`.

.Tests
[source,tcl]
----
<<method tests>>=
test transitions-1.0 {
    Get the transitions for the Sample_Set class
} -body {
    set tm [sio transitions Sample_Set]
    relation cardinality $tm
} -result {16}
----

[source,tcl]
----
<<method tests>>=
test transitions-1.1 {
    Get the transitions for a class with no state model
} -body {
    set tm [sio transitions Point_Threshold]
    relation cardinality $tm
} -result {0}
----

[source,tcl]
----
<<method tests>>=
test transitions-2.0 {
    Get the transitions for the Conduit class
} -body {
    set tm [aggrmgmt transitions Conduit]
    relation cardinality $tm
} -result {66}
----

[source,tcl]
----
<<method tests>>=
test transitions-2.1 {
    Get the transition matrix for the Reporting Sensor class
} -body {
    set tm [aggrmgmt transitions Reporting_Sensor]
    relation cardinality $tm
} -result {90}
----

=== State model as graph

*****
_modelobj_ stateModelGraph _class_

The `stateModelGraph` method returns a _graph_ command from the `struct::graph`
package in Tcllib that represents the state model for _class_ as a graph.
It is the responsibility of the caller to insure that
the returned graph command is disposed of properly by invoking
_graph_ `destroy` when no longer needed.
If _class_ does not not have a state model,
the returned _graph_ has no nodes or arcs.

The returned graph is annotated by the following *key* / value attributes:

[horizontal]
*domain*:: the name of the domain.
*class*:: the name of the class or assigner.
*initialstate*:: the name of the default initial state.
*defaulttrans*:: the name of the default transition, _i.e._ `IG` or `CH`.

Nodes in the graph represent states in the state model and
are named the same as the state name.
Nodes are annotated by the following *key* / value attributes:

[horizontal]
*activity*:: the state activity code.
*final*:: a boolean value indicating if the state is a final state.

Arcs in the graph represent the directed transitions from a source state
to a target state.
Note that `IG` and `CH` transitions are _not_ represented by arcs since
as target states they do not cause an actual transition.
Arcs are annotated by the following *key* / value attributes:

[horizontal]
*event*:: the name of the event causing the transition.
*params*:: a list of event parameter names representing parameter values
    carried by the event.
*****

We need the `struct::graph` package from Tcllib and we want to make sure
that it is at least version 2 or higher.

[source,tcl]
----
<<required packages>>=
package require struct::graph 2
----

.Implementation
[source,tcl]
----
<<model class definition>>=
method stateModelGraph {class_name} {
    my variable domain_name
    set gr [::struct::graph]

    try {
        $gr set domain $domain_name
        $gr set class $class_name

        set smodel [relvar restrictone StateModel\
                Domain $domain_name Model $class_name]
        if {[relation isempty $smodel]} {
            $gr set initialstate {}
            $gr set defaulttrans {}
            return $gr
        }

        $gr set defaulttrans [relation extract $smodel DefaultTrans]

        set cr_state [pipe {
            relvar set CreationState |
            relation semijoin $smodel ~ |
            relation extend ~ cstup\
                    Activity string {{}}\
                    IsFinal boolean {false} |
            relation project ~ Name Activity IsFinal
        }]

        $gr set initialstate [expr {[relation isnotempty $cr_state] ?\
                "@" : [relation extract $smodel InitialState]}]

        set states [pipe {
            relvar set State |
            relation semijoin $smodel ~ |
            relation project ~ Name Activity IsFinal |
            relation union ~ $cr_state
        }]
        # log::debug \n[relformat $states states]

        relation foreach state $states {
            relation assign $state Name Activity IsFinal
            $gr node insert $Name
            $gr node set $Name activity $Activity
            $gr node set $Name final $IsFinal
        }

        set trans [pipe {
            my transitions $class_name |
            relation restrictwith ~ {$NewState ne "IG" && $NewState ne "CH"} |
            relation eliminate ~ Domain Model
        }]

        relation foreach tran $trans {
            relation assign $tran State Event NewState Params
            set arc [$gr arc insert $State $NewState]
            $gr arc set $arc event $Event
            $gr arc set $arc params\
                    [relation list $Params Name -ascending Position]
        }

        return $gr
    } on error {result opts} {
        $gr destroy
        return -options $opts $result
    }
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test stateModelGraph-1.0 {
    Get the state model graph for the Sample_Set class
} -body {
    set sample_set_graph [sio stateModelGraph Sample_Set]
    set nnodes [llength [$sample_set_graph nodes]]
    $sample_set_graph destroy
    return $nnodes
} -result {4}
----

[source,tcl]
----
<<method tests>>=
test stateModelGraph-1.1 {
    State model graph for class with not state model
} -body {
    set pt_graph [sio stateModelGraph Point_Threshold]
    set nnodes [llength [$pt_graph nodes]]
    $pt_graph destroy
    return $nnodes
} -result {0}
----

[source,tcl]
----
<<method tests>>=
test stateModelGraph-2.0 {
    Get the state model graph for the Conduit class
} -body {
    set conduit_graph [aggrmgmt stateModelGraph Conduit]
    set nnodes [llength [$conduit_graph nodes]]
    $conduit_graph destroy
    return $nnodes
} -result {11}
----

[source,tcl]
----
<<method tests>>=
test stateModelGraph-2.1 {
    Check the state model graph for the Conduit class
} -body {
    set conduit_graph [aggrmgmt stateModelGraph Conduit]
    set create_trans [$conduit_graph arcs -out @]
    set cr_event [$conduit_graph arc get $create_trans event]
    $conduit_graph destroy
    return $cr_event
} -result {Connect}
----

[source,tcl]
----
<<required packages>>=
package require struct::tree
package require lambda
----

[source,tcl]
----
<<method tests>>=
proc classifyTransitions {graph} {
    set nodes [$graph nodes]
    foreach node $nodes {
        $graph node set $node pre 0
        $graph node set $node rpost 0
    }
    variable preorder 1
    variable postorder [llength $nodes]
    classifyNode $graph [$graph get initialstate]
    return
}

proc classifyNode {graph node} {
    variable preorder
    $graph node set $node pre [set thisPre $preorder]
    incr preorder
    set arcList [$graph arcs -out $node]
        
    foreach arc $arcList {
        set succ [$graph arc target $arc]
        set succPre [$graph node get $succ pre]
        if {$succPre == 0} {
            $graph arc set $arc type tree
            classifyNode $graph $succ
        } elseif {[$graph node get $succ rpost] == 0} {
            $graph arc set $arc type back
        } elseif {$thisPre < $succPre} {
            $graph arc set $arc type frwd
        } else {
            $graph arc set $arc type cross
        }
    }
    variable postorder
    $graph node set $node rpost $postorder
    incr postorder -1

    return
}
----

[source,tcl]
----
<<method tests>>=
test stateModelGraph-2.2 {
    Check the state model graph for the Conduit class
} -cleanup {
    $conduit_graph destroy
} -body {
    set conduit_graph [aggrmgmt stateModelGraph Conduit]
    classifyTransitions $conduit_graph

    set dfsproc [lambda {action graph node} {
        foreach outarc [$graph arcs -out $node] {
            set target [$graph arc target $outarc]
            puts "$node - [$graph arc get $outarc event] -> $target\
                ==> [$graph arc get $outarc type]"
        }
    }]
    $conduit_graph walk [$conduit_graph get initialstate]\
        -order pre -type bfs -dir forward -command $dfsproc
} -result {}
----

=== State model with Tcldot

*****
_modelobj_ stateModelDot _class_

The `stateModelDot` method returns a
https://graphviz.org/pdf/tcldot.3tcl.pdf[`Tcldot`]
command handle to the state model graph of _class_.
The command handle can be used to render an image of
the state model graph using the
https://graphviz.org/doc/info/lang.html[`dot`]
program (along with many other uses).
*****

[source,tcl]
----
<<required packages>>=
package require Tcldot
----

.Implementation
[source,tcl]
----
<<model class definition>>=
method stateModelDot {class_name} {
    my variable domain_name

    set dot [dotnew digraph]
    try {
        set smodel [relvar restrictone StateModel\
                Domain $domain_name Model $class_name]
        if {[relation isempty $smodel]} {
            return $dot
        }

        $dot setnodeattributes shape box

        set cr_state [pipe {
            relvar set CreationState |
            relation semijoin $smodel ~ |
            relation extend ~ cstup IsFinal boolean {false} |
            relation project ~ Name IsFinal
        }]
        set states [pipe {
            relvar set State |
            relation semijoin $smodel ~ |
            relation project ~ Name IsFinal |
            relation union ~ $cr_state
        }]

        set node(@) [$dot addnode @ {*}{
            shape circle
            style filled
            fillcolor black
            label {}
            width 0.15
            fixedsize true
        }]

        set finals [relation restrictwith $states {$IsFinal}]
        if {[relation isnotempty $finals]} {
            set node(__x__) [$dot addnode __x__ {*}{
                shape doublecircle
                style filled
                fillcolor black
                label {}
                width 0.15
                fixedsize true
            }]
        }

        relation foreach state $states {
            relation assign $state
            if {$Name eq "@"} {
                continue
            }
            set node($Name) [$dot addnode $Name\
                label [string map {_ { }} $Name]\
            ]
            if {$IsFinal} {
                set edge($Name,__x__) [$dot addedge $node($Name) $node(__x__)]
            }
        }

        if {[relation isempty $cr_state]} {
            set initialstate [relation extract $smodel InitialState]
            set edge(@,$initialstate)\
                    [$dot addedge $node(@) $node($initialstate)]
        } ;                                                             # <1>

        set params [pipe {
            relvar set Parameter |
            relation eliminate ~ PSigID
        }]
        set statetrans [pipe {
            relvar set StateTransition |
            relation semijoin $smodel ~ |
            rvajoin ~ $params Params |
            relation eliminate ~ Domain Model ASigID
        }]

        relation foreach statetran $statetrans {
            relation assign $statetran
            set evt_label [string map {_ { }} $Event]
            if {[relation isnotempty $Params]} {
                append evt_label\
                    "("\
                    [join [relation list $Params Name -ascending Position] ,]\
                    ")"
            }
            set edge($State,$NewState) [$dot addedge\
                    $node($State) $node($NewState)\
                    label $evt_label
            ]
        }

        return $dot
    } on error {result opts} {
        rename $dot {}
        return -options $opts $result
    }
}
----
<1> If there is no creation state,
we connect the pseudo-initial state to the default initial state
with no event label.
This is a convenient indication of the default initial state.

.Tests
[source,tcl]
----
<<method tests>>=
test stateModelDot-1.0 {
    Get the dot graph for the Sample_Set class
} -cleanup {
    chan close $ss_file
    chan close $gv_file
    rename $sample_set_dot {}
} -body {
    set sample_set_dot [sio stateModelDot Sample_Set]

    set ss_file [open Sample_Set.pdf w]
    $sample_set_dot write $ss_file pdf

    set gv_file [open Sample_Set.gv w]
    $sample_set_dot write $gv_file dot

    $sample_set_dot countnodes
} -result {5}
----

image::Sample_Set.pdf[title="Sample Set state model rendered by dot"]

[source,tcl]
----
<<method tests>>=
test stateModelDot-2.0 {
    Get the dot graph for the Conduit class
} -cleanup {
    chan close $cond_file
    chan close $gv_file
    rename $conduit_dot {}
} -body {
    set conduit_dot [aggrmgmt stateModelDot Conduit]

    set cond_file [open Conduit.pdf w]
    $conduit_dot write $cond_file pdf

    set gv_file [open Conduit.gv w]
    $conduit_dot write $gv_file dot

    $conduit_dot countnodes
} -result {12}
----

image::Conduit.pdf[title="Conduit state model rendered by dot"]

[source,tcl]
----
<<method tests>>=
test stateModelDot-2.1 {
    Get the dot graph for the Discovered Sensor class
} -cleanup {
    chan close $ds_file
    chan close $gv_file
    rename $ds_dot {}
} -body {
    set ds_dot [aggrmgmt stateModelDot Discovered_Sensor]

    set ds_file [open Discovered_Sensor.pdf w]
    $ds_dot write $cond_file pdf

    set gv_file [open Discovered_Sensor.gv w]
    $ds_dot write $gv_file dot

    $ds_dot countnodes
} -result {13}
----

image::Discovered_Sensor.pdf[title="Discovered Sensor state model rendered by dot"]

== Logging

[source,tcl]
----
<<logger setup>>=
set logger [::logger::init miccautil]
set appenderType [expr {[dict exist [fconfigure stdout] -mode] ?\
        "colorConsole" : "console"}]
::logger::utils::applyAppender -appender $appenderType -serviceCmd $logger\
        -appenderArgs {-conversionPattern {\[%c\] \[%p\] '%m'}}
::logger::import -all -force -namespace log miccautil
----
