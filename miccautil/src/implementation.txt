// vim:set syntax=asciidoc:

== Preliminaries

We will have need of a number of supporting packages.

[source,tcl]
----
<<required packages>>=
package require logger
package require logger::utils
package require logger::appender
package require ral
package require ralutil
----

The
http://repos.modelrealization.com/cgi-bin/fossil/tclral/wiki?name=Downloads[`ral` and `ralutil`]
packages are essential and hold the relational schema that is the platform
specific model.
Several procedures in the package return relation values which can be
further manipulated using `ral` procedures.

We also need to configure the logger output.

[source,tcl]
----
<<logger setup>>=
set logger [::logger::init miccautil]
set appenderType [expr {[dict exist [fconfigure stdout] -mode] ?\
        "colorConsole" : "console"}]
::logger::utils::applyAppender -appender $appenderType -serviceCmd $logger\
        -appenderArgs {-conversionPattern {\[%c\] \[%p\] '%m'}}
::logger::import -all -force -namespace log miccautil
----

== The Model Class

The `model` class represents the population of the `micca` platform specific
model for a single domain.

(((command,model)))

[source,tcl]
----
<<miccautil commands>>=
::oo::class create ::miccautil::model {
    <<model class definition>>
}
----

The class command name is exported and the exported commands
of the `miccautil` namespace are used to create an ensemble command
of the same name.

[source,tcl]
----
<<package exports>>=
namespace export model
----

=== Constructor

(((model,method,constructor)))

*****
`::miccautil model create` _objname_ _savefile_

`::miccautil model new` _savefile_

[horizontal]
_objname_::
    The name of the command to be created which represents the model.
    The `new` version of the constructor creates a name automatically.
_savefile_::
    The name of a file saved from a micca run.
    This file should be saved in TclRAL native serialization format.

The `create` and `new` methods create an instance of a `model` object.
The _savefile_ argument is required and is the name of a file
produced by a run of `micca` with the `-save` option.
The return value of the function is a fully qualified command that
may be used with the methods given below.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
constructor {savefile} {
    ::logger::import -all -namespace log miccautil

    namespace import ::ral::*
    namespace import ::ralutil::*

    ral deserializeFromFile $savefile [self namespace]

    set domains [pipe {
        relvar set Domain |
        relation project ~ Name |
        relation list ~
    }]

    if {[llength $domains] > 1} {
        error "micca save file must contain only one domain:\
                found, \"[join $domains ,]\""
    }

    my variable domain_name
    set domain_name [lindex $domains 0]

    my variable recording_state
    set recording_state off
}
----

.Tests
[source,tcl]
----
<<constructor tests>>=
test constructor-1.0 {
    Create a model object for the sio domain
} -body {
    miccautil model create sio sio.ral

    relation cardinality [relvar set [info object namespace sio]::Domain]
} -result 1
----

[source,tcl]
----
<<constructor tests>>=
test constructor-2.0 {
    Create a model object for the aggrmgmt domain
} -body {
    miccautil model create aggrmgmt aggrmgmt.ral

    relation cardinality [relvar set [info object namespace aggrmgmt]::Domain]
} -result 1
----

=== Destructor

(((model,method,destructor)))

*****
_modelobj_ destroy

The `destroy` method is used to delete _modelobj_ when it is no longer needed.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
destructor {
    relvar constraint delete {*}[relvar constraint names [self namespace]::*]
    relvar unset {*}[relvar names [self namespace]::*]
}
----

.Tests
[source,tcl]
----
<<constructor tests>>=
test destructor-1.0 {
    Create a model object for the sio domain
} -setup {
    miccautil model create sio2 sio.ral
} -body {
    set ns [info object namespace sio2]
    sio2 destroy
    return [namespace exists $ns]
} -result 0
----

=== Domain name method

(((model,method,domainName)))

*****
_modelobj_ domainName

The `domainName` method returns the name of the domain represented by
_modelobj_.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method domainName {} {
    my variable domain_name

    return $domain_name
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test domainName-1.0 {
    Get the domain name
} -body {
    sio domainName
} -result sio
----

=== Class names

(((model,method,classes)))

*****
_modelobj_ classes

The `classes` method returns a list of the names of the classes defined in the
domain represented by _modelobj_.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method classes {} {
    return [pipe {
        relvar set Class |
        relation project ~ Name |
        relation list
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test classes-1.0 {
    Get the list of classes
} -body {
    llength [sio classes]
} -result 24
----

=== Class attributes

(((model,method,attributes)))

*****
_modelobj_ attributes _class_

[horizontal]
_class_::
    The name of a class in the domain represented by _modelobj_.

The `attributes` method returns a dictionary of the attributes of _class_.
The keys to the dictionary are the names of the attributes.
The values associated to the keys are the data type of the attribute.
If _class_ does not exist in the domain,
an empty dictionary is returned.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method attributes {class} {
    return [pipe {
        relvar set Attribute |
        relation restrictwith ~ {$Class eq $class} |
        relation dict ~ Name DataType
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test attributes-1.0 {
    Get the Point Threshold attributes
} -body {
    set attrs [sio attributes Point_Threshold]
    return [dict size $attrs]
} -result 4
----

[source,tcl]
----
<<method tests>>=
test attributes-1.1 {
    Get the attributes for non-existent class
} -body {
    set attrs [sio attributes foobar]
    return [dict size $attrs]
} -result 0
----

=== State names

(((model,method,states)))

*****
_modelobj_ states _class_

[horizontal]
_class_::
    The name of a class or assigner in the domain represented by _modelobj_.

The `states` method returns a list of state names for _class_.
If _class_ does not exist in the domain or if class does not have a state model,
an empty list is returned.

A state name of, `@`, indicates the pseudo-initial state
out from which creation events transition.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method states {class} {
    return [pipe {
        relvar set StatePlace |
        relation restrictwith ~ {$Model eq $class} |
        relation project ~ Name |
        relation list
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test states-1.0 {
    Get the states for the Sample_Set class
} -body {
    llength [sio states Sample_Set]
} -result 4
----
[source,tcl]
----
<<method tests>>=
test states-1.1 {
    Get non-existent states
} -body {
    llength [sio states foobar]
} -result 0
----

=== Event names

(((model,method,events)))

*****
_modelobj_ events _class_

[horizontal]
_class_::
    The name of a class or assigner in the domain represented by _modelobj_.

The `events` method returns a list of event names for _class_.
If _class_ does not exist in the domain or if class does not have a state model
or any polymorphic events,
an empty list is returned.
The returned list includes the event names for any type of event that
the class may have.
For example,
a superclass may not have a state model, but could have polymorphic events
and these names would be returned.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method events {class} {
    return [pipe {
        relvar set Event |
        relation restrictwith ~ {$Model eq $class} |
        relation project ~ Event |
        relation list
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test events-1.0 {
    Get the events for the Sample_Set class
} -body {
    llength [sio events Sample_Set]
} -result 4
----
[source,tcl]
----
<<method tests>>=
test events-1.1 {
    Get polymorphic events from a superclass
} -body {
    llength [aggrmgmt events Remote_Sensor]
} -result 3
----

=== State model transitions

(((model,method,transitions)))

*****
_modelobj_ transitions _class_

[horizontal]
_class_::
    The name of a class or assigner in the domain represented by _modelobj_.

The `transitions` method returns a relation value that contains the state
transitions for _class_.
The heading of the returned relation value is:

[width="75%",options="header",cols="6*^",grid="cols"]
|============
|Domain |Model  |State  |Event  |NewState   |Params
h|string h|string h|string h|string h|string     h|Relation
|============

where:

[horizontal]
*Domain*:: is the name of the domain.
*Model*:: is the name of the class or assigner.
*State*:: is the name of a state.
    A _State_ name of, `@`, indicates the pseudo-initial state out of
    which creation events transition.
*Event*:: is the name of an event which causes a transition out of _State_.
*NewState*:: is the name of the state entered by the transition caused
    when _Event_ is received in _State_.
    A _NewState_ name of `IG` indicates the _Event_ is ignored when it
    is received in _State_.
    A _NewState_ name of `CH` indicates it is logically impossible to
    receive _Event_ in _State_ (_i.e._ _can't happen_) and at run time
    will cause a _panic_ condition.
*Params*:: is a relation valued attribute giving the parameters of _Event_
    (and hence the arguments to *NewState*).
    The cardinality of the _Params_ attribute is zero if the event
    carries no supplemental event data.
    The _Params_ attribute has the heading:

[width="35%",options="header",cols="3*^",grid="cols"]
|============
|Name       |Position   |DataType
h|string     h|int        h|string
|============

where:

[horizontal]
*Name*:: is the name of the parameter.
*Position*:: is the order of the parameter carried in _Event_.
    _Position_ values start at zero and sequentially increase for each tuple
    in _Params_.
*DataType*:: is the ``C'' type name for the parameter.

The cardinality of the returned relation is _states_ times _events_ where
_states_
(including the pseudo-initial state for a creation event,
if present in the model)
is the number of states in the model and _events_ is the
number of events.
The cardinality of the returned relation is zero if the class has no
state model.

Each tuple in the returned relation represents a cell in a conceptual
_states_ by _events_ transition matrix with _NewState_ as the cell value.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method transitions {class_name} {
    set params [pipe {
        relvar set Parameter |
        relation join ~ [relvar set Argument] |
        relation eliminate ~ ASigID
    }]
    # log::debug \n[relformat $params params]

    set transitions [pipe {
        my GetTransitionCells |
        relation restrictwith ~ {$Model eq $class_name} |
        relation join ~ [relvar set Event] |
        relation eliminate ~ Number |
        rvajoin ~ $params Params |
        relation eliminate ~ PSigID
    }]
    # log::debug \n[relformat $transitions transitions]

    return $transitions
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test transitions-1.0 {
    Get the transitions for the Sample_Set class
} -body {
    set tm [sio transitions Sample_Set]
    csvToFile [relation eliminate $tm Params] Sample_Set_trans.csv
    return [relation cardinality $tm]
} -result {16}
----

The following table shows the transitions for the Sample_Set class
(minus the event parameters, of which there are none for this class).

[format="csv",options="header,unbreakable"]
|==============================================
include::../test/Sample_Set_trans.csv[]
|==============================================

[source,tcl]
----
<<method tests>>=
test transitions-1.1 {
    Get the transitions for a class with no state model
} -body {
    set tm [sio transitions Point_Threshold]
    relation cardinality $tm
} -result {0}
----

[source,tcl]
----
<<method tests>>=
test transitions-2.0 {
    Get the transitions for the Conduit class
} -body {
    set tm [aggrmgmt transitions Conduit]
    relation cardinality $tm
} -result {66}
----

[source,tcl]
----
<<method tests>>=
test transitions-2.1 {
    Get the transition matrix for the Reporting Sensor class
} -body {
    set tm [aggrmgmt transitions Reporting_Sensor]
    relation cardinality $tm
} -result {90}
----

==== Computing the transition matrix

Computing the transition matrix is the heart of the `transitions` method and
several other methods in this package.
The following method queries the `micca` platform model to determine
the state transitions.
The result produced is the transition matrix for the entire domain.
Each method that uses this computation then adjusts the relation
to suit its needs.

In `micca`,
there is a concept of default transitions.
This can be either `IG` or `CH` and the default transition is used as the
target for a transition which is not otherwise specified explicitly.
The strategy for the queries below is to compute all possible transitions.
Then the transitions which were specified are subtracted from the
possible set.
The difference is then the unspecified transitions which are
given the default transition target.

[source,tcl]
----
<<model class definition>>=
method GetTransitionCells {} {
    set state_places [pipe {
        relvar set StatePlace |
        relation eliminate ~ Number |
        relation rename ~ Name State
    }]
    set possible_trans [pipe {
        relvar set TransitioningEvent |
        relation join $state_places ~
    }]
    # log::debug \n[relformat $possible_trans possible_trans]

    set trans [pipe {
        relvar set StateTransition |
        relation eliminate ~ ASigID
    }]
    set non_trans [pipe {
        relvar set NonStateTransition |
        relation rename ~ TransRule NewState
    }]

    set spec_trans [relation union $trans $non_trans]
    # log::debug \n[relformat $spec_trans spec_trans]

    set defrule [pipe {
        relvar set StateModel |
        relation project ~ Domain Model DefaultTrans |
        relation rename ~ DefaultTrans NewState
    }]
    # log::debug \n[relformat $defrule defrule]

    set non_spec_trans [pipe {
        relation project $spec_trans Domain Model State Event |
        relation minus $possible_trans ~ |
        relation join ~ $defrule |
        relation update ~ ftup {[tuple extract $ftup State] eq "@"}\
            {tuple update $ftup NewState CH}
    }]
    # log::debug \n[relformat $non_spec_trans non_spec_trans]

    set trans_records [relation union $spec_trans $non_spec_trans]
    # log::debug \n[relformat $trans_records trans_records]

    return $trans_records
}
----

=== Recording event dispatch

`Micca` generated domains can be wrapped in an automatically generated
test harness by using the
https://repos.modelrealization.com/cgi-bin/fossil/mrtools/wiki?name=BosalPage[`bosal`]
program.
When the resulting test harness is operated using the
https://repos.modelrealization.com/cgi-bin/fossil/mrtools/wiki?name=MecatePage[`mecate`]
package,
event transitions can be captured.
The methods in this section facilitate counting transitions
and creating summaries of the state and transition coverage.

The following methods create a transition recording session.
The semantics are similar to files, _i.e._ you first start the recording,
then call a method to record each state transition, and finally
you can stop the recording.
At any time after starting a recording,
you may request the event dispatch information.

==== Starting a transition recording session

(((model,method,startTransitionRecording)))

*****
_modelobj_ startTransitionRecording

The `startTransitionRecording` method initializes internal
data structures in preparation for recording event transitions in
the domain represented by _modelobj_.
In particular,
any previous event transition counts are reset back to zero.
Attempting to start an already running session is silently ignored.
The method returns the empty string.
*****

[source,tcl]
----
<<model class definition>>=
method startTransitionRecording {} {
    my variable recording_state
    if {$recording_state eq "on"} {
        return
    }

    if {![relvar exists __Event_Record__]} {                        # <1>
        set trans [pipe {
            my GetTransitionCells |
            relation extend ~ sptup TransCount int 0
        }]
        relvar create __Event_Record__ [relation heading $trans]\
            {Domain Model State Event}
        relvar set __Event_Record__ $trans
    } else {
        relvar update __Event_Record__ ertup true {
            tuple update $ertup TransCount 0
        }
    }

    set recording_state on
    return
}
----
<1> We record the event transition information in a relvar which consists of
the transition matrix cell values and a new column to hold the counts.
First time through, we must create the relvar to hold the counts.
Next time through, we can just zero out the counts.

==== Stopping a transition recording session

(((model,method,stopTransitionRecording)))

*****
_modelobj_ stopTransitionRecording

The `stopTransitionRecording` method closes an ongoing event
transition recording session.
The information gathered during the session is not modified.
Attempting to stop an already stopped session is silently ignored.
The method returns the empty string.
*****

[source,tcl]
----
<<model class definition>>=
method stopTransitionRecording {} {
    my variable recording_state
    set recording_state off

    return
}
----

==== Recording an event transition

(((model,method,recordTransition)))

*****
_modelobj_ recordTransition _class_ _currstate_ _event_

[horizontal]
_class_::
    The name of a class or assigner in the domain represented by _modelobj_.
_currstate_::
    The name of the state in _class_ which is the source state in
    a transition.
_event_::
    The name of an event in _class_ which caused a transition from _currstate_.

The `recordTransition` method counts the transition which
occurred when _class_ was in _currstate_ and received _event_.
It is necessary to start the event transition recording session
by invoking the `startTransitionRecording` method before invoking
this method.
The method returns a boolean value indicating if the counting occurred,
_i.e._ if _currstate_ and _event_ form a valid transition in _class_.
*****

[source,tcl]
----
<<model class definition>>=
method recordTransition {class currstate event} {
    my variable recording_state
    if {$recording_state eq "off"} {
        error "event transition recording is stopped"
    }

    my variable domain_name
    set updated [relvar updateone __Event_Record__ ertup\
            [list Domain $domain_name Model $class State $currstate\
            Event $event] {
        tuple update $ertup TransCount\
                [expr {[tuple extract $ertup TransCount] + 1}]
    }]

    return [relation isnotempty $updated]
}
----

==== Reporting transitions

(((model,method,reportTransitions)))

*****
_modelobj_ reportTransitions _pattern_

[horizontal]
_pattern_::
    A pattern of the format used by the `string match` command for the names of
    classes or assigners in the domain represented by _modelobj_.

The `reportTransitions` method returns a relation value containing
the transition counts for all classes whose names match _pattern_.
The heading of the returned relation value is:

[width="75%",options="header",cols="6*^",grid="cols"]
|============
|Domain |Model  |State  |Event  |NewState   |TransCount
h|string h|string h|string h|string h|string     h|int
|============

where:

[horizontal]
*Domain*:: is the name of the domain.
*Model*:: is the name of the class or assigner.
*State*:: is the name of a state.
    A _State_ name of, `@`, indicates the pseudo-initial state out of
    which creation events transition.
*Event*:: is the name of an event which causes a transition out of _State_.
*NewState*:: The name of the state entered by the transition caused
    when _Event_ is received in _State_.
    A _NewState_ name of `IG` indicates the _Event_ is ignored when it
    is received in _State_.
    A _NewState_ name of `CH` indicates it is logically impossible to
    receive _Event_ in _State_ (_i.e._ _can't happen_) and at run time
    will cause a _panic_ condition.
*TransCount*:: The number of times recorded when *Model* was in a given
    *State* and *Event* was received.
*****

[source,tcl]
----
<<model class definition>>=
method reportTransitions {pattern} {
    return [pipe {
        relvar set __Event_Record__ |
        relation restrictwith ~ {[string match $pattern $Model]}
    }]
}
----

.Recording transitions
============================
Here we show a simple transition session and record three transitions

[source,tcl]
----
<<method tests>>=
test reportTransitions-1.0 {
    report event transitions
} -body {
    sio startTransitionRecording
    sio recordTransition Sample_Set IDLE Start
    sio recordTransition Sample_Set RUNNING Point_ready
    sio recordTransition Sample_Set RUNNING Point_ready
    sio stopTransitionRecording

    set trans [sio reportTransitions Sample_Set]
    ral::csvToFile $trans Sample_Set.csv
    return [relation cardinality $trans]
} -result {16}
----

The following table shows the output of the test case.

[format="csv",options="header,unbreakable"]
|==============================================
include::../test/Sample_Set.csv[]
|==============================================

Examining the *TransCount* column show the three recorded transitions.
============================

.Transitions not ignored or impossible
============================
The relation value returned from `reportTransitions` can be further
processed to yield more refined results.
For example,
if we are only interested in transitions which result in a state change,
_i.e._ are *not* `IG` or `CH`,
we can restrict the output to exclude tuples where *NewState*
is `IG` or `CH`.

[source,tcl]
----
<<method tests>>=
test reportTransitions-1.1 {
    report event dispatch which are not IG or CH
} -body {
    set trans [pipe {
        sio reportTransitions Sample_Set |
        relation restrictwith ~ {$NewState ne "IG" && $NewState ne "CH"}
    }]
    ral::csvToFile $trans Sample_Set_noigch.csv
    return [relation cardinality $trans]
} -result {6}
----

The following table shows the reduced output.

[format="csv",options="header,unbreakable"]
|==============================================
include::../test/Sample_Set_noigch.csv[]
|==============================================
============================

.Transitions not taken
============================
We can further refine the transition information to yield those
transitions which were not taken.
This information can be used to evaluate the effect of test scenarios
in covering the execution of state activities.

[source,tcl]
----
<<method tests>>=
test reportTransitions-1.2 {
    report event dispatch which are not IG or CH
} -body {
    set trans [pipe {
        sio reportTransitions Sample_Set |
        relation restrictwith ~\
            {$NewState ne "IG" && $NewState ne "CH" && $TransCount == 0}
    }]
    ral::csvToFile $trans Sample_Set_missed.csv
    return [relation cardinality $trans]
} -result {4}
----

The following table shows only those transitions in the state model
which were never taken.

[format="csv",options="header,unbreakable"]
|==============================================
include::../test/Sample_Set_missed.csv[]
|==============================================
============================

.Executed state activities
============================
Since the state machines produced by `micca` are
https://en.wikipedia.org/wiki/Moore_machine[Moore]
type machines,
each time the *TransCount* of a transition is non-zero,
we know the activity for the *NewState* was executed.
Additional processing shows how to compute the number of times
a given state activity is executed.

[source,tcl]
----
<<method tests>>=
test reportTransitions-2.0 {
    report state activity execution
} -body {
    set trans [pipe {
        sio reportTransitions Sample_Set |
        relation restrictwith ~ {$NewState ne "IG" && $NewState ne "CH"} |
        relation summarizeby ~ {Domain Model NewState} sa_rel\
                Executed int {rsum($sa_rel, "TransCount")} |
        relation rename ~ NewState State
    }]
    ral::csvToFile $trans Sample_Set_act.csv
    return [relation cardinality $trans]
} -result {4}
----

The following table shows the number times each state activity
was executed.

[format="csv",options="header,unbreakable"]
|==============================================
include::../test/Sample_Set_act.csv[]
|==============================================

Usually in a testing scenario,
we are most interested in those state activities that are _not_ executed
by the test suite,
indicating a potential lack of coverage.
Restricting the above relation to those tuples where *Executed* is zero,
gives that result.
============================

==== Counting transitions with `mecate`

When `bosal` generated test harnesses are operated using the `mecate` package,
`mecate` has the capability of invoking a command each time an event
trace arrives from the test harness.
The following methods serve as _glue_ code between the `mecate` interface and
the `miccautil` transition recording.

(((model,method,startMecateTransitionCount)))

*****
_modelobj_ startMecateTransitionCount _reinobj_

_reinobj_::
    An object command as returned from the `rein` command of
    the `mecate` package.
    A _reinobj_ represents a `bosal` generated test harness and methods
    of the object allow for operations on the test harness.

The `startMecateTransitionCount` method starts capturing event transitions
as they arrive from a `bosal` generated test harness.
This method uses the `traceNotify` method of the _reinobj_ to install
a callback handler for when event traces arrive.

Note this method does *not* turn on event tracing in the test harness.
That is done with the _reinobj_ `trace on` command which must be executed
before any events will be received and counted.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method startMecateTransitionCount {reinobj} {
    my startTransitionRecording

    my variable previous_callback
    set previous_callback [$reinobj traceNotify]
    $reinobj traceNotify [mymethod RecordMecateTransition]
}
----

(((model,method,stopMecateTransitionCount)))

*****
_modelobj_ stopMecateTransitionCount _reinobj_

_reinobj_::
    An object command as returned from the `rein` command of
    the `mecate` package.
    A _reinobj_ represents a `bosal` generated test harness and methods
    of the object allow for operations on the test harness.

The `stopMecateTransitionCount` method stops capturing event transitions
as they arrive from a `bosal` generated test harness.
The previous _reinobj_ callback handler is re-instated.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=

method stopMecateTransitionCount {reinobj} {
    my variable previous_callback
    $reinobj traceNotify $previous_callback

    my stopTransitionRecording
}
----

(((model,method,RecordMecateTransition)))

*****
_modelobj_ RecordMecateTransition _trace_

_trace_::
    A dictionary of the form generated by a `bosal` test harness
    containing an event dispatch trace.
    See the `mecate` man pages for a detailed description of a _trace_
    dictionary contents.

The `RecordMecateTransition` method examines the information in _trace_ and uses it
to count transition of the state machines in _modelobj_.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method RecordMecateTransition {trace} {
    if {[dict get $trace type] eq "transition"} {
        set target_class [lindex [split [dict get $trace target] .] 0] ; # <1>
        my recordTransition $target_class\
            [dict get $trace currstate] [dict get $trace event]
    }

    return
}
export RecordMecateTransition
----
<1> In the trace data,
the _target_ of the event is given in the form: _<class>.<instance>_.
Here we only want the class name part.

.Tests
[source,tcl]
----
<<method tests>>=
test RecordMecateTransition-1.0 {
    record event dispatch using mecate trace data
} -cleanup {
    sio stopTransitionRecording
} -body {
    sio startTransitionRecording

    set trace_info [dict create\
        type transition\
        target Sample_Set.0\
        currstate RUNNING\
        event Point_ready\
    ]
    sio RecordMecateTransition $trace_info

    dict set trace_info currstate RUNNING
    dict set trace_info event Point_ready
    sio RecordMecateTransition $trace_info
    sio RecordMecateTransition $trace_info

    set report [sio reportTransitions Sample_Set]
    return [pipe {
        sio reportTransitions Sample_Set |
        relation summarize ~ $::ralutil::DEE rpt_rel\
                TotalCount int {rsum($rpt_rel, "TransCount")} |
        relation extract ~ TotalCount
    }]
} -result {3}
----

=== Default attribute values

(((model,method,defaultAttributeValues)))

*****
_modelobj_ defaultAttributeValues

The `defaultAttributeValues` returns a relation value giving
the default values that attributes in the domain represented by
_modelobj_ are given if not otherwise specified.

The heading of the returned relation is:

[width="35%",options="header",cols="3*^",grid="cols"]
|============
|Domain         |Class      |Defaults
^h|string     ^h|string   ^h|Relation
|============

where:

[horizontal]
*Domain*:: is the name of the domain.
*Class*:: is the name of a class in *Domain*.
*Defaults*:: is a relation valued attribute containing the attribute names
    and values for *Class*.

The heading of the *Defaults* attribute is:

[width="40%",options="header",cols="3*^",grid="cols"]
|============
|Attribute      |Value      |DataType
h|string        h|string    h|string
|============

where:

[horizontal]
*Attribute*:: is the name of the attribute of the instance.
*Value*:: is the value of the attribute in the instance.
*DataType*:: is the ``C'' type name for the attribute.
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method defaultAttributeValues {} {
    return [pipe {
        relvar set DefaultValue |
        relation join ~ [relvar set Attribute]\
                -using {Domain Domain Class Class Attribute Name} |
        relation group ~ Defaults Attribute Value DataType
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test defaultAttributeValues-1.0 {
    list default attributes
} -body {
    set def_attr [sio defaultAttributeValues]
    log::debug \n[relformat $def_attr]

    return [relation cardinality $def_attr]
} -result {11}
----

=== Initial instance population

(((model,method,initialInstancePopulation)))

*****
_modelobj_ initialInstancePopulation

The `initialInstancePopulation` method returns a relation value
containing the initial instance population of the domain
represented by _modelobj_.
The heading of the returned relation is:

[width="35%",options="header",cols="3*^",grid="cols"]
|============
|Domain         |Class      |Instances
^h|string     ^h|string   ^h|Relation
|============

where:

[horizontal]
*Domain*:: is the name of the domain.
*Class*:: is the name of a class in *Domain*.
*Instances*:: is a relation valued attribute containing the initial
    instances of *Class*.

The heading of the *Instance* attribute is:

[width="35%",options="header",cols="3*^",grid="cols"]
|============
|Instance       |ID         |Attributes
^h|string     ^h|int      ^h|Relation
|============

where:

[horizontal]
*Instance*:: is the name given to the inital instance in the `micca`
    population.
*ID*:: is the numeric identifier of the instance.
    This number is the same as the array index of the instance in the
    storage pool for the class.
*Attributes*:: is a relation valued attribute giving the attribute names and
    values of the initial instance.

The heading of the *Attributes* attribute is:

[width="35%",options="header",cols="2*^",grid="cols"]
|============
|Attribute      |Value
^h|string     ^h|string
|============

where:

[horizontal]
*Attribute*:: is the name of the attribute of the instance.
*Value*:: is the value of the attribute in the instance.
*****

<<<

// Some hairy ascidoc table manipulations

.Example initial instance population tuple
=====================
An example tuple
(_i.e._ one row)
of the initial instance population relation might appear in tabular form as:

[options="header,unbreakable",cols="6*^"]
|============
|Domain         |Class        4+h|Instances
h|string       h|string       4+h|Relation
.12+.^|sio  .12+.^|Signaled_Point h|Instance   h|ID   2+h|Attributes
                              h|string     h|int  2+h|Relation  
                            .2+|         .2+|       h|Attribute      h|Value
                                                    h|string         h|string
                         .4+.^|sigpt1  .4+.^|6       |Trigger         |ed_Active
                                                     |Active_high     |true
                                                     |Settle_interval |100
                                                     |R3              |sigpt1
                     .4+.^|sigpt2  .4+.^|7       |Trigger         |ed_BothActive
                                                     |Active_high     |false
                                                     |Settle_interval |100
                                                     |R3              |sigpt2
|============
=====================

.Implementation
[source,tcl]
----
<<model class definition>>=
method initialInstancePopulation {} {
    return [pipe {
        relvar set PopulatedComponent |
        relation semijoin ~\
            [relvar set ClassComponent]\
            [relvar set ClassComponentValue]\
                -using {Domain Domain Class Class Name Component}\
            [relvar set SpecifiedComponentValue] |
        relation join ~ [relvar set ClassInstance] |
        relation rename ~ Component Attribute Number ID |
        relation group ~ Attributes Attribute Value |
        relation group ~ Instances Instance ID Attributes
    }]
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test initialInstancePopulation-1.0 {
    list initial instance values
} -body {
    set init_inst [sio initialInstancePopulation]

    log::debug \n[relformat $init_inst]

    return [relation cardinality $init_inst]
} -result {22}
----

=== State model as a graph

(((model,method,stateModelGraph)))

*****
_modelobj_ stateModelGraph _class_

[horizontal]
_class_::
    The name of a class or assigner in the domain represented by _modelobj_.

The `stateModelGraph` method returns a _graph_ command from the `struct::graph`
package in Tcllib that represents the state model for _class_ as a graph.
It is the responsibility of the caller to insure that
the returned graph command is disposed of properly by invoking
_graph_ `destroy` when no longer needed.
If _class_ does not not have a state model,
the returned _graph_ has no nodes or arcs.

The returned graph is annotated by the following *key* / value attributes:

[horizontal]
*domain*:: the name of the domain.
*class*:: the name of the class or assigner.
*initialstate*:: the name of the default initial state.
*defaulttrans*:: the name of the default transition, _i.e._ `IG` or `CH`.

Nodes in the graph represent states in the state model and
are named the same as the state name.
Nodes are annotated by the following *key* / value attributes:

[horizontal]
*activity*:: the state activity code.
*final*:: a boolean value indicating if the state is a final state.

Arcs in the graph represent the directed transitions from a source state
to a target state.
Note that `IG` and `CH` transitions are _not_ represented by arcs since
as target states they do not cause an actual transition.
Arcs are annotated by the following *key* / value attributes:

[horizontal]
*event*:: the name of the event causing the transition.
*params*:: a list of event parameter names giving the additional values
    carried by the event.
*****

We need the `struct::graph` package from Tcllib and we want to make sure
that it is at least version 2 or higher.

[source,tcl]
----
<<required packages>>=
package require struct::graph 2
----

.Implementation
[source,tcl]
----
<<model class definition>>=
method stateModelGraph {class_name} {
    my variable domain_name
    set gr [::struct::graph]

    try {
        $gr set domain $domain_name
        $gr set class $class_name

        set smodel [relvar restrictone StateModel\
                Domain $domain_name Model $class_name]
        if {[relation isempty $smodel]} {
            $gr set initialstate {}
            $gr set defaulttrans {}
            return $gr
        }

        $gr set defaulttrans [relation extract $smodel DefaultTrans]

        set cr_state [pipe {
            relvar set CreationState |
            relation semijoin $smodel ~ |
            relation extend ~ cstup\
                    Activity string {{}}\
                    IsFinal boolean {false} |
            relation project ~ Name Activity IsFinal
        }]

        $gr set initialstate [expr {[relation isnotempty $cr_state] ?\
                "@" : [relation extract $smodel InitialState]}]

        set states [pipe {
            relvar set State |
            relation semijoin $smodel ~ |
            relation project ~ Name Activity IsFinal |
            relation union ~ $cr_state
        }]
        # log::debug \n[relformat $states states]

        relation foreach state $states {
            relation assign $state Name Activity IsFinal
            $gr node insert $Name
            $gr node set $Name activity $Activity
            $gr node set $Name final $IsFinal
        }

        set trans [pipe {
            my transitions $class_name |
            relation restrictwith ~ {$NewState ne "IG" && $NewState ne "CH"} |
            relation eliminate ~ Domain Model
        }]

        relation foreach tran $trans {
            relation assign $tran State Event NewState Params
            set arc [$gr arc insert $State $NewState]
            $gr arc set $arc event $Event
            $gr arc set $arc params\
                    [relation list $Params Name -ascending Position]
        }

        return $gr
    } on error {result opts} {
        $gr destroy
        return -options $opts $result
    }
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test stateModelGraph-1.0 {
    Get the state model graph for the Sample_Set class
} -body {
    set sample_set_graph [sio stateModelGraph Sample_Set]
    set nnodes [llength [$sample_set_graph nodes]]
    $sample_set_graph destroy
    return $nnodes
} -result {4}
----

[source,tcl]
----
<<method tests>>=
test stateModelGraph-1.1 {
    State model graph for class with not state model
} -body {
    set pt_graph [sio stateModelGraph Point_Threshold]
    set nnodes [llength [$pt_graph nodes]]
    $pt_graph destroy
    return $nnodes
} -result {0}
----

[source,tcl]
----
<<method tests>>=
test stateModelGraph-2.0 {
    Get the state model graph for the Conduit class
} -body {
    set conduit_graph [aggrmgmt stateModelGraph Conduit]
    set nnodes [llength [$conduit_graph nodes]]
    $conduit_graph destroy
    return $nnodes
} -result {11}
----

[source,tcl]
----
<<method tests>>=
test stateModelGraph-2.1 {
    Check the state model graph for the Conduit class
} -body {
    set conduit_graph [aggrmgmt stateModelGraph Conduit]
    set create_trans [$conduit_graph arcs -out @]
    set cr_event [$conduit_graph arc get $create_trans event]
    $conduit_graph destroy
    return $cr_event
} -result {Connect}
----

=== State model with Tcldot

(((model,method,stateModelDot)))

*****
_modelobj_ stateModelDot _class_

[horizontal]
_class_::
    The name of a class or assigner in the domain represented by _modelobj_.

The `stateModelDot` method returns a
http://graphviz.org/pdf/tcldot.3tcl.pdf[`Tcldot`]
command handle to the state model of _class_.
The command handle can be used to render an image of
the state model graph (along with many other uses).
*****

.Implementation
[source,tcl]
----
<<model class definition>>=
method stateModelDot {class_name} {
    package require Tcldot ;                                        # <1>

    my variable domain_name

    set dot [dotnew digraph]
    try {
        set smodel [relvar restrictone StateModel\
                Domain $domain_name Model $class_name]
        if {[relation isempty $smodel]} {
            return $dot
        }

        $dot setnodeattributes shape box
        $dot setnodeattributes style filled
        $dot setnodeattributes fillcolor yellow

        set cr_state [pipe {
            relvar set CreationState |
            relation semijoin $smodel ~ |
            relation extend ~ cstup IsFinal boolean {false} |
            relation project ~ Name IsFinal
        }]
        set states [pipe {
            relvar set State |
            relation semijoin $smodel ~ |
            relation project ~ Name IsFinal |
            relation union ~ $cr_state
        }]

        set node(@) [$dot addnode @ {*}{
            shape point
            fillcolor black
            label {}
            width 0.15
            fixedsize true
        }]

        set finals [relation restrictwith $states {$IsFinal}]
        if {[relation isnotempty $finals]} {
            set node(__x__) [$dot addnode __x__ {*}{
                shape doublecircle
                fillcolor black
                label {}
                width 0.15
                fixedsize true
            }]
        }

        relation foreach state $states {
            relation assign $state
            if {$Name eq "@"} {
                continue
            }
            set node($Name) [$dot addnode $Name\
                label [string map {_ { }} $Name]\
            ]
            if {$IsFinal} {
                set edge($Name,__x__) [$dot addedge $node($Name) $node(__x__)]
            }
        }

        if {[relation isempty $cr_state]} {
            set initialstate [relation extract $smodel InitialState]
            set edge(@,$initialstate)\
                    [$dot addedge $node(@) $node($initialstate)]
        } ;                                                             # <2>

        set params [pipe {
            relvar set Parameter |
            relation eliminate ~ PSigID
        }]
        set statetrans [pipe {
            relvar set StateTransition |
            relation semijoin $smodel ~ |
            rvajoin ~ $params Params |
            relation eliminate ~ Domain Model ASigID
        }]

        relation foreach statetran $statetrans {
            relation assign $statetran
            set evt_label [string map {_ { }} $Event]
            if {[relation isnotempty $Params]} {
                append evt_label\
                    "("\
                    [join [relation list $Params Name -ascending Position] ,]\
                    ")"
            }
            set edge($State,$NewState) [$dot addedge\
                    $node($State) $node($NewState)\
                    label $evt_label
            ]
        }

        return $dot
    } on error {result opts} {
        rename $dot {}
        return -options $opts $result
    }
}
----
<1> Since `Tcldot` is not a common package,
we do the `package require` here to minimize the dependency upon
`Tcldot`.
Other commands and methods can be used without having to have `Tcldot`
installed.
<2> If there is no creation state,
we connect the pseudo-initial state to the default initial state
with no event label.
This is a convenient indication of the default initial state.

.Tests
[source,tcl]
----
<<method tests>>=
test stateModelDot-1.0 {
    Get the dot graph for the Sample_Set class
} -cleanup {
    chan close $ss_file
    chan close $gv_file
    rename $sample_set_dot {}
} -body {
    set sample_set_dot [sio stateModelDot Sample_Set]

    set ss_file [open Sample_Set.pdf w]
    $sample_set_dot write $ss_file pdf

    set gv_file [open Sample_Set.gv w]
    $sample_set_dot write $gv_file dot

    $sample_set_dot countnodes
} -result {5}
----

The following figure is the rendered state model for the Sample_Set class.

image::Sample_Set.pdf[title="Sample Set state model rendered by dot"]

[source,tcl]
----
<<method tests>>=
test stateModelDot-2.0 {
    Get the dot graph for the Conduit class
} -cleanup {
    chan close $cond_file
    chan close $gv_file
    rename $conduit_dot {}
} -body {
    set conduit_dot [aggrmgmt stateModelDot Conduit]

    set cond_file [open Conduit.pdf w]
    $conduit_dot write $cond_file pdf

    set gv_file [open Conduit.gv w]
    $conduit_dot write $gv_file dot

    $conduit_dot countnodes
} -result {12}
----

The following figure is the rendered state model for the Conduit class.

image::Conduit.pdf[title="Conduit state model rendered by dot"]

As a comparison,
the following figure shows the original layout of the Conduit state model
drawn manually during the analysis effort.
The
https://www.umlet.com/[Umlet]
program was used to draw the state model.

image::Conduit_umlet.pdf[title="Original Conduit state model from Umlet"]

[source,tcl]
----
<<method tests>>=
test stateModelDot-2.1 {
    Get the dot graph for the Discovered Sensor class
} -cleanup {
    chan close $ds_file
    chan close $gv_file
    rename $ds_dot {}
} -body {
    set ds_dot [aggrmgmt stateModelDot Discovered_Sensor]

    set ds_file [open Discovered_Sensor.pdf w]
    $ds_dot write $cond_file pdf

    set gv_file [open Discovered_Sensor.gv w]
    $ds_dot write $gv_file dot

    $ds_dot countnodes
} -result {13}
----

The following figure is the rendered state model for the Discovered_Sensor
class.

image::Discovered_Sensor.pdf[title="Discovered Sensor state model rendered by dot"]

== Functions on state model graphs

In this section,
we show `miccautil` ensemble subcommands which
operate on graphs.
These are convenience commands and are provided as procedures
which take a `struct::graph` command handle.
Invoking the `stateModelGraph` method yields a suitable graph command.

=== Depth first search of a state model graph

(((command,dfs)))

*****
::miccautil dfs _graph_ ?_start_?

[horizontal]
_graph_::
    a graph command as returned from `struct::graph`,
    usually obtained by invoking, _modelobj_ `stateModelGraph` _class_.
_start_::
    the name of node where the search is to start.
    If _start_ is not given,
    then the search starts at node given by the *initialstate*
    attribute of the graph.

The `dfs` subcommand performs a depth first search (DFS) of _graph_.
_graph_ is a command as returned from `struct::graph`,
usually obtained by invoking the `stateModelGraph` method with the
desired class name.
The return value of the command is the empty string.

During the DFS,
each node in the graph is annotated with the following additional attributes:

[horizontal]
*pre*::
    the pre-order number of the node, starting at 1.
    This is the order in which the node was visited during the DFS.
*rpost*::
    the reverse post-order number of the node, starting at 1.
    This is the order the node would be visited in a reverse post-order
    traversal.
    For graphs that do _not_ contain cycles,
    the *rpost* numbers form a topological sort of the graph.
    Graphs which have no *back* edges (see following) have no cycles.

Each edge in the graph is annotated with one additional attribute:

[horizontal]
*type*::
    the classification of the graph edge.
    The *type* attribute has one of the following values:
tree:::
    the edge is part of a spanning tree for the graph,
    _i.e._ the target node is visited for the first time when the
    edge is traversed.
forw:::
    the edge is a forward directed,
    _i.e._ the target node is a decendent of the source node.
back:::
    the edge is a back edge,
    _i.e._ the target node is an ancestor of the source node.
cross:::
    the edge is a cross edge.
    All edges which are not classified as *tree*, *forw,* or *back* are
    classified as cross edges.
*****

[source,tcl]
----
<<package exports>>=
namespace export dfs
----

.Implementation
[source,tcl]
----
<<miccautil commands>>=
proc ::miccautil::dfs {graph {start {}}} {
    if {$start eq {}} {
        set start [$graph get initialstate]
    }

    set nodes [$graph nodes]
    foreach node $nodes {
        $graph node set $node pre 0
        $graph node set $node rpost 0
    }
    variable preorder 1
    variable postorder [llength $nodes]
    ClassifyNode $graph $start
    return
}
----

The classification algorithm is the convention recursive algorithm.
The classification of the graph arcs is accomplished by
examining the pre and post order numbering to determine when the
node under consideration has been seen.

[source,tcl]
----
<<miccautil commands>>=
proc ::miccautil::ClassifyNode {graph node} {
    variable preorder
    set thisPre $preorder
    $graph node set $node pre $thisPre
    incr preorder
    set arcList [$graph arcs -out $node]

    foreach arc $arcList {
        set succ [$graph arc target $arc]
        set succPre [$graph node get $succ pre]
        if {$succPre == 0} {
            $graph arc set $arc type tree
            ClassifyNode $graph $succ
        } elseif {[$graph node get $succ rpost] == 0} {
            $graph arc set $arc type back
        } elseif {$thisPre < $succPre} {
            $graph arc set $arc type frwd
        } else {
            $graph arc set $arc type cross
        }
    }
    variable postorder
    $graph node set $node rpost $postorder
    incr postorder -1

    return
}
----

The following figure shows the `dfs` annotations applied to the
Conduit state model.

image::Conduit_dfs.pdf[title="DFS annotations for Conduit state model"]

.Tests
[source,tcl]
----
<<method tests>>=
test dfs-1.0 {
    DFS on the state model graph for the Conduit class
} -cleanup {
    $conduit_graph destroy
} -body {
    set conduit_graph [aggrmgmt stateModelGraph Conduit]
    miccautil dfs $conduit_graph

    set walkproc [lambda {action graph node} {
        foreach outarc [$graph arcs -out $node] {
            set target [$graph arc target $outarc]
            # log::debug "$node - [$graph arc get $outarc event] -> $target\
                ==> [$graph arc get $outarc type]"
        }
    }]
    $conduit_graph walk [$conduit_graph get initialstate]\
        -order pre -type bfs -dir forward -command $walkproc
} -result {}
----

[source,tcl]
----
<<method tests>>=
test dfs-2.0 {
    DFS on the state model graph for the Sample_Set class
} -cleanup {
    chan close $ss_file
    rename $ss_dot {}
} -body {
    set ss_graph [sio stateModelGraph Sample_Set]
    miccautil dfs $ss_graph

    set ss_dot [miccautil graphToDot $ss_graph type {pre rpost}]
    set ss_file [open Sample_Set_dfs.pdf w]
    $ss_dot write $ss_file pdf
} -result {}
----

image::Sample_Set_dfs.pdf[title="DFS annotations for Sample Set state model"]

=== Spanning tree of a state model

(((command,spanningTree)))

*****
::miccautil spanningTree _graph_ _start_

[horizontal]
_graph_::
    a graph command as returned from `struct::graph`,
    usually obtained by invoking, _modelobj_ stateModelGraph _class_.
_start_::
    the name of node where the DFS for the tree is to start.
    If _start_ is not given,
    then the tree starts at node given by the *initialstate*
    attribute of the graph.

The `spanningTree` subcommand returns a `graph` command handle
as obtained from the `struct::graph` package in Tcllib.
The returned graph contains a spanning tree of the _graph_ argument.
The spanning tree returned is the sub-graph of `graph` where only
*tree* type edges are retained.
The caller is responsible for invoking the `destroy` method on the
returned graph command when it is no longer needed.
It is not necessary to have run the `dfs` command previously on
_graph_ as that will be done by `spanningTree`.
*****

[source,tcl]
----
<<package exports>>=
namespace export spanningTree
----

[source,tcl]
----
<<required packages>>=
package require lambda
----

.Implementation
[source,tcl]
----
<<miccautil commands>>=
proc ::miccautil::spanningTree {graph {start {}}} {
    set span [::struct::graph]
    $span = $graph
    dfs $span $start

    set ffunc [lambda {graph arc} {
        expr {[$graph arc get $arc type] ne "tree"}
    }]
    set non_tree [$span arcs -key type -filter $ffunc]
    $span arc delete {*}$non_tree

    return $span
}
----

The following figure shows the spanning tree of the Conduit state model.

image::Conduit_span.pdf[title="Spanning tree of Conduit state model"]

.Tests
[source,tcl]
----
<<method tests>>=
test spanning-1.0 {
    Spanning tree for the state model graph of the Conduit class
} -cleanup {
    $conduit_graph destroy
    $span_tree destroy
} -body {
    set conduit_graph [aggrmgmt stateModelGraph Conduit]
    miccautil dfs $conduit_graph
    set span_tree [miccautil spanningTree $conduit_graph]

    variable tree_nodes 0

    set walkproc [lambda@ [namespace current] {action graph node} {
        variable tree_nodes
        foreach outarc [$graph arcs -out $node] {
            set node_type [$graph arc get $outarc type]
            if {$node_type eq "tree"} {
                incr tree_nodes
            }
            set target [$graph arc target $outarc]
            # log::debug "$node - [$graph arc get $outarc event] -> $target\
                ==> $node_type"
        }
    }]
    $conduit_graph walk [$conduit_graph get initialstate]\
        -order pre -type bfs -dir forward -command $walkproc

    return $tree_nodes
} -result {10}
----

=== Graphviz view of a graph

(((command,graphToDot)))

*****
::miccautil graphToDot _graph_ ?_edgekeys_? ?_nodekeys_?

[horizontal]
_graph_::
    a graph command as returned from `struct::graph`,
    usually obtained by invoking, _modelobj_ stateModelGraph _class_.
_edgekeys_::
    a list of key names which will be included as the label of an edge.
_nodekeys_::
    a list of key names which will be included in the label of a node.

The `graphToDot` subcommand returns a `Tcldot` command handle which is
the `dot` representation of _graph_.
The edges of the dot drawing are annotated with the values given
by the edge attribute keys contained in the _edgekeys_ list.
Similarly,
the nodes of the dot drawing are annotated with the values given
by the node attribute keys contained in the _nodekeys_ list.
The command handle can be used in the same way as those returned
by the `stateModelDot` method.

Note that invoking `graphToDot` with the return value of
`stateModelGraph` does _not_ yield the same rendering as
the `stateModelDot` method.
The later method insures the rendered state model appears more in line
with usual UML notation.
*****

[source,tcl]
----
<<package exports>>=
namespace export graphToDot
----

(((command,graphToDot)))

.Implementation
[source,tcl]
----
<<miccautil commands>>=
proc ::miccautil::graphToDot {graph {edgekeys {}} {nodekeys {}}} {
    package require Tcldot

    set dot_graph [dotnew digraph]
    $dot_graph setnodeattributes shape box
    $dot_graph setnodeattributes style filled
    $dot_graph setnodeattributes fillcolor yellow

    foreach node [$graph nodes] {
        set dot_node [$dot_graph addnode $node]
        if {$node eq "@"} {
            $dot_node setattributes shape circle
        }
        set label_value $node
        set node_attrs [$graph node keys $node]
        foreach nodekey $nodekeys {
            if {$nodekey in $node_attrs} {
                append label_value "\\n"\
                        $nodekey=[$graph node get $node $nodekey]
            }
        }
        $dot_node setattributes label $label_value
    }

    foreach arc [$graph arcs] {
        set source [$graph arc source $arc]
        set target [$graph arc target $arc]
        set dot_edge [$dot_graph addedge $source $target]
        set label_value {}
        set nl {}
        set edge_attrs [$graph arc keys $arc]
        foreach edgekey $edgekeys {
            if {$edgekey in $edge_attrs} {
                append label_value $nl\
                        ${edgekey}=[$graph arc get $arc $edgekey]
                set nl "\\n"
            }
        }
        $dot_edge setattributes label $label_value
    }

    return $dot_graph
}
----

.Tests
[source,tcl]
----
<<method tests>>=
test graphToDot-1.0 {
    Draw spanning tree for the state model graph of the Conduit class
} -cleanup {
    $conduit_graph destroy
    $span_tree destroy
    chan close $span_file
    chan close $dfs_file
    rename $span_dot {}
    rename $dfs_dot {}
} -body {
    set conduit_graph [aggrmgmt stateModelGraph Conduit]
    miccautil dfs $conduit_graph
    set span_tree [miccautil spanningTree $conduit_graph]

    set span_dot [miccautil graphToDot $span_tree event]

    set span_file [open Conduit_span.pdf w]
    $span_dot write $span_file pdf

    miccautil dfs $conduit_graph
    set dfs_dot [miccautil graphToDot $conduit_graph type {pre rpost}]
    set dfs_file [open Conduit_dfs.pdf w]
    $dfs_dot write $dfs_file pdf
} -result {}
----
